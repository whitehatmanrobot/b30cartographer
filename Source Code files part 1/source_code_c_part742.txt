opid     - Property ID
*   plVal      - Pointer to returned LONG
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI proxyReadPropLong(
   IUnknown                *pIUnknown,
   PROPID                  propid,
   LONG                    *plVal)
{
    IWiaPropertyStorage *pIWiaPropStg;

    if (!pIUnknown) {
        return E_INVALIDARG;
    }

    HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);

    if (FAILED(hr)) {
        return hr;
    }

    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
       *plVal = PropVar[0].lVal;
    }
    else {
       DPRINT("proxyReadPropLong, ReadMultiple failed\n");
    }

    pIWiaPropStg->Release();

    return hr;
}

/**************************************************************************\
* proxyWritePropLong
*
*   Read property long helper.
*
* Arguments:
*
*   pItem  - Pointer to WIA item
*   propid - Property ID
*   lVal  -  LONG value to write
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI proxyWritePropLong(
    IWiaDataTransfer*       pIUnknown,
    PROPID                  propid,
    LONG                    lVal)
{
    IWiaPropertyStorage *pIWiaPropStg;

    if (!pIUnknown) {
        return E_INVALIDARG;
    }

    HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);

    if (FAILED(hr)) {
        DPRINT("proxyWritePropLong, QI for IID_IWiaPropertyStorage failed\n");
        return hr;
    }

    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_I4;
    propvar[0].lVal = lVal;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, 2);
    if (FAILED(hr)) {
        DPRINT("proxyWritePropLong, WriteMultiple failed\n");
    }

    pIWiaPropStg->Release();

    return hr;
}


/**************************************************************************\
* proxyReadPropGuid
*
*   Read property GUID helper.
*
* Arguments:
*
*   pIUnknown  - Pointer to WIA item
*   propid     - Property ID
*   plVal      - Pointer to returned GUID
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI proxyReadPropGuid(
                                 IUnknown                *pIUnknown,
                                 PROPID                  propid,
                                 GUID                    *plVal)
{
    HRESULT hr = E_FAIL;

    IWiaPropertyStorage *pIWiaPropStg = NULL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize;

    if (!pIUnknown) {
        return E_INVALIDARG;
    }

    hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);
    if (FAILED(hr)) {
        DPRINT("proxyReadPropGuid, QI failed\n");
        return hr;
    }

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        *plVal = *(PropVar[0].puuid);
    }
    else {
        DPRINT("proxyReadPropGuid, QI failed\n");
    } 

    pIWiaPropStg->Release();
    
    return hr;
}


//
//  IWiaDataTransfer
//

HRESULT GetRemoteStatus(
    IWiaDataTransfer*   idt,
    BOOL*               pbRemote,
    ULONG*              pulMinBufferSize,
    ULONG*              pulItemSize)
{
    //
    // find out if parent device is remote or local
    //
    // !!! this will be a bit SLOW !!!
    //


    IWiaItem   *pWiaItem = NULL, *pWiaItemRoot = NULL;
    IWiaPropertyStorage *pIWiaPropStg = NULL;
    HRESULT    hr;
    *pbRemote = FALSE;

    hr = idt->QueryInterface(IID_IWiaItem, (void **)&pWiaItem);

    if (hr == S_OK) {


        //
        //  Read the minimum buffer size
        //


        if (pulMinBufferSize != NULL) {
            hr = pWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);
            if (SUCCEEDED(hr)) {

                PROPSPEC        PSpec[2] = {
                    {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
                    {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE}
                };
                PROPVARIANT     PVar[2];

                memset(PVar, 0, sizeof(PVar));

                hr = pIWiaPropStg->ReadMultiple(sizeof(PSpec)/sizeof(PROPSPEC),
                                                PSpec,
                                                PVar);
                if (SUCCEEDED(hr)) {

                    if (hr == S_FALSE) {

                        //
                        //  Property was not found
                        //

                        DPRINT("GetRemoteStatus, properties not found\n");
                        goto Cleanup;
                    }

                    //
                    //  Fill in the minimum buffer size
                    //

                    *pulMinBufferSize = PVar[0].lVal;
                    *pulItemSize = PVar[1].lVal;
                } else {

                    //
                    //  Error reading property
                    //

                    DPRINT("GetRemoteStatus, Error reading MIN_BUFFER_SIZE\n");
                    goto Cleanup;
                }

                FreePropVariantArray(sizeof(PVar)/sizeof(PVar[0]), PVar);

                pIWiaPropStg->Release();
            } else {
                DPRINT("GetRemoteStatus, QI for IID_IWiaPropertyStorage failed\n");
                goto Cleanup;
            }
        }

        hr = pWiaItem->GetRootItem(&pWiaItemRoot);

        if (hr == S_OK) {

            hr = pWiaItemRoot->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);

            if (hr == S_OK) {

                PROPSPEC        PropSpec[2] = {{PRSPEC_PROPID, WIA_DIP_SERVER_NAME},
                                               {PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME}};
                PROPVARIANT     PropVar[2];

                memset(PropVar, 0, sizeof(PropVar));

                hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                          PropSpec,
                                          PropVar);

                if (hr == S_OK) {

                    if (wcscmp(L"local", PropVar[0].bstrVal) != 0) {
                        *pbRemote = TRUE;
                    }
                }

                FreePropVariantArray(sizeof(PropVar)/sizeof(PropVar[0]), PropVar);

            } else {
                DPRINT("QI for IID_WiaPropertyStorage failed");
            }

        }


    }
Cleanup:
    if(pIWiaPropStg) pIWiaPropStg->Release();
    if(pWiaItem) pWiaItem->Release();
    if(pWiaItemRoot) pWiaItemRoot->Release();
    return hr;
}

/*******************************************************************************
*
*  RemoteBandedDataTransfer
*
*  DESCRIPTION:
*    
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT RemoteBandedDataTransfer(
    IWiaDataTransfer __RPC_FAR   *This,
    PWIA_DATA_TRANSFER_INFO      pWiaDataTransInfo,
    IWiaDataCallback             *pIWiaDataCallback,
    ULONG                        ulBufferSize)
{
    HRESULT hr = E_FAIL;
    IWiaItemInternal *pIWiaItemInternal = NULL;
    STGMEDIUM medium = { TYMED_NULL, 0 };
    BYTE *pBuffer = NULL;
    ULONG cbTransferred;
    LONG Message;
    LONG Offset;
    LONG Status;
    LONG PercentComplete;
    LONG ulBytesPerLine;

    hr = proxyReadPropLong(This, WIA_IPA_BYTES_PER_LINE, &ulBytesPerLine);
    if(FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed getting WIA_IPA_BYTES_PER_LINE\n");
        goto Cleanup;
    }

    //
    // Make sure the transfer buffer has integral number of lines
    // (if we know bytes per line)
    //
    if(ulBytesPerLine != 0 && ulBufferSize % ulBytesPerLine)
    {
        ulBufferSize -= ulBufferSize % ulBytesPerLine;
    }

    //
    // Prepare for remote transfer -- allocate buffer and get
    // IWiaItemInternal
    //
    pBuffer = (BYTE *)LocalAlloc(LPTR, ulBufferSize);
    if(pBuffer == NULL) goto Cleanup;
    hr = This->QueryInterface(IID_IWiaItemInternal, (void **) &pIWiaItemInternal);
    if(FAILED(hr)) {
        DPRINT("IWiaItemInternal QI failed\n");
        goto Cleanup;
    }

    //
    // Start transfer on the server side
    //
    hr = pIWiaItemInternal->idtStartRemoteDataTransfer(&medium);
    if(FAILED(hr)) {
        DPRINT("RemoteBandedTransfer:idtStartRemoteDataTransfer failed\n");
        goto Cleanup;
    }

    for(;;) {

        //
        // Call the server and pass any results to the client application, handling any transmission errors 
        //

        hr = pIWiaItemInternal->idtRemoteDataTransfer(ulBufferSize, &cbTransferred, pBuffer, &Offset, &Message, &Status, &PercentComplete);
        if(FAILED(hr)) {
            DPRINT("pIWiaItemInternal->idtRemoteDataTransfer() failed\n");
            break;
        }

        hr = pIWiaDataCallback->BandedDataCallback(Message, Status, PercentComplete, Offset, cbTransferred, 0, cbTransferred, pBuffer);
        if(FAILED(hr)) {
            DPRINT("pWiaDataCallback->BandedDataCallback() failed\n");
            break;
        }

        if(hr == S_FALSE) {
            DPRINT("pWiaDataCallback->BandedDataCallback() returned FALSE, cancelling\n");
            pIWiaItemInternal->idtCancelRemoteDataTransfer();

            while(Message != IT_MSG_TERMINATION) {
                if(FAILED(pIWiaItemInternal->idtRemoteDataTransfer(ulBufferSize, &cbTransferred,
                    pBuffer, &Offset, &Message, &Status, &PercentComplete)))
                {
                    DPRINT("pIWiaItemInternal->idtRemoteDataTransfer() failed\n");
                    break;
                }
            }
            break;
        }
        
        //
        // This we are garanteed to get at the end of the transfer
        //
        if(Message == IT_MSG_TERMINATION)
            break;
    }

    //
    // Give server a chance to stop the transfer and free any resources
    //
    if(FAILED(pIWiaItemInternal->idtStopRemoteDataTransfer())) {
        DPRINT("pIWiaItemInternal->idtStopRemoteDataTransfer() failed\n");
    }

Cleanup:
    if(pIWiaItemInternal) pIWiaItemInternal->Release();
    if(pBuffer) LocalFree(pBuffer);
    return hr;
}

/*******************************************************************************
*
*  IWiaDataTransfer_idtGetBandedData_Proxy
*
*  DESCRIPTION:
*    Data transfer using shared memory buffer when possible.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT __stdcall IWiaDataTransfer_idtGetBandedData_Proxy(
    IWiaDataTransfer __RPC_FAR   *This,
    PWIA_DATA_TRANSFER_INFO       pWiaDataTransInfo,
    IWiaDataCallback             *pIWiaDataCallback)
{                  
    HRESULT        hr = S_OK;
    HANDLE         hTransferBuffer;
    PBYTE          pTransferBuffer = NULL;
    BOOL           bAppSection;
    ULONG          ulNumBuffers;
    ULONG          ulMinBufferSize;
    ULONG          ulItemSize;

    //
    //  Do parameter validation
    //

    if(!pIWiaDataCallback) {
        return E_INVALIDARG;
    }

    if (!pWiaDataTransInfo) {
        DPRINT("IWiaDataTransfer_idtGetBandedData_Proxy, Can't determine remote status\n");
        return hr;
    }

    //
    // The size specified by the client must match the proxy's version
    //

    if (pWiaDataTransInfo->ulSize != sizeof(WIA_DATA_TRANSFER_INFO)) {
        return (E_INVALIDARG);
    }

    //
    // The reserved parameters must be ZERO
    //

    if ((pWiaDataTransInfo->ulReserved1) ||
        (pWiaDataTransInfo->ulReserved2) ||
        (pWiaDataTransInfo->ulReserved3)) {
        return (E_INVALIDARG);
    }

    //
    // determine if this is a local or remote case
    //

    BOOL bRemote;

    hr = GetRemoteStatus(This, &bRemote, &ulMinBufferSize, &ulItemSize);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetBandedData_Proxy, Can't determine remote status\n");
        return hr;
    }

    if (pWiaDataTransInfo->ulBufferSize < ulMinBufferSize) {
        pWiaDataTransInfo->ulBufferSize = ulMinBufferSize;
    }

    if (pWiaDataTransInfo->bDoubleBuffer) {
        ulNumBuffers = 2;
    } else {
        ulNumBuffers = 1;
    }

    pWiaDataTransInfo->ulReserved3 = ulNumBuffers;

    hr = RemoteBandedDataTransfer(This, pWiaDataTransInfo, pIWiaDataCallback, ulMinBufferSize);


    return hr;
}

/*******************************************************************************
*
*  IWiaDataTransfer_idtGetBandedData_Stub
*
*  DESCRIPTION:
*    User Stub for the call_as idtGetBandedDataEx
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT __stdcall IWiaDataTransfer_idtGetBandedData_Stub(
    IWiaDataTransfer __RPC_FAR   *This,
    PWIA_DATA_TRANSFER_INFO       pWiaDataTransInfo,
    IWiaDataCallback             *pIWiaDataCallback)
{
    return (This->idtGetBandedData(pWiaDataTransInfo,
                                   pIWiaDataCallback));
}

/**************************************************************************\
* IWiaDataCallback_BandedDataCallback_Proxy
*
*   server callback proxy, just a pass-through
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/6/1999 Original Version
*
\**************************************************************************/

HRESULT IWiaDataCallback_BandedDataCallback_Proxy(
        IWiaDataCallback __RPC_FAR   *This,
        LONG                         lMessage,
        LONG                         lStatus,
        LONG                         lPercentComplete,
        LONG                         lOffset,
        LONG                         lLength,
        LONG                         lReserved,
        LONG                         lResLength,
        BYTE                        *pbBuffer)
{

    HRESULT hr = IWiaDataCallback_RemoteBandedDataCallback_Proxy(This,
                                                                 lMessage,
                                                                 lStatus,
                                                                 lPercentComplete,
                                                                 lOffset,
                                                                 lLength,
                                                                 lReserved,
                                                                 lResLength,
                                                                 pbBuffer);
    return hr;
}


/**************************************************************************\
* IWiaDataCallback_BandedDataCallback_Stub
*
*   Obsolete: Hide from the client (receiver of this call) the fact that the buffer
*   they see might be the shared memory window or it might be a standard
*   marshaled buffer (remote case)
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/6/1999 Original Version
*
\**************************************************************************/

HRESULT IWiaDataCallback_BandedDataCallback_Stub(
        IWiaDataCallback __RPC_FAR   *This,
        LONG                          lMessage,
        LONG                          lStatus,
        LONG                          lPercentComplete,
        LONG                          lOffset,
        LONG                          lLength,
        LONG                          lReserved,
        LONG                          lResLength,
        BYTE                         *pbBuffer)
{

    //
    // 64bit fix.  XP client code:
    //  
    // //
    // // pass transfer buffer back to client in pbBuffer
    // //
    // //
    // if (pbBuffer == NULL) {
    // 
    //     //  NOTE:  Possible problem here!!!!!!
    //     //  The caller had to cast a pointer (possibly 64bit) as ULONG (32bit)
    //     //  to fit into ulReserved field
    // 
    //     //  TO FIX: Use the IWiaItemInternal interface to get transfer info
    // 
    //     pbBuffer = (BYTE *)ULongToPtr(lReserved);
    // }
    //
    //
    // This should no longer be needed, since the we now use
    // normal COM marhsalling, and no shared memory buffer.
    // The shared memory window could not work on 64bit
    // because a 32bit field was being used to store a
    // 64bit pointer on Win64.
    //

    HRESULT hr = This->BandedDataCallback(lMessage,
                                          lStatus,
                                          lPercentComplete,
                                          lOffset,
                                          lLength,
                                          lReserved,
                                          lResLength,
                                          pbBuffer);
    return hr;
}

HRESULT FileDataTransfer(IWiaDataTransfer __RPC_FAR *This,
                         LPSTGMEDIUM pMedium,
                         IWiaDataCallback *pIWiaDataCallback,
                         ULONG tymed,
                         ULONG ulminBufferSize,
                         ULONG ulItemSize)
{
    HRESULT hr = S_OK;
    TCHAR   tszFileNameBuffer[MAX_PATH] = { 0 };
    BOOL    bWeAllocatedString = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    IWiaItemInternal *pIWiaItemInternal = NULL;
    BYTE *pTransferBuffer = NULL;
    ULONG ulTransferBufferSize = 0x8000; // 32K transfer buffer
    ULONG cbTransferred;
    LONG Message;
    LONG Offset;
    LONG Status;
    LONG PercentComplete;
    BOOL bKeepFile = FALSE;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pAcl = NULL, pNewAcl = NULL;
    PSID pLocalService = NULL;
    BOOL bAdjustedSecurity = FALSE;


    pTransferBuffer = (BYTE *)LocalAlloc(LPTR, ulTransferBufferSize);
    if(pTransferBuffer == NULL) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed to allocate transfer buffer\n");
        goto Cleanup;
    }

    //
    //  Check whether a filename has been specified.  If not, generate a tempory one.
    //  NOTE:  We do this on the CLIENT-SIDE so we get the client's temp path.
    //

    if (!pMedium->lpszFileName) {

        DWORD dwRet = GetTempPath(MAX_PATH, tszFileNameBuffer);
        if ((dwRet == 0) || (dwRet > MAX_PATH)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("GetTempPath failed");
            goto Cleanup;
        }

        if (!GetTempFileName(tszFileNameBuffer,
                             TEXT("WIA"),
                             0,
                             tszFileNameBuffer))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("GetTempFileName failed");
            goto Cleanup;
        }
    } else {
        //
        //  Copy the filename into tszFileNameBuffer.  This will be used if we
        //  have to delete the file when the transfer fails.
        //

#ifndef UNICODE

        //
        //  Convert from UNICODE to ANSI
        //

        if (!WideCharToMultiByte(CP_ACP, 0, pMedium->lpszFileName, -1, tszFileNameBuffer, MAX_PATH, NULL, NULL)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("WideCharToMultiByte failed");
            goto Cleanup;
        }
#else
        lstrcpynW(tszFileNameBuffer, pMedium->lpszFileName, MAX_PATH);
#endif
    }

    //
    //  Try to create the file here, so we don't waste time by allocating memory
    //  for the filename if it fails.
    //  NOTE:  We create the file here on the client-side.  We can close the file straight 
    //  away, but we want to have it created with client's credentials.  It will simply be 
    //  opened on the server-side.
    //

    hFile = CreateFile(tszFileNameBuffer,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_WRITE,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS | SECURITY_SQOS_PRESENT,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {                
        hr = HRESULT_FROM_WIN32(::GetLastError());
        DPRINT("Failed to create file");
        goto Cleanup;
    } else {

        //
        //  Check that this is a file
        //
        if (GetFileType(hFile) != FILE_TYPE_DISK)
        {
            hr = E_INVALIDARG;
            DPRINT("WIA will only transfer to files of type FILE_TYPE_DISK.");
            goto Cleanup;
        }
        
        //
        //  close file handle, adjust security
        //

        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        EXPLICIT_ACCESS ea = { 0 };
        DWORD dwResult;

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        dwResult = GetNamedSecurityInfo(
            tszFileNameBuffer, 
            SE_FILE_OBJECT,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            &pAcl,
            NULL,
            &pSD);

        if(dwResult == ERROR_SUCCESS && pAcl != NULL) {
            if(AllocateAndInitializeSid(&SIDAuthNT, 1, 
                SECURITY_LOCAL_SERVICE_RID,
                0,
                0, 0, 0, 0, 0, 0,
                &pLocalService) && pLocalService) 
            {
                ea.grfAccessPermissions = FILE_ALL_ACCESS;
                ea.grfAccessMode = SET_ACCESS;
                ea.grfInheritance = NO_INHERITANCE;
                ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
                ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
                ea.Trustee.ptstrName = (LPTSTR) pLocalService;

                dwResult = SetEntriesInAcl(1, &ea, pAcl, &pNewAcl);

                if(dwResult == ERROR_SUCCESS && pNewAcl != NULL) 
                {
                    dwResult = SetNamedSecurityInfo(tszFileNameBuffer, 
                        SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, 
                        NULL, NULL, pNewAcl, NULL);

                    if(dwResult == ERROR_SUCCESS) {
                        bAdjustedSecurity = TRUE;
                    } else {
                        DPRINT("Failure to update file DACL");
                    }
                } else {
                        DPRINT("Failure to set ACE in the file DACL");
                }
            } else {
                DPRINT("Failure to allocate and LocalService SID");
            }
        } else {
            DPRINT("Failure to retrieve file security information");
        }
    }

    if (!pMedium->lpszFileName) {
        //
        //  Assign the file name to pMedium
        //

        DWORD length = lstrlen(tszFileNameBuffer) + 1;
        pMedium->lpszFileName = (LPOLESTR)CoTaskMemAlloc(length * sizeof(WCHAR));
        if (!pMedium->lpszFileName) {
            hr = E_OUTOFMEMORY;
            DPRINT("Failed to allocate temp file name");
            goto Cleanup;
        }
        
        bWeAllocatedString = TRUE;

#ifndef UNICODE

        //
        //  Do conversion from ANSI to UNICODE
        //

        if (!MultiByteToWideChar(CP_ACP, 0, tszFileNameBuffer, -1, pMedium->lpszFileName, length)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            goto Cleanup;
        }
#else
        lstrcpyW(pMedium->lpszFileName, tszFileNameBuffer);
#endif  
    }


    //
    //  We unconditionally set the STGMEDIUM's tymed to TYMED_FILE.  This is because
    //  COM wont marshall the filename if it's is TYMED_MULTIPAGE_FILE, since
    //  it doesn't recognize it.  This is OK, since the service doesn't use
    //  pMedium->tymed. 
    //
    pMedium->tymed = TYMED_FILE;

    //
    //  Finally, we're ready to do the transfer
    //

    hr = This->QueryInterface(IID_IWiaItemInternal, (void **) &pIWiaItemInternal);
    if(FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed to obtain IWiaItemInternal\n");
        goto Cleanup;
    }
    
    //
    // Start transfer on the server side
    //
    hr = pIWiaItemInternal->idtStartRemoteDataTransfer(pMedium);
    if(FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer idtStartRemoteDataTransfer() failed\n");
        goto Cleanup;
    }

    for(;;) {

        //
        // Call the server and pass any results to the client application, handling any transmission errors 
        //

        hr = pIWiaItemInternal->idtRemoteDataTransfer(ulTransferBufferSize,
            &cbTransferred, pTransferBuffer, &Offset, &Message, &Status,
            &PercentComplete);
        
        if(FAILED(hr)) {
            //
            // special case: multipage file transfer that resulted in
            // paper handling error 
            //
            if(tymed == TYMED_MULTIPAGE_FILE &&
               (hr == WIA_ERROR_PAPER_JAM || hr == WIA_ERROR_PAPER_EMPTY || hr == WIA_ERROR_PAPER_PROBLEM))
            {
                // make note not to delete file and store hr so we can
                // return it to the app
                bKeepFile = TRUE;
            }
            DPRINT("IWiaDataCallback_RemoteFileTransfer idtRemoteDataTransfer() failed\n");
            break;
        }

        //
        // If there is app-provided callback, call it
        //
        if(pIWiaDataCallback) {
            hr = pIWiaDataCallback->BandedDataCallback(Message,
                Status, PercentComplete, Offset, cbTransferred,
                0, cbTransferred, pTransferBuffer);
            if(FAILED(hr)) {
                DPRINT("pWiaDataCallback->BandedDataCallback() failed\n");
                break;
            }
            if(hr == S_FALSE) {
                DPRINT("pWiaDataCallback->BandedDataCallback() returned FALSE, cancelling\n");
                pIWiaItemInternal->idtCancelRemoteDataTransfer();
                while(Message != IT_MSG_TERMINATION) {
                    if(FAILED(pIWiaItemInternal->idtRemoteDataTransfer(ulTransferBufferSize,
                        &cbTransferred, pTransferBuffer, &Offset, &Message, &Status,
                        &PercentComplete)))
                    {
                        DPRINT("pIWiaItemInternal->idtRemoteDataTransfer() failed\n");
                        break;
                    }
                }
                break;
            }
        }

        //
        // This we are garanteed to get at the end of the transfer
        //
        if(Message == IT_MSG_TERMINATION)
            break;
    }

    //
    // Give server a chance to stop the transfer and free any resources
    //
    if(FAILED(pIWiaItemInternal->idtStopRemoteDataTransfer())) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer idtStopDataTransfer() failed\n");
    }


Cleanup:
    if(pIWiaItemInternal) pIWiaItemInternal->Release();

    if (hFile && (hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    //
    //  Remove the temporary file if the transfer failed, and we must free the filename string if we 
    //  allocated.
    //  NOTE: We only delete the file if we were the ones that generated the name i.e. it's a temporary
    //        file.
    //

    if (FAILED(hr) && bWeAllocatedString)
    {
            // special case: multipage file transfers that
            // resulted in paper jam or empty feeder or other paper
            // problem
        if(!bKeepFile) {
            DeleteFile(tszFileNameBuffer);
        }
        
        CoTaskMemFree(pMedium->lpszFileName);
        pMedium->lpszFileName = NULL;
    }

    if(bAdjustedSecurity) {
        SetNamedSecurityInfo(tszFileNameBuffer, SE_FILE_OBJECT,
            DACL_SECURITY_INFORMATION, NULL, NULL, pAcl, NULL);
    }

    if(pSD) LocalFree(pSD);
    if(pNewAcl) LocalFree(pNewAcl);
    if(pLocalService) LocalFree(pLocalService);
    if(pTransferBuffer) LocalFree(pTransferBuffer);
    
    return hr;
}

/*******************************************************************************
* IWiaDataCallback_idtGetData_Proxy
*
*  DESCRIPTION:
*   Allocates a shared memory buffer for image transfer.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT IWiaDataTransfer_idtGetData_Proxy(
    IWiaDataTransfer __RPC_FAR   *This,
    LPSTGMEDIUM                   pMedium,
    IWiaDataCallback             *pIWiaDataCallback)
{
    HRESULT  hr = S_OK;
    LONG     tymed;
    ULONG    ulminBufferSize = 0;
    ULONG    ulItemSize = 0;
    
    BOOL     bRemote;

    //
    // !!!perf: should do all server stuf with 1 call
    //  this includes QIs, get root item, read props
    //

    hr = proxyReadPropLong(This, WIA_IPA_TYMED, &tymed);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetData_Proxy, failed to read WIA_IPA_TYMED\n");
        return hr;
    }

    //
    // find out if the transfer is remote
    //

    hr = GetRemoteStatus(This, &bRemote, &ulminBufferSize, &ulItemSize);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetData_Proxy, Can't determine remote status\n");
        return hr;
    }

    if (tymed != TYMED_FILE && tymed != TYMED_MULTIPAGE_FILE) {
        //
        // remote callback data transfer
        //
        if(pIWiaDataCallback) 
        {
            hr = RemoteBandedDataTransfer(This,
                                          NULL,
                                          pIWiaDataCallback,
                                          ulminBufferSize);
        }
        else
        {
            hr = E_INVALIDARG;
        }
            
    } else {

        hr = FileDataTransfer(This,
                              pMedium,
                              pIWiaDataCallback,
                              tymed,
                              ulminBufferSize,
                              ulItemSize);
    }

    return hr;
}

/*******************************************************************************
* IWiaDataCallback_idtGetData_Stub
*
*  DESCRIPTION:
*   Allocates a shared memory buffer for image transfer.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT IWiaDataTransfer_idtGetData_Stub(
    IWiaDataTransfer __RPC_FAR   *This,
    LPSTGMEDIUM                   pMedium,
    IWiaDataCallback             *pIWiaDataCallback)
{
    return (This->idtGetData(pMedium, pIWiaDataCallback));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\eventprxy.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       EventPrxy.Cpp
*
*  VERSION:     1.0
*
*  DATE:        3 April, 2002
*
*  DESCRIPTION:
*   Implements client-side hooks for WIA event notification support.
*
*******************************************************************************/

#include <windows.h>
#include <wia.h>
//
//  Global object needed to receive WIA run-time events
//
#include "stirpc.h"
#include "coredbg.h"
#include "simlist.h"
#include "lock.h"
#include "EventRegistrationInfo.h"
#include "WiaEventInfo.h"
#include "ClientEventRegistrationInfo.h"
#include "ClientEventTransport.h"
#include "AsyncRPCEventTransport.h"
#include "RegistrationCookie.h"
#include "WiaEventReceiver.h"
#include "stilib.h"

//
//  This is the quickest, safest way to instantiate our global Event Receiver object.
//  Instantiating it this way ensures proper cleanup on the server when this object is destroyed
//  when the App exists normally.
//
WiaEventReceiver g_WiaEventReceiver(new AsyncRPCEventTransport());

//remove
extern void Trace(LPCSTR fmt, ...);


/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackInterface_Proxy
*
*  DESCRIPTION:
*   Proxy code to catch runtime event registrations.  Since the service runs under
*   LocalService account, it will not have required access to callback into the
*   application (in most cases).  Therefore, we catch this here and establish 
*   our own notification channel to the server.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::RegisterEventCallbackInterface()
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackInterface_Proxy(
    IWiaDevMgr __RPC_FAR            *This,
    LONG                            lFlags,
    BSTR                            bstrDeviceID,
    const GUID                      *pEventGUID,
    IWiaEventCallback               *pIWiaEventCallback,
    IUnknown                        **pEventObject)
{
    ClientEventRegistrationInfo     *pClientEventRegistrationInfo   = NULL;
    RegistrationCookie              *pRegistrationCookie            = NULL;
    HRESULT                         hr                              = S_OK;

    //
    //  Do parameter validation
    //
    if (!pEventGUID)
    {
        hr = E_INVALIDARG;
        DBG_ERR(("Client called IWiaDevMgr_RegisterEventCallbackInterface with NULL pEventGUID"));
    }
    if (!pIWiaEventCallback)
    {
        hr = E_INVALIDARG;
        DBG_ERR(("Client called IWiaDevMgr_RegisterEventCallbackInterface with NULL pIWiaEventCallback"));
    }
    if (!pEventObject)
    {
        hr = E_INVALIDARG;
        DBG_ERR(("Client called IWiaDevMgr_RegisterEventCallbackInterface with NULL pEventObject"));
    }

    //
    //  Initialize the OUT parameters
    //
    *pEventObject = NULL;

    if (SUCCEEDED(hr))
    {
        //
        //  We need to send the registration to the service to deal with
        //  as appropriate.  
        //  Notice that we need to hand back an IUnknown event object.  This is
        //  considered to be the server's event registration cookie.  Releasing the
        //  cookie unregisters the client for this registration.
        //  We create this cookie later on, if we can successfully send the
        //  registration to the service.
        //
        pClientEventRegistrationInfo = new ClientEventRegistrationInfo(lFlags, 
                                                                       *pEventGUID, 
                                                                       bstrDeviceID,
                                                                       pIWiaEventCallback);
        if (pClientEventRegistrationInfo)
        {
            //
            //  Send the registration info.
            //
            hr = g_WiaEventReceiver.SendRegisterUnregisterInfo(pClientEventRegistrationInfo);
            if (SUCCEEDED(hr))
            {
                //
                //  Create the event registration cookie.  We only create the cookie after successfully
                //  registering with the server, because the cookie object holds an automatic ref count
                //  on the client's pIWiaEventCallback interface.  There's no reason to do this
                //  if registration was not successful.
                //
                pRegistrationCookie = new RegistrationCookie(&g_WiaEventReceiver, pClientEventRegistrationInfo);
                if (pRegistrationCookie)
                {
                    //
                    //  Set the [out] Event object to be our cookie
                    //
                    *pEventObject = pRegistrationCookie;
                }
                else
                {
                    DBG_ERR(("Could not register client for runtime event.  We appear to be out of memory"));
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                DBG_ERR(("Could not successfully send runtime event information from client to WIA Service"));
            }
            pClientEventRegistrationInfo->Release();
            pClientEventRegistrationInfo = NULL;
        }
        else
        {
            DBG_ERR(("Could not register client for runtime event - we appear to be out of memory"));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackInterface_Stub
*
*   Never called.
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackInterface_Stub(
    IWiaDevMgr __RPC_FAR            *This,
    LONG                            lFlags,
    BSTR                            bstrDeviceID,
    const GUID                      *pEventGUID,
    IWiaEventCallback               *pIWiaEventCallback,
    IUnknown                        **pEventObject)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\getimage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       GetImage.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        6 Apr, 1998
*
*  DESCRIPTION:
*   Implements top level GetImageDlg API for the ImageIn device manager.
*   These methods execute only on the client side.
*
*******************************************************************************/
#include <windows.h>
#include <wia.h>
#include <wiadevdp.h>

/*******************************************************************************
*
*  IWiaDevMgr_GetImageDlg_Proxy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_GetImageDlg_Proxy(
    IWiaDevMgr __RPC_FAR  *This,
    HWND                  hwndParent,
    LONG                  lDeviceType,
    LONG                  lFlags,
    LONG                  lIntent,
    IWiaItem              *pItemRoot,
    BSTR                  bstrFilename,
    GUID                  *pguidFormat)
{
    IWiaGetImageDlg *pWiaGetImageDlg = NULL;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaGetImageDlg, (void**)&pWiaGetImageDlg );
    if (SUCCEEDED(hr) && pWiaGetImageDlg)
    {
        hr = pWiaGetImageDlg->GetImageDlg( This, hwndParent, lDeviceType, lFlags, lIntent, pItemRoot, bstrFilename, pguidFormat );
        pWiaGetImageDlg->Release();
    }
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_GetImageDlg_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_GetImageDlg_Stub(
    IWiaDevMgr __RPC_FAR  *This,
    HWND                  hwndParent,
    LONG                  lDeviceType,
    LONG                  lFlags,
    LONG                  lIntent,
    IWiaItem              *pItemRoot,
    BSTR                  bstrFilename,
    GUID                  *pguidFormat)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\devdlg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevDlg.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        3 Apr, 1998
*
*  DESCRIPTION:
*   Implements device dialog UI for WIA devices. These methods execute
*   only on the client side.
*
*******************************************************************************/

#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include "wia.h"
#include "sti.h"
#include "wiadevd.h"
#include <initguid.h>
#include "wiadevdp.h"

HRESULT GetDeviceExtensionClassID( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, IID &iidClassID )
{
    HRESULT hr = E_FAIL;
    
    //
    // Make sure all of the parameters are valid
    //
    if (pwszUiClassId && pszCategory && lstrlenW(pwszUiClassId) && lstrlen(pszCategory))
    {
        //
        // Construct the key name
        //
        TCHAR szRootKeyName[1024] = {0};
        _sntprintf( szRootKeyName, (sizeof(szRootKeyName)/sizeof(szRootKeyName[0])) - 1, TEXT("CLSID\\%ws\\shellex\\%s"), pwszUiClassId, pszCategory );
        
        //
        // open the reg key
        //
        HKEY hKeyRoot = NULL;
        DWORD dwResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, szRootKeyName, 0, KEY_READ, &hKeyRoot );
        if (ERROR_SUCCESS == dwResult)
        {
            //
            // Get the buffer size
            //
            TCHAR szClassID[MAX_PATH] = {0};
            DWORD dwLength = sizeof(szClassID)/sizeof(szClassID[0]);
            
            //
            // Note that we only take the first registry key
            //
            dwResult = RegEnumKeyEx( hKeyRoot, 0, szClassID, &dwLength, NULL, NULL, NULL, NULL );
            if (ERROR_SUCCESS == dwResult)
            {
                //
                // Convert the registry string to a CLSID
                //
#if defined(UNICODE)
                hr = CLSIDFromString( szClassID, &iidClassID );
#else
                WCHAR wszClassID[MAX_PATH] = {0};
                MultiByteToWideChar( CP_ACP, 0, szClassID, -1, wszClassID, MAX_PATH );
                hr = CLSIDFromString( wszClassID, &iidClassID );
#endif
            }
            else hr = HRESULT_FROM_WIN32(dwResult);

            //
            // Close the registry key
            //
            RegCloseKey(hKeyRoot);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CreateDeviceExtension( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
{
    IID iidClassID = {0};
    HRESULT hr = GetDeviceExtensionClassID( pwszUiClassId, pszCategory, iidClassID );
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance( iidClassID, NULL, CLSCTX_INPROC_SERVER, iid, ppvObject );
    }
    return hr;
}

HRESULT GetUiGuidFromWiaItem( IWiaItem *pWiaItem, LPWSTR pwszGuid, size_t nMaxLen )
{
    HRESULT hr;
    if (pWiaItem && pwszGuid)
    {
        IWiaPropertyStorage *pWiaPropertyStorage = NULL;
        hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void**)&pWiaPropertyStorage );
        if (SUCCEEDED(hr))
        {
            PROPSPEC ps[1];
            PROPVARIANT  pv[1];
            ps[0].ulKind = PRSPEC_PROPID;
            ps[0].propid = WIA_DIP_UI_CLSID;
            hr = pWiaPropertyStorage->ReadMultiple(sizeof(ps)/sizeof(ps[0]), ps, pv );
            if (SUCCEEDED(hr))
            {
                if (VT_LPWSTR == pv[0].vt || VT_BSTR == pv[0].vt)
                {
                    lstrcpynW( pwszGuid, pv[0].bstrVal, nMaxLen );
                    hr = S_OK;
                }
                FreePropVariantArray( sizeof(pv)/sizeof(pv[0]), pv );
            }
            pWiaPropertyStorage->Release();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT GetDeviceExtensionClassID( IWiaItem *pWiaItem, LPCTSTR pszCategory, IID &iidClassID )
{
    WCHAR wszGuid[MAX_PATH] = {0};
    HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid,sizeof(wszGuid)/sizeof(wszGuid[0]));
    if (SUCCEEDED(hr))
    {
        hr = GetDeviceExtensionClassID( wszGuid, pszCategory, iidClassID );
    }
    return hr;
}

HRESULT CreateDeviceExtension( IWiaItem *pWiaItem, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
{
    WCHAR wszGuid[MAX_PATH] = {0};
    HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid,sizeof(wszGuid)/sizeof(wszGuid[0]));
    if (SUCCEEDED(hr))
    {
        hr = CreateDeviceExtension( wszGuid, pszCategory, iid, ppvObject );
    }
    return hr;
}

/*******************************************************************************
*
*  InvokeVendorDeviceDlg
*
*  DESCRIPTION:
*   Helper function which displays the system-supplied device dlg
*
*  PARAMETERS:
*
*******************************************************************************/
static HRESULT InvokeSystemDeviceDlg(
    IWiaItem __RPC_FAR *This,
    DEVICEDIALOGDATA &DeviceDialogData )
{
    IWiaUIExtension *pIWiaUIExtension = NULL;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaUIExtension, (void**)(&pIWiaUIExtension) );
    if (SUCCEEDED(hr))
    {
        //
        // The following call will return E_NOTIMPL if it is a device type
        // we don't handle in the system UI
        //
        hr = pIWiaUIExtension->DeviceDialog(&DeviceDialogData);
        pIWiaUIExtension->Release();
    }
    return hr;
}


/*******************************************************************************
*
*  InvokeVendorDeviceDlg
*
*  DESCRIPTION:
*   Helper function which displays the IHV-supplied device dlg
*
*  PARAMETERS:
*
*******************************************************************************/
static HRESULT InvokeVendorDeviceDlg(
    IWiaItem __RPC_FAR *This,
    DEVICEDIALOGDATA &DeviceDialogData )
{
    IWiaUIExtension *pIWiaUIExtension = NULL;
    HRESULT hr = CreateDeviceExtension( This, SHELLEX_WIAUIEXTENSION_NAME, IID_IWiaUIExtension, (void**)(&pIWiaUIExtension) );
    if (SUCCEEDED(hr))
    {
        //
        // The following call will return E_NOTIMPL if the IHV has
        // not implemented a custom UI
        //
        hr = pIWiaUIExtension->DeviceDialog(&DeviceDialogData);
        pIWiaUIExtension->Release();
    }
    else
    {
        //
        // We want to override this return value, so we can
        // handle it by showing the system UI as a fallback.
        // Basically, we are going to assume a failure to create
        // the extension means that the extension doesn't exist.
        // We don't do that for the system UI, because if it can't
        // load, that is considered a catastrophic failure.
        //
        hr = E_NOTIMPL;
    }
    return hr;
}


/*******************************************************************************
*
*  IWiaItem_DeviceDlg_Proxy
*
*  DESCRIPTION:
*   Display device data acquistion UI.
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaItem_DeviceDlg_Proxy(
    IWiaItem __RPC_FAR      *This,
    HWND                    hwndParent,
    LONG                    lFlags,
    LONG                    lIntent,
    LONG                    *plItemCount,
    IWiaItem                ***ppIWiaItems)
{
    HRESULT hr = E_FAIL;

    //
    // Make sure we have valid pointer arguments
    //
    if (!plItemCount || !ppIWiaItems)
    {
        return E_POINTER;
    }

    //
    // Initialize the OUT arguments
    //
    *plItemCount = 0;
    *ppIWiaItems = NULL;

    //
    // Verify that this is a root item.
    //
    LONG lItemType = 0;
    hr = This->GetItemType(&lItemType);
    if ((FAILED(hr)) || !(lItemType & WiaItemTypeRoot))
    {
        return E_INVALIDARG;
    }


    //
    // Prepare the struct we will be passing to the function
    //
    DEVICEDIALOGDATA DeviceDialogData = {0};
    DeviceDialogData.cbSize         = sizeof(DeviceDialogData);
    DeviceDialogData.hwndParent     = hwndParent;
    DeviceDialogData.pIWiaItemRoot  = This;
    DeviceDialogData.dwFlags        = lFlags;
    DeviceDialogData.lIntent        = lIntent;
    DeviceDialogData.ppWiaItems     = *ppIWiaItems;

    //
    // If the client wants to use the system UI, the order we try to do it in is:
    // System UI --> IHV UI
    // Otherwise, we do:
    // IHV UI --> System UI
    //
    if (0 == (lFlags & WIA_DEVICE_DIALOG_USE_COMMON_UI))
    {
        hr = InvokeVendorDeviceDlg( This, DeviceDialogData );
        if (E_NOTIMPL == hr)
        {
            hr = InvokeSystemDeviceDlg( This, DeviceDialogData );
        }
    }
    else
    {
        hr = InvokeSystemDeviceDlg( This, DeviceDialogData );
        if (E_NOTIMPL == hr)
        {
            hr = InvokeVendorDeviceDlg( This, DeviceDialogData );
        }
    }

    //
    // It should return S_OK for success, but who knows?
    //
    if (SUCCEEDED(hr) && hr != S_FALSE)
    {
        *ppIWiaItems = DeviceDialogData.ppWiaItems;
        *plItemCount = DeviceDialogData.lItemCount;
    }
    return(hr);
}

/*******************************************************************************
*
*  IWiaItem_DeviceDlg_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaItem_DeviceDlg_Stub(
    IWiaItem  __RPC_FAR    *This,
    HWND                    hwndParent,
    LONG                    lFlags,
    LONG                    lIntent,
    LONG                    *plItemCount,
    IWiaItem                ***pIWiaItems)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\regsvr.c ===
/*****************************************************************************
 *
 *  RegSvr.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      StillImage server OLE self-registration.
 *
 *  Contents:
 *
 *      DllRegisterServer()
 *      DllUnregisterServer()
 *
 *****************************************************************************/

#include "pch.h"

VOID
DmPrxyDllRegisterServer(
    void
    );

VOID
DmPrxyDllUnregisterServer(
    void
    );


/*****************************************************************************
 *
 *      RegSetStringEx
 *
 *      Add a REG_SZ to hkey\sub::value.
 *
 *****************************************************************************/

void INTERNAL
RegSetStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                             (PV)ptszData, cbCtch(lstrlen(ptszData)+1));
}

/*****************************************************************************
 *
 *      RegDelStringEx
 *
 *      Remove a REG_SZ from hkey\sub::value.  The data is ignored.
 *      It's passed so that RegDelStringEx matches the prototype for a
 *      REGSTRINGACTION.
 *
 *****************************************************************************/

void INTERNAL
RegDelStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegDeleteValue(hk, ptszValue);
}

/*****************************************************************************
 *
 *      RegCloseFinish
 *
 *      Just close the subkey already.
 *
 *****************************************************************************/

void INTERNAL
RegCloseFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc = RegCloseKey(hkSub);
}

/*****************************************************************************
 *
 *      RegDelFinish
 *
 *      Delete a key if there is nothing in it.
 *
 *      OLE unregistration rules demand that you not delete a key if OLE
 *      has added something to it.
 *
 *****************************************************************************/

void INTERNAL
RegDelFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc;
    DWORD cKeys = 0, cValues = 0;
    RegQueryInfoKey(hkSub, 0, 0, 0, &cKeys, 0, 0, &cValues, 0, 0, 0, 0);
    RegCloseKey(hkSub);
    if ((cKeys | cValues) == 0) {
        lRc = RegDeleteKey(hk, ptszSub);
    } else {
        lRc = 0;
    }
}

/*****************************************************************************
 *
 *      REGVTBL
 *
 *      Functions for dorking with a registry key, either coming or going.
 *
 *****************************************************************************/

typedef struct REGVTBL {
    /* How to create/open a key */
    LONG (INTERNAL *KeyAction)(HKEY hk, LPCTSTR ptszSub, PHKEY phkOut);

    /* How to create/delete a string */
    void (INTERNAL *StringAction)(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData);

    /* How to finish using a key */
    void (INTERNAL *KeyFinish)(HKEY hk, LPCTSTR ptszSub, HKEY hkSub);

} REGVTBL, *PREGVTBL;
typedef const REGVTBL *PCREGVTBL;

const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish };

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllServerAction |
 *
 *          Register or unregister our objects with OLE/COM/ActiveX/
 *          whatever its name is.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern const TCHAR c_tszNil[];

#define ctchClsid       ctchGuid

const TCHAR c_tszClsidGuid[] =
TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

const TCHAR c_tszInProcServer32[] = TEXT("InProcServer32");
const TCHAR c_tszThreadingModel[] = TEXT("ThreadingModel");
const TCHAR c_tszBoth[] = TEXT("Both");

#pragma END_CONST_DATA

void INTERNAL
DllServerAction(PCREGVTBL pvtbl)
{
    TCHAR tszThisDll[MAX_PATH];
    UINT iclsidmap;

    GetModuleFileName(g_hInst, tszThisDll, cA(tszThisDll));

    for (iclsidmap = 0; iclsidmap < cclsidmap; iclsidmap++) {
        TCHAR tszClsid[7+ctchClsid];
        HKEY hkClsid;
        HKEY hkSub;
        REFCLSID rclsid = c_rgclsidmap[iclsidmap].rclsid;

        wsprintf(tszClsid, c_tszClsidGuid,
                 rclsid->Data1, rclsid->Data2, rclsid->Data3,
                 rclsid->Data4[0], rclsid->Data4[1],
                 rclsid->Data4[2], rclsid->Data4[3],
                 rclsid->Data4[4], rclsid->Data4[5],
                 rclsid->Data4[6], rclsid->Data4[7]);

        if (pvtbl->KeyAction(HKEY_CLASSES_ROOT, tszClsid, &hkClsid) == 0) {
            TCHAR tszName[127];

            /* Do the type name */
            LoadString(g_hInst, c_rgclsidmap[iclsidmap].ids,
                       tszName, cA(tszName));
            pvtbl->StringAction(hkClsid, 0, tszName);

            /* Do the in-proc server name and threading model */
            if (pvtbl->KeyAction(hkClsid, c_tszInProcServer32, &hkSub) == 0) {
                pvtbl->StringAction(hkSub, 0, tszThisDll);
                pvtbl->StringAction(hkSub, c_tszThreadingModel, c_tszBoth);
                pvtbl->KeyFinish(hkClsid, c_tszInProcServer32, hkSub);
            }

            pvtbl->KeyFinish(HKEY_CLASSES_ROOT, tszClsid, hkClsid);

        }
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRegisterServer |
 *
 *          Register our classes with OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllRegisterServer(void)
{
    DmPrxyDllRegisterServer();

    //DllServerAction(&c_vtblAdd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllUnregisterServer |
 *
 *          Unregister our classes from OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllUnregisterServer(void)
{
    DmPrxyDllUnregisterServer();

    //DllServerAction(&c_vtblDel);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\stirpc_client.c ===
#include "pch.h"
#include "stirpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     sti.lib    - client side lib for STI clients.
#     sti.dll    - proxy/stub code for STI and WIA.
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=sti
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK

PASS1_PUBLISH= \
    {$(O)\sti.lib=$(SDK_LIB_PATH)\sti.lib}

DLLDEF=..\sti.def
#DLLENTRY=DllMain
DLLENTRY=_DllMainCRTStartup
COFFBASE=usermode

IDL_RULES =1
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES=$(INCLUDES);..\..\rpc;..\..\rpc\$(O);..\.;.\;

C_DEFINES=$(C_DEFINES) -D_WIN32_DCOM -DREGISTER_PROXY_DLL -DENTRY_PREFIX=DmPrxy

SOURCES= \
     ..\stimsg.mc       \
     ..\sti.rc          \
     ..\bind.c          \
     ..\classf.c        \
     ..\regsvr.c        \
     ..\sti.c           \
     ..\util.c          \
     ..\stirpc_client.c

SOURCES= $(SOURCES) \
        ..\wiaenum.cpp      \
        ..\select.cpp       \
        ..\getimage.cpp     \
        ..\italloc.cpp      \
        ..\wia_proxy.c      \
        ..\devdlg.cpp       \
        ..\eventprxy.cpp    \
        ..\wia_dlldata.c    \
        ..\wiapriv_proxy.c  \

TARGETLIBS= $(TARGETLIBS) \
          $(SDK_LIB_PATH)\wiaguid.lib	\
          $(WIA_LIB_PATH)\stirt.lib     \
	  $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(O)\psutil.lib
#
# Note:  The precompiled header is C not C++!
#
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\select.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       Select.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        11 Feb, 1998
*
*  DESCRIPTION:
*   Implements device selection UI of the WIA device manager.
*   These methods execute only on the client side.
*
*******************************************************************************/

#include <windows.h>
#include <wia.h>
#include <waitcurs.h>
#include "wiadevdp.h"


/*******************************************************************************
*
*  CallSelectDeviceDlg
*
*  DESCRIPTION:
*   Wrapper for dynamically loaded select device dll procedure
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall CallSelectDeviceDlg(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID,
    IWiaItem                **ppWiaItemRoot)
{
    IWiaGetImageDlg *pWiaGetImageDlg = NULL;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaGetImageDlg, (void**)&pWiaGetImageDlg );
    if (SUCCEEDED(hr) && pWiaGetImageDlg)
    {
        hr = pWiaGetImageDlg->SelectDeviceDlg( hwndParent, NULL, lDeviceType, lFlags, pbstrDeviceID, ppWiaItemRoot );
        pWiaGetImageDlg->Release();
    }
    return hr;
}

/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlg_Proxy
*
*  DESCRIPTION:
*   Present UI to select then create an WIA device.
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_SelectDeviceDlg_Proxy(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID,
    IWiaItem                **ppWiaItemRoot)
{
    CWaitCursor         wc;                  // Put up a wait cursor.

    if (!ppWiaItemRoot)
    {
        return E_POINTER;
    }
    *ppWiaItemRoot = NULL;

    if (pbstrDeviceID)
    {
        *pbstrDeviceID = 0;
    }
    return CallSelectDeviceDlg( This, hwndParent, lDeviceType, lFlags, pbstrDeviceID, ppWiaItemRoot );
}

/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlg_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_SelectDeviceDlg_Stub(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID,
    IWiaItem                **ppWiaItemRoot)
{
    return S_OK;
}


/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlgID_Proxy
*
*  DESCRIPTION:
*   Present UI to select and return the device ID
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_SelectDeviceDlgID_Proxy(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID )
{
    CWaitCursor         wc;                  // Put up a wait cursor.

    if (!pbstrDeviceID)
    {
        return E_POINTER;
    }

    *pbstrDeviceID = 0;

    return CallSelectDeviceDlg( This, hwndParent, lDeviceType, lFlags, pbstrDeviceID, NULL );
}

/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlgID_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_SelectDeviceDlgID_Stub(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstr )
{
    return S_OK;
}


/*******************************************************************************
*
*  IWiaDevMgr_CreateDevice_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::CreateDevice()
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_CreateDevice_Proxy(
    IWiaDevMgr __RPC_FAR *This,
    BSTR                 bstrDeviceID,
    IWiaItem             **ppWiaItemRoot)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaDevMgr_LocalCreateDevice_Proxy(This,
                                                bstrDeviceID,
                                                ppWiaItemRoot);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_CreateDevice_Stub
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_CreateDevice_Stub(
    IWiaDevMgr __RPC_FAR *This,
    BSTR                 bstrDeviceID,
    IWiaItem             **ppWiaItemRoot)
{
    return This->CreateDevice(bstrDeviceID, ppWiaItemRoot);
}


/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackProgram_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.  This is so we
*   can impersonate client todo security check on server side.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::RegisterEventCallbackProgram()
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackProgram_Proxy(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,
    BSTR                 bstrDeviceID,
    const GUID           *pEventGUID,
    BSTR                 bstrCommandline,
    BSTR                 bstrName,
    BSTR                 bstrDescription,
    BSTR                 bstrIcon)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaDevMgr_LocalRegisterEventCallbackProgram_Proxy(This,
                                                                lFlags,         
                                                                bstrDeviceID,   
                                                                pEventGUID,    
                                                                bstrCommandline,
                                                                bstrName,       
                                                                bstrDescription,
                                                                bstrIcon);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackProgram_Stub
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackProgram_Stub(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,
    BSTR                 bstrDeviceID,
    const GUID           *pEventGUID,
    BSTR                 bstrCommandline,
    BSTR                 bstrName,
    BSTR                 bstrDescription,
    BSTR                 bstrIcon)
{
    return This->RegisterEventCallbackProgram(lFlags,         
                                              bstrDeviceID,   
                                              pEventGUID,    
                                              bstrCommandline,
                                              bstrName,       
                                              bstrDescription,
                                              bstrIcon);
}

/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackCLSID_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.  This is so we
*   can impersonate client todo security check on server side.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::RegisterEventCallbackCLSID()
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackCLSID_Proxy(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,          
    BSTR                 bstrDeviceID,    
    const GUID           *pEventGUID,     
    const GUID           *pClsID,         
    BSTR                 bstrName,        
    BSTR                 bstrDescription, 
    BSTR                 bstrIcon)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaDevMgr_LocalRegisterEventCallbackCLSID_Proxy(This,
                                                              lFlags,
                                                              bstrDeviceID,
                                                              pEventGUID,
                                                              pClsID,
                                                              bstrName,
                                                              bstrDescription,
                                                              bstrIcon);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_LocalRegisterEventCallbackCLSID_Stub
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackCLSID_Stub(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,          
    BSTR                 bstrDeviceID,    
    const GUID           *pEventGUID,     
    const GUID           *pClsID,         
    BSTR                 bstrName,        
    BSTR                 bstrDescription, 
    BSTR                 bstrIcon)
{
    return This->RegisterEventCallbackCLSID(lFlags,
                                            bstrDeviceID,
                                            pEventGUID,
                                            pClsID,
                                            bstrName,
                                            bstrDescription,
                                            bstrIcon);
}

/*******************************************************************************
*
*  IWiaPropertyStorage_WriteMultiple_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.  This is so we
*   can impersonate client todo security check on server side.
*
*  PARAMETERS:
*   Same as  IWiaPropertyStorage::WriteMultiple()
*
*******************************************************************************/
HRESULT IWiaPropertyStorage_WriteMultiple_Proxy(
    IWiaPropertyStorage __RPC_FAR *This,
    ULONG                         cpspec,
    const PROPSPEC                rgpspec[],
    const PROPVARIANT             rgpropvar[],
    PROPID                        propidNameFirst)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaPropertyStorage_RemoteWriteMultiple_Proxy(This,
                                                           cpspec,
                                                           rgpspec,
                                                           rgpropvar,
                                                           propidNameFirst);
    }

    if(pcs) pcs->Release();
    return hr;
}

/*******************************************************************************
*
*  IWiaPropertyStorage_WriteMultiple_Stub
*
*******************************************************************************/
HRESULT IWiaPropertyStorage_WriteMultiple_Stub(
    IWiaPropertyStorage __RPC_FAR *This,
    ULONG                         cpspec,
    const PROPSPEC                rgpspec[],
    const PROPVARIANT             rgpropvar[],
    PROPID                        propidNameFirst)
{
    return This->WriteMultiple(cpspec,
                               rgpspec,
                               rgpropvar,
                               propidNameFirst);
}

/*******************************************************************************
*
*  IWiaPropertyStorage_SetPropertyStream_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.  This is so we
*   can impersonate client todo security check on server side.
*
*  PARAMETERS:
*   Same as  IWiaPropertyStorage::SetPropertyStream()
*
*******************************************************************************/
HRESULT IWiaPropertyStorage_SetPropertyStream_Proxy(
    IWiaPropertyStorage __RPC_FAR *This,
    GUID                          *pCompatibilityId,
    IStream                       *pIStream)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaPropertyStorage_RemoteSetPropertyStream_Proxy(This,                
                                                               pCompatibilityId,    
                                                               pIStream);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaPropertyStorage_SetPropertyStream_Stub
*
*******************************************************************************/
HRESULT IWiaPropertyStorage_SetPropertyStream_Stub(
    IWiaPropertyStorage __RPC_FAR *This,
    GUID                   *pCompatibilityId,
    IStream                *pIStream)
{
    return This->SetPropertyStream(pCompatibilityId,
                                   pIStream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\sti.c ===
/*****************************************************************************
 *
 *  Sti.c
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1998  All Rights Reserved.
 *
 *  Abstract:
 *
 *    DLL Initialization/termination routines and global
 *    exported functions
 *
 *  Contents:
 *
 *      StiCreateInstance() - exported function to create top level instance
 *
 *****************************************************************************/


#define INITGUID
#include "pch.h"

//
// Externs found in STIRT
//
extern DWORD            g_cRef;
extern CRITICAL_SECTION g_crstDll;
extern CHAR             szProcessCommandLine[MAX_PATH];

#ifdef DEBUG
extern int         g_cCrit;
#endif

extern VOID RegSTIforWiaHelper(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
extern VOID MigrateSTIAppsHelper(HWND hWnd, HINSTANCE hInst, PTSTR pszCommandLine, INT iParam);

#include <rpcproxy.h>
#define DbgFl DbgFlSti


BOOL APIENTRY
DmPrxyDllMain(
    HINSTANCE hinst,
    DWORD dwReason,
    LPVOID lpReserved
    );


STDAPI
DmPrxyDllGetClassObject(
    REFCLSID rclsid,
    RIID riid,
    PPV ppvObj
    );

STDMETHODIMP
DmPrxyDllCanUnloadNow(
    void
    );

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.
 *
 *****************************************************************************/

void EXTERNAL
DllEnterCrit(void)
{
    EnterCriticalSection(&g_crstDll);
#ifdef DEBUG

    // Save thread ID , taking critical section first , it becomes owner
    if (++g_cCrit == 0) {
        g_thidCrit = GetCurrentThreadId();
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit(void)
{
#ifdef DEBUG
    AssertF(g_thidCrit == GetCurrentThreadId());
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0) {
        g_thidCrit = 0;
    }
#endif
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

CLSIDMAP c_rgclsidmap[cclsidmap] = {
    {   &CLSID_Sti,         CStiObj_New,     IDS_STIOBJ     },
//    {   &CLSID_StiDevice,   CStiDevice_New,  IDS_STIDEVICE  },
};

#pragma END_CONST_DATA

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    UINT iclsidmap;
    EnterProcR(DllGetClassObject, (_ "G", rclsid));

    //
    // Bump global ref count temporarily. By doing so we minimize chances of
    // faulting on potential race condition when another thread just called
    // DllCanUnloadNow while  we are inside ClassFactory.
    //
    DllAddRef();
    for (iclsidmap = 0; iclsidmap < cA(c_rgclsidmap); iclsidmap++) {
        if (IsEqualIID(rclsid, c_rgclsidmap[iclsidmap].rclsid)) {
            hres = CSti_Factory_New(c_rgclsidmap[iclsidmap].pfnCreate,
                                  riid, ppvObj);
            goto done;
        }
    }
    DebugOutPtszV(DbgFlDll | DbgFlError, TEXT("%s: Wrong CLSID"),"");
    *ppvObj = 0;
    hres = CLASS_E_CLASSNOTAVAILABLE;

done:;

    //
    // If unsucessful - try DM Proxy
    //
    if (!SUCCEEDED(hres)) {
        hres = DmPrxyDllGetClassObject(rclsid, riid, ppvObj);
    }

    ExitOleProcPpv(ppvObj);
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;

    //
    // First ask DM proxy and it says OK - check out ref count
    //
    hres = DmPrxyDllCanUnloadNow();
    if (hres == S_OK) {
        #ifdef DEBUG
        DebugOutPtszV(DbgFlDll, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
        Common_DumpObjects();
        #endif
        hres = g_cRef ? S_FALSE : S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllEntryPoint |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

BOOL APIENTRY
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    //RPC_STATUS  RpcStatus;
    DWORD       dwLocalSTIServerVer = 0;
    UINT        uiCmdLineLength;

    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

        g_hInst = hinst;

        __try {
            // Disable thread library calls to avoid
            // deadlock when we spin up the worker thread

            DisableThreadLibraryCalls(hinst);
            if(!InitializeCriticalSectionAndSpinCount(&g_crstDll, MINLONG)) {
                // refuse to load if we can't initialize critsect
                return FALSE;
            }

            // Set global flags
            g_NoUnicodePlatform = !OSUtil_IsPlatformUnicode();

            //
            // Save command line for use in GetLaunchInformation
            //
            uiCmdLineLength = min(lstrlenA(GetCommandLineA()),sizeof(szProcessCommandLine)-1);
            lstrcpyn(szProcessCommandLine,GetCommandLineA(),uiCmdLineLength);
            szProcessCommandLine[uiCmdLineLength] = '\0';

            #ifdef DEBUG
            // Debugging flags
            InitializeDebuggingSupport();
            #endif

            //
            // Initialize file logging
            //
        
            g_hStiFileLog = CreateStiFileLog(TEXT("STICLI"),NULL,
                                             STI_TRACE_ERROR |
                                             STI_TRACE_ADD_THREAD | STI_TRACE_ADD_PROCESS
                                            );

            #if CHECK_LOCAL_SERVER
            // Check version of the local server
            RpcStatus = RpcStiApiGetVersion(NULL,
                                           0,
                                           &dwLocalSTIServerVer);

            DebugOutPtszV(DbgFlDll, TEXT("STIINIT : Getting server version : RpcStatus = %d LocalServerVer=%d"),
                          RpcStatus,dwLocalSTIServerVer);
            #endif
            
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:
        if (g_cRef) {
            DebugOutPtszV(DbgFl,"Unloaded before all objects Release()d! Crash soon!\r\n");
        }

        // Close file logging
        CloseStiFileLog(g_hStiFileLog);

        //
        // Don't forget to delete our critical section. (It is safe to
        // do this because we definitely tried to initialize it and so
        // it should be in a sane state)
        //
        
        DeleteCriticalSection(&g_crstDll);
        
        break;
    }
    return 1;
}

BOOL APIENTRY
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    // First call proxy dll main
    DmPrxyDllMain(hinst, dwReason, lpReserved);

    return DllEntryPoint(hinst, dwReason, lpReserved);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | StiCreateInstance |
 *
 *          <bnew>This function creates a new Sti object
 *          which supports the <i ISti> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpSti>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the Sti object.
 *
 *          Sti uses this value to determine whether the
 *          application or DLL has been certified.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the sti.h header file that was used.
 *          This value must be <c STI_VERSION>.
 *
 *          Sti uses this value to determine what version of
 *          Sti the application or DLL was designed for.
 *
 *  @parm   OUT LPSti * | lplpSti |
 *          Points to where to return
 *          the pointer to the <i ISti> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *          Note that if aggregation is requested, the object returned
 *          in *<p lplpSti> will be a pointer to an
 *          <i IUnknown> rather than an <i ISti>, as required
 *          by OLE aggregation.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lplpSti> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c STIERR_STIERR_OLDStiVERSION>: The application
 *          requires a newer version of Sti.
 *
 *          <c STIERR_STIERR_BETAStiVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of Sti.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_Sti, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_ISti, <p lplpSti>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_Sti, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpSti>).
 *          The aggregated object must be initialized manually.
 *
 *****************************************************************************/

STDMETHODIMP
StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, PSTI *ppSti, PUNK punkOuter)
{
    HRESULT hres;
    EnterProc(StiCreateInstance, (_ "xxx", hinst, dwVer, punkOuter));

    hres = StiCreateHelper(hinst, dwVer, (PPV)ppSti, punkOuter,&IID_IStillImageW);

    ExitOleProcPpv(ppSti);
    return hres;
}

STDMETHODIMP
StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, PSTIA *ppSti, PUNK punkOuter)
{
    HRESULT hres;
    EnterProc(StiCreateInstance, (_ "xxx", hinst, dwVer, punkOuter));

    hres = StiCreateHelper(hinst, dwVer, (PPV)ppSti, punkOuter,&IID_IStillImageA);

    ExitOleProcPpv(ppSti);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllInitializeCOM |
 *
 *          Initialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/

BOOL
EXTERNAL
DllInitializeCOM(
    void
    )
{
    DllEnterCrit();

    if(!g_COMInitialized) {
#ifdef USE_REAL_OLE32
        if(SUCCEEDED(CoInitializeEx(NULL,
                                    COINIT_MULTITHREADED  |
                                    COINIT_DISABLE_OLE1DDE))
          ) {
            g_COMInitialized = TRUE;
        }
#else
        g_COMInitialized = TRUE;
#endif
    }

    DllLeaveCrit();

    return g_COMInitialized;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllUnInitializeCOM |
 *
 *          UnInitialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/
BOOL EXTERNAL
DllUnInitializeCOM(
    void
    )
{
    DllEnterCrit();

#ifdef USE_REAL_OLE32
    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }
#endif

    DllLeaveCrit();

    return TRUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | RegSTIforWia |
 *
 *          Private server entry point to register STI apps for WIA events
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          VOID
 *
 *****************************************************************************/

VOID
EXTERNAL
RegSTIforWia(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    RegSTIforWiaHelper(hwnd, hinst, lpszCmdLine, nCmdShow);
}

VOID
WINAPI
MigrateRegisteredSTIAppsForWIAEvents(
                                    HWND        hWnd,
                                    HINSTANCE   hInst,
                                    PTSTR       pszCommandLine,
                                    INT         iParam
                                    )
{
    MigrateSTIAppsHelper(hWnd,
                         hInst,
                         pszCommandLine,
                         iParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\util.c ===
/*****************************************************************************
 *
 *  Util.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc helper functions.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "pch.h"

#define DbgFl DbgFlUtil

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | pvFindResource |
 *
 *          Handy wrapper that finds and loads a resource.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   DWORD | id |
 *
 *          Resource identifier.
 *
 *  @parm   LPCTSTR | rt |
 *
 *          Resource type.
 *
 *  @returns
 *
 *          Pointer to resource, or 0.
 *
 *****************************************************************************/

PV EXTERNAL
pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt)
{
    HANDLE hrsrc;
    PV pv = NULL;

    hrsrc = FindResource(hinst, (LPTSTR)ULongToPtr(id), rt);
    if (hrsrc) {
        pv = LoadResource(hinst, hrsrc);
    } else {
        pv = 0;
    }
    return pv;
}

#ifndef UNICODE

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | LoadStringW |
 *
 *          Implementation of LoadStringW for platforms on which Unicode is
 *          not supported.  Does exactly what LoadStringW would've done
 *          if it existed.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   UINT | ids |
 *
 *          String id number.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of UNICODE output buffer.
 *
 *  @returns
 *
 *          Number of characters copied, not including terminating null.
 *
 *  @comm
 *
 *          Since the string is stored in the resource as UNICODE,
 *          we just pull it out ourselves.  If we go through
 *          <f LoadStringA>, we may end up losing characters due
 *          to character set translation.
 *
 *****************************************************************************/

int EXTERNAL
LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch)
{
    PWCHAR pwch;

    AssertF(cwch);
    ScrambleBuf(pwsz, cbCwch(cwch));

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    pwch = pvFindResource(hinst, 1 + ids / 16, RT_STRING);
    if (pwch) {
        /*
         *  Now skip over the strings in the resource until we
         *  hit the one we want.  Each entry is a counted string,
         *  just like Pascal.
         */
        for (ids %= 16; ids; ids--) {
            pwch += *pwch + 1;
        }
        cwch = min(*pwch, cwch - 1);
        memcpy(pwsz, pwch+1, cbCwch(cwch)); /* Copy the goo */
    } else {
        cwch = 0;
    }
    pwsz[cwch] = TEXT('\0');            /* Terminate the string */
    return cwch;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func    Parse command line
 *
 *  @parm    |  |
 *
 *****************************************************************************/
HRESULT
ParseCommandLine(
    LPSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    )
{

    LPSTR       pszT = lpszCmdLine;

    *pargc=0;

    //
    // Get to first parameter in command line.
    //
    while (*pszT && ((*pszT != '-') && (*pszT != '/')) ) {
         pszT++;
    }

    //
    // Parse options from command line
    //
    while (*pszT) {

        // Skip white spaces
        while (*pszT && *pszT <= ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        if ('-' == *pszT || '/' == *pszT) {
            pszT++;
            if (!*pszT)
                break;

            argv[*pargc] = pszT;
            (*pargc)++;
        }

        // Skip till space
        while (*pszT && *pszT > ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        // Got next argument
        *pszT++='\0';
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\wiaenum.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       WiaEnum.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        24 Aug, 1999
*
*  DESCRIPTION:
*   Implements the [local]-to-[call_as] and [call_as]-to-[local] methods for
*   the WIA enumerators.
*
*******************************************************************************/

#include <objbase.h>
#include "wia.h"

/**************************************************************************\
* IEnumWiaItem_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWiaItem.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   ppIWiaItem      -   Array of IWiaItem pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWiaItem_Next_Proxy(
    IEnumWiaItem __RPC_FAR  *This,
    ULONG                   celt,
    IWiaItem                **ppIWiaItem,
    ULONG                   *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWiaItem_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched;

    if (pceltFetched == 0) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWiaItem_RemoteNext_Proxy(This,
                                         celt,
                                         ppIWiaItem,
                                         pceltFetched);
}

/**************************************************************************\
* IEnumWiaItem_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWiaItem.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   ppIWiaItem      -   Array of IWiaItem pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWiaItem_Next_Stub(
    IEnumWiaItem __RPC_FAR  *This,
    ULONG                   celt,
    IWiaItem                **ppIWiaItem,
    ULONG                   *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    hr = This->Next(celt,
                    ppIWiaItem,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}

/**************************************************************************\
* IEnumWIA_DEV_CAPS_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWIA_DEV_CAPS.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_DEV_CAPs.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_CAPS_Next_Proxy(
    IEnumWIA_DEV_CAPS __RPC_FAR     *This,
    ULONG                           celt,
    WIA_DEV_CAP                     *rgelt,
    ULONG                           *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWIA_DEV_CAPS_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched;

    if (pceltFetched == 0) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWIA_DEV_CAPS_RemoteNext_Proxy(This,
                                              celt,
                                              rgelt,
                                              pceltFetched);
}

/**************************************************************************\
* IEnumWIA_DEV_CAPS_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWIA_DEV_CAPS.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_DEV_CAPs.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_CAPS_Next_Stub(
    IEnumWIA_DEV_CAPS __RPC_FAR     *This,
    ULONG                           celt,
    WIA_DEV_CAP                     *rgelt,
    ULONG                           *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    hr = This->Next(celt,
                    rgelt,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}

/**************************************************************************\
* IEnumWIA_DEV_INFO_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWIA_DEV_INFO.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of IWiaPropertyStorage pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_INFO_Next_Proxy(
    IEnumWIA_DEV_INFO __RPC_FAR     *This,
    ULONG                           celt,
    IWiaPropertyStorage             **rgelt,
    ULONG                           *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWIA_DEV_INFO_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched = 0;

    if (pceltFetched == NULL) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWIA_DEV_INFO_RemoteNext_Proxy(This,
                                              celt,
                                              rgelt,
                                              pceltFetched);
}

/**************************************************************************\
* IEnumWIA_DEV_INFO_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWIA_DEV_INFO.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of IWiaPropertyStorage pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_INFO_Next_Stub(
    IEnumWIA_DEV_INFO __RPC_FAR     *This,
    ULONG                           celt,
    IWiaPropertyStorage             **rgelt,
    ULONG                           *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    ULONG   cFetched = 0;

    if (pceltFetched == NULL) {
        pceltFetched = &cFetched;
    }

    hr = This->Next(celt,
                    rgelt,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}

/**************************************************************************\
* IEnumWIA_FORMAT_INFO_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWIA_FORMAT_INFO.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_FORMAT_INFO.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_FORMAT_INFO_Next_Proxy(
    IEnumWIA_FORMAT_INFO __RPC_FAR      *This,
    ULONG                               celt,
    WIA_FORMAT_INFO                     *rgelt,
    ULONG                               *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWIA_FORMAT_INFO_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched;

    if (pceltFetched == 0) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWIA_FORMAT_INFO_RemoteNext_Proxy(This,
                                                 celt,
                                                 rgelt,
                                                 pceltFetched);
}

/**************************************************************************\
* IEnumWIA_FORMAT_INFO_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWIA_FORMAT_INFO.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_FORMAT_INFO.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_FORMAT_INFO_Next_Stub(
    IEnumWIA_FORMAT_INFO __RPC_FAR  *This,
    ULONG                           celt,
    WIA_FORMAT_INFO                 *rgelt,
    ULONG                           *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    hr = This->Next(celt,
                    rgelt,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\wiapriv_proxy.c ===
#include "pch.h"
#include "wiapriv_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\wia_proxy.c ===
#include "pch.h"
#include "wia_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\sti\wia_dlldata.c ===
#include "pch.h"
#include "wia_a.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\globals.cpp ===
/*++


Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    GLOBALS.CPP

Abstract:

    Placeholder for global data definitions and routines to
    initialize/save global information

Author:

    Vlad  Sadovsky  (vlads)     12-20-99

Revision History:



--*/


//
// Headers
//

#define     INITGUID
#define     DEFINE_GLOBAL_VARIABLES

#include    "stiexe.h"
#include    "stiusd.h"

//
// Code section
//

DWORD
InitGlobalConfigFromReg(VOID)
/*++
  Loads the global configuration parameters from registry and performs start-up checks

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;
    DWORD   dwMessageId = 0;

    HKEY    hkey = NULL;

    DWORD   dwMask = 0;

    RegEntry    re(REGSTR_PATH_STICONTROL_A,HKEY_LOCAL_MACHINE);

    re.GetString(REGSTR_VAL_STIWIASVCDLL, g_szWiaServiceDll, sizeof(g_szWiaServiceDll));

    g_fUIPermitted = re.GetNumber(REGSTR_VAL_DEBUG_STIMONUI_A,0);

    return dwError;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\globals.h ===
/*++


Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    GLOBALS.H

Abstract:

    Global defines and data.
    Variables and string , located in global scope are defined here
    and memory for them will be allocated in no more than one source
    module, containing definition of DEFINE_GLOBAL_VARIABLES before
    including this file

Author:

    Vlad  Sadovsky  (vlads)     12-20-98

Revision History:



--*/

#ifndef WINVER
#define WINVER  0x0500      /* version 5.0 */
#else

#endif /* !WINVER */

#pragma once

#include <windows.h>
#include <winuser.h>

#include <sti.h>
#include <stiapi.h>

//
// Global variables are defined in one module, which has definition of
// DEFINE_GLOBAL_VARIABLES before including this  header file.
//

#ifdef DEFINE_GLOBAL_VARIABLES


#undef  ASSIGN
#define ASSIGN(value) =value

#undef EXTERN
#define EXTERN

#else

#define ASSIGN(value)
#if !defined(EXTERN)
#define EXTERN  extern
#endif

#endif


//
// General char values
//

#define     COLON_CHAR          TEXT(':')    // Native syntax delimiter
#define     DOT_CHAR            TEXT('.')
#define     SLASH_CHAR          TEXT('/')
#define     BACKSLASH_CHAR      TEXT('\\')
#define     STAR_CHAR           TEXT('*')

#define     EQUAL_CHAR          TEXT('=')
#define     COMMA_CHAR          TEXT(',')
#define     WHITESPACE_CHAR     TEXT(' ')
#define     DOUBLEQUOTE_CHAR    TEXT('"')
#define     SINGLEQUOTE_CHAR    TEXT('\'')
#define     TAB_CHAR            TEXT('\t')

#define     DEADSPACE(x) (((x)==WHITESPACE_CHAR) || ((x)==DOUBLEQUOTE_CHAR) )
#define     IS_EMPTY_STRING(pch) (!(pch) || !(*(pch)))

//
// Macros
//
#define TEXTCONST(name,text) extern const TCHAR name[] ASSIGN(text)
#define EXT_STRING(name)     extern const TCHAR name[]

//
// Trace strings should not appear in retail builds, thus define following macro
//
#ifdef DEBUG
#define DEBUG_STRING(s) (s)
#else
#define DEBUG_STRING(s) (NULL)
#endif

//
// Various defines
//
//
//
// STI Device specific values
//
#ifdef DEBUG
#define STIMON_AD_DEFAULT_POLL_INTERVAL       10000             // 10s
#else
#define STIMON_AD_DEFAULT_POLL_INTERVAL       1000              // 1s
#endif


#define STIMON_AD_DEFAULT_WAIT_LOCK           100               // 100ms
#define STIMON_AD_DEFAULT_WAIT_LAUNCH         5000              // 5s


//
// External references to  GLOBAL DATA
//

//
// Server process instance
//
EXTERN  HINSTANCE   g_hProcessInstance      ASSIGN(NULL);

//
// Server library instance
//
EXTERN  HINSTANCE   g_hImagingSvcDll        ASSIGN(NULL);

//
// Handle of main window
//
EXTERN  HWND        g_hMainWindow           ASSIGN(NULL);    ;

//
// Default timeout for pollable devices
//
EXTERN  UINT        g_uiDefaultPollTimeout  ASSIGN(STIMON_AD_DEFAULT_POLL_INTERVAL);

//
// Flag indicating request to refresh device list state
//
EXTERN  BOOL        g_fRefreshDeviceList    ASSIGN(FALSE);


//
// Platform type
//
EXTERN  BOOL        g_fIsWindows9x          ASSIGN(FALSE);

//
// Reentrancy flag for timeout selection
//
EXTERN  BOOL        g_fTimeoutSelectionDialog ASSIGN(FALSE);

//
// Results of command line parsing
//
EXTERN  BOOL        g_fInstallingRequest    ASSIGN(FALSE);
EXTERN  BOOL        g_fRemovingRequest      ASSIGN(FALSE);
EXTERN  BOOL        g_fUIPermitted          ASSIGN(FALSE);
EXTERN  BOOL        g_fStoppingRequest      ASSIGN(FALSE);


//
// Running as a service
//
EXTERN  BOOL        g_fRunningAsService ASSIGN(TRUE);

EXTERN  HANDLE      g_hHeap             ASSIGN(NULL);


//
// Function pointers to imaging services entry points
//


//
// Strings
//

EXTERN TCHAR    g_szImagingServiceDll[MAX_PATH] ASSIGN(TEXT(""));

TEXTCONST(g_szBACK, TEXT("\\"));
TEXTCONST(g_szTitle,TEXT("STI Monitor"));
TEXTCONST(STIStartedEvent_name,TEXT("STIExeStartedEvent"));
TEXTCONST(g_szServiceDll,TEXT("ServiceDll"));
TEXTCONST(g_szServiceMain,TEXT("ServiceMain"));
//
// Class name for the services hidden window
//
TEXTCONST(g_szStiSvcClassName,STISVC_WINDOW_CLASS);
TEXTCONST(g_szClass,STIMON_WINDOW_CLASS);

// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#define     DEFINE_GLOBAL_VARIABLES

#include "stdafx.h"


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

//
// Code section
//

DWORD
InitGlobalConfigFromReg(VOID)
/*++
  Loads the global configuration parameters from registry and performs start-up checks

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;
    DWORD   dwMessageId = 0;

    HKEY    hkey = NULL;

    DWORD   dwMask = 0;

    return dwError;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\memory.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    memory.cpp

Abstract:

    Implements heap management wrappers for use on process default heap

Notes:

Author:

    Vlad Sadovsky   (VladS)    4/12/1999

Environment:

    User Mode - Win32

Revision History:

    4/12/1999       VladS       Created

--*/

VOID
inline
MemInit (
    IN HANDLE   hHeap
    )
{
    g_hHeap = hHeap;
}

LPVOID
inline
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    )
{
    return HeapAlloc (g_hHeap, dwFlags, dwBytes);
}

BOOL
inline
MemFree (
    IN LPVOID   pv
    )
{
    return HeapFree (g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\memory.cpp ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    memory.cpp

Abstract:

    Implements heap management wrappers for use on process default heap

Notes:

Author:

    Vlad Sadovsky   (VladS)    4/12/1999

Environment:

    User Mode - Win32

Revision History:

    4/12/1999       VladS       Created

--*/

VOID
MemInit (
    IN HANDLE   hHeap
    )
{
    g_hHeap = hHeap;
}

LPVOID
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    )
{
    return HeapAlloc (g_hHeap, dwFlags, dwBytes);
}

BOOL
MemFree (
    IN LPVOID   pv
    )
{
    return HeapFree (g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C2DEFF4F_E904_11D1_BAA7_00A02438AD48__INCLUDED_)
#define AFX_STDAFX_H__C2DEFF4F_E904_11D1_BAA7_00A02438AD48__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#ifdef WINNT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#endif

#define _ATL_APARTMENT_FREE


#include <atlbase.h>

#include <shellapi.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
    LONG Unlock();
    DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include "globals.h"

#include <sti.h>
#include <stilib.h>
#include <stireg.h>
#include <stisvc.h>
#include <stiapi.h>
#include <stierr.h>
#include <stiregi.h>
#include <stidebug.h>
#include <regentry.h>

//
//
//
//
// Auto-synchronization helper class
//

class TAKE_CRITSEC
{
private:
    CComAutoCriticalSection  & _critsec;

public:
    TAKE_CRITSEC(CComAutoCriticalSection& critsec) : _critsec(critsec) { _critsec.Lock(); }
    ~TAKE_CRITSEC() {_critsec.Unlock(); }
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C2DEFF4F_E904_11D1_BAA7_00A02438AD48__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stimon.rc
//
#define STIEXE_EVENT_TITLE              1
#define IDS_STIEXE_DEFAULT_APP          2
#define IDS_APP_CHOICE_CAPTION          3
#define IDS_SERVICE_DISPLAY_NAME        4
#define IDR_MENU                        102
#define IDD_APP_CHOICE                  103
#define IDD_SETTIMEOUT                  104
#define IDI_STILL_IMAGE                 111
#define IDC_APP_LIST                    1002
#define IDC_TIMEOUT                     1003
#define IDC_CHECK_ALLDEVICES            1004
#define IDC_CHOICE_PROMPT               1005
#define IDC_SCANNER_ICON                1006
#define IDM_TOOLS_REFRESH               40001
#define IDM_TOOLS_DEVLIST               40002
#define IDM_TOOLS_TIMEOUT               40003
#define IDM_TOOLS_REMOVEALL             40005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     stimon.exe    - hosts the STI/WIA service on win9x platforms
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=stimon
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMTYPE=windows

!IFDEF NOT_UNICODE
UMENTRY=winmain
!ELSE
UMENTRY=wwinmain
!ENDIF

USE_STATIC_ATL=1
USE_STL=1
USE_NATIVE_EH=1

INCLUDES=$(INCLUDES); ..\.;

TARGETLIBS= \
        $(TARGETLIBS) \
        $(WIA_LIB_PATH)\stirt.lib   

SOURCES=    \
         ..\stimon.rc   \
         ..\stdafx.cpp  \
         ..\stimon.cpp  \
         ..\util.cpp    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\util.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.h

Abstract:


Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#include <stistr.h>

BOOL
ParseCommandLine(
    LPTSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    );


BOOL WINAPI
IsPlatformNT(
    VOID
    );

BOOL
IsSetupInProgressMode(
    BOOL    *pUpgradeFlag = NULL
    );


LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    );

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    ) ;

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PSTR*   ppszData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\stimon.cpp ===
/*++


Copyright (c)   1999    Microsoft Corporation

Module Name:

    STIMON.CPP

Abstract:

    This module contains code for process, running STI/WIA services

    Service process is specific for Windows9x OS and represents a wrapper necessary
    to create execution environment. On NT svchost.exe or similar will be used to host
    service.


Author:

    Vlad  Sadovsky  (vlads)     03-20-99

Environment:

    User Mode - Win32

Revision History:

    03-20-99      VladS       created

--*/

//
//  Include Headers
//

#include "stdafx.h"

#include "resource.h"
#include "initguid.h"

#include <atlapp.h>
#include <atltmp.h>

#include <regstr.h>

#include "stimon.h"
#include "memory.h"
#include "util.h"


//
// STL includes
//
#include <algorithm>
#include <vector>
#include <list>


#include <eventlog.h>

//
// Service list manager
//
#include "svclist.h"
#include <winsvc.h>


//
//  Local variables and types definitions
//

using namespace std;

#ifdef USE_MULTIPLE_SERVICES
list<SERVICE_ENTRY>     ServiceList;
CComAutoCriticalSection csServiceList;
#endif

HANDLE  ServerStartedEvent = NULL;

CMainWindow *   pMainWindow = NULL;

SERVICE_ENTRY * pImageServices = NULL;

//
//  Local prototypes
//

DWORD
InitGlobalConfigFromReg(
    VOID
    );

BOOL
DoGlobalInit(
    VOID
    );

BOOL
DoGlobalTermination(
    VOID
    );

BOOL
UpdateRunningServer(
    VOID
    );

HWND
CreateMasterWindow(
    VOID
    );

BOOL
StartMasterLoop(
    PVOID pv
    );

BOOL
StartOperation(
    VOID
    );

BOOL
ParseCommandLine(
    LPSTR   lpszCmdLine,
    UINT    *pargc,
    PTSTR  *argv
    );


BOOL
LoadImageService(
    PTSTR  pszServiceName,
    UINT        argc,
    LPTSTR      *argv
    );

LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    );

LONG
WINAPI
StimonUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

DWORD
WINAPI
StiServiceInstall(
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    );

DWORD
WINAPI
StiServiceRemove(
    VOID
    );

//
// Missing definitions from Win9x version of windows.h
//

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001

typedef DWORD WINAPI REGISTERSERVICEPROCESS(
    DWORD dwProcessId,
    DWORD dwServiceType);

//#include "atlexe_i.c"

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


extern "C"
int
WINAPI
#ifdef UNICODE
_tWinMain
#else
WinMain
#endif
    (
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    int         nShowCmd
    )
/*++

Routine Description:

    WinMain



Arguments:

Return Value:

Side effects:

--*/
{

    UINT                        argc;
    PTSTR                       argv[10];

    DWORD                       err;
    HRESULT                     hres;

    TCHAR                       szCommandLine[255];
    UINT                        i = 0;
    REGISTERSERVICEPROCESS     *pfnRegServiceProcess = NULL;

    DBGTRACE    __s(TEXT("StiMON::WinMain"));

    HRESULT hRes =  CoInitializeEx(0,COINIT_MULTITHREADED);
    // ASSERT SUCCEEDED(hRes)

    //
    // To use built-in ATL conversion macros
    //
    USES_CONVERSION;

    _Module.Init(ObjectMap, hInstance);

    CMessageLoop    cMasterLoop;

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    ::lstrcpyn(szCommandLine,lpCmdLine,(sizeof(szCommandLine) / sizeof(szCommandLine[0])) - 1);
    szCommandLine[sizeof(szCommandLine)/sizeof(szCommandLine[0]) - 1] = TEXT('\0');

    //
    //  Disable hard-error popups and set unhnadled exception filter
    //
    ::SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    ::SetUnhandledExceptionFilter(&StimonUnhandledExceptionFilter);

    //
    // Initialize globals. If this routine fails, we have to exit immideately
    //
    if(NOERROR != InitGlobalConfigFromReg()) {
        goto ExitMain;
    }

    //
    // Parse command line , set up needed options
    //
    ParseCommandLine(szCommandLine,&argc,&argv[0]);

    DPRINTF(DM_TRACE,TEXT("STIMON: starting with the commnd line : %s "), lpCmdLine);

    //
    // Other instances of STIMON running ?
    //
    ServerStartedEvent = ::CreateSemaphore( NULL,
                                            0,
                                            1,
                                            STIStartedEvent_name);
    err = ::GetLastError();

    if ((hPrevInstance) || (err == ERROR_ALREADY_EXISTS)) {

        if (UpdateRunningServer()) {
            goto ExitAlreadyRunning;
        }

        //
        // Win9x specific: If first instance exists - signal it should stop
        //
        if ( g_fStoppingRequest ) {
            ReleaseSemaphore(ServerStartedEvent,1,NULL);
        }
    }

    DPRINTF(DM_TRACE  ,TEXT("STIMON proceeding to create service instance"));

    //
    // Do global initialization, independent of specific service
    //
    if (!DoGlobalInit()) {
        goto ExitMain;
    }

    //
    // If command line is special - process it and bail out
    //
    if (g_fRemovingRequest) {
        StiServiceRemove();
        goto ExitMain;
    }
    else if (g_fInstallingRequest) {
        StiServiceInstall(NULL,NULL);
        goto ExitMain;
    }

    //
    // Tell system we are running as service to prevent shutting down on relogon
    //

    #ifndef WINNT
    if (g_fRunningAsService) {

        pfnRegServiceProcess = (REGISTERSERVICEPROCESS *)GetProcAddress(
                                                             GetModuleHandleA("kernel32.dll"),
                                                             "RegisterServiceProcess");
        if (pfnRegServiceProcess) {
            pfnRegServiceProcess(::GetCurrentProcessId(), RSP_SIMPLE_SERVICE);
        } else {

            //
            // Print out the warning and let the server continue
            //
            DPRINTF(DM_ERROR, TEXT("RegisterServiceProcess() is not exported by kernel32.dll"));
        }
    }
    #endif

    //
    // Load and prepare service DLL for execution
    //
    if ( !LoadImageService(STI_SERVICE_NAME,argc,argv) ) {
        DPRINTF(DM_ERROR, TEXT("Unable load imaging service DLL  Error=%d"),::GetLastError() );
        goto ExitMain;
    }

    #if USE_HIDDEN_WINDOW
    //
    // Create hidden window to receive system-wide notifications
    //
    pMainWindow = new CMainWindow;
    pMainWindow->Create();

    cMasterLoop.Run();
    #else

    //
    // Wait till somebody wakes us up
    //
    // WaitForSingleObject(ServerStartedEvent,INFINITE);

    #endif

ExitMain:

    //
    // Global cleanup
    //
    DPRINTF(DM_TRACE, TEXT("STIMON coming to global cleanup") );

    //
    // Deregister with kernel (Win9x specific)
    //
    #ifndef WINNT
    if (g_fRunningAsService) {

        if (pfnRegServiceProcess) {
            pfnRegServiceProcess(::GetCurrentProcessId(), RSP_UNREGISTER_SERVICE);
        }
    }
    #endif

    DoGlobalTermination();

ExitAlreadyRunning:

    CoUninitialize();

    return 0;
}

BOOL
DoGlobalInit(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    #ifdef MAXDEBUG
    StiSetDebugMask(0xffff);
    StiSetDebugParameters(TEXT("STIMON"),TEXT(""));
    #endif


    //
    // Do misc. cleanup, which we need to do on startup  .
    //
    // 1. Some shipping packages for Win98 register STIMON entry to Run section, which
    //    after upgrade creates problem with racing two copies of STIMON. Remove it.
    // 2. Register WIA service if there is STIMON left over in Run section
    //

    HKEY    hkRun = NULL;
    LONG    lRet ;
    ULONG   lcbValue = 0;
    BOOL    fNeedToRegister = FALSE;
    TCHAR   szSvcPath[MAX_PATH] = {TEXT('0')};

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

        DPRINTF(DM_TRACE,TEXT("Removing erroneous entry on cleanup: HKLM\\..\\Run\\%s"),REGSTR_VAL_MONITOR);

        lcbValue = sizeof(szSvcPath);
        lRet = RegQueryValueEx(hkRun,REGSTR_VAL_MONITOR,NULL,NULL,(LPBYTE)szSvcPath,&lcbValue);

        fNeedToRegister = (lRet == NOERROR);

        lRet = RegDeleteValue (hkRun, REGSTR_VAL_MONITOR);
        RegCloseKey(hkRun);
    }

    if (fNeedToRegister ) {

        LONG    lLen;
        LONG    lNameIndex = 0;

        lLen = ::GetModuleFileName(NULL, szSvcPath, sizeof(szSvcPath)/sizeof(szSvcPath[0]));

        DPRINTF(DM_TRACE,TEXT("Adding STIMON to RunServices entry on cleanup path is : %s"),szSvcPath);

        if ( lLen) {

            if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNSERVICES , &hkRun) == NO_ERROR) {

                DPRINTF(DM_TRACE,TEXT("Adding STIMON to RunServices entry on cleanup: HKLM\\..\\RunServices\\%s"),REGSTR_VAL_MONITOR);

                lcbValue = (::lstrlen(szSvcPath) + 1 ) * sizeof(szSvcPath[0]);
                lRet = RegSetValueEx(hkRun,REGSTR_VAL_MONITOR,NULL,REG_SZ,(LPBYTE)szSvcPath,(DWORD)lcbValue);

                RegCloseKey(hkRun);
            }
        }
        else {
            DPRINTF(DM_ERROR  ,TEXT("Failed to get my own path registering Still Image service monitor. LastError=%d   "), ::GetLastError());
        }
    }

    return TRUE;
}

BOOL
DoGlobalTermination(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{

    if (ServerStartedEvent) {
        ::CloseHandle(ServerStartedEvent);
    }

    //
    // Shut down message loop
    //
    PostQuitMessage(0);

    return TRUE;
}



BOOL
UpdateRunningServer(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/

{

    HWND        hExistingWindow;

    hExistingWindow = ::FindWindow(g_szClass,NULL);

    if (!hExistingWindow) {

        DPRINTF(DM_TRACE  ,TEXT("STIMON second instance did not find first one "));

        return FALSE;
    }

    //
    // Server already running , find it 's window and send a message
    // with new values of parameters
    //

    //
    //  If instructed to stop - do that
    //
    if ( g_fStoppingRequest ) {
        //
        // This is Win9x specific
        //
        DPRINTF(DM_TRACE  ,TEXT("STIMON is trying to close first service instance with handle %X"),hExistingWindow);

        ::PostMessage(hExistingWindow,WM_CLOSE,0,0L);
    }
    else {

        // Refresh requested ?
        if (g_fRefreshDeviceList) {
            // Refresh device list
            ::PostMessage(hExistingWindow,STIMON_MSG_REFRESH,1,0L);
        }

        if (STIMON_AD_DEFAULT_POLL_INTERVAL != g_uiDefaultPollTimeout) {
            ::SendMessage(hExistingWindow,STIMON_MSG_SET_PARAMETERS,STIMON_MSG_SET_TIMEOUT,g_uiDefaultPollTimeout);
        }

    }

    return TRUE;
}

BOOL
LoadImageService(
    PTSTR  pszServiceName,
    UINT        argc,
    LPTSTR      *argv
    )
/*++

Routine Description:

    Attempts to load and initialize the imaging services DLL.

    Calls initialization related services.

Arguments:

    Action - Specifies the initialization action.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    HKEY    hkeyService;
    HKEY    hkeyParams;

    LONG    lr = 0;

    pImageServices = new SERVICE_ENTRY(pszServiceName);

    if (pImageServices) {

        LPSERVICE_MAIN_FUNCTION pfnMain;

        pfnMain = pImageServices->GetServiceMainFunction();

        //
        // Call main entry point
        //
        if (pfnMain) {
            pfnMain(argc,argv);
        }
        return TRUE;
    }

    return FALSE;
}

LONG
WINAPI
StimonUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
/*++

Routine Description:

    Filter for catching unhnalded exceptions

Arguments:

    Standard

Return Value:

    NOERROR

Side effects:

    None

--*/
{
    PCTSTR  pszCommandLine;
    PVOID   Addr;

    pszCommandLine = GetCommandLine ();
    if (!pszCommandLine || !*pszCommandLine) {
        pszCommandLine = TEXT("<error getting command line>");
    }

#if DBG
    DebugBreak();
#endif

    return 0;
}

DWORD
WINAPI
StiServiceInstall(
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    )
/*++

Routine Description:

    Service installation function.
    Calls SCM to install STI service, which is running in user security context

    BUGBUG Review

Arguments:

Return Value:

    None.

--*/
{

    DWORD       dwError = NOERROR;

    return dwError;

} //StiServiceInstall


DWORD
WINAPI
StiServiceRemove(
    VOID
    )

/*++

Routine Description:

    Service removal function.  This function calls SCM to remove the STI  service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success

--*/

{
    DWORD       dwError = NOERROR;

    return dwError;

} // StiServiceRemove
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\svclist.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    svclist.h

Abstract:

    Array of service descriptors

Notes:


Author:

    Vlad Sadovsky   (VladS)    4/12/1999

Environment:

    User Mode - Win32

Revision History:

    4/12/1999       VladS       Created

--*/

#pragma once

class SERVICE_ENTRY  {

    HMODULE     m_hModule;
    CString     m_csDllPath;
    CString     m_csServiceName;
    CString     m_csEntryPoint;
    LPSERVICE_MAIN_FUNCTION    pfnMainEntry;

public:
    SERVICE_ENTRY()
    {
        Reset();
    }

    SERVICE_ENTRY(LPCTSTR   pszServiceName)
    {
        Reset();
        m_csServiceName = pszServiceName;
    }


    ~SERVICE_ENTRY()
    {
        //
        if ( m_hModule ) {
            ::FreeLibrary(m_hModule);
            m_hModule = NULL;
        }
    }

    VOID
    Reset(VOID)
    {
        m_hModule = NULL;
        pfnMainEntry = NULL;
    }

    FARPROC
    GetServiceDllFunction ( VOID )
    {

        USES_CONVERSION;

        FARPROC     pfn;

        //
        // Load the module if neccessary.
        //
        if (!m_hModule) {
            m_hModule = ::LoadLibraryEx (
                        (LPCTSTR)m_csDllPath,
                        NULL,
                        LOAD_WITH_ALTERED_SEARCH_PATH);

            if (!m_hModule) {
                //DPRINTF(DM_ERROR,"LoadLibrary (%ws) failed.  Error %d.\n",pDll->pszDllPath, GetLastError ());
                return NULL;
            }
        }

        ASSERT (m_hModule);

        pfn = ::GetProcAddress(m_hModule, T2A((LPTSTR)(LPCTSTR)m_csEntryPoint));
        if (!pfn) {
            //DPRINTF(DM_ERROR,"GetProcAddress (%s) failed on DLL %s.  Error = %d.\n",pszFunctionName, pDll->pszDllPath, GetLastError ());
        }

        return pfn;
    };

    LPSERVICE_MAIN_FUNCTION
    GetServiceMainFunction (VOID)
    {
        LPTSTR pszEntryPoint = NULL;

        if (!pfnMainEntry) {

            // Get the dll and entrypoint for this service if we don't have it yet.
            //
            LONG    lr;
            HKEY    hkeyParams;
            TCHAR   szEntryPoint[MAX_PATH + 1];

            lr = OpenServiceParametersKey (m_csServiceName, &hkeyParams);

            if (!lr) {

                DWORD dwType;
                DWORD dwSize;
                TCHAR pszDllName         [MAX_PATH + 1];
                TCHAR pszExpandedDllName [MAX_PATH + 1];

                // Look for the service dll path and expand it.
                //
                dwSize = sizeof(pszDllName);
                lr = RegQueryValueEx (
                        hkeyParams,
                        g_szServiceDll,
                        NULL,
                        &dwType,
                        (LPBYTE)pszDllName,
                        &dwSize);

                if (!lr &&
                    ( (REG_EXPAND_SZ == dwType)  || ( REG_SZ == dwType) )
                    && *pszDllName) {

                    // Expand the dll name and lower case it for comparison
                    // when we try to find an existing dll record.
                    //
                    if (REG_EXPAND_SZ == dwType) {
                        ::ExpandEnvironmentStrings (pszDllName,pszExpandedDllName,MAX_PATH);
                    }
                    else {
                        ::lstrcpy(pszExpandedDllName,pszDllName);
                    }
                    ::CharLower (pszExpandedDllName);

                    // Remember this dll for this service for next time.
                    m_csDllPath  = pszExpandedDllName;

                    // Look for an explicit entrypoint name for this service.
                    // (Optional)
                    //
                    *szEntryPoint = TEXT('\0');
                    lr = RegQueryString (hkeyParams,TEXT("ServiceMain"),REG_SZ,&pszEntryPoint);
                }

                RegCloseKey (hkeyParams);
            }

            if (!lstrlen((LPCTSTR)m_csDllPath)) {
                return NULL;
            }

            // We should have it the dll by now, so proceed to load the entry point.
            //

            // Default the entry point if we don't have one specified.
            //

            if ( IS_EMPTY_STRING(pszEntryPoint) ) {
                m_csEntryPoint = g_szServiceMain;
            }
            else {
                m_csEntryPoint = pszEntryPoint;
            }

            if (pszEntryPoint) {
                MemFree(pszEntryPoint);
                pszEntryPoint = NULL;
            }

            pfnMainEntry =  (LPSERVICE_MAIN_FUNCTION) GetServiceDllFunction ();

        }

        return pfnMainEntry;

    };

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\camerads.cpp ===
#include "precomp.h"

//
// values that the WIA/TWAIN data source provides for capability negotation
//

TW_UINT16 g_CameraUnits[]            = {TWUN_PIXELS};
TW_UINT16 g_CameraBitOrder[]         = {TWBO_MSBFIRST};
TW_UINT16 g_CameraXferMech[]         = {TWSX_NATIVE, TWSX_FILE, TWSX_MEMORY};
TW_UINT16 g_CameraPixelFlavor[]      = {TWPF_CHOCOLATE};
TW_UINT16 g_CameraPlanarChunky[]     = {TWPC_CHUNKY};

const TW_UINT32 NUM_CAMERACAPDATA = 23;
CAPDATA CAMERA_CAPDATA[NUM_CAMERACAPDATA] =
{
    //
    // Every source must support all five DG_CONTROL / DAT_CAPABILITY operations on:
    //

    {CAP_XFERCOUNT, TWTY_INT16, TWON_ONEVALUE,
        sizeof(TW_INT16), 0, 0, 0, 32767, 1, NULL, NULL
    },

    //
    // Every source must support DG_CONTROL / DAT_CAPABILITY, MSG_GET on:
    //

    {CAP_SUPPORTEDCAPS, TWTY_UINT16, TWON_ARRAY,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_UICONTROLLABLE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, and MSG_GETDEFAULT on:
    //

    {ICAP_COMPRESSION, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PLANARCHUNKY, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraPlanarChunky, NULL
    },
    {ICAP_PHYSICALHEIGHT, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1024, 1024, 1024, 1024, 0, NULL, NULL
    },
    {ICAP_PHYSICALWIDTH, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1536, 1536, 1536, 1536, 0, NULL, NULL
    },
    {ICAP_PIXELFLAVOR, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraPixelFlavor, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, MSG_GETDEFAULT, MSG_RESET, and MSG_SET on:
    //

    {ICAP_BITDEPTH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BITORDER, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraBitOrder, NULL
    },
    {ICAP_PIXELTYPE, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_UNITS, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraUnits, NULL
    },
    {ICAP_XFERMECH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 2, 0, g_CameraXferMech, NULL
    },
    {ICAP_XRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },
    {ICAP_YRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },

    //
    // The following capabilities are camera specific capabilities
    //

    {CAP_THUMBNAILSENABLED, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  FALSE, FALSE, TRUE, TRUE, 0, NULL, NULL
    },

    {CAP_CAMERAPREVIEWUI, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    {ICAP_IMAGEDATASET, TWTY_UINT32, TWON_RANGE,
        sizeof(TW_UINT32),  1, 1, 1, 50, 1, NULL, NULL
    },

    //
    // The following capabilities are provided for application compatiblity only.
    //

    {ICAP_IMAGEFILEFORMAT, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_INDICATORS, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_ENABLEDSUIONLY, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
    {CAP_DEVICEONLINE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_SUPPORTEDCAPSEXT, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
};

TW_UINT16 CWiaCameraDS::OpenDS(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_UINT16 twCc = TWCC_SUCCESS;

    m_bArrayModeAcquisition = FALSE;
    m_pulImageIndexes   = NULL;
    m_lNumValidIndexes  = 0;
    m_lCurrentArrayIndex = 0;
    m_bRangeModeAcquisition = FALSE;
    memset(&m_twImageRange,0,sizeof(TW_RANGE));

    //
    // create capability list
    //
    twCc = CreateCapList(NUM_CAMERACAPDATA, CAMERA_CAPDATA);
    if (TWCC_SUCCESS != twCc) {
        m_twStatus.ConditionCode = twCc;
        return TWRC_FAILURE;
    }

    twRc =  CWiaDataSrc::OpenDS(ptwMsg);
    if (TWRC_SUCCESS == twRc) {

        HRESULT hr = m_pDevice->AcquireImages(NULL, FALSE);
        if (SUCCEEDED(hr)) {

            //
            // get number of pictures taken, for IMAGEDATASET query
            //

            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            CCap *pCap = NULL;
            pCap = FindCap(ICAP_IMAGEDATASET);
            if (pCap) {
                pCap->Set((TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,1);
            }

            hr = m_pDevice->EnumAcquiredImage(0, &m_pCurrentIWiaItem);
            if (SUCCEEDED(hr)) {

                //
                // attempt to get common settings from the camera device
                // if at any point a "bad" WIA item is encountered, fall
                // through and get common default settings.  This will
                // allow the camera to be used in a TWAIN session even if
                // the WIA item tree appears to be corrupted.
                //

                twRc = GetCommonSettings();
                if(twRc != TWRC_SUCCESS) {
                    twRc = GetCommonDefaultSettings();
                }
            } else {
                //
                // camera devices, can be in a state that there are no still images
                // to transfer
                //

                twRc = GetCommonDefaultSettings();
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaCameraDS::CloseDS(PTWAIN_MSG ptwMsg)
{
    DestroyCapList();
    return CWiaDataSrc::CloseDS(ptwMsg);
}

TW_UINT16 CWiaCameraDS::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    if (ptwCap->Cap == ICAP_IMAGEDATASET) {

        switch(ptwCap->ConType){
        case TWON_ONEVALUE:
            DBG_TRC(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET to a TWON_ONEVALUE"));

            //
            // implied contiguous image transfer, from 1 to the specified TW_ONEVALUE
            //

            twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);

            break;
        case TWON_RANGE:
            DBG_TRC(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_RANGE"));

            //
            // contiguous image transfer, from MinValue to MaxValue TW_RANGE (using StepSize? or increment by 1?)
            //

            twRc = SetRangeOfImageIndexes(ptwCap);

            break;
        case TWON_ARRAY:
            DBG_TRC(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_ARRAY"));

            //
            // image transfer with specified indexes supplied by the TWAIN application (user)
            //

            twRc = SetArrayOfImageIndexes(ptwCap);

            break;
        default:
            DBG_WRN(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET unknown container type (%d)",ptwCap->ConType));
            break;
        }

    } else {
        twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);
        if(TWRC_SUCCESS == twRc){
            if(m_pCurrentIWiaItem){
                twRc = CWiaDataSrc::SetCommonSettings(pCap);
            }
        }
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_ARRAY:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_ARRAY *pArray = (TW_ARRAY*)GlobalLock(ptwCap->hContainer);
        if (pArray) {
            TW_UINT32 *pUINT32Array = NULL;
            pUINT32Array = (TW_UINT32*)pArray->ItemList;
            if(pUINT32Array){
                if (m_pulImageIndexes) {
                    delete [] m_pulImageIndexes;
                    m_pulImageIndexes = NULL;
                }
                m_lNumValidIndexes = pArray->NumItems;
                m_pulImageIndexes  = new LONG[m_lNumValidIndexes];
                if (m_pulImageIndexes) {
                    DBG_TRC(("CWiaCameraDS::SetArrayOfImageIndexes(), number of selected images to transfer = %d",m_lNumValidIndexes));
                    for (int i = 0; i < m_lNumValidIndexes; i++) {

                        //
                        // subtract 1 from the supplied index in the application index array, because TWAIN's image index
                        // array starts at 1 and goes to n. WIA (image) item array is zero-based. This will sync
                        // up the indexes here, to avoid any strange calculations later on.
                        //

                        m_pulImageIndexes[i] = (pUINT32Array[i] - 1);
                        DBG_TRC(("CWiaCameraDS::SetArrayOfImageIndexes(), image index copied into index array = %d",m_pulImageIndexes[i]));
                    }
                } else {
                    DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), could not allocate image index array"));
                    twRc = TWRC_FAILURE;
                }
            } else {
                DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), could not assign TW_ARRAY pointer to TW_UINT32 pointer"));
                twRc = TWRC_FAILURE;
            }

            GlobalUnlock(ptwCap->hContainer);
        } else {
            DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), could not LOCK the array container for write access"));
            twRc = TWRC_FAILURE;
        }
    }

    if(TWRC_SUCCESS == twRc){
        m_bArrayModeAcquisition = TRUE;
        m_bRangeModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_RANGE:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaCameraDS::SetRangeOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_RANGE *pRange = (TW_RANGE*)GlobalLock(ptwCap->hContainer);
        if (pRange) {
            m_bRangeModeAcquisition = TRUE;
            memcpy(&m_twImageRange,pRange,sizeof(TW_RANGE));

            //
            // adjust values to be zero-based to match our stored item list
            //

            m_twImageRange.CurrentValue -=1;
            m_twImageRange.DefaultValue -=1;
            m_twImageRange.MaxValue-=1;
            m_twImageRange.MinValue-=1;

            DBG_TRC(("CWiaCameraDS::SetRangeOfImageIndexes(), Set to the following Range Values"));
            DBG_TRC(("m_twImageRange.ItemType     = %d",m_twImageRange.ItemType));
            DBG_TRC(("m_twImageRange.CurrentValue = %d",m_twImageRange.CurrentValue));
            DBG_TRC(("m_twImageRange.DefaultValue = %d",m_twImageRange.DefaultValue));
            DBG_TRC(("m_twImageRange.MaxValue     = %d",m_twImageRange.MaxValue));
            DBG_TRC(("m_twImageRange.MinValue     = %d",m_twImageRange.MinValue));
            DBG_TRC(("m_twImageRange.StepSize     = %d",m_twImageRange.StepSize));
        } else {
            DBG_ERR(("CWiaCameraDS::SetRangeOfImageIndexes(), could not assign TW_RANGE pointer to TW_RANGE pointer"));
            twRc = TWRC_FAILURE;
        }
        GlobalUnlock(ptwCap->hContainer);
    } else {
        DBG_ERR(("CWiaCameraDS::SetRangeOfImageIndexes(), could not LOCK the range container for read access"));
        twRc = TWRC_FAILURE;
    }

    if(TWRC_SUCCESS == twRc){
        m_bRangeModeAcquisition = TRUE;
        m_bArrayModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::EnableDS(TW_USERINTERFACE *pUI)
{

    TW_UINT16 twRc = TWRC_FAILURE;
    if (DS_STATE_4 == GetTWAINState()) {
        HRESULT hr = S_OK;
        if (pUI->ShowUI) {
            //
            // since we were told to show UI, ignore the UI-LESS settings, and
            // get a new image item list from the WIA UI.
            //
            DBG_TRC(("CWiaCameraDS::EnableDS(), TWAIN UI MODE"));
            m_pDevice->FreeAcquiredImages();
        } else {
            DBG_TRC(("CWiaCameraDS::EnableDS(), TWAIN UI-LESS MODE"));
        }
        hr = m_pDevice->AcquireImages(HWND (pUI->ShowUI ? pUI->hParent : NULL),
                                      pUI->ShowUI);
        LONG lNumImages = 0;
        if (S_OK == hr) {
            twRc = TWRC_SUCCESS;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            if (lNumImages) {
                m_NumIWiaItems = (TW_UINT32)lNumImages;
                m_pIWiaItems = new (IWiaItem *[m_NumIWiaItems]);
                if (m_pIWiaItems) {
                    hr = m_pDevice->GetAcquiredImageList(lNumImages, m_pIWiaItems, NULL);
                    if (FAILED(hr)) {
                        delete [] m_pIWiaItems;
                        m_pIWiaItems = NULL;
                        m_NumIWiaItems = 0;
                        m_NextIWiaItemIndex = 0;
                        m_twStatus.ConditionCode = TWCC_BUMMER;
                        twRc = TWRC_FAILURE;
                    }
                } else {
                    m_NumIWiaItems = 0;
                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    twRc = TWRC_FAILURE;
                }
            }
        } else if(S_FALSE == hr) {
            return TWRC_CANCEL;
        } else {
            m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
            twRc = TWRC_FAILURE;
        }

        //
        // check for number of image items returned
        //

        if(lNumImages <= 0) {
            m_twStatus.ConditionCode = TWCC_BUMMER;
            twRc = TWRC_CANCEL;
        }

        if (TWRC_SUCCESS == twRc) {

            //
            // set current item pointer
            //

            if(m_bRangeModeAcquisition){
                DBG_TRC(("CWiaCameraDS::EnableDS(), RANGE MODE"));
                m_pCurrentIWiaItem = m_pIWiaItems[m_twImageRange.MinValue];
                m_NextIWiaItemIndex = m_twImageRange.MinValue + 1; // use Step value???
            } else if(m_bArrayModeAcquisition){
                DBG_TRC(("CWiaCameraDS::EnableDS(), ARRAY MODE"));
                m_lCurrentArrayIndex = 0;
                m_pCurrentIWiaItem = m_pIWiaItems[m_pulImageIndexes[m_lCurrentArrayIndex]];
                if(m_lNumValidIndexes > 1){
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex + 1]; // the next index value
                } else {
                    m_NextIWiaItemIndex = m_lCurrentArrayIndex;
                }
            } else {
                m_pCurrentIWiaItem = m_pIWiaItems[0];
                m_NextIWiaItemIndex = 1;
            }


            //
            // set total image count
            //

            CCap *pcapXferCount = NULL;
            TW_UINT32 NumImages = 0;
            pcapXferCount = FindCap(CAP_XFERCOUNT);
            if (pcapXferCount) {
                if(m_bRangeModeAcquisition){
                    // only images in the specified range (zero-based)
                    twRc = pcapXferCount->SetCurrent((m_twImageRange.MaxValue - m_twImageRange.MinValue) + 1);
                } else if(m_bArrayModeAcquisition){
                    // only selected images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_lNumValidIndexes);
                } else {
                    // all images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_NumIWiaItems);
                }

                NumImages = pcapXferCount->GetCurrent();
            } else {
                DBG_ERR(("CWiaCameraDS::EnableDS(), could not find CAP_XFERCOUNT in supported CAP list"));
                twRc = TWRC_FAILURE;
            }

            if (TWRC_SUCCESS == twRc) {

                //
                // set thumbnail count
                //

                CCap *pDataSet = NULL;
                pDataSet = FindCap(ICAP_IMAGEDATASET);
                if(pDataSet){
                    pDataSet->Set((TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,1);
                }

                if (m_NumIWiaItems) {

                    //
                    // transition to STATE_5, XferReady will transition to STATE_6
                    //

                    SetTWAINState(DS_STATE_5);
                    NotifyXferReady();
                } else {
                    NotifyCloseReq();

                    //
                    // transition to STATE_5
                    //

                    SetTWAINState(DS_STATE_5);
                }
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaCameraDS::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{

    TW_UINT16 twRc = TWRC_SUCCESS;

    CCap *pXferCount;
    pXferCount = FindCap(CAP_XFERCOUNT);
    if (!pXferCount) {
        m_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }

    twRc = TWRC_SUCCESS;
    switch (ptwMsg->MSG) {
    case MSG_GET:
        switch (GetTWAINState()) {
        case DS_STATE_4:
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
            DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_GET returning %d",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
            break;
        default:
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
            break;
        }
        break;
    case MSG_ENDXFER:
        if (DS_STATE_6 == GetTWAINState() || DS_STATE_7 == GetTWAINState()) {
            ResetMemXfer();
            TW_INT32 Count = 0;
            Count = pXferCount->GetCurrent();
            Count--;

            if (Count <= 0) {
                Count = 0;

                DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, 0 (no more images left to transfer)"));

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)0;

                //
                // update count now, so NotifyCoseReq can be prepared for reentry by a TWAIN application
                //

                pXferCount->SetCurrent((TW_UINT32)0);

                //
                // Transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);
                NotifyCloseReq();
            } else {

                DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, %d (more images may be ready to transfer)",Count));

                //
                // Advance to next image
                //

                if (m_bRangeModeAcquisition) {
                    m_NextIWiaItemIndex+=1; // use Step value???
                    if(m_NextIWiaItemIndex <= (LONG)m_twImageRange.MaxValue){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed RANGE index"));
                    }
                } else if (m_bArrayModeAcquisition) {
                    m_lCurrentArrayIndex++; // advance to next image index
                    DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, next image index  to acquire = %d",m_pulImageIndexes[m_lCurrentArrayIndex]));
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex];
                    if(m_NextIWiaItemIndex <= m_lNumValidIndexes){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed ARRAY index"));
                    }

                } else {
                    m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex++];
                }

                //
                // Transition to STATE_6
                //

                SetTWAINState(DS_STATE_6);

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)Count;
            }

            //
            // update count
            //

            pXferCount->SetCurrent((TW_UINT32)Count);
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    case MSG_RESET:
        if (DS_STATE_6 == GetTWAINState()) {

            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = 0;
            pXferCount->SetCurrent((TW_UINT32)0);

            ResetMemXfer();

            //
            // Transition to STATE_5
            //

            SetTWAINState(DS_STATE_5);

        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaCameraDS::OnImageInfoMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        if (pCap->GetCurrent()) {
            bThumbailMode = TRUE;
        }
    } else {
        DBG_ERR(("CWiaCameraDS::OnImageInfoMsg(), could not get CAP_THUMBNAILSENABLED capabilty settings"));
    }

    if (bThumbailMode) {
        DBG_TRC(("CWiaCameraDS::OnImageInfoMsg(), Reporting Thumbnail image information"));

        TW_IMAGEINFO *ptwImageInfo = NULL;
        if (DS_STATE_6 == GetTWAINState()) {
            if (MSG_GET == ptwMsg->MSG) {
                ptwImageInfo = (TW_IMAGEINFO *)ptwMsg->pData;
                HRESULT hr = S_OK;
                hr = m_pDevice->GetThumbnailImageInfo(m_pCurrentIWiaItem, &m_MemoryTransferInfo);
                if (SUCCEEDED(hr)) {

                    ptwImageInfo->ImageWidth      = (TW_INT32)m_MemoryTransferInfo.mtiWidthPixels;
                    ptwImageInfo->ImageLength     = (TW_INT32)m_MemoryTransferInfo.mtiHeightPixels;
                    ptwImageInfo->BitsPerPixel    = (TW_INT16)m_MemoryTransferInfo.mtiBitsPerPixel;
                    ptwImageInfo->SamplesPerPixel = (TW_INT16)m_MemoryTransferInfo.mtiNumChannels;
                    ptwImageInfo->Planar          = (TW_BOOL)m_MemoryTransferInfo.mtiPlanar;

                    //
                    // set PixelType to corresponding TWAIN pixel type
                    //

                    switch (m_MemoryTransferInfo.mtiDataType) {
                    case WIA_DATA_THRESHOLD:
                        ptwImageInfo->PixelType = TWPT_BW;
                        break;
                    case WIA_DATA_GRAYSCALE:
                        ptwImageInfo->PixelType = TWPT_GRAY;
                        break;
                    case WIA_DATA_COLOR:
                    default:
                        ptwImageInfo->PixelType = TWPT_RGB;
                        break;
                    }

                    //
                    // set compression to NONE
                    //

                    ptwImageInfo->Compression = TWCP_NONE;

                    //
                    // Unit conversion.......
                    //

                    ptwImageInfo->XResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiXResolution);
                    ptwImageInfo->YResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiYResolution);

                    twRc = TWRC_SUCCESS;

                } else {
                    m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
                    twRc = TWRC_FAILURE;
                }

                if (TWRC_SUCCESS == twRc) {
                    DBG_TRC(("CWiaCameraDS::OnImageInfoMsg(), Reported Image Information from data source"));
                    DBG_TRC(("XResolution     = %d.%d",ptwImageInfo->XResolution.Whole,ptwImageInfo->XResolution.Frac));
                    DBG_TRC(("YResolution     = %d.%d",ptwImageInfo->YResolution.Whole,ptwImageInfo->YResolution.Frac));
                    DBG_TRC(("ImageWidth      = %d",ptwImageInfo->ImageWidth));
                    DBG_TRC(("ImageLength     = %d",ptwImageInfo->ImageLength));
                    DBG_TRC(("SamplesPerPixel = %d",ptwImageInfo->SamplesPerPixel));

                    memset(ptwImageInfo->BitsPerSample,0,sizeof(ptwImageInfo->BitsPerSample));

                    if (ptwImageInfo->BitsPerPixel < 24) {
                        ptwImageInfo->BitsPerSample[0] = ptwImageInfo->BitsPerPixel;
                    } else {
                        for (int i = 0; i < ptwImageInfo->SamplesPerPixel; i++) {
                            ptwImageInfo->BitsPerSample[i] = (ptwImageInfo->BitsPerPixel/ptwImageInfo->SamplesPerPixel);
                        }
                    }
                    // (bpp / spp) = bps
                    DBG_TRC(("BitsPerSample   = [%d],[%d],[%d],[%d],[%d],[%d],[%d],[%d]",ptwImageInfo->BitsPerSample[0],
                             ptwImageInfo->BitsPerSample[1],
                             ptwImageInfo->BitsPerSample[2],
                             ptwImageInfo->BitsPerSample[3],
                             ptwImageInfo->BitsPerSample[4],
                             ptwImageInfo->BitsPerSample[5],
                             ptwImageInfo->BitsPerSample[6],
                             ptwImageInfo->BitsPerSample[7]));
                    DBG_TRC(("BitsPerPixel    = %d",ptwImageInfo->BitsPerPixel));
                    DBG_TRC(("Planar          = %d",ptwImageInfo->Planar));
                    DBG_TRC(("PixelType       = %d",ptwImageInfo->PixelType));
                    DBG_TRC(("Compression     = %d",ptwImageInfo->Compression));
                }
            } else {
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
                twRc = TWRC_FAILURE;
            }
        } else {
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS != twRc) {
            DSError();
        }
    } else {
        twRc = CWiaDataSrc::OnImageInfoMsg(ptwMsg);
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::TransferToDIB(HGLOBAL *phDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        bThumbailMode = pCap->GetCurrent();
    }

    if(bThumbailMode){
        twRc = CWiaDataSrc::TransferToThumbnail(phDIB);
    } else {
        twRc = CWiaDataSrc::TransferToDIB(phDIB);
    }

    return twRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\camerads.h ===
#ifndef __CAMERADS_H_
#define __CAMERADS_H_

class CWiaCameraDS : public CWiaDataSrc
{
protected:

    //
    // overridden function definitions
    //

    virtual TW_UINT16 OpenDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual TW_UINT16 EnableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageInfoMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);

private:

    //
    // camera specific function definitions
    //

    TW_UINT16 SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap);
    TW_UINT16 SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap);

    //
    // camera specific member variables
    //

    BOOL m_bArrayModeAcquisition;
    LONG *m_pulImageIndexes;
    LONG m_lNumValidIndexes;
    LONG m_lCurrentArrayIndex;

    BOOL m_bRangeModeAcquisition;
    TW_RANGE m_twImageRange;
};

#endif  // __CAMERADS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\util.cpp ===
/*++


Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    UTIL.CPP

Abstract:

    Utility functions

Author:

    Vlad  Sadovsky  (vlads)     4-12-99

Revision History:



--*/

//
// Headers
//

#include "stdafx.h"

#include "stimon.h"
#include "memory.h"

#include <windowsx.h>
#include <regstr.h>


BOOL
ParseCommandLine(
    LPTSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    )
/*++

Routine Description:

    Parses command line into standard arg.. array.

Arguments:

    None.

Return Value:

    TRUE - command line parsed

--*/
{

    USES_CONVERSION;

    LPTSTR       pszT = lpszCmdLine;
    TCHAR       cOption;
    UINT        iCurrentOption = 0;

    *pargc=0;

    //
    // Get to first parameter in command line.
    //
    while (*pszT && ((*pszT != '-') && (*pszT != '/')) ) {
         pszT++;
    }

    //
    // Parse options from command line
    //
    while (*pszT) {

        // Skip white spaces
        while (*pszT && *pszT <= ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        if ('-' == *pszT || '/' == *pszT) {
            pszT++;
            if (!*pszT)
                break;

            argv[*pargc] = pszT;
            (*pargc)++;
        }

        // Skip till space
        while (*pszT && *pszT > ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        // Got next argument
        *pszT++='\0';
    }

    //
    // Interpret options
    //

    if (*pargc) {

        for (iCurrentOption=0;
             iCurrentOption < *pargc;
             iCurrentOption++) {

            cOption = *argv[iCurrentOption];
            pszT = argv[iCurrentOption]+ 2 * sizeof(TCHAR);


            switch ((TCHAR)LOWORD(::CharUpper((LPTSTR)cOption))) {
                case 'Q':
                     //
                     // Exit main service instance
                     //
                     g_fStoppingRequest = TRUE;

                break;
                case 'V':
                    // Become visible
                    g_fUIPermitted = TRUE;
                    break;

                case 'H':
                    // Become invisible
                    g_fUIPermitted = FALSE;
                    break;


                case 'R':
                    // Refresh device list
                    g_fRefreshDeviceList = TRUE;
                    break;

                case 'A':
                    // Not running as a service, but as an app
                    g_fRunningAsService = FALSE;
                    break;

                case 'T':
                    // Value of timeout in seconds
                    {
                        UINT    uiT = atoi(T2A(pszT));
                        if (uiT) {
                            g_uiDefaultPollTimeout = uiT * 1000;
                        }
                    }
                    break;

                case 'I':
                    // Install STI service
                    g_fInstallingRequest = TRUE;
                    break;
                case 'U':
                    // Uninstall STI service
                    g_fRemovingRequest = TRUE;
                    break;



                default:;
                    break;
            }
        }
    }

    //
    // Print parsed options for debug build
    //

    return TRUE;

} // ParseCommandLine

BOOL
IsSetupInProgressMode(
    BOOL    *pUpgradeFlag   // = NULL
    )
/*++

Routine Description:

    IsSetupInProgressMode

Arguments:

    Pointer to the flag, receiving InUpgrade value

Return Value:

    TRUE - setup is in progress
    FALSE - not

Side effects:

--*/
{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   DWORD dwType, dwSize;
   HKEY hKeySetup;
   DWORD dwSystemSetupInProgress,dwUpgradeInProcess;
   LONG lResult;

   DBGTRACE    _t(TEXT("IsSetupInProgressMode"));

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) {

       dwSize = sizeof(DWORD);
       lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);

       if (lResult == ERROR_SUCCESS) {

           lResult = RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                      &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);

           if (lResult == ERROR_SUCCESS) {

               DPRINTF(DM_TRACE,
                      TEXT("[IsInSetupUpgradeMode] dwSystemSetupInProgress =%d, dwUpgradeInProcess=%d "),
                      dwSystemSetupInProgress,dwUpgradeInProcess);

               if( pUpgradeFlag ) {
                   *pUpgradeFlag = dwUpgradeInProcess ? TRUE : FALSE;
               }

               if (dwSystemSetupInProgress != 0) {
                   return TRUE;
               }
           }
       }
       RegCloseKey (hKeySetup);
   }

   return FALSE ;
}


BOOL WINAPI
IsPlatformNT()
{
    OSVERSIONINFOA  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    // Just always call the ANSI function
    if(!GetVersionExA(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc

LONG
RegQueryDword (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD pdwValue
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (pdwValue);

    dwSize = sizeof(DWORD);

    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            (LPBYTE)pdwValue,
            &dwSize);

    if (!lr && (REG_DWORD != dwType))
    {
        *pdwValue = 0;
        lr = ERROR_INVALID_DATATYPE;
    }

    return lr;
}

LONG
RegQueryValueWithAlloc (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT LPBYTE* ppbData,
    OUT LPDWORD pdwSize
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppbData);
    ASSERT (pdwSize);

    // Initialize the output parameters.
    //
    *ppbData = NULL;
    *pdwSize = 0;

    // Get the size of the buffer required.
    //
    dwSize = 0;
    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            NULL,
            &dwSize);

    if (!lr && (dwType == dwTypeMustBe) && dwSize)
    {
        LPBYTE  pbData;

        // Allocate the buffer.
        //
        lr = ERROR_OUTOFMEMORY;
        pbData = (PBYTE)MemAlloc (0, dwSize);
        if (pbData)
        {
            // Get the data.
            //
            lr = RegQueryValueEx (
                    hkey,
                    pszValueName,
                    NULL,
                    &dwType,
                    pbData,
                    &dwSize);

            if (!lr)
            {
                *ppbData = pbData;
                *pdwSize = dwSize;
            }
            else
            {
                MemFree (pbData);
            }
        }
    }
    else if (!lr && (dwType != dwTypeMustBe))
    {
        lr = ERROR_INVALID_DATA;
    }

    return lr;
}

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    )
{
    LONG    lr;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);

    lr = RegQueryValueWithAlloc (
            hkey,
            pszValueName,
            dwTypeMustBe,
            (LPBYTE*)ppszData,
            &dwSize);

    return lr;
}

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*   ppszData
    )
{
    LONG    lr;
    PTSTR   pszUnicode;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppszData);

    // Initialize the output parameter.
    //
    *ppszData = NULL;

    lr = RegQueryString (
            hkey,
            pszValueName,
            dwTypeMustBe,
            &pszUnicode);

    if (!lr && pszUnicode)
    {
        INT cb;
        INT cchUnicode = lstrlen (pszUnicode) + 1;

        // Compute the number of bytes required to hold the ANSI string.
        //
        cb = WideCharToMultiByte (
                CP_ACP,     // CodePage
                0,          // dwFlags
                (LPCWSTR)pszUnicode,
                cchUnicode,
                NULL,       // no buffer to receive translated string
                0,          // return the number of bytes required
                NULL,       // lpDefaultChar
                NULL);      // lpUsedDefaultChar
        if (cb)
        {
            PSTR pszAnsi;

            lr = ERROR_OUTOFMEMORY;
            pszAnsi = (PSTR)MemAlloc (0, cb);
            if (pszAnsi)
            {
                lr = NOERROR;

                // Now translate the UNICODE string to ANSI.
                //
                cb = WideCharToMultiByte (
                        CP_ACP,     // CodePage
                        0,          // dwFlags
                        (LPCWSTR)pszUnicode,
                        cchUnicode,
                        pszAnsi,    // buffer to receive translated string
                        cb,         // return the number of bytes required
                        NULL,       // lpDefaultChar
                        NULL);      // lpUsedDefaultChar

                if (cb)
                {
                    *ppszData = (PTSTR)pszAnsi;
                }
                else
                {
                    MemFree (pszAnsi);
                    lr = GetLastError ();
                }
            }
        }

        MemFree (pszUnicode);
    } else {
        lr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return lr;
}


LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    )
{
    LONG lr;
    HKEY hkeyServices;

    // Open the Services key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SERVICES,
            0,
            KEY_READ,
            &hkeyServices);

    if (!lr)
    {
        HKEY hkeySvc;

        // Open the service key.
        //
        lr = RegOpenKeyEx (
                hkeyServices,
                pszServiceName,
                0,
                KEY_READ,
                &hkeySvc);

        if (!lr)
        {
            // Open the Parameters key.
            //
            lr = RegOpenKeyEx (
                    hkeySvc,
                    TEXT("Parameters"),
                    0,
                    KEY_READ,
                    phkey);

            RegCloseKey (hkeySvc);
        }

        RegCloseKey (hkeyServices);
    }

    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\cap.cpp ===
#include "precomp.h"

//
// This table translates a given TWTY code to it corresponding
// size in bytes. The table is indexed by TWTY code.
//

const TW_UINT16 TWTY_STRFIRST = TWTY_STR32;
const TW_UINT16 TWTY_STRLAST = TWTY_STR255;
const TW_UINT32 LAST_ITEMTYPE = TWTY_STR255;
const TW_UINT32 g_ItemSizeTable[LAST_ITEMTYPE + 1] =
{
    sizeof(TW_INT8),
    sizeof(TW_INT16),
    sizeof(TW_INT32),
    sizeof(TW_UINT8),
    sizeof(TW_UINT16),
    sizeof(TW_UINT32),
    sizeof(TW_BOOL),
    sizeof(TW_FIX32),
    sizeof(TW_FRAME),
    sizeof(TW_STR32),
    sizeof(TW_STR64),
    sizeof(TW_STR128),
    sizeof(TW_STR255),
};

//
// TWAIN capabilty class implemenation
//

TW_UINT16 CCap::ICap(PCAPDATA pCapData)
{
    if (!pCapData || pCapData->ItemType > LAST_ITEMTYPE)
        return TWCC_BADVALUE;

    m_ItemSize = g_ItemSizeTable[pCapData->ItemType];

    if (m_ItemSize != pCapData->ItemSize)
        return TWCC_BADVALUE;
    //
    // StrData only applies to TW_STRxxx
    //
    if (pCapData->pStrData &&
        (pCapData->ItemSize < sizeof(TW_STR32) ||
         pCapData->ItemType < TWTY_STRFIRST ||
         pCapData->ItemType > TWTY_STRLAST)) {
        return TWCC_BADVALUE;
    }
    //
    // Itemlist only applies to TWON_ENUMERATION
    //
    if (pCapData->ItemList && TWON_ENUMERATION != pCapData->ConType)
        return TWCC_BADVALUE;

    m_ItemType = pCapData->ItemType;
    m_CapId = pCapData->CapId;
    m_ConType = pCapData->ConType;
    m_StepSize = pCapData->StepSize;
    m_CurrentValue = pCapData->Current;
    m_DefaultValue = pCapData->Default;
    m_BaseMinValue = m_CurMinValue = pCapData->MinValue;
    m_BaseMaxValue = m_CurMaxValue = pCapData->MaxValue;
    m_StepSize = pCapData->StepSize;
    m_CurNumItems = 0;
    m_ItemList = NULL;
    if (pCapData->pStrData && TWON_ONEVALUE == pCapData->ConType) {
        // string data
        return Set(pCapData->ItemSize, (BYTE*)pCapData->pStrData);
    }
    if (TWON_ENUMERATION == pCapData->ConType) {
        return Set(pCapData->Default, pCapData->Current,
                   pCapData->MaxValue - pCapData->MinValue + 1,
                   (BYTE *)pCapData->ItemList
                  );
    }
    return TWCC_SUCCESS;
}

TW_UINT16 CCap::Reset()
{
    m_CurMinValue = m_BaseMinValue;
    m_CurMaxValue = m_BaseMaxValue;
    m_CurrentValue = m_DefaultValue;
    if (TWON_ENUMERATION == m_ConType) {

        if(m_ResetItemList){

            ::LocalFree(m_ItemList);
            m_ItemList = NULL;

            //
            // restore original enumeration values
            //

            m_ItemList    = m_ResetItemList;
            m_CurNumItems = m_ResetNumItems;
            m_CurrentValue = m_ResetCurIndex;
            m_DefaultValue = m_ResetDefIndex;
            m_BaseMinValue = 0;
            m_BaseMaxValue = m_ResetNumItems - 1;
            m_CurMinValue = m_BaseMinValue;
            m_CurMaxValue = m_BaseMaxValue;
            m_CurEnumMask = 0xFFFFFFFF >> (32 - m_ResetNumItems);
            m_CurNumItems =  m_ResetNumItems;

        } else {

            //
            // re-establish the mask and the count
            //

            m_CurNumItems = m_BaseMaxValue - m_BaseMinValue + 1;
        }
        m_CurEnumMask = 0xFFFFFFFF >> (32 - m_CurNumItems);
    }
    return TWCC_SUCCESS;
}

#ifdef _USE_NONSPRINTF_CONVERSION

float CCap::Fix32ToFloat(TW_FIX32 fix32)
{
    float ffloat = 0.0f;
    int iexp = 1;
    int frac = fix32.Frac;
    while(frac/10 > 0){
        iexp++;
        frac = (frac/10);
    }
    ffloat = (float)fix32.Whole + (float) ( (float) fix32.Frac / (float) pow(10,iexp));
    return ffloat;
}

TW_FIX32 CCap::FloatToFix32(float ffloat)
{
    TW_FIX32 fix32;
    memset(&fix32,0,sizeof(fix32));
    fix32.Whole = (TW_INT16)ffloat;
    float fVal  = (ffloat - (float)fix32.Whole);
    fVal = (fVal * 100000.0f);
    fix32.Frac = (TW_UINT16)(fVal);
    return fix32;
}

#else   // _USE_NONSPRINTF_CONVERSION

TW_FIX32 CCap::FloatToFix32(float f)
{
    char  fstr[64];
    char  *p = NULL;
    TW_FIX32 f32;
    sprintf(fstr, "%f", f);
    p = strchr(fstr, '.');
    if (p != NULL) {
        *p = '\0';
        f32.Whole = (TW_INT16)atoi(fstr);
        f32.Frac = (TW_UINT16)atoi(p + 1);
    }
    return f32;
}

float CCap::Fix32ToFloat(TW_FIX32 fix32)
{
    return(float)fix32.Whole + (float)(fix32.Frac / 65536.0);
}

#endif // _USE_NONSPRINTF_CONVERSION

TW_UINT32 CCap::ExtractValue(BYTE *pData)
{
    TW_UINT32 Value = 0;
    if (pData) {
        switch (m_ItemType) {
        case TWTY_INT8:
            Value = *((TW_INT8 *)pData);
            break;
        case TWTY_UINT8:
            Value = *((TW_UINT8 *)pData);
            break;
        case TWTY_INT16:
            Value = *((TW_INT16 *)pData);
            break;
        case TWTY_UINT16:
            Value = *((TW_UINT16 *)pData);
            break;
        case TWTY_INT32:
            Value = *((TW_INT32 *)pData);
            break;
        case TWTY_UINT32:
            Value = *((TW_UINT32 *)pData);
            break;
        case TWTY_BOOL:
            Value = *((TW_BOOL *)pData);
            break;
        case TWTY_FIX32:
            Value = *((TW_UINT32 *)pData);
            break;
        default:
            break;

        }
    }
    return Value;
}

TW_UINT32 CCap::GetCurrent()
{
    if (m_ItemSize > sizeof(TW_UINT32))
        return 0;

    if (TWON_ENUMERATION == m_ConType) {
        DBG_TRC(("CCap::GetCurrent(), Extracting %d index from TWON_ENUMERATION",m_CurrentValue));
        return ExtractValue(m_ItemList + m_CurrentValue * m_ItemSize);
    }
    return m_CurrentValue;
}

TW_UINT32 CCap::GetDefault()
{
    if (m_ItemSize > sizeof(TW_UINT32))
        return 0;

    if (TWON_ENUMERATION == m_ConType) {
        return ExtractValue(m_ItemList + m_DefaultValue * m_ItemSize);
    }
    return m_DefaultValue;
}

TW_UINT16 CCap::Set(TW_UINT32 StrDataSize,BYTE *pStrData)
{
    if (m_ItemSize != StrDataSize ||  TWTY_STRFIRST < m_ItemType ||
        TWTY_STRLAST < m_ItemType) {
        //
        // Only apply to string
        //
        return TWCC_BADVALUE;
    }
    if (!m_pStrData) {
        m_pStrData = new BYTE[StrDataSize];
        if (!m_pStrData)
            return TWCC_LOWMEMORY;
    }
    memcpy(m_pStrData, pStrData, StrDataSize);
    return TWCC_SUCCESS;
}

TW_UINT16 CCap::Set(TW_UINT32 DefValue,TW_UINT32 CurValue,TW_UINT32 MinValue,
                    TW_UINT32 MaxValue,TW_UINT32 StepSize)
{
    //
    // This is for TWON_ONEVALUE or TWON_RANGE container type only
    //
    if (TWON_ONEVALUE != m_ConType && TWON_RANGE != m_ConType)
        return TWCC_BADVALUE;

    m_BaseMinValue = m_CurMinValue = MinValue;
    m_BaseMaxValue = m_CurMaxValue = MaxValue;
    m_StepSize = StepSize;
    m_CurrentValue = CurValue;
    m_DefaultValue = DefValue;
    return TWCC_SUCCESS;
}

TW_UINT16 CCap::Set(TW_UINT32 DefIndex,TW_UINT32 CurIndex,TW_UINT32 NumItems,
         BYTE *ItemList,BOOL bForce)
{
    //
    // Total number of items must be less or equal to 32
    // The container type must be TWON_ENUMERATION.
    //

    if(bForce){
        m_ConType  = TWON_ENUMERATION;
    }

    return Set(DefIndex,CurIndex,NumItems,ItemList);
}

TW_UINT16 CCap::Set(TW_UINT32 DefIndex,TW_UINT32 CurIndex,TW_UINT32 NumItems,
         BYTE *  ItemList)
{
    //
    // The container type must be TWON_ENUMERATION.
    //

    if (TWON_ENUMERATION != m_ConType)
        return TWCC_BADVALUE;

    //
    // if we have an existing list, but not a backup
    // make a backup..
    //

    if (m_ItemList) {

        //
        // make a backup if one does not exist
        //

        if (NULL == m_ResetItemList) {

            //
            // save backup list and set current list pointer
            // to NULL
            //

            m_ResetItemList = m_ItemList;
            m_ResetDefIndex = DefIndex;
            m_ResetCurIndex = CurIndex;
            m_ResetNumItems = NumItems;
            m_ItemList = NULL;
        } else {
            ::LocalFree(m_ItemList);
            m_ItemList = NULL;
        }
    }

    m_BaseMinValue =
    m_BaseMaxValue =
    m_CurMinValue =
    m_CurMaxValue =
    m_DefaultValue =
    m_CurrentValue =
    m_CurEnumMask =  0;
    m_ItemList = NULL;
    m_CurNumItems = 0;

    if (NumItems && ItemList) {
        m_ItemList = (BYTE*)LocalAlloc(LPTR,(NumItems * m_ItemSize));
        if (!m_ItemList)
            return TWCC_LOWMEMORY;

        m_CurrentValue = CurIndex;
        m_DefaultValue = DefIndex;
        m_BaseMinValue = 0;
        m_BaseMaxValue = NumItems - 1;
        m_CurMinValue = m_BaseMinValue;
        m_CurMaxValue = m_BaseMaxValue;
        m_CurEnumMask = 0xFFFFFFFF >> (32 - NumItems);
        m_CurNumItems =  NumItems;
        memcpy(m_ItemList, (BYTE*)ItemList, m_ItemSize * NumItems);
    }
    return TWCC_SUCCESS;
}

int CCap::CompareValue(TW_UINT32 valThis, TW_UINT32 valThat)
{
    //
    // When they are equal, they are equal no matter they are signed or not.
    //
    if (valThis == valThat)
        return 0;

    switch (m_ItemType) {
    case TWTY_INT8:
    case TWTY_INT16:
    case TWTY_INT32:
        //
        // Signed.
        //
        return(TW_INT32)valThis > (TW_INT32)valThat ? 1 : -1;
        break;

    case TWTY_UINT8:
    case TWTY_UINT16:
    case TWTY_UINT32:
        //
        // Unsigned.
        //
        return valThis > valThat ? 1 : -1;
        break;

    case TWTY_FIX32:
        {
            TW_FIX32 fix32This;
            TW_FIX32 fix32That;
            memcpy(&fix32This, &valThis, sizeof(TW_UINT32));
            memcpy(&fix32That, &valThat, sizeof(TW_UINT32));
            return Fix32ToFloat(fix32This) > Fix32ToFloat(fix32That) ? 1 : -1;
            break;
        }
    case TWTY_BOOL:
        {
            //
            // eqaul or non-eqaul. Relational comparisons are meaningless
            //
            // valVal == valAgianst is handled up front.
            //
            if (valThis && valThat)
                return 0;
            //
            // We know they are non-eqaul but we can not tell which one
            // is larger.
            //
            return -2;
            break;
        }
    default:
        return -2;
    }
}

TW_UINT32 CCap::GetClosestValue(TW_UINT32 Value)
{
    if (TWON_RANGE != m_ConType)
        return Value;

    TW_UINT32 ClosestValue = Value;

    if (TWON_RANGE == m_ConType) {
        if (CompareValue(ClosestValue, m_CurMinValue) >= 0 &&
            CompareValue(m_CurMaxValue, ClosestValue) >= 0) {
            TW_UINT32 AlignedValue;
            AlignedValue = m_CurMinValue;
            while (CompareValue(m_CurMaxValue, AlignedValue) >= 0) {
                if (CompareValue(AlignedValue, ClosestValue) >= 0) {
                    //
                    // either the values match or we found
                    // the closest one
                    //
                    ClosestValue = AlignedValue;
                    break;
                }
                AlignedValue += m_StepSize;
            }
        }
    }
    return ClosestValue;
}

TW_UINT16 CCap::SetCurrent(TW_UINT32 NewValue)
{
    TW_UINT16 twCc = TWCC_SUCCESS;

    switch (m_ConType) {
    case TWON_ONEVALUE:
        if(m_ItemType == TWTY_BOOL){
            m_CurrentValue = NewValue;
        } else {
            if (m_CapId == CAP_XFERCOUNT){

                //
                // since we are dealing with unsigned values, just
                // allow the setting for CAP_XFERCOUNT to fall through.
                //

                m_CurrentValue = NewValue;
            } else {
                // The value must be between m_CurMinValue and m_CurMaxValue
                if (CompareValue(NewValue, m_CurMinValue) >= 0 &&
                    CompareValue(m_CurMaxValue, NewValue) >= 0) {

                    //
                    // The value is okay. Set it
                    //

                    m_CurrentValue = NewValue;
                } else {
                    twCc = TWCC_BADVALUE;
                }
            }
        }
        break;

    case TWON_RANGE:
        //
        // The value must be between m_CurMinValue and m_CurMaxValue.
        //
        if (CompareValue(NewValue, m_CurMinValue) >= 0 &&
            CompareValue(m_CurMaxValue, NewValue) >= 0) {
            m_CurrentValue = GetClosestValue(NewValue);
        } else {
            twCc = TWCC_BADVALUE;
        }
        break;
    default:
        twCc = TWCC_BADVALUE;
        break;
    }
    return twCc;
}

TW_UINT16 CCap::SetCurrent(VOID *pNewValue)
{
    if (!pNewValue)
        return TWCC_BADVALUE;

    TW_UINT16 twCc;

    switch (m_ConType) {
    case TWON_ONEVALUE:
        if (m_ItemSize <= sizeof(TW_UINT32)) {
            // simple case, do it the easy way
            twCc = SetCurrent(*((TW_UINT32 *)pNewValue));
        } else {
            // this must be a string
            memcpy(m_pStrData, pNewValue, m_ItemSize);
            twCc = TWCC_SUCCESS;
        }
        break;
    case TWON_RANGE:
        twCc = SetCurrent(*((TW_UINT32 *)pNewValue));
        break;
    case TWON_ENUMERATION:
        {
            TW_UINT32 ui32;
            TW_UINT32 Mask;
            BYTE *ItemList;

            //
            // Presume guilty
            //
            twCc = TWCC_BADVALUE;

            Mask = m_CurEnumMask >> m_CurMinValue;
            //
            // Have an alias so that we can save some calculations
            //
            ItemList = m_ItemList + m_CurMinValue * m_ItemSize;
            for (ui32 = m_CurMinValue; ui32 <= m_CurMaxValue; ui32 ++) {
                if (Mask & 1) {
                    //
                    // This item is one of the possible selections
                    //
                    if (!memcmp(ItemList, (BYTE*)pNewValue, m_ItemSize)) {
                        // The new value is within the selection and is
                        // one of the selection. We do not find the
                        // closes value for enumeration. Either they match or
                        // they do not.
                        m_CurrentValue = ui32;
                        twCc = TWCC_SUCCESS;
                    }
                }
                //
                // Advance the item data pointer
                //
                Mask >>= 1;
                ItemList += m_ItemSize;
            }
            break;
        }
    default:
        twCc = TWCC_BADVALUE;
    }
    return twCc;
}

TW_UINT16 CCap::GetOneValue(BOOL bDefault,TW_CAPABILITY *ptwCap)
{
    if (!ptwCap)
        return TWCC_BADCAP;

    TW_UINT32 TheValue;

    TheValue = (bDefault) ? m_DefaultValue : m_CurrentValue;

    HGLOBAL hContainer;
    TW_UINT32 ExtraSize;
    ExtraSize = m_ItemSize <= sizeof(TW_UINT32) ? 0 : m_ItemSize;
    hContainer = GlobalAlloc(GHND, sizeof(TW_ONEVALUE) + ExtraSize);
    if (hContainer) {
        TW_ONEVALUE *pOneValue = (TW_ONEVALUE*)GlobalLock(hContainer);
        if (pOneValue) {
            pOneValue->ItemType = m_ItemType;
            ptwCap->ConType = TWON_ONEVALUE;
            if (!ExtraSize) {
                // simple data
                if (TWON_ENUMERATION == m_ConType) {
                    pOneValue->Item = ExtractValue(m_ItemList + TheValue * m_ItemSize);
                } else
                    pOneValue->Item = TheValue;
            } else {
                BYTE *pData;
                if (m_pStrData) {
                    pData = m_pStrData;
                } else {
                    // string data in enumeration
                    pData = m_ItemList + TheValue * m_ItemSize;
                }
                memcpy(&pOneValue->Item, pData, m_ItemSize);
            }
            GlobalUnlock(hContainer);
            ptwCap->hContainer = hContainer;
            return TWCC_SUCCESS;
        } else {
            GlobalFree(hContainer);
        }
    }
    return TWCC_LOWMEMORY;
}

TW_UINT16 CCap::Get(TW_CAPABILITY *ptwCap)
{
    if (!ptwCap)
        return TWCC_BADCAP;
    HGLOBAL hContainer = NULL;
    TW_UINT16 twCc     = TWCC_SUCCESS;
    TW_RANGE *ptwRange = NULL;
    TW_ENUMERATION *ptwEnum = NULL;
    ptwCap->ConType = m_ConType;
    BYTE *pDst = NULL;
    BYTE *pSrc = NULL;
    TW_UINT32 Size = 0;
    TW_UINT32 Mask = 0;
    TW_UINT32 ui32 = 0;

    switch (m_ConType) {
    case TWON_ONEVALUE:
        twCc = GetCurrent(ptwCap);
        break;
    case TWON_RANGE:
        {
            hContainer = GlobalAlloc(GHND, sizeof(TW_RANGE));
            if (hContainer) {
                ptwRange = (TW_RANGE *)GlobalLock(hContainer);
                if (ptwRange) {
                    ptwRange->ItemType = m_ItemType;
                    ptwRange->MinValue = m_CurMinValue;
                    ptwRange->MaxValue = m_CurMaxValue;
                    ptwRange->StepSize = m_StepSize;
                    ptwRange->DefaultValue = m_DefaultValue;
                    ptwRange->CurrentValue = m_CurrentValue;
                    GlobalUnlock(hContainer);
                    ptwCap->hContainer = hContainer;
                    twCc = TWCC_SUCCESS;
                } else {
                    //
                    // Unable to lock the memory.
                    //
                    GlobalFree(hContainer);
                    twCc = TWCC_LOWMEMORY;
                }
            } else {
                //
                // Unable to allocate memory for the container
                //
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    case TWON_ENUMERATION:
        {
            Size = sizeof(TW_ENUMERATION) + (m_CurNumItems * m_ItemSize);
            hContainer = GlobalAlloc(GHND, Size);
            if (hContainer) {
                ptwEnum = (TW_ENUMERATION *)GlobalLock(hContainer);
                if (ptwEnum) {
                    ptwEnum->ItemType       = m_ItemType;
                    ptwEnum->NumItems       = m_CurNumItems;
                    ptwEnum->DefaultIndex   = m_DefaultValue;
                    ptwEnum->CurrentIndex   = m_CurrentValue;
                    pDst = &ptwEnum->ItemList[0];
                    pSrc = m_ItemList + m_CurMinValue * m_ItemSize;
                    Mask = m_CurEnumMask >> m_CurMinValue;
                    for (ui32 = m_CurMinValue; ui32 <= m_CurMaxValue; ui32++) {
                        if (Mask & 1) {
                            //
                            // got one to return. Copy it to the
                            // returning buffer
                            memcpy(pDst, pSrc, m_ItemSize);
                            pDst += m_ItemSize;
                        }
                        pSrc += m_ItemSize;
                        Mask >>= 1;
                    }
                    GlobalUnlock(ptwEnum);
                    ptwCap->hContainer = hContainer;
                    twCc = TWCC_SUCCESS;
                } else {
                    twCc = TWCC_LOWMEMORY;
                    GlobalFree(hContainer);
                }
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    default:
        twCc = TWCC_BADVALUE;
        break;
    }
    return twCc;
}

TW_UINT16 CCap::Set(TW_CAPABILITY *ptwCap)
{
    if ((!ptwCap)||(NULL == ptwCap->hContainer)||(INVALID_HANDLE_VALUE == ptwCap->hContainer))
        return TWCC_BADCAP;

    TW_UINT16 twCc = TWCC_SUCCESS;

    TW_ONEVALUE    *pOneValue = NULL;
    TW_RANGE       *pRange    = NULL;
    TW_ENUMERATION *ptwEnum   = NULL;

    switch (ptwCap->ConType) {
    case TWON_ONEVALUE:
        {
            DBG_TRC(("CCap::Set(TW_CAPABILITY *ptwCap) -> TWON_ONEVALUE"));
            pOneValue = (TW_ONEVALUE*)GlobalLock(ptwCap->hContainer);
            if (pOneValue != NULL) {
                if (pOneValue->ItemType == m_ItemType) {
                    twCc = SetCurrent(&pOneValue->Item);
                } else {
                    pOneValue->ItemType = m_ItemType;
                    twCc = SetCurrent(&pOneValue->Item);
                    //twCc = TWCC_BADVALUE;
                }
                DBG_TRC(("Application wanted to set (%d) as the value.",pOneValue->Item));
                GlobalUnlock(ptwCap->hContainer);
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    case TWON_RANGE:
        {
            DBG_TRC(("CCap::Set(TW_CAPABILITY *ptwCap) -> TWON_RANGE"));
            pRange = (TW_RANGE*)GlobalLock(ptwCap->hContainer);
            if (pRange != NULL) {
                if (CompareValue(pRange->MinValue, m_BaseMinValue) < 0 ||
                    CompareValue(pRange->MinValue, m_BaseMaxValue) > 0 ||
                    CompareValue(pRange->MaxValue, m_BaseMinValue) < 0 ||
                    CompareValue(pRange->MaxValue, m_BaseMaxValue) > 0 ||
                    CompareValue(pRange->CurrentValue, pRange->MinValue) < 0 ||
                    CompareValue(pRange->CurrentValue, pRange->MaxValue) > 0) {
                    twCc = TWCC_BADVALUE;
                } else {

                    //
                    // Ignore StepSize since it does not make sense for
                    // the application to change it.
                    //

                    m_CurMinValue = GetClosestValue(pRange->MinValue);
                    m_CurMaxValue = GetClosestValue(pRange->MaxValue);
                    m_CurrentValue = GetClosestValue(pRange->CurrentValue);
                    twCc = TWCC_SUCCESS;
                }
                GlobalUnlock(ptwCap->hContainer);
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    case TWON_ENUMERATION:
        {
            DBG_TRC(("CCap::Set(TW_CAPABILITY *ptwCap) -> TWON_ENUMERATION"));
            twCc = TWCC_SUCCESS;
            ptwEnum = (TW_ENUMERATION *)GlobalLock(ptwCap->hContainer);
            if (ptwEnum != NULL) {

                DBG_TRC(("Application sent this Enumeration to be set:"));
                Debug_DumpEnumerationValues(ptwEnum);

                if (m_ConType == TWON_ENUMERATION) {

                    DBG_TRC(("We are a natural TWON_ENUMERATION"));
                    DBG_TRC(("Our List contains:"));
                    Debug_DumpEnumerationValues(NULL);

                } else {
                    DBG_TRC(("We are not a natural TWON_ENUMERATION."));

                    //
                    // fail at the moment, because I need to look up, to see if we should
                    // construct an TWON_ENUMERATION to send back to the application.
                    //

                    twCc = TWCC_BADVALUE;

                    //
                    // "break" here to avoid accessing any bad list data, and to
                    // continue the flow of execution
                    //

                    break;
                }

                //
                // assign the list pointers
                //

                BYTE *pDSList  = m_ItemList;
                BYTE *pAppList = ptwEnum->ItemList;
                UINT ValueIndex = 0;

                //
                // Compare lists, if any value is requested that we don't support,
                // fail them, because the application is trying alter the sources
                // supported values..*smack* BAD APPLICATION!....fail them with
                // TWRC_FAILURE, TWCC_BADVALUE.  That way they know that some value
                // in their enumeration list set was invalid.
                //

                BOOL bFoundItem = FALSE;
                BOOL bBuildEnumeration = TRUE;
                UINT NEWMaxValue = 0;
                UINT NEWMinValue = 0;
                UINT NEWEnumMask = 0;

                for (UINT AppListIndex = 0;AppListIndex < ptwEnum->NumItems;AppListIndex++) {

                    //
                    // reset Data Source's List pointer for searching
                    //

                    pDSList  = m_ItemList;
                    ValueIndex = 0;

                    while ((ValueIndex < m_BaseMaxValue + 1 /* m_CurNumItems */) && (!bFoundItem)) {
                        if(*pDSList == *pAppList){
                            DBG_TRC(("Found Item %d!",*pAppList));
                            bFoundItem = TRUE;

                            //
                            // set mask value
                            //

                            NEWEnumMask |= 1 << ValueIndex;

                            //
                            // update MIN/MAX values
                            //

                            if (ValueIndex > NEWMaxValue){
                                NEWMaxValue = ValueIndex;
                            }

                            if (ValueIndex < NEWMinValue) {
                                NEWMinValue = ValueIndex;
                            }

                        }
                        ValueIndex++;
                        pDSList += ValueSize(m_ItemType);
                    }
                    if(!bFoundItem) {

                        //
                        // we were not found, so break, and fail
                        //

                        DBG_TRC(("Could not find Item %d!",*pAppList));
                        twCc = TWCC_BADVALUE;

                        //
                        // set build enumeration flag to false, because we don't want to
                        // construct an enumeration with invalid entries
                        //

                        bBuildEnumeration = FALSE;
                        break;
                    } else {

                        //
                        // set found flag, and continue searching
                        //

                        bFoundItem = FALSE;
                    }
                    pAppList += ValueSize(ptwEnum->ItemType);
                }

                //
                // set the enumeration, if all values were found, and accounted for
                //

                if(bBuildEnumeration) {
                    DBG_TRC(("Set the application's enumeration"));

                    Set(ptwEnum->DefaultIndex,ptwEnum->CurrentIndex,ptwEnum->NumItems,(BYTE*)ptwEnum->ItemList);

                    DBG_TRC(("What does our new enumeration look like?"));
                    Debug_DumpEnumerationValues(NULL);
                }
                GlobalUnlock(ptwCap->hContainer);
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    default:
        DBG_TRC(("What is this container type [%X]???",ptwCap->ConType));
        twCc = TWCC_BADVALUE;
        break;
    }
    return twCc;
}

TW_UINT16 CCap::ValueSize(TW_UINT16 uTWAINType)
{
    TW_UINT16 uSize = 0;

    switch(uTWAINType) {
    case TWTY_INT8:
        uSize = sizeof(TW_INT8);
        break;
    case TWTY_INT16:
        uSize = sizeof(TW_INT16);
        break;
    case TWTY_INT32:
        uSize = sizeof(TW_INT32);
        break;
    case TWTY_UINT8:
        uSize = sizeof(TW_UINT8);
        break;
    case TWTY_UINT16:
        uSize = sizeof(TW_UINT16);
        break;
    case TWTY_UINT32:
        uSize = sizeof(TW_UINT32);
        break;
    case TWTY_BOOL:
        uSize = sizeof(TW_BOOL);
        break;
    case TWTY_FIX32:
        uSize = sizeof(TW_FIX32);
        break;
    case TWTY_FRAME:
        uSize = sizeof(TW_FRAME);
        break;
    case TWTY_STR32:
        uSize = sizeof(TW_STR32);
        break;
    case TWTY_STR64:
        uSize = sizeof(TW_STR64);
        break;
    case TWTY_STR128:
        uSize = sizeof(TW_STR128);
        break;
    case TWTY_STR255:
        uSize = sizeof(TW_STR255);
        break;
    default:
        uSize = sizeof(TW_UINT16);
        break;
    }
    return uSize;
}

TW_UINT16 CCap::CalcEnumBitMask(TW_ENUMERATION *pEnum)
{
    TW_UINT32 nBitMask = 0x0;
    TW_UINT16 twStatus = TWCC_SUCCESS;

    for(unsigned int nIndex=0;nIndex<pEnum->NumItems;nIndex++)
    {
        switch(pEnum->ItemType)
        {
        case TWTY_UINT8:
            {
                pTW_UINT8 pBits = pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_INT8:
            {
                pTW_INT8 pBits = (pTW_INT8)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_UINT16:
            {
                pTW_UINT16 pBits = (pTW_UINT16)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_INT16:
            {
                pTW_INT16 pBits = (pTW_INT16)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_UINT32:
            {
                pTW_UINT32 pBits = (pTW_UINT32)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_INT32:
            {
                pTW_INT32 pBits = (pTW_INT32)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_BOOL:
            {
                pTW_BOOL pBits = (pTW_BOOL)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        /*case TWTY_FIX32:
            {
                pTW_FIX32 pBits = pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        */
        case TWTY_STR32:
            {
                pTW_STR32 pBits = (pTW_STR32)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_STR64:
            {
                pTW_STR64 pBits = (pTW_STR64)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_STR128:
            {
                pTW_STR128 pBits = (pTW_STR128)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_STR255:
            {
                pTW_STR255 pBits = (pTW_STR255)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        default:
            twStatus = TWCC_BADVALUE;
            break;
        }
    }

    if(twStatus == TWCC_SUCCESS) {
        m_CurEnumMask = nBitMask;
    }

    return twStatus;
}

//
// debug helpers
//

void CCap::Debug_DumpEnumerationValues(TW_ENUMERATION *ptwEnumeration)
{
    BYTE *pList  = NULL;
    UINT ValueIndex = 0;
    UINT iItemSize  = 0;
    UINT iNumItems = 0;
    DBG_TRC(("CCap::Debug_DumpEnumerationValues(), Enumeration Value debug dump"));
    if(ptwEnumeration){
        pList = ptwEnumeration->ItemList;
        DBG_TRC(("Enumeration Values:"));
        DBG_TRC(("ItemType     = %d",ptwEnumeration->ItemType));
        DBG_TRC(("NumItems     = %d",ptwEnumeration->NumItems));
        DBG_TRC(("CurrentIndex = %d",ptwEnumeration->CurrentIndex));
        DBG_TRC(("DefaultIndex = %d",ptwEnumeration->DefaultIndex));
        iItemSize = ValueSize(ptwEnumeration->ItemType);
        iNumItems = ptwEnumeration->NumItems;
    } else {
        pList = m_ItemList;
        DBG_TRC(("Enumeration Values: (current internal settings)"));
        DBG_TRC(("ItemType     = %d",m_ItemType));
        DBG_TRC(("NumItems     = %d",m_CurNumItems));
        DBG_TRC(("CurrentIndex = %d",m_CurrentValue));
        DBG_TRC(("DefaultIndex = %d",m_DefaultValue));
        iItemSize = ValueSize(m_ItemType);
        iNumItems = m_CurNumItems;
    }

#ifdef DEBUG
        DBG_TRC(("Values:"));
        for(ValueIndex = 0;ValueIndex < iNumItems;ValueIndex++) {
            DBG_TRC(("ItemList[%d] = %d",ValueIndex,*pList));
            pList += iItemSize;
        }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\stimon\stimon.h ===
/////////////////////////////////////////////////////////////////////////////
// CMainWin
class CMainWindow :
    public CWindowImpl<CMainWindow>
{
public:

    DECLARE_WND_CLASS(TEXT("StiMonHiddenWindow"))

    CMainWindow()
    {

    }

    ~CMainWindow()
    {

    }

    BOOL Create()
    {
        RECT rcPos;
        ZeroMemory(&rcPos, sizeof(RECT));
        HWND hWnd = CWindowImpl<CMainWindow>::Create( NULL, //HWND hWndParent,
                            rcPos, //RECT& rcPos,
                            NULL,  //LPCTSTR szWindowName = NULL,
                            WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE,
                            0x0,   //DWORD dwExStyle = 0,
                            0      //UINT nID = 0
                            );
        return hWnd != NULL;
    }

    BEGIN_MSG_MAP(CMainWindow)
    END_MSG_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\cap.h ===
#ifndef __CAP_H_
#define __CAP_H_

typedef struct tagCapData
{
    TW_UINT16   CapId;      // TWAIN capability ID(CAP_xxx or ICAP_xxx)
    TW_UINT16   ItemType;   // Item type, TWTY_xxx
    TW_UINT16   ConType;    // Container type, TWON_xxx
    TW_UINT32   ItemSize;   // size of each item
    TW_UINT16   Default;    // Default and Current are both value if
    TW_UINT16   Current;    // ConType is not TWON_ENUMERATION. They are
                // index into the enumeration item list
                // if ConType is TWON_ENUMERATION.
                // When ConType is TWON_ONEVALUE, this is
                // *the* value.
    TW_UINT16   MinValue;   // if Contype is TWON_ENUMERATION,
                // MaxValue - MinValue + 1 is number of
    TW_UINT16   MaxValue;   // items in the enumeration with
                // MinValue indexes to the first item and
    TW_UINT16   StepSize;   // MaxValue indexes to the last item.
                // If ConType is not TWON_ENUMERATION, MinValue
                // and MaxValue creates a bound for all the
                // possible values. For TWON_ONEVALUE, step size
                // is 1. For TWON_RANGE, StepSize is the
                // step size.
    VOID    *ItemList;  // ignore if ConType is not TWON_ENUMERATION
    VOID    *pStrData;   // optional string data
}CAPDATA, *PCAPDATA;


//
// This class serves as a basic repository for saving and retreiving
// TWAIN data.

class CCap
{
public:
    CCap()
    {
        m_CurMinValue =
        m_CurMaxValue =
        m_BaseMinValue =
        m_BaseMaxValue =
        m_CurrentValue =
        m_DefaultValue =
        m_CurEnumMask =
        m_CurNumItems =
        m_ResetNumItems =
        m_ResetCurIndex =
        m_ResetDefIndex = 0;
        m_pStrData = NULL;
        m_ItemList = NULL;
        m_ResetItemList = NULL;
    }
    ~CCap()
    {
        if (m_ItemList) {
            if (m_ResetItemList == m_ItemList) {
                m_ResetItemList = NULL;
            }
            ::LocalFree(m_ItemList);
        }

        if (m_ResetItemList) {
            ::LocalFree(m_ResetItemList);
        }

        if (m_pStrData) {
            ::LocalFree(m_pStrData);
        }
    }

    TW_UINT16 ICap(PCAPDATA pCapData);
    TW_UINT16 ValueSize(TW_UINT16 uTWAINType);

    TW_UINT16   GetCapId()
    {
        return m_CapId;
    }

    TW_UINT16   GetItemType()
    {
        return m_ItemType;
    }

    TW_UINT16   GetContainerType()
    {
        return m_ConType;
    }

    TW_UINT32   GetDefault();

    TW_UINT32   GetCurrent();

    TW_UINT16 Set(TW_UINT32 DefValue, TW_UINT32 CurValue,
          TW_UINT32 MinValue, TW_UINT32 MaxValue,
          TW_UINT32 StepSize = 0
          );
    TW_UINT16 Set(TW_UINT32 StrDataSize, BYTE *pStrData);
    TW_UINT16 Set(TW_UINT32 DefIndex, TW_UINT32 CurIndex,
          TW_UINT32 NumItems, BYTE *ItemList
          );
    TW_UINT16 Set(TW_UINT32 DefIndex, TW_UINT32 CurIndex,
          TW_UINT32 NumItems, BYTE *ItemList,BOOL bForce
          );

    TW_UINT16 CalcEnumBitMask(TW_ENUMERATION *pEnum);
    TW_UINT16   Reset();
    TW_UINT16   GetCurrent(TW_CAPABILITY *ptwCap)
    {
        return GetOneValue(FALSE, ptwCap);
    }
    TW_UINT16   GetDefault(TW_CAPABILITY *ptwCap)
    {
        return GetOneValue(TRUE, ptwCap);
    }
    TW_UINT16   Get(TW_CAPABILITY *ptwCap);
    TW_UINT16   SetCurrent(VOID *pNewValue);
    TW_UINT16   SetCurrent(TW_CAPABILITY *ptwCap);
    TW_UINT16   Set(TW_CAPABILITY *ptwCap);

    int     CompareValue(TW_UINT32 This, TW_UINT32 That);

    TW_FIX32 FloatToFix32(FLOAT f);
    FLOAT    Fix32ToFloat(TW_FIX32 fix32);

    TW_UINT16   SetCurrent(TW_UINT32 NewValue);
protected:
    TW_UINT32   ExtractValue(BYTE *pData);
    TW_UINT16   m_CapId;
    TW_UINT16   m_ItemType;
    TW_UINT16   m_ConType;
    TW_UINT32   m_ItemSize;
private:
    TW_UINT16   GetOneValue(BOOL bDefault, TW_CAPABILITY *ptwCap);
    TW_UINT32   GetClosestValue(TW_UINT32 Value);
    // copy contstructor.
    CCap(const CCap& CapData);
    // Assignment operator
    CCap& operator=(const CCap& CCap);
    TW_UINT32   m_CurrentValue;
    TW_UINT32   m_DefaultValue;

    TW_UINT32   m_StepSize;

    TW_UINT32   m_BaseMinValue;
    TW_UINT32   m_BaseMaxValue;

    TW_UINT32   m_CurMinValue;
    TW_UINT32   m_CurMaxValue;
    TW_UINT32   m_CurEnumMask;
    TW_UINT32   m_CurNumItems;
    TW_UINT32   m_ResetNumItems;
    TW_UINT32   m_ResetCurIndex;
    TW_UINT32   m_ResetDefIndex;
    BYTE    *m_ItemList;
    BYTE    *m_ResetItemList;
    BYTE    *m_pStrData;

    //
    // debug helpers
    //

    void Debug_DumpEnumerationValues(TW_ENUMERATION *ptwEnumeration = NULL);

};

#endif      // #ifndef __CAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\datasrc.h ===
#ifndef __DATASRC_H_
#define __DATASRC_H_

const TW_UINT32 MIN_MEMXFER_SIZE       = 16 * 1024;
const TW_UINT32 MAX_MEMXFER_SIZE       = 64 * 1024;
const TW_UINT32 PREFERRED_MEMXFER_SIZE = 32 * 1024;

//
// TWAIN specific registry KEY
//

// Location: HKEY_CURRENT_USER\Software\Microsoft\WIA\TwainCompatLayer

#define TWAIN_REG_KEY TEXT("Software\\Microsoft\\WIA\\TwainCompatLayer")
#define DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED  TEXT("EnableMultiPageScrollFed")

// Registry Key Value defines
#define DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED_ON    1
#define MAX_BITDEPTHS   64

typedef enum dsState
{
    DS_STATE_0 = 0,
    DS_STATE_1,
    DS_STATE_2,
    DS_STATE_3,
    DS_STATE_4,
    DS_STATE_5,
    DS_STATE_6,
    DS_STATE_7
} DS_STATE, *PDS_STATE;

typedef struct tagTWMsg
{
    TW_IDENTITY *AppId;
    TW_UINT32   DG;
    TW_UINT16   DAT;
    TW_UINT16   MSG;
    TW_MEMREF   pData;
}TWAIN_MSG, *PTWAIN_MSG;

//
// bitmap file type
//

const WORD  BFT_BITMAP  = 0x4d42;

class CWiaDataSrc
{
public:
    CWiaDataSrc();
    virtual ~CWiaDataSrc();
    virtual TW_UINT16 IWiaDataSrc(LPCTSTR DeviceName);
    virtual void NotifyCloseReq();
    virtual void NotifyXferReady();
    TW_UINT16 DSEntry(pTW_IDENTITY pOrigin,TW_UINT32 DG,TW_UINT16 DAT,TW_UINT16 MSG,TW_MEMREF pData);
    TW_FIX32 FloatToFix32(FLOAT f);
    FLOAT Fix32ToFloat(TW_FIX32 fix32);
    TW_UINT16 AddWIAPrefixToString(LPTSTR szString,UINT uSize);
    DS_STATE SetTWAINState(DS_STATE NewTWAINState);
    DS_STATE GetTWAINState();
    TW_UINT16 SetStatusTWCC(TW_UINT16 NewConditionCode);
    float ConvertToTWAINUnits(LONG lValue, LONG lResolution);
    LONG ConvertFromTWAINUnits(float fValue, LONG lResolution);
    DWORD ReadTwainRegistryDWORDValue(LPTSTR szRegValue, DWORD dwDefault = 0);
    BOOL m_bCacheImage;
protected:

    //
    // Functions for DG == DG_CONTROL
    //

    virtual TW_UINT16 OnCapabilityMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnPrivateCapabilityMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnIdentityMsg     (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnSetupMemXferMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnSetupFileXferMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnUserInterfaceMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnXferGroupMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnStatusMsg       (PTWAIN_MSG ptwMsg);

    //
    // Functions for DG == DG_IMAGE
    //

    virtual TW_UINT16 OnPalette8Msg       (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnGrayResponseMsg   (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnRGBResponseMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnCIEColorMsg       (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnJPEGCompressionMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageInfoMsg      (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageLayoutMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageMemXferMsg   (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageFileXferMsg  (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageNativeXferMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 DispatchControlMsg  (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 DispatchImageMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 EnableDS (TW_USERINTERFACE *pUI);
    virtual TW_UINT16 DisableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 OpenDS   (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS  (PTWAIN_MSG ptwMsg);

    //
    // TWAIN capability negotiation
    //

    virtual CCap * FindCap(TW_UINT16 CapId);
    virtual TW_UINT16 CreateCapList(TW_UINT32 NumCaps, PCAPDATA pCapData);
    virtual TW_UINT16 DestroyCapList();
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual LONG GetPrivateSupportedCapsFromWIADevice(PLONG *ppCapArray);
    virtual TW_UINT16 GetPixelTypes();
    virtual TW_UINT16 GetBitDepths();
    virtual TW_UINT16 GetImageFileFormats();
    virtual TW_UINT16 GetCompressionTypes();
    virtual TW_UINT16 GetCommonSettings();
    virtual TW_UINT16 GetCommonDefaultSettings();
    virtual TW_UINT16 SetCommonSettings(CCap *pCap);

    TW_UINT16 AllocatePrivateCapBuffer(TWAIN_CAPABILITY *pHeader, BYTE** ppBuffer, DWORD dwSize);
    TW_UINT16 CopyContainerToPrivateCapBuffer(BYTE* pBuffer, HGLOBAL hContainer);
    TW_UINT16 CopyPrivateCapBufferToContainer(HGLOBAL *phContainer, BYTE* pBuffer, DWORD dwSize);

    //
    // Data transfer negotiation
    //

    virtual void ResetMemXfer();
    virtual TW_UINT16 TransferToFile(GUID guidFormatID);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);
    virtual TW_UINT16 TransferToMemory(GUID guidFormatID);
    virtual TW_UINT16 GetCachedImage(HGLOBAL *phImage);
    virtual TW_UINT16 TransferToThumbnail(HGLOBAL *phThumbnail);
    virtual TW_UINT16 GetMemoryTransferBits(BYTE* pImageData);
    virtual void DSError();

    static HRESULT CALLBACK DeviceEventCallback(LONG lEvent, LPARAM lParam);

    //
    // TWAIN specific members
    //

    DS_STATE          m_dsState;                // current Data Source STATE (1 - 7)
    TW_STATUS         m_twStatus;               // TWAIN status value
    TW_IDENTITY       m_AppIdentity;            // Application's Identity structure
    TW_IDENTITY       m_dsIdentity;             // Data source's Identity structure
    CDSM              m_DSM;                    // Data source Manager object
    CCap              *m_CapList;               // list of capabilities supported by this source
    TW_UINT32         m_NumCaps;                // number of capabilities
    TW_FRAME          m_CurFrame;               // Current FRAME setting (IMAGELAYOUT storage) (not used??)
    TW_IMAGELAYOUT    m_CurImageLayout;         // Current IMAGELAYOUT

    //
    // data transfer specific members
    //

    HGLOBAL           m_hMemXferBits;           // Handle to memory
    BYTE              *m_pMemXferBits;          // Pointer to memory

    TW_UINT32         m_LinesTransferred;       // Number of lines transferred
    TW_UINT32         m_BytesPerScanline;       // Bytes per scan line
    TW_INT32          m_ScanlineOffset;         // offset, per scan line
    TW_UINT32         m_ImageHeight;            // Image Height, in pixels
    TW_UINT32         m_ImageWidth;             // Image Width, in pixels
    CHAR              m_FileXferName[MAX_PATH]; // File name used in FILEXFER
    HGLOBAL           m_hCachedImageData;       // cached image data
    MEMORY_TRANSFER_INFO m_MemoryTransferInfo;  // memory transfer information

    //
    // WIA specific members
    //

    CWiaDevice       *m_pDevice;                // WIA device used as the TWAIN device
    IWiaItem        **m_pIWiaItems;             // pointer to Item(s) for transferring/or setting properties
    LONG              m_NextIWiaItemIndex;      // index to next Item/Image
    LONG              m_NumIWiaItems;           // number of Items/Images
    IWiaItem         *m_pCurrentIWiaItem;       // pointer to current Item/Image
};

#endif  // #ifndef __DATASRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\dsloader.h ===
#ifndef _DSLOADER__H_
#define _DSLOADER__H_

//
// This header file defines the interface between TWAIN Source manager and
// the import data source loader. An import data source loader is a
// separate module loaded by the Source manager to enumerate, load, and unload
// data sources not in TWAIN traditional form, ie, *.ds files in the TWAIN
// subdirectory. This kind of data sources can be in any form as far as
// the loader can expose them properly so that the Source
// manager can access to them.
// A registry entry is dedicated for the loader(only one loader is allowed,
// although this may be changed in the future):
// ImportDSLoader = REG_SZ : <loader full path name>
//

//
// API names provided by the loader.
//

const CHAR FIND_FIRSTIMPORTDS[]        = "FindFirstImportDS";
const CHAR FIND_NEXTIMPORTDS[]         = "FindNextImportDS";
const CHAR CLOSE_FINDCONTEXT[]         = "CloseFindContext";
const CHAR LOAD_IMPORTDS[]             = "LoadImportDS";
const CHAR UNLOAD_IMPORTDS[]           = "UnloadImportDS";
const CHAR GET_LOADERSTATUS[]          = "GetLoaderStatus";
const CHAR FIND_IMPORTDSBYDEVICENAME[] = "FindImportDSByDeviceName";

//
// We pass the imported data source handle on every call to an imported
// data source so that the loader has a way of dispatching the call
// to the designated data source in case two or more data sources
// share the same DS_Entry.
//

typedef TW_UINT16 (APIENTRY *PFNIMPORTEDDSENTRY)(HANDLE, TW_IDENTITY *,
				            TW_UINT32, TW_UINT16, TW_UINT16, TW_MEMREF);
//
// Each data source has its own load/unload function. This makes it possible
// for the loader to assign different loading/unloading scheme for
// different data source.
//

typedef TW_UINT16 (APIENTRY *PFNLOAD_IMPORTDS)(LPCSTR DeviceName,
					       DWORD DeviceFlags, HANDLE *phDS, PFNIMPORTEDDSENTRY *pDSEntry);
typedef TW_UINT16 (APIENTRY *PFNUNLOAD_IMPORTDS)(HANDLE hDS);

//
// Data structure used to convey information about a
// particular data source
//

typedef struct tagImportDSInfo
{
    DWORD Size;		      // The size of the entire structure in bytes.
    CHAR DeviceName[MAX_PATH];  // The device name which uniquely
				                // identifies a particular device
				                // instance in a system. The content
				                // is up to the loader.
    DWORD DeviceFlags;          // misc flags used by the loader.
				                // Together with DeviceName, it is required
				                // to load a device.
    PFNLOAD_IMPORTDS pfnLoadDS; // Loader provided function to load this
				                // this data source.
				                
    PFNUNLOAD_IMPORTDS	pfnUnloadDS; // Loader provided function to unload this data source.
}IMPORT_DSINFO, *PIMPORT_DSINFO;

//
// Funtion prototypes for the APIs
//

typedef TW_UINT16 (APIENTRY *PFNFIND_FIRSTIMPORTDS)(PIMPORT_DSINFO pDSInfo, PVOID *Context);
typedef TW_UINT16 (APIENTRY *PFNFIND_NEXTIMPORTDS)(PIMPORT_DSINFO pDSInfo, PVOID Context);
typedef TW_UINT16 (APIENTRY *PFNCLOSE_FINDCONTEXT)(PVOID Context);
typedef TW_UINT16 (APIENTRY *PFNFIND_IMPORTDSBYDEVICENAME)(PIMPORT_DSINFO pDSInfo, LPCSTR DeviceName);
typedef TW_UINT16 (APIENTRY *PFNGET_LOADERSTATUS)(TW_STATUS *ptwStatus);

//
// This API finds the first available data source managed by the loader
// Input:
//	pDSInfo -- the buffer to receive the first available data source
//		   information. The structure size must be initialized.
//	Context -- A place holder to store the context created by this
//		   API. It is required for FindNextImportDS.
//		   CloseFindContext should be called to release any
//		   resource alloated for this context.
//Output:
//	standard TWRC_ code. If it is not TWRC_SUCCESS, a call
//	to GetLoaderStatus will returns the corresponding TWCC_ code.
//	If the API succeeded, TWRC_SUCCESS is returned.
//	If the API succeeded, pDSInfo is filled with the data source
//	information.

TW_UINT16 APIENTRY FindFirstImportDS(PIMPORT_DSINFO pDSInfo,PVOID Context);

//
// This API finds the next available data source managed by the loader
// Input:
//	pDSInfo -- the buffer to receive the next available data source
//		   information. The structure size must be initialized.
//	Context -- The context returned by FindFirstImportDS
//Output:
//	standard TWRC_ code. If it is not TWRC_SUCCESS, a call
//	to GetLoaderStatus returns the corresponding TWCC_ code.
//	If the API succeeded, TWRC_SUCCESS is returned.
//	If there are no available Data source, TWRC_ENDOFLIST is
//	returned. If the function succeeded, the buffer designated
//	by pDSInfo is filled with data source information.

TW_UINT16 APIENTRY FindNextImportDS(PIMPORT_DSINFO pDSInfo,PVOID Context);

//
// This API closes the context information used to find the data sources
// managed by the loader. The context is returned from FindFirstImportDS
// API and should be releases by calling this API when the searching
// is done.
// Input:
//	Contex -- the context to be closed
// Output:
//	standard TWRC_ error code

TW_UINT16 APIENTRY CloseFindContext( PVOID Context);

//
// This API asks the loader to load the specific data source
// idenetified by the given IMPORT_DSINFO and returns
// the data source's DSEntry. Each data source can supply its own load function
// or several data sources can share the same function. The choice is up
// to the loader and how it load/unload the data source.
// Input:
//	DeviceName -- the name that uniquely represent the data source
//	phDS	   -- to receive a handle to the loaded data source.
//	pDSEntry   -- to receive the data source DSEntry
// Output:
//	standard TWRC_.
//	If the data source is loaded successfully, TWRC_SUCCESS
//	is returned, pDSEntry is filled with the data source's
//	DSEntry and phDS is filled with the handle to the loaded
//	data source. If this api failed, NULL are returned in phDS
//	and pDSEntry.
//
TW_UINT16 APIENTRY LoadImportDS(LPCSTR DeviceName, DWORD  DeviceFlags,HANDLE *phDS,
                                PFNIMPORTEDDSENTRY *pImportDSEntry);
//
// This API asks the loader to unload the specific data source
// The loader is free to release any resources allocated for this
// data source. When the data source is needed again, it will be
// loaded again.
// Input:
//	hDS	-- handle to the loaded data source obtained
//		   from LoadImportDS API
// Output:
//   standard TWRC_ error code

TW_UINT16 APIENTRY UnloadImportDS(HANDLE hDS);

//
// This API finds the data source designated by the given
// device name. This API is useful when the caller only
// knows about a particular device name.
//
// Input:
//	pDSInfo -- buffer to receive data source info.
//	DeviceName -- the device name use to search
//		      for data source
// Output:
//	TWRC_SUCCESS  if a match is found.
//	TWRC_ENDOFLIST if no math is found.
//	TWRC_	other error code.
//

TW_UINT16 APIENTRY FindImportDSByDeviceName(PIMPORT_DSINFO pDSInfo,LPCSTR DeviceName);

//
// This API returns the current loader TW_STATUS. The loader
// updates its status only when the last api call to the loader
// did not return TWRC_SUCCESS.
// Input:
//	ptwStatus -- buffer to receive the status
// Output:
//	standard TWRC_ code.
//

TW_UINT16 APIENTRY GetLoaderStatus(TW_STATUS *ptwStatus);

#endif	// #ifndef _DSLOADER__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\datasrc.cpp ===
#include "precomp.h"

// #define DEBUG_MEMXFER

#define PRIVATE_CAP_ARRAY_PADDING 64 // 64 bytes padding
const TCHAR WIA_STR[] = TEXT("WIA-");
const CHAR* FAMILY_NAME = "Twain Data Source On WIA";

CWiaDataSrc::CWiaDataSrc() :
m_dsState(DS_STATE_0),
m_hMemXferBits(NULL),
m_pMemXferBits(NULL),
m_pDevice(NULL),
m_pIWiaItems(NULL),
m_NumIWiaItems(0),
m_NextIWiaItemIndex(0),
m_NumCaps(0),
m_CapList(NULL),
m_hCachedImageData(NULL),
m_bCacheImage(FALSE)
{
    SetTWAINState(DS_STATE_3);
    memset(m_FileXferName,0,sizeof(m_FileXferName));
    memset(&m_AppIdentity,0,sizeof(m_AppIdentity));
    memset(&m_dsIdentity,0, sizeof(m_dsIdentity));
    memset(&m_CurFrame, 0,sizeof(m_CurFrame));
    memset(&m_CurImageLayout, 0,sizeof(m_CurImageLayout));
    memset(&m_MemoryTransferInfo,0,sizeof(m_MemoryTransferInfo));

    ResetMemXfer();

    m_twStatus.ConditionCode = TWCC_SUCCESS;

    m_CurImageLayout.DocumentNumber     = 1;
    m_CurImageLayout.PageNumber         = 1;
    m_CurImageLayout.FrameNumber        = 1;
    m_CurImageLayout.Frame.Top.Whole    = 0;
    m_CurImageLayout.Frame.Top.Frac     = 0;
    m_CurImageLayout.Frame.Left.Whole   = 0;
    m_CurImageLayout.Frame.Left.Frac    = 0;
    m_CurImageLayout.Frame.Right.Whole  = 8;
    m_CurImageLayout.Frame.Right.Frac   = 5;
    m_CurImageLayout.Frame.Bottom.Whole = 11;
    m_CurImageLayout.Frame.Bottom.Frac  = 0;
    m_pCurrentIWiaItem = NULL;
}

CWiaDataSrc::~CWiaDataSrc()
{
    ResetMemXfer();
    if (m_pDevice){
        delete m_pDevice;
        m_pDevice = NULL;
    }

    if (m_pIWiaItems){
        delete [] m_pIWiaItems;
        m_pIWiaItems = NULL;
    }
}

TW_UINT16 CWiaDataSrc::IWiaDataSrc(LPCTSTR DeviceId)
{
    if (!DeviceId) {
        m_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }

    //
    // Initialize m_dsIdentity. This is required because
    // DG_CONTROL/DAT_IDENTITY/MSG_GET could be called
    // before we are opened.
    //

    m_pDevice = new CWiaDevice;

    if (!m_pDevice) {
        m_twStatus.ConditionCode = TWCC_LOWMEMORY;
        return TWRC_FAILURE;
    }

    TCHAR szTempString[MAX_PATH];
    memset(szTempString,0,sizeof(szTempString));

    HRESULT hr = S_OK;

    hr = m_pDevice->Initialize(DeviceId);
    if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_LOWMEMORY;
        delete m_pDevice;
        m_pDevice = NULL;
        DBG_ERR(("CWiaDataSrc::IWiaDataSrc(), WIA Device object Initialize failed"));
        return TWRC_FAILURE;
    }

    //
    // We don't need to attach a callback here because we will
    // close the device after we are done with it.
    //

    if (SUCCEEDED(hr)) {
        m_dsIdentity.Id               = 0;
        m_dsIdentity.Version.MajorNum = 1;
        m_dsIdentity.Version.MinorNum = 0;
        m_dsIdentity.Version.Language = TWLG_USA;
        m_dsIdentity.Version.Country  = TWCY_USA;
        m_dsIdentity.ProtocolMajor    = TWON_PROTOCOLMAJOR;
        m_dsIdentity.ProtocolMinor    = TWON_PROTOCOLMINOR;
        m_dsIdentity.SupportedGroups  = DG_CONTROL | DG_IMAGE;
        lstrcpyA(m_dsIdentity.Version.Info,"26 June 2000");

        //
        // Use a specific product family name so that applications
        // can differentiate between a data source on WIA and
        // a *pure* TWAIN data source
        //

        lstrcpyA(m_dsIdentity.ProductFamily, FAMILY_NAME);
        lstrcpyA(m_dsIdentity.ProductName, "UnknownProduct");
        lstrcpyA(m_dsIdentity.Manufacturer, "UnknownMfg");

#ifdef UNICODE

        //
        // UNICODE specific
        //

        // This assumes that ProductName, FamilyName and Manufacturer
        // are all in TW_STR32 (TWAIN data type for a string).
        //

        UINT Len = 0;
        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceDesc(szTempString,sizeof(szTempString),&Len);
        if (SUCCEEDED(hr)) {

            //
            // Add "WIA-" to beginning of ProductName string, to separate
            // TWAIN installed data sources, from WIA data sources
            //

            AddWIAPrefixToString(szTempString,sizeof(szTempString));
            Len += lstrlen(WIA_STR); // add prefix size to length

            //
            // set ProductName in TW_IDENTITY structure
            //

            WideCharToMultiByte(CP_ACP, 0, szTempString, Len + 1,m_dsIdentity.ProductName,
                                (sizeof(m_dsIdentity.ProductName)/sizeof(m_dsIdentity.ProductName[0])),NULL, NULL);

            Len = 0;
        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(), GetDeviceDesc failed"));
            return TWRC_FAILURE;
        }

        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceVendorName(szTempString,sizeof(szTempString),&Len);
        if (SUCCEEDED(hr)) {

            //
            // set Manufacturer in TW_IDENTITY structure
            //

            WideCharToMultiByte(CP_ACP, 0, szTempString, Len + 1,m_dsIdentity.Manufacturer,
                                (sizeof(m_dsIdentity.Manufacturer)/sizeof(m_dsIdentity.Manufacturer[0])),NULL, NULL);
        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(), GetDeviceVendorName failed"));
            return TWRC_FAILURE;
        }

#else

        //
        // ANSI specific
        //

        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceDesc(szTempString,sizeof(szTempString),NULL);
        if (SUCCEEDED(hr) ) {

            //
            // Add "WIA-" to beginning of ProductName string, to separate
            // TWAIN installed data sources, from WIA data sources
            //

            AddWIAPrefixToString(szTempString,sizeof(szTempString));

            //
            // set ProductName in TW_IDENTITY structure
            //

            strncpy(m_dsIdentity.ProductName,szTempString,sizeof(TW_STR32) - 1);

        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(),GetDeviceDesc failed"));
            return TWRC_FAILURE;
        }

        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceVendorName(szTempString,sizeof(szTempString),NULL);
        if (SUCCEEDED(hr) ) {

            //
            // set Manufacturer in TW_IDENTITY structure
            //

            strncpy(m_dsIdentity.Manufacturer,szTempString,sizeof(TW_STR32) - 1);
        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(),GetDeviceVendorName failed"));
        }
#endif
    }
    return(SUCCEEDED(hr)) ? TWRC_SUCCESS : TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::AddWIAPrefixToString(LPTSTR szString,UINT uSize)
{
    TCHAR szTempBuffer[512];
    memset(szTempBuffer,0,sizeof(szTempBuffer));
    _sntprintf(szTempBuffer,(sizeof(szTempBuffer)/sizeof(szTempBuffer[0])),TEXT("%s%s"),WIA_STR,szString);
    szTempBuffer[(sizeof(szTempBuffer)/sizeof(szTempBuffer[0])) - 1] = 0;

    //
    // copy, and truncate New string to TWAIN's required
    // restricted size.
    //

    memset(szString,0,uSize);

#ifdef UNICODE
    wcsncpy(szString,szTempBuffer,(sizeof(TW_STR32) - 1));
#else
    strncpy(szString,szTempBuffer,(sizeof(TW_STR32) - 1));
#endif
    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::DSEntry(pTW_IDENTITY pOrigin,TW_UINT32 DG,TW_UINT16 DAT,
                               TW_UINT16 MSG,TW_MEMREF pData)
{
    TWAIN_MSG twMsg;
    twMsg.AppId = pOrigin;
    twMsg.DG = DG;
    twMsg.DAT = DAT;
    twMsg.MSG = MSG;
    twMsg.pData = pData;

    TW_UINT16 twRc = TWRC_SUCCESS;

    if (MSG_PROCESSEVENT == MSG) {
        //
        // Since we rely on WIA UI to provide the user interface and since
        // the WIA UI is a modal dialog box(meaning it has its own
        // messge loop), every event we receive here is not DS event.
        //

        //((TW_EVENT*)twMsg.pData)->TWMessage = MSG_NULL;

        twRc = TWRC_NOTDSEVENT;
    } else {
        //
        // Dispatch message based on group
        //
        switch (twMsg.DG) {
        case DG_CONTROL:
            twRc = DispatchControlMsg(&twMsg);
            break;
        case DG_IMAGE:
            twRc = DispatchImageMsg(&twMsg);
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            break;
        }
        DBG_TRC(("Sent to TWAIN Application, DG = %X, DT = %X, MSG = %X, ( TWRC = %X, TWCC = %X)",DG,DAT,MSG,twRc,m_twStatus.ConditionCode));
    }
    return twRc;
}

#ifdef _USE_NONSPRINTF_CONVERSION

float CWiaDataSrc::Fix32ToFloat(TW_FIX32 fix32)
{
    float ffloat = 0.0f;

    //
    // TWAIN spec implementation
    //

    ffloat = (float)fix32.Whole + (float)fix32.Frac / 65536.0f;

    /*

    //
    // original implementation
    //

    int iexp = 1;
    int frac = fix32.Frac;
    while(frac/10 > 0){
        iexp++;
        frac = (frac/10);
    }
    ffloat = (float)fix32.Whole + (float) ( (float) fix32.Frac / (float) pow(10,iexp));

    */

    return ffloat;
}

TW_FIX32 CWiaDataSrc::FloatToFix32(float ffloat)
{
    TW_FIX32 fix32;
    memset(&fix32,0,sizeof(fix32));

    //
    // TWAIN spec implementation
    //

    TW_INT32 value = (TW_INT32) (ffloat * 65536.0f + 0.5f);
    fix32.Whole    = (TW_INT16)(value >> 16);
    fix32.Frac     = (TW_UINT16)(value & 0x0000ffffL);

    /*

    //
    // original implementation
    //

    fix32.Whole = (TW_INT16)ffloat;
    //float fVal  = -((float)fix32.Whole - ffloat);
    float fVal  = (ffloat - (float)fix32.Whole);
    fVal = (fVal * 100000.0f);
    fix32.Frac = (TW_UINT16)(fVal);
    */

    return fix32;
}

#else   // _USE_NONSPRINTF_CONVERSION

TW_FIX32 CWiaDataSrc::FloatToFix32(float f)
{
    char fstr[64];
    memset(fstr,0,sizeof(fstr));
    char *p = NULL;
    TW_FIX32 f32;
    memset(&f32,0,sizeof(f32));

    sprintf(fstr, "%f", f);
    p = strchr(fstr, '.');
    if (p != NULL) {
        *p = '\0';
        f32.Whole = (TW_INT16)atoi(fstr);
        f32.Frac  = (TW_UINT16)atoi(p + 1);
    }
    return f32;
}

float CWiaDataSrc::Fix32ToFloat(TW_FIX32 fix32)
{

    // (full precision)
    char fstr[64];
    memset(fstr,0,sizeof(fstr));
    float fReturnValue = 0.0f;
    sprintf(fstr,"%d.%d",fix32.Whole,fix32.Frac);
    sscanf(fstr,"%f",&fReturnValue);

    // original (loses precision)
    // fReturnValue = (float)fix32.Whole + (float)(fix32.Frac / 65536.0);

    return fReturnValue;
}
#endif  // _USE_NONSPRINTF_CONVERSION

void CWiaDataSrc::NotifyCloseReq()
{
    DBG_FN_DS(CWiaDataSrc::NotifyCloseReq());
    if(m_DSM.Notify(&m_dsIdentity, &m_AppIdentity,
                 (TW_UINT32)DG_CONTROL, DAT_NULL,MSG_CLOSEDSREQ, (TW_MEMREF)NULL)){
        DBG_TRC(("CWiaDataSrc::NotifyCloseReq(), MSG_CLOSEDSREQ is sent to application"));
    } else {
        DBG_WRN(("CWiaDataSrc::NotifyCloseReq(), could not notify application for MSG_CLOSEDSREQ"));
    }
}

void CWiaDataSrc::NotifyXferReady()
{
    DBG_FN_DS(CWiaDataSrc::NotifyXferReady());
    if (m_DSM.Notify(&m_dsIdentity,&m_AppIdentity,
                     (TW_UINT32)DG_CONTROL,DAT_NULL,MSG_XFERREADY,(TW_MEMREF)NULL)) {

        DBG_TRC(("CWiaDataSrc::NotifyXferReady(), MSG_XFERREADY is sent to application"));

        //
        // transition to STATE_6
        //

        SetTWAINState(DS_STATE_6);

    } else {
        DBG_WRN(("CWiaDataSrc::NotifyXferReady(), could not notify application for MSG_XFERREADY"));
    }
}

void CWiaDataSrc::ResetMemXfer()
{
    DBG_FN_DS(CWiaDataSrc::ResetMemXfer());
    if (IS_VALID_HANDLE(m_hMemXferBits)) {
        if (m_pMemXferBits) {
            if (GlobalUnlock(m_hMemXferBits)) {
                m_pMemXferBits = NULL;
            }
        }
        // Now free block always
        GlobalFree(m_hMemXferBits);
    }
    m_hMemXferBits = NULL;
    m_hCachedImageData = NULL;
    m_LinesTransferred = 0;
}

TW_UINT16 CWiaDataSrc::DispatchControlMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (!ptwMsg) {
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        return TWRC_FAILURE;
    }
    switch (ptwMsg->DAT) {
    case DAT_IDENTITY:
        twRc = OnIdentityMsg(ptwMsg);
        break;
    case DAT_USERINTERFACE:
        twRc = OnUserInterfaceMsg(ptwMsg);
        break;
    case DAT_CAPABILITY:
        twRc = OnCapabilityMsg(ptwMsg);
        break;
    case DAT_STATUS:
        twRc = OnStatusMsg(ptwMsg);
        break;
    case DAT_PENDINGXFERS:
        twRc = OnPendingXfersMsg(ptwMsg);
        break;
    case DAT_SETUPMEMXFER:
        twRc = OnSetupMemXferMsg(ptwMsg);
        break;
    case DAT_SETUPFILEXFER:
        twRc = OnSetupFileXferMsg(ptwMsg);
        break;
    case DAT_XFERGROUP:
        twRc = OnXferGroupMsg(ptwMsg);
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::DispatchImageMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (!ptwMsg) {
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        return TWRC_FAILURE;
    }

    switch (ptwMsg->DAT) {
    case DAT_IMAGEINFO:
        twRc = OnImageInfoMsg(ptwMsg);
        break;
    case DAT_IMAGELAYOUT:
        twRc = OnImageLayoutMsg(ptwMsg);
        break;
    case DAT_IMAGEMEMXFER:
        twRc = OnImageMemXferMsg(ptwMsg);
        break;
    case DAT_IMAGENATIVEXFER:
        twRc = OnImageNativeXferMsg(ptwMsg);
        break;
    case DAT_IMAGEFILEXFER:
        twRc = OnImageFileXferMsg(ptwMsg);
        break;
    case DAT_PALETTE8:
        twRc = OnPalette8Msg(ptwMsg);
        break;
    case DAT_GRAYRESPONSE:
        twRc = OnGrayResponseMsg(ptwMsg);
        break;
    case DAT_RGBRESPONSE:
        twRc = OnRGBResponseMsg(ptwMsg);
        break;
    case DAT_CIECOLOR:
        twRc = OnCIEColorMsg(ptwMsg);;
        break;
    case DAT_JPEGCOMPRESSION:
        twRc = OnJPEGCompressionMsg(ptwMsg);
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnPalette8Msg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnPalette8Msg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
    case DS_STATE_7:
        switch (ptwMsg->MSG) {
        case MSG_GET:

            // TWPA_RGB     - color palette
            // TWPA_GRAY    - grayscale palette
            // TWPA_CMY     - CMY palette

            ((TW_PALETTE8 *)ptwMsg->pData)->NumColors = 0;
            ((TW_PALETTE8 *)ptwMsg->pData)->PaletteType = TWPA_RGB;
            break;
        case MSG_GETDEFAULT:
        case MSG_RESET:
        case MSG_SET:
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
        }
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnSetupMemXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnSetupMemXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_SETUPMEMXFER *pMemSetup = (TW_SETUPMEMXFER *)ptwMsg->pData;

    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
        if (MSG_GET == ptwMsg->MSG) {
            if (pMemSetup) {
                pMemSetup->MinBufSize = MIN_MEMXFER_SIZE;
                pMemSetup->MaxBufSize = MAX_MEMXFER_SIZE;
                pMemSetup->Preferred  = PREFERRED_MEMXFER_SIZE;
            } else {
                m_twStatus.ConditionCode = TWCC_BADVALUE;
                twRc = TWRC_FAILURE;
            }
        } else {
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
        }
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnSetupFileXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnSetupFileXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    CCap *pImageXferCap = NULL;
    TW_SETUPFILEXFER *pFileXfer = NULL;
    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
        pFileXfer = (TW_SETUPFILEXFER *)ptwMsg->pData;
        pImageXferCap = FindCap(ICAP_IMAGEFILEFORMAT);
        switch (ptwMsg->MSG) {
        case MSG_GET:
        case MSG_GETDEFAULT:
        case MSG_GETCURRENT:
            if (pImageXferCap) {
                pFileXfer->Format = (TW_UINT16)pImageXferCap->GetCurrent();
                pFileXfer->VRefNum = 0;
                pFileXfer->FileName[0] = 0;
                strcpy(pFileXfer->FileName, m_FileXferName);
            } else {
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BUMMER;
            }
            break;
        case MSG_SET:
            {
                strcpy(m_FileXferName, pFileXfer->FileName);
                pImageXferCap->SetCurrent((VOID*)&pFileXfer->Format);
            }
            break;
        default:
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            DSError();
            break;
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnXferGroupMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnXferGroupMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
        switch (ptwMsg->MSG) {
        case MSG_GET:
        case MSG_GETDEFAULT:
        case MSG_GETCURRENT:
        case MSG_RESET:
            *((TW_UINT16 *)ptwMsg->pData) = DG_IMAGE;
            break;
        case MSG_SET:
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
            break;
        }
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageInfoMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageInfoMsg());
    TW_UINT16 twRc = TWRC_FAILURE;
    TW_IMAGEINFO *ptwImageInfo = NULL;
    if (DS_STATE_6 == GetTWAINState()) {
        if (MSG_GET == ptwMsg->MSG) {
            ptwImageInfo = (TW_IMAGEINFO *)ptwMsg->pData;
            HRESULT hr = S_OK;
            hr = m_pDevice->GetImageInfo(m_pCurrentIWiaItem, &m_MemoryTransferInfo);
            if (SUCCEEDED(hr)) {

                ptwImageInfo->ImageWidth      = (TW_INT32)m_MemoryTransferInfo.mtiWidthPixels;
                ptwImageInfo->ImageLength     = (TW_INT32)m_MemoryTransferInfo.mtiHeightPixels;
                ptwImageInfo->BitsPerPixel    = (TW_INT16)m_MemoryTransferInfo.mtiBitsPerPixel;
                ptwImageInfo->SamplesPerPixel = (TW_INT16)m_MemoryTransferInfo.mtiNumChannels;
                ptwImageInfo->Planar          = (TW_BOOL)m_MemoryTransferInfo.mtiPlanar;

                //
                // adjust height for unknown length acquisitions
                //

                if(ptwImageInfo->ImageLength == 0){
                    DBG_WRN(("CWiaDataSrc::OnImageInfoMsg(), Possible unknown length device detected..checking cached height value"));
                    ptwImageInfo->ImageLength = m_ImageHeight;
                    if(ptwImageInfo->ImageLength == 0){
                        DBG_WRN(("CWiaDataSrc::OnImageInfoMsg(), no cached height available, defaulting to -1 (ICAP_UNDEFINEDIMAGESIZE support only)"));
                        ptwImageInfo->ImageLength = -1; // unknown page length (only valid if TWAIN applications support ICAP_UNDEFINEDIMAGESIZE)
                    } else {
                        DBG_TRC(("CWiaDataSrc::OnImageInfoMsg(), new height = %d",ptwImageInfo->ImageLength));
                    }
                }

                //
                // set PixelType to corresponding TWAIN pixel type
                //

                switch(m_MemoryTransferInfo.mtiDataType) {
                case WIA_DATA_THRESHOLD:
                    ptwImageInfo->PixelType = TWPT_BW;
                    break;
                case WIA_DATA_GRAYSCALE:
                    ptwImageInfo->PixelType = TWPT_GRAY;
                    break;
                case WIA_DATA_COLOR:
                default:
                    ptwImageInfo->PixelType = TWPT_RGB;
                    break;
                }

                //
                // set compression to NONE
                //

                ptwImageInfo->Compression = TWCP_NONE;

                //
                // Unit conversion.......
                //

                ptwImageInfo->XResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiXResolution);
                ptwImageInfo->YResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiYResolution);

                twRc = TWRC_SUCCESS;

            } else {
                m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
                twRc = TWRC_FAILURE;
            }

            if (TWRC_SUCCESS == twRc) {
                DBG_TRC(("CWiaDataSrc::OnImageInfoMsg(), Reported Image Information from data source"));
                DBG_TRC(("XResolution     = %d.%d",ptwImageInfo->XResolution.Whole,ptwImageInfo->XResolution.Frac));
                DBG_TRC(("YResolution     = %d.%d",ptwImageInfo->YResolution.Whole,ptwImageInfo->YResolution.Frac));
                DBG_TRC(("ImageWidth      = %d",ptwImageInfo->ImageWidth));
                DBG_TRC(("ImageLength     = %d",ptwImageInfo->ImageLength));
                DBG_TRC(("SamplesPerPixel = %d",ptwImageInfo->SamplesPerPixel));

                memset(ptwImageInfo->BitsPerSample,0,sizeof(ptwImageInfo->BitsPerSample));

                if (ptwImageInfo->BitsPerPixel < 24) {
                    ptwImageInfo->BitsPerSample[0] = ptwImageInfo->BitsPerPixel;
                } else {
                    for (int i = 0; i < ptwImageInfo->SamplesPerPixel; i++) {
                        ptwImageInfo->BitsPerSample[i] = (ptwImageInfo->BitsPerPixel/ptwImageInfo->SamplesPerPixel);
                    }
                }
                // (bpp / spp) = bps
                DBG_TRC(("BitsPerSample   = [%d],[%d],[%d],[%d],[%d],[%d],[%d],[%d]",ptwImageInfo->BitsPerSample[0],
                         ptwImageInfo->BitsPerSample[1],
                         ptwImageInfo->BitsPerSample[2],
                         ptwImageInfo->BitsPerSample[3],
                         ptwImageInfo->BitsPerSample[4],
                         ptwImageInfo->BitsPerSample[5],
                         ptwImageInfo->BitsPerSample[6],
                         ptwImageInfo->BitsPerSample[7]));
                DBG_TRC(("BitsPerPixel    = %d",ptwImageInfo->BitsPerPixel));
                DBG_TRC(("Planar          = %d",ptwImageInfo->Planar));
                DBG_TRC(("PixelType       = %d",ptwImageInfo->PixelType));
                DBG_TRC(("Compression     = %d",ptwImageInfo->Compression));
            }
        } else {
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
        }
    } else {
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
    }
    if (TWRC_SUCCESS != twRc) {
        DSError();
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageLayoutMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnGrayResponseMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnRGBResponseMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnCIEColorMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnJPEGCompressionMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnIdentityMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnIdentityMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    if (ptwMsg) {
        switch (ptwMsg->MSG) {
        case MSG_OPENDS:

#ifdef DEBUG_ME
            MessageBox(NULL,TEXT("MSG_OPENDS - Attach me to a debugger"),TEXT("Attach me to a debugger"),MB_OK);
#endif

            twRc = OpenDS(ptwMsg);
            break;
        case MSG_CLOSEDS:
            twRc = CloseDS(ptwMsg);
            break;
        case MSG_GET:
            if (!IsBadWritePtr(ptwMsg->pData, sizeof(TW_IDENTITY))) {
                *(TW_IDENTITY*)ptwMsg->pData = m_dsIdentity;
                DBG_TRC(("CWiaDataSrc::OnIdentityMsg(), Reported TW_IDENTITY from data source"));
                DBG_TRC(("Id            = %d",m_dsIdentity.Id));
                DBG_TRC(("Manufacturer  = %s",m_dsIdentity.Manufacturer));
                DBG_TRC(("ProductFamily = %s",m_dsIdentity.ProductFamily));
                DBG_TRC(("ProductName   = %s",m_dsIdentity.ProductName));
                DBG_TRC(("ProtocolMajor = %d",m_dsIdentity.ProtocolMajor));
                DBG_TRC(("ProtocolMinor = %d",m_dsIdentity.ProtocolMinor));
                DBG_TRC(("SupportedGrps = %d",m_dsIdentity.SupportedGroups));
                DBG_TRC(("Ver Country   = %d",m_dsIdentity.Version.Country));
                DBG_TRC(("Ver Info      = %s",m_dsIdentity.Version.Info));
                DBG_TRC(("Ver Language  = %d",m_dsIdentity.Version.Language));
                DBG_TRC(("Ver MajorNum  = %d",m_dsIdentity.Version.MajorNum));
                DBG_TRC(("Ver MinorNum  = %d",m_dsIdentity.Version.MinorNum));
                twRc = TWRC_SUCCESS;
            } else {
                twRc = TWCC_BADVALUE;
            }
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
            break;
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnUserInterfaceMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnUserInterfaceMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    switch (ptwMsg->MSG) {
    case MSG_ENABLEDS:
        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            twRc = EnableDS((TW_USERINTERFACE*)ptwMsg->pData);
            break;
        }
        break;
    case MSG_DISABLEDS:
            twRc = DisableDS((TW_USERINTERFACE*)ptwMsg->pData);
        break;
    default:
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnCapabilityMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnCapabilityMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_UINT16 twCC = TWCC_SUCCESS;

    TW_CAPABILITY *ptwCap = (TW_CAPABILITY *)ptwMsg->pData;
    if (!ptwCap) {
        m_twStatus.ConditionCode = TWCC_BADCAP;
        return TWRC_FAILURE;
    }
    if (CAP_SUPPORTEDCAPS == ptwCap->Cap) {
        switch(ptwMsg->MSG) {
        case MSG_SET:
        case MSG_RESET:
            {
                //
                // MSG_SET, MSG_RESET shouldn't be able to be called on CAP_SUPPORTEDCAPS!!
                //

                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_CAPBADOPERATION;
                return twRc;
            }
        default:
            break;
        }

        //
        // get number of PRIVATE TWAIN capabilities from WIA driver
        // and add them to our CAP_SUPPORTEDCAPS list.
        //

        LONG lNumPrivateCaps = 0;
        LONG *pPrivateCapArray = NULL;
        lNumPrivateCaps = GetPrivateSupportedCapsFromWIADevice(&pPrivateCapArray);

        ptwCap->ConType = TWON_ARRAY;
        ptwCap->hContainer = GlobalAlloc(GHND, sizeof(TW_ARRAY) + sizeof(TW_UINT16) * (m_NumCaps + lNumPrivateCaps) );
        if (ptwCap->hContainer) {
            TW_ARRAY *pCapIdArray = (TW_ARRAY *) GlobalLock(ptwCap->hContainer);
            if (pCapIdArray) {
                TW_UINT32 i = 0;
                pCapIdArray->ItemType = TWTY_UINT16;
                TW_UINT16 *ItemList;
                ItemList = (TW_UINT16 *)pCapIdArray->ItemList;

                //
                // fill in TWAIN compat layer's supported CAPS first
                //

                for (i = 0; i < m_NumCaps; i++) {
                    ItemList[i] = m_CapList[i].GetCapId();
                }

                //
                // fill in WIA driver's private supported CAPS next
                //

                int PrivateCapIndex = 0;
                for(i = m_NumCaps; i < (m_NumCaps + lNumPrivateCaps);i++){
                    ItemList[i] = (TW_UINT16)pPrivateCapArray[PrivateCapIndex];
                    DBG_TRC(("(%d) Private Capability ID reported = %x",(PrivateCapIndex + 1), ItemList[i]));
                    PrivateCapIndex++;
                }

                //
                // finally set NumItems
                //

                pCapIdArray->NumItems = (m_NumCaps + lNumPrivateCaps);

                GlobalUnlock(ptwCap->hContainer);
            } else {
                GlobalFree(ptwCap->hContainer);
                ptwCap->hContainer = NULL;
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_LOWMEMORY;
            }
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_LOWMEMORY;
        }

        //
        // delete Private capability array, if it was allocated
        //

        if(pPrivateCapArray){
            GlobalFree(pPrivateCapArray);
            pPrivateCapArray = NULL;
        }

        return twRc;
    }

    CCap *pCap = FindCap(ptwCap->Cap);
    if (!pCap) {
        DBG_TRC(("Couldn't find the CCap object for CAP ID %x in TWAIN Compat layer CAP list, try WIA driver's private TWAIN cap list", ptwCap->Cap));
        if (m_pDevice->TwainCapabilityPassThrough()) {
            return OnPrivateCapabilityMsg(ptwMsg);
        } else {
            m_twStatus.ConditionCode = TWCC_BADCAP;
            return TWRC_FAILURE;
        }
    }
    switch (ptwMsg->MSG) {
    case MSG_GET:
        if(ptwCap->Cap == ICAP_IMAGEDATASET)
            twCC = pCap->GetCurrent(ptwCap);
        else
            twCC = pCap->Get(ptwCap);
        break;
    case MSG_GETDEFAULT:
        twCC = pCap->GetDefault(ptwCap);
        break;
    case MSG_GETCURRENT:
        twCC = pCap->GetCurrent(ptwCap);
        break;
    case MSG_SET:
        switch (GetTWAINState()) {
        case DS_STATE_7:
            twCC = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            twCC = SetCapability(pCap, ptwCap);
            break;
        }
        break;
    case MSG_RESET:
        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            twCC = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            {
                //      ptwCap->Cap,
                //      ptwCap->ConType,
                //      ptwCap->hContainer);

                twCC = pCap->Reset();

                //
                // According to the TWAIN spec, a MSG_RESET can be sent down meaning more than just
                // RESET!!!  It is stated that it can mean GET_DEFAULT/CURRENT, and RESET in a single call.
                // Applications choose to ignore the value returned if they don't care, But if they
                // attempt to read the value as the DEFAULT/CURRENT value...it must be set correctly in the
                // container.
                //

                //
                // fill the container with the current value, after the
                // RESET call.
                //

                twCC = pCap->GetCurrent(ptwCap);

                //      ptwCap->ConType);
            }
            break;
        }
        break;
    default:
        twCC = TWCC_BADPROTOCOL;
        DSError();
        break;
    }

    m_twStatus.ConditionCode = twCC;

    if (TWCC_SUCCESS != twCC) {
        twRc = TWRC_FAILURE;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnPrivateCapabilityMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnPrivateCapabilityMsg());
    TW_UINT16 twRc = TWRC_FAILURE;
    m_twStatus.ConditionCode = TWCC_BADCAP;

    if (ptwMsg) {

        if (ptwMsg->MSG == MSG_SET) {
            TW_CAPABILITY *ptwCap = (TW_CAPABILITY *)ptwMsg->pData;
            if (ptwCap) {
                if ((NULL == ptwCap->hContainer)||(INVALID_HANDLE_VALUE == ptwCap->hContainer)) {
                    return twRc;
                }
            }
        }

        if (m_pCurrentIWiaItem) {

            //
            // Get the IWiaItemExtras Interface
            //

            IWiaItemExtras *pIWiaItemExtras = NULL;
            HRESULT hr = m_pCurrentIWiaItem->QueryInterface(IID_IWiaItemExtras,(void **)&pIWiaItemExtras);
            if (S_OK == hr) {

                //
                // we have an IWiaItemExtras Interface, so lets talk to the WIA device about
                // the capability message
                //

                TW_CAPABILITY *ptwCap = (TW_CAPABILITY *)ptwMsg->pData;
                if (ptwCap) {

                    //
                    // Initialize the common header
                    //

                    TWAIN_CAPABILITY twCap;
                    twCap.lSize    = sizeof(twCap);     // size of TWAIN_CAPABILITY structure
                    twCap.lMSG     = ptwMsg->MSG;       // TWAIN message
                    twCap.lCapID   = ptwCap->Cap;       // TWAIN capability ID
                    twCap.lConType = ptwCap->ConType;   // TWAIN container type
                    twCap.lCC      = TWCC_BADCAP;       // TWAIN return code
                    twCap.lRC      = TWRC_FAILURE;      // TWAIN condition code
                    twCap.lDataSize= 0;                 // TWAIN capability data size
                    twCap.Data[0]  = 0;                 // TWAIN capability data (first byte)

                    DBG_TRC(("== Private TWAIN_CAPABILITY data Header =="));
                    DBG_TRC(("twCap.lSize     = %d", twCap.lSize));
                    DBG_TRC(("twCap.lMSG      = %d", twCap.lMSG));
                    DBG_TRC(("twCap.lCapID    = %x", twCap.lCapID));
                    DBG_TRC(("twCap.lConType  = %d", twCap.lConType));
                    DBG_TRC(("twCap.lCC       = %d", twCap.lCC));
                    DBG_TRC(("twCap.lRC       = %d", twCap.lRC));

                    DWORD dwInDataSize        = 0;
                    DWORD dwOutDataSize       = 0;
                    DWORD dwContainerSize     = 0;
                    DWORD dwActualOutDataSize = 0;

                    BYTE *pInData             = NULL;
                    BYTE *pOutData            = NULL;
                    BYTE *pContainerData      = NULL;
                    TWAIN_CAPABILITY *pHeader = NULL;

                    //
                    // Depending on the Message type GET ot SET we do different things
                    //

                    //
                    // For a SET or RESET message, we just send the IN buffer, with an OUT buffer
                    // containing the header.
                    //

                    if ((ptwMsg->MSG == MSG_SET) ||
                        (ptwMsg->MSG == MSG_RESET)) {

                        dwContainerSize = 0;

                        if (ptwMsg->MSG == MSG_SET) {

                            //
                            // only check container size, when the TWAIN message is a MSG_SET
                            // MSG_RESET operations do not have containers attached.
                            //

                            dwContainerSize     = (DWORD)GlobalSize(ptwCap->hContainer);
                        }

                        dwInDataSize        = dwContainerSize + sizeof(twCap);
                        dwOutDataSize       = sizeof(twCap);
                        dwActualOutDataSize = dwOutDataSize;

                        twCap.lDataSize           = dwContainerSize;
                        DBG_TRC(("twCap.lDataSize = %d", twCap.lDataSize));

                        DBG_TRC(("== Processing MSG_SET or MSG_RESET Capability Message =="));
                        DBG_TRC(("dwInDataSize        = %d",dwInDataSize));
                        DBG_TRC(("dwOutDataSize       = %d",dwOutDataSize));
                        DBG_TRC(("dwActualOutDataSize = %d",dwActualOutDataSize));
                        DBG_TRC(("dwContainerSize     = %d",dwContainerSize));

                        //
                        // allocate IN buffer and write TWAIN_CAPABILITY header
                        //

                        if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pInData,dwInDataSize)) {

                            if (ptwMsg->MSG == MSG_SET) {

                                //
                                // copy TWAIN container data to IN buffer
                                //

                                if (TWRC_SUCCESS == CopyContainerToPrivateCapBuffer(pInData,ptwCap->hContainer)) {

                                    //
                                    // container data was copied to IN buffer
                                    //

                                    DBG_TRC(("Container data was successfully copied, we are processing a MSG_SET"));

                                } else {

                                    //
                                    // could not copy TWAIN container data into private capability IN buffer
                                    //

                                    DBG_ERR(("could not copy TWAIN container data into private capability IN buffer"));

                                    if(pInData){
                                        GlobalFree(pInData);
                                        pInData = NULL;
                                    }

                                    return twRc;    // return here, becuase we can not continue
                                }

                            } else {

                                //
                                // no container data needs to be copied
                                //

                                DBG_TRC(("No Container data was copied, because we are processing a MSG_RESET"));

                            }

                            //
                            // allocate OUT buffer and write TWAIN_CAPABILITY header
                            //

                            if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pOutData,dwOutDataSize)) {
                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_CAPABILITY,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             &dwActualOutDataSize);
                                if (S_OK == hr) {
                                    pHeader = (TWAIN_CAPABILITY*)pOutData;
                                    DBG_TRC(("== Returned TWAIN_CAPABILITY data Header from WIA device =="));
                                    DBG_TRC(("pHeader->lSize     = %d", pHeader->lSize));
                                    DBG_TRC(("pHeader->lMSG      = %d", pHeader->lMSG));
                                    DBG_TRC(("pHeader->lCapID    = %x", pHeader->lCapID));
                                    DBG_TRC(("pHeader->lConType  = %d", pHeader->lConType));
                                    DBG_TRC(("pHeader->lCC       = %d", pHeader->lCC));
                                    DBG_TRC(("pHeader->lRC       = %d", pHeader->lRC));
                                    DBG_TRC(("pHeader->lDataSize = %d", pHeader->lDataSize));

                                    twRc = (TW_UINT16)pHeader->lRC;
                                    m_twStatus.ConditionCode = (TW_UINT16)pHeader->lCC;
                                } else {

                                    //
                                    // pIWiaItemExtras->Escape call failed,
                                    // a failure means that we do not respond with a success to the TWAIN application
                                    //

                                    DBG_ERR(("pIWiaItemExtras->Escape Failed"));
                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %p)",
                                             ESC_TWAIN_CAPABILITY,
                                             pInData,
                                             dwInDataSize,
                                             pOutData,
                                             dwOutDataSize,
                                             &dwActualOutDataSize));
                                }
                            } else {

                                //
                                // could not allocate memory for private capability OUT buffer
                                //

                                DBG_ERR(("could not allocate memory for private capability OUT buffer"));

                            }

                        } else {

                            //
                            // could not allocate memory for private capability IN buffer
                            //

                            DBG_ERR(("could not allocate memory for private capability IN buffer"));

                        }
                    } else if ((ptwMsg->MSG == MSG_GET) ||
                               (ptwMsg->MSG == MSG_GETCURRENT) ||
                               (ptwMsg->MSG == MSG_GETDEFAULT)) {

                        dwContainerSize     = 0;
                        dwInDataSize        = sizeof(twCap);
                        dwOutDataSize       = dwInDataSize;
                        dwActualOutDataSize = dwInDataSize;

                        twCap.lDataSize     = dwContainerSize;
                        DBG_TRC(("twCap.lDataSize = %d", twCap.lDataSize));

                        DBG_TRC(("== Processing MSG_GET, MSG_GETCURRENT, or MSG_GETDEFAULT Capability Message =="));
                        DBG_TRC(("dwInDataSize        = %d",dwInDataSize));
                        DBG_TRC(("dwOutDataSize       = %d",dwOutDataSize));
                        DBG_TRC(("dwActualOutDataSize = %d",dwActualOutDataSize));
                        DBG_TRC(("dwContainerSize     = %d",dwContainerSize));

                        //
                        // allocate IN buffer and write TWAIN_CAPABILITY header
                        //

                        if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pInData,dwInDataSize)) {

                            //
                            // ask the WIA driver how large is the data, so
                            // we can allocate the proper OUT buffer
                            //

                            //
                            // allocate OUT buffer and write TWAIN_CAPABILITY header
                            //

                            if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pOutData,dwOutDataSize)) {

                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_CAPABILITY,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             &dwActualOutDataSize);
                                if (S_OK == hr) {

                                    //
                                    // make sure that the returned data is large enough to
                                    // contain a proper header.
                                    //

                                    if (dwActualOutDataSize == dwInDataSize) {

                                        pHeader = (TWAIN_CAPABILITY*)pOutData;
                                        DBG_TRC(("== Returned TWAIN_CAPABILITY data Header from WIA device =="));
                                        DBG_TRC(("pHeader->lSize     = %d", pHeader->lSize));
                                        DBG_TRC(("pHeader->lMSG      = %d", pHeader->lMSG));
                                        DBG_TRC(("pHeader->lCapID    = %x", pHeader->lCapID));
                                        DBG_TRC(("pHeader->lConType  = %d", pHeader->lConType));
                                        DBG_TRC(("pHeader->lCC       = %d", pHeader->lCC));
                                        DBG_TRC(("pHeader->lRC       = %d", pHeader->lRC));
                                        DBG_TRC(("pHeader->lDataSize = %d", pHeader->lDataSize));

                                        if (pHeader->lDataSize > 0) {

                                            //
                                            // update common header data size from information returned
                                            // to create OUT buffer header
                                            //

                                            twCap.lDataSize = pHeader->lDataSize;

                                            //
                                            // set new out data size to (data + header) size
                                            //

                                            dwOutDataSize = (pHeader->lDataSize + sizeof(twCap));

                                            //
                                            // update InBuffer header data size from the common header
                                            //

                                            pHeader = (TWAIN_CAPABILITY*)pInData;
                                            pHeader->lDataSize = twCap.lDataSize;

                                            //
                                            // free old out buffer, before allocating new one
                                            //

                                            if (pOutData) {
                                                GlobalFree(pOutData);
                                                pOutData = NULL;
                                            }

                                            //
                                            // allocate OUT buffer and write TWAIN_CAPABILITY header
                                            //

                                            if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pOutData,dwOutDataSize)) {
                                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_CAPABILITY,
                                                                             pInData,
                                                                             dwInDataSize,
                                                                             pOutData,
                                                                             dwOutDataSize,
                                                                             &dwActualOutDataSize);
                                                if (S_OK == hr) {
                                                    pHeader = (TWAIN_CAPABILITY*)pOutData;
                                                    DBG_TRC(("== Returned TWAIN_CAPABILITY data Header from WIA device =="));
                                                    DBG_TRC(("pHeader->lSize     = %d", pHeader->lSize));
                                                    DBG_TRC(("pHeader->lMSG      = %d", pHeader->lMSG));
                                                    DBG_TRC(("pHeader->lCapID    = %x", pHeader->lCapID));
                                                    DBG_TRC(("pHeader->lConType  = %d", pHeader->lConType));
                                                    DBG_TRC(("pHeader->lCC       = %d", pHeader->lCC));
                                                    DBG_TRC(("pHeader->lRC       = %d", pHeader->lRC));
                                                    DBG_TRC(("pHeader->lDataSize = %d", pHeader->lDataSize));
                                                    twRc = (TW_UINT16)pHeader->lRC;
                                                    m_twStatus.ConditionCode = (TW_UINT16)pHeader->lCC;
                                                    if (TWRC_SUCCESS == twRc) {
                                                        if (TWRC_SUCCESS == CopyPrivateCapBufferToContainer(&ptwCap->hContainer,pOutData,pHeader->lDataSize)) {
                                                            ptwCap->ConType = (TW_UINT16)pHeader->lConType;
                                                        } else {

                                                            //
                                                            // could not copy private capability buffer into TWAIN container data
                                                            //

                                                            DBG_ERR(("could not copy private capability buffer into TWAIN container data"));

                                                        }
                                                    } else {

                                                        //
                                                        // WIA driver failed the TWAIN capability request, by returning a TWAIN failure
                                                        // return code in the OUT header.
                                                        //

                                                        DBG_ERR(("WIA driver failed the TWAIN capability request, by returning a TWAIN failure return code in the OUT header."));

                                                    }
                                                } else {

                                                    //
                                                    // pIWiaItemExtras->Escape call failed, (sending passthrough operation)
                                                    // a failure means that we do not respond with a success to the TWAIN application
                                                    //

                                                    DBG_ERR(("pIWiaItemExtras->Escape Failed (sending passthrough operation)"));
                                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                                             ESC_TWAIN_CAPABILITY,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             dwActualOutDataSize));

                                                }
                                            } else {

                                                //
                                                // could not allocate memory for private capability OUT buffer
                                                //

                                                DBG_ERR(("could not allocate memory for private capability OUT buffer"));

                                            }
                                        } else {

                                            //
                                            // OUT buffer size returned from the WIA driver is too small to contain a
                                            // proper header.
                                            //

                                            DBG_ERR(("OUT buffer size (%d) returned from the WIA driver is too small to contain data",pHeader->lDataSize));

                                        }
                                    } else {

                                        //
                                        // OUT buffer size returned from the WIA driver is too small to contain a
                                        // proper header.
                                        //

                                        DBG_ERR(("OUT buffer size (%d) returned from the WIA driver is too small to contain a proper header",dwActualOutDataSize));

                                    }
                                } else {

                                    //
                                    // pIWiaItemExtras->Escape call failed, (requesting OUT buffer size)
                                    // a failure means that we do not respond with a success to the TWAIN application
                                    //

                                    DBG_ERR(("pIWiaItemExtras->Escape Failed (requesting OUT buffer size)"));
                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                             ESC_TWAIN_CAPABILITY,
                                             pInData,
                                             dwInDataSize,
                                             pInData,
                                             dwInDataSize,
                                             dwActualOutDataSize));
                                }
                            } else {

                                //
                                // could not allocate memory for private capability OUT buffer
                                //

                                DBG_ERR(("could not allocate memory for private capability OUT buffer"));

                            }
                        } else {

                            //
                            // could not allocate memory for private capability IN buffer
                            //

                            DBG_ERR(("could not allocate memory for private capability IN buffer"));

                        }
                    }

                    //
                    // free IN buffer
                    //

                    if (pInData) {
                        GlobalFree(pInData);
                        pInData = NULL;
                    }

                    //
                    // free OUT buffer
                    //

                    if (pOutData) {
                        GlobalFree(pOutData);
                        pOutData = NULL;
                    }
                } else {

                    //
                    // could not get TWAIN capability from TWAIN message
                    //

                    DBG_ERR(("could not get TWAIN capability from TWAIN message"));
                }

                //
                // release IWiaItemExtras Interface
                //

                if (pIWiaItemExtras) {
                    pIWiaItemExtras->Release();
                    pIWiaItemExtras = NULL;
                }
            } else {

                //
                // QI for IWiaItemExtras Failed
                //

                DBG_ERR(("QueryInterface for IWiaItemExtras Failed"));

            }
        } else {

            //
            // no current item selected
            //

            DBG_ERR(("no current item selected for use"));

        }
    } else {

        //
        // imcoming TWAIN capability is NULL
        //

        DBG_ERR(("incoming TWAIN capability is NULL"));

    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::AllocatePrivateCapBuffer(TWAIN_CAPABILITY *pHeader, BYTE** ppBuffer, DWORD dwSize)
{
    DBG_FN_DS(CWiaDataSrc::AllocatePrivateCapBuffer());
    if(dwSize < sizeof(TWAIN_CAPABILITY) || (!ppBuffer)|| (!pHeader)){
        return TWRC_FAILURE;
    }

    *ppBuffer = (BYTE*)GlobalAlloc(GPTR,dwSize);
    if(*ppBuffer){
        memcpy(*ppBuffer, pHeader,sizeof(TWAIN_CAPABILITY));
    } else {
        return TWRC_FAILURE;
    }

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::CopyContainerToPrivateCapBuffer(BYTE* pBuffer, HGLOBAL hContainer)
{
    DBG_FN_DS(CWiaDataSrc::CopyContainerToPrivateCapBuffer());
    if((!pBuffer)||(!hContainer)){
        return TWRC_FAILURE;
    }

    DWORD dwContainerSize = (DWORD)GlobalSize(hContainer);
    BYTE *pContainerBuffer = (BYTE*)GlobalLock(hContainer);
    if(!pContainerBuffer){
        return TWRC_FAILURE;
    }

    TWAIN_CAPABILITY *pHeader = (TWAIN_CAPABILITY*)pBuffer;
    memcpy((BYTE*)pHeader->Data,pContainerBuffer,dwContainerSize);

    //
    // unlock handle before returning
    //

    GlobalUnlock(hContainer);

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::CopyPrivateCapBufferToContainer(HGLOBAL *phContainer, BYTE* pBuffer, DWORD dwSize)
{
    DBG_FN_DS(CWiaDataSrc::CopyPrivateCapBufferToContainer());
    if((!phContainer) || (!pBuffer) || (dwSize <= 0)){
        return TWRC_FAILURE;
    }

    *phContainer = NULL;
    *phContainer = (HGLOBAL)GlobalAlloc(GHND,dwSize);
    if(!*phContainer){
        return TWRC_FAILURE;
    }

    BYTE *pContainerBuffer = (BYTE*)GlobalLock(*phContainer);
    if(!pContainerBuffer){
        GlobalFree(*phContainer);
        *phContainer = NULL;
        return TWRC_FAILURE;
    }

    TWAIN_CAPABILITY *pHeader = (TWAIN_CAPABILITY*)pBuffer;

    memcpy(pContainerBuffer,(BYTE*)pHeader->Data,dwSize);

    //
    // unlock handle before returning
    //

    GlobalUnlock(*phContainer);

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    DBG_FN_DS(CWiaDataSrc::SetCapability());
    if (!pCap || !ptwCap) {
        m_twStatus.ConditionCode = TWCC_BADCAP;
        return TWRC_FAILURE;
    }

    return pCap->Set(ptwCap);
}

TW_UINT16 CWiaDataSrc::OnStatusMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnStatusMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (MSG_GET == ptwMsg->MSG) {
        *((TW_STATUS*)ptwMsg->pData) = m_twStatus;
        twRc = TWRC_SUCCESS;
    } else {
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnImageMemXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageMemXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    HRESULT hr = E_FAIL;
    switch (GetTWAINState()) {
    case DS_STATE_6:
    case DS_STATE_7:
        {
            if (MSG_GET == ptwMsg->MSG) {
                TW_IMAGEMEMXFER *pMemXfer = (TW_IMAGEMEMXFER *)ptwMsg->pData;

                if ((m_hMemXferBits == NULL)) {

                    m_LinesTransferred = 0;

                    GUID guidFormat = GUID_NULL;

                    DBG_WRN(("Transferring %d bit data",m_MemoryTransferInfo.mtiBitsPerPixel));
                    if (m_MemoryTransferInfo.mtiBitsPerPixel > 32) {

                        //
                        // Load image into memory for memory transfer (hi-color images)
                        //

                        guidFormat = WiaImgFmt_RAWRGB;
                    } else {

                        //
                        // The TWAIN compatibility layer has the ability to transfer images
                        // 1,2,4,8,16,24 and 32 bit when using MEMORYBMP.
                        //

                        guidFormat = WiaImgFmt_MEMORYBMP;
                    }

                    twRc = TransferToMemory(guidFormat);

                    if (TWRC_SUCCESS != twRc) {
                        return twRc;
                    } else {

                        //
                        // transition to STATE_7
                        //

                        SetTWAINState(DS_STATE_7);
                    }
                }

                //
                // turn off the Image caching flag
                //

                m_bCacheImage = FALSE;

                //
                // Lock down the memory and get the address to the bits
                //

                GetMemoryTransferBits((BYTE*)GlobalLock(m_hMemXferBits));

                m_pMemXferBits = m_MemoryTransferInfo.mtipBits;

                if (m_pMemXferBits) {
                    if(m_MemoryTransferInfo.mtiHeightPixels == 0){
                        m_MemoryTransferInfo.mtiHeightPixels = m_ImageHeight;
                    }

                    if(m_MemoryTransferInfo.mtiguidFormat == WiaImgFmt_MEMORYBMP){

                        //
                        // adjust the image information to report the actual information
                        // reported in the BITMAPINFO header.
                        //

                        //
                        // only change these values, if the current information does not
                        // match the image header. (always take the header's values)
                        //

                        if(m_MemoryTransferInfo.mtiHeightPixels != m_ImageHeight){
                            m_MemoryTransferInfo.mtiHeightPixels = m_ImageHeight;
                        }

                        if(m_MemoryTransferInfo.mtiWidthPixels != m_ImageWidth){
                            m_MemoryTransferInfo.mtiWidthPixels = m_ImageWidth;
                        }

                    }

                    DBG_TRC(("CWiaDataSrc::OnImageMemXferMsg(), Transferring (%d) of (%d) total lines of image data.",m_LinesTransferred,m_MemoryTransferInfo.mtiHeightPixels));
                    if (m_LinesTransferred >= (TW_UINT32)m_MemoryTransferInfo.mtiHeightPixels) {

                        //
                        // we have completed the transfer, or we are out
                        // of scan lines to copy..so return XFERDONE
                        //

                        //
                        // unlock memory before bailing
                        //

                        // Keep unlock and NULLing together
                        GlobalUnlock(m_hMemXferBits);
                        m_pMemXferBits = NULL;

                        ResetMemXfer();
                        m_twStatus.ConditionCode = TWCC_SUCCESS;

                        return TWRC_XFERDONE;
                    } else {

                        //
                        // looks like we are working with transfer data
                        //

                        BYTE * pAppBuffer = NULL;
                        if (pMemXfer->Memory.Flags & TWMF_HANDLE) {

                            DBG_TRC(("TWAIN Application wants to work with a HANDLE"));

                            //
                            // if the memory is a HANDLE, lock it first
                            //

                            pAppBuffer = (LPBYTE)GlobalLock(pMemXfer->Memory.TheMem);
                        } else if (pMemXfer->Memory.Flags & TWMF_POINTER) {

                            DBG_TRC(("TWAIN Application wants to work with a POINTER"));

                            //
                            // if the memory is a POINTER, then proceed
                            //

                            pAppBuffer = (LPBYTE)pMemXfer->Memory.TheMem;
                        } else {

                            DBG_TRC(("TWAIN Application gave us nothing to work with"));

                            //
                            // we have no memory, so set it to NULL
                            //

                            pAppBuffer = NULL;
                        }

                        //
                        // if (there is no Memory to write to), or
                        //    (the app doesn't own the memory), or
                        //    (the length is less than MIN_  ), or
                        //    (the length is greater than MAX),
                        //    return a FAILURE!, and a CC of BADVALUE
                        //

                        if (!pAppBuffer ||
                            !(pMemXfer->Memory.Flags & TWMF_APPOWNS) ||
                            pMemXfer->Memory.Length < MIN_MEMXFER_SIZE ||
                            pMemXfer->Memory.Length > MAX_MEMXFER_SIZE) {

                            twRc = TWRC_FAILURE;
                            m_twStatus.ConditionCode = TWCC_BADVALUE;

                        } else {

                            //
                            // set memory Xfer values
                            //

                            UINT ScanlinesToCopy   = 0;
                            pMemXfer->BytesPerRow  = GetLineSize(&m_MemoryTransferInfo);
                            ScanlinesToCopy        = min(pMemXfer->Memory.Length / pMemXfer->BytesPerRow,
                                                         (TW_UINT32)(m_MemoryTransferInfo.mtiHeightPixels - m_LinesTransferred));

                            pMemXfer->Compression  = TWCP_NONE;
                            pMemXfer->Columns      = m_MemoryTransferInfo.mtiWidthPixels;
                            pMemXfer->Rows         = ScanlinesToCopy;
                            pMemXfer->XOffset      = 0;
                            pMemXfer->YOffset      = m_LinesTransferred;
                            pMemXfer->BytesWritten = pMemXfer->BytesPerRow * ScanlinesToCopy;

#ifdef DEBUG_MEMXFER
                            DBG_TRC(("CWiaDataSrc::OnImageMemXferMsg(), Reports TW_IMAGEMEMXFER"));
                            DBG_TRC(("pMemXfer->Compression  = %d",pMemXfer->Compression));
                            DBG_TRC(("pMemXfer->Columns      = %d",pMemXfer->Columns));
                            DBG_TRC(("pMemXfer->Rows         = %d",pMemXfer->Rows));
                            DBG_TRC(("pMemXfer->XOffset      = %d",pMemXfer->XOffset));
                            DBG_TRC(("pMemXfer->YOffset      = %d",pMemXfer->YOffset));
                            DBG_TRC(("pMemXfer->BytesPerRow  = %d",pMemXfer->BytesPerRow));
                            DBG_TRC(("pMemXfer->BytesWritten = %d",pMemXfer->BytesWritten));
                            DBG_TRC(("pAppBuffer = %p, m_pMemXferBits = %p",pAppBuffer,m_pMemXferBits));
#endif
                            //
                            // Transfer one-line strips in a loop to Application supplied buffer
                            //

                            LPBYTE  pTo   = pAppBuffer;
                            LPBYTE  pFrom = m_pMemXferBits + m_LinesTransferred * GetLineSize(&m_MemoryTransferInfo);
                            for (UINT i=0;i < ScanlinesToCopy;i++ ) {

                                //
                                // swap color values, if needed
                                //

                                if (m_MemoryTransferInfo.mtiBitsPerPixel == 24) {
                                    for (ULONG ulIndex = 0; ulIndex < pMemXfer->BytesPerRow; ulIndex+= 3) {

                                        //  1    2    3
                                        // RED-GREEN-BLUE
                                        //

                                        BYTE bFirst = pFrom[ulIndex];
                                        pFrom[ulIndex]    = pFrom[ulIndex+2];
                                        pFrom[ulIndex+2]  = bFirst;
                                    }
                                }

                                /*
                                if(m_MemoryTransferInfo.mtiBitsPerPixel == 48){
                                    for(j = 0; j < pMemXfer->BytesPerRow; j+=6){

                                        //  1  2    1    2     1  2
                                        // REDRED-GREENGREEN-BLUEBLUE
                                        //

                                        BYTE bFirst  = pFrom[j];
                                        BYTE bSecond = pFrom[j+1];
                                        pFrom[j]     = pFrom[j+4];
                                        pFrom[j+1]   = pFrom[j+5];
                                        pFrom[j+4]   = bFirst;
                                        pFrom[j+5]   = bSecond;
                                    }
                                }
                                */

                                //
                                // copy line to application supplied buffer
                                //

                                memcpy(pTo,pFrom,pMemXfer->BytesPerRow);
                                pFrom+=GetLineSize(&m_MemoryTransferInfo);
                                pTo+=pMemXfer->BytesPerRow;
                            }

                            //
                            // calculate lines transferred
                            //

                            m_LinesTransferred += ScanlinesToCopy;
                            if (m_LinesTransferred >= (TW_UINT32)m_MemoryTransferInfo.mtiHeightPixels) {

                                //
                                // we have completed the transfer, or we are out
                                // of scan lines to copy..so return XFERDONE
                                //

                                twRc = TWRC_XFERDONE;
                                m_twStatus.ConditionCode = TWCC_SUCCESS;

                                // Keep unlock and NULLing together
                                GlobalUnlock(m_hMemXferBits);
                                m_pMemXferBits = NULL;

                                ResetMemXfer();

                                //
                                // if we are working with an application provided HANDLE,
                                // GlobalUnlock it before continuing
                                //

                                if (pMemXfer->Memory.Flags & TWMF_HANDLE) {
                                    GlobalUnlock(pMemXfer->Memory.TheMem);
                                }

                                return twRc;
                            }

                            //
                            // if we are working with an application provided HANDLE,
                            // GlobalUnlock it before continuing
                            //

                            if (pMemXfer->Memory.Flags & TWMF_HANDLE) {
                                GlobalUnlock(pMemXfer->Memory.TheMem);
                            }
                        }
                    }

                    //
                    // unlock buffer when finished
                    //

                    // Keep unlock and NULLing together
                    GlobalUnlock(m_hMemXferBits);
                    m_pMemXferBits = NULL;


                } else {

                    //
                    // Could not lock down memory for transfer
                    //

                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    return TWRC_FAILURE;
                }

            } else {

                //
                // we recieved a message other than the expected MSG_GET
                //

                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            }
        }
        break;
    default:
        {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            return twRc;
            break;
        }
        break;
    }

    //
    // if we failed, report it properly
    //

    if (TWRC_FAILURE == twRc)
        DSError();

    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageFileXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageFileXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (MSG_GET == ptwMsg->MSG) {
        GUID guidFileFormat = WiaImgFmt_BMP;

        CCap *pCap = FindCap(ICAP_IMAGEFILEFORMAT);
        if(pCap){
            guidFileFormat = ICAP_IMAGEFILEFORMAT_TO_WIA_IPA_FORMAT((TW_UINT16)pCap->GetCurrent());
        }

        twRc = TransferToFile(guidFileFormat);
        if(TWRC_XFERDONE == twRc) {
            SetTWAINState(DS_STATE_7);
        } else {
            DBG_ERR(("CWiaDataSrc::OnImageFileXferMsg(), TransferToFile() failed"));
        }
    } else {
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
    }

    if (TWRC_FAILURE == twRc){
        DSError();
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageNativeXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageNativeXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    HGLOBAL hDIB = NULL;

    switch (GetTWAINState()) {
    case DS_STATE_6:
        {
            if (MSG_GET == ptwMsg->MSG) {
                twRc = TransferToDIB(&hDIB);
                if (TWRC_XFERDONE == twRc) {
                    SetTWAINState(DS_STATE_7);
                    *(TW_UINT32*)ptwMsg->pData = (TW_UINT32)(INT_PTR)hDIB;
                } else {
                    DBG_ERR(("CWiaDataSrc::OnImageNativeXferMsg(), TransferToDIB() failed"));
                }
            } else {
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            }
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        break;
    }

    if (TWRC_FAILURE == twRc){
        DSError();
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OpenDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OpenDS());
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (DS_STATE_3 == GetTWAINState()) {
        //
        // No multiple clients are allowed.
        // This is enforced by making sure that our identity's id field
        // has a value of 0.
        if (m_dsIdentity.Id) {

            m_twStatus.ConditionCode = TWCC_MAXCONNECTIONS;
            twRc = TWRC_FAILURE;
        } else {
            //
            // make a copy of the caller's identity
            //
            m_AppIdentity = *ptwMsg->AppId;
            m_dsIdentity = *((TW_IDENTITY *)ptwMsg->pData);
            HRESULT hr = S_OK;
            hr = m_pDevice->Open(CWiaDataSrc::DeviceEventCallback,
                                 (LPARAM)this);
            if (FAILED(hr)) {
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BUMMER;
            }
        }
    } else {
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
    }

    if (TWRC_SUCCESS == twRc) {

        //
        // transition to STATE_4
        //

        SetTWAINState(DS_STATE_4);
    }

    if (TWRC_SUCCESS != twRc) {
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::CloseDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::CloseDS());
    TW_UINT16 twRc = TWRC_SUCCESS;

    switch (GetTWAINState()) {
    case DS_STATE_7:
    case DS_STATE_6:
    case DS_STATE_5:
    case DS_STATE_4:
        m_pDevice->Close();
        //DBG_TRC(("Calling ResetMemXfer because CLOSEDS was called"));
        ResetMemXfer();
        //
        // We are up for sale again.
        //
        m_AppIdentity.Id = 0;

        //
        // transition to STATE_3
        //

        SetTWAINState(DS_STATE_3);

        if (m_pIWiaItems)
            delete [] m_pIWiaItems;
        m_pIWiaItems = NULL;
        m_NumIWiaItems = 0;
        m_NextIWiaItemIndex = 0;
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::EnableDS(TW_USERINTERFACE *pUI)
{
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::DisableDS(TW_USERINTERFACE *pUI)
{
    DBG_FN_DS(CWiaDataSrc::DisableDS());
    TW_UINT16 twRc = TWRC_SUCCESS;
    switch (GetTWAINState()) {
    case DS_STATE_5:

        //
        // transition to STATE_4
        //

        SetTWAINState(DS_STATE_4);
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::CreateCapList(TW_UINT32 NumCaps,PCAPDATA  pCapData)
{
    DBG_FN_DS(CWiaDataSrc::CreateCapList());
    if (!NumCaps || !pCapData)
        return TWCC_BADVALUE;

    TW_UINT16 twCc = TWCC_SUCCESS;

    DestroyCapList();
    m_CapList = new CCap[NumCaps];
    if (m_CapList) {

        for (m_NumCaps = 0; m_NumCaps < NumCaps; m_NumCaps++) {
            twCc  = m_CapList[m_NumCaps].ICap(&pCapData[m_NumCaps]);
            if (TWCC_SUCCESS != twCc) {
                break;
            }
        }
        m_NumCaps = NumCaps;

    } else {
        twCc = TWCC_LOWMEMORY;
    }

    if (TWCC_SUCCESS != twCc && m_CapList) {
        DestroyCapList();
    }

    return twCc;
}

TW_UINT16 CWiaDataSrc::DestroyCapList()
{
    DBG_FN_DS(CWiaDataSrc::DestroyCapList());
    if (m_CapList) {
        delete [] m_CapList;
        m_CapList = NULL;
    }
    m_NumCaps = 0;
    return TWCC_SUCCESS;
}

CCap * CWiaDataSrc::FindCap(TW_UINT16 CapId)
{
    TW_UINT32 ui32;
    for (ui32 = 0; ui32 < m_NumCaps; ui32++) {
        if (m_CapList[ui32].GetCapId() == CapId)
            return &m_CapList[ui32];
    }
    return NULL;
}

void CWiaDataSrc::DSError()
{
    DBG_FN_DS(CWiaDataSrc::DSError());
    NotifyCloseReq();
}

HRESULT CALLBACK CWiaDataSrc::DeviceEventCallback(LONG lEvent,LPARAM lParam)
{
    CWiaDataSrc *pDataSrc = NULL;
    pDataSrc = (CWiaDataSrc *)lParam;
    if (pDataSrc) {
        pDataSrc->NotifyCloseReq();
        return S_OK;
    }
    return E_FAIL;
}

DS_STATE CWiaDataSrc::SetTWAINState(DS_STATE NewTWAINState)
{
    DBG_TRC(("(Transitioning From TWAIN STATE %d to TWAIN STATE %d)",m_dsState,NewTWAINState));
    m_dsState = NewTWAINState;
    return m_dsState;
}

DS_STATE CWiaDataSrc::GetTWAINState()
{
    return m_dsState;
}

TW_UINT16 CWiaDataSrc::SetStatusTWCC(TW_UINT16 NewConditionCode)
{
    m_twStatus.ConditionCode = NewConditionCode;
    return NewConditionCode;
}

float CWiaDataSrc::ConvertToTWAINUnits(LONG lValue, LONG lResolution)
{
    float fReturnValue = 0.0f;
    CCap *pUnits = FindCap(ICAP_UNITS);
    if(pUnits){
        switch (pUnits->GetCurrent()) {
        case TWUN_INCHES:
            fReturnValue = (float)lValue / (float)lResolution;
            break;
        case TWUN_CENTIMETERS:
            fReturnValue = (float)((lValue * 2.54) / (float)lResolution);
            break;
        case TWUN_PICAS:
            fReturnValue = (float)((lValue * 6.00) / (float)lResolution);
            break;
        case TWUN_POINTS:
            fReturnValue = (float)(((float)lValue * 72.0) / (float)lResolution);
            break;
        case TWUN_PIXELS:
        default:
            fReturnValue = (float)lValue;
            break;
        }
    }
    return fReturnValue;
}

LONG CWiaDataSrc::ConvertFromTWAINUnits(float fValue, LONG lResolution)
{
    LONG lReturnValue = 0;
    CCap *pUnits = FindCap(ICAP_UNITS);
    if (pUnits) {
        switch (pUnits->GetCurrent()) {
        case TWUN_INCHES:
            lReturnValue = (LONG)((float)fValue * (float)lResolution);
            break;
        case TWUN_CENTIMETERS:
            lReturnValue = (LONG)(((float)fValue / 2.54) * (float)lResolution);
            break;
        case TWUN_PICAS:
            lReturnValue = (LONG)(((float)fValue / 6.00) * (float)lResolution);
            break;
        case TWUN_POINTS:
            lReturnValue = (LONG)(((float)fValue / 72.0) * (float)lResolution);
            break;
        case TWUN_PIXELS:
        default:
            lReturnValue = (LONG)fValue;
            break;
        }
    }
    return lReturnValue;
}

DWORD CWiaDataSrc::ReadTwainRegistryDWORDValue(LPTSTR szRegValue, DWORD dwDefault)
{
    DBG_FN_DS(CWiaDataSrc::ReadTwainRegistryDWORDValue());
    DWORD dwValue = 0;
    DWORD dwType = REG_DWORD;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDisposition = REG_OPENED_EXISTING_KEY;
    HKEY hTwainRootKey = NULL;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,TWAIN_REG_KEY,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,
                       NULL,&hTwainRootKey,&dwDisposition)){

        if(dwDisposition == REG_CREATED_NEW_KEY){
            DBG_WRN(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Created Root Twain Registry Key"));
        }

        if (ERROR_SUCCESS == RegQueryValueEx(hTwainRootKey,szRegValue,NULL,&dwType,(BYTE*)&dwValue,&dwDataSize)) {
            #ifdef UNICODE
                DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Reading %ws Registry Key Value = %d",szRegValue,dwValue));
            #else
                DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Reading %s Registry Key Value = %d",szRegValue,dwValue));
            #endif
        } else {
            // reset sizes, just for safety
            dwType = REG_DWORD;
            dwDataSize = sizeof(DWORD);
            dwValue = dwDefault;
            if(ERROR_SUCCESS == RegSetValueEx(hTwainRootKey,szRegValue,NULL,dwType,(BYTE*)&dwDefault,dwDataSize)){
                #ifdef UNICODE
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Writing Default Value for %ws Registry Key Value = %d",szRegValue,dwDefault));
                #else
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Writing Default Value for %s Registry Key Value = %d",szRegValue,dwDefault));
                #endif
            } else {
                #ifdef UNICODE
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Error Reading %ws Registry Key Value",szRegValue));
                #else
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Error Reading %s Registry Key Value",szRegValue));
                #endif
            }
        }

        RegCloseKey(hTwainRootKey);
        hTwainRootKey = NULL;
    } else {
        DBG_ERR(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), could not open Root TWAIN Registry Key"));
    }
    return dwValue;
}

LONG CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice(LONG **ppCapArray)
{
    DBG_FN_DS(CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice());
    if (!ppCapArray) {
        DBG_ERR(("CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice(), ppCapArray is NULL"));
        return 0;
    }

    *ppCapArray = NULL;
    LONG lNumPrivateCaps = 0;
    if (m_pDevice) {
        if (m_pDevice->TwainCapabilityPassThrough()) {
            if (m_pCurrentIWiaItem) {

                //
                // Get the IWiaItemExtras Interface
                //

                IWiaItemExtras *pIWiaItemExtras = NULL;
                HRESULT hr = m_pCurrentIWiaItem->QueryInterface(IID_IWiaItemExtras,(void **)&pIWiaItemExtras);
                if (S_OK == hr) {

                    //
                    // set data sizes
                    //

                    DWORD dwInDataSize        = 0;
                    DWORD dwOutDataSize       = 0;
                    DWORD dwActualOutDataSize = 0;

                    BYTE *pInData  = NULL;
                    BYTE *pOutData = NULL;

                    LONG lCapabilityDataSize = sizeof(LONG);
                    pOutData      = (BYTE*)&lCapabilityDataSize;
                    pInData       = (BYTE*)&lCapabilityDataSize;

                    dwActualOutDataSize = sizeof(LONG);
                    dwInDataSize        = dwActualOutDataSize;
                    dwOutDataSize       = dwActualOutDataSize;

                    //
                    // ask how many bytes are needed to store the private TWAIN capabilities the WIA driver supports
                    //

                    hr = pIWiaItemExtras->Escape(ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                                 pInData,
                                                 dwInDataSize,
                                                 pOutData,
                                                 dwOutDataSize,
                                                 &dwActualOutDataSize);
                    if (S_OK == hr) {

                        lCapabilityDataSize = (LONG)(*pOutData);

                        lNumPrivateCaps = (lCapabilityDataSize / sizeof(LONG));

                        DBG_TRC(("WIA device reported %d private TWAIN supported CAPS",lNumPrivateCaps));

                        if (lNumPrivateCaps > 0) {

                            //
                            // allocate an array of LONGs for the WIA driver to fill with
                            // CAP ids.
                            //

                            dwOutDataSize = (lCapabilityDataSize + PRIVATE_CAP_ARRAY_PADDING);
                            dwActualOutDataSize = dwOutDataSize;

                            *ppCapArray = (LONG*)GlobalAlloc(GPTR,dwOutDataSize);
                            if (*ppCapArray) {

                                pOutData = (BYTE*)*ppCapArray;

                                //
                                // ask the WIA driver to fill the array of LONGS
                                //

                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             &dwActualOutDataSize);
                                if (FAILED(hr)) {

                                    //
                                    // pIWiaItemExtras->Escape call failed,
                                    // a failure means that there are no private supported capabilities
                                    //

                                    DBG_ERR(("pIWiaItemExtras->Escape Failed (sending a request for the cability array data)"));
                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                             ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                             pInData,
                                             dwInDataSize,
                                             pOutData,
                                             dwOutDataSize,
                                             dwActualOutDataSize));
                                }
                            } else {
                                DBG_ERR(("could not allocate memory for private capability array of %d items (%d bytes - this includes padding)",lNumPrivateCaps,dwOutDataSize));
                                lNumPrivateCaps = 0;
                                *ppCapArray = NULL;
                            }
                        } else {

                            //
                            // no supported caps
                            //

                            DBG_TRC(("No private supported caps reported from WIA device"));

                        }

                    } else {

                        //
                        // pIWiaItemExtras->Escape call failed,
                        // a failure means that there are no private supported capabilities
                        //

                        DBG_ERR(("pIWiaItemExtras->Escape Failed (sending a request for the number of capabilities)"));
                        DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                 ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                 pInData,
                                 dwInDataSize,
                                 pOutData,
                                 dwOutDataSize,
                                 dwActualOutDataSize));
                    }

                    //
                    // release IWiaItemExtras Interface
                    //

                    if (pIWiaItemExtras) {
                        pIWiaItemExtras->Release();
                        pIWiaItemExtras = NULL;
                    }
                } else {

                    //
                    // QI for IWiaItemExtras Failed
                    //

                    DBG_ERR(("QueryInterface for IWiaItemExtras Failed"));

                }
            } else {

                //
                // no current item selected
                //

                DBG_ERR(("no current item selected for use"));

            }
        }
    } else {

        //
        // m_pDevice is NULL
        //

        DBG_ERR(("CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice(), m_pDevice is NULL"));
    }
    return lNumPrivateCaps;
}

TW_UINT16 CWiaDataSrc::TransferToFile(GUID guidFormatID)
{
    DBG_FN_DS(CWiaDataSrc::TransferToFile());
    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;

    CWiaDataCallback DataCallback;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_INDICATORS);
    if(pCap){
        DataCallback.Initialize(NULL,pCap->GetCurrent());
    } else {
        DataCallback.Initialize(NULL,TRUE);
    }

    IWiaDataCallback *pIDataCB = NULL;
    hr = DataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIDataCB);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->LoadImageToDisk(m_pCurrentIWiaItem, m_FileXferName, guidFormatID, pIDataCB);
        if (SUCCEEDED(hr)) {
            twRc = TWRC_XFERDONE;
            m_twStatus.ConditionCode = TWCC_SUCCESS;
        }
        pIDataCB->Release();
        pIDataCB = NULL;
    }

    //
    // check for a cancel, or out-of-paper error (scanners could return this)
    //

    if ((S_FALSE == hr) || (WIA_ERROR_PAPER_EMPTY == hr)) {
        m_twStatus.ConditionCode = TWCC_SUCCESS;

        if(WIA_ERROR_PAPER_EMPTY == hr) {
            DBG_TRC(("CWiaDataSrc::TransferToFile(), WIA_ERROR_PAPER_EMPTY returned from source."));
        }

        //
        // set XFERCOUNT
        //

        CCap *pxferCap = FindCap(CAP_XFERCOUNT);
        if (pxferCap) {
            pxferCap->SetCurrent((TW_UINT32)0);
        }

        //
        // return a cancel to abort the transfer.
        // Applications will most commonly delete the current
        // image, and keep the previous images.
        //

        twRc = TWRC_CANCEL;
    } else if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_FROM_HRESULT(hr);
        twRc = TWRC_FAILURE;
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::TransferToDIB(HGLOBAL *phDIB)
{
    DBG_FN_DS(CWiaDataSrc::TransferToDIB());
    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;

    CWiaDataCallback DataCallback;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_INDICATORS);
    if(pCap){
        DataCallback.Initialize(NULL,pCap->GetCurrent());
    } else {
        DataCallback.Initialize(NULL,TRUE);
    }

    IWiaDataCallback *pIDataCB = NULL;
    hr = DataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIDataCB);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->LoadImage(m_pCurrentIWiaItem, WiaImgFmt_MEMORYBMP, pIDataCB);   // memory bmp only
        if (SUCCEEDED(hr)) {
            if(SUCCEEDED(DataCallback.GetImage(phDIB, NULL))){

                //
                // DIB data (special case) - NATIVE TWAIN transfers are in DIB format always
                // If we are acquiring DIB data, then we have to apply the
                // height rules:
                // positive = image is right side up
                // negative = image is up side down
                // zero     = image has an unknown length (and assumed to be upside down)

                if(FlipDIB(*phDIB)){
                    twRc = TWRC_XFERDONE;
                    m_ImageHeight = (TW_UINT32)DataCallback.GetImageHeight();
                    m_ImageWidth = (TW_UINT32)DataCallback.GetImageWidth();
                }
            }
        }
        pIDataCB->Release();
        pIDataCB = NULL;
    }

    //
    // check for a cancel, or out-of-paper error (scanners could return this)
    //

    if ((S_FALSE == hr) || (WIA_ERROR_PAPER_EMPTY == hr)) {
        m_twStatus.ConditionCode = TWCC_SUCCESS;

        if(WIA_ERROR_PAPER_EMPTY == hr) {
            DBG_TRC(("CWiaDataSrc::TransferToDIB(), WIA_ERROR_PAPER_EMPTY returned from source."));
        }

        //
        // set XFERCOUNT
        //

        CCap *pxferCap = FindCap(CAP_XFERCOUNT);
        if (pxferCap) {
            pxferCap->SetCurrent((TW_UINT32)0);
        }

        //
        // return a cancel to abort the transfer.
        // Applications will most commonly delete the current
        // image, and keep the previous images.
        //

        twRc = TWRC_CANCEL;
    } else if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_FROM_HRESULT(hr);
        twRc = TWRC_FAILURE;
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::TransferToMemory(GUID guidFormatID)
{
    DBG_FN_DS(CWiaDataSrc::TransferToMemory());

    //
    // set WIA format in Transfer Information structure
    //

    m_MemoryTransferInfo.mtiguidFormat = guidFormatID;

    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;
    CWiaDataCallback DataCallback;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_INDICATORS);
    if(pCap){
        DataCallback.Initialize(NULL,pCap->GetCurrent());
    } else {
        DataCallback.Initialize(NULL,TRUE);
    }

    IWiaDataCallback *pIDataCB = NULL;
    hr = DataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIDataCB);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->LoadImage(m_pCurrentIWiaItem, guidFormatID, pIDataCB);
        if (SUCCEEDED(hr)) {
            if(SUCCEEDED(DataCallback.GetImage(&m_hMemXferBits, NULL))){

                //
                // check for DIB data (special case)
                // If we are acquiring DIB data, then we have to apply the
                // height rules:
                // positive = image is right side up
                // negative = image is up side down
                // zero     = image has an unknown length (and assumed to be upside down)

                if(WiaImgFmt_MEMORYBMP == guidFormatID){

                    //
                    // for memory transfers we need to make sure that the image
                    // is upside down in memory, so the application can assemble
                    // the bands correctly.
                    //

                    FlipDIB(m_hMemXferBits, TRUE);
                }

                m_ImageHeight = (TW_UINT32)DataCallback.GetImageHeight();
                m_ImageWidth = (TW_UINT32)DataCallback.GetImageWidth();
                m_hCachedImageData = m_hMemXferBits;
                twRc = TWRC_SUCCESS;
            }
        }
        pIDataCB->Release();
        pIDataCB = NULL;
    }

    //
    // check for a cancel, or out-of-paper error (scanners could return this)
    //

    if ((S_FALSE == hr) || (WIA_ERROR_PAPER_EMPTY == hr)) {
        m_twStatus.ConditionCode = TWCC_SUCCESS;

        if(WIA_ERROR_PAPER_EMPTY == hr) {
            DBG_TRC(("CWiaDataSrc::TransferToMemory(), WIA_ERROR_PAPER_EMPTY returned from source."));
        }

        //
        // set XFERCOUNT
        //

        CCap *pxferCap = FindCap(CAP_XFERCOUNT);
        if (pxferCap) {
            pxferCap->SetCurrent((TW_UINT32)0);
        }

        //
        // return a cancel to abort the transfer.
        // Applications will most commonly delete the current
        // image, and keep the previous images.
        //

        twRc = TWRC_CANCEL;
    } else if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_FROM_HRESULT(hr);
        twRc = TWRC_FAILURE;
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCachedImage(HGLOBAL *phImage)
{
    DBG_FN_DS(CWiaDataSrc::GetCachedImage());
    TW_UINT16 twRc = TWRC_FAILURE;
    if(phImage){
        if (m_hCachedImageData) {
            *phImage = m_hCachedImageData;

            //
            // since we are giving out the cached data
            // reset the cache handle to NULL;
            //

            m_hCachedImageData = NULL;
            m_hMemXferBits = NULL;
            twRc = TWRC_SUCCESS;
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::TransferToThumbnail(HGLOBAL *phThumbnail)
{
    DBG_FN_DS(CWiaDataSrc::TransferToThumbnail());
    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;
    hr = m_pDevice->LoadThumbnail(m_pCurrentIWiaItem,phThumbnail,NULL);
    if (SUCCEEDED(hr)) {
        twRc = TWRC_XFERDONE;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCommonSettings()
{
    DBG_FN_DS(CWiaDataSrc::GetCommonSettings());
    TW_UINT16 twRc = TWRC_FAILURE;

    //
    // Some TWAIN applications make the assumption that the TWAIN data source
    // defaults to BMP/DIB data formats.  This is on the basis that TWAIN
    // spec minimal requirements are BMP/DIB.  WIA minimal requirements are
    // BMP/DIB. Set the current Format GUID to MEMORYBMP, and TYMED to
    // TYMED_CALLBACK.  This will set the WIA driver to transfer bitmap data
    // by default.  This does not limit the data types in any way.  A high
    // end application will properly read the valid TWAIN values and configure
    // the device to do the correct thing.
    //

    //
    // before configuring TWAIN valid values, set the WIA device to TYMED_CALLBACK, MEMORYBMP.
    //

    HRESULT hr = S_OK;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), failed to set IWiaItem for property writing"));
        return twRc;
    }

    hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_CALLBACK);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), failed to set TYMED_CALLBACK as a default setting"));
        return twRc;
    }

    hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT,WiaImgFmt_MEMORYBMP);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), failed to set WiaImgFmt_MEMORYBMP as a default setting"));
        return twRc;
    }

    if (TWRC_SUCCESS == GetPixelTypes()) {
        if (TWRC_SUCCESS == GetCompressionTypes()) {
            if (TWRC_SUCCESS == GetBitDepths()) {
                if (TWRC_SUCCESS == GetImageFileFormats()) {
                    twRc = TWRC_SUCCESS;
                } else {
                    DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetImageFileFormats()"));
                }
            } else {
                DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetBitDepths() failed"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetCompressionTypes() failed"));
        }
    } else {
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetPixelTypes() failed"));
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCommonDefaultSettings()
{
    DBG_FN_DS(CWiaDataSrc::GetCommonDefaultSettings());
    TW_UINT16 twRc = TWRC_FAILURE;
    CCap *pCap = NULL;
    TW_UINT16 CapDataArray[1];

    pCap = FindCap(ICAP_PIXELTYPE);
    if (pCap) {
        CapDataArray[0] = TWPT_RGB;
        twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);
        if (TWRC_SUCCESS == twRc) {

            pCap = FindCap(ICAP_COMPRESSION);
            if (pCap) {
                CapDataArray[0] = TWCP_NONE;
                twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);

                pCap = FindCap(ICAP_BITDEPTH);
                if (pCap) {
                    CapDataArray[0] = 24;
                    twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);
                    if (TWRC_SUCCESS == twRc) {

                        pCap = FindCap(ICAP_IMAGEFILEFORMAT);
                        if (pCap) {
                            CapDataArray[0] = TWFF_BMP;
                            twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);
                            if (TWRC_SUCCESS == twRc) {

                            }
                        }
                    }
                }
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetPixelTypes()
{
    DBG_FN_DS(CWiaScannerDS::GetPixelTypes());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_PIXELTYPE);
    if (pCap) {

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount  = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 *pPixelTypeArray = NULL;

        //
        // read current value, for default and current index settings
        //

        LONG lCurrentDataTypeValue = WIA_DATA_COLOR;

        //
        // read current WIA_IPA_DATATYPE setting
        //

        hr = WIA.ReadPropertyLong(WIA_IPA_DATATYPE,&lCurrentDataTypeValue);
        if (SUCCEEDED(hr)) {

            //
            // read valid values for WIA_IPA_DATATYPE
            //

            PROPVARIANT pv;
            memset(&pv,0,sizeof(pv));
            LONG lAccessFlags = 0;
            hr = WIA.ReadPropertyAttributes(WIA_IPA_DATATYPE,&lAccessFlags,&pv);
            if (SUCCEEDED(hr)) {
                if (lAccessFlags & WIA_PROP_LIST) {

                    //
                    // for each valid WIA value in the LIST, set a corresponding
                    // TWAIN value
                    //

                    pPixelTypeArray = new TW_UINT16[WIA_PROP_LIST_COUNT(&pv)];
                    if (pPixelTypeArray) {
                        memset(pPixelTypeArray,0,(sizeof(TW_UINT16)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {

                            switch (pv.caul.pElems[i+2]) {
                            case WIA_DATA_THRESHOLD:
                                pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_BW;
                                if (lCurrentDataTypeValue == WIA_DATA_THRESHOLD) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_DATA_THERSHOLD -> TWPT_BW"));
                                break;
                            case WIA_DATA_GRAYSCALE:
                                pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_GRAY;
                                if (lCurrentDataTypeValue == WIA_DATA_GRAYSCALE) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_DATA_GRAYSCALE -> TWPT_GRAY"));
                                break;
                            case WIA_DATA_COLOR:
                                pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_RGB;
                                if (lCurrentDataTypeValue == WIA_DATA_COLOR) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_DATA_COLOR -> TWPT_RGB"));
                                break;
                            case WIA_DATA_DITHER:
                            case WIA_DATA_COLOR_THRESHOLD:
                            case WIA_DATA_COLOR_DITHER:
                                ////////////////////////////////
                                // NO TWAIN -> WIA CONVERSION //
                                ////////////////////////////////
                                //
                                // TWPT_PALETTE
                                // TWPT_CMY
                                // TWPT_CMYK
                                // TWPT_YUV
                                // TWPT_YUVK
                                // TWPT_CIEXYZ
                            default:
                                DBG_TRC(("WIA Data Type (%d) does not MAP to TWAIN a pixel type",pv.caul.pElems[i+2]));
                                break;
                            }
                        }
                    } else {
                        DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to allocate Pixel Type Array Memory"));
                    }
                } else {

                    //
                    // we only have 1 value, so make it the current, default and valid value.
                    //

                    pPixelTypeArray = new TW_UINT16[1];
                    if (pPixelTypeArray) {
                        memset(pPixelTypeArray,0,(sizeof(TW_UINT16)));

                        switch (lCurrentDataTypeValue) {
                        case WIA_DATA_THRESHOLD:
                            pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_BW;
                            if (lCurrentDataTypeValue == WIA_DATA_THRESHOLD) {
                                CurrentIndex = ActualCount;
                            }
                            ActualCount++;
                            DBG_TRC(("WIA driver supports WIA_DATA_THERSHOLD -> TWPT_BW"));
                            break;
                        case WIA_DATA_GRAYSCALE:
                            pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_GRAY;
                            if (lCurrentDataTypeValue == WIA_DATA_GRAYSCALE) {
                                CurrentIndex = ActualCount;
                            }
                            ActualCount++;
                            DBG_TRC(("WIA driver supports WIA_DATA_GRAYSCALE -> TWPT_GRAY"));
                            break;
                        case WIA_DATA_COLOR:
                            pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_RGB;
                            if (lCurrentDataTypeValue == WIA_DATA_COLOR) {
                                CurrentIndex = ActualCount;
                            }
                            ActualCount++;
                            DBG_TRC(("WIA driver supports WIA_DATA_COLOR -> TWPT_RGB"));
                            break;
                        case WIA_DATA_DITHER:
                        case WIA_DATA_COLOR_THRESHOLD:
                        case WIA_DATA_COLOR_DITHER:
                            ////////////////////////////////
                            // NO TWAIN -> WIA CONVERSION //
                            ////////////////////////////////
                            //
                            // TWPT_PALETTE
                            // TWPT_CMY
                            // TWPT_CMYK
                            // TWPT_YUV
                            // TWPT_YUVK
                            // TWPT_CIEXYZ
                        default:
                            DBG_TRC(("WIA Data Type (%d) does not MAP to TWAIN a pixel type",lCurrentDataTypeValue));
                            break;
                        }
                    } else {
                        DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to allocate Pixel Type Array Memory"));
                    }
                }

                if (pPixelTypeArray) {

                    //
                    // default index is equal to current index, because we are stating that the WIA driver
                    // is a fresh start-up state.
                    //

                    DefaultIndex = CurrentIndex;

                    twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)pPixelTypeArray,TRUE); // list
                    delete [] pPixelTypeArray;
                    pPixelTypeArray = NULL;

                    //twRc = TWRC_SUCCESS;
                }

                PropVariantClear(&pv);
            } else {
                DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to read WIA_IPS_DATATYPE attributes"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to read WIA_IPS_DATATYPE current value"));
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetBitDepths()
{
    DBG_FN_DS(CWiaScannerDS::GetBitDepths());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_BITDEPTH);
    if (pCap) {

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetBitDepths(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount  = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 BitDepthArray[MAX_BITDEPTHS];
        memset(BitDepthArray,0,sizeof(BitDepthArray));

        //
        // read current value, for default and current index settings
        //

        LONG lCurrentDataTypeValue = WIA_DATA_COLOR;
        LONG lCurrentBitDepthValue = 24;

        //
        // read current WIA_IPA_DATATYPE setting
        //

        hr = WIA.ReadPropertyLong(WIA_IPA_DATATYPE,&lCurrentDataTypeValue);
        if (SUCCEEDED(hr)) {

            //
            // read current WIA_IPA_DEPTH setting
            //

            hr = WIA.ReadPropertyLong(WIA_IPA_DEPTH,&lCurrentBitDepthValue);
            if (SUCCEEDED(hr)) {

                PROPVARIANT pv;
                memset(&pv,0,sizeof(pv));
                LONG lAccessFlags = 0;

                //
                // read valid values for WIA_IPA_DATATYPE
                //

                hr = WIA.ReadPropertyAttributes(WIA_IPA_DATATYPE,&lAccessFlags,&pv);
                if (SUCCEEDED(hr)) {

                    //
                    // for each valid value, set it to the current setting, and read
                    // the valid values for WIA_IPA_DEPTH.
                    //

                    if (lAccessFlags & WIA_PROP_LIST) {

                        //
                        // set the WIA_IPA_DATATYPE to each valid value in the LIST
                        //

                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {

                            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,(LONG)pv.caul.pElems[i+2]);
                            if (SUCCEEDED(hr)) {

                                //
                                // read valid values for WIA_IPA_DEPTH
                                //

                                lAccessFlags = 0;
                                PROPVARIANT pvDepth;
                                memset(&pvDepth,0,sizeof(pvDepth));
                                hr = WIA.ReadPropertyAttributes(WIA_IPA_DEPTH,&lAccessFlags,&pvDepth);
                                if (SUCCEEDED(hr)) {
                                    LONG lBitDepth = 0;
                                    if (lAccessFlags & WIA_PROP_LIST) {

                                        //
                                        // copy each valid value in the LIST to the array
                                        //

                                        for (ULONG ulIndex = 0; ulIndex < WIA_PROP_LIST_COUNT(&pvDepth);ulIndex++) {
                                            lBitDepth = pvDepth.caul.pElems[ulIndex+2];
                                            for (ULONG BitDepthArrayIndex = 0; BitDepthArrayIndex < MAX_BITDEPTHS; BitDepthArrayIndex++) {

                                                if (BitDepthArray[BitDepthArrayIndex] == 0) {

                                                    //
                                                    // the current slot is (0) zero, so add the new bit depth value
                                                    //

                                                    BitDepthArray[BitDepthArrayIndex] = (TW_UINT16)lBitDepth;
                                                    DBG_TRC(("WIA driver supports %d bit depth",lBitDepth));
                                                    ActualCount++;

                                                    //
                                                    // exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                } else if (BitDepthArray[BitDepthArrayIndex] == (TW_UINT16)lBitDepth) {

                                                    //
                                                    // bit depth is already in the list, so exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                }
                                            }
                                        }
                                    } else if (lAccessFlags & WIA_PROP_NONE) {

                                        //
                                        // read the current value for WIA_IPA_DEPTH
                                        // and copy it to the array
                                        //

                                        hr = WIA.ReadPropertyLong(WIA_IPA_DEPTH,&lBitDepth);
                                        if (SUCCEEDED(hr)) {
                                            for (ULONG BitDepthArrayIndex = 0; BitDepthArrayIndex < MAX_BITDEPTHS; BitDepthArrayIndex++) {

                                                if (BitDepthArray[BitDepthArrayIndex] == 0) {

                                                    //
                                                    // the current slot is (0) zero, so add the new bit depth value
                                                    //

                                                    BitDepthArray[BitDepthArrayIndex] = (TW_UINT16)lBitDepth;
                                                    DBG_TRC(("WIA driver supports %d bit depth",lBitDepth));
                                                    ActualCount++;

                                                    //
                                                    // exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                } else if (BitDepthArray[BitDepthArrayIndex] == (TW_UINT16)lBitDepth) {

                                                    //
                                                    // bit depth is already in the list, so exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                }
                                            }
                                        } else {
                                            DBG_ERR(("CWiaDataSrc::GetBitDepths(), ReadPropertyLong(WIA_IPA_DEPTH) failed"));
                                        }
                                    }

                                    //
                                    // clean up the PROPVARIANT structure
                                    //

                                    PropVariantClear(&pvDepth);
                                }
                            } else {
                                DBG_ERR(("CWiaDataSrc::GetBitDepths(), WritePropertyLong(WIA_IPA_DATATYPE) failed"));
                            }
                        }
                    } else {

                        //
                        // we only have 1 value, so make it the current, default and valid value.
                        //

                        BitDepthArray[0] = (TW_UINT16)lCurrentBitDepthValue;
                        ActualCount = 1;
                        DBG_TRC(("WIA driver supports %d bit depth",lCurrentBitDepthValue));
                    }

                    //
                    // set the current values back
                    //

                    hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,lCurrentDataTypeValue);
                    if (SUCCEEDED(hr)) {
                        hr = WIA.WritePropertyLong(WIA_IPA_DEPTH,lCurrentBitDepthValue);
                    }

                    for (ULONG BitDepthArrayIndex = 0; BitDepthArrayIndex < MAX_BITDEPTHS; BitDepthArrayIndex++) {
                        if (BitDepthArray[BitDepthArrayIndex] == (TW_UINT16)lCurrentBitDepthValue) {
                            CurrentIndex = BitDepthArrayIndex;
                            BitDepthArrayIndex = MAX_BITDEPTHS;
                        }
                    }

                    //
                    // default index is equal to current index, because we are stating that the WIA driver
                    // is a fresh start-up state.
                    //

                    DefaultIndex = CurrentIndex;

                    twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)BitDepthArray,TRUE); // list
                    //twRc = TWRC_SUCCESS;

                    PropVariantClear(&pv);
                } else {
                    DBG_ERR(("CWiaDataSrc::GetBitDepths(), failed to read WIA_IPS_DATATYPE attributes"));
                }
            } else {
                DBG_ERR(("CWiaDataSrc::GetBitDepths(), ReadPropertyLong(WIA_IPA_DEPTH) failed"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetBitDepths(), ReadPropertyLong(WIA_IPA_DATATYPE) failed"));
        }
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::GetImageFileFormats()
{
    DBG_FN_DS(CWiaScannerDS::GetImageFileFormats());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_IMAGEFILEFORMAT);
    if (pCap) {

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetImageFileFormats(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 *pFileTypeArray = NULL;

        IWiaDataTransfer *pIWiaDataTransfer = NULL;
        TW_UINT32 TotalFileFormats = 0;
        IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO = NULL;
        WIA_FORMAT_INFO pfe;

        //
        // read current value, for default and current index settings
        //

        GUID guidCurrentFileFormat = GUID_NULL;
        hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&guidCurrentFileFormat);
        if (SUCCEEDED(hr)) {

            //
            // collect valid values for image file format
            //

            hr = m_pCurrentIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
            if (S_OK == hr) {
                hr = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
                if (SUCCEEDED(hr)) {

                    //
                    // count supported FILE formats
                    //

                    do {
                        memset(&pfe,0,sizeof(pfe));
                        hr = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                        if (hr == S_OK) {
                            if ((pfe.lTymed == TYMED_FILE) || (pfe.lTymed == TYMED_MULTIPAGE_FILE)) {
                                TotalFileFormats++;
                            }
                        }
                    } while (hr == S_OK);

                    //
                    // allocate supported FILE format array
                    //

                    pFileTypeArray = new TW_UINT16[TotalFileFormats];
                    if (pFileTypeArray) {
                        memset(pFileTypeArray,0,(sizeof(TW_UINT16) * TotalFileFormats));

                        //
                        // reset enuerator
                        //

                        hr = pIEnumWIA_FORMAT_INFO->Reset();
                        if (SUCCEEDED(hr)) {
                            do {
                                memset(&pfe,0,sizeof(pfe));
                                hr = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                                if (hr == S_OK) {

                                    if (pfe.lTymed == TYMED_MULTIPAGE_FILE) {
                                        if (pfe.guidFormatID == WiaImgFmt_TIFF) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_TIFFMULTI;
                                            if (guidCurrentFileFormat == WiaImgFmt_TIFF) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_TIFF (Multipage) -> TWFF_TIFFMULTI"));
                                        }
                                    }

                                    if (pfe.lTymed == TYMED_FILE) {
                                        if (pfe.guidFormatID == WiaImgFmt_BMP) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_BMP;
                                            if (guidCurrentFileFormat == WiaImgFmt_BMP) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_BMP -> TWFF_BMP"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_JPEG) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_JFIF;
                                            if (guidCurrentFileFormat == WiaImgFmt_JPEG) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_JPEG -> TWFF_JFIF"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_TIFF) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_TIFF;
                                            if (guidCurrentFileFormat == WiaImgFmt_TIFF) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_TIFF -> TWFF_TIFF"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_PICT) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_PICT;
                                            if (guidCurrentFileFormat == WiaImgFmt_PICT) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_PICT -> TWFF_PICT"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_PNG) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_PNG;
                                            if (guidCurrentFileFormat == WiaImgFmt_PNG) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_PNG -> WiaImgFmt_PNG"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_EXIF) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_EXIF;
                                            if (guidCurrentFileFormat == WiaImgFmt_EXIF) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_EXIF -> TWFF_EXIF"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_FLASHPIX) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_FPX;
                                            if (guidCurrentFileFormat == WiaImgFmt_FLASHPIX) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_FLASHPIX -> TWFF_FPX"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_UNDEFINED) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_UNDEFINED does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_EMF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_EMF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_WMF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_WMF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_GIF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_GIF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_PHOTOCD) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_PHOTOCD does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_ICO) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_ICO does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_CIFF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_CIFF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_JPEG2K) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_JPEG2K does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_JPEG2KX) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_JPEG2KX does not MAP to TWAIN a file format"));
                                        } else {

                                        }

                                        ////////////////////////////////
                                        // NO TWAIN -> WIA CONVERSION //
                                        ////////////////////////////////
                                        //
                                        // TWFF_XBM
                                        // TWFF_SPIFF
                                    }
                                }
                            } while (hr == S_OK);
                        }

                        if (pFileTypeArray) {

                            //
                            // default index is equal to current index, because we are stating that the WIA driver
                            // is a fresh start-up state.
                            //

                            DefaultIndex = CurrentIndex;

                            twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)pFileTypeArray,TRUE); // list
                            delete [] pFileTypeArray;
                            pFileTypeArray = NULL;
                            //twRc = TWRC_SUCCESS;
                        }
                    }

                    pIEnumWIA_FORMAT_INFO->Release();
                    pIEnumWIA_FORMAT_INFO = NULL;
                } else {
                    DBG_ERR(("CWiaDataSrc::GetImageFileFormats(), pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO() failed to enumerate supported file formats"));
                }
                pIWiaDataTransfer->Release();
                pIWiaDataTransfer = NULL;
            } else {
                DBG_ERR(("CWiaDataSrc::GetImageFileFormats(), QueryInterface(IID_IWiaDataTransfer) failed"));
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCompressionTypes()
{
    DBG_FN_DS(CWiaScannerDS::GetCompressionTypes());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_COMPRESSION);
    if (pCap) {

#ifdef SUPPORT_COMPRESSION_TYPES

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount  = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 *pCompressionTypeArray = NULL;

        //
        // read current value, for default and current index settings
        //

        LONG lCurrentCompressionTypeValue = WIA_COMPRESSION_NONE;
        hr = WIA.ReadPropertyLong(WIA_IPA_COMPRESSION,&lCurrentCompressionTypeValue);
        if (SUCCEEDED(hr)) {

            PROPVARIANT pv;
            memset(&pv,0,sizeof(pv));
            LONG lAccessFlags = 0;
            hr = WIA.ReadPropertyAttributes(WIA_IPA_COMPRESSION,&lAccessFlags,&pv);
            if (SUCCEEDED(hr)) {

                //
                // collect valid values for compression type
                //

                if (lAccessFlags & WIA_PROP_LIST) {
                    pCompressionTypeArray = new TW_UINT16[WIA_PROP_LIST_COUNT(&pv)];
                    if (pCompressionTypeArray) {
                        memset(pCompressionTypeArray,0,(sizeof(TW_UINT16)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {

                            switch (pv.caul.pElems[i+2]) {
                            case WIA_COMPRESSION_NONE:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_NONE;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_NONE) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_NONE -> TWCP_NONE"));
                                break;
                            case WIA_COMPRESSION_G3:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_GROUP31D;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_G3) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_G3 -> TWCP_GROUP31D"));
                                break;
                            case WIA_COMPRESSION_G4:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_GROUP4;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_G4) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_G4 -> TWCP_GROUP4"));
                                break;
                            case WIA_COMPRESSION_JPEG:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_JPEG;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_JPEG) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_JPEG -> TWCP_JPEG"));
                                break;
                            case WIA_COMPRESSION_BI_RLE4:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_RLE4;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_BI_RLE4) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE4 -> TWCP_RLE4"));
                                break;
                            case WIA_COMPRESSION_BI_RLE8:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_RLE8;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_BI_RLE8) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE8 -> TWCP_RLE8"));
                                break;
                                ////////////////////////////////
                                // NO TWAIN -> WIA CONVERSION //
                                ////////////////////////////////
                                //
                                // TWCP_PACKBITS
                                // TWCP_GROUP31D
                                // TWCP_GROUP31DEOL
                                // TWCP_GROUP32D
                                //
                                //
                                // TWCP_LZW
                                // TWCP_JBIG

                            default:
                                DBG_TRC(("WIA Compression Type (%d) does not MAP to TWAIN a compression type",pv.caul.pElems[i+2]));
                                break;
                            }
                        }
                    } else {
                        DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to allocate Compression Type Array Memory"));
                    }
                } else {

                    //
                    // current value becomes the only valid value
                    //

                    CurrentIndex = 0;
                    ActualCount  = 1;

                    pCompressionTypeArray = new TW_UINT16[1];
                    if (pCompressionTypeArray) {
                        switch (lCurrentCompressionTypeValue) {
                        case WIA_COMPRESSION_NONE:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_NONE;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_NONE -> TWCP_NONE"));
                            break;
                        case WIA_COMPRESSION_G3:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_GROUP31D;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_G3 -> TWCP_GROUP31D"));
                            break;
                        case WIA_COMPRESSION_G4:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_GROUP4;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_G4 -> TWCP_GROUP4"));
                            break;
                        case WIA_COMPRESSION_JPEG:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_JPEG;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_JPEG -> TWCP_JPEG"));
                            break;
                        case WIA_COMPRESSION_BI_RLE4:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_RLE4;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE4 -> TWCP_RLE4"));
                            break;
                        case WIA_COMPRESSION_BI_RLE8:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_RLE8;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE8 -> TWCP_RLE8"));
                            break;
                            ////////////////////////////////
                            // NO TWAIN -> WIA CONVERSION //
                            ////////////////////////////////
                            //
                            // TWCP_PACKBITS
                            // TWCP_GROUP31D
                            // TWCP_GROUP31DEOL
                            // TWCP_GROUP32D
                            //
                            //
                            // TWCP_LZW
                            // TWCP_JBIG

                        default:
                            DBG_TRC(("WIA Compression Type (%d) does not MAP to TWAIN a compression type",lCurrentCompressionTypeValue));
                            break;
                        }
                    }
                }

                if (pCompressionTypeArray) {

                    //
                    // default index is equal to current index, because we are stating that the WIA driver
                    // is a fresh start-up state.
                    //

                    DefaultIndex = CurrentIndex;

                    twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)pCompressionTypeArray,TRUE); // list
                    delete [] pCompressionTypeArray;
                    pCompressionTypeArray = NULL;

                    //twRc = TWRC_SUCCESS;
                }

                PropVariantClear(&pv);
            } else {
                DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to read WIA_IPA_COMPRESSION attributes"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to read WIA_IPA_COMPRESSION current value"));
        }
#else // SUPPORT_COMPRESSION_TYPES

        //
        // support only TWCP_NONE (no Compression)
        //

        TW_UINT16 CapDataArray[1];
        CapDataArray[0] = TWCP_NONE;
        twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);

#endif // SUPPORT_COMPRESSION_TYPES
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::SetCommonSettings(CCap *pCap)
{
    DBG_FN_DS(CWiaScannerDS::SetCommonSettings());
    HRESULT hr = S_OK;
    LONG lValue = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDataSrc::SetCommonSettings(), failed to set IWiaItem for property reading"));
    }

    //
    // determine if it is a Capability that the device really needs to know
    // about.
    //

    switch (pCap->GetCapId()) {
    case ICAP_PIXELTYPE:
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_PIXELTYPE)"));
        switch (pCap->GetCurrent()) {
        case TWPT_BW:
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_THRESHOLD"));
            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,WIA_DATA_THRESHOLD);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_THRESHOLD failed"));
            }
            break;
        case TWPT_GRAY:
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_GRAYSCALE"));
            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,WIA_DATA_GRAYSCALE);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_GRAYSCALE failed"));
            }
            break;
        case TWPT_RGB:
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_COLOR"));
            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,WIA_DATA_COLOR);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_COLOR failed"));
            }
            break;
        case TWPT_PALETTE:
        case TWPT_CMY:
        case TWPT_CMYK:
        case TWPT_YUV:
        case TWPT_YUVK:
        case TWPT_CIEXYZ:
        default:
            DBG_WRN(("CWiaDataSrc::SetCommonSettings(), An unsupported ICAP_PIXELTYPE (%d) was sent to this data source",(LONG)pCap->GetCurrent()));
            break;
        }
        break;
    case ICAP_BITDEPTH:
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_BITDEPTH)"));
        lValue = (LONG)pCap->GetCurrent();
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_BITDEPTH to %d",lValue));
        hr = WIA.WritePropertyLong(WIA_IPA_DEPTH,lValue);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_BITDEPTH to %d failed",lValue));
        }
        break;
    case ICAP_IMAGEFILEFORMAT:
        {
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_IMAGEFILEFORMAT)"));
            lValue = (LONG)pCap->GetCurrent();
            LONG lTymed = TYMED_FILE;
            if (lValue == TWFF_TIFFMULTI) {
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_TYMED to TYMED_MULTIPAGE_FILE"));
                lTymed = TYMED_MULTIPAGE_FILE;
            } else {
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_TYMED to TYMED_FILE"));
            }

            hr = WIA.WritePropertyLong(WIA_IPA_TYMED,lTymed);

            GUID guidFormat = GUID_NULL;

            if (SUCCEEDED(hr)) {
                switch (lValue) {
                case TWFF_TIFFMULTI:
                case TWFF_TIFF:
                    guidFormat = WiaImgFmt_TIFF;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_TIFF"));
                    break;
                case TWFF_PICT:
                    guidFormat = WiaImgFmt_PICT;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_PICT"));
                    break;
                case TWFF_BMP:
                    guidFormat = WiaImgFmt_BMP;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_BMP"));
                    break;
                case TWFF_JFIF:
                    guidFormat = WiaImgFmt_JPEG;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_JPEG"));
                    break;
                case TWFF_FPX:
                    guidFormat = WiaImgFmt_FLASHPIX;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_FLASHPIX"));
                    break;
                case TWFF_PNG:
                    guidFormat = WiaImgFmt_PNG;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_PNG"));
                    break;
                case TWFF_EXIF:
                    guidFormat = WiaImgFmt_EXIF;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_EXIF"));
                    break;
                case TWFF_SPIFF:
                case TWFF_XBM:
                default:
                    break;
                }

                hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT,guidFormat);
                if (FAILED(hr)) {
                    DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to %d failed",lValue));
                }
            } else {
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_TYMED to %d failed",lTymed));
            }
        }
        break;
    case ICAP_COMPRESSION:
        {
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_COMPRESSION)"));
            lValue = (LONG)pCap->GetCurrent();
            LONG lCompression = WIA_COMPRESSION_NONE;
            switch (lValue) {
            case TWCP_NONE:
                lCompression = WIA_COMPRESSION_NONE;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_NONE"));
                break;
            case TWCP_GROUP4:
                lCompression = WIA_COMPRESSION_G4;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_G4"));
                break;
            case TWCP_JPEG:
                lCompression = WIA_COMPRESSION_JPEG;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_JPEG"));
                break;
            case TWCP_RLE4:
                lCompression = WIA_COMPRESSION_BI_RLE4;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_BI_RLE4"));
                break;
            case TWCP_RLE8:
                lCompression = WIA_COMPRESSION_BI_RLE8;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_BI_RLE8"));
                break;
            case TWCP_GROUP31D:
            case TWCP_GROUP31DEOL:
            case TWCP_GROUP32D:
                lCompression = WIA_COMPRESSION_G3;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_G3"));
                break;
            case TWCP_LZW:
            case TWCP_JBIG:
            case TWCP_PACKBITS:
            default:
                break;
            }

            hr = WIA.WritePropertyLong(WIA_IPA_COMPRESSION,lCompression);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to %d failed",lCompression));
            }
        }
        break;
    default:
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(), data source is not setting CAPID = %x to WIA device (it is not needed)",pCap->GetCapId()));
        break;
    }

    if (SUCCEEDED(hr)) {
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Settings were successfully sent to WIA device"));
    } else {
        DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Settings were unsuccessfully sent to WIA device"));
        return TWRC_FAILURE;
    }

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::GetMemoryTransferBits(BYTE* pImageData)
{
    DBG_FN_DS(CWiaScannerDS::GetMemoryTransferBits());
    if(!pImageData){
        return TWRC_FAILURE;
    }

    BYTE *pBits = pImageData;

    if (m_MemoryTransferInfo.mtiguidFormat == WiaImgFmt_MEMORYBMP) {
        BITMAPINFOHEADER* pbmh = (BITMAPINFOHEADER*)pImageData;
        if (pbmh) {
            pBits += sizeof(BITMAPINFOHEADER) + (pbmh->biClrUsed * sizeof(RGBQUAD));
        }
    }

    m_MemoryTransferInfo.mtipBits = pBits;

    return TWRC_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\progress.h ===
#ifndef __PROGRESS_H_
#define __PROGRESS_H_

#include <wiadevdp.h>
#include <validate.h>

#define MEMORY_BLOCK_FACTOR 2
#define TITLE_FROMDEVICE       101
#define TITLE_PROCESSINGDATA   102
#define TITLE_TRANSFERTOCLIENT 103

//
// Progress dialog class definition (uses common WIA UI)
//

class CProgressDlg {
public:

    CProgressDlg()
    {
        m_bCancelled = FALSE;
        m_pWiaProgressDialog = NULL;
        m_iLow  = 0;
        m_iHigh = 100;
    }

    ~CProgressDlg()
    {
        if (m_pWiaProgressDialog) {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog->Release();
            m_pWiaProgressDialog = NULL;
        }
    }

    BOOL Initialize(HINSTANCE hI, DWORD dwI)
    {
        return TRUE;
    }

    BOOL DoModeless(HWND hwndOwner, LPARAM lp)
    {

        //
        // Create standard WIA progress, allowing cancel
        //

        if(m_pWiaProgressDialog){
            // dialog has already been created
            return TRUE;
        }

        HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog );
        if (SUCCEEDED(hr) && m_pWiaProgressDialog) {
            hr = m_pWiaProgressDialog->Create( hwndOwner, WIA_PROGRESSDLG_NO_ANIM );
            if (SUCCEEDED(hr)) {
                m_pWiaProgressDialog->SetTitle( L"" );
                m_pWiaProgressDialog->SetMessage( L"" );
                m_pWiaProgressDialog->SetPercentComplete(0);
                m_pWiaProgressDialog->Show();
            } else {
                m_pWiaProgressDialog->Release();
                m_pWiaProgressDialog = NULL;
            }
        }

        return(NULL != m_pWiaProgressDialog);
    }

    void SetRange(int Low, int High)
    {
        m_iLow  = Low;
        m_iHigh = High;
    }

    void  SetPos(int NewPos)
    {
        int delta = (m_iHigh - m_iLow) ;
        int percent = 0;

        if (NewPos < m_iLow ) {
            percent = 0;
        } else if ( (delta == 0) || (NewPos > m_iHigh) ) {
            percent = 100;
        } else {
            percent = 100 * ( NewPos - m_iLow) / delta;
        }

        ASSERT(m_pWiaProgressDialog != NULL);

        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->SetPercentComplete(percent))) {
        }
    }

    BOOL CheckCancelled()
    {
        ASSERT(m_pWiaProgressDialog != NULL);

        m_bCancelled = FALSE;
        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->Cancelled(&m_bCancelled))) {
        }
        return m_bCancelled;
    }

    void    SetTitle(LPTSTR pszTitle)
    {
        ASSERT(m_pWiaProgressDialog != NULL);

#ifndef UNICODE

        WCHAR wszTitle[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, pszTitle, -1,
                            wszTitle, sizeof(wszTitle) / sizeof(WCHAR)
                           );
        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->SetTitle(wszTitle))) {
            // What do we do if SetTitle fails?
        }
#else
        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->SetTitle(pszTitle))) {
            // What do we do if SetTitle fails?
        }
#endif

    }

private:

    BOOL m_bCancelled;
    IWiaProgressDialog *m_pWiaProgressDialog;
    int m_iLow;
    int m_iHigh;
};

//
// WIA data callback class definition
//

class CWiaDataCallback : public IWiaDataCallback {
public:
    CWiaDataCallback()
    {
        m_Ref = 1;
        m_hrLast = S_OK;

        //
        // image data
        //

        m_hImage = NULL;
        m_pImage = NULL;

        m_ImageSize = 0;
        m_bBitmapData = FALSE;
        m_lImageHeight = 0;
        m_lImageWidth = 0;
        m_MemBlockSize = 0;
        m_SizeTransferred = 0;

        //
        // progress dialog
        //

        m_hwndOwner = NULL;
        m_pProgDlg = NULL;
        m_pszXferFromDevice = NULL;
        m_pszProcessingData = NULL;
        m_pszXferToClient = NULL;
        m_bSetTitle = FALSE;
        m_lLastTextUpdate = 0;
        m_lCurrentTextUpdate = 0;
    }

    ~CWiaDataCallback()
    {

        //
        // free image data memory members
        //

        if (m_pImage){
            GlobalUnlock(m_hImage);
            m_pImage = NULL;
        }

        if (m_hImage){
            GlobalFree(m_hImage);
            m_hImage = NULL;
        }

        //
        // free progress dialog members
        //

        if (m_pProgDlg){
            delete m_pProgDlg;
            m_pProgDlg = NULL;
        }

        if (m_pszXferFromDevice){
            delete [] m_pszXferFromDevice;
            m_pszXferFromDevice = NULL;
        }

        if (m_pszProcessingData){
            delete [] m_pszProcessingData;
            m_pszProcessingData = NULL;
        }

        if (m_pszXferToClient){
            delete [] m_pszXferToClient;
            m_pszXferToClient = NULL;
        }
    }

    HRESULT Initialize(HWND hwndOwner, BOOL bShowProgress);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID iid, void **ppv);
    STDMETHODIMP BandedDataCallback(LONG lMessage, LONG lStatus,LONG lPercentComplete,LONG lOffset, LONG Length,
                                    LONG lReserved, LONG lResLength,BYTE *pData);
    HRESULT GetImage(HGLOBAL *phImage, ULONG *pImageSize);
    LONG CalculateWidthBytes(LONG lWidthPixels, LONG lbpp);
    LONG GetImageHeight(){return m_lImageHeight;}
    LONG GetImageWidth(){return m_lImageWidth;}

    HRESULT GetLastResult() {
        return m_hrLast;
    }

private:
    ULONG   m_Ref;
    HRESULT m_hrLast;

    //
    // image data
    //

    HGLOBAL m_hImage;
    BYTE    *m_pImage;

    ULONG   m_ImageSize;
    BOOL    m_bBitmapData;
    LONG    m_lImageHeight;
    LONG    m_lImageWidth;
    LONG    m_MemBlockSize;
    ULONG   m_SizeTransferred;

    //
    // progress dialog
    //

    HWND    m_hwndOwner;
    CProgressDlg *m_pProgDlg;
    TCHAR   *m_pszXferFromDevice;
    TCHAR   *m_pszProcessingData;
    TCHAR   *m_pszXferToClient;
    BOOL    m_bSetTitle;
    LONG    m_lLastTextUpdate;
    LONG    m_lCurrentTextUpdate;
};

#endif //__PROGRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiadss.rc
//
#define IDD_PROGRESSDLG 		        101
#define IDS_PROGRESS_XFER_FROM_DEVICE	103
#define IDS_PROGRESS_PROCESSING_DATA	104
#define IDS_PROGRESS_XFER_TO_CLIENT	    105
#define IDC_PROGRESSBAR                 1000

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\precomp.h ===
#ifndef __PRECOMP_H_
#define __PRECOMP_H_
#include <windows.h>
#include <math.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include "twain19.h"    // standard TWAIN header (1.9 Version)
#include <commctrl.h>
#include "resource.h"   // Resource IDs
#include "dsloader.h"   // import data source loader
#include <ole2.h>
#include "wia.h"        // WIA application header
#include "wiatwcmp.h"   // WIA Twain compatibility layer support
#include "coredbg.h"    // WIA core debugging library
#include "wiadss.h"     // main DLL
#include "utils.h"      // helper funtions
#include "progress.h"   // progress dialog (used from Common UI)
#include "cap.h"        // capability negotiations
#include "wiadev.h"     // WIA device class
#include "datasrc.h"    // TWAIN data source base class
#include "camerads.h"   // TWAIN data source (camera specific)
#include "scanerds.h"   // TWAIN data source (scanner specific)
#include "videods.h"    // TWAIN data source (streaming video specific)
#include "wiahelper.h"  // WIA property access helper class
#include <stilib.h>

#define _USE_NONSPRINTF_CONVERSION

////////////////////////////////////////////////////////////
// #define COREDBG_ERRORS                  0x00000001
// #define COREDBG_WARNINGS                0x00000002
// #define COREDBG_TRACES                  0x00000004
// #define COREDBG_FNS                     0x00000008
////////////////////////////////////////////////////////////

#define TWAINDS_FNS                        0x00000016
#define WIADEVICE_FNS                      0x00000032
#define CAP_FNS                            0x00000064

//
// override default WIA core debugging DBG_TRC macro.
//

#undef DBG_TRC
#undef DBG_ERR
#undef DBG_WRN

#define DBG_TRC(x) DBG_PRT(x)
#define DBG_WRN(x) \
    { \
        DBG_TRC(("================================= WARNING =====================================")); \
        DBG_TRC(x); \
        DBG_TRC(("===============================================================================")); \
    }
#define DBG_ERR(x) \
    { \
        DBG_TRC(("********************************* ERROR ***************************************")); \
        DBG_TRC(x); \
        DBG_TRC(("*******************************************************************************")); \
    }

#define DBG_FN_DS(x) DBG_FN(x)
#define DBG_FN_WIADEV(x) DBG_FN(x)
#define DBG_FN_CAP(x) DBG_FN(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\scanerds.cpp ===
#include "precomp.h"

//
// values that the WIA/TWAIN data source provides for capability negotation
//

TW_UINT16 g_ScannerUnits[]            = {TWUN_INCHES,TWUN_PIXELS};
TW_UINT16 g_ScannerBitOrder[]         = {TWBO_MSBFIRST};
TW_UINT16 g_ScannerXferMech[]         = {TWSX_NATIVE, TWSX_FILE, TWSX_MEMORY};
TW_UINT16 g_ScannerPixelFlavor[]      = {TWPF_CHOCOLATE,TWPF_VANILLA};

const TW_UINT32 NUM_SCANNERCAPDATA = 29;
const TW_UINT32 NUM_SCANNERCAPDATA_NO_FEEDER_DETECTED = 26;
CAPDATA SCANNER_CAPDATA[NUM_SCANNERCAPDATA] =
{
    //
    // Every source must support all five DG_CONTROL / DAT_CAPABILITY operations on:
    //

    {CAP_XFERCOUNT, TWTY_INT16, TWON_ONEVALUE,
     sizeof(TW_INT16), 0, 0, -1, 0, 1, NULL, NULL
    },

    //
    // Every source must support DG_CONTROL / DAT_CAPABILITY, MSG_GET on:
    //

    {CAP_SUPPORTEDCAPS, TWTY_UINT16, TWON_ARRAY,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_UICONTROLLABLE, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, and MSG_GETDEFAULT on:
    //

    {ICAP_COMPRESSION, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PLANARCHUNKY, TWTY_UINT16, TWON_ONEVALUE,
     sizeof(TW_UINT16), TWPC_CHUNKY, TWPC_CHUNKY, TWPC_CHUNKY, TWPC_PLANAR, 0, NULL, NULL
    },
    {ICAP_PHYSICALHEIGHT, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PHYSICALWIDTH, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PIXELFLAVOR, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 1, 0, g_ScannerPixelFlavor, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, MSG_GETDEFAULT, MSG_RESET, and MSG_SET on:
    //

    {ICAP_BITDEPTH, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BITORDER, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_ScannerBitOrder, NULL
    },
    {ICAP_PIXELTYPE, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_UNITS, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 1, 0, g_ScannerUnits, NULL
    },
    {ICAP_XFERMECH, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 2, 0, g_ScannerXferMech, NULL
    },
    {ICAP_XRESOLUTION, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 100, 100, 75, 1200, 1, NULL, NULL
    },
    {ICAP_YRESOLUTION, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 100, 100, 75, 1200, 1, NULL, NULL
    },

    //
    // The following capabilities are provided for application compatiblity only.
    //

    {ICAP_IMAGEFILEFORMAT, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_INDICATORS, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_ENABLEDSUIONLY, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL),  FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
    {CAP_DEVICEONLINE, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_UINT16), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {ICAP_XNATIVERESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_YNATIVERESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BRIGHTNESS, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 0, 0, -1000, 1000, 1, NULL, NULL
    },
    {ICAP_CONTRAST, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 0, 0, -1000, 1000, 1, NULL, NULL
    },
    {ICAP_XSCALING, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 1, 1, 1, 1, 1, NULL, NULL
    },
    {ICAP_YSCALING, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 1, 1, 1, 1, 1, NULL, NULL
    },
    {ICAP_THRESHOLD, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 128, 128, 0, 255, 1, NULL, NULL
    },

    //
    // All sources must implement the advertised features supplied by their devices.
    // The following properties are supplied for TWAIN protocol only, this source
    // supports document feeders (if they are detected).
    //

    {CAP_FEEDERENABLED, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), FALSE, FALSE, FALSE, TRUE, 0, NULL, NULL
    },
    {CAP_FEEDERLOADED, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), FALSE, FALSE, FALSE, TRUE, 0, NULL, NULL
    },
    {CAP_AUTOFEED, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), FALSE, FALSE, FALSE, TRUE, 0, NULL, NULL
    }
};

TW_UINT16 CWiaScannerDS::OpenDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::OpenDS());
    m_bUnknownPageLength = FALSE;
    m_bCacheImage = FALSE;
    m_bEnforceUIMode = FALSE;
    m_bUnknownPageLengthMultiPageOverRide = FALSE;
    if (ReadTwainRegistryDWORDValue(DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED,
                                    DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED_ON) == DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED_ON) {
        m_bUnknownPageLengthMultiPageOverRide = TRUE;
    }

    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr     = S_OK;

    twRc = CWiaDataSrc::OpenDS(ptwMsg);
    if (TWRC_SUCCESS != twRc)
        return twRc;

    BASIC_INFO BasicInfo;
    memset(&BasicInfo,0,sizeof(BasicInfo));
    BasicInfo.Size = sizeof(BasicInfo);

    hr = m_pDevice->GetBasicScannerInfo(&BasicInfo);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::OpenDS(), GetBasicScannerInfo() failed"));
        return TWRC_FAILURE;
    }

    DBG_TRC(("CWiaScannerDS::OpenDS(), Reported Basic Scanner Information from WIA device"));
    DBG_TRC(("BasicInfo.Size        = %d",BasicInfo.Size));
    DBG_TRC(("BasicInfo.xBedSize    = %d",BasicInfo.xBedSize));
    DBG_TRC(("BasicInfo.yBedSize    = %d",BasicInfo.yBedSize));
    DBG_TRC(("BasicInfo.xOpticalRes = %d",BasicInfo.xOpticalRes));
    DBG_TRC(("BasicInfo.yOpticalRes = %d",BasicInfo.yOpticalRes));
    DBG_TRC(("BasicInfo.FeederCaps  = %d",BasicInfo.FeederCaps));

    //
    // Update cap based on information we got
    //

    CCap * pCap = NULL;
    TW_UINT32 Value = 0;
    TW_FIX32 fix32;
    memset(&fix32,0,sizeof(fix32));

    //
    // Cache the scanner document handling capability
    //

    m_FeederCaps = BasicInfo.FeederCaps;

    //
    // create capability list
    //

    if(m_FeederCaps > 0){
        twRc = CreateCapList(NUM_SCANNERCAPDATA, SCANNER_CAPDATA);
    } else {
        twRc = CreateCapList(NUM_SCANNERCAPDATA_NO_FEEDER_DETECTED, SCANNER_CAPDATA);
    }

    if (TWCC_SUCCESS != twRc) {
        m_twStatus.ConditionCode = twRc;
        return TWRC_FAILURE;
    }

    if (m_FeederCaps > 0) {

        //
        // we have a scanner that has feeder capabilities
        //

        pCap = NULL;
        pCap = FindCap(CAP_FEEDERENABLED);
        if (pCap) {
            DBG_TRC(("Setting feeder enabled to TRUE, because we have a document feeder"));
            twRc = pCap->Set(FALSE, FALSE, TRUE, TRUE);
        }

        pCap = NULL;
        pCap = FindCap(CAP_FEEDERLOADED);
        if (pCap) {
            DBG_TRC(("Setting feeder loaded to TRUE, because we have a document feeder and assume it is loaded"));
            twRc = pCap->Set(TRUE, TRUE, TRUE, TRUE);
        }
    }

    //
    // Update the cached frame.
    //

    m_CurFrame.Left.Whole = m_CurFrame.Top.Whole = 0;
    m_CurFrame.Left.Frac = m_CurFrame.Top.Frac = 0;
    pCap = FindCap(ICAP_XNATIVERESOLUTION);
    if (pCap) {
        twRc = pCap->Set(BasicInfo.xOpticalRes, BasicInfo.xOpticalRes,
                         BasicInfo.xOpticalRes, BasicInfo.xOpticalRes);
    }
    pCap = NULL;
    pCap = FindCap(ICAP_YNATIVERESOLUTION);
    if (pCap) {
        twRc = pCap->Set(BasicInfo.yOpticalRes, BasicInfo.yOpticalRes,
                         BasicInfo.yOpticalRes, BasicInfo.yOpticalRes);
    }
    pCap = NULL;
    pCap = FindCap(ICAP_PHYSICALHEIGHT);
    if (pCap) {
        // bed size is in 1000th inches (we default to inches, so calculate the size correctly..)
        fix32 = FloatToFix32((FLOAT)(BasicInfo.yBedSize / 1000.00));
        memcpy(&Value, &fix32, sizeof(TW_UINT32));
        twRc = pCap->Set(Value, Value, Value, Value);
        m_CurFrame.Bottom = fix32;
    }
    pCap = NULL;
    pCap = FindCap(ICAP_PHYSICALWIDTH);
    if (pCap) {
        // bed size is in 1000th inches (we default to inches, so calculate the size correctly..)
        fix32 = FloatToFix32((FLOAT)(BasicInfo.xBedSize / 1000.00));
        memcpy(&Value, &fix32, sizeof(TW_UINT32));
        twRc = pCap->Set(Value, Value, Value, Value);
        m_CurFrame.Right = fix32;
    }

    //
    // By TWAIN standard, capability negotiations come before
    // data source enabling. For this reason, we have to
    // trigger the device have those information ready for us.
    //

    hr = m_pDevice->AcquireImages(NULL, FALSE);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->EnumAcquiredImage(0, &m_pCurrentIWiaItem);
        if (SUCCEEDED(hr)) {
            twRc = GetCommonSettings();
            if(TWRC_SUCCESS == twRc){
                twRc = GetSettings();
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::OnImageLayoutMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::OnImageLayoutMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_IMAGELAYOUT *pLayout = (TW_IMAGELAYOUT*)ptwMsg->pData;
    switch (ptwMsg->MSG) {
    case MSG_GET:
    case MSG_GETDEFAULT:
    case MSG_GETCURRENT:
        switch (GetTWAINState()) {
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            {
                GetImageLayout(&m_CurImageLayout);
                pLayout->DocumentNumber     = m_CurImageLayout.DocumentNumber;
                pLayout->PageNumber         = m_CurImageLayout.PageNumber;
                pLayout->FrameNumber        = m_CurImageLayout.FrameNumber;
                pLayout->Frame.Top.Whole    = m_CurImageLayout.Frame.Top.Whole;
                pLayout->Frame.Top.Frac     = m_CurImageLayout.Frame.Top.Frac;
                pLayout->Frame.Left.Whole   = m_CurImageLayout.Frame.Left.Whole;
                pLayout->Frame.Left.Frac    = m_CurImageLayout.Frame.Left.Frac;
                pLayout->Frame.Right.Whole  = m_CurImageLayout.Frame.Right.Whole;
                pLayout->Frame.Right.Frac   = m_CurImageLayout.Frame.Right.Frac;
                pLayout->Frame.Bottom.Whole = m_CurImageLayout.Frame.Bottom.Whole;
                pLayout->Frame.Bottom.Frac  = m_CurImageLayout.Frame.Bottom.Frac;
                //pLayout->Frame            = m_CurFrame; // BETTER BE IN CORRECT UNITS!!!!
            }
            break;
        }
        break;
    case MSG_SET:

        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            // do actual MSG_SET here..
            {
                DBG_TRC(("CWiaScannerDS::OnImageLayoutMsg(), MSG_SET TW_IMAGELAYOUT to set from Application"));
                DBG_TRC(("DocumentNumber     = %d",pLayout->DocumentNumber));
                DBG_TRC(("PageNumber         = %d",pLayout->PageNumber));
                DBG_TRC(("FrameNumber        = %d",pLayout->FrameNumber));
                DBG_TRC(("Frame.Top.Whole    = %d",pLayout->Frame.Top.Whole));
                DBG_TRC(("Frame.Top.Frac     = %d",pLayout->Frame.Top.Frac));
                DBG_TRC(("Frame.Left.Whole   = %d",pLayout->Frame.Left.Whole));
                DBG_TRC(("Frame.Left.Frac    = %d",pLayout->Frame.Left.Frac));
                DBG_TRC(("Frame.Right.Whole  = %d",pLayout->Frame.Right.Whole));
                DBG_TRC(("Frame.Right.Frac   = %d",pLayout->Frame.Right.Frac));
                DBG_TRC(("Frame.Bottom.Whole = %d",pLayout->Frame.Bottom.Whole));
                DBG_TRC(("Frame.Bottom.Frac  = %d",pLayout->Frame.Bottom.Frac));

                //
                // perform a really rough validation check on FRAME values.
                // validate possible incorrect settings by an application.
                //

                CCap *pXCap = FindCap(ICAP_PHYSICALWIDTH);
                TW_INT16 MaxWidthWhole = 8;
                if(pXCap){
                    MaxWidthWhole = (TW_INT16)pXCap->GetCurrent();
                }
                if(pLayout->Frame.Right.Whole  > MaxWidthWhole) {
                    twRc = TWRC_FAILURE;
                    m_twStatus.ConditionCode = TWCC_BADVALUE;
                    DBG_TRC(("Frame.Right.Whole Value (%d) is greater than MAX Right value (%d)",pLayout->Frame.Right.Whole,MaxWidthWhole));
                }

                CCap *pYCap = FindCap(ICAP_PHYSICALHEIGHT);
                TW_INT16 MaxHeightWhole = 11;
                if(pYCap){
                    MaxHeightWhole = (TW_INT16)pYCap->GetCurrent();
                }

                if(pLayout->Frame.Bottom.Whole > MaxHeightWhole) {
                    twRc = TWRC_FAILURE;
                    m_twStatus.ConditionCode = TWCC_BADVALUE;
                    DBG_TRC(("Frame.Bottom.Whole Value (%d) is greater than MAX Bottom value (%d)",pLayout->Frame.Bottom.Whole,MaxHeightWhole));
                }

                if (twRc == TWRC_SUCCESS) {

                    //
                    // save SET values to ImageLayout member
                    //

                    m_CurImageLayout.DocumentNumber     = pLayout->DocumentNumber;
                    m_CurImageLayout.PageNumber         = pLayout->PageNumber;
                    m_CurImageLayout.FrameNumber        = pLayout->FrameNumber;
                    m_CurImageLayout.Frame.Top.Whole    = pLayout->Frame.Top.Whole;
                    m_CurImageLayout.Frame.Top.Frac     = pLayout->Frame.Top.Frac;
                    m_CurImageLayout.Frame.Left.Whole   = pLayout->Frame.Left.Whole;
                    m_CurImageLayout.Frame.Left.Frac    = pLayout->Frame.Left.Frac;
                    m_CurImageLayout.Frame.Right.Whole  = pLayout->Frame.Right.Whole;
                    m_CurImageLayout.Frame.Right.Frac   = pLayout->Frame.Right.Frac;
                    m_CurImageLayout.Frame.Bottom.Whole = pLayout->Frame.Bottom.Whole;
                    m_CurImageLayout.Frame.Bottom.Frac  = pLayout->Frame.Bottom.Frac;
                    twRc = SetImageLayout(pLayout);
                }

            }
            break;
        }

        break;
    case MSG_RESET:

        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            // do actual MSG_RESET here..
            {
#ifdef DEBUG
                DBG_TRC(("\n\nMSG_RESET - ImageLayout DocNum = %d, PgNum = %d, FrameNum = %d",
                      pLayout->DocumentNumber,
                      pLayout->PageNumber,
                      pLayout->FrameNumber));

                DBG_TRC(("Frame Values\n Top = %d.%d\nLeft = %d.%d\nRight = %d.%d\nBottom = %d.%d",
                      pLayout->Frame.Top.Whole,
                      pLayout->Frame.Top.Frac,
                      pLayout->Frame.Left.Whole,
                      pLayout->Frame.Left.Frac,
                      pLayout->Frame.Right.Whole,
                      pLayout->Frame.Right.Frac,
                      pLayout->Frame.Bottom.Whole,
                      pLayout->Frame.Bottom.Frac));
#endif

                m_CurImageLayout.Frame.Top.Whole    = 0;
                m_CurImageLayout.Frame.Top.Frac     = 0;
                m_CurImageLayout.Frame.Left.Whole   = 0;
                m_CurImageLayout.Frame.Left.Frac    = 0;
                m_CurImageLayout.Frame.Right.Whole  = 8;
                m_CurImageLayout.Frame.Right.Frac   = 5;
                m_CurImageLayout.Frame.Bottom.Whole = 11;
                m_CurImageLayout.Frame.Bottom.Frac  = 0;

            }
            break;
        }

        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::CloseDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::CloseDS());
    DestroyCapList();
    return CWiaDataSrc::CloseDS(ptwMsg);
}

TW_UINT16 CWiaScannerDS::EnableDS(TW_USERINTERFACE *pUI)
{
    DBG_FN_DS(CWiaScannerDS::EnableDS());
    TW_UINT16 twRc = TWRC_FAILURE;
    m_bUnknownPageLength = FALSE;
    if (DS_STATE_4 == GetTWAINState()) {
        HRESULT hr = S_OK;
        if(pUI->ShowUI){
            DBG_TRC(("CWiaScannerDS::EnableDS(), TWAIN UI MODE"));
            m_pDevice->FreeAcquiredImages();
            m_pCurrentIWiaItem = NULL;
        } else {
            DBG_TRC(("CWiaScannerDS::EnableDS(), TWAIN UI-LESS MODE"));
            m_pDevice->FreeAcquiredImages();
            m_pCurrentIWiaItem = NULL;
        }
        hr = m_pDevice->AcquireImages(HWND (pUI->ShowUI ? pUI->hParent : NULL),pUI->ShowUI);
        if (S_OK == hr) {
            twRc = TWRC_SUCCESS;
            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            if (lNumImages) {
                m_NumIWiaItems = (TW_UINT32)lNumImages;
                m_pIWiaItems = new (IWiaItem *[m_NumIWiaItems]);
                if (m_pIWiaItems) {
                    hr = m_pDevice->GetAcquiredImageList(lNumImages, m_pIWiaItems, NULL);
                    if (FAILED(hr)) {
                        delete [] m_pIWiaItems;
                        m_pIWiaItems = NULL;
                        m_NumIWiaItems = 0;
                        m_NextIWiaItemIndex = 0;
                        m_twStatus.ConditionCode = TWCC_BUMMER;
                        twRc = TWRC_FAILURE;
                    }
                } else {
                    m_NumIWiaItems = 0;
                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    twRc = TWRC_FAILURE;
                }
            }
        } else if(S_FALSE == hr) {
            return TWRC_CANCEL;
        } else {
            m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
            twRc = TWRC_FAILURE;
        }

        if (TWRC_SUCCESS == twRc) {
            if (m_NumIWiaItems) {
                m_pCurrentIWiaItem = m_pIWiaItems[0];
                m_NextIWiaItemIndex = 1;

                //
                // Special case the devices that can acquire with an unknown page length setting.
                // WIA devices will be missing the YExtent property, or it will be set to 0.
                // TRUE will be returned from IsUnknownPageLengthDevice() if it this functionality
                // is supported.
                // Since TWAIN does not support unknown page lengths very well, we are required to
                // cache the page data, and image settings.
                // Note: unknown page length devices will be limited to DIB/BMP data types.
                //       This will allow the TWAIN compatibility layer to calculate the
                //       missing image information from the transferred data size.
                //

                if(IsUnknownPageLengthDevice()){
                    twRc = TransferToMemory(WiaImgFmt_MEMORYBMP);
                    if(TWRC_SUCCESS != twRc){
                        return twRc;
                    }
                    m_bUnknownPageLength = TRUE;
                    m_bCacheImage = TRUE;
                }

                //
                // transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);

                NotifyXferReady();

                twRc = TWRC_SUCCESS;
            } else {
                NotifyCloseReq();

                //
                // transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);

                twRc = TWRC_SUCCESS;
            }
        }
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_SUCCESS;

    //
    // Use base class's function for now
    //

    twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);

    if (twRc == TWRC_SUCCESS) {
        twRc = CWiaDataSrc::SetCommonSettings(pCap);
        if(twRc == TWRC_SUCCESS){
            twRc = SetSettings(pCap);
        }
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::TransferToFile(GUID guidFormatID)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pPendingXfers = FindCap(CAP_XFERCOUNT);
    if(pPendingXfers){
        if(IsFeederEnabled()){
            DBG_TRC(("CWiaScannerDS::TransferToFile(), Scanner device is set to FEEDER mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)32767);
        } else {
            DBG_TRC(("CWiaScannerDS::TransferToFile(), Scanner device is set to FLATBED mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)0);
        }
    }

    if (m_bCacheImage) {
        m_bCacheImage = FALSE;

        //
        // acquire a cached image
        //

        HGLOBAL hDIB = NULL;

        twRc = CWiaDataSrc::GetCachedImage(&hDIB);
        if(TWRC_SUCCESS == twRc){

            //
            // cached data is always upside down orientation
            // because it was acquired using the TransferToMemory()
            // API. Call FlipDIB() to correct the image's orientation
            // and to adjust any negative heights that may exist.
            //

            FlipDIB(hDIB,TRUE);

            twRc = WriteDIBToFile(m_FileXferName, hDIB);

            GlobalFree(hDIB);
            hDIB = NULL;
        }
    } else {

        //
        // acquire a real image
        //

        twRc = CWiaDataSrc::TransferToFile(guidFormatID);
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::TransferToDIB(HGLOBAL *phDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pPendingXfers = FindCap(CAP_XFERCOUNT);
    if(pPendingXfers){
        if(IsFeederEnabled()){
            DBG_TRC(("CWiaScannerDS::TransferToDIB(), Scanner device is set to FEEDER mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)32767);
        } else {
            DBG_TRC(("CWiaScannerDS::TransferToDIB(), Scanner device is set to FLATBED mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)0);
        }
    }

    if (m_bCacheImage) {
        m_bCacheImage = FALSE;

        //
        // acquire a cached image
        //

        twRc = CWiaDataSrc::GetCachedImage(phDIB);
        if(TWRC_SUCCESS == twRc){

            //
            // cached data is always upside down orientation
            // because it was acquired using the TransferToMemory()
            // API. Call FlipDIB() to correct the image's orientation
            // and to adjust any negative heights that may exist.
            //

            FlipDIB(*phDIB,TRUE);

            twRc = TWRC_XFERDONE;
        }
    } else {

        //
        // acquire a real image
        //

        twRc = CWiaDataSrc::TransferToDIB(phDIB);
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::TransferToMemory(GUID guidFormatID)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    CCap *pPendingXfers = FindCap(CAP_XFERCOUNT);
    if(pPendingXfers){
        if(IsFeederEnabled()){
            DBG_TRC(("CWiaScannerDS::TransferToMemory(), Scanner device is set to FEEDER mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)32767);
        } else {
            DBG_TRC(("CWiaScannerDS::TransferToMemory(), Scanner device is set to FLATBED mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)0);
        }
    }

    if (m_bCacheImage) {
        m_bCacheImage = FALSE;

        //
        // acquire a cached image
        //

        //
        // cached data is already in the correct form to just pass
        // back because it was originally acquired using the TransferToMemory()
        // API.
        //

        twRc = CWiaDataSrc::GetCachedImage(&m_hMemXferBits);
        if(TWRC_FAILURE == twRc){
            DBG_ERR(("CWiaDataSrc::GetCachedImage(), failed to return cached data"));
        }
    } else {

        //
        // acquire a real image
        //

        twRc = CWiaDataSrc::TransferToMemory(guidFormatID);

        if(TWRC_FAILURE == twRc){
            DBG_ERR(("CWiaDataSrc::TransferToMemory(), failed to return data"));
        }
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::OnPendingXfersMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    CCap *pXferCount;
    pXferCount = FindCap(CAP_XFERCOUNT);
    if (!pXferCount) {
        m_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }

    twRc = TWRC_SUCCESS;
    switch (ptwMsg->MSG) {
    case MSG_GET:
        switch (GetTWAINState()) {
            case DS_STATE_4:
            case DS_STATE_5:
            case DS_STATE_6:
            case DS_STATE_7:
                if(m_bUnknownPageLength){
                    if(m_bUnknownPageLengthMultiPageOverRide){
                        ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
                        DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_GET returning %d (unknown page length device detected) MULTI-PAGE enabled",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
                    } else {
                        DBG_WRN(("CWiaScannerDS::OnPendingXfersMsg(), MSG_GET returning 0 (unknown page length device detected)"));
                        ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = 0; // force 1 page only
                    }
                } else {
                    ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
                    DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_GET returning %d",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
                }
                break;
            default:
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_SEQERROR;
                DSError();
                break;
        }
        break;
    case MSG_ENDXFER:
        if (DS_STATE_6 == GetTWAINState() || DS_STATE_7 == GetTWAINState()) {
            ResetMemXfer();
            TW_INT32 Count = 0;
            if (m_bUnknownPageLength) {
                if(m_bUnknownPageLengthMultiPageOverRide){
                    DBG_WRN(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER (unknown page length device detected) MULTI-PAGE enabled"));

                    //
                    // check to see if we are in FEEDER mode
                    //

                    if (IsFeederEnabled()) {

                        //
                        // check for documents
                        //

                        if (IsFeederEmpty()) {
                            Count = 0;
                        } else {
                            Count = pXferCount->GetCurrent();
                        }
                    } else {

                        //
                        // we must be in FLATBED mode, so force a single page transfer
                        //

                        Count = 0;
                    }
                } else {
                    DBG_WRN(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER returning 0 (unknown page length device detected)"));
                    Count = 0; // force a single page transfer only
                }
            } else {

                //
                // check to see if we are in FEEDER mode
                //

                if (IsFeederEnabled()) {

                    //
                    // check for documents
                    //

                    if (IsFeederEmpty()) {
                        Count = 0;
                    } else {
                        Count = pXferCount->GetCurrent();
                    }
                } else {

                    //
                    // we must be in FLATBED mode, so force a single page transfer
                    //

                    Count = 0;
                }
            }

            if(Count == 32767){
                DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER, -1 or (32767) (feeder may have more documents)"));
            } else if (Count > 0){
                Count--;
            } else {
                Count = 0;
            }

            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = (SHORT)Count;
            pXferCount->SetCurrent((TW_UINT32)Count);
            if (Count == 0) {

                DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER, no more pages to transfer"));

                //
                // Transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);
                NotifyCloseReq();
            } else if(Count == 32767){

                DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER, more pages to transfer"));

                //
                // Transition to STATE_6
                //

                SetTWAINState(DS_STATE_6);

            }
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    case MSG_RESET:
        if (DS_STATE_6 == GetTWAINState()) {

            //
            // Transition to STATE_5
            //

            SetTWAINState(DS_STATE_5);
            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = 0;

            ResetMemXfer();
            pXferCount->SetCurrent((TW_UINT32)0);
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::SetImageLayout(TW_IMAGELAYOUT *pImageLayout)
{
    DBG_FN_DS(CWiaScannerDS::SetImageLayout());
    HRESULT hr = S_OK;
    LONG lXPos = 0;
    LONG lYPos = 0;
    LONG lXExtent = 0;
    LONG lYExtent = 0;
    LONG lXRes = 0;
    LONG lYRes = 0;
    BOOL bCheckStatus = FALSE;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to set IWiaItem for property reading"));
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XPOS,&lXPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_XPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YPOS,&lYPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_YPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XEXTENT,&lXExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_XEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_YEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&lXRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_XRES"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&lYRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_YRES"));
        return TWRC_FAILURE;
    }

    //
    // read the current values of the device
    //

    if (SUCCEEDED(hr)) {
        DBG_TRC(("==============================================================================="));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), WIA extents from device at %d dpi(x), %d dpi(y)",lXRes,lYRes));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current X Position = %d",lXPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current Y Position = %d",lYPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current X Extent   = %d",lXExtent));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current Y Extent   = %d",lYExtent));
        DBG_TRC(("==============================================================================="));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN extents to convert.."));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN X Position = %f",Fix32ToFloat(pImageLayout->Frame.Left)));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN Y Position = %f",Fix32ToFloat(pImageLayout->Frame.Top)));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN X Extent   = %f",Fix32ToFloat(pImageLayout->Frame.Right)));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN Y Extent   = %f",Fix32ToFloat(pImageLayout->Frame.Bottom)));
        DBG_TRC(("==============================================================================="));

        lXPos = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Left),lXRes);
        lYPos = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Top),lYRes);
        lXExtent = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Right),lXRes);
        lYExtent = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Bottom),lYRes);

        DBG_TRC(("TWAIN -> WIA extent conversion at %d dpi(x), %d dpi(y)",lXRes,lYRes));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New X Position = %d",lXPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New Y Position = %d",lYPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New X Extent   = %d",lXExtent));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New Y Extent   = %d",lYExtent));
        DBG_TRC(("==============================================================================="));

        if (!m_bUnknownPageLength) {

            //
            // note: A failure to write the properties, isn't a large issue here, because
            //       TWAIN UI-LESS mode expects clipping.  They will reread properties
            //       for application's validation section.  All capabilities are validated
            //       against their valid values, before setting here.
            //

            //
            // Write extents first, because TWAIN expects Height/Width settings to validate
            // the new Pos settings.
            //

            hr = WIA.WritePropertyLong(WIA_IPS_XEXTENT,lXExtent);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_XEXTENT"));
                bCheckStatus = TRUE;
            }

            hr = WIA.WritePropertyLong(WIA_IPS_YEXTENT,lYExtent);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_YEXTENT"));
                bCheckStatus = TRUE;
            }

            //
            // Write position settings...(top-of-page offsets)
            //

            hr = WIA.WritePropertyLong(WIA_IPS_XPOS,lXPos);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_XPOS"));
                bCheckStatus = TRUE;
            }

            hr = WIA.WritePropertyLong(WIA_IPS_YPOS,lYPos);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_YPOS"));
                bCheckStatus = TRUE;
            }

            if (bCheckStatus) {
                DBG_TRC(("CWiaScannerDS::SetImageLayout(), some settings could not be set exactly, so return TWRC_CHECKSTATUS"));
                //return TWRC_CHECKSTATUS;
            }
        } else {
            DBG_WRN(("CWiaScannerDS::SetImageLayout(), ImageLayout is does not make since when using a UnknownPageLength Device"));
            //return TWRC_CHECKSTATUS;
        }

    } else {
        return TWRC_FAILURE;
    }

    //
    // Always return TWRC_CHECKSTATUS because we may have rounding errors.
    // According to the TWAIN spec, a return of TWRC_CHECKSTATUS tells the
    // calling application that we successfully set the settings, but there
    // may have been some changes (clipping etc.) So the Calling application
    // is required to requery for our current settings.
    //

    //
    // call GetImageLayout to update our TWAIN capabilities to match our new WIA settings.
    //

    GetImageLayout(&m_CurImageLayout);

    return TWRC_CHECKSTATUS; //return TWRC_SUCCESS;
}
TW_UINT16 CWiaScannerDS::GetImageLayout(TW_IMAGELAYOUT *pImageLayout)
{
    DBG_FN_DS(CWiaScannerDS::GetImageLayout());
    HRESULT hr = S_OK;
    LONG lXPos = 0;
    LONG lYPos = 0;
    LONG lXExtent = 0;
    LONG lYExtent = 0;
    LONG lXRes = 0;
    LONG lYRes = 0;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to set IWiaItem for property reading"));
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XPOS,&lXPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_XPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YPOS,&lYPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_YPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XEXTENT,&lXExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_XEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_YEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&lXRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_XRES"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&lYRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_YRES"));
        return TWRC_FAILURE;
    }

    if (SUCCEEDED(hr)) {

        if(lXRes <= 0){
            DBG_ERR(("CWiaScannerDS::GetImageLayout(), WIA_IPS_XRES returned an invalid value (%d)",lXRes));
            return TWRC_FAILURE;
        }

        if(lYRes <= 0){
            DBG_ERR(("CWiaScannerDS::GetImageLayout(), WIA_IPS_YRES returned an invalid value (%d)",lYRes));
            return TWRC_FAILURE;
        }

        pImageLayout->Frame.Top      = FloatToFix32((float)((float)lYPos/(float)lYRes));
        pImageLayout->Frame.Left     = FloatToFix32((float)((float)lXPos/(float)lXRes));
        pImageLayout->Frame.Right    = FloatToFix32((float)((float)lXExtent/(float)lXRes));
        pImageLayout->Frame.Bottom   = FloatToFix32((float)((float)lYExtent/(float)lYRes));
    } else {
        return TWRC_FAILURE;
    }

    if(m_bUnknownPageLength){
        DBG_WRN(("CWiaScannerDS::GetImageLayout(), ImageLayout is does not make since when using a UnknownPageLength Device"));
        return TWRC_CHECKSTATUS;
    }
    return TWRC_SUCCESS;
}
TW_UINT16 CWiaScannerDS::GetResolutions()
{
    DBG_FN_DS(CWiaScannerDS::GetResolutions());
    HRESULT hr = S_OK;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to set IWiaItem for property reading"));
        return TWRC_FAILURE;
    }

    TW_UINT16 twRc = TWRC_FAILURE;
    TW_RANGE twOptionalYRange;
    memset(&twOptionalYRange,0,sizeof(twOptionalYRange));
    TW_UINT32 *pOptionalYResArray = NULL;
    TW_UINT32 OptionalYResNumValues = 0;
    BOOL bOptionalYResRange = FALSE;

    PROPVARIANT pv;
    memset(&pv,0,sizeof(pv));
    LONG lAccessFlags = 0;
    hr = WIA.ReadPropertyAttributes(WIA_IPS_XRES,&lAccessFlags,&pv);
    if (SUCCEEDED(hr)) {

        //
        // collect valid values for X resolutions
        //

        CCap *pCap = FindCap(ICAP_XRESOLUTION);
        if (pCap) {
            if (lAccessFlags & WIA_PROP_RANGE) {
                twRc = pCap->Set((TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_MIN],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_MAX],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_STEP]); // range
                //
                // save X resolution values in RANGE form (just in case the Y
                // resolution is WIA_PROP_NONE)
                //

                twOptionalYRange.ItemType     = TWTY_UINT32;
                twOptionalYRange.CurrentValue = (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM];
                twOptionalYRange.DefaultValue = (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM];
                twOptionalYRange.MinValue     = (TW_UINT32)pv.caul.pElems[WIA_RANGE_MIN];
                twOptionalYRange.MaxValue     = (TW_UINT32)pv.caul.pElems[WIA_RANGE_MAX];
                twOptionalYRange.StepSize     = (TW_UINT32)pv.caul.pElems[WIA_RANGE_STEP];

                bOptionalYResRange = TRUE;

            } else if (lAccessFlags & WIA_PROP_LIST) {
                TW_UINT32 *pResArray = new TW_UINT32[WIA_PROP_LIST_COUNT(&pv)];
                if (pResArray) {
                    memset(pResArray,0,(sizeof(TW_UINT32)*WIA_PROP_LIST_COUNT(&pv)));
                    pOptionalYResArray = new TW_UINT32[WIA_PROP_LIST_COUNT(&pv)];
                    if (pOptionalYResArray) {
                        memset(pOptionalYResArray,0,(sizeof(TW_UINT32)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {
                            pResArray[i] = (TW_UINT32)pv.caul.pElems[i+2];

                            //
                            // save the X resolution values in LIST form (just in case the Y
                            // resolution is WIA_PROP_NONE)
                            //

                            pOptionalYResArray[i] = (TW_UINT32)pv.caul.pElems[i+2];
                        }

                        //
                        // save the number of X resolutions saved
                        //

                        OptionalYResNumValues = (TW_UINT32)WIA_PROP_LIST_COUNT(&pv);

                        twRc = pCap->Set(0,0,WIA_PROP_LIST_COUNT(&pv),(BYTE*)pResArray,TRUE); // list
                    } else {
                        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to allocate optional Y Resolution Array Memory"));
                        twRc =  TWRC_FAILURE;
                    }

                    delete [] pResArray;
                    pResArray = NULL;
                } else {
                    DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to allocate X Resolution Array Memory"));
                    twRc =  TWRC_FAILURE;
                }
            } else if (lAccessFlags & WIA_PROP_NONE) {

                //
                // we are a "real" WIA_PROP_NONE value
                //

                LONG lCurrentValue = 0;
                hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&lCurrentValue);
                if (SUCCEEDED(hr)) {
                    TW_UINT32 OneValueArray[1];
                    OneValueArray[0] = (TW_UINT32)lCurrentValue;
                    twRc = pCap->Set(0,0,1,(BYTE*)OneValueArray,TRUE); // list
                } else {
                    DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read X Resolution current value"));
                    twRc = TWRC_FAILURE;
                }
            }
        }

        PropVariantClear(&pv);
    } else {
        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read WIA_IPS_XRES attributes"));
        twRc = TWRC_FAILURE;
    }

    if (TWRC_SUCCESS == twRc) {
        memset(&pv,0,sizeof(pv));
        lAccessFlags = 0;
        hr = WIA.ReadPropertyAttributes(WIA_IPS_YRES,&lAccessFlags,&pv);
        if (SUCCEEDED(hr)) {

            //
            // collect valid values for Y resolutions
            //

            CCap *pCap = FindCap(ICAP_YRESOLUTION);
            if (pCap) {
                if (lAccessFlags & WIA_PROP_RANGE) {
                    twRc = pCap->Set((TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_MIN],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_MAX],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_STEP]); // range
                } else if (lAccessFlags & WIA_PROP_LIST) {
                    TW_UINT32 *pResArray = new TW_UINT32[WIA_PROP_LIST_COUNT(&pv)];
                    if (pResArray) {
                        memset(pResArray,0,(sizeof(TW_UINT32)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {
                            pResArray[i] = (TW_UINT32)pv.caul.pElems[i+2];
                        }

                        twRc = pCap->Set(0,0,WIA_PROP_LIST_COUNT(&pv),(BYTE*)pResArray,TRUE); // list
                        delete [] pResArray;
                        pResArray = NULL;
                    } else {
                        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to allocate Y Resolution Array Memory"));
                        twRc = TWRC_FAILURE;
                    }
                } else if (lAccessFlags & WIA_PROP_NONE) {

                    if (pOptionalYResArray) {

                        //
                        // if we have an optional array allocated, then X Resolution must be in
                        // array form, so match it.
                        //

                        twRc = pCap->Set(0,0,OptionalYResNumValues,(BYTE*)pOptionalYResArray,TRUE); // list

                    } else if (bOptionalYResRange) {

                        //
                        // if the RANGE flag is set to TRUE, then X Resolution must be in range form, so match it.
                        //

                        twRc = pCap->Set(twOptionalYRange.DefaultValue,
                                         twOptionalYRange.CurrentValue,
                                         twOptionalYRange.MinValue,
                                         twOptionalYRange.MaxValue,
                                         twOptionalYRange.StepSize); // range

                    } else {

                        //
                        // we are a "real" WIA_PROP_NONE value
                        //

                        LONG lCurrentValue = 0;
                        hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&lCurrentValue);
                        if (SUCCEEDED(hr)) {
                            TW_UINT32 OneValueArray[1];
                            OneValueArray[0] = (TW_UINT32)lCurrentValue;
                            twRc = pCap->Set(0,0,1,(BYTE*)OneValueArray,TRUE); // list
                        } else {
                            DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read Y Resolution current value"));
                            twRc = TWRC_FAILURE;
                        }
                    }
                }
            }

            PropVariantClear(&pv);
        } else {
            DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read WIA_IPS_YRES attributes"));
            twRc = TWRC_FAILURE;
        }
    }

    if (pOptionalYResArray) {
        delete [] pOptionalYResArray;
        pOptionalYResArray = NULL;
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::GetSettings()
{
    DBG_FN_DS(CWiaScannerDS::GetSettings());
    TW_UINT16 twRc = TWRC_SUCCESS;
    twRc = GetImageLayout(&m_CurImageLayout);
    if (TWRC_SUCCESS == twRc) {
        twRc = GetResolutions();
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::SetSettings(CCap *pCap)
{
    DBG_FN_DS(CWiaScannerDS::SetSettings());
    HRESULT hr = S_OK;
    LONG lValue = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::SetSettings(), failed to set IWiaItem for property reading"));
    }

    //
    // determine if it is a Capability that the device really needs to know
    // about.
    //

    switch (pCap->GetCapId()) {
    case CAP_FEEDERENABLED:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(CAP_FEEDERENABLED)"));
        lValue = (LONG)pCap->GetCurrent();
        if(lValue){
            DBG_TRC(("CWiaScannerDS::SetSettings(), Setting FEEDER mode"));
            lValue = FEEDER;
        } else {
            DBG_TRC(("CWiaScannerDS::SetSettings(), Setting FLATBED mode Enabled"));
            lValue = FLATBED;
        }
        hr = m_pCurrentIWiaItem->GetRootItem(&pIRootItem);
        if(S_OK == hr){
            hr = WIA.SetIWiaItem(pIRootItem);
            if(SUCCEEDED(hr)){

                //
                // read current document handling select setting
                //

                LONG lCurrentDocumentHandlingSelect = 0;
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lCurrentDocumentHandlingSelect);
                if(lValue == FEEDER){
                    lCurrentDocumentHandlingSelect &= ~FLATBED;
                } else {
                    lCurrentDocumentHandlingSelect &= ~FEEDER;
                }

                //
                // add the intended settings, and write them to the WIA device
                //

                lValue = lValue | lCurrentDocumentHandlingSelect;
                hr = WIA.WritePropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,lValue);

                if(SUCCEEDED(hr)){

                    //
                    // adjust ICAP_PHYSICALWIDTH and ICAP_PHYSICALHEIGHT
                    //

                    LONG lWidth  = 0;
                    LONG lHeight = 0;
                    TW_UINT32 Value = 0;
                    CCap* pPhysicalCap = NULL;
                    TW_FIX32 fix32;
                    memset(&fix32,0,sizeof(fix32));

                    if(lValue & FEEDER){

                        //
                        // read current horizontal sheet feeder size
                        //

                        hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,&lWidth);

                    } else {

                        //
                        // read current horizontal bed size
                        //

                        hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_BED_SIZE,&lWidth);

                    }

                    if(SUCCEEDED(hr)){

                        //
                        // find the TWAIN capability ICAP_PHYSICALWIDTH
                        //

                        pPhysicalCap = FindCap(ICAP_PHYSICALWIDTH);
                        if(pPhysicalCap){

                            //
                            // set the current value, by reading the current setting from
                            // the WIA property WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE and
                            // dividing by 1000.0 (because WIA units are in 1/1000th of
                            // an inch)
                            //

                            memset(&fix32,0,sizeof(fix32));
                            fix32 = FloatToFix32((FLOAT)(lWidth / 1000.00));
                            memcpy(&Value, &fix32, sizeof(TW_UINT32));
                            if(TWRC_SUCCESS == pPhysicalCap->Set(Value, Value, Value, Value)){

                                //
                                // if setting the new ICAP_PHYSICALWIDTH was successful, continue
                                // and attempt to set the ICAP_PHYSICALHEIGHT
                                //

                                if(lValue & FEEDER){

                                    //
                                    // read current vertical sheet feeder size
                                    //

                                    hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_SHEET_FEED_SIZE,&lHeight);
                                } else {

                                    //
                                    // read current vertical bed size
                                    //

                                    hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_BED_SIZE,&lHeight);
                                }

                                if (S_OK == hr){

                                    //
                                    // if the setting was successful, continue to attempt to set
                                    // ICAP_PHYSICALHEIGHT setting.
                                    //

                                    pPhysicalCap = FindCap(ICAP_PHYSICALHEIGHT);
                                    if (pPhysicalCap){

                                        //
                                        // set the current value, by reading the current setting from
                                        // the WIA property WIA_DPS_VERTICAL_SHEET_FEED_SIZE and
                                        // dividing by 1000.0 (because WIA units are in 1/1000th of
                                        // an inch)
                                        //

                                        memset(&fix32,0,sizeof(fix32));
                                        fix32 = FloatToFix32((FLOAT)(lHeight / 1000.00));
                                        memcpy(&Value, &fix32, sizeof(TW_UINT32));
                                        if (TWRC_SUCCESS != pPhysicalCap->Set(Value, Value, Value, Value)){
                                            DBG_WRN(("CWiaScannerDS::SetSettings(), could not update TWAIN ICAP_PHYSICALHEIGHT settings"));
                                        }
                                    }
                                } else {

                                    //
                                    // allow this to pass, because we are either dealing with a "unknown length"
                                    // device and it can not tell us the height, or the driver can not give us this
                                    // value at this time.. (this is OK, because this setting is not fully needed for
                                    // proper data transfers.)  Worst case scenerio: The TWAIN compat layer will
                                    // report the same height as the flatbed for the new ICAP_PHYSICALHEIGHT value.
                                    //

                                    hr = S_OK;
                                }
                            }
                        } else {
                            DBG_ERR(("CWiaScannerDS::SetSettings(), could not find ICAP_PHYSICALHEIGHT capability"));
                        }
                    } else {
                        DBG_ERR(("CWiaScannerDS::SetSettings(), failed to read physical sheet feeder size settings"));
                    }
                }
            }
            pIRootItem->Release();
        }
        break;
    case ICAP_XRESOLUTION:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_XRESOLUTION)"));
        lValue = (LONG)pCap->GetCurrent();
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting X Resolution to %d",lValue));
        hr = WIA.WritePropertyLong(WIA_IPS_XRES,lValue);
        break;
    case ICAP_YRESOLUTION:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_YRESOLUTION)"));
        lValue = (LONG)pCap->GetCurrent();
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting Y Resolution to %d",lValue));
        hr = WIA.WritePropertyLong(WIA_IPS_YRES,lValue);
        break;
    case ICAP_BRIGHTNESS:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_BRIGHTNESS)"));
        lValue = (LONG)pCap->GetCurrent();
        // to do: convert -1000 to 1000 range value in the range specified by the WIA driver
        //        and set that to lValue.
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting WIA_IPS_BRIGHTNESS to %d",lValue));
        break;
    case ICAP_CONTRAST:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_CONTRAST)"));
        lValue = (LONG)pCap->GetCurrent();
        // to do: convert -1000 to 1000 range value in the range specified by the WIA driver
        //        and set that to lValue.
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting WIA_IPS_CONTRAST to %d",lValue));
        break;
    default:
        DBG_TRC(("CWiaScannerDS::SetSettings(), data source is not setting CAPID = %x to WIA device (it is not needed)",pCap->GetCapId()));
        break;
    }

    if (SUCCEEDED(hr)) {
        DBG_TRC(("CWiaScannerDS::SetSettings(), Settings were successfully sent to WIA device"));
    } else {
        DBG_ERR(("CWiaScannerDS::SetSettings(), Settings were unsuccessfully sent to WIA device"));
        return TWRC_FAILURE;
    }

    return TWRC_SUCCESS;
}

BOOL CWiaScannerDS::IsUnknownPageLengthDevice()
{
    DBG_FN_DS(CWiaScannerDS::IsUnknownPageLengthDevice());
    HRESULT hr = S_OK;
    BOOL bIsUnknownPageLengthDevice = FALSE;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::IsUnknownPageLengthDevice(), failed to set IWiaItem for property reading"));
        return FALSE;
    }

    LONG lYExtent = 0;
    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::IsUnknownPageLengthDevice(), failed to read WIA_IPS_YEXTENT"));
    }

    if(SUCCEEDED(hr)){
        if(S_FALSE == hr){      // property does not exist, so we have to support this feature
            bIsUnknownPageLengthDevice = TRUE;
        } else if(S_OK == hr){  // property exists, (need more information, so check the current value)
            if(lYExtent == 0){  // property is set to 0, which means unknown page length is supported
                bIsUnknownPageLengthDevice = TRUE;
            }
        }
    }

    if(bIsUnknownPageLengthDevice){
        DBG_TRC(("CWiaScannerDS::IsUnknownPageLengthDevice(), device is set to do unknown page length"));
    } else {
        DBG_TRC(("CWiaScannerDS::IsUnknownPageLengthDevice(), device is not set to do unknown page length"));
    }

    return bIsUnknownPageLengthDevice;
}

BOOL CWiaScannerDS::IsFeederEnabled()
{
    DBG_FN_DS(CWiaScannerDS::IsFeederEnabled());
    HRESULT hr = S_OK;
    BOOL bIsFeederEnabled = FALSE;
    LONG lDocumentHandlingSelect = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = m_pCurrentIWiaItem->GetRootItem(&pIRootItem);
    if (SUCCEEDED(hr)) {
        if (NULL != pIRootItem) {
            hr = WIA.SetIWiaItem(pIRootItem);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::IsFeederEnabled(), failed to set IWiaItem for property reading"));
            }

            if (SUCCEEDED(hr)) {
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocumentHandlingSelect);
                if (FAILED(hr)) {
                   DBG_ERR(("CWiaScannerDS::IsFeederEnabled(), failed to read WIA_DPS_DOCUMENT_HANDLING_SELECT"));
                }

                if (S_OK == hr) {
                    if ((lDocumentHandlingSelect & FEEDER) == FEEDER) {
                        bIsFeederEnabled = TRUE;
                    }
                } else if (S_FALSE == hr) {
                    DBG_WRN(("CWiaScannerDS::IsFeederEnabled(), WIA_DPS_DOCUMENT_HANDLING_SELECT was not found...defaulting to FLATBED"));
                }
            }

            pIRootItem->Release();
            pIRootItem = NULL;
        }
    } else {
        DBG_ERR(("CWiaScannerDS::IsFeederEnabled(), failed to get ROOT IWiaItem from current IWiaItem"));
    }
    return bIsFeederEnabled;
}

BOOL CWiaScannerDS::IsFeederEmpty()
{
    DBG_FN_DS(CWiaScannerDS::IsFeederEmpty());
    HRESULT hr = S_OK;
    BOOL bIsFeederEmpty = TRUE;
    LONG lDocumentHandlingStatus = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = m_pCurrentIWiaItem->GetRootItem(&pIRootItem);
    if (SUCCEEDED(hr)) {
        if (NULL != pIRootItem) {
            hr = WIA.SetIWiaItem(pIRootItem);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::IsFeederEmpty(), failed to set IWiaItem for property reading"));
            }

            if (SUCCEEDED(hr)) {
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_STATUS,&lDocumentHandlingStatus);
                if (FAILED(hr)) {
                   DBG_ERR(("CWiaScannerDS::IsFeederEmpty(), failed to read WIA_DPS_DOCUMENT_HANDLING_STATUS"));
                }

                if (S_OK == hr) {
                    if (lDocumentHandlingStatus & FEED_READY) {
                        bIsFeederEmpty = FALSE;
                    }
                } else if (S_FALSE == hr) {
                    DBG_WRN(("CWiaScannerDS::IsFeederEmpty(), WIA_DPS_DOCUMENT_HANDLING_STATUS was not found"));
                }
            }

            pIRootItem->Release();
            pIRootItem = NULL;
        }
    } else {
        DBG_ERR(("CWiaScannerDS::IsFeederEmpty(), failed to get ROOT IWiaItem from current IWiaItem"));
    }
    return bIsFeederEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\progress.cpp ===
#include "precomp.h"

//
// WIA data callback implementation
//


STDMETHODIMP_(ULONG) CWiaDataCallback::AddRef()
{
    InterlockedIncrement((LONG*)&m_Ref);
    return m_Ref;
}

STDMETHODIMP_(ULONG) CWiaDataCallback::Release()
{
    if (!InterlockedDecrement((LONG*)&m_Ref)) {
        m_Ref++;
        delete this;
        return(ULONG) 0;
    }
    return m_Ref;
}

STDMETHODIMP CWiaDataCallback::QueryInterface(REFIID iid, void **ppv)
{
    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;
    if (IID_IUnknown == iid) {
        *ppv = (IUnknown*)this;
        AddRef();
        return S_OK;
    } else if (IID_IWiaDataCallback == iid) {
        *ppv = (IWiaDataCallback *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

HRESULT CWiaDataCallback::Initialize(HWND hWndOwner,BOOL bShowProgress)
{
    m_hwndOwner = hWndOwner;
    if (bShowProgress) {
        if (NULL == m_pProgDlg) {
            m_pProgDlg = new CProgressDlg();
            if (!m_pProgDlg) {
                return E_OUTOFMEMORY;
            }
            m_pProgDlg->Initialize(g_hInstance, IDD_PROGRESSDLG);
        }
        //
        // Preload progress title strings
        //
        m_pszXferFromDevice = LoadResourceString(IDS_PROGRESS_XFER_FROM_DEVICE);
        m_pszProcessingData = LoadResourceString(IDS_PROGRESS_PROCESSING_DATA);
        m_pszXferToClient = LoadResourceString(IDS_PROGRESS_XFER_TO_CLIENT);
        m_bSetTitle = FALSE;
        if (!m_pszXferFromDevice || !m_pszProcessingData || !m_pszXferToClient) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (m_pProgDlg->DoModeless(m_hwndOwner, (LPARAM)m_pProgDlg)) {
            m_pProgDlg->SetRange(0, 100);
            m_pProgDlg->SetPos(0);
            m_lCurrentTextUpdate = TITLE_TRANSFERTOCLIENT;
            m_pProgDlg->SetTitle(m_pszXferToClient);
        } else {
            DBG_ERR(("DoModeless Failed to create Progress Dialog"));
        }
    }
    return S_OK;
}

#define WIADSMSG_PROGRESS           MSG_USER + 0

STDMETHODIMP CWiaDataCallback::BandedDataCallback(LONG lMessage,LONG lStatus,LONG lPercentComplete,
                                                  LONG lOffset,LONG Length,LONG lReserved,
                                                  LONG lResLength,BYTE *pData)
{
    HRESULT hr = S_OK;

    switch (lMessage) {
    case IT_MSG_FILE_PREVIEW_DATA_HEADER:   // we do nothing with file preview header data
        break;
    case IT_MSG_DATA_HEADER:
        {
            PWIA_DATA_CALLBACK_HEADER pHeader = NULL;
            pHeader = (PWIA_DATA_CALLBACK_HEADER)pData;
            if(pHeader->guidFormatID == WiaImgFmt_MEMORYBMP){
                DBG_TRC(("pHeader->guidFormatID = WiaImgFmt_MEMORYBMP"));
                m_bBitmapData = TRUE;
            } else if(pHeader->guidFormatID == WiaImgFmt_MEMORYBMP){
                DBG_TRC(("pHeader->guidFormatID = WiaImgFmt_RAWRGB"));
                m_bBitmapData = FALSE;
            } else {
                DBG_TRC(("pHeader->guidFormatID = (unknown)"));
                m_bBitmapData = TRUE;
            }

            m_MemBlockSize = pHeader->lBufferSize;
            DBG_TRC(("CWiaDataCallback::BandedDataCallback(), IT_MSG_DATA_HEADER Reports"));
            DBG_TRC(("pHeader->lBufferSize = %d",pHeader->lBufferSize));
            DBG_TRC(("pHeader->lPageCount  = %d",pHeader->lPageCount));
            DBG_TRC(("pHeader->lSize       = %d",pHeader->lSize));

            //
            // if we get a lbuffer size of zero, allocate one for us,
            // and maintain the size.
            //

            DBG_TRC(("MemBlockSize         = %d",pHeader->lBufferSize));
            if(m_MemBlockSize <= 0){
                m_MemBlockSize = (520288 * 2);
                DBG_WRN(("CWiaDataCallback::BandedDataCallback(), adjusting MemBlockSize to %d",m_MemBlockSize));
            }

            if (m_hImage) {
                GlobalFree(m_hImage);
                m_hImage = NULL;
                m_pImage = NULL;
                m_ImageSize = 0;
                m_SizeTransferred = 0;
            }

            m_SizeTransferred = 0;

            //
            // allocate the buffer
            //

            m_hImage = (HGLOBAL)GlobalAlloc(GHND, m_MemBlockSize);
            hr = E_OUTOFMEMORY;
            if (m_hImage) {
                hr = S_OK;
            }
            break;
        }
    case IT_MSG_FILE_PREVIEW_DATA:  // we do nothing with file preview data
        break;
    case IT_MSG_DATA:
        {
            m_SizeTransferred += Length;
            if((LONG)m_SizeTransferred >= m_MemBlockSize){
                m_MemBlockSize += (Length * MEMORY_BLOCK_FACTOR);

                //
                // process allocation into a temp handle, and fail, if allocation
                // fails.
                //

                HGLOBAL hTempMemory = (HGLOBAL)GlobalReAlloc(m_hImage,m_MemBlockSize,LMEM_MOVEABLE);
                if(hTempMemory){
                    m_hImage = hTempMemory;
                } else {
                    if(m_hImage){
                        GlobalFree(m_hImage);
                        m_hImage = NULL;
                    }
                    return E_OUTOFMEMORY;
                }
            }

            //
            // lock memory down
            //

            m_pImage = (BYTE*)GlobalLock(m_hImage);
            if (m_pImage) {
                DBG_TRC(("Copying %d into m_pImage (m_hImage = 0x%X, m_pImage = 0x%X) buffer",Length,m_hImage,m_pImage));
                memcpy(m_pImage + lOffset, pData,  Length);

                //
                // unlock memory
                //

                GlobalUnlock(m_hImage);
            } else {
                DBG_ERR(("Could not lock down m_hImage memory block"));
            }

            /*
            if (Length == 40) {
                BITMAPINFOHEADER* pbmi = NULL;
                pbmi = (BITMAPINFOHEADER*)pData;
                DBG_TRC(("CWiaDataCallback::BandedDataCallback(), Reported BITMAPINFOHEADER from IT_MSG_DATA"));
                DBG_TRC(("pbmi->biSize          = %d",pbmi->biSize));
                DBG_TRC(("pbmi->biSizeImage     = %d",pbmi->biSizeImage));
                DBG_TRC(("pbmi->biBitCount      = %d",pbmi->biBitCount));
                DBG_TRC(("pbmi->biClrImportant  = %d",pbmi->biClrImportant));
                DBG_TRC(("pbmi->biClrUsed       = %d",pbmi->biClrUsed));
                DBG_TRC(("pbmi->biCompression   = %d",pbmi->biCompression));
                DBG_TRC(("pbmi->biHeight        = %d",pbmi->biHeight));
                DBG_TRC(("pbmi->biWidth         = %d",pbmi->biWidth));
                DBG_TRC(("pbmi->biPlanes        = %d",pbmi->biPlanes));
                DBG_TRC(("pbmi->biXPelsPerMeter = %d",pbmi->biXPelsPerMeter));
                DBG_TRC(("pbmi->biYPelsPerMeter = %d",pbmi->biYPelsPerMeter));
            }
            */

            if (m_pProgDlg) {
                m_lCurrentTextUpdate = TITLE_TRANSFERTOCLIENT;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszXferToClient);
                }
                m_pProgDlg->SetPos(lPercentComplete);
            }
        }
        break;
    case IT_MSG_STATUS:
        if (m_pProgDlg) {
            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE) {
                m_lCurrentTextUpdate = TITLE_FROMDEVICE;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszXferFromDevice);
                }
            } else if (lStatus & IT_STATUS_PROCESSING_DATA) {
                m_lCurrentTextUpdate = TITLE_PROCESSINGDATA;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszProcessingData);
                }
            } else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT) {
                m_lCurrentTextUpdate = TITLE_TRANSFERTOCLIENT;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszXferToClient);
                }
            }
            m_pProgDlg->SetPos(lPercentComplete);
        }
        break;
    case IT_MSG_TERMINATION:

        if (m_pProgDlg) {
            delete m_pProgDlg;
            m_pProgDlg = NULL;
        }
        break;
    default:
        break;
    }

    //
    // check for user cancel operation
    //

    if (m_pProgDlg && m_pProgDlg->CheckCancelled()) {
        hr = S_FALSE;
    }

    //
    // transfer failed, or user pressed cancel
    //

    if (FAILED(hr) || S_FALSE == hr) {
        if(FAILED(hr)){
            DBG_ERR(("CWiaDataCallback::BandedDataCallback(), The transfer failed"));
        } else {
            DBG_WRN(("CWiaDataCallback::BandedDataCallback(), The user pressed cancel"));
        }

        if (m_pProgDlg) {
            delete m_pProgDlg;
            m_pProgDlg = NULL;
        }
    }

    //
    // save last hr
    //

    m_hrLast = hr;
    return hr;
}

HRESULT CWiaDataCallback::GetImage(HGLOBAL *phImage,ULONG *pImageSize)
{
    if (!phImage)
        return E_INVALIDARG;

    if (pImageSize)
        *pImageSize = 0;
    *phImage = NULL;

    if (SUCCEEDED(m_hrLast)) {
        if (m_bBitmapData) {

            //
            // we need to adjust any headers, because the height and image size information
            // could be incorrect. (this will handle infinite page length devices)
            //

            BITMAPINFOHEADER *pbmh = NULL;
            pbmh = (BITMAPINFOHEADER*)GlobalLock(m_hImage);
            if (pbmh) {
                // only fix the BITMAPINFOHEADER if height needs to be calculated
                if (pbmh->biHeight == 0) {
                    LONG lPaletteSize     = pbmh->biClrUsed * sizeof(RGBQUAD);
                    LONG lWidthBytes      = CalculateWidthBytes(pbmh->biWidth,pbmh->biBitCount);
                    pbmh->biSizeImage     = m_SizeTransferred - lPaletteSize - sizeof(BITMAPINFOHEADER);
                    pbmh->biHeight        = -(LONG)(pbmh->biSizeImage/lWidthBytes); // 0 also means upside down
                    pbmh->biXPelsPerMeter = 0;  // zero out
                    pbmh->biYPelsPerMeter = 0;  // zero out
                }
                m_lImageHeight = abs(pbmh->biHeight);
                m_lImageWidth = abs(pbmh->biWidth);
                GlobalUnlock(m_hImage);
            }
        }

        if (pImageSize){
            *pImageSize = m_SizeTransferred;
        }

        *phImage = m_hImage;

        //
        // reset internal variables, for next data transfer
        //

        m_hImage = NULL;
        m_pImage = NULL;
        m_SizeTransferred = 0;
        DBG_TRC(("CWiaDataCallback::GetImage(), Returned 0x%X (HANDLE pointer)",*phImage));
    }
    return m_hrLast;
}

LONG CWiaDataCallback::CalculateWidthBytes(LONG lWidthPixels,LONG lbpp)
{
    LONG lWidthBytes = 0;
    lWidthBytes = (lWidthPixels * lbpp) + 31;
    lWidthBytes = ((lWidthBytes/8) & 0xfffffffc);
    return lWidthBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\scanerds.h ===
#ifndef __SCANERDS_H_
#define __SCANERDS_H_

class CWiaScannerDS : public CWiaDataSrc
{
protected:

    //
    // overridden function definitions
    //

    virtual TW_UINT16 OpenDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 EnableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual TW_UINT16 OnImageLayoutMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 TransferToFile(GUID guidFormatID);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);
    virtual TW_UINT16 TransferToMemory(GUID guidFormatID);

private:

    //
    // scanner specific function definitions
    //

    TW_UINT16 SetImageLayout(TW_IMAGELAYOUT *pImageLayout);
    TW_UINT16 GetImageLayout(TW_IMAGELAYOUT *pImageLayout);
    TW_UINT16 GetResolutions();
    TW_UINT16 GetSettings();
    TW_UINT16 SetSettings(CCap *pCap);
    BOOL IsUnknownPageLengthDevice();
    BOOL IsFeederEnabled();
    BOOL IsFeederEmpty();

    //
    // scanner specific member variables
    //

    DWORD m_FeederCaps;
    BOOL  m_bEnforceUIMode;

    //
    // unknown page lenght scanning variables (cached data scans)
    //

    ULONG   m_ulBitsSize;
    BOOL    m_bUnknownPageLength;
    BOOL    m_bUnknownPageLengthMultiPageOverRide;
};

#endif //__SCANERDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   9-Feb-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#   TWAIN compatibility layer
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc


TARGETNAME=wiadss
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLDEF=$O\wiadss.def
DLLENTRY=DllMain
COFFBASE=usermode

#PRECOMPILED_INCLUDE = ..\precomp.h
#PRECOMPILED_PCH = precomp.pch
#PRECOMPILED_OBJ = precomp.obj

SOURCES= \
        ..\wiadss.rc    \
        ..\wiadss.cpp   \
        ..\cap.cpp      \
        ..\utils.cpp    \
        ..\datasrc.cpp  \
        ..\wiadev.cpp   \
        ..\camerads.cpp \
        ..\scanerds.cpp \
        ..\videods.cpp  \
        ..\progress.cpp \
        ..\wiahelper.cpp


TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib        \
            $(SDK_LIB_PATH)\wiaguid.lib         \
            $(WIA_LIB_PATH)\stirt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\utils.h ===
#ifndef __UTILS__H
#define __UTILS__H

#ifdef UNICODE
#define LSTRNCPY(str1, str2, n)     wcsncpy(str1, str2, n)
#else
#define LSTRNCPY(str1, str2, n)     strncpy(str1, str2, n)
#endif

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
#define SToT AToU
#define TToS UToA
#define AToT AToU
#define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
#define SToT UToA
#define TToS AToU
#define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#define TToU AToU
#endif

//
// WIA->TWAIN Capability Conversions
//

TW_UINT16 WIA_IPA_COMPRESSION_TO_ICAP_COMPRESSION(LONG lCompression);
TW_UINT16 WIA_IPA_DATATYPE_TO_ICAP_PIXELTYPE(LONG lDataType);
TW_UINT16 WIA_IPA_FORMAT_TO_ICAP_IMAGEFILEFORMAT(GUID guidFormat);

//
// TWAIN->WIA Property Conversions
//

LONG ICAP_COMPRESSION_TO_WIA_IPA_COMPRESSION(TW_UINT16 Compression);
LONG ICAP_PIXELTYPE_TO_WIA_IPA_DATATYPE(TW_UINT16 PixelType);
GUID ICAP_IMAGEFILEFORMAT_TO_WIA_IPA_FORMAT(TW_UINT16 ImageFileFormat);

//
// BITMAP / DIB data helper function definitions
//

#define BMPFILE_HEADER_MARKER ((WORD) ('M' << 8) | 'B')
TW_UINT16 WriteDIBToFile(LPSTR szFileName, HGLOBAL hDIB);

int GetDIBBitsOffset(BITMAPINFO *pbmi);
UINT GetDIBLineSize(UINT Width, UINT BitCount);
BOOL FlipDIB(HGLOBAL hDIB, BOOL bUpsideDown = FALSE);

UINT GetLineSize(PMEMORY_TRANSFER_INFO pInfo);

//
// string resource loader helper function definition
//

LPTSTR LoadResourceString(int StringId);

//
// TWAIN condition code (TW_STATUS) conversion helper function
//

TW_UINT16 TWCC_FROM_HRESULT(HRESULT hr);

//
// data source manager class definition
//

class CDSM
{
public:
    CDSM();
    ~CDSM();
    BOOL Notify(TW_IDENTITY *pSrc, TW_IDENTITY *pDst,
                TW_UINT32 twDG, TW_UINT16 twDAT, TW_UINT16 Msg,
                TW_MEMREF pData);
private:
    HINSTANCE       m_hDSM;
    DSMENTRYPROC    m_DSMEntry;
};

//
// dialog class definition
//

class CDialog
{
public:

    CDialog()
        {
            m_TemplateId = -1;
            m_hInst = NULL;
            m_hDlg = NULL;
        }
    void Initialize(HINSTANCE hInst, int TemplateId)
        {
            m_hInst = hInst;
            m_TemplateId = TemplateId;
        }
    virtual ~CDialog()
        {}

    static INT_PTR CALLBACK DialogWndProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR DoModal(HWND hwndOwner, LPARAM lParam)
        {
            if (m_hInst && -1 != m_TemplateId)
                return DialogBoxParam(m_hInst, MAKEINTRESOURCE(m_TemplateId),
                                      hwndOwner, DialogWndProc, lParam);
            else
                return -1;
        }
    BOOL DoModeless(HWND hwndOwner, LPARAM lParam)
        {
            if (m_hInst && -1 != m_TemplateId)
                m_hDlg = CreateDialogParam(m_hInst, MAKEINTRESOURCE(m_TemplateId),
                                           hwndOwner, DialogWndProc, lParam);
            return NULL != m_hDlg;
        }
    virtual BOOL OnInitDialog()
        {
            return TRUE;
        }
    virtual void OnCommand(WPARAM wParam, LPARAM lParam)
        {}
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo)
        {
            return FALSE;
        }
    virtual BOOL OnNotify(LPNMHDR pnmh)
        {
            SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;
        }

    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos)
        {
            return FALSE;
        }
    virtual BOOL OnMiscMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
            return FALSE;
        }

    LRESULT SendControlMsg( int ControlId, UINT Msg, WPARAM wParam = 0, LPARAM lParam = 0)
        {
            return SendDlgItemMessage(m_hDlg, ControlId, Msg, wParam, lParam);
        }
    HWND GetControl(int idControl)
        {
            return GetDlgItem(m_hDlg, idControl);
        }
    BOOL SetTitle(LPCTSTR Title)
        {
            if (m_hDlg)
                return ::SetWindowText(m_hDlg, Title);
            return FALSE;
        }
    operator HWND()
        {
            return m_hDlg;
        }
    HWND    m_hDlg;
protected:
    HINSTANCE    m_hInst;
    int          m_TemplateId;
};

#endif   // __UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\videods.h ===
#ifndef __VIDEODS_H_
#define __VIDEODS_H_

class CWiaVideoDS : public CWiaDataSrc
{
protected:

    //
    // overridden function definitions
    //

    virtual TW_UINT16 OpenDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual TW_UINT16 EnableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageInfoMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);

private:

    //
    // camera specific function definitions
    //

    TW_UINT16 SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap);
    TW_UINT16 SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap);

    //
    // camera specific member variables
    //

    BOOL m_bArrayModeAcquisition;
    LONG *m_pulImageIndexes;
    LONG m_lNumValidIndexes;
    LONG m_lCurrentArrayIndex;

    BOOL m_bRangeModeAcquisition;
    TW_RANGE m_twImageRange;
};

#endif  // __VIDEODS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\utils.cpp ===
#include "precomp.h"

//
// data source manager class implementation
//

CDSM::CDSM()
: m_hDSM(NULL),
m_DSMEntry(NULL)
{
}

CDSM::~CDSM()
{
    if (m_DSMEntry) {
        FreeLibrary(m_hDSM);
    }
}

BOOL CDSM::Notify(TW_IDENTITY *pidSrc,TW_IDENTITY *pidDst,TW_UINT32 twDG,
                  TW_UINT16 twDAT,TW_UINT16 twMsg,TW_MEMREF pData)
{
    if (!m_DSMEntry) {
        TCHAR szWindowsDirectory[MAX_PATH];
        memset(szWindowsDirectory,0,sizeof(szWindowsDirectory));
        if(GetWindowsDirectory(szWindowsDirectory,(sizeof(szWindowsDirectory)/sizeof(szWindowsDirectory[0]))) == 0)
        {
            //
            // could not get windows directory to load TWAIN_32.DLL to get the
            // DSM entry point.
            //

            return FALSE;
        }

        TCHAR szTwainDSMDir[MAX_PATH];
        memset(szTwainDSMDir,0,sizeof(szTwainDSMDir));

        //
        // create TWAIN_32.DLL loading, full path
        //

        _sntprintf(szTwainDSMDir,(sizeof(szTwainDSMDir)/sizeof(szTwainDSMDir[0])),TEXT("%s\\%s"),szWindowsDirectory,TEXT("TWAIN_32.DLL"));
        szTwainDSMDir[MAX_PATH - 1] = 0;

        m_hDSM = LoadLibrary(szTwainDSMDir);
        if (m_hDSM) {
            m_DSMEntry = (DSMENTRYPROC)GetProcAddress(m_hDSM, "DSM_Entry");
            if (!m_DSMEntry) {
                FreeLibrary(m_hDSM);
                m_hDSM = NULL;
                m_DSMEntry = NULL;
            }
        }
    }
    if (m_DSMEntry) {
        (*m_DSMEntry)(pidSrc, pidDst, twDG, twDAT, twMsg, pData);
        return TRUE;
    }
    return FALSE;
}

LPTSTR LoadResourceString(int StringId)
{
    LPTSTR str = NULL;
    TCHAR strTemp[256];
    int len;
    len = ::LoadString(g_hInstance, StringId, strTemp,
                       sizeof(strTemp)/sizeof(TCHAR));
    if (len) {
        str = new TCHAR[len + 1];
        if (str) {
            LSTRNCPY(str, strTemp, len + 1);
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    return str;
}

//
// dialog class implementation
//

INT_PTR CALLBACK CDialog::DialogWndProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    CDialog* pThis = (CDialog *) GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL Result;

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            pThis = (CDialog *)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
            pThis->m_hDlg = hDlg;
            Result = pThis->OnInitDialog();
            break;
        }
    case WM_COMMAND:
        {
            if (pThis)
                pThis->OnCommand(wParam, lParam);
            Result = FALSE;
            break;
        }
    case WM_HELP:
        {
            if (pThis)
                pThis->OnHelp((LPHELPINFO)lParam);
            Result = FALSE;
            break;
        }
    case WM_CONTEXTMENU:
        {
            if (pThis)
                pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            Result = FALSE;
            break;
        }
    case WM_NOTIFY:
        {
            if (pThis)
                pThis->OnNotify((LPNMHDR)lParam);
            Result = FALSE;
            break;
        }

    default:
        if (pThis)
            Result = pThis->OnMiscMsg(uMsg, wParam, lParam);
        else
            Result = FALSE;
        break;
    }
    return Result;
}

int GetDIBBitsOffset(BITMAPINFO *pbmi)
{
    int Offset = -1;
    if (pbmi && pbmi->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) {
        Offset = pbmi->bmiHeader.biSize;
        if (pbmi->bmiHeader.biBitCount <= 8) {
            if (pbmi->bmiHeader.biClrUsed) {
                Offset += pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD);
            } else {
                Offset += ((DWORD) 1 << pbmi->bmiHeader.biBitCount) * sizeof(RGBQUAD);
            }
        }
        if (BI_BITFIELDS == pbmi->bmiHeader.biCompression) {
            Offset += 3 * sizeof(DWORD);
        }
    }
    return Offset;
}

UINT GetLineSize(PMEMORY_TRANSFER_INFO pInfo)
{
    UINT uiWidthBytes = 0;

    uiWidthBytes = (pInfo->mtiWidthPixels * pInfo->mtiBitsPerPixel) + 31;
    uiWidthBytes = ((uiWidthBytes/8) & 0xfffffffc);

    return uiWidthBytes;
}

UINT GetDIBLineSize(UINT Width,UINT BitCount)
{
    UINT uiWidthBytes = 0;
    uiWidthBytes = (Width * BitCount) + 31;
    uiWidthBytes = ((uiWidthBytes/8) & 0xfffffffc);
    return uiWidthBytes;
}

BOOL FlipDIB(HGLOBAL hDIB, BOOL bUpsideDown)
{
    BITMAPINFO *pbmi = NULL;
    if (!hDIB) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pbmi = (BITMAPINFO *)GlobalLock(hDIB);
    if (pbmi == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check upside down flag
    //

    if (bUpsideDown) {
        if (pbmi->bmiHeader.biHeight < 0) {

            //
            // if the height is already negative, then the image
            // is already upside down.  Make the height positive
            // and you have a valid upside down image.
            //

            pbmi->bmiHeader.biHeight = abs(pbmi->bmiHeader.biHeight);
            GlobalUnlock(hDIB);
            return TRUE;
        }
    } else {

        //
        // if we do not need flipping, just return TRUE
        //

        if (pbmi->bmiHeader.biHeight > 0) {
            GlobalUnlock(hDIB);
            return TRUE;
        }
    }

    //
    // proceed to flip the DIB image
    //

    UINT LineSize = 0;
    UINT Height   = 0;
    UINT Line     = 0;
    BOOL Result = TRUE;

    BYTE *pTop, *pBottom, *pLine;
    // calculate the image height
    Height = abs(pbmi->bmiHeader.biHeight);
    //
    // get the line size. This is the unit we will be working on
    //
    LineSize = GetDIBLineSize(pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biBitCount);

    DBG_TRC(("FlipDIB, src height = %d", pbmi->bmiHeader.biHeight));

    //
    // line buffer for swapping data
    //
    pLine = new BYTE[LineSize];
    if (pLine) {
        pTop = (BYTE *)pbmi + GetDIBBitsOffset(pbmi);

        pBottom = pTop + (Height - 1) * LineSize;
        Height /= 2;
        for (Line = 0; Line < Height; Line++) {
            memcpy(pLine, pTop, LineSize);
            memcpy(pTop, pBottom, LineSize);
            memcpy(pBottom, pLine, LineSize);
            pTop += LineSize;
            pBottom -= LineSize;
        }
        pbmi->bmiHeader.biHeight = abs(pbmi->bmiHeader.biHeight);
        delete [] pLine;
    } else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        Result = FALSE;
    }
    GlobalUnlock(hDIB);
    return Result;
}

TW_UINT16 WriteDIBToFile(LPSTR szFileName, HGLOBAL hDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    //
    // write BITMAPFILEHEADER
    //

    BITMAPFILEHEADER bmfh;
    BITMAPINFOHEADER *pbmh = (BITMAPINFOHEADER *)GlobalLock(hDIB);
    if(pbmh){

        LONG lPaletteSize = pbmh->biClrUsed * sizeof(RGBQUAD);

        bmfh.bfType       = BMPFILE_HEADER_MARKER;
        bmfh.bfOffBits    = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + lPaletteSize;
        bmfh.bfSize       = pbmh->biSizeImage + bmfh.bfOffBits;
        bmfh.bfReserved1  = 0;
        bmfh.bfReserved2  = 0;

        LONG lDataSize    = sizeof(BITMAPINFOHEADER) + pbmh->biSizeImage + lPaletteSize;

        //
        // write BITMAP data (this includes header)
        //

        HANDLE hBitmapFile = NULL;
        hBitmapFile = CreateFileA(szFileName,
                                  GENERIC_WRITE,FILE_SHARE_READ,NULL,
                                  CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

        if (hBitmapFile != INVALID_HANDLE_VALUE && hBitmapFile != NULL) {

            DWORD dwBytesWritten = 0;

            //
            // write BITMAPFILHEADER
            //

            if((WriteFile(hBitmapFile,&bmfh,sizeof(bmfh),&dwBytesWritten,NULL)) && (dwBytesWritten == sizeof(bmfh))){

                //
                // write BITMAPINFOHEADER, palette, and data
                //

                if ((WriteFile(hBitmapFile,pbmh,lDataSize,&dwBytesWritten,NULL)) && (dwBytesWritten == lDataSize)) {

                    //
                    // return TWRC_XFERDONE when file has been saved to disk properly
                    //

                    twRc = TWRC_XFERDONE;
                } else {
                    DBG_ERR(("WriteDIBToFile, could not write the BITMAPINFOHEADER, palette, and data to file %s", szFileName));
                }

            } else {
                DBG_ERR(("WriteDIBToFile, could not write the BITMAPFILEHEADER to file %s", szFileName));
            }

            //
            // close file
            //

            CloseHandle(hBitmapFile);
            hBitmapFile = NULL;
        } else {
            DBG_ERR(("WriteDIBToFile, could not create the file %s", szFileName));
        }

        //
        // unlock memory when finished
        //

        GlobalUnlock(hDIB);
        pbmh = NULL;
    }

    return twRc;
}

TW_UINT16 TWCC_FROM_HRESULT(HRESULT hr)
{
    TW_UINT16 twCc = S_OK;
    switch (hr) {
    case S_OK:
        twCc = TWCC_SUCCESS;
        break;
    case E_OUTOFMEMORY:
        twCc = TWCC_LOWMEMORY;
        break;
    case E_INVALIDARG:
        twCc = TWCC_BADVALUE;
        break;
    case E_FAIL:
    default:
        twCc = TWCC_BUMMER;
        break;
    }
    return twCc;
}

TW_UINT16 WIA_IPA_COMPRESSION_TO_ICAP_COMPRESSION(LONG lCompression)
{
    TW_UINT16 Compression = TWCP_NONE;

    switch(lCompression){
    case WIA_COMPRESSION_NONE:
        Compression = TWCP_NONE;
        break;
    case WIA_COMPRESSION_BI_RLE4:
        Compression = TWCP_RLE4;
        break;
    case WIA_COMPRESSION_BI_RLE8:
        Compression = TWCP_RLE8;
        break;
    case WIA_COMPRESSION_G3:
        Compression = TWCP_GROUP31D;
        break;
    case WIA_COMPRESSION_G4:
        Compression = TWCP_GROUP4;
        break;
    case WIA_COMPRESSION_JPEG:
        Compression = TWCP_JPEG;
        break;
    default:
        break;
    }

    return Compression;
}

TW_UINT16 WIA_IPA_DATATYPE_TO_ICAP_PIXELTYPE(LONG lDataType)
{
    TW_UINT16 PixelType = TWPT_RGB;

    switch (lDataType) {
    case WIA_DATA_THRESHOLD:
        PixelType = TWPT_BW;
        break;
    case WIA_DATA_GRAYSCALE:
        PixelType = TWPT_GRAY;
        break;
    case WIA_DATA_COLOR:
        PixelType = TWPT_RGB;
        break;
    case WIA_DATA_DITHER:
    case WIA_DATA_COLOR_THRESHOLD:
    case WIA_DATA_COLOR_DITHER:
    default:
        break;
    }

    return PixelType;
}

TW_UINT16 WIA_IPA_FORMAT_TO_ICAP_IMAGEFILEFORMAT(GUID guidFormat)
{
    TW_UINT16 ImageFileFormat = TWFF_BMP;

    if (guidFormat == WiaImgFmt_BMP) {
        ImageFileFormat = TWFF_BMP;
    } else if (guidFormat == WiaImgFmt_JPEG) {
        ImageFileFormat = TWFF_JFIF;
    } else if (guidFormat == WiaImgFmt_TIFF) {
        ImageFileFormat = TWFF_TIFF;
    } else if (guidFormat == WiaImgFmt_PICT) {
        ImageFileFormat = TWFF_PICT;
    } else if (guidFormat == WiaImgFmt_PNG) {
        ImageFileFormat = TWFF_PNG;
    } else if (guidFormat == WiaImgFmt_EXIF) {
        ImageFileFormat = TWFF_EXIF;
    } else if (guidFormat == WiaImgFmt_FLASHPIX) {
        ImageFileFormat = TWFF_FPX;
    } else if (guidFormat == WiaImgFmt_UNDEFINED) {
        DBG_TRC(("WIA File Format WiaImgFmt_UNDEFINED does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_EMF) {
        DBG_TRC(("WIA File Format WiaImgFmt_EMF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_WMF) {
        DBG_TRC(("WIA File Format WiaImgFmt_WMF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_GIF) {
        DBG_TRC(("WIA File Format WiaImgFmt_GIF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_PHOTOCD) {
        DBG_TRC(("WIA File Format WiaImgFmt_PHOTOCD does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_ICO) {
        DBG_TRC(("WIA File Format WiaImgFmt_ICO does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_CIFF) {
        DBG_TRC(("WIA File Format WiaImgFmt_CIFF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_JPEG2K) {
        DBG_TRC(("WIA File Format WiaImgFmt_JPEG2K does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_JPEG2KX) {
        DBG_TRC(("WIA File Format WiaImgFmt_JPEG2KX does not MAP to TWAIN a file format"));
    } else {
        DBG_TRC(("WIA File Format (Unknown) does not MAP to TWAIN a file format"));
    }

    return ImageFileFormat;
}

LONG ICAP_COMPRESSION_TO_WIA_IPA_COMPRESSION(TW_UINT16 Compression)
{
    LONG lCompression = WIA_COMPRESSION_NONE;

    switch(Compression){
    case TWCP_NONE:
        lCompression = WIA_COMPRESSION_NONE;
        break;
    case TWCP_RLE4:
        lCompression = WIA_COMPRESSION_BI_RLE4;
        break;
    case TWCP_RLE8:
        lCompression = WIA_COMPRESSION_BI_RLE8;
        break;
    case TWCP_GROUP4:
        lCompression = WIA_COMPRESSION_G4;
        break;
    case TWCP_JPEG:
        lCompression = WIA_COMPRESSION_JPEG;
        break;
    case TWCP_GROUP31D:
    case TWCP_GROUP31DEOL:
    case TWCP_GROUP32D:
        lCompression = WIA_COMPRESSION_G3;
        break;
    case TWCP_LZW:
    case TWCP_JBIG:
    case TWCP_PNG:
    case TWCP_PACKBITS:
    case TWCP_BITFIELDS:
    default:
        break;
    }

    return lCompression;
}

LONG ICAP_PIXELTYPE_TO_WIA_IPA_DATATYPE(TW_UINT16 PixelType)
{
    LONG lDataType = WIA_DATA_COLOR;

    switch(PixelType){
    case TWPT_BW:
        lDataType = WIA_DATA_THRESHOLD;
        break;
    case TWPT_GRAY:
        lDataType = WIA_DATA_GRAYSCALE;
        break;
    case TWPT_RGB:
        lDataType = WIA_DATA_COLOR;
        break;
    case TWPT_PALETTE:
    case TWPT_CMY:
    case TWPT_CMYK:
    case TWPT_YUV:
    case TWPT_YUVK:
    case TWPT_CIEXYZ:
    default:
        break;
    }

    return lDataType;
}

GUID ICAP_IMAGEFILEFORMAT_TO_WIA_IPA_FORMAT(TW_UINT16 ImageFileFormat)
{
    GUID guidFormat = WiaImgFmt_BMP;

    switch(ImageFileFormat){
    case TWFF_TIFFMULTI:
    case TWFF_TIFF:
        guidFormat = WiaImgFmt_TIFF;
        break;
    case TWFF_PICT:
        guidFormat = WiaImgFmt_PICT;
        break;
    case TWFF_BMP:
        guidFormat = WiaImgFmt_BMP;
        break;
    case TWFF_JFIF:
        guidFormat = WiaImgFmt_JPEG;
        break;
    case TWFF_FPX:
        guidFormat = WiaImgFmt_FLASHPIX;
        break;
    case TWFF_PNG:
        guidFormat = WiaImgFmt_PNG;
        break;
    case TWFF_EXIF:
        guidFormat = WiaImgFmt_EXIF;
        break;
    case TWFF_SPIFF:
    case TWFF_XBM:
    default:
        break;

    }

    return guidFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\wiadev.h ===
#ifndef __WIADEV_H_
#define __WIADEV_H_

typedef HRESULT (CALLBACK *PFNDEVICEEVENTCALLBACK)(LONG lEvent, LPARAM lParam);
typedef HRESULT (CALLBACK *PFNLOADIMAGECALLBACK)(LONG lMessage,
                                                 LONG lStatus,
                                                 LONG lPercentComplete,
                                                 LONG lOffset,
                                                 LONG Length,
                                                 BYTE *pData
                                                );
//
// structure definitions
//

typedef struct tagCAPVALUES {
    LONG    xResolution;    // x-resolution
    LONG    yResolution;    // y-resolution
    LONG    xPos;           // x position (selection window)
    LONG    yPos;           // y position (selection window)
    LONG    xExtent;        // x extent   (selection window)
    LONG    yExtent;        // y extent   (selection window)
    LONG    DataType;       // Data Type, (BW,GRAY,RGB)
}CAPVALUES, *PCAPVALUES;

typedef struct tagBasicInfo
{
    TW_UINT32   Size;           // structure size
    TW_UINT32   xOpticalRes;    // x optical resolution in DPI
    TW_UINT32   yOpticalRes;    // y optical resolution in DPI
    TW_UINT32   xBedSize;       // Scan bed size in 1000th Inches
    TW_UINT32   yBedSize;       // Scan bed size in 1000th Inches
    TW_UINT32   FeederCaps;     // document handling capability
}BASIC_INFO, *PBASIC_INFO;

//
// WIA event callback class definition
//

class CWiaEventCallback : public IWiaEventCallback {
public:
    CWiaEventCallback()
    {
        m_Ref = 0;
        m_pfnCallback = NULL;
        m_CallbackParam = (LPARAM)0;
    }
    ~CWiaEventCallback()
    {
    }
    HRESULT Initialize(PFNDEVICEEVENTCALLBACK pCallback, LPARAM lParam)
    {
        if (!pCallback)
            return E_INVALIDARG;
        m_pfnCallback = pCallback;
        m_CallbackParam = lParam;
        return S_OK;
    }

    //
    // IUnknown interface
    //

    STDMETHODIMP_(ULONG) AddRef()
    {
        InterlockedIncrement((LONG*)&m_Ref);
        return m_Ref;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (!InterlockedDecrement((LONG*)&m_Ref)) {
            m_Ref++;
            delete this;
            return(ULONG) 0;
        }
        return m_Ref;
    }

    STDMETHODIMP QueryInterface(REFIID iid, void **ppv)
    {
        if (!ppv)
            return E_INVALIDARG;
        *ppv = NULL;
        if (IID_IUnknown == iid) {
            *ppv = (IUnknown*)this;
            AddRef();
        } else if (IID_IWiaEventCallback == iid) {
            *ppv = (IWiaEventCallback*)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    //
    // IWiaEventCallback interface
    //
    STDMETHODIMP ImageEventCallback(const GUID *pEventGuid,
                                    BSTR  bstrEventDescription,
                                    BSTR  bstrDeviceId,
                                    BSTR  bstrDeviceDescription,
                                    DWORD dwDeviceType,
                                    BSTR  bstrFullItemName,
                                    ULONG *pulEventType,
                                    ULONG ulReserved);

private:
    ULONG   m_Ref;
    TCHAR   m_szDeviceID[MAX_PATH];
    PFNDEVICEEVENTCALLBACK m_pfnCallback;
    LPARAM  m_CallbackParam;
};

//
// WIA device class definition
//

class CWiaDevice {
public:
    CWiaDevice()
    {
        m_pRootItem      = NULL;
        m_ImageItemArray = NULL;
        m_NumImageItems  = 0;

        memset(m_szDeviceName,0,sizeof(m_szDeviceName));
        memset(m_szDeviceDesc,0,sizeof(m_szDeviceDesc));
        memset(m_szDeviceVendorDesc,0,sizeof(m_szDeviceVendorDesc));
        memset(m_szDeviceID,0,sizeof(m_szDeviceID));
    }
    virtual ~CWiaDevice()
    {

    }
    LPCTSTR GetDeviceId() const
    {
        return m_szDeviceID;
    }

    virtual HRESULT Initialize(LPCTSTR DeviceId);
    virtual HRESULT Open(PFNDEVICEEVENTCALLBACK pEventCallback,LPARAM lParam);
    virtual HRESULT Close();
    virtual HRESULT AcquireImages(HWND hwndOwner, BOOL ShowUI);
    virtual HRESULT LoadImage(IWiaItem *pIWiaItem, GUID guidFormatID,IWiaDataCallback *pIDataCB);
    virtual HRESULT LoadThumbnail(IWiaItem *pIWiaItem, HGLOBAL *phThumbnail,ULONG *pThumbnailSize);
    virtual HRESULT LoadImageToDisk(IWiaItem *pIWiaItem,CHAR *pFileName, GUID guidFormatID,IWiaDataCallback *pIDataCB);

    HRESULT GetImageInfo(IWiaItem *pIWiaItem, PMEMORY_TRANSFER_INFO pImageInfo);
    HRESULT GetThumbnailImageInfo(IWiaItem *pIWiaItem, PMEMORY_TRANSFER_INFO pImageInfo);
    HRESULT GetImageRect(IWiaItem *pIWiaItem, LPRECT pRect);
    HRESULT GetThumbnailRect(IWiaItem *pIWiaItem, LPRECT pRect);
    HRESULT GetDeviceName(LPTSTR Name, UINT NameSize, UINT *pActualSize);
    HRESULT GetDeviceDesc(LPTSTR Desc, UINT DescSize, UINT *pActualSize);
    HRESULT GetDeviceVendorName(LPTSTR Name, UINT NameSize, UINT *pActualSize);
    HRESULT GetDeviceFamilyName(LPTSTR Name, UINT NameSize, UINT *pActualSize);
    HRESULT FreeAcquiredImages();
    HRESULT EnumAcquiredImage(DWORD Index, IWiaItem **ppIWiaItem);
    HRESULT GetNumAcquiredImages(LONG *plNumImages);
    HRESULT GetAcquiredImageList(LONG lBufferSize, IWiaItem  **ppIWiaItem, LONG *plActualSize);
    HRESULT GetBasicScannerInfo(PBASIC_INFO pBasicInfo);
    BOOL TwainCapabilityPassThrough();

protected:
    HRESULT CollectImageItems(IWiaItem *pStartItem, IWiaItem **ImageItemList,
                              DWORD ImageItemListSize, DWORD *pCount);

    TCHAR             m_szDeviceID[MAX_PATH];
    IWiaItem         *m_pRootItem;
    IWiaItem        **m_ImageItemArray;
    LONG              m_NumImageItems;
    CWiaEventCallback m_EventCallback;
    TCHAR             m_szDeviceName[MAX_PATH];
    TCHAR             m_szDeviceDesc[MAX_PATH];
    TCHAR             m_szDeviceVendorDesc[MAX_PATH];
};

#endif  // #ifndef __WIADEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\videods.cpp ===
#include "precomp.h"

//
// values that the WIA/TWAIN data source provides for capability negotation
//

TW_UINT16 g_VideoUnits[]            = {TWUN_PIXELS};
TW_UINT16 g_VideoBitOrder[]         = {TWBO_MSBFIRST};
TW_UINT16 g_VideoXferMech[]         = {TWSX_NATIVE, TWSX_FILE, TWSX_MEMORY};
TW_UINT16 g_VideoPixelFlavor[]      = {TWPF_CHOCOLATE};
TW_UINT16 g_VideoPlanarChunky[]     = {TWPC_CHUNKY};

const TW_UINT32 NUM_VIDEOCAPDATA = 23;
CAPDATA VIDEO_CAPDATA[NUM_VIDEOCAPDATA] =
{
    //
    // Every source must support all five DG_CONTROL / DAT_CAPABILITY operations on:
    //

    {CAP_XFERCOUNT, TWTY_INT16, TWON_ONEVALUE,
        sizeof(TW_INT16), 0, 0, 0, 32767, 1, NULL, NULL
    },

    //
    // Every source must support DG_CONTROL / DAT_CAPABILITY, MSG_GET on:
    //

    {CAP_SUPPORTEDCAPS, TWTY_UINT16, TWON_ARRAY,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_UICONTROLLABLE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, and MSG_GETDEFAULT on:
    //

    {ICAP_COMPRESSION, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PLANARCHUNKY, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoPlanarChunky, NULL
    },
    {ICAP_PHYSICALHEIGHT, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1024, 1024, 1024, 1024, 0, NULL, NULL
    },
    {ICAP_PHYSICALWIDTH, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1536, 1536, 1536, 1536, 0, NULL, NULL
    },
    {ICAP_PIXELFLAVOR, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoPixelFlavor, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, MSG_GETDEFAULT, MSG_RESET, and MSG_SET on:
    //

    {ICAP_BITDEPTH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BITORDER, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoBitOrder, NULL
    },
    {ICAP_PIXELTYPE, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_UNITS, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoUnits, NULL
    },
    {ICAP_XFERMECH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 2, 0, g_VideoXferMech, NULL
    },
    {ICAP_XRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },
    {ICAP_YRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },

    //
    // The following capabilities are camera specific capabilities
    //

    {CAP_THUMBNAILSENABLED, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },

    {CAP_CAMERAPREVIEWUI, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    {ICAP_IMAGEDATASET, TWTY_UINT32, TWON_RANGE,
        sizeof(TW_UINT32),  1, 1, 1, 50, 1, NULL, NULL
    },

    //
    // The following capabilities are provided for application compatiblity only.
    //

    {ICAP_IMAGEFILEFORMAT, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_INDICATORS, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_ENABLEDSUIONLY, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
    {CAP_DEVICEONLINE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_SUPPORTEDCAPSEXT, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
};

TW_UINT16 CWiaVideoDS::OpenDS(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_UINT16 twCc = TWCC_SUCCESS;

    m_bArrayModeAcquisition = FALSE;
    m_pulImageIndexes   = NULL;
    m_lNumValidIndexes  = 0;
    m_lCurrentArrayIndex = 0;
    m_bRangeModeAcquisition = FALSE;
    memset(&m_twImageRange,0,sizeof(TW_RANGE));

    //
    // create capability list
    //
    twCc = CreateCapList(NUM_VIDEOCAPDATA, VIDEO_CAPDATA);
    if (TWCC_SUCCESS != twCc) {
        m_twStatus.ConditionCode = twCc;
        return TWRC_FAILURE;
    }

    twRc =  CWiaDataSrc::OpenDS(ptwMsg);
    if (TWRC_SUCCESS == twRc) {

        HRESULT hr = m_pDevice->AcquireImages(NULL, FALSE);
        if (SUCCEEDED(hr)) {

            //
            // get number of pictures taken, for IMAGEDATASET query
            //

            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            CCap *pCap = NULL;
            pCap = FindCap(ICAP_IMAGEDATASET);
            if (pCap) {
                pCap->Set((TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,1);
            }

            hr = m_pDevice->EnumAcquiredImage(0, &m_pCurrentIWiaItem);
            if (SUCCEEDED(hr)) {
                twRc = GetCommonSettings();
            } else {

                //
                // Video capture devices, can be in a state that there are no still images
                // to transfer
                //

                twRc = GetCommonDefaultSettings();
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaVideoDS::CloseDS(PTWAIN_MSG ptwMsg)
{
    DestroyCapList();
    return CWiaDataSrc::CloseDS(ptwMsg);
}

TW_UINT16 CWiaVideoDS::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    if (ptwCap->Cap == ICAP_IMAGEDATASET) {

        switch(ptwCap->ConType){
        case TWON_ONEVALUE:
            DBG_TRC(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET to a TWON_ONEVALUE"));

            //
            // implied contiguous image transfer, from 1 to the specified TW_ONEVALUE
            //

            twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);

            break;
        case TWON_RANGE:
            DBG_TRC(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_RANGE"));

            //
            // contiguous image transfer, from MinValue to MaxValue TW_RANGE (using StepSize? or increment by 1?)
            //

            twRc = SetRangeOfImageIndexes(ptwCap);

            break;
        case TWON_ARRAY:
            DBG_TRC(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_ARRAY"));

            //
            // image transfer with specified indexes supplied by the TWAIN application (user)
            //

            twRc = SetArrayOfImageIndexes(ptwCap);

            break;
        default:
            DBG_WRN(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET unknown container type (%d)",ptwCap->ConType));
            break;
        }

    } else {
        twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);
        if(TWRC_SUCCESS == twRc){
            if(m_pCurrentIWiaItem){
                twRc = CWiaDataSrc::SetCommonSettings(pCap);
            }
        }
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_ARRAY:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_ARRAY *pArray = (TW_ARRAY*)GlobalLock(ptwCap->hContainer);
        if (pArray) {
            TW_UINT32 *pUINT32Array = NULL;
            pUINT32Array = (TW_UINT32*)pArray->ItemList;
            if(pUINT32Array){
                if (m_pulImageIndexes) {
                    delete [] m_pulImageIndexes;
                    m_pulImageIndexes = NULL;
                }
                m_lNumValidIndexes = pArray->NumItems;
                m_pulImageIndexes  = new LONG[m_lNumValidIndexes];
                if (m_pulImageIndexes) {
                    DBG_TRC(("CWiaVideoDS::SetArrayOfImageIndexes(), number of selected images to transfer = %d",m_lNumValidIndexes));
                    for (int i = 0; i < m_lNumValidIndexes; i++) {

                        //
                        // subtract 1 from the supplied index in the application index array, because TWAIN's image index
                        // array starts at 1 and goes to n. WIA (image) item array is zero-based. This will sync
                        // up the indexes here, to avoid any strange calculations later on.
                        //

                        m_pulImageIndexes[i] = (pUINT32Array[i] - 1);
                        DBG_TRC(("CWiaVideoDS::SetArrayOfImageIndexes(), image index copied into index array = %d",m_pulImageIndexes[i]));
                    }
                } else {
                    DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), could not allocate image index array"));
                    twRc = TWRC_FAILURE;
                }
            } else {
                DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), could not assign TW_ARRAY pointer to TW_UINT32 pointer"));
                twRc = TWRC_FAILURE;
            }

            GlobalUnlock(ptwCap->hContainer);
        } else {
            DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), could not LOCK the array container for write access"));
            twRc = TWRC_FAILURE;
        }
    }

    if(TWRC_SUCCESS == twRc){
        m_bArrayModeAcquisition = TRUE;
        m_bRangeModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_RANGE:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaVideoDS::SetRangeOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_RANGE *pRange = (TW_RANGE*)GlobalLock(ptwCap->hContainer);
        if (pRange) {
            m_bRangeModeAcquisition = TRUE;
            memcpy(&m_twImageRange,pRange,sizeof(TW_RANGE));

            //
            // adjust values to be zero-based to match our stored item list
            //

            m_twImageRange.CurrentValue -=1;
            m_twImageRange.DefaultValue -=1;
            m_twImageRange.MaxValue-=1;
            m_twImageRange.MinValue-=1;

            DBG_TRC(("CWiaVideoDS::SetRangeOfImageIndexes(), Set to the following Range Values"));
            DBG_TRC(("m_twImageRange.ItemType     = %d",m_twImageRange.ItemType));
            DBG_TRC(("m_twImageRange.CurrentValue = %d",m_twImageRange.CurrentValue));
            DBG_TRC(("m_twImageRange.DefaultValue = %d",m_twImageRange.DefaultValue));
            DBG_TRC(("m_twImageRange.MaxValue     = %d",m_twImageRange.MaxValue));
            DBG_TRC(("m_twImageRange.MinValue     = %d",m_twImageRange.MinValue));
            DBG_TRC(("m_twImageRange.StepSize     = %d",m_twImageRange.StepSize));
        } else {
            DBG_ERR(("CWiaVideoDS::SetRangeOfImageIndexes(), could not assign TW_RANGE pointer to TW_RANGE pointer"));
            twRc = TWRC_FAILURE;
        }
        GlobalUnlock(ptwCap->hContainer);
    } else {
        DBG_ERR(("CWiaVideoDS::SetRangeOfImageIndexes(), could not LOCK the range container for read access"));
        twRc = TWRC_FAILURE;
    }

    if(TWRC_SUCCESS == twRc){
        m_bRangeModeAcquisition = TRUE;
        m_bArrayModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::EnableDS(TW_USERINTERFACE *pUI)
{

    TW_UINT16 twRc = TWRC_FAILURE;
    if (DS_STATE_4 == GetTWAINState()) {
        HRESULT hr = S_OK;
        if (pUI->ShowUI) {
            //
            // since we were told to show UI, ignore the UI-LESS settings, and
            // get a new image item list from the WIA UI.
            //
            DBG_TRC(("CWiaVideoDS::EnableDS(), TWAIN UI MODE"));
            m_pDevice->FreeAcquiredImages();
        } else {
            DBG_TRC(("CWiaVideoDS::EnableDS(), TWAIN UI-LESS MODE"));
            DBG_TRC(("CWiaVideoDS::EnableDS(), TWAIN UI MODE (FORCING UI MODE TO ON)"));
            pUI->ShowUI = TRUE; // force UI mode
            m_pDevice->FreeAcquiredImages();
        }
        hr = m_pDevice->AcquireImages(HWND (pUI->ShowUI ? pUI->hParent : NULL),
                                      pUI->ShowUI);
        if (S_OK == hr) {
            twRc = TWRC_SUCCESS;
            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            if (lNumImages) {
                m_NumIWiaItems = (TW_UINT32)lNumImages;
                m_pIWiaItems = new (IWiaItem *[m_NumIWiaItems]);
                if (m_pIWiaItems) {
                    hr = m_pDevice->GetAcquiredImageList(lNumImages, m_pIWiaItems, NULL);
                    if (FAILED(hr)) {
                        delete [] m_pIWiaItems;
                        m_pIWiaItems = NULL;
                        m_NumIWiaItems = 0;
                        m_NextIWiaItemIndex = 0;
                        m_twStatus.ConditionCode = TWCC_BUMMER;
                        twRc = TWRC_FAILURE;
                    }
                } else {
                    m_NumIWiaItems = 0;
                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    twRc = TWRC_FAILURE;
                }
            }
        } else if(S_FALSE == hr) {
            return TWRC_CANCEL;
        } else {
            m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS == twRc) {

            //
            // set current item pointer
            //

            if(m_bRangeModeAcquisition){
                DBG_TRC(("CWiaVideoDS::EnableDS(), RANGE MODE"));
                m_pCurrentIWiaItem = m_pIWiaItems[m_twImageRange.MinValue];
                m_NextIWiaItemIndex = m_twImageRange.MinValue + 1; // use Step value???
            } else if(m_bArrayModeAcquisition){
                DBG_TRC(("CWiaVideoDS::EnableDS(), ARRAY MODE"));
                m_lCurrentArrayIndex = 0;
                m_pCurrentIWiaItem = m_pIWiaItems[m_pulImageIndexes[m_lCurrentArrayIndex]];
                if(m_lNumValidIndexes > 1){
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex + 1]; // the next index value
                } else {
                    m_NextIWiaItemIndex = m_lCurrentArrayIndex;
                }
            } else {
                m_pCurrentIWiaItem = m_pIWiaItems[0];
                m_NextIWiaItemIndex = 1;
            }


            //
            // set total image count
            //

            CCap *pcapXferCount = NULL;
            TW_UINT32 NumImages = 0;
            pcapXferCount = FindCap(CAP_XFERCOUNT);
            if (pcapXferCount) {
                if(m_bRangeModeAcquisition){
                    // only images in the specified range (zero-based)
                    twRc = pcapXferCount->SetCurrent((m_twImageRange.MaxValue - m_twImageRange.MinValue) + 1);
                } else if(m_bArrayModeAcquisition){
                    // only selected images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_lNumValidIndexes);
                } else {
                    // all images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_NumIWiaItems);
                }

                NumImages = pcapXferCount->GetCurrent();
            } else {
                DBG_ERR(("CWiaVideoDS::EnableDS(), could not find CAP_XFERCOUNT in supported CAP list"));
                twRc = TWRC_FAILURE;
            }

            if (TWRC_SUCCESS == twRc) {

                //
                // set thumbnail count
                //

                CCap *pDataSet = NULL;
                pDataSet = FindCap(ICAP_IMAGEDATASET);
                if(pDataSet){
                    pDataSet->Set((TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,1);
                }

                if (m_NumIWiaItems) {

                    //
                    // transition to STATE_5, XferReady will transition to STATE_6
                    //

                    SetTWAINState(DS_STATE_5);
                    NotifyXferReady();
                } else {
                    NotifyCloseReq();

                    //
                    // transition to STATE_5
                    //

                    SetTWAINState(DS_STATE_5);
                }
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaVideoDS::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{

    TW_UINT16 twRc = TWRC_SUCCESS;

    CCap *pXferCount;
    pXferCount = FindCap(CAP_XFERCOUNT);
    if (!pXferCount) {
        m_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }

    twRc = TWRC_SUCCESS;
    switch (ptwMsg->MSG) {
    case MSG_GET:
        switch (GetTWAINState()) {
        case DS_STATE_4:
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
            DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_GET returning %d",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
            break;
        default:
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
            break;
        }
        break;
    case MSG_ENDXFER:
        if (DS_STATE_6 == GetTWAINState() || DS_STATE_7 == GetTWAINState()) {
            ResetMemXfer();
            TW_INT32 Count = 0;
            Count = pXferCount->GetCurrent();
            Count--;

            if (Count <= 0) {
                Count = 0;

                DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, 0 (no more images left to transfer)"));

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)0;

                //
                // update count now, so NotifyCoseReq can be prepared for reentry by a TWAIN application
                //

                pXferCount->SetCurrent((TW_UINT32)0);

                //
                // Transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);
                NotifyCloseReq();
            } else {

                DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, %d (more images may be ready to transfer)",Count));

                //
                // Advance to next image
                //

                if (m_bRangeModeAcquisition) {
                    m_NextIWiaItemIndex+=1; // use Step value???
                    if(m_NextIWiaItemIndex <= (LONG)m_twImageRange.MaxValue){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed RANGE index"));
                    }
                } else if (m_bArrayModeAcquisition) {
                    m_lCurrentArrayIndex++; // advance to next image index
                    DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, next image index  to acquire = %d",m_pulImageIndexes[m_lCurrentArrayIndex]));
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex];
                    if(m_NextIWiaItemIndex <= m_lNumValidIndexes){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed ARRAY index"));
                    }

                } else {
                    m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex++];
                }

                //
                // Transition to STATE_6
                //

                SetTWAINState(DS_STATE_6);

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)Count;
            }

            //
            // update count
            //

            pXferCount->SetCurrent((TW_UINT32)Count);
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    case MSG_RESET:
        if (DS_STATE_6 == GetTWAINState()) {

            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = 0;
            pXferCount->SetCurrent((TW_UINT32)0);

            ResetMemXfer();

            //
            // Transition to STATE_5
            //

            SetTWAINState(DS_STATE_5);

        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaVideoDS::OnImageInfoMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        if (pCap->GetCurrent()) {
            bThumbailMode = TRUE;
        }
    } else {
        DBG_ERR(("CWiaVideoDS::OnImageInfoMsg(), could not get CAP_THUMBNAILSENABLED capabilty settings"));
    }

    if (bThumbailMode) {
        DBG_TRC(("CWiaVideoDS::OnImageInfoMsg(), Reporting Thumbnail image information"));

        TW_IMAGEINFO *ptwImageInfo = NULL;
        if (DS_STATE_6 == GetTWAINState()) {
            if (MSG_GET == ptwMsg->MSG) {
                ptwImageInfo = (TW_IMAGEINFO *)ptwMsg->pData;
                HRESULT hr = S_OK;
                hr = m_pDevice->GetThumbnailImageInfo(m_pCurrentIWiaItem, &m_MemoryTransferInfo);
                if (SUCCEEDED(hr)) {

                    ptwImageInfo->ImageWidth      = (TW_INT32)m_MemoryTransferInfo.mtiWidthPixels;
                    ptwImageInfo->ImageLength     = (TW_INT32)m_MemoryTransferInfo.mtiHeightPixels;
                    ptwImageInfo->BitsPerPixel    = (TW_INT16)m_MemoryTransferInfo.mtiBitsPerPixel;
                    ptwImageInfo->SamplesPerPixel = (TW_INT16)m_MemoryTransferInfo.mtiNumChannels;
                    ptwImageInfo->Planar          = (TW_BOOL)m_MemoryTransferInfo.mtiPlanar;

                    //
                    // set PixelType to corresponding TWAIN pixel type
                    //

                    switch (m_MemoryTransferInfo.mtiDataType) {
                    case WIA_DATA_THRESHOLD:
                        ptwImageInfo->PixelType = TWPT_BW;
                        break;
                    case WIA_DATA_GRAYSCALE:
                        ptwImageInfo->PixelType = TWPT_GRAY;
                        break;
                    case WIA_DATA_COLOR:
                    default:
                        ptwImageInfo->PixelType = TWPT_RGB;
                        break;
                    }

                    //
                    // set compression to NONE
                    //

                    ptwImageInfo->Compression = TWCP_NONE;

                    //
                    // Unit conversion.......
                    //

                    ptwImageInfo->XResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiXResolution);
                    ptwImageInfo->YResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiYResolution);

                    twRc = TWRC_SUCCESS;

                } else {
                    m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
                    twRc = TWRC_FAILURE;
                }

                if (TWRC_SUCCESS == twRc) {
                    DBG_TRC(("CWiaVideoDS::OnImageInfoMsg(), Reported Image Information from data source"));
                    DBG_TRC(("XResolution     = %d.%d",ptwImageInfo->XResolution.Whole,ptwImageInfo->XResolution.Frac));
                    DBG_TRC(("YResolution     = %d.%d",ptwImageInfo->YResolution.Whole,ptwImageInfo->YResolution.Frac));
                    DBG_TRC(("ImageWidth      = %d",ptwImageInfo->ImageWidth));
                    DBG_TRC(("ImageLength     = %d",ptwImageInfo->ImageLength));
                    DBG_TRC(("SamplesPerPixel = %d",ptwImageInfo->SamplesPerPixel));

                    memset(ptwImageInfo->BitsPerSample,0,sizeof(ptwImageInfo->BitsPerSample));

                    if (ptwImageInfo->BitsPerPixel < 24) {
                        ptwImageInfo->BitsPerSample[0] = ptwImageInfo->BitsPerPixel;
                    } else {
                        for (int i = 0; i < ptwImageInfo->SamplesPerPixel; i++) {
                            ptwImageInfo->BitsPerSample[i] = (ptwImageInfo->BitsPerPixel/ptwImageInfo->SamplesPerPixel);
                        }
                    }
                    // (bpp / spp) = bps
                    DBG_TRC(("BitsPerSample   = [%d],[%d],[%d],[%d],[%d],[%d],[%d],[%d]",ptwImageInfo->BitsPerSample[0],
                             ptwImageInfo->BitsPerSample[1],
                             ptwImageInfo->BitsPerSample[2],
                             ptwImageInfo->BitsPerSample[3],
                             ptwImageInfo->BitsPerSample[4],
                             ptwImageInfo->BitsPerSample[5],
                             ptwImageInfo->BitsPerSample[6],
                             ptwImageInfo->BitsPerSample[7]));
                    DBG_TRC(("BitsPerPixel    = %d",ptwImageInfo->BitsPerPixel));
                    DBG_TRC(("Planar          = %d",ptwImageInfo->Planar));
                    DBG_TRC(("PixelType       = %d",ptwImageInfo->PixelType));
                    DBG_TRC(("Compression     = %d",ptwImageInfo->Compression));
                }
            } else {
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
                twRc = TWRC_FAILURE;
            }
        } else {
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS != twRc) {
            DSError();
        }
    } else {
        twRc = CWiaDataSrc::OnImageInfoMsg(ptwMsg);
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::TransferToDIB(HGLOBAL *phDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        bThumbailMode = pCap->GetCurrent();
    }

    if(bThumbailMode){
        twRc = CWiaDataSrc::TransferToThumbnail(phDIB);
    } else {
        twRc = CWiaDataSrc::TransferToDIB(phDIB);
    }

    return twRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\wiadev.cpp ===
#include "precomp.h"

const ULONG DEFAULT_BUFFER_SIZE = 65535;
IMessageFilter * g_pOldOleMessageFilter = NULL;

HRESULT CWiaDevice::Initialize(LPCTSTR DeviceId)
{
    DBG_FN_WIADEV(CWiaDevice::Initialize());
    HRESULT hr = S_OK;
    HRESULT Temphr = S_OK;

    if (!DeviceId) {
        return E_INVALIDARG;
    }

    //
    // copy the deviceID string into the member variable for later use.
    //

    if(!lstrcpyn(m_szDeviceID,DeviceId, ((sizeof(m_szDeviceID)/sizeof(m_szDeviceID[0])) - 1))) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // we have a device ID, so now find it in the device enumeration, and
    // fill the needed values for TW_IDENTITY
    //

    if (SUCCEEDED(hr)) {

        IWiaDevMgr *pIWiaDevMgr = NULL;

        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL,CLSCTX_LOCAL_SERVER,IID_IWiaDevMgr,(void **)&pIWiaDevMgr);
        if (SUCCEEDED(hr)) {

            //
            // create a WIA DEV info enumerator
            //

            IEnumWIA_DEV_INFO   *pWiaEnumDevInfo = NULL;
            hr = pIWiaDevMgr->EnumDeviceInfo(0,&pWiaEnumDevInfo);
            if (SUCCEEDED(hr)) {

                do {

                    IWiaPropertyStorage  *pIWiaPropStg = NULL;
                    hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg, NULL);
                    if (hr == S_OK) {

                        PROPSPEC        PropSpec[4];
                        PROPVARIANT     PropVar[4];

                        memset(PropVar,0,sizeof(PropVar));

                        // Device ID (used for searching)
                        PropSpec[0].ulKind = PRSPEC_PROPID;
                        PropSpec[0].propid = WIA_DIP_DEV_ID;

                        // Device Name
                        PropSpec[1].ulKind = PRSPEC_PROPID;
                        PropSpec[1].propid = WIA_DIP_DEV_NAME;

                        // Device Description
                        PropSpec[2].ulKind = PRSPEC_PROPID;
                        PropSpec[2].propid = WIA_DIP_DEV_DESC;

                        // Device Vendor Description
                        PropSpec[3].ulKind = PRSPEC_PROPID;
                        PropSpec[3].propid = WIA_DIP_VEND_DESC;

                        hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                                        PropSpec,
                                                        PropVar);

                        if (hr == S_OK) {

                            DBG_TRC(("CWiaDevice::Initialize(), Reported Device Information from WIA device"));
                            DBG_TRC(("Device ID          = %ws",PropVar[0].bstrVal));
                            DBG_TRC(("Device Name        = %ws",PropVar[1].bstrVal));
                            DBG_TRC(("Device Desc        = %ws",PropVar[2].bstrVal));
                            DBG_TRC(("Device Vendor Desc = %ws",PropVar[3].bstrVal));

#ifdef UNICODE
                            //
                            // compare Device IDs to find the correct device
                            //

                            DBG_TRC(("comparing Device ID [in] = %ws, to Device ID [read] = %ws",m_szDeviceID,PropVar[0].bstrVal));

                            if (lstrcmpi(m_szDeviceID,PropVar[0].bstrVal) == 0) {

                                //
                                // copy the device name
                                //

                                if(!lstrcpyn(m_szDeviceName,PropVar[1].bstrVal,((sizeof(m_szDeviceName)/sizeof(m_szDeviceName[0])) - 1))) {
                                    hr  = HRESULT_FROM_WIN32(GetLastError());
                                } else {

                                    //
                                    // copy the device description
                                    //

                                    if(!lstrcpyn(m_szDeviceDesc,PropVar[2].bstrVal,((sizeof(m_szDeviceDesc)/sizeof(m_szDeviceDesc[0])) - 1))){
                                        hr  = HRESULT_FROM_WIN32(GetLastError());
                                    } else {

                                        //
                                        // copy the device vendor description
                                        //

                                        if(!lstrcpyn(m_szDeviceVendorDesc,PropVar[3].bstrVal,((sizeof(m_szDeviceVendorDesc)/sizeof(m_szDeviceVendorDesc[0])) - 1))) {
                                            hr  = HRESULT_FROM_WIN32(GetLastError());
                                        }
                                    }
                                }
                            }
#else

                            TCHAR szTempString[MAX_PATH];
                            memset(szTempString,0,sizeof(szTempString));

                            LONG lLength = 0;
                            lLength = WideCharToMultiByte(CP_ACP,0,PropVar[0].bstrVal,
                                                          lstrlenW(PropVar[0].bstrVal),
                                                          szTempString,
                                                          (sizeof(szTempString)/sizeof(CHAR)),
                                                          NULL,NULL);

                            if (!lLength) {
                                hr  = HRESULT_FROM_WIN32(GetLastError());
                            } else {

                                //
                                // compare Device IDs to find the correct device
                                //

                                DBG_TRC(("comparing Device ID [in] = %s, to Device ID [read] = %s",m_szDeviceID,szTempString));

                                if (lstrcmpi(m_szDeviceID,szTempString) == 0) {

                                    // convert and copy Device Name
                                    memset(szTempString,0,sizeof(szTempString));
                                    lLength = WideCharToMultiByte(CP_ACP,0,PropVar[1].bstrVal,
                                                                  lstrlenW(PropVar[1].bstrVal),
                                                                  szTempString,
                                                                  (sizeof(szTempString)/sizeof(CHAR)),
                                                                  NULL,NULL);

                                    if (!lLength) {
                                        hr  = HRESULT_FROM_WIN32(GetLastError());
                                    } else {

                                        if (!lstrcpyn(m_szDeviceName,szTempString,((sizeof(m_szDeviceName)/sizeof(m_szDeviceName[0])) - 1))) {
                                            hr  = HRESULT_FROM_WIN32(GetLastError());
                                        } else {

                                            // convert and copy Device Description
                                            memset(szTempString,0,sizeof(szTempString));
                                            lLength = WideCharToMultiByte(CP_ACP,0,PropVar[2].bstrVal,
                                                                          lstrlenW(PropVar[2].bstrVal),
                                                                          szTempString,
                                                                          (sizeof(szTempString)/sizeof(CHAR)),
                                                                          NULL,NULL);

                                            if (!lLength) {
                                                hr  = HRESULT_FROM_WIN32(GetLastError());
                                            } else {

                                                if(!lstrcpyn(m_szDeviceDesc,szTempString,((sizeof(m_szDeviceDesc)/sizeof(m_szDeviceDesc[0])) - 1))){
                                                    hr  = HRESULT_FROM_WIN32(GetLastError());
                                                } else {

                                                    // convert and copy Device Vendor Description
                                                    memset(szTempString,0,sizeof(szTempString));
                                                    lLength = WideCharToMultiByte(CP_ACP,0,
                                                                                  PropVar[3].bstrVal,
                                                                                  lstrlenW(PropVar[3].bstrVal),
                                                                                  szTempString,
                                                                                  (sizeof(szTempString)/sizeof(CHAR)),
                                                                                  NULL,NULL);
                                                    if (!lLength) {
                                                        hr  = HRESULT_FROM_WIN32(GetLastError());
                                                    } else {

                                                        if (!lstrcpyn(m_szDeviceVendorDesc,szTempString,((sizeof(m_szDeviceVendorDesc)/sizeof(m_szDeviceVendorDesc[0])) - 1))) {
                                                            hr  = HRESULT_FROM_WIN32(GetLastError());
                                                        } else {

                                                            //
                                                            // Set hr to S_FALSE, to signal that we are finished with
                                                            // the device enumeration
                                                            //

                                                            hr = S_FALSE;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
#endif

                            //
                            // free property variant array
                            //

                            FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);

                            //
                            // release Property Storage
                            //

                            if(pIWiaPropStg) {
                                pIWiaPropStg->Release();
                                pIWiaPropStg = NULL;
                            }

                        }
                    }
                } while (hr == S_OK);

                //
                // release WIA device Enumerator
                //

                if(pWiaEnumDevInfo) {
                    pWiaEnumDevInfo->Release();
                }
            }

            //
            // release WIA device manager
            //

            if(pIWiaDevMgr) {
                pIWiaDevMgr->Release();
            }
        }
    }

    if(S_FALSE == hr){

        //
        // set this to OK, because enumeration termination could set hr to S_FALSE
        //

        hr = S_OK;
    }
    return hr;
}

HRESULT CWiaDevice::Open( PFNDEVICEEVENTCALLBACK pCallback, LPARAM lParam)
{
    DBG_FN_WIADEV(CWiaDevice::Open());
    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    BSTR bstrDeviceId = NULL;

    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL,CLSCTX_LOCAL_SERVER,IID_IWiaDevMgr,
                              (void **)&pIWiaDevMgr);
    if (S_OK == hr) {

#ifdef UNICODE
        bstrDeviceId = SysAllocString(m_szDeviceID);
#else
        WCHAR DeviceIdW[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szDeviceID, -1,DeviceIdW, (sizeof(DeviceIdW) / sizeof(DeviceIdW[0])));
        bstrDeviceId = SysAllocString(DeviceIdW);
#endif

        if (bstrDeviceId) {
            hr = pIWiaDevMgr->CreateDevice(bstrDeviceId,&m_pRootItem);
            SysFreeString(bstrDeviceId);
        } else {
            hr = E_OUTOFMEMORY;
        }

        pIWiaDevMgr->Release();
    }
    return hr;
}

HRESULT CWiaDevice::Close()
{
    DBG_FN_WIADEV(CWiaDevice::Close());
    HRESULT hr = S_OK;
    FreeAcquiredImages();

    if (m_pRootItem) {
        m_pRootItem->Release();
        m_pRootItem = NULL;
    }

    return hr;
}

HRESULT CWiaDevice::GetDeviceName(LPTSTR Name,UINT NameSize,UINT *pActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetDeviceName());
    HRESULT hr = S_OK;
    memset(Name,0,NameSize);
    lstrcpyn(Name,m_szDeviceName,NameSize-1);
    if(pActualSize){
        *pActualSize = 0;
        *pActualSize = lstrlen(Name);
    }
    return hr;
}

HRESULT CWiaDevice::GetDeviceDesc(LPTSTR Desc,UINT DescSize,UINT *pActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetDeviceDesc());
    HRESULT hr = S_OK;
    memset(Desc,0,DescSize);
    lstrcpyn(Desc,m_szDeviceDesc,DescSize-1);
    if(pActualSize){
        *pActualSize = 0;
        *pActualSize = lstrlen(Desc);
    }
    return hr;
}

HRESULT CWiaDevice::GetDeviceVendorName(LPTSTR Name,UINT NameSize,UINT *pActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetDeviceVendorName);
    HRESULT hr = S_OK;
    memset(Name,0,NameSize);
    lstrcpyn(Name,m_szDeviceVendorDesc,NameSize-1);
    if(pActualSize){
        *pActualSize = 0;
        *pActualSize = lstrlen(Name);
    }
    return hr;
}

HRESULT CWiaDevice::AcquireImages(HWND hwndOwner,BOOL ShowUI)
{
    DBG_FN_WIADEV(CWiaDevice::AcquireImages());
    HRESULT hr = S_OK;

    if (!m_NumImageItems) {

        //
        // If we have not done so, do it.
        //

        if (ShowUI) {
            DBG_TRC(("CWiaDevice::AcquireImages(), called for UI mode Initialization"));

            //
            // We will present the acquistion UI, use the default
            // dialog to do it. The dialog is modal.
            // It will return an array of (IWiaItem *) with each item
            // represent a image(camera) or scan head(scanner).
            // For a camera item, a call to LoadImage will load the image
            // it represents; for a scanner item, a call to LoadImage
            // will trigger scanning.
            //

            hr = m_pRootItem->DeviceDlg(hwndOwner,
                                     // WIA_DEVICE_DIALOG_USE_COMMON_UI,// flags - removed because it was forcing Common UI
                                        0,                              // flags
                                        WIA_INTENT_MINIMIZE_SIZE,       // intent
                                        &m_NumImageItems,               // item count
                                        &m_ImageItemArray);             // item array

            DBG_TRC(("CWiaDevice::AcquireImages(),Number of images from DeviceDlg to Transfer = %d",m_NumImageItems));
        } else {
            DBG_TRC(("CWiaDevice::AcquireImages(), called for UI-LESS mode Initialization"));
            DBG_TRC(("or...DS needs information for CAPABILITY initialization"));

            //
            // Non-UI mode, every item with
            // ItemType == (WiaItemTypeImage | WiaItemTypeFile) is a data acquire
            // item. Here we go through two passes:
            //  - The first pass determines how many items are available.
            //  - The second pass allocates buffer and retrieves all the items
            //    into that buffer
            //

            IEnumWiaItem *pEnum = NULL;
            hr = m_pRootItem->EnumChildItems(&pEnum);
            if (S_OK == hr) {
                DWORD Count = 0;
                pEnum->Reset();
                IWiaItem *pIWiaItem = NULL;
                while (SUCCEEDED(hr) && S_OK == pEnum->Next(1, &pIWiaItem, &Count)) {
                    hr = CollectImageItems(pIWiaItem, NULL, 0, &Count);
                    if (SUCCEEDED(hr)) {
                        m_NumImageItems += Count;
                    }
                }

                if (SUCCEEDED(hr)) {
                    // Second pass .....

                    //
                    // m_NumImageItems has the number of image items
                    // Allocate buffer to hold all the image items
                    //
                    m_ImageItemArray = (IWiaItem**)CoTaskMemAlloc((sizeof(IWiaItem*) * m_NumImageItems));
                    if (m_ImageItemArray) {
                        IWiaItem **ppIWiaItems = NULL;
                        DWORD BufferSize = 0;
                        ppIWiaItems = m_ImageItemArray;
                        BufferSize = m_NumImageItems;
                        pEnum->Reset();
                        while (SUCCEEDED(hr) && S_OK == pEnum->Next(1, &pIWiaItem, &Count)) {
                            hr = CollectImageItems(pIWiaItem, ppIWiaItems,BufferSize, &Count);
                            if (SUCCEEDED(hr)) {
                                // advance the buffer
                                ppIWiaItems += Count;
                                // adjust the buffer size
                                BufferSize -= Count;
                            }
                        }

                        if (FAILED(hr)) {
                            m_NumImageItems -=  BufferSize;
                            FreeAcquiredImages();
                        }

                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CWiaDevice::CollectImageItems(IWiaItem *pStartItem,IWiaItem **ItemList,
                                      DWORD ItemListSize, DWORD *pCount)
{
    DBG_FN_WIADEV(CWiaDevice::CollectImageItems());
    HRESULT hr = S_OK;
    DWORD Count = 0;

    if (!pStartItem || (ItemListSize && !ItemList))
        return E_INVALIDARG;

    if (pStartItem) {
        LONG ItemType = 0;
        hr = pStartItem->GetItemType(&ItemType);
        if (SUCCEEDED(hr)) {
            if (ItemType & WiaItemTypeImage) {

                //
                // Count this is as an image item even though
                // we may not have buffer to put it.
                //

                Count++;

                if (ItemList && ItemListSize) {

                    //
                    // AddRef since will call Release on each item
                    // we ever receive
                    //

                    pStartItem->AddRef();
                    *ItemList = pStartItem;
                    ItemListSize--;
                }
            }
            IEnumWiaItem *pEnum = NULL;
            hr = pStartItem->EnumChildItems(&pEnum);
            if (SUCCEEDED(hr)) {
                IWiaItem *pChildItem = NULL;
                DWORD ChildrenCount = 0;
                pEnum->Reset();
                while (SUCCEEDED(hr) && S_OK == pEnum->Next(1, &pChildItem, &ChildrenCount)) {
                    hr = CollectImageItems(pChildItem,&ItemList[Count],ItemListSize,&ChildrenCount);
                    if (SUCCEEDED(hr)) {
                        Count += ChildrenCount;
                        if (ItemListSize > ChildrenCount) {
                            ItemListSize -= ChildrenCount;
                        } else {
                            ItemListSize = 0;
                            ItemList = NULL;
                        }
                    }
                }
                pEnum->Release();
            } else {
                hr = S_OK;
            }
        }
        pStartItem->Release();
    }
    if (pCount)
        *pCount = Count;
    return hr;
}

HRESULT CWiaDevice::FreeAcquiredImages()
{
    DBG_FN_WIADEV(CWiaDevice::FreeAcquiredImages());
    HRESULT hr = S_OK;
    if (m_ImageItemArray) {
        DBG_TRC(("CWiaDevice::FreeAcquiredImages(), Freeing %d IWiaItems",m_NumImageItems));
        for(LONG lItemIndex = 0; lItemIndex < m_NumImageItems; lItemIndex++){
            if(NULL != m_ImageItemArray[lItemIndex]){
                DBG_TRC(("CWiaDevice::FreeAcquiredImages(), Free IWiaItem (%d)",m_ImageItemArray[lItemIndex]));
                m_ImageItemArray[lItemIndex]->Release();
                m_ImageItemArray[lItemIndex] = NULL;
                DBG_TRC(("CWiaDevice::FreeAcquiredImages(), Finished Freeing IWiaItem (%d)",lItemIndex));
            }
        }
        CoTaskMemFree(m_ImageItemArray);
        m_ImageItemArray = NULL;
        m_NumImageItems = 0;
    }
    return hr;
}

HRESULT CWiaDevice::GetNumAcquiredImages(LONG *pNumImages)
{
    DBG_FN_WIADEV(CWiaDevice::GetNumAcquiredImages());
    HRESULT hr = S_OK;
    if (!pNumImages){
        return E_INVALIDARG;
    }
    *pNumImages = m_NumImageItems;
    return hr;
}

HRESULT CWiaDevice::GetAcquiredImageList(LONG lBufferSize,IWiaItem **ppIWiaItem,LONG *plActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetAcquiredImageList());
    HRESULT hr = S_OK;

    if (lBufferSize && !ppIWiaItem) {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr)) {
        if (lBufferSize >=  m_NumImageItems) {
            for (lBufferSize = 0; lBufferSize < m_NumImageItems; lBufferSize++) {
                ppIWiaItem[lBufferSize] = m_ImageItemArray[lBufferSize];
            }
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        if (plActualSize) {
            *plActualSize = m_NumImageItems;
        }
    }
    return hr;
}

HRESULT CWiaDevice::EnumAcquiredImage(DWORD Index,IWiaItem **ppIWiaItem)
{
    DBG_FN_WIADEV(CWiaDevice::EnumAcquiredImages);
    HRESULT hr = S_OK;
    if (!ppIWiaItem) {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr)) {
        if (Index < (DWORD)m_NumImageItems) {
            *ppIWiaItem = m_ImageItemArray[Index];
            hr = S_OK;
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        }
    }
    return hr;
}

HRESULT CWiaDevice::GetImageInfo(IWiaItem *pIWiaItem,PMEMORY_TRANSFER_INFO pImageInfo)
{
    DBG_FN_WIADEV(CWiaDevice::GetImageInfo());
    if (!pIWiaItem || !pImageInfo)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_DATATYPE,&pImageInfo->mtiDataType);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_DATATYPE"));
        return hr;
    }

#ifdef SUPPORT_COMPRESSION_TYPES

    hr = WIA.ReadPropertyLong(WIA_IPA_COMPRESSION,&pImageInfo->mtiCompression);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_COMPRESSION"));
        return hr;
    }

#else // SUPPORT_COMPRESSION_TYPES

    pImageInfo->mtiCompression = WIA_COMPRESSION_NONE;

#endif // SUPPORT_COMPRESSION_TYPES

    hr = WIA.ReadPropertyLong(WIA_IPA_CHANNELS_PER_PIXEL,&pImageInfo->mtiNumChannels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_CHANNELS_PER_PIXEL"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_BITS_PER_CHANNEL,&pImageInfo->mtiBitsPerChannel[0]);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_BITS_PER_CHANNEL"));
        return hr;
    }

    for(LONG i = 0; i<pImageInfo->mtiNumChannels; i++){
        pImageInfo->mtiBitsPerChannel[i] = pImageInfo->mtiBitsPerChannel[0];
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_PIXELS_PER_LINE,&pImageInfo->mtiWidthPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_PIXELS_PER_LINE"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_BYTES_PER_LINE,&pImageInfo->mtiBytesPerLine);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_BYTES_PER_LINE"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_PLANAR,&pImageInfo->mtiPlanar);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_PLANAR"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_NUMBER_OF_LINES,&pImageInfo->mtiHeightPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_NUMBER_OF_LINES"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_DEPTH,&pImageInfo->mtiBitsPerPixel);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_DEPTH"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&pImageInfo->mtiXResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPS_XRES"));
        return hr;
    } else if (S_FALSE == hr) {
        DBG_WRN(("CWiaDevice::GetImageInfo(), S_FALSE was returned from reading X Resolution, defaulting to 300 dpi (dummy value)"));
        // set default
        pImageInfo->mtiXResolution = 300;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&pImageInfo->mtiYResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPS_YRES"));
        return hr;
    } else if (S_FALSE == hr) {
        DBG_WRN(("CWiaDevice::GetImageInfo(), S_FALSE was returned from reading Y Resolution, defaulting to 300 dpi (dummy value)"));
        // set default
        pImageInfo->mtiYResolution = 300;
    }

    hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&pImageInfo->mtiguidFormat);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_FORMAT"));
        return hr;
    }

    return hr;
}

HRESULT CWiaDevice::GetThumbnailImageInfo(IWiaItem *pIWiaItem,PMEMORY_TRANSFER_INFO pImageInfo)
{
    DBG_FN_WIADEV(CWiaDevice::GetThumbnailImageInfo());
    if (!pIWiaItem || !pImageInfo)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailImageInfo(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH,&pImageInfo->mtiWidthPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailImageInfo(), failed to read WIA_IPC_THUMB_WIDTH"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT,&pImageInfo->mtiHeightPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailImageInfo(), failed to read WIA_IPC_THUMB_HEIGHT"));
        return hr;
    }

    if (SUCCEEDED(hr)) {

        //
        // Thumbnail is always in 24bits color in DIB format without
        // BITMAPINFO header.
        //

        pImageInfo->mtiNumChannels       = 3;
        pImageInfo->mtiBitsPerChannel[0] = 8;
        pImageInfo->mtiBitsPerChannel[1] = 8;
        pImageInfo->mtiBitsPerChannel[2] = 8;
        pImageInfo->mtiBitsPerPixel      = 24;
        pImageInfo->mtiPlanar            = FALSE;
        pImageInfo->mtiBytesPerLine      = (pImageInfo->mtiWidthPixels * 24/8 + 3) / 4;
        pImageInfo->mtiCompression       = WIA_COMPRESSION_NONE;
        pImageInfo->mtiXResolution       = 75;
        pImageInfo->mtiYResolution       = 75;
    }
    return hr;
}

HRESULT CWiaDevice::GetImageRect(IWiaItem *pIWiaItem,LPRECT pRect)
{
    DBG_FN_WIADEV(CWiaDevice::GetImageRect());
    if (!pRect || !pIWiaItem)
        return E_INVALIDARG;

    HRESULT hr    = S_OK;
    LONG lXPos    = 0;
    LONG lYPos    = 0;
    LONG lXExtent = 0;
    LONG lYExtent = 0;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XPOS,&lXPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_XPOS"));
        return hr;
    }
    hr = WIA.ReadPropertyLong(WIA_IPS_YPOS,&lYPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_YPOS"));
        return hr;
    }
    hr = WIA.ReadPropertyLong(WIA_IPS_XEXTENT,&lXExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_XEXTENT"));
        return hr;
    }
    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_YEXTENT"));
        return hr;
    }

    if (SUCCEEDED(hr)) {
        pRect->left   = lXPos;
        pRect->right  = lXExtent + lXPos - 1;
        pRect->top    = lYPos;
        pRect->bottom = lYExtent + lYPos - 1;
    }
    return hr;
}

HRESULT CWiaDevice::GetThumbnailRect(IWiaItem *pIWiaItem,LPRECT  pRect)
{
    DBG_FN_WIADEV(CWiaDevice::GetThumbnailRect());
    if (!pIWiaItem || !pRect)
        return E_INVALIDARG;

    HRESULT hr   = S_OK;
    LONG lWidth  = 0;
    LONG lHeight = 0;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailRect(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH,&lWidth);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailRect(), failed to read WIA_IPC_THUMB_WIDTH"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT,&lHeight);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailRect(), failed to read WIA_IPC_THUMB_HEIGHT"));
        return hr;
    }

    if (SUCCEEDED(hr)) {
        pRect->left   = 0;
        pRect->top    = 0;
        pRect->right  = lWidth - 1;
        pRect->bottom = lHeight - 1;
    }

    return hr;
}

HRESULT CWiaDevice::LoadImage(IWiaItem *pIWiaItem,GUID guidFormatID,IWiaDataCallback *pIDataCB)
{
    DBG_FN_WIADEV(CWiaDevice::LoadImage());
    HRESULT hr = S_OK;
    if (!pIWiaItem || !pIDataCB) {
        return E_INVALIDARG;
    }

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::LoadImage(), failed to set IWiaItem for property writing"));
        return hr;
    }

    IWiaDataTransfer *pDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer,(void**)&pDataTransfer);
    if (S_OK == hr) {

        //
        // write TYMED
        //

        hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_CALLBACK);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDevice::LoadImage(), failed to write WIA_IPA_TYMED"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }

        //
        // write format
        //

        hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT, guidFormatID);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::LoadImage(), failed to write WIA_IPA_FORMAT"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }


        LONG BufferSize = DEFAULT_BUFFER_SIZE;
        hr = WIA.ReadPropertyLong(WIA_IPA_MIN_BUFFER_SIZE, &BufferSize);
        if (FAILED(hr)) {
            DBG_WRN(("CWiaDevice::LoadImage(), failed to read WIA_IPA_MIN_BUFFER_SIZE, (defaulting to %d)",DEFAULT_BUFFER_SIZE));
            BufferSize = DEFAULT_BUFFER_SIZE;
        }

        //
        // Before we do the blocking call, we need to temporarily disable
        // the registered IMessageFilter (if any).  We do this primarily
        // for MFC based apps, as in some situations they can put up
        // the "Server Busy" dialog when things are fine -- it's just
        // taking a while to scan, etc.  Unfortunately, we can't detect
        // if it's MFC's IMessageFilter we're disabling.  Apps can actually
        // do interesting work in IMessageFilter, but it's not likely.  This
        // is a risk we're taking by nuking the message filter for the duration
        // of the transfer.
        //

        // Nb: Note we ignore result of this call. It is generally harmless, but asserting it
        // may be useful

        g_pOldOleMessageFilter = NULL;
        HRESULT hr_ServerBusyFix = S_OK;
        hr_ServerBusyFix = ::CoRegisterMessageFilter( NULL, &g_pOldOleMessageFilter );
        if(FAILED(hr_ServerBusyFix)){
            DBG_WRN(("CWiaDevice::LoadImage(), failed to (Saving IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
        }

        WIA_DATA_TRANSFER_INFO wiadtInfo;
        memset(&wiadtInfo,0,sizeof(wiadtInfo));
        wiadtInfo.ulSize        = sizeof(wiadtInfo);
        wiadtInfo.ulBufferSize  = BufferSize * 4;

        //
        // acquire data from the IWiaItem
        //

        hr = pDataTransfer->idtGetBandedData(&wiadtInfo, pIDataCB);

        //
        // Restore the old IMessageFilter if there was one
        //

        if (g_pOldOleMessageFilter) {
            hr_ServerBusyFix = ::CoRegisterMessageFilter( g_pOldOleMessageFilter, NULL );
            if(FAILED(hr_ServerBusyFix)){
                DBG_WRN(("CWiaDevice::LoadImage(), failed to (Restoring IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
            }
            g_pOldOleMessageFilter = NULL;
        }

        //
        // release IWiaDataTransfer Interface
        //

        pDataTransfer->Release();
    }
    return hr;
}

HRESULT CWiaDevice::LoadImageToDisk(IWiaItem *pIWiaItem,CHAR *pFileName, GUID guidFormatID,IWiaDataCallback *pIDataCB)
{
    DBG_FN_WIADEV(CWiaDevice::LoadImage());
    HRESULT hr = S_OK;
    if (!pIWiaItem || !pIDataCB || !pFileName) {
        return E_INVALIDARG;
    }

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::LoadImageToDisk(), failed to set IWiaItem for property writing"));
        return hr;
    }

    IWiaDataTransfer *pDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer,(void**)&pDataTransfer);
    if (S_OK == hr) {

        //
        // write TYMED
        //

        hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_FILE);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDevice::LoadImageToDisk(), failed to write WIA_IPA_TYMED"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }

        //
        // write format
        //

        hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT, guidFormatID);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::LoadImageToDisk(), failed to write WIA_IPA_FORMAT"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }

        //
        // Before we do the blocking call, we need to temporarily disable
        // the registered IMessageFilter (if any).  We do this primarily
        // for MFC based apps, as in some situations they can put up
        // the "Server Busy" dialog when things are fine -- it's just
        // taking a while to scan, etc.  Unfortunately, we can't detect
        // if it's MFC's IMessageFilter we're disabling.  Apps can actually
        // do interesting work in IMessageFilter, but it's not likely.  This
        // is a risk we're taking by nuking the message filter for the duration
        // of the transfer.
        //

        // Nb: Note we ignore result of this call. It is generally harmless, but asserting it
        // may be useful

        g_pOldOleMessageFilter = NULL;
        HRESULT hr_ServerBusyFix = S_OK;
        hr_ServerBusyFix = ::CoRegisterMessageFilter( NULL, &g_pOldOleMessageFilter );
        if(FAILED(hr_ServerBusyFix)){
            DBG_WRN(("CWiaDevice::LoadImageToDisk(), failed to (Saving IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
        }

        //
        // load the StgMedium
        //

        WCHAR wszFileName[MAX_PATH];
        memset(wszFileName,0,sizeof(wszFileName));
        MultiByteToWideChar(CP_ACP, 0,pFileName,-1,wszFileName,(sizeof(wszFileName)/sizeof(wszFileName[0])));

        STGMEDIUM StgMedium;
        memset(&StgMedium,0,sizeof(StgMedium));

        StgMedium.tymed          = TYMED_FILE;
        StgMedium.pUnkForRelease = NULL;
        StgMedium.hGlobal        = NULL;
        StgMedium.lpszFileName   = wszFileName;

        //
        // acquire data from the IWiaItem
        //

        hr = pDataTransfer->idtGetData(&StgMedium, pIDataCB);

        //
        // Restore the old IMessageFilter if there was one
        //

        if (g_pOldOleMessageFilter) {
            hr_ServerBusyFix = ::CoRegisterMessageFilter( g_pOldOleMessageFilter, NULL );
            if(FAILED(hr_ServerBusyFix)){
                DBG_WRN(("CWiaDevice::LoadImageToDisk(), failed to (Restoring IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
            }
            g_pOldOleMessageFilter = NULL;
        }

        //
        // release IWiaDataTransfer Interface
        //

        pDataTransfer->Release();
    }
    return hr;
}

HRESULT CWiaDevice::GetBasicScannerInfo(PBASIC_INFO pBasicInfo)
{
    if (!pBasicInfo || pBasicInfo->Size < sizeof(BASIC_INFO))
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    LONG lDocumentHandlingCapabilites = 0;
    LONG lHorizontalBedSize           = 0;
    LONG lVerticalBedSize             = 0;
    LONG lXOpticalResolution          = 0;
    LONG lYOpticalResolution          = 0;

    pBasicInfo->FeederCaps  = 0;
    pBasicInfo->xBedSize    = 0;
    pBasicInfo->xOpticalRes = 0;
    pBasicInfo->yOpticalRes = 0;
    pBasicInfo->yBedSize    = 0;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pRootItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,&lDocumentHandlingCapabilites);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES"));
        return hr;
    }

    pBasicInfo->FeederCaps  = (TW_UINT32)lDocumentHandlingCapabilites;

    hr = WIA.ReadPropertyLong(WIA_DPS_OPTICAL_XRES,&lXOpticalResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_OPTICAL_XRES"));
        return hr;
    }


    pBasicInfo->xOpticalRes = (TW_UINT32)lXOpticalResolution;

    hr = WIA.ReadPropertyLong(WIA_DPS_OPTICAL_YRES,&lYOpticalResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_OPTICAL_YRES"));
        return hr;
    }

    pBasicInfo->yOpticalRes = (TW_UINT32)lYOpticalResolution;

    hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_BED_SIZE,&lHorizontalBedSize);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_HORIZONTAL_BED_SIZE"));
        return hr;
    } else if(S_FALSE == hr){
        DBG_WRN(("CWiaDevice::GetBasicScannerInfo(), WIA_DPS_HORIZONTAL_BED_SIZE property not found"));
        hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,&lHorizontalBedSize);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE"));
            return hr;
        }
    }

    pBasicInfo->xBedSize    = lHorizontalBedSize;

    hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_BED_SIZE,&lVerticalBedSize);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_VERTICAL_BED_SIZE"));
        return hr;
    } else if(S_FALSE == hr){
        DBG_WRN(("CWiaDevice::GetBasicScannerInfo(), WIA_DPS_VERTICAL_BED_SIZE property not found"));
        hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_SHEET_FEED_SIZE,&lVerticalBedSize);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_VERTICAL_SHEET_FEED_SIZE"));
            return hr;
        }
    }

    pBasicInfo->yBedSize    = lVerticalBedSize;

    return hr;
}

BOOL CWiaDevice::TwainCapabilityPassThrough()
{
    HRESULT hr = S_OK;

    LONG lRootItemFlags = 0;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pRootItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::TwainCapabilityPassThrough(), failed to set IWiaItem for property reading"));
        return FALSE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_ITEM_FLAGS,&lRootItemFlags);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::TwainCapabilityPassThrough(), failed to read WIA_IPA_ITEM_FLAGS"));
        return FALSE;
    }

    return (lRootItemFlags & WiaItemTypeTwainCapabilityPassThrough);
}

HRESULT CWiaDevice::LoadThumbnail(IWiaItem *pIWiaItem,HGLOBAL *phThumbnail,ULONG *pThumbnailSize)
{
    DBG_FN_WIADEV(CWiaDevice::LoadThumbnail());
    HRESULT hr = S_OK;

    if (!phThumbnail || !pIWiaItem)
        return E_INVALIDARG;

    *phThumbnail    = NULL;
    HGLOBAL hThumbnail = NULL;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::LoadThumbnail(), failed to set IWiaItem for property writing"));
        return hr;
    }

    LONG ThumbWidth  = 0;
    LONG ThumbHeight = 0;
    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH, &ThumbWidth);
    if (SUCCEEDED(hr)) {
        hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT, &ThumbHeight);
        if (SUCCEEDED(hr)) {
            LONG lDataSize   = 0;
            BYTE* pThumbData = NULL;
            hr = WIA.ReadPropertyData(WIA_IPC_THUMBNAIL,&pThumbData,&lDataSize);
            if (SUCCEEDED(hr)) {
                hThumbnail = NULL;
                hThumbnail = GlobalAlloc(GHND, (lDataSize + sizeof(BITMAPINFOHEADER)));
                if (hThumbnail) {
                    BITMAPINFOHEADER *pbmih = NULL;
                    pbmih = (BITMAPINFOHEADER*)GlobalLock(hThumbnail);
                    if (pbmih) {

                        DBG_TRC(("CWiaDevice::LoadThumbnail(), Reported thumbnail information"));
                        DBG_TRC(("Width     = %d",ThumbWidth));
                        DBG_TRC(("Height    = %d",ThumbHeight));
                        DBG_TRC(("Data Size = %d",lDataSize));

                        //
                        // Initialize the BITMAPINFOHEADER
                        //

                        pbmih->biSize          = sizeof(BITMAPINFOHEADER);
                        pbmih->biWidth         = ThumbWidth;
                        pbmih->biHeight        = ThumbHeight;
                        pbmih->biPlanes        = 1;
                        pbmih->biBitCount      = 24;
                        pbmih->biCompression   = BI_RGB;
                        pbmih->biSizeImage     = lDataSize;
                        pbmih->biXPelsPerMeter = 0;
                        pbmih->biYPelsPerMeter = 0;
                        pbmih->biClrUsed       = 0;
                        pbmih->biClrImportant  = 0;

                        //
                        // Copy the bits. The bits buffer is right after
                        // the header.
                        //

                        BYTE *pDst = (BYTE*)pbmih;
                        pDst = pDst + sizeof(BITMAPINFOHEADER);
                        memcpy(pDst, pThumbData,lDataSize);
                        GlobalUnlock(hThumbnail);
                        *phThumbnail = hThumbnail;

                        if (pThumbnailSize){
                            *pThumbnailSize = (lDataSize + sizeof(BITMAPINFOHEADER));
                        }
                    } else {
                        GlobalFree(hThumbnail);
                        hr = E_OUTOFMEMORY;
                    }
                } else {
                    hr = E_OUTOFMEMORY;
                }

                //
                // free any temporary buffers
                //

                if (pThumbData) {
                    DBG_TRC(("CWiaDevice::LoadThumbnail(), freeing temporary thumbnail buffer"));
                    GlobalFree(pThumbData);
                    pThumbData = NULL;
                    DBG_TRC(("CWiaDevice::LoadThumbnail(), finished freeing temporary thumbnail buffer"));
                }
            }
        }
    }
    return hr;
}

//
// CWiaEventCallback object implementation
//

HRESULT CWiaEventCallback::ImageEventCallback(const GUID *pEventGuid,BSTR bstrEventDescription,
                                              BSTR bstrDeviceId,BSTR bstrDeviceDescription,
                                              DWORD dwDeviceType,BSTR bstrFullItemName,
                                              ULONG *pulEventType,ULONG ulReserved)
{
    DBG_FN_WIADEV(CWiaEventCallback::ImageEventCallback);
    //
    // translate WIA event guid to event code.
    // Note that we do not verify device id here because
    // we will not receive events not meant for the device this
    // object was created for.
    //

    if (m_pfnCallback && WIA_EVENT_DEVICE_DISCONNECTED == *pEventGuid) {
        return(*m_pfnCallback)(0, m_CallbackParam);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\wiadss.h ===
#ifndef __WIADSS_H_
#define __WIADSS_H_

//
// DeviceFlags definitions
//

#define DEVICE_FLAGS_DEVICETYPE     0xF // device type mask
#define DEVICETYPE_UNKNOWN          0x0 // unknown device
#define DEVICETYPE_DIGITALCAMERA    0x1 // digital camera
#define DEVICETYPE_SCANNER          0x2 // scanner
#define DEVICETYPE_STREAMINGVIDEO   0x4 // streaming video

//
// structure definitions
//

typedef struct tagMEMORY_TRANSFER_INFO
{
    GUID  mtiguidFormat;        // WIA image format
    LONG  mtiCompression;       // compression type
    LONG  mtiBitsPerPixel;      // image bits per pixel
    LONG  mtiBytesPerLine;      // image bytes per line
    LONG  mtiWidthPixels;       // image width (pixels)
    LONG  mtiHeightPixels;      // image height (pixels)
    LONG  mtiXResolution;       // image x resolution
    LONG  mtiYResolution;       // image y resolution
    LONG  mtiNumChannels;       // number of channels used
    LONG  mtiBitsPerChannel[8]; // number of bits per channel
    LONG  mtiPlanar;            // TRUE - planar, FALSE - packed
    LONG  mtiDataType;          // WIA data type
    BYTE *mtipBits;             // pointer to image data bits
}MEMORY_TRANSFER_INFO, *PMEMORY_TRANSFER_INFO;

//
// Imported data source entry retuned to DSM. Every data source from us
// shares this entry point.
//

TW_UINT16 APIENTRY ImportedDSEntry(HANDLE hDS,TW_IDENTITY *AppId,TW_UINT32 DG,
                                   TW_UINT16 DT,TW_UINT16 MSG,TW_MEMREF pData);

extern  HINSTANCE   g_hInstance;

#endif  // #ifndef __WIADSS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\wiahelper.h ===
#ifndef WIAHELPER_H
#define WIAHELPER_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MIN_PROPID 2
#define NO_STREAMSUPPORT

//
// WIA property access class definition
//

class CWiahelper
{
public:
    CWiahelper();
    virtual ~CWiahelper();

    HRESULT SetIWiaItem(IWiaItem *pIWiaItem);

    HRESULT ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue, INT iBufferSize);
    HRESULT ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue);
    HRESULT ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue);
    HRESULT ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue);
    HRESULT ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize);
    HRESULT ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue);
    HRESULT ReadPropertyStreamFile(TCHAR *szPropertyStreamFile);
    HRESULT ReadPropertyAttributes(PROPID PropertyID, LONG *plAccessFlags, PROPVARIANT *pPropertyVariant);

    HRESULT WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT WritePropertyLong(PROPID PropertyID, LONG lPropertyValue);
    HRESULT WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue);
    HRESULT WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue);
    HRESULT WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue);
    HRESULT WritePropertyStreamFile(TCHAR *szPropertyStreamFile);

private:
    IWiaItem *m_pIWiaItem;
    IWiaPropertyStorage *m_pIWiaPropStg;
};

#endif // WIAHELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\wiadss.cpp ===
#include "precomp.h"
#include "dsloader.h"
#include <sti.h>

extern IMessageFilter * g_pOldOleMessageFilter;

const DWORD FINDCONTEXT_SIGNATURE = 0x1F2E4C3D;

HINSTANCE         g_hInstance;
TW_STATUS         g_twStatus;

typedef struct tagFindContext {
    DWORD   Signature;
    IEnumWIA_DEV_INFO *pEnumDevInfo;
}FINDCONTEXT, *PFINDCONTEXT;

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, void* lpReserved)
{
    HRESULT hr = S_OK;

    DBG_INIT((HINSTANCE)hModule);

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:

        // Disable thread library calls to avoid
        // deadlock when we spin up the worker thread
        DisableThreadLibraryCalls(hModule);
        g_hInstance = hModule;
        InitCommonControls();
        break;

    case DLL_PROCESS_DETACH:
        break;
    default:
        break;
    }

    return TRUE ;
}

TW_UINT16 APIENTRY ImportedDSEntry(HANDLE hDS,TW_IDENTITY *AppId,TW_UINT32 DG,
                                   TW_UINT16 DT,TW_UINT16 MSG,TW_MEMREF pData)
{
    if (MSG != MSG_PROCESSEVENT) {
        if(AppId != NULL) {
#ifdef UNICODE

        //
        // TWAIN only passes ANSI strings. DPRINTF(DM_TRACE,) is expecting TCHARs which are supposed to
        // be WCHAR on NT.  Conversion here is only for clear debug output, and will
        // not be in release builds. (the calling application name is useful for logging)
        //

        WCHAR szProductName[255];
        MultiByteToWideChar(CP_ACP, 0, AppId->ProductName, -1, szProductName, (sizeof(szProductName) / sizeof(szProductName[0])));

        DBG_TRC(("[%ws] Sent to TWAIN Source, DG = %X, DT = %X, MSG = %X",szProductName,DG,DT,MSG));
#else
        DBG_TRC(("[%s] Sent to TWAIN Source, DG = %X, DT = %X, MSG = %X",AppId->ProductName,DG,DT,MSG));
#endif

        }
        if (DT == DAT_CAPABILITY) {
            if (g_dwDebugFlags & COREDBG_TRACES) {
                char szBuf[256];
                memset(szBuf,0,sizeof(szBuf));
                switch (MSG) {
                case MSG_GET:
                    lstrcpyA(szBuf,"MSG_GET");
                    break;
                case MSG_GETCURRENT:
                    lstrcpyA(szBuf,"MSG_GETCURRENT");
                    break;
                case MSG_GETDEFAULT:
                    lstrcpyA(szBuf,"MSG_GETDEFAULT");
                    break;
                case MSG_SET:
                    lstrcpyA(szBuf,"MSG_SET");
                    break;
                case MSG_RESET:
                    lstrcpyA(szBuf,"MSG_RESET");
                    break;
                default:
                    lstrcpyA(szBuf,"MSG_UNKNOWN");
                    DBG_TRC(("Unknown MSG = %X",MSG));
                    break;
                }

                char szBuf2[256];
                memset(szBuf2,0,sizeof(szBuf2));
                switch (((TW_CAPABILITY*)pData)->Cap) {
                case CAP_CUSTOMBASE:
                    lstrcpyA(szBuf2,"CAP_CUSTOMBASE");
                    break;
                case CAP_XFERCOUNT:
                    lstrcpyA(szBuf2,"CAP_XFERCOUNT");
                    break;
                case ICAP_COMPRESSION:
                    lstrcpyA(szBuf2,"ICAP_COMPRESSION");
                    break;
                case ICAP_PIXELTYPE:
                    lstrcpyA(szBuf2,"ICAP_PIXELTYPE");
                    break;
                case ICAP_UNITS:
                    lstrcpyA(szBuf2,"ICAP_UNITS");
                    break;
                case ICAP_XFERMECH:
                    lstrcpyA(szBuf2,"ICAP_XFERMECH");
                    break;
                case CAP_AUTHOR:
                    lstrcpyA(szBuf2,"CAP_AUTHOR");
                    break;
                case CAP_CAPTION:
                    lstrcpyA(szBuf2,"CAP_CAPTION");
                    break;
                case CAP_FEEDERENABLED:
                    lstrcpyA(szBuf2,"CAP_FEEDERENABLED");
                    break;
                case CAP_FEEDERLOADED:
                    lstrcpyA(szBuf2,"CAP_FEEDERLOADED");
                    break;
                case CAP_TIMEDATE:
                    lstrcpyA(szBuf2,"CAP_TIMEDATE");
                    break;
                case CAP_SUPPORTEDCAPS:
                    lstrcpyA(szBuf2,"CAP_SUPPORTEDCAPS");
                    break;
                case CAP_EXTENDEDCAPS:
                    lstrcpyA(szBuf2,"CAP_EXTENDEDCAPS");
                    break;
                case CAP_AUTOFEED:
                    lstrcpyA(szBuf2,"CAP_AUTOFEED");
                    break;
                case CAP_CLEARPAGE:
                    lstrcpyA(szBuf2,"CAP_CLEARPAGE");
                    break;
                case CAP_FEEDPAGE:
                    lstrcpyA(szBuf2,"CAP_FEEDPAGE");
                    break;
                case CAP_REWINDPAGE:
                    lstrcpyA(szBuf2,"CAP_REWINDPAGE");
                    break;
                case CAP_INDICATORS:
                    lstrcpyA(szBuf2,"CAP_INDICATORS");
                    break;
                case CAP_SUPPORTEDCAPSEXT:
                    lstrcpyA(szBuf2,"CAP_SUPPORTEDCAPSEXT");
                    break;
                case CAP_PAPERDETECTABLE:
                    lstrcpyA(szBuf2,"CAP_PAPERDETECTABLE");
                    break;
                case CAP_UICONTROLLABLE:
                    lstrcpyA(szBuf2,"CAP_UICONTROLLABLE");
                    break;
                case CAP_DEVICEONLINE:
                    lstrcpyA(szBuf2,"CAP_DEVICEONLINE");
                    break;
                case CAP_AUTOSCAN:
                    lstrcpyA(szBuf2,"CAP_AUTOSCAN");
                    break;
                case CAP_THUMBNAILSENABLED:
                    lstrcpyA(szBuf2,"CAP_THUMBNAILSENABLED");
                    break;
                case CAP_DUPLEX:
                    lstrcpyA(szBuf2,"CAP_DUPLEX");
                    break;
                case CAP_DUPLEXENABLED:
                    lstrcpyA(szBuf2,"CAP_DUPLEXENABLED");
                    break;
                case CAP_ENABLEDSUIONLY:
                    lstrcpyA(szBuf2,"CAP_ENABLEDSUIONLY");
                    break;
                case CAP_CUSTOMDSDATA:
                    lstrcpyA(szBuf2,"CAP_CUSTOMDSDATA");
                    break;
                case CAP_ENDORSER:
                    lstrcpyA(szBuf2,"CAP_ENDORSER");
                    break;
                case CAP_JOBCONTROL:
                    lstrcpyA(szBuf2,"CAP_JOBCONTROL");
                    break;
                case ICAP_AUTOBRIGHT:
                    lstrcpyA(szBuf2,"ICAP_AUTOBRIGHT");
                    break;
                case ICAP_BRIGHTNESS:
                    lstrcpyA(szBuf2,"ICAP_BRIGHTNESS");
                    break;
                case ICAP_CONTRAST:
                    lstrcpyA(szBuf2,"ICAP_CONTRAST");
                    break;
                case ICAP_CUSTHALFTONE:
                    lstrcpyA(szBuf2,"ICAP_CUSTHALFTONE");
                    break;
                case ICAP_EXPOSURETIME:
                    lstrcpyA(szBuf2,"ICAP_EXPOSURETIME");
                    break;
                case ICAP_FILTER:
                    lstrcpyA(szBuf2,"ICAP_FILTER");
                    break;
                case ICAP_FLASHUSED:
                    lstrcpyA(szBuf2,"ICAP_FLASHUSED");
                    break;
                case ICAP_GAMMA:
                    lstrcpyA(szBuf2,"ICAP_GAMMA");
                    break;
                case ICAP_HALFTONES:
                    lstrcpyA(szBuf2,"ICAP_HALFTONES");
                    break;
                case ICAP_HIGHLIGHT:
                    lstrcpyA(szBuf2,"ICAP_HIGHLIGHT");
                    break;
                case ICAP_IMAGEFILEFORMAT:
                    lstrcpyA(szBuf2,"ICAP_IMAGEFILEFORMAT");
                    break;
                case ICAP_LAMPSTATE:
                    lstrcpyA(szBuf2,"ICAP_LAMPSTATE");
                    break;
                case ICAP_LIGHTSOURCE:
                    lstrcpyA(szBuf2,"ICAP_LIGHTSOURCE");
                    break;
                case ICAP_ORIENTATION:
                    lstrcpyA(szBuf2,"ICAP_ORIENTATION");
                    break;
                case ICAP_PHYSICALWIDTH:
                    lstrcpyA(szBuf2,"ICAP_PHYSICALWIDTH");
                    break;
                case ICAP_PHYSICALHEIGHT:
                    lstrcpyA(szBuf2,"ICAP_PHYSICALHEIGHT");
                    break;
                case ICAP_SHADOW:
                    lstrcpyA(szBuf2,"ICAP_SHADOW");
                    break;
                case ICAP_FRAMES:
                    lstrcpyA(szBuf2,"ICAP_FRAMES");
                    break;
                case ICAP_XNATIVERESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_XNATIVERESOLUTION");
                    break;
                case ICAP_YNATIVERESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_YNATIVERESOLUTION");
                    break;
                case ICAP_XRESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_XRESOLUTION");
                    break;
                case ICAP_YRESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_YRESOLUTION");
                    break;
                case ICAP_MAXFRAMES:
                    lstrcpyA(szBuf2,"ICAP_MAXFRAMES");
                    break;
                case ICAP_TILES:
                    lstrcpyA(szBuf2,"ICAP_TILES");
                    break;
                case ICAP_BITORDER:
                    lstrcpyA(szBuf2,"ICAP_BITORDER");
                    break;
                case ICAP_CCITTKFACTOR:
                    lstrcpyA(szBuf2,"ICAP_CCITTKFACTOR");
                    break;
                case ICAP_LIGHTPATH:
                    lstrcpyA(szBuf2,"ICAP_LIGHTPATH");
                    break;
                case ICAP_PIXELFLAVOR:
                    lstrcpyA(szBuf2,"ICAP_PIXELFLAVOR");
                    break;
                case ICAP_PLANARCHUNKY:
                    lstrcpyA(szBuf2,"ICAP_PLANARCHUNKY");
                    break;
                case ICAP_ROTATION:
                    lstrcpyA(szBuf2,"ICAP_ROTATION");
                    break;
                case ICAP_SUPPORTEDSIZES:
                    lstrcpyA(szBuf2,"ICAP_SUPPORTEDSIZES");
                    break;
                case ICAP_THRESHOLD:
                    lstrcpyA(szBuf2,"ICAP_THRESHOLD");
                    break;
                case ICAP_XSCALING:
                    lstrcpyA(szBuf2,"ICAP_XSCALING");
                    break;
                case ICAP_YSCALING:
                    lstrcpyA(szBuf2,"ICAP_YSCALING");
                    break;
                case ICAP_BITORDERCODES:
                    lstrcpyA(szBuf2,"ICAP_BITORDERCODES");
                    break;
                case ICAP_PIXELFLAVORCODES:
                    lstrcpyA(szBuf2,"ICAP_PIXELFLAVORCODES");
                    break;
                case ICAP_JPEGPIXELTYPE:
                    lstrcpyA(szBuf2,"ICAP_JPEGPIXELTYPE");
                    break;
                case ICAP_TIMEFILL:
                    lstrcpyA(szBuf2,"ICAP_TIMEFILL");
                    break;
                case ICAP_BITDEPTH:
                    lstrcpyA(szBuf2,"ICAP_BITDEPTH");
                    break;
                case ICAP_BITDEPTHREDUCTION:
                    lstrcpyA(szBuf2,"ICAP_BITDEPTHREDUCTION");
                    break;
                case ICAP_UNDEFINEDIMAGESIZE:
                    lstrcpyA(szBuf2,"ICAP_UNDEFINEDIMAGESIZE");
                    break;
                case ICAP_IMAGEDATASET:
                    lstrcpyA(szBuf2,"ICAP_IMAGEDATASET");
                    break;
                case ICAP_EXTIMAGEINFO:
                    lstrcpyA(szBuf2,"ICAP_EXTIMAGEINFO");
                    break;
                case ICAP_MINIMUMHEIGHT:
                    lstrcpyA(szBuf2,"ICAP_MINIMUMHEIGHT");
                    break;
                case ICAP_MINIMUMWIDTH:
                    lstrcpyA(szBuf2,"ICAP_MINIMUMWIDTH");
                    break;
                default:
                    lstrcpyA(szBuf2,"(undefined or new CAP)");
                    break;
                }

                DBG_TRC(("DAT_CAPABILITY operation, %s on CAP  = %s (%x)",szBuf,szBuf2,((TW_CAPABILITY*)pData)->Cap));
            }
        }
    }
    CWiaDataSrc *pDataSrc;
    pDataSrc = (CWiaDataSrc *)hDS;
    if (pDataSrc) {
        return pDataSrc->DSEntry(AppId, DG, DT, MSG, pData);
    }

    return TWRC_FAILURE;
}

TW_UINT16 APIENTRY FindFirstImportDS(PIMPORT_DSINFO pDSInfo,PVOID *Context)
{
    DBG_TRC(("FindFirstImportDS - CoInitialize"));
    ::CoInitialize(NULL);
    if (!pDSInfo || pDSInfo->Size < sizeof(IMPORT_DSINFO) ||
        !Context) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }

    HRESULT hr;
    IWiaDevMgr *pWiaDevMgr;
    TW_UINT16 twRc;

    *Context = NULL;
    g_twStatus.ConditionCode = TWCC_OPERATIONERROR;

    //
    // Presume guilty
    //
    twRc = TWRC_FAILURE;

    //
    // Get IWiaDevMgr interface
    //
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL,
                          CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,
                          (void**)&pWiaDevMgr
                         );
    if (SUCCEEDED(hr)) {
        //
        // Get IEnumWIA_DEV_INFO interface.
        // This interface pointer will be saved as part
        // of the find context.
        //
        IEnumWIA_DEV_INFO *pEnumDevInfo = NULL;
        hr = pWiaDevMgr->EnumDeviceInfo(0, &pEnumDevInfo);

        //
        // We do not need the IWiaDevMgr interface anymore. The reference count
        // on the IEnumWIA_DEV_INFO will keep the WIA Device Manager
        // alive.
        //
        pWiaDevMgr->Release();

        if (SUCCEEDED(hr)) {
            //
            // Make sure the current position is reset to the begining.
            //
            pEnumDevInfo->Reset();
            //
            // Create a new find context
            //
            PFINDCONTEXT pFindContext;
            pFindContext = new FINDCONTEXT;
            if (pFindContext) {
                pFindContext->pEnumDevInfo = pEnumDevInfo;
                pFindContext->Signature = FINDCONTEXT_SIGNATURE;
                //
                // This gets the first available data source
                //
                twRc = FindNextImportDS(pDSInfo, pFindContext);
                if (TWRC_SUCCESS == twRc) {
                    *Context = pFindContext;
                } else {
                    //
                    // The callers will not call CloseFindContext
                    // if FindFirstContext failed. For this reason
                    // we have to delete the find context here
                    //
                    delete pFindContext;
                    pFindContext = NULL;
                }
            } else {

                //
                // set TWAIN condition code to TWCC_LOWMEMORY
                // because we failed to allocate pFindContext
                //

                g_twStatus.ConditionCode = TWCC_LOWMEMORY;
            }
        }

        //
        // release IEnumWIA_DEV_INFO interface when finished
        //

        /*
        if (pEnumDevInfo) {
            pEnumDevInfo->Release();
            pEnumDevInfo = NULL;
            if(*Context){
                PFINDCONTEXT pFindContext;
                pFindContext = (PFINDCONTEXT)*Context;
                pFindContext->pEnumDevInfo = NULL;
            }
        }
        */
    }
    return twRc;
}

TW_UINT16 APIENTRY FindNextImportDS(PIMPORT_DSINFO pDSInfo,PVOID Context)
{
    PFINDCONTEXT pFindContext;
    pFindContext = (PFINDCONTEXT)Context;

    if (!pDSInfo || pDSInfo->Size < sizeof(IMPORT_DSINFO) ||
        !pFindContext || FINDCONTEXT_SIGNATURE != pFindContext->Signature ||
        !pFindContext->pEnumDevInfo) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    HRESULT hr = S_OK;
    TW_UINT16 twRc = TWRC_FAILURE;
    g_twStatus.ConditionCode = TWCC_OPERATIONERROR;

    IWiaPropertyStorage *piwps = NULL;
    DWORD Count = 0;
    while (S_OK == pFindContext->pEnumDevInfo->Next(1, &piwps, &Count)) {

        PROPSPEC propSpec;
        PROPVARIANT propVar;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_DIP_DEV_ID;
        propVar.vt = VT_BSTR;
        hr = piwps->ReadMultiple(1, &propSpec, &propVar);
        if (SUCCEEDED(hr)) {
            DBG_TRC(("Found Device ID %ws", propVar.bstrVal));

            //
            // LPOLESTR == LPWSTR. We have to convert the device id
            // from UNICODE to ANSI
            //
            WideCharToMultiByte(CP_ACP, 0, propVar.bstrVal, -1,pDSInfo->DeviceName,
                                sizeof(pDSInfo->DeviceName) / sizeof(pDSInfo->DeviceName[0]),NULL, NULL);
            //
            // Remember this or lose memory.
            //
            SysFreeString(propVar.bstrVal);
            //
            // Get device type
            //
            pDSInfo->DeviceFlags &= ~DEVICE_FLAGS_DEVICETYPE;

            PropVariantInit(&propVar);
            propSpec.propid = WIA_DIP_DEV_TYPE;
            hr = piwps->ReadMultiple(1, &propSpec, &propVar);
            piwps->Release();
            if (SUCCEEDED(hr)) {

                switch (GET_STIDEVICE_TYPE(propVar.ulVal)) {
                case StiDeviceTypeDigitalCamera:
                    pDSInfo->DeviceFlags |= DEVICETYPE_DIGITALCAMERA;
                    break;
                case StiDeviceTypeScanner:
                    pDSInfo->DeviceFlags |= DEVICETYPE_SCANNER;
                    break;
                case StiDeviceTypeStreamingVideo:
                    pDSInfo->DeviceFlags |= DEVICETYPE_STREAMINGVIDEO;
                    break;
                default:
                    pDSInfo->DeviceFlags |= DEVICETYPE_UNKNOWN;
                }

                //
                // All our data sources share the same load/unload function
                //
                pDSInfo->pfnLoadDS = LoadImportDS;
                pDSInfo->pfnUnloadDS = UnloadImportDS;
                return TWRC_SUCCESS;
            } else {
                DBG_TRC(("Unable to get DEV_TYPE, hr = %lx", hr));
                pDSInfo->DeviceFlags |= DEVICETYPE_UNKNOWN;
            }
        }
        //
        // Keep looking
        //
    }
    //
    // We are out of data sources.
    //
    return TWRC_ENDOFLIST;
}

TW_UINT16 APIENTRY CloseFindContext(PVOID Context)
{
    PFINDCONTEXT pFindContext;
    pFindContext = (PFINDCONTEXT)Context;
    if (!pFindContext || FINDCONTEXT_SIGNATURE != pFindContext->Signature) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    if (pFindContext->pEnumDevInfo) {
        pFindContext->pEnumDevInfo->Release();
        pFindContext->pEnumDevInfo = NULL;
    }
    delete pFindContext;
    DBG_TRC(("CloseFindContext - CoUnIntialize()"));
    ::CoUninitialize();
    return TWRC_SUCCESS;
}

TW_UINT16 APIENTRY LoadImportDS(LPCSTR DeviceName,DWORD DeviceFlags,HANDLE *phDS,
                                PFNIMPORTEDDSENTRY *pdsEntry)
{
    DBG_TRC(("LoadImportDS - CoInitialize()"));
    ::CoInitialize(NULL);
    if (!DeviceName || !phDS || !pdsEntry) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }

    *phDS = NULL;
    *pdsEntry = NULL;

    //
    // Create Data source
    //
    CWiaDataSrc *pDS;

    if (DEVICETYPE_DIGITALCAMERA == (DeviceFlags & DEVICE_FLAGS_DEVICETYPE)) {
        pDS = new CWiaCameraDS;
    } else if (DEVICETYPE_SCANNER == (DeviceFlags & DEVICE_FLAGS_DEVICETYPE)) {
        pDS = new CWiaScannerDS;
    } else if (DEVICETYPE_STREAMINGVIDEO == (DeviceFlags & DEVICE_FLAGS_DEVICETYPE)) {
        pDS = new CWiaVideoDS;
    } else {
        //
        // Unknown device type
        //
        g_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }
    TW_UINT16 twCc = TWRC_SUCCESS;

    if (pDS) {

        //
        // Initialize the data source
        //

#ifdef UNICODE
        WCHAR DeviceNameW[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, DeviceName, -1,  DeviceNameW,sizeof(DeviceNameW) / sizeof(DeviceNameW[0]));
        twCc = pDS->IWiaDataSrc(DeviceNameW);
#else
        twCc = pDS->IWiaDataSrc(DeviceName);
#endif
        if (TWCC_SUCCESS != twCc) {
            delete pDS;
            pDS = NULL;
            g_twStatus.ConditionCode = twCc;
            return TWRC_FAILURE;
        }
        *phDS = (HANDLE)pDS;
        *pdsEntry = ImportedDSEntry;
        return TWRC_SUCCESS;
    } else {
        g_twStatus.ConditionCode = TWCC_LOWMEMORY;
        return TWRC_FAILURE;
    }
}

TW_UINT16 APIENTRY UnloadImportDS(HANDLE hDS)
{
    CWiaDataSrc *pDS;

    pDS = (CWiaDataSrc *)hDS;
    if (pDS) {
        delete  pDS;
        DBG_TRC(("UnloadImportDS - CoUnInitialize()"));
        ::CoUninitialize();
        return TWRC_SUCCESS;
    }
    g_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 APIENTRY GetLoaderStatus(TW_STATUS *ptwStatus)
{
    if (!ptwStatus) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    *ptwStatus = g_twStatus;
    return TWRC_SUCCESS;
}

TW_UINT16 APIENTRY FindImportDSByDeviceName(PIMPORT_DSINFO pDSInfo,LPCSTR DeviceName)
{
    if (!pDSInfo || pDSInfo->Size < sizeof(IMPORT_DSINFO) ||
        !DeviceName) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    PVOID Context;
    TW_UINT16 twRc = TWRC_ENDOFLIST;

    if (TWRC_SUCCESS == FindFirstImportDS(pDSInfo, &Context)) {
        do {
            if (!_strcmpi(DeviceName, pDSInfo->DeviceName)) {
                twRc = TWRC_SUCCESS;
                break;
            }
        }while (TWRC_SUCCESS == FindNextImportDS(pDSInfo, Context));

        CloseFindContext(Context);
    }
    return twRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\twcompat\wiahelper.cpp ===
#include "precomp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiahelper::CWiahelper()
{
    m_pIWiaItem = NULL;
    m_pIWiaPropStg = NULL;
}

CWiahelper::~CWiahelper()
{

    // release property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release item
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }
}

HRESULT CWiahelper::SetIWiaItem(IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;

    // release old property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release old item pointer
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }

    // add ref item pointer (because we are storing it in this object)
    if(pIWiaItem){
        // get property storage interface
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(VOID**)&m_pIWiaPropStg);
        if(SUCCEEDED(hr)){
            pIWiaItem->AddRef();
            m_pIWiaItem = pIWiaItem;
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue, INT iBufferSize)
{
    HRESULT hr = S_OK;

    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {

#ifndef UNICODE
            WideCharToMultiByte(CP_ACP, 0,PropVar[0].bstrVal,-1,szPropertyValue,iBufferSize,NULL,NULL);
#else
            lstrcpyn(szPropertyValue,PropVar[0].bstrVal, (iBufferSize/sizeof(TCHAR)));
#endif
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *plPropertyValue = PropVar[0].lVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pfPropertyValue = PropVar[0].fltVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            memcpy(pguidPropertyValue,PropVar[0].puuid,sizeof(GUID));
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize)
{
    HRESULT hr = E_POINTER;
    if (m_pIWiaPropStg) {
        if (NULL != pDataSize) {
            if (NULL != ppData) {
                // initialize propspecs
                PROPSPEC          PropSpec[1];
                PROPVARIANT       PropVar[1];

                memset(PropVar, 0, sizeof(PropVar));
                PropSpec[0].ulKind = PRSPEC_PROPID;
                PropSpec[0].propid = PropertyID;

                hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
                if (SUCCEEDED(hr)) {
                    *pDataSize = PropVar[0].caub.cElems;
                    *ppData = NULL;
                    *ppData = (BYTE*)GlobalAlloc(GPTR,PropVar[0].caub.cElems);
                    if (NULL != *ppData) {
                        memcpy(*ppData,PropVar[0].caub.pElems,PropVar[0].caub.cElems);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                    PropVariantClear(PropVar);
                }
            }
        }
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pbstrPropertyValue = SysAllocString(PropVar[0].bstrVal);
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyStreamFile(TCHAR *szPropertyStreamFile)
{
#ifdef NO_STREAMSUPPORT
    HRESULT hr = E_NOTIMPL;
#else
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        HGLOBAL hMem = NULL;
        LPSTREAM pstmProp = NULL;
        LPBYTE pStreamData = NULL;
        CFile StreamFile;
        CFileException Exception;

        if (StreamFile.Open(szPropertyStreamFile,CFile::modeRead,&Exception)) {
            DWORD dwSize = 0;
            StreamFile.Read(&dwSize,sizeof(DWORD));
            if (dwSize) {
                hMem = GlobalAlloc(GMEM_MOVEABLE, dwSize);
                if (hMem) {
                    pStreamData = (LPBYTE)GlobalLock(hMem);
                    if (pStreamData != NULL) {
                        DWORD dwReadSize = 0;
                        dwReadSize = StreamFile.Read(pStreamData,dwSize);
                        GlobalUnlock(hMem);
                        if(dwSize == dwReadSize){
                            hr = CreateStreamOnHGlobal(hMem, TRUE, &pstmProp);
                            if (SUCCEEDED(hr)) {
                                hr = m_pIWiaPropStg->SetPropertyStream((GUID*) &GUID_NULL, pstmProp);
                                pstmProp->Release();
                            }
                        } else {
                            hr = E_INVALIDARG;
                        }
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                    GlobalFree(hMem);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
            StreamFile.Close();
        } else {
            AfxThrowFileException(Exception.m_cause);
        }
    } else {
        hr = E_POINTER;
    }
#endif
    return hr;
}

HRESULT CWiahelper::ReadPropertyAttributes(PROPID PropertyID, LONG *plAccessFlags, PROPVARIANT *pPropertyVariant)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        if(pPropertyVariant){
            // initialize propspecs
            PROPSPEC PropSpec[1];
            memset(pPropertyVariant, 0, sizeof(PROPVARIANT));
            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = PropertyID;
            hr = m_pIWiaPropStg->GetPropertyAttributes(1, PropSpec,(ULONG*)plAccessFlags,pPropertyVariant);
        } else {
            hr = E_INVALIDARG;
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt      = VT_BSTR;

#ifndef UNICODE
        WCHAR wszPropertyValue[MAX_PATH];
        memset(wszPropertyValue,0,sizeof(wszPropertyValue));
        MultiByteToWideChar(CP_ACP, 0,szPropertyValue,-1,wszPropertyValue,(sizeof(wszPropertyValue)/sizeof(wszPropertyValue[0])));
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(wszPropertyValue);
#else
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(szPropertyValue);
#endif

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);

        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyLong(PROPID PropertyID, LONG lPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt   = VT_I4;
        propvar[0].lVal = lPropertyValue;

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt     = VT_R4;
        propvar[0].fltVal = fPropertyValue;

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt     = VT_CLSID;
        propvar[0].puuid  = &guidPropertyValue;

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt      = VT_BSTR;

        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(bstrPropertyValue);

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);

        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyStreamFile(TCHAR *szPropertyStreamFile)
{
#ifdef NO_STREAMSUPPORT
    HRESULT hr = E_NOTIMPL;
#else
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        IStream *pIStrm  = NULL;
        CFile StreamFile;
        CFileException Exception;
        GUID guidCompatId = GUID_NULL;

        hr = m_pIWiaPropStg->GetPropertyStream(&guidCompatId, &pIStrm);
        if (S_OK == hr) {
            if (StreamFile.Open(szPropertyStreamFile,CFile::modeCreate|CFile::modeWrite,&Exception)) {
                ULARGE_INTEGER uliSize  = {0,0};
                LARGE_INTEGER  liOrigin = {0,0};
                pIStrm->Seek(liOrigin, STREAM_SEEK_END, &uliSize);
                DWORD dwSize = uliSize.u.LowPart;
                if (dwSize) {
                    StreamFile.Write(&dwSize, sizeof(DWORD));
                    PBYTE pBuf = (PBYTE) LocalAlloc(LPTR, dwSize);
                    if (pBuf) {
                        pIStrm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
                        ULONG ulRead = 0;
                        pIStrm->Read(pBuf, dwSize, &ulRead);
                        StreamFile.Write(pBuf, ulRead);
                        LocalFree(pBuf);
                    }
                }
                StreamFile.Close();
            } else {
                AfxThrowFileException(Exception.m_cause);
            }
            pIStrm->Release();
        }
    } else {
        hr = E_POINTER;
    }
#endif
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\cwiavideo.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       CWiaVideo.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: COM wrapper for CPreviewGraph class
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

///////////////////////////////
// CWiaVideo Constructor
//
CWiaVideo::CWiaVideo() :
    m_bInited(FALSE)
{
    DBG_FN("CWiaVideo::CWiaVideo");

    HRESULT hr = S_OK;

    hr = CAccessLock::Init(&m_csLock);

    if (hr == S_OK)
    {
        m_bInited = TRUE;
    }

    hr = m_PreviewGraph.Init(this);

    CHECK_S_OK2(hr, ("CWiaVideo::CWiaVideo, error trying to initialize "
                     "preview Graph, this should never happen"));

    ASSERT(hr == S_OK);
}

///////////////////////////////
// CWiaVideo Destructor
//
CWiaVideo::~CWiaVideo()
{
    DBG_FN("CWiaVideo::~CWiaVideo");

    m_PreviewGraph.Term();

    if (m_bInited)
    {
        CAccessLock::Term(&m_csLock);
    }
}


///////////////////////////////
// get_PreviewVisible
//
STDMETHODIMP CWiaVideo::get_PreviewVisible(BOOL *pbPreviewVisible)
{
    DBG_FN("CWiaVideo::get_PreviewVisible");

    ASSERT(pbPreviewVisible != NULL);

    HRESULT hr = S_OK;

    if (pbPreviewVisible == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::get_PreviewVisible received NULL "
                         "parameter"));
                         
    }

    if (hr == S_OK)
    {
        *pbPreviewVisible = m_PreviewGraph.IsPreviewVisible();
    }

    return hr;
}

///////////////////////////////
// put_PreviewVisible
//
STDMETHODIMP CWiaVideo::put_PreviewVisible(BOOL bPreviewVisible)
{
    DBG_FN("CWiaVideo::put_PreviewVisible");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.ShowVideo(bPreviewVisible);
    }

    return hr;
}

///////////////////////////////
// get_ImagesDirectory
//
STDMETHODIMP CWiaVideo::get_ImagesDirectory(BSTR *pbstrImageDirectory)
{
    DBG_FN("CWiaVideo::get_ImagesDirectory");

    ASSERT(pbstrImageDirectory != NULL);

    HRESULT       hr = S_OK;
    CSimpleString strImagesDir;

    if (pbstrImageDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::get_ImagesDirectory, received a NULL "
                         "param"));
    }

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.GetImagesDirectory(&strImagesDir);
        CHECK_S_OK2(hr, ("CWiaVideo::get_ImagesDirectory, failed to get "
                         "images directory"));
    }

    if (hr == S_OK)
    {
        *pbstrImageDirectory = 
               SysAllocString(CSimpleStringConvert::WideString(strImagesDir));
    }

    return hr;
}

///////////////////////////////
// put_ImagesDirectory
//
STDMETHODIMP CWiaVideo::put_ImagesDirectory(BSTR bstrImageDirectory)
{
    DBG_FN("CWiaVideo::put_ImagesDirectory");

    ASSERT(bstrImageDirectory != NULL);

    HRESULT             hr = S_OK;
    CSimpleStringWide   strImagesDir;

    if (bstrImageDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::put_ImagesDirectory received a "
                         "NULL param"));
    }

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        strImagesDir = bstrImageDirectory;

        hr = m_PreviewGraph.SetImagesDirectory(
                    &(CSimpleStringConvert::NaturalString(strImagesDir)));

        CHECK_S_OK2(hr, ("CWiaVideo::put_ImagesDirectory, failed to set "
                         "images directory"));
    }

    return hr;
}

///////////////////////////////
// CreateVideoByWiaDevID
//
STDMETHODIMP CWiaVideo::CreateVideoByWiaDevID(BSTR       bstrWiaID,
                                              HWND       hwndParent,
                                              BOOL       bStretchToFitParent,
                                              BOOL       bAutoBeginPlayback)
{
    DBG_FN("CWiaVideo::CreateVideoByWiaDevID");

    ASSERT(bstrWiaID != NULL);

    HRESULT             hr = S_OK;
    CComPtr<IMoniker>   pCaptureDeviceMoniker;
    CSimpleString       strWiaID;

    CAccessLock Lock(&m_csLock);

    if (bstrWiaID == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID received NULL "
                         "parameter"));

        return hr;
    }
    else if (m_PreviewGraph.GetState() != WIAVIDEO_NO_VIDEO)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID attempting "
                         "to create video when previous video hasn't "
                         "been destroyed yet"));

        return hr;
    }

    //
    // Initialize our WiaLink.  This enables use to respond to TAKE_PICTURE 
    // commands sent to the WiaDriver.
    //

    if (hr == S_OK)
    {
        strWiaID = CSimpleStringConvert::NaturalString(
                                            CSimpleStringWide(bstrWiaID));

        hr = m_WiaLink.Init(&strWiaID, this);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID failed to link to "
                         "WIA to respond to the video driver TAKE_PICTURE "
                         "command "));
    }

    // 
    // Get the Directshow Capture Filter Moniker associated with this 
    // WIA Imaging device.
    //
    if (hr == S_OK)
    {
        hr = CDShowUtil::FindDeviceByWiaID(&m_WiaLink,
                                           &strWiaID,
                                           NULL, 
                                           NULL,
                                           NULL,
                                           &pCaptureDeviceMoniker);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID, failed to find "
                         "the DShow device specified by Wia ID '%ls'", 
                         strWiaID.String()));
    }

    //
    // Create the Video Preview
    //
    if (hr == S_OK)
    {
        hr = m_PreviewGraph.CreateVideo(strWiaID,
                                        pCaptureDeviceMoniker, 
                                        hwndParent, 
                                        bStretchToFitParent, 
                                        bAutoBeginPlayback);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID, failed to "
                         "CreateVideo"));
    }

    if (hr == S_OK)
    {
        hr = m_WiaLink.StartMonitoring();
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaID, failed to "
                         "start monitoring WIA TAKE_PICTURE requests"));
    }

    if (hr != S_OK)
    {
        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// CreateVideoByDevNum
//
STDMETHODIMP CWiaVideo::CreateVideoByDevNum(UINT       uiDeviceNumber,
                                            HWND       hwndParent,
                                            BOOL       bStretchToFitParent,
                                            BOOL       bAutoBeginPlayback)
{
    DBG_FN("CWiaVideo::CreateVideoByDevNum");

    HRESULT             hr = S_OK;
    CComPtr<IMoniker>   pCaptureDeviceMoniker;
    CSimpleString       strDShowDeviceID;

    //
    // Since we are creating video via the DShow enumeration position,
    // we will NOT establish a WIA link.
    //

    //
    // Find the Directshow Capture Filter moniker associated with this
    // enumeration position.
    //

    CAccessLock Lock(&m_csLock);

    if (m_PreviewGraph.GetState() != WIAVIDEO_NO_VIDEO)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevNum attempting "
                         "to create video when previous video hasn't "
                         "been destroyed yet"));
        return hr;
    }


    if (hr == S_OK)
    {
        hr = CDShowUtil::FindDeviceByEnumPos(uiDeviceNumber,
                                             &strDShowDeviceID,
                                             NULL,
                                             &pCaptureDeviceMoniker);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByDevNum, failed to find "
                         "DShow device # '%d'", uiDeviceNumber));
    }

    //
    // Create the Video
    //
    if (hr == S_OK)
    {
        hr = m_PreviewGraph.CreateVideo(NULL,
                                        pCaptureDeviceMoniker, 
                                        hwndParent, 
                                        bStretchToFitParent, 
                                        bAutoBeginPlayback);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByDevNum, failed to Create "
                         "Video for DShow device # '%d'", uiDeviceNumber));
    }

    if (hr != S_OK)
    {
        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// CreateVideoByName
//
STDMETHODIMP CWiaVideo::CreateVideoByName(BSTR       bstrFriendlyName,
                                          HWND       hwndParent,
                                          BOOL       bStretchToFitParent,
                                          BOOL       bAutoBeginPlayback)
{
    DBG_FN("CWiaVideo::CreateVideoByName");

    ASSERT(bstrFriendlyName != NULL);

    HRESULT             hr = S_OK;
    CComPtr<IMoniker>   pCaptureDeviceMoniker;
    CSimpleString       strFriendlyName;
    CSimpleString       strDShowDeviceID;

    CAccessLock Lock(&m_csLock);

    if (bstrFriendlyName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName received NULL "
                         "parameter"));
    }
    else if (m_PreviewGraph.GetState() != WIAVIDEO_NO_VIDEO)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName attempting "
                         "to create video when previous video hasn't "
                         "been destroyed yet"));

        return hr;
    }

    if (hr == S_OK)
    {
        strFriendlyName = CSimpleStringConvert::NaturalString(
                                    CSimpleStringWide(bstrFriendlyName));

        hr = CDShowUtil::FindDeviceByFriendlyName(&strFriendlyName,
                                                  NULL,
                                                  &strDShowDeviceID,
                                                  &pCaptureDeviceMoniker);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName failed to find DShow "
                         "device identified by friendly name '%ls'", 
                         strFriendlyName.String()));
    }

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.CreateVideo(NULL,
                                        pCaptureDeviceMoniker, 
                                        hwndParent, 
                                        bStretchToFitParent, 
                                        bAutoBeginPlayback);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName failed to create "
                         "video for DShow device identified by friendly "
                         "name '%ls'", strFriendlyName.String()));
    }

    if (hr != S_OK)
    {
        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// DestroyVideo
//
STDMETHODIMP CWiaVideo::DestroyVideo()
{
    DBG_FN("CWiaVideo::DestroyVideo");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        if (m_WiaLink.IsEnabled())
        {
            m_WiaLink.StopMonitoring();
            m_WiaLink.Term();
        }
    }

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.DestroyVideo();

        CHECK_S_OK2(hr, ("CWiaVideo::DestroyVideo failed to destroy video"));
    }

    return hr;
}

///////////////////////////////
// Play
//
STDMETHODIMP CWiaVideo::Play()
{
    DBG_FN("CWiaVideo::Play");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.Play();

        CHECK_S_OK2(hr, ("CWiaVideo::Play failed"));
    }

    return hr;
}

///////////////////////////////
// Pause
//
STDMETHODIMP CWiaVideo::Pause()
{
    DBG_FN("CWiaVideo::Pause");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.Pause();

        CHECK_S_OK2(hr, ("CWiaVideo::Pause failed"));
    }

    return hr;
}

///////////////////////////////
// GetCurrentState
//
STDMETHODIMP CWiaVideo::GetCurrentState(WIAVIDEO_STATE  *pCurrentState)
{
    DBG_FN("CWiaVideo::GetCurrentState");

    ASSERT(pCurrentState != NULL);

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (pCurrentState == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::GetCurrentState received NULL param"));
    }

    if (hr == S_OK)
    {
        *pCurrentState = m_PreviewGraph.GetState();
    }

    return hr;
}

///////////////////////////////
// TakePicture
//
STDMETHODIMP CWiaVideo::TakePicture(BSTR *pbstrNewImageFileName)
{
    DBG_FN("CWiaVideo::TakePicture");

    HRESULT         hr = S_OK;
    CSimpleString   strNewImageFileName;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.TakePicture(&strNewImageFileName);

        CHECK_S_OK2(hr, ("CWiaVideo::TakePicture failed"));
    }

    if (hr == S_OK)
    {
        *pbstrNewImageFileName =::SysAllocString(
                                            (CSimpleStringConvert::WideString(
                                             strNewImageFileName)).String());

        if (*pbstrNewImageFileName)
        {
            DBG_TRC(("CWiaVideo::TakePicture, new image file name is '%ls'",
                     *pbstrNewImageFileName));
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CWiaVideo::TakePicture, SysAllocString "
                             "returned NULL BSTR"));
        }
    }

    return hr;
}

///////////////////////////////
// ResizeVideo
//
STDMETHODIMP CWiaVideo::ResizeVideo(BOOL bStretchToFitParent)
{
    DBG_FN("CWiaVideo::ResizeVideo");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.ResizeVideo(bStretchToFitParent);

        CHECK_S_OK2(hr, ("CWiaVideo::ResizeVideo failed"));
    }

    return hr;
}

///////////////////////////////
// ProcessAsyncImage
//
// Called by CPreviewGraph
// when user presses hardware
// button and it is delivered to
// Still Pin.
//
HRESULT CWiaVideo::ProcessAsyncImage(const CSimpleString *pNewImage)
{
    DBG_FN("CWiaVideo::ProcessAsyncImage");

    HRESULT hr = S_OK;

    hr = m_WiaLink.SignalNewImage(pNewImage);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\cwiavideo.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CWiaVideo.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Implements preview graph for capture still images
 *
 *****************************************************************************/

#ifndef _CWIAVIDEO_H_
#define _CWIAVIDEO_H_

#include "prvgrph.h"
#include "resource.h"       // main symbols

class CWiaVideo : 
    public IWiaVideo,
    public CComObjectRoot,
    public CComCoClass<CWiaVideo,&CLSID_WiaVideo>
{
public:
    
BEGIN_COM_MAP(CWiaVideo)
    COM_INTERFACE_ENTRY(IWiaVideo)
END_COM_MAP()


//DECLARE_NOT_AGGREGATABLE(CWiaVideo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_WiaVideo)

    CWiaVideo();
    virtual ~CWiaVideo();

    //
    // IWiaVideo Properties and Methods.

    //
    // Properties
    //
    STDMETHOD(get_PreviewVisible)(BOOL *pPreviewVisible);
    STDMETHOD(put_PreviewVisible)(BOOL bPreviewVisible);

    STDMETHOD(get_ImagesDirectory)(BSTR *pbstrImageDirectory);
    STDMETHOD(put_ImagesDirectory)(BSTR bstrImageDirectory);

    // 
    // Methods
    //

    STDMETHOD(CreateVideoByWiaDevID)(BSTR       bstrWiaDeviceID,
                                     HWND       hwndParent,
                                     BOOL       bStretchToFitParent,
                                     BOOL       bAutoBeginPlayback);

    STDMETHOD(CreateVideoByDevNum)(UINT       uiDeviceNumber,
                                   HWND       hwndParent,
                                   BOOL       bStretchToFitParent,
                                   BOOL       bAutoBeginPlayback);

    STDMETHOD(CreateVideoByName)(BSTR       bstrFriendlyName,
                                 HWND       hwndParent,
                                 BOOL       bStretchToFitParent,
                                 BOOL       bAutoBeginPlayback);

    STDMETHOD(DestroyVideo)();

    STDMETHOD(Play)();

    STDMETHOD(Pause)();

    STDMETHOD(TakePicture)(BSTR *pbstrNewImageFilename);

    STDMETHOD(ResizeVideo)(BOOL bStretchToFitParent);

    STDMETHOD(GetCurrentState)(WIAVIDEO_STATE *pbCurrentState);

    //
    // Misc Functions
    //

    ///////////////////////////////
    // ProcessAsyncImage
    //
    // Called by CPreviewGraph
    // when user presses hardware
    // button and it is delivered to
    // Still Pin.
    //
    HRESULT ProcessAsyncImage(const CSimpleString *pNewImage);

private:

    //
    // Preview Graph object that does all video related activities.
    //
    CPreviewGraph       m_PreviewGraph;

    //
    // WiaLink object that handles all the WIA related activities 
    // enabling this object to communicate with WIA
    //
    CWiaLink            m_WiaLink;

    CRITICAL_SECTION    m_csLock;
    BOOL                m_bInited;
};

#endif // _CWIAVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\dshowutl.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       DShowUtl.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Provides support functions for preview graph class
 *
 *****************************************************************************/
 
#include <precomp.h>
#include <atlconv.h>
#pragma hdrstop

///////////////////////////////
// Constants
//
const UINT FIND_FLAG_BY_ENUM_POS      = 1;
const UINT FIND_FLAG_BY_DSHOW_ID      = 2;
const UINT FIND_FLAG_BY_FRIENDLY_NAME = 3;

//
// These are values found in the registry, specified in the 
// DeviceData section of the vendor's INF file.
//
const TCHAR* REG_VAL_PREFERRED_MEDIASUBTYPE    = _T("PreferredMediaSubType");
const TCHAR* REG_VAL_PREFERRED_VIDEO_WIDTH     = _T("PreferredVideoWidth");
const TCHAR* REG_VAL_PREFERRED_VIDEO_HEIGHT    = _T("PreferredVideoHeight");
const TCHAR* REG_VAL_PREFERRED_VIDEO_FRAMERATE = _T("PreferredVideoFrameRate");

///////////////////////////////
// SizeVideoToWindow
//
// Static Fn
//
HRESULT CDShowUtil::SizeVideoToWindow(HWND                hwnd,
                                      IVideoWindow        *pVideoWindow,
                                      BOOL                bStretchToFit)
{
    DBG_FN("CDShowUtil::SizeVideoToWindow");

    ASSERT(hwnd         != NULL);
    ASSERT(pVideoWindow != NULL);

    RECT    rc = {0};
    HRESULT hr = S_OK;

    //
    // Check for invalid args
    //

    if ((hwnd         == NULL) || 
        (pVideoWindow == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SizeVideoToWindow received NULL pointer"));
        return hr;
    }

    //
    // Try to position preview window as best we
    // can in the context of the containing window
    //

    ::GetClientRect(hwnd, &rc);

    //
    // First, get ideal sizes (that won't incur scaling penalty)
    //

    LONG maxWidth     = 0;
    LONG maxHeight    = 0;
    LONG minWidth     = 0;
    LONG minHeight    = 0;
    LONG nativeWidth  = 0;
    LONG nativeHeight = 0;

    LONG w         = rc.right - rc.left;
    LONG h         = rc.bottom - rc.top;
    BOOL bDone     = FALSE;

    //
    // ***NOTE***
    //
    // Little known fact (i.e. not in MSDN)
    // 'GetMaxIdealSize' and 'GetMinIdealSize' will FAIL if the graph is 
    // in the stopped state.  Therefore, the graph must be in the paused
    // or in the playing state.
    //

    hr = pVideoWindow->GetMaxIdealImageSize(&maxWidth, &maxHeight);

    if (FAILED(hr))
    {
        maxWidth  = w;
        maxHeight = h;

        DBG_WRN(("pVideoWindow->GetMaxIdealImageSize failed.  "
                 "This is a non-fatal error, setting our max video "
                 "width '%lu' and height '%lu' to the window's "
                 "boundaries", maxWidth, maxHeight));
    }

    hr = pVideoWindow->GetMinIdealImageSize(&minWidth, &minHeight);

    if (FAILED(hr))
    {
        minWidth  = w;
        minHeight = h;

        DBG_WRN(("pVideoWindow->GetMinIdealImageSize failed.  "
                 "This is a non-fatal error, setting our minimum video "
                 "width '%lu' and height '%lu' to the window's "
                 "boundaries", maxWidth, maxHeight));
    }

    //
    // Now, get nominal size of preview
    //
    if (pVideoWindow)
    {
        CComPtr<IBasicVideo> pBasicVideo;

        hr = pVideoWindow->QueryInterface(IID_IBasicVideo, 
                                reinterpret_cast<void **>(&pBasicVideo));

        CHECK_S_OK2(hr, ("pVideoWindow->QueryInterface for IBasicVideo failed"));

        if (SUCCEEDED(hr) && pBasicVideo)
        {
            hr = pBasicVideo->GetVideoSize( &nativeWidth, &nativeHeight );

            CHECK_S_OK2(hr, ("pBasicVideo->GetVideoSize() failed" ));

            if (FAILED(hr))
            {
                nativeWidth = nativeHeight = 0;
            }
        }
    }


    if (bStretchToFit)
    {
        nativeWidth  = w;
        nativeHeight = h;
    }

    //
    // Try native size first
    //
    if (nativeWidth && nativeHeight)
    {
        if ((nativeWidth <= w) && (nativeHeight <= h))
        {
            hr = pVideoWindow->SetWindowPosition((w - nativeWidth)  / 2,
                                                 (h - nativeHeight) / 2,
                                                 nativeWidth,
                                                 nativeHeight);

            CHECK_S_OK2( hr, ("pVideoWindow->SetWindowPosition( "
                              "native size )"));
            bDone = TRUE;
        }
    }

    //
    // Don't scale outside of min/max range so we don't incur performance hit,
    // also, as we scale, keep the aspect ratio of the native size
    //
    if (!bDone)
    {
        INT x  = 0;
        INT y  = 0;
        INT _h = h;
        INT _w = w;

        //
        // cap (in both directions) for no loss of performance...
        //

        if ((_w > maxWidth) && (maxWidth <= w))
        {
            _w = maxWidth;
        }
        else if ((_w < minWidth) && (minWidth <= w))
        {
            _w = minWidth;
        }

        if ((_h > maxHeight) && (maxHeight <= h))
        {
            _h = maxHeight;
        }
        else if ((_h < minHeight) && (minHeight <= h))
        {
            _h = minHeight;
        }

        //
        // Notice that if the client window size is 0,0 then
        // the video will be set to that size.  We will warn the
        // caller below in a warning statement, but if they want
        // to do that I'm not going to stop them.
        //

        //
        // Find the smallest axis
        //
        if (h < w)
        {
            //
            // Space is wider than tall
            //
            if (nativeHeight)
            {
                _w = ((_h * nativeWidth) / nativeHeight);
            }
        }
        else
        {
            //
            // Space is taller than wide
            //
            if (nativeWidth)
            {
                _h = ((nativeHeight * _w) / nativeWidth);
            }
        }

        x = ((w - _w) / 2);
        y = ((h - _h) / 2);

        if ((_w == 0) || (_h == 0))
        {
            DBG_WRN(("WARNING:  CDShowUtils::SizeVideoToWindow "
                     "video width and/or height is 0.  This will "
                     "result in video that is not visible.  This is "
                     "because the owning window dimensions are probably 0. "
                     "Video -> Width:'%lu', Height:'%lu', Window -> "
                     "Top:'%lu', Bottom:'%lu', Left:'%lu', Right:'%lu'",
                     _w, _h, rc.top, rc.bottom, rc.left, rc.right));
        }

        hr = pVideoWindow->SetWindowPosition( x, y, _w, _h );

        CHECK_S_OK2(hr, ("pVideoWindow->SetWindowPosition to set the "
                         "aspect scaled size failed"));
    }

    return hr;
}


///////////////////////////////
// ShowVideo
//
// Static Fn
//
HRESULT CDShowUtil::ShowVideo(BOOL                bShow,
                              IVideoWindow        *pVideoWindow)
{
    DBG_FN("CDShowUtil::ShowVideo");

    HRESULT hr = S_OK;

    if (pVideoWindow == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::ShowVideo failed to show video "
                         "successfully"));
    }

    if (hr == S_OK)
    {
        if (bShow)
        {
            //
            // We were told to show the preview window therefore we will show 
            // it.
            //
            hr = pVideoWindow->put_Visible(OATRUE);
            CHECK_S_OK2(hr, ("pVideoWindow->put_Visible(OATRUE)"));

            hr = pVideoWindow->put_AutoShow(OATRUE);
            CHECK_S_OK2(hr, ("pVideoWindow->put_AutoShow(OATRUE)"));
        }
        else
        {
            //
            // We were told to hide the preview window.  
            //
    
            pVideoWindow->put_Visible(OAFALSE);
            pVideoWindow->put_AutoShow(OAFALSE);
        }
    }

    return hr;
}


///////////////////////////////
// SetVideoWindowParent
//
// Static Fn
//
HRESULT CDShowUtil::SetVideoWindowParent(HWND         hwndParent,
                                         IVideoWindow *pVideoWindow,
                                         LONG         *plOldWindowStyle)
{
    DBG_FN("CDShowUtil::SetVideoRendererParent");

    HRESULT hr = S_OK;

    if (pVideoWindow == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SetVideoWindowParent received NULL "
                         "Param"));
    }
    else if (hwndParent && !IsWindow(hwndParent))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CDShowUtil::SetVideoWindowParent received invalid "
                         "hwnd = 0x%08x", hwndParent));
    }

    if (hr == S_OK)
    {
        if (!hwndParent)
        {
            //
            // Okay, we are setting the preview window to NULL, which
            // means we are disassociating it from its parent.  
            //
            //
            // Reseting graph preview window
            //

            hr = pVideoWindow->put_Owner(NULL);
            CHECK_S_OK2(hr, ("pVideoWindow->put_Owner(NULL)"));

            if ((plOldWindowStyle) && (*plOldWindowStyle))
            {
                hr = pVideoWindow->put_WindowStyle(*plOldWindowStyle);

                CHECK_S_OK2(hr, ("pVideoWindow->put_WindowStyle"
                                 "(*plOldWindowStyle)"));
            }
        }
        else
        {
            LONG WinStyle;
            HRESULT hr2;

            //
            // Okay, we are giving the preview window a new parent
            //

            // Set the owning window
            //

            hr = pVideoWindow->put_Owner(PtrToUlong(hwndParent));
            CHECK_S_OK2(hr, ("pVideoWindow->putOwner( hwndParent )"));

            //
            // Set the style for the preview
            //

            //
            // First, store the window style so that we can restore it
            // when we disassociate the parent from the window
            //
            hr2 = pVideoWindow->get_WindowStyle(&WinStyle);
            CHECK_S_OK2(hr2, ("pVideoWindow->get_WindowStyle"
                              "( pOldWindowStyle )"));

            //
            // Set the Video Renderer window so that it will be a child of 
            // the parent window, i.e. it does not have a border etc.
            //

            if (plOldWindowStyle)
            {
                *plOldWindowStyle = WinStyle;
            }

            WinStyle &= ~WS_OVERLAPPEDWINDOW;
            WinStyle &= ~WS_CLIPCHILDREN;
            WinStyle |= WS_CHILD;

            hr2 = pVideoWindow->put_WindowStyle(WinStyle);
            CHECK_S_OK2(hr2, ("pVideoWindow->put_WindowStyle( WinStyle )"));
        }
    }

    return hr;
}


///////////////////////////////
// GetDeviceProperty
//
// Static Fn
//
HRESULT CDShowUtil::GetDeviceProperty(IPropertyBag         *pPropertyBag,
                                      LPCWSTR              pwszProperty,
                                      CSimpleString        *pstrProperty)
{
    DBG_FN("CDShowUtil::GetDeviceProperty");

    HRESULT hr = S_OK;

    ASSERT(pPropertyBag != NULL);
    ASSERT(pwszProperty != NULL);
    ASSERT(pstrProperty != NULL);

    VARIANT VarName;

    if ((pPropertyBag == NULL) || 
        (pwszProperty == NULL) ||
        (pstrProperty == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetDeviceProperty received a NULL "
                         "param"));
    }
    
    if (SUCCEEDED(hr))
    {
        VariantInit(&VarName);
        VarName.vt = VT_BSTR;
        hr = pPropertyBag->Read(pwszProperty, &VarName, 0);
    }

    if (SUCCEEDED(hr))
    {
        *pstrProperty = CSimpleStringConvert::NaturalString(
                                          CSimpleStringWide(VarName.bstrVal));
        VariantClear(&VarName);
    }

    return hr;
}

///////////////////////////////
// GetMonikerProperty
//
// Static Fn
//
HRESULT CDShowUtil::GetMonikerProperty(IMoniker             *pMoniker,
                                       LPCWSTR              pwszProperty,
                                       CSimpleString        *pstrProperty)
{
    DBG_FN("CDShowUtil::GetMonikerProperty");

    HRESULT                 hr      = S_OK;
    VARIANT                 VarName;
    CComPtr<IPropertyBag>   pPropertyBag;

    ASSERT(pMoniker     != NULL);
    ASSERT(pwszProperty != NULL);
    ASSERT(pstrProperty != NULL);

    if ((pMoniker     == NULL) || 
        (pwszProperty == NULL) ||
        (pstrProperty == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetMonikerProperty received a "
                         "NULL param"));
    }

    hr = pMoniker->BindToStorage(0, 
                                 0,
                                 IID_IPropertyBag,
                                 (void **)&pPropertyBag);

    CHECK_S_OK2(hr, ("CDShowUtil::GetMonikerProperty, BindToStorage failed"));

    if (hr == S_OK)
    {
        hr = GetDeviceProperty(pPropertyBag, 
                               pwszProperty,
                               pstrProperty);

        CHECK_S_OK2(hr, ("CDShowUtil::GetMonikerProperty, failed "
                         "to get device property '%ls'", pwszProperty));
    }
    
    return hr;
}


///////////////////////////////
// FindDeviceGeneric
//
// Given the device ID, we will
// find all the remaining parameters.
// If a parameter is NULL, that information
// is not looked up.
//
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceGeneric(UINT           uiFindFlag,
                                      CSimpleString  *pstrDShowDeviceID,
                                      LONG           *plEnumPos,
                                      CSimpleString  *pstrFriendlyName,
                                      IMoniker       **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceGeneric");

    HRESULT                 hr      = S_OK;
    BOOL                    bFound  = FALSE;
    LONG                    lPosNum = 0;
    CComPtr<ICreateDevEnum> pCreateDevEnum;
    CComPtr<IEnumMoniker>   pEnumMoniker;

    if ((uiFindFlag == FIND_FLAG_BY_ENUM_POS) && (plEnumPos == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShow::FindDeviceGeneric requesting search by enum "
                         "pos, but plEnumPos is NULL"));
    }
    else if ((uiFindFlag        == FIND_FLAG_BY_DSHOW_ID) && 
             (pstrDShowDeviceID == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShow::FindDeviceGeneric requesting search by "
                         "DShow ID, but pstrDShowDeviceID is NULL"));
    }
    else if ((uiFindFlag       == FIND_FLAG_BY_FRIENDLY_NAME) && 
             (pstrFriendlyName == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShow::FindDeviceGeneric requesting search by "
                         "friendly name, but pstrFriendlyName is NULL"));
    }

    if (hr == S_OK)
    {
    
        // 
        // Create the device enumerator
        //
        hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum,
                              (void**)&pCreateDevEnum);
    
        CHECK_S_OK2(hr, ("CDShowUtil::CreateCaptureFilter failed to create "
                         "CLSID_SystemDeviceEnum enumerator"));
    }

    if (hr == S_OK)
    {
        hr = pCreateDevEnum->CreateClassEnumerator(
                                            CLSID_VideoInputDeviceCategory,
                                            &pEnumMoniker,
                                            0);

        CHECK_S_OK2(hr, ("CDShowUtil::CreateCaptureFilter failed to "
                         "create enumerator for Video Input Device "
                         "Category"));
    }

    //
    // Loop through all the devices
    //

    while ((!bFound) && (hr == S_OK))
    {
        CComPtr<IMoniker>       pMoniker;
        CComPtr<IPropertyBag>   pPropertyBag;
        CSimpleString           strDShowDeviceID(TEXT(""));
        CSimpleString           strFriendlyName(TEXT(""));

        hr = pEnumMoniker->Next(1, &pMoniker, NULL);

        if (hr == S_OK)
        {
            //
            // Get property storage for this DS device so we can get it's
            // device id...
            //
    
            hr = pMoniker->BindToStorage(0, 
                                         0,
                                         IID_IPropertyBag,
                                         (void **)&pPropertyBag);

            CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceGeneric, failed to "
                             "bind to storage"));
        }

        if (hr == S_OK)
        {
            hr = GetDeviceProperty(pPropertyBag, 
                                   L"DevicePath", 
                                   &strDShowDeviceID);

            CHECK_S_OK2(hr, ("Failed to get DevicePath for DShow # '%lu", 
                             lPosNum));

            hr = GetDeviceProperty(pPropertyBag, 
                                   L"FriendlyName",
                                   &strFriendlyName);

            CHECK_S_OK2(hr, ("Failed to get FriendlyName for DShow # '%lu", 
                             lPosNum));
        }


        //
        // This is the search criteria.
        //
        switch (uiFindFlag)
        {
            case FIND_FLAG_BY_ENUM_POS:

                if (lPosNum == *plEnumPos)
                {
                    bFound = TRUE;
                }

            break;

            case FIND_FLAG_BY_DSHOW_ID:

                if (pstrDShowDeviceID->CompareNoCase(strDShowDeviceID) == 0)
                {
                    bFound = TRUE;
                }

            break;

            case FIND_FLAG_BY_FRIENDLY_NAME:

                if (pstrFriendlyName->CompareNoCase(strFriendlyName) == 0)
                {
                    bFound = TRUE;
                }

            break;

            default:
                hr = E_FAIL;
            break;
        }

        if (bFound)
        {
            if (pstrDShowDeviceID)
            {
                pstrDShowDeviceID->Assign(strDShowDeviceID);
            }

            if (pstrFriendlyName)
            {
                pstrFriendlyName->Assign(strFriendlyName);
            }

            if (plEnumPos)
            {
                *plEnumPos = lPosNum;
            }

            if (ppDeviceMoniker)
            {
                *ppDeviceMoniker = pMoniker;
                (*ppDeviceMoniker)->AddRef();
            }
        }
        else
        {
            ++lPosNum;
        }
    }

    if (!bFound)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}


///////////////////////////////
// FindDeviceByEnumPos
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceByEnumPos(LONG          lEnumPos,
                                        CSimpleString *pstrDShowDeviceID,
                                        CSimpleString *pstrFriendlyName,
                                        IMoniker      **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceByEnumPos");

    HRESULT hr = S_OK;

    if (hr == S_OK)
    {
        hr = FindDeviceGeneric(FIND_FLAG_BY_ENUM_POS, 
                               pstrDShowDeviceID,
                               &lEnumPos,
                               pstrFriendlyName,
                               ppDeviceMoniker);
    }

    CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByEnumPos failed to find a "
                     "Directshow device with an enum position "
                     "of '%lu'", lEnumPos));

    return hr;
}

///////////////////////////////
// FindDeviceByFriendlyName
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceByFriendlyName(
                                    const CSimpleString  *pstrFriendlyName,
                                    LONG                 *plEnumPos,
                                    CSimpleString        *pstrDShowDeviceID,
                                    IMoniker             **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceByFriendlyName");

    HRESULT hr = S_OK;

    ASSERT(pstrFriendlyName != NULL);

    if (pstrFriendlyName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByFriendlyName received a "
                         "NULL param"));

        return hr;
    }


    if (hr == S_OK)
    {
        hr = FindDeviceGeneric(FIND_FLAG_BY_FRIENDLY_NAME, 
                               pstrDShowDeviceID,
                               plEnumPos,
                               const_cast<CSimpleString*>(pstrFriendlyName),
                               ppDeviceMoniker);
    }

    CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByFriendlyName failed to find a "
                     "Directshow device named '%ls'", 
                     pstrFriendlyName->String()));

    return hr;
}

///////////////////////////////
// FindDeviceByWiaID
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceByWiaID(CWiaLink             *pWiaLink,
                                      const CSimpleString  *pstrWiaDeviceID,
                                      CSimpleString        *pstrFriendlyName,
                                      LONG                 *plEnumPos,
                                      CSimpleString        *pstrDShowDeviceID,
                                      IMoniker             **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceByWiaID");

    HRESULT                        hr = S_OK;
    CSimpleStringWide              strDShowID(TEXT(""));
    CComPtr<IWiaPropertyStorage>   pPropStorage;

    ASSERT(pWiaLink        != NULL);
    ASSERT(pstrWiaDeviceID != NULL);

    if ((pWiaLink == NULL) || 
        (pstrWiaDeviceID == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByWiaID received a NULL "
                         "param"));

        return hr;
    }

    if (hr == S_OK)
    {
        hr = pWiaLink->GetDeviceStorage(&pPropStorage);
    }

    if (hr == S_OK)
    {
        hr = CWiaUtil::GetProperty(pPropStorage, 
                                   WIA_DPV_DSHOW_DEVICE_PATH,
                                   &strDShowID);
    }

    if (hr == S_OK)
    {
        //
        // If all three of these are NULL, then there is no point searching, 
        // we already have the DShow device ID.  On the other hand, if we 
        // want at least one of them, then we need to find the device.
        //
        if ((pstrFriendlyName  != NULL) ||
            (plEnumPos         != NULL) ||
            (ppDeviceMoniker   != NULL))
        {
            hr = FindDeviceGeneric(
                        FIND_FLAG_BY_DSHOW_ID, 
                        &(CSimpleStringConvert::NaturalString(strDShowID)),
                        plEnumPos,
                        pstrFriendlyName,
                        ppDeviceMoniker);
        }

        if (pstrDShowDeviceID)
        {
            *pstrDShowDeviceID = strDShowID;
        }
    }

    CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByWiaID failed to find a "
                     "Directshow device with a WIA device ID of '%ls'", 
                     pstrWiaDeviceID->String()));

    return hr;
}

///////////////////////////////
// CreateGraphBuilder
//
//
// Static Fn
//
HRESULT CDShowUtil::CreateGraphBuilder(
                                ICaptureGraphBuilder2 **ppCaptureGraphBuilder,
                                IGraphBuilder         **ppGraphBuilder)
{
    DBG_FN("CDShowUtil::CreateGraphBuilder");

    HRESULT hr = S_OK;

    ASSERT(ppCaptureGraphBuilder != NULL);
    ASSERT(ppGraphBuilder        != NULL);

    if ((ppCaptureGraphBuilder == NULL) ||
        (ppGraphBuilder        == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::CreateGraphBuilder received NULL "
                         "params"));

        return hr;
    }

    if (SUCCEEDED(hr))
    {
        //
        // First, get a CaptureGraph builder
        //

        hr = CoCreateInstance(CLSID_CaptureGraphBuilder2,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ICaptureGraphBuilder2,
                              (void**)ppCaptureGraphBuilder);

        CHECK_S_OK2( hr, ("CDShowUtil::CreateGraphBuilder, failed to create "  
                          "the DShow Capture Graph Builder object"));
    }

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_FilterGraph,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGraphBuilder,
                              (void**)ppGraphBuilder);

        CHECK_S_OK2( hr, ("CDShowUtil::CreateGraphBuilder, failed to create "  
                          "the DShow Filter Graph Object"));
    }


    if (SUCCEEDED(hr) && (*ppCaptureGraphBuilder) && (*ppGraphBuilder))
    {
        hr = (*ppCaptureGraphBuilder)->SetFiltergraph(*ppGraphBuilder);

        CHECK_S_OK2( hr, ("CDShowUtil::CreateGraphBuilder, failed to set "  
                          "the capture graph builder's filter graph object"));
    }

    return hr;
}

///////////////////////////////
// TurnOffGraphClock
//
// Turn off the clock that the
// graph would use so that 
// the graph won't drop frames
// if some frames are delivered
// late.
// 
//
HRESULT CDShowUtil::TurnOffGraphClock(IGraphBuilder *pGraphBuilder)
{
    DBG_FN("CDShowUtil::TurnOffGraphClock");

    ASSERT(pGraphBuilder != NULL);

    HRESULT               hr = S_OK;
    CComPtr<IMediaFilter> pMediaFilter;

    if (pGraphBuilder == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::TurnOffGraphClock received a NULL pointer"));
    }

    if (hr == S_OK)
    {
        hr = pGraphBuilder->QueryInterface(IID_IMediaFilter, (void**) &pMediaFilter);
    }

    if (hr == S_OK)
    {
        hr = pMediaFilter->SetSyncSource(NULL);
    }

    return hr;
}


///////////////////////////////
// SetPreferredVideoFormat
//
// This builds the preview graph
// based on the device ID we
// pass it.
//
HRESULT CDShowUtil::SetPreferredVideoFormat(IPin                *pCapturePin,
                                            const GUID          *pPreferredSubType,
                                            LONG                lPreferredWidth,
                                            LONG                lPreferredHeight,
                                            CWiaVideoProperties *pVideoProperties)
{
    ASSERT(pCapturePin          != NULL);
    ASSERT(pPreferredSubType    != NULL);
    ASSERT(pVideoProperties     != NULL);

    DBG_FN("CDShowUtil::SetPreferredVideoFormat");

    CComPtr<IAMStreamConfig>    pStreamConfig;
    HRESULT                     hr                 = S_OK;
    INT                         iCount             = 0;
    INT                         iSize              = 0;
    INT                         iIndex             = 0;
    BOOL                        bDone              = FALSE;
    BYTE                        *pConfig           = NULL;
    AM_MEDIA_TYPE               *pMediaType        = NULL;
    AM_MEDIA_TYPE               *pFoundType        = NULL;
    VIDEOINFOHEADER             *pVideoInfo        = NULL;

    //
    // Check for invalid parameters
    //
    if ((pCapturePin          == NULL) ||
        (pPreferredSubType    == NULL) ||
        (pVideoProperties     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CDShowUtil::SetPreferredFormat "
                         "received a NULL param"));
    }

    //
    // Attempt to get the stream config interface on this pin.  Not 
    // all capture filters will allow you to configure them, so if 
    // this fails, we will just exit the function, and the BuildPreviewGraph
    // function will attempt to render the graph with the default settings
    // of the pin.
    //
    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    //
    // We can configure this pin, so lets see how many options it has.
    //
    if (hr == S_OK)
    {
        hr = pStreamConfig->GetNumberOfCapabilities(&iCount, &iSize);
    }

    //
    // We need to alloc memory for the GetStreamCaps function below.
    //
    if (hr == S_OK)
    {
        pConfig = new BYTE[iSize];

        if (pConfig == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    while ((hr == S_OK) && (iIndex < iCount) && (!bDone))
    {
        //
        // Clear out the memory
        //
        ZeroMemory(pConfig, iSize);

        //
        // Get the capabilities for the stream.  There are iCount options,
        // we will iterate searching for the best one.
        //
        hr = pStreamConfig->GetStreamCaps(iIndex, &pMediaType, pConfig);

        if ((hr == S_OK) && (pMediaType))
        {
            pVideoInfo = NULL;

            //
            // We successfully got the media type, check to see if it is
            // a VideoInfo, if not we are not interested.
            //
            if (pMediaType->formattype == FORMAT_VideoInfo)
            {
                pVideoInfo = reinterpret_cast<VIDEOINFOHEADER*>(pMediaType->pbFormat);
            }

            if (pVideoInfo) 
            {
                //
                // Check to see if this option contains the preferred settings we
                // are looking for.
                //

                if ((pMediaType->subtype            == *pPreferredSubType) &&
                    (pVideoInfo->bmiHeader.biWidth  == lPreferredWidth) &&
                    (pVideoInfo->bmiHeader.biHeight == lPreferredHeight))
                {
                    //
                    // Is this our ideal media type.  That is, does it have the
                    // preferred subtype we want and the preferred width and height.
                    // If so, then great, we can't do better than this, so exit the loop.
                    //
    
                    if (pFoundType)
                    {
                        DeleteMediaType(pFoundType);
                        pFoundType = NULL;
                    }
    
                    pFoundType = pMediaType;
                    bDone = TRUE;
                }
                else if ((pVideoInfo->bmiHeader.biWidth  == lPreferredWidth) &&
                         (pVideoInfo->bmiHeader.biHeight == lPreferredHeight))
                {
                    //
                    // Okay, we found a media type with the width and height that
                    // we would like, but we it doesn't have our preferred subtype.
                    // So lets hang on to this media subtype, but continue looking,
                    // maybe we will find something better.  If we don't, then
                    // we will use this media type anyway.
                    //
    
                    if (pFoundType)
                    {
                        DeleteMediaType(pFoundType);
                        pFoundType = NULL;
                    }
    
                    pFoundType = pMediaType;
                }
                else
                {
                    //
                    // This media type is not even close to what we want, so
                    // delete it and keep looking.
                    //
                    //
                    DeleteMediaType(pMediaType);
                    pMediaType = NULL;
                }
            }
            else
            {
                DeleteMediaType(pMediaType);
                pMediaType = NULL;
            }
        }

        ++iIndex;
    }

    //
    // Set the format on the output pin if we found a good one.
    //
    if (pFoundType)
    {
        WCHAR szGUID[CHARS_IN_GUID] = {0};

        GUIDToString(pFoundType->subtype, szGUID, sizeof(szGUID) / sizeof(WCHAR));

        DBG_TRC(("CDShowUtil::SetPreferredVideoFormat, setting "
                 "capture pin's settings to MediaSubType = '%ls', "
                 "Video Width = %lu, Video Height = %lu",
                 szGUID, lPreferredWidth, lPreferredHeight));

        hr = pStreamConfig->SetFormat(pFoundType);

        //
        // ***Pay attention***
        //
        // We set the new media type in the pVideoProperties object.  If 
        // the media type is already set, we delete it first, then set a new 
        // one.
        //
        if (hr == S_OK)
        {
            pVideoProperties->pVideoInfoHeader = NULL;

            if (pVideoProperties->pMediaType)
            {
                DeleteMediaType(pVideoProperties->pMediaType);
            }

            pVideoProperties->pMediaType = pFoundType;
            pVideoProperties->pVideoInfoHeader = reinterpret_cast<VIDEOINFOHEADER*>(pFoundType->pbFormat);
        }

        pFoundType = NULL;
    }

    delete [] pConfig;

    return hr;
}

///////////////////////////////
// GetFrameRate
//
HRESULT CDShowUtil::GetFrameRate(IPin   *pCapturePin,
                                 LONG   *plFrameRate)
{
    HRESULT                     hr = S_OK;
    CComPtr<IAMStreamConfig>    pStreamConfig;
    AM_MEDIA_TYPE               *pMediaType = NULL;

    //
    // Check for invalid parameters
    //
    if ((pCapturePin == NULL) ||
        (plFrameRate == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CDShowUtil::GetFrameRate "
                         "received a NULL param"));
    }

    //
    // Attempt to get the stream config interface on this pin.  Not 
    // all capture filters will allow you to configure them, so if 
    // this fails, we will just exit the function.
    //
    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    if (hr == S_OK)
    {
        hr = pStreamConfig->GetFormat(&pMediaType);
    }

    if (hr == S_OK)
    {
        if (pMediaType->formattype == FORMAT_VideoInfo) 
        {
            VIDEOINFOHEADER *pHdr = reinterpret_cast<VIDEOINFOHEADER*>(pMediaType->pbFormat);

            *plFrameRate = (LONG) (pHdr->AvgTimePerFrame / 10000000);
        }
    }

    if (pMediaType)
    {
        DeleteMediaType(pMediaType);
    }

    return hr;
}


///////////////////////////////
// SetFrameRate
//
HRESULT CDShowUtil::SetFrameRate(IPin                 *pCapturePin,
                                 LONG                 lNewFrameRate,
                                 CWiaVideoProperties  *pVideoProperties)
{
    HRESULT                     hr = S_OK;
    CComPtr<IAMStreamConfig>    pStreamConfig;

    //
    // Check for invalid parameters
    //
    if (pCapturePin == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CDShowUtil::SetFrameRate "
                         "received a NULL param"));
    }

    //
    // Attempt to get the stream config interface on this pin.  Not 
    // all capture filters will allow you to configure them, so if 
    // this fails, we will just exit the function.
    //
    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    if (hr == S_OK)
    {
        AM_MEDIA_TYPE *pMediaType = NULL;

        hr = pStreamConfig->GetFormat(&pMediaType);

        if (hr == S_OK)
        {
            if (pMediaType->formattype == FORMAT_VideoInfo) 
            {
                VIDEOINFOHEADER *pHdr = reinterpret_cast<VIDEOINFOHEADER*>(pMediaType->pbFormat);

                pHdr->AvgTimePerFrame = (LONGLONG)(10000000 / lNewFrameRate);

                hr = pStreamConfig->SetFormat(pMediaType);

                if (hr == S_OK)
                {
                    if (pVideoProperties)
                    {
                        pVideoProperties->dwFrameRate = lNewFrameRate;
                    }
                }
                else
                {
                    DBG_WRN(("CDShowUtil::SetFrameRate, failed to set frame rate, "
                             "hr = %08lx, this is not fatal", hr));
                }
            }
        }

        if (pMediaType)
        {
            DeleteMediaType(pMediaType);
        }
    }

    return hr;
}

///////////////////////////////
// GetVideoProperties
//
HRESULT CDShowUtil::GetVideoProperties(IBaseFilter         *pCaptureFilter,
                                       IPin                *pCapturePin,
                                       CWiaVideoProperties *pVideoProperties)
{
    USES_CONVERSION;

    ASSERT(pCaptureFilter   != NULL);
    ASSERT(pCapturePin      != NULL);
    ASSERT(pVideoProperties != NULL);

    HRESULT hr = S_OK;
    CComPtr<IAMStreamConfig>    pStreamConfig;

    if ((pCaptureFilter     == NULL) ||
        (pCapturePin        == NULL) ||
        (pVideoProperties   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetVideoProperties received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    //
    // Get the current AM_MEDIA_TYPE.  Notice that we do not call DeleteMediaType.  It is 
    // stored in the CWiaVideoProperties and deleted when the object is freed.
    //
    if (hr == S_OK)
    {
        hr = pStreamConfig->GetFormat(&pVideoProperties->pMediaType);

        if (hr == S_OK)
        {
            if (pVideoProperties->pMediaType->formattype == FORMAT_VideoInfo) 
            {
                pVideoProperties->pVideoInfoHeader = reinterpret_cast<VIDEOINFOHEADER*>(pVideoProperties->pMediaType->pbFormat);
            }
        }

        CHECK_S_OK2(hr, ("CDShowUtil::GetVideoProperties, failed to get AM_MEDIA_TYPE"));

        hr = S_OK;
    }

    //
    // Get the frame rate.
    //
    if (hr == S_OK)
    {
        pVideoProperties->dwFrameRate = (DWORD) (pVideoProperties->pVideoInfoHeader->AvgTimePerFrame / 10000000);
    }

    //
    // Get all the picture attributes we can.
    //
    if (hr == S_OK)
    {
        HRESULT hrRange = S_OK;
        HRESULT hrValue = S_OK;

        CComPtr<IAMVideoProcAmp>    pVideoProcAmp;

        hr = pCaptureFilter->QueryInterface(IID_IAMVideoProcAmp, (void**) &pVideoProcAmp);

        if (pVideoProcAmp)
        {
            pVideoProperties->bPictureAttributesUsed = TRUE;

            //
            // Brightness
            //
            pVideoProperties->Brightness.Name = VideoProcAmp_Brightness;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Brightness.Name,
                                              &pVideoProperties->Brightness.lMinValue,
                                              &pVideoProperties->Brightness.lMaxValue,
                                              &pVideoProperties->Brightness.lIncrement,
                                              &pVideoProperties->Brightness.lDefaultValue,
                                              (long*) &pVideoProperties->Brightness.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Brightness.Name,
                                         &pVideoProperties->Brightness.lCurrentValue,
                                         (long*) &pVideoProperties->Brightness.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Brightness.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Brightness.bUsed = TRUE;
            }

            //
            // Contrast
            //
            pVideoProperties->Contrast.Name = VideoProcAmp_Contrast;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Contrast.Name,
                                              &pVideoProperties->Contrast.lMinValue,
                                              &pVideoProperties->Contrast.lMaxValue,
                                              &pVideoProperties->Contrast.lIncrement,
                                              &pVideoProperties->Contrast.lDefaultValue,
                                              (long*) &pVideoProperties->Contrast.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Contrast.Name,
                                         &pVideoProperties->Contrast.lCurrentValue,
                                         (long*) &pVideoProperties->Contrast.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Contrast.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Contrast.bUsed = TRUE;
            }

            //
            // Hue
            //
            pVideoProperties->Hue.Name = VideoProcAmp_Hue;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Hue.Name,
                                              &pVideoProperties->Hue.lMinValue,
                                              &pVideoProperties->Hue.lMaxValue,
                                              &pVideoProperties->Hue.lIncrement,
                                              &pVideoProperties->Hue.lDefaultValue,
                                              (long*) &pVideoProperties->Hue.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Hue.Name,
                                         &pVideoProperties->Hue.lCurrentValue,
                                         (long*) &pVideoProperties->Hue.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Hue.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Hue.bUsed = TRUE;
            }

            
            //
            // Saturation
            //
            pVideoProperties->Saturation.Name = VideoProcAmp_Saturation;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Saturation.Name,
                                              &pVideoProperties->Saturation.lMinValue,
                                              &pVideoProperties->Saturation.lMaxValue,
                                              &pVideoProperties->Saturation.lIncrement,
                                              &pVideoProperties->Saturation.lDefaultValue,
                                              (long*) &pVideoProperties->Saturation.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Saturation.Name,
                                         &pVideoProperties->Saturation.lCurrentValue,
                                         (long*) &pVideoProperties->Saturation.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Saturation.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Saturation.bUsed = TRUE;
            }


            //
            // Sharpness
            //
            pVideoProperties->Sharpness.Name = VideoProcAmp_Sharpness;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Sharpness.Name,
                                              &pVideoProperties->Sharpness.lMinValue,
                                              &pVideoProperties->Sharpness.lMaxValue,
                                              &pVideoProperties->Sharpness.lIncrement,
                                              &pVideoProperties->Sharpness.lDefaultValue,
                                              (long*) &pVideoProperties->Sharpness.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Sharpness.Name,
                                         &pVideoProperties->Sharpness.lCurrentValue,
                                         (long*) &pVideoProperties->Sharpness.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Sharpness.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Sharpness.bUsed = TRUE;
            }


            //
            // Gamma
            //
            pVideoProperties->Gamma.Name = VideoProcAmp_Gamma;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Gamma.Name,
                                              &pVideoProperties->Gamma.lMinValue,
                                              &pVideoProperties->Gamma.lMaxValue,
                                              &pVideoProperties->Gamma.lIncrement,
                                              &pVideoProperties->Gamma.lDefaultValue,
                                              (long*) &pVideoProperties->Gamma.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Gamma.Name,
                                         &pVideoProperties->Gamma.lCurrentValue,
                                         (long*) &pVideoProperties->Gamma.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Gamma.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Gamma.bUsed = TRUE;
            }


            //
            // ColorEnable
            //
            pVideoProperties->ColorEnable.Name = VideoProcAmp_ColorEnable;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->ColorEnable.Name,
                                              &pVideoProperties->ColorEnable.lMinValue,
                                              &pVideoProperties->ColorEnable.lMaxValue,
                                              &pVideoProperties->ColorEnable.lIncrement,
                                              &pVideoProperties->ColorEnable.lDefaultValue,
                                              (long*) &pVideoProperties->ColorEnable.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->ColorEnable.Name,
                                         &pVideoProperties->ColorEnable.lCurrentValue,
                                         (long*) &pVideoProperties->ColorEnable.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->ColorEnable.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->ColorEnable.bUsed = TRUE;
            }


            //
            // WhiteBalance
            //
            pVideoProperties->WhiteBalance.Name = VideoProcAmp_WhiteBalance;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->WhiteBalance.Name,
                                              &pVideoProperties->WhiteBalance.lMinValue,
                                              &pVideoProperties->WhiteBalance.lMaxValue,
                                              &pVideoProperties->WhiteBalance.lIncrement,
                                              &pVideoProperties->WhiteBalance.lDefaultValue,
                                              (long*) &pVideoProperties->WhiteBalance.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->WhiteBalance.Name,
                                         &pVideoProperties->WhiteBalance.lCurrentValue,
                                         (long*) &pVideoProperties->WhiteBalance.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->WhiteBalance.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->WhiteBalance.bUsed = TRUE;
            }


            //
            // BacklightCompensation
            //
            pVideoProperties->BacklightCompensation.Name = VideoProcAmp_BacklightCompensation;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->BacklightCompensation.Name,
                                              &pVideoProperties->BacklightCompensation.lMinValue,
                                              &pVideoProperties->BacklightCompensation.lMaxValue,
                                              &pVideoProperties->BacklightCompensation.lIncrement,
                                              &pVideoProperties->BacklightCompensation.lDefaultValue,
                                              (long*) &pVideoProperties->BacklightCompensation.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->BacklightCompensation.Name,
                                         &pVideoProperties->BacklightCompensation.lCurrentValue,
                                         (long*) &pVideoProperties->BacklightCompensation.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->BacklightCompensation.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->BacklightCompensation.bUsed = TRUE;
            }
        }
        else
        {
            pVideoProperties->bPictureAttributesUsed = FALSE;
        }

        hr = S_OK;
    }

    //
    // Get all the camera attributes we can.
    //
    if (hr == S_OK)
    {
        HRESULT hrRange = S_OK;
        HRESULT hrValue = S_OK;

        CComPtr<IAMCameraControl>    pCameraControl;

        hr = pCaptureFilter->QueryInterface(IID_IAMCameraControl, (void**) &pCameraControl);

        if (pCameraControl)
        {
            pVideoProperties->bCameraAttributesUsed = TRUE;

            //
            // Pan
            //
            pVideoProperties->Pan.Name = CameraControl_Pan;
            hrRange = pCameraControl->GetRange(pVideoProperties->Pan.Name,
                                               &pVideoProperties->Pan.lMinValue,
                                               &pVideoProperties->Pan.lMaxValue,
                                               &pVideoProperties->Pan.lIncrement,
                                               &pVideoProperties->Pan.lDefaultValue,
                                               (long*) &pVideoProperties->Pan.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Pan.Name,
                                          &pVideoProperties->Pan.lCurrentValue,
                                          (long*) &pVideoProperties->Pan.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Pan.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Pan.bUsed = TRUE;
            }

            //
            // Tilt
            //
            pVideoProperties->Tilt.Name = CameraControl_Tilt;
            hrRange = pCameraControl->GetRange(pVideoProperties->Tilt.Name,
                                               &pVideoProperties->Tilt.lMinValue,
                                               &pVideoProperties->Tilt.lMaxValue,
                                               &pVideoProperties->Tilt.lIncrement,
                                               &pVideoProperties->Tilt.lDefaultValue,
                                               (long*) &pVideoProperties->Tilt.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Tilt.Name,
                                          &pVideoProperties->Tilt.lCurrentValue,
                                          (long*) &pVideoProperties->Tilt.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Tilt.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Tilt.bUsed = TRUE;
            }


            //
            // Roll
            //
            pVideoProperties->Roll.Name = CameraControl_Roll;
            hrRange = pCameraControl->GetRange(pVideoProperties->Roll.Name,
                                               &pVideoProperties->Roll.lMinValue,
                                               &pVideoProperties->Roll.lMaxValue,
                                               &pVideoProperties->Roll.lIncrement,
                                               &pVideoProperties->Roll.lDefaultValue,
                                               (long*) &pVideoProperties->Roll.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Roll.Name,
                                          &pVideoProperties->Roll.lCurrentValue,
                                          (long*) &pVideoProperties->Roll.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Roll.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Roll.bUsed = TRUE;
            }


            //
            // Zoom
            //
            pVideoProperties->Zoom.Name = CameraControl_Zoom;
            hrRange = pCameraControl->GetRange(pVideoProperties->Zoom.Name,
                                               &pVideoProperties->Zoom.lMinValue,
                                               &pVideoProperties->Zoom.lMaxValue,
                                               &pVideoProperties->Zoom.lIncrement,
                                               &pVideoProperties->Zoom.lDefaultValue,
                                               (long*) &pVideoProperties->Zoom.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Zoom.Name,
                                          &pVideoProperties->Zoom.lCurrentValue,
                                          (long*) &pVideoProperties->Zoom.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Zoom.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Zoom.bUsed = TRUE;
            }

            //
            // Exposure
            //
            pVideoProperties->Exposure.Name = CameraControl_Exposure;
            hrRange = pCameraControl->GetRange(pVideoProperties->Exposure.Name,
                                               &pVideoProperties->Exposure.lMinValue,
                                               &pVideoProperties->Exposure.lMaxValue,
                                               &pVideoProperties->Exposure.lIncrement,
                                               &pVideoProperties->Exposure.lDefaultValue,
                                               (long*) &pVideoProperties->Exposure.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Exposure.Name,
                                          &pVideoProperties->Exposure.lCurrentValue,
                                          (long*) &pVideoProperties->Exposure.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Exposure.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Exposure.bUsed = TRUE;
            }


            //
            // Iris
            //
            pVideoProperties->Iris.Name = CameraControl_Iris;
            hrRange = pCameraControl->GetRange(pVideoProperties->Iris.Name,
                                               &pVideoProperties->Iris.lMinValue,
                                               &pVideoProperties->Iris.lMaxValue,
                                               &pVideoProperties->Iris.lIncrement,
                                               &pVideoProperties->Iris.lDefaultValue,
                                               (long*) &pVideoProperties->Iris.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Iris.Name,
                                          &pVideoProperties->Iris.lCurrentValue,
                                          (long*) &pVideoProperties->Iris.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Iris.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Iris.bUsed = TRUE;
            }

            //
            // Focus
            //
            pVideoProperties->Focus.Name = CameraControl_Focus;
            hrRange = pCameraControl->GetRange(pVideoProperties->Focus.Name,
                                               &pVideoProperties->Focus.lMinValue,
                                               &pVideoProperties->Focus.lMaxValue,
                                               &pVideoProperties->Focus.lIncrement,
                                               &pVideoProperties->Focus.lDefaultValue,
                                               (long*) &pVideoProperties->Focus.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Focus.Name,
                                          &pVideoProperties->Focus.lCurrentValue,
                                          (long*) &pVideoProperties->Focus.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Focus.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Focus.bUsed = TRUE;
            }
        }
        else
        {
            pVideoProperties->bCameraAttributesUsed = FALSE;
        }

        hr = S_OK;
    }

    if (pVideoProperties->szWiaDeviceID[0] != 0)
    {
        CComPtr<IStillImage> pSti = NULL;
        TCHAR szGUID[CHARS_IN_GUID + 1] = {0};

        pVideoProperties->PreferredSettingsMask = 0;

        hr = StiCreateInstance(_Module.GetModuleInstance(), 
                               STI_VERSION,
                               &pSti,
                               NULL);

        if (hr == S_OK)
        {
            DWORD dwType = REG_DWORD;
            DWORD dwSize = sizeof(pVideoProperties->PreferredWidth);

            hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                      T2W((TCHAR*)REG_VAL_PREFERRED_VIDEO_WIDTH),
                                      &dwType,
                                      (BYTE*) &pVideoProperties->PreferredWidth,
                                      &dwSize);

            if (hr == S_OK)
            {
                dwSize = sizeof(pVideoProperties->PreferredHeight);

                hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                          T2W((TCHAR*) REG_VAL_PREFERRED_VIDEO_HEIGHT),
                                          &dwType,
                                          (BYTE*) &pVideoProperties->PreferredHeight,
                                          &dwSize);
            }

            if (hr == S_OK)
            {
                pVideoProperties->PreferredSettingsMask |= PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT;
            }

            hr = S_OK;
        }

        if (hr == S_OK)
        {
            DWORD dwType = REG_SZ;
            DWORD dwSize = sizeof(szGUID);

            hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                      T2W((TCHAR*)REG_VAL_PREFERRED_MEDIASUBTYPE),
                                      &dwType,
                                      (BYTE*) szGUID,
                                      &dwSize);

            if (hr == S_OK)
            {
                CLSIDFromString(T2OLE(szGUID), &pVideoProperties->PreferredMediaSubType);
                pVideoProperties->PreferredSettingsMask |= PREFERRED_SETTING_MASK_MEDIASUBTYPE;
            }

            hr = S_OK;
        }

        if (hr == S_OK)
        {
            DWORD dwType = REG_SZ;
            DWORD dwSize = sizeof(pVideoProperties->PreferredFrameRate);

            
            hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                      T2W((TCHAR*) REG_VAL_PREFERRED_VIDEO_FRAMERATE),
                                      &dwType,
                                      (BYTE*) &pVideoProperties->PreferredFrameRate,
                                      &dwSize);

            if (hr == S_OK)
            {
                pVideoProperties->PreferredSettingsMask |= PREFERRED_SETTING_MASK_VIDEO_FRAMERATE;
            }

            hr = S_OK;
        }

        DBG_TRC(("Settings found for Device '%ls' in DeviceData section of INF file",
                 pVideoProperties->szWiaDeviceID));

        DBG_PRT(("   PreferredVideoWidth      = '%lu', Is In INF and value is of type REG_DWORD? '%ls'", 
                 pVideoProperties->PreferredWidth,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT) ? _T("TRUE") : _T("FALSE")));

        DBG_PRT(("   PreferredVideoHeight     = '%lu', Is In INF and value is of type REG_DWORD? '%ls'", 
                 pVideoProperties->PreferredHeight,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT) ? _T("TRUE") : _T("FALSE")));

        DBG_PRT(("   PreferredVideoFrameRate  = '%lu', Is In INF and value is of type REG_DWORD? '%ls'", 
                 pVideoProperties->PreferredFrameRate,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_VIDEO_FRAMERATE) ? _T("TRUE") : _T("FALSE")));

        DBG_PRT(("   PreferredMediaSubType    = '%ls', Is In INF and value is of type REG_SZ? '%ls'", 
                 szGUID,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_MEDIASUBTYPE) ? _T("TRUE") : _T("FALSE")));
    }

    return hr;
}

///////////////////////////////
// SetPictureAttribute
//
HRESULT CDShowUtil::SetPictureAttribute(IBaseFilter                             *pCaptureFilter,
                                        CWiaVideoProperties::PictureAttribute_t *pPictureAttribute,
                                        LONG                                    lNewValue,
                                        VideoProcAmpFlags                       lNewFlag)
{
    ASSERT(pCaptureFilter    != NULL);
    ASSERT(pPictureAttribute != NULL);

    HRESULT                     hr = S_OK;
    CComPtr<IAMVideoProcAmp>    pVideoProcAmp;

    if ((pCaptureFilter    == NULL) ||
        (pPictureAttribute == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SetPictureAttribute, received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = pCaptureFilter->QueryInterface(IID_IAMVideoProcAmp, (void**) &pVideoProcAmp);
    }

    if (hr == S_OK)
    {
        if (pPictureAttribute->bUsed)
        {
            //
            // Attempt to set the new value for the property.
            //
            hr = pVideoProcAmp->Set(pPictureAttribute->Name,
                                    lNewValue,
                                    (long) lNewFlag);


            //
            // If we successfully set the new value, then get it again.  We do this
            // in case the capture filter decided to change the values a little upon
            // setting them (it shouldn't, but each filter could act differently)
            //
            if (hr == S_OK)
            {
                hr = pVideoProcAmp->Get(pPictureAttribute->Name,
                                        &pPictureAttribute->lCurrentValue,
                                        (long*) &pPictureAttribute->CurrentFlag);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

///////////////////////////////
// SetCameraAttribute
//
HRESULT CDShowUtil::SetCameraAttribute(IBaseFilter                             *pCaptureFilter,
                                       CWiaVideoProperties::CameraAttribute_t  *pCameraAttribute,
                                       LONG                                    lNewValue,
                                       CameraControlFlags                      lNewFlag)
{
    ASSERT(pCaptureFilter    != NULL);
    ASSERT(pCameraAttribute  != NULL);

    HRESULT                     hr = S_OK;
    CComPtr<IAMCameraControl>   pCameraControl;

    if ((pCaptureFilter == NULL) ||
        (pCameraControl == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SetCameraAttribute, received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = pCaptureFilter->QueryInterface(IID_IAMCameraControl, (void**) &pCameraControl);
    }

    if (hr == S_OK)
    {
        if (pCameraAttribute->bUsed)
        {
            //
            // Attempt to set the new value for the property.
            //
            hr = pCameraControl->Set(pCameraAttribute->Name,
                                     lNewValue,
                                     (long) lNewFlag);

            //
            // If we successfully set the new value, then get it again.  We do this
            // in case the capture filter decided to change the values a little upon
            // setting them (it shouldn't, but each filter could act differently)
            //
            if (hr == S_OK)
            {
                hr = pCameraControl->Get(pCameraAttribute->Name,
                                         &pCameraAttribute->lCurrentValue,
                                         (long*) &pCameraAttribute->CurrentFlag);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

///////////////////////////////
// GetPin
//
// This function returns the first
// pin on the specified filter 
// matching the requested 
// pin direction
//
HRESULT CDShowUtil::GetPin(IBaseFilter       *pFilter,
                           PIN_DIRECTION     PinDirection,
                           IPin              **ppPin)
{
    HRESULT             hr           = S_OK;
    BOOL                bFound       = FALSE;
    ULONG               ulNumFetched = 0;
    PIN_DIRECTION       PinDir;
    CComPtr<IEnumPins>  pEnum;

    if ((pFilter == NULL) ||
        (ppPin   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetPin, received a NULL param"));
        return hr;
    }

    hr = pFilter->EnumPins(&pEnum);

    if (hr == S_OK)
    {
        hr = pEnum->Reset();
    }

    while ((hr == S_OK) && (!bFound))
    {
        CComPtr<IPin>       pPin;

        hr = pEnum->Next(1, &pPin, &ulNumFetched);
      
        if (hr == S_OK)
        {
            hr = pPin->QueryDirection(&PinDir);

            if (hr == S_OK)
            {
                if (PinDir == PinDirection)
                {
                    *ppPin = pPin;
                    (*ppPin)->AddRef();

                    bFound = TRUE;
                }
            }
            else
            {
                CHECK_S_OK2(hr, ("CDShowUtil::GetPin, failed to get "
                                 "Pin Direction, aborting find attempt"));
            }
        }
    }

    if (hr == S_FALSE)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        CHECK_S_OK2(hr, ("CDShowUtil::GetPin, failed to find "
                         "pin with direction %lu", PinDirection));
    }

    return hr;
}


///////////////////////////////
// GUIDToString
//
// Static Fn
//
void CDShowUtil::GUIDToString(const GUID &   clsid,
                              WCHAR*         pwszGUID,
                              ULONG          ulNumChars)
{
    OLECHAR sz_clsid[CHARS_IN_GUID] = L"{Unknown}";

    if (pwszGUID)
    {
        StringFromGUID2(clsid, 
                        sz_clsid, 
                        sizeof(sz_clsid)/sizeof(sz_clsid[0]));

        wcsncpy(pwszGUID, sz_clsid, ulNumChars - 1);
        pwszGUID[ulNumChars - 1] = '\0';
    }
    return;
}

///////////////////////////////
// MyDumpVideoProperties
//
// Static Fn
//
void CDShowUtil::MyDumpVideoProperties(CWiaVideoProperties  *pVideoProperties)
{
    WCHAR wszMajorType[CHARS_IN_GUID + 1] = {0};
    WCHAR wszSubType[CHARS_IN_GUID + 1] = {0};
    WCHAR wszFormatType[CHARS_IN_GUID + 1] = {0};

    if (pVideoProperties == NULL)
    {
        return;
    }

    DBG_TRC(("***Dumping Wia Video Properties***"));

    GUIDToString(pVideoProperties->pMediaType->majortype, wszMajorType, sizeof(wszMajorType) / sizeof(WCHAR));
    GUIDToString(pVideoProperties->pMediaType->subtype, wszSubType, sizeof(wszSubType) / sizeof(WCHAR));
    GUIDToString(pVideoProperties->pMediaType->formattype, wszFormatType, sizeof(wszFormatType) / sizeof(WCHAR));

    DBG_PRT(("Media Type Information:"));
    DBG_PRT(("  Major Type:           %ls", wszMajorType));
    DBG_PRT(("  Sub Type:             %ls", wszSubType));
    DBG_PRT(("  Fixed Size Samples?   %d ", pVideoProperties->pMediaType->bFixedSizeSamples));
    DBG_PRT(("  Temporal Compression? %d ", pVideoProperties->pMediaType->bTemporalCompression));
    DBG_PRT(("  Sample Size:          %d ", pVideoProperties->pMediaType->lSampleSize));
    DBG_PRT(("  Format Type:          %ls ", wszFormatType));

    DBG_PRT(("Video Header Information:"));
    DBG_PRT(("  Source Rect: Left %d, Top %d, Right %d, Bottom %d", 
                pVideoProperties->pVideoInfoHeader->rcSource.left,
                pVideoProperties->pVideoInfoHeader->rcSource.top,
                pVideoProperties->pVideoInfoHeader->rcSource.right, 
                pVideoProperties->pVideoInfoHeader->rcSource.bottom));
    DBG_PRT(("  Target Rect: Left %d, Top %d, Right %d, Bottom %d", 
                pVideoProperties->pVideoInfoHeader->rcTarget.left,
                pVideoProperties->pVideoInfoHeader->rcTarget.top,
                pVideoProperties->pVideoInfoHeader->rcTarget.right, 
                pVideoProperties->pVideoInfoHeader->rcTarget.bottom));
    DBG_PRT(("  Bit Rate:       %d", pVideoProperties->pVideoInfoHeader->dwBitRate));
    DBG_PRT(("  Bit Error Rate: %d", pVideoProperties->pVideoInfoHeader->dwBitErrorRate));
    DBG_PRT(("  Frame Rate:     %d", pVideoProperties->dwFrameRate));

    DBG_PRT(("Bitmap Information Header:"));
    DBG_PRT(("  Width:          %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biWidth));
    DBG_PRT(("  Height:         %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biHeight));
    DBG_PRT(("  Planes:         %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biPlanes));
    DBG_PRT(("  Bitcount:       %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biBitCount));
    DBG_PRT(("  Compresssion:   %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biCompression));
    DBG_PRT(("  Size Image:     %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biSizeImage));
    DBG_PRT(("  XPelsPerMeter:  %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biXPelsPerMeter));
    DBG_PRT(("  YPelsPerMeter:  %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biYPelsPerMeter));
    DBG_PRT(("  ClrUsed:        %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biClrUsed));
    DBG_PRT(("  ClrImportant:   %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biClrImportant));

    if (pVideoProperties->bPictureAttributesUsed)
    {
        DBG_PRT(("Picture Attributes:       Available"));

        DBG_PRT(("  Brightness:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Brightness.bUsed));

        if (pVideoProperties->Brightness.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Brightness.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Brightness.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Brightness.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Brightness.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Brightness.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Brightness.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Brightness.ValidFlags));
        }

        DBG_PRT(("  Contrast:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Contrast.bUsed));

        if (pVideoProperties->Contrast.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Contrast.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Contrast.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Contrast.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Contrast.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Contrast.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Contrast.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Contrast.ValidFlags));
        }

        DBG_PRT(("  Hue:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Hue.bUsed));

        if (pVideoProperties->Hue.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Hue.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Hue.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Hue.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Hue.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Hue.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Hue.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Hue.ValidFlags));
        }

        DBG_PRT(("  Saturation:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Saturation.bUsed));

        if (pVideoProperties->Saturation.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Saturation.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Saturation.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Saturation.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Saturation.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Saturation.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Saturation.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Saturation.ValidFlags));
        }

        DBG_PRT(("  Sharpness:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Sharpness.bUsed));

        if (pVideoProperties->Sharpness.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Sharpness.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Sharpness.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Sharpness.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Sharpness.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Sharpness.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Sharpness.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Sharpness.ValidFlags));
        }

        DBG_PRT(("  Gamma:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Gamma.bUsed));

        if (pVideoProperties->Gamma.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Gamma.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Gamma.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Gamma.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Gamma.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Gamma.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Gamma.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Gamma.ValidFlags));
        }

        DBG_PRT(("  ColorEnable:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->ColorEnable.bUsed));

        if (pVideoProperties->ColorEnable.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->ColorEnable.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->ColorEnable.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->ColorEnable.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->ColorEnable.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->ColorEnable.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->ColorEnable.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->ColorEnable.ValidFlags));
        }

        DBG_PRT(("  WhiteBalance:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->WhiteBalance.bUsed));

        if (pVideoProperties->WhiteBalance.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->WhiteBalance.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->WhiteBalance.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->WhiteBalance.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->WhiteBalance.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->WhiteBalance.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->WhiteBalance.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->WhiteBalance.ValidFlags));
        }

        DBG_PRT(("  BacklightCompensation:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->BacklightCompensation.bUsed));

        if (pVideoProperties->BacklightCompensation.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->BacklightCompensation.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->BacklightCompensation.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->BacklightCompensation.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->BacklightCompensation.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->BacklightCompensation.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->BacklightCompensation.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->BacklightCompensation.ValidFlags));
        }
    }
    else
    {
        DBG_PRT(("Picture Attributes:       Not Available"));
    }

    if (pVideoProperties->bCameraAttributesUsed)
    {
        DBG_PRT(("Camera Attributes:        Available"));

        DBG_PRT(("  Pan:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Pan.bUsed));

        if (pVideoProperties->Pan.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Pan.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Pan.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Pan.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Pan.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Pan.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Pan.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Pan.ValidFlags));
        }

        DBG_PRT(("  Tilt:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Tilt.bUsed));

        if (pVideoProperties->Tilt.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Tilt.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Tilt.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Tilt.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Tilt.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Tilt.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Tilt.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Tilt.ValidFlags));
        }

        DBG_PRT(("  Roll:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Roll.bUsed));

        if (pVideoProperties->Roll.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Roll.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Roll.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Roll.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Roll.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Roll.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Roll.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Roll.ValidFlags));
        }

        DBG_PRT(("  Zoom:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Zoom.bUsed));

        if (pVideoProperties->Zoom.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Zoom.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Zoom.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Zoom.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Zoom.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Zoom.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Zoom.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Zoom.ValidFlags));
        }

        DBG_PRT(("  Exposure:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Exposure.bUsed));

        if (pVideoProperties->Exposure.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Exposure.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Exposure.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Exposure.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Exposure.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Exposure.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Exposure.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Exposure.ValidFlags));
        }

        DBG_PRT(("  Iris:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Iris.bUsed));

        if (pVideoProperties->Iris.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Iris.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Iris.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Iris.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Iris.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Iris.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Iris.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Iris.ValidFlags));
        }

        DBG_PRT(("  Focus:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Focus.bUsed));

        if (pVideoProperties->Focus.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Focus.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Focus.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Focus.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Focus.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Focus.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Focus.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Focus.ValidFlags));
        }
    }
    else
    {
        DBG_PRT(("Camera Attributes:        Not Available"));
    }

    return;
}


///////////////////////////////
// DumpCaptureMoniker
//
// Static Fn
//
void CDShowUtil::DumpCaptureMoniker(IMoniker *pCaptureDeviceMoniker)
{
    HRESULT hr = S_OK;
    CComPtr<IPropertyBag> pPropertyBag;

    if (pCaptureDeviceMoniker == NULL)
    {
        return;
    }

    if (hr == S_OK)
    {
        //
        // Get property storage for this DS device so we can get it's
        // device id...
        //

        hr = pCaptureDeviceMoniker->BindToStorage(0, 
                                                  0,
                                                  IID_IPropertyBag,
                                                  (void **)&pPropertyBag);
    }

    if (hr == S_OK)
    {
        CSimpleString strTemp;

        DBG_TRC(("Dumping Moniker information for Capture Device"));

        GetDeviceProperty(pPropertyBag, L"FriendlyName", &strTemp);

        DBG_PRT(("DShow: FriendlyName = %ls", strTemp.String()));

        GetDeviceProperty(pPropertyBag, L"CLSID", &strTemp);

        DBG_PRT(("DShow: CLSID = %ls", strTemp.String()));

        hr = GetDeviceProperty(pPropertyBag, L"DevicePath", &strTemp);

        DBG_PRT(("DShow: DevicePath = %ls", strTemp.String()));
    }

    return;
}


///////////////////////////////
// MyDumpGraph
//
// Static Fn
//
void CDShowUtil::MyDumpGraph(LPCTSTR              Description,
                             IGraphBuilder        *pGraphBuilder)
{
    if (pGraphBuilder == NULL)
    {
        return;
    }

    if (Description)
    {
        DBG_TRC(("%S", Description));
    }
    else
    {
        DBG_TRC(("*** Dumping Filter Graph ***"));
    }

    //
    // Enum all the filters
    //

    CComPtr<IEnumFilters> pEnum;
    UINT uiNumFilters = 0;

    if ((pGraphBuilder) && (pGraphBuilder->EnumFilters(&pEnum) == S_OK))
    {
        pEnum->Reset();
        CComPtr<IBaseFilter> pFilter;

        while (S_OK == pEnum->Next(1, &pFilter, NULL))
        {
            ++uiNumFilters;
            MyDumpFilter(pFilter);
            pFilter = NULL;
        }

        if (uiNumFilters == 0)
        {
            DBG_TRC(("*** No Filters in Graph ***"));
        }
    }
}


///////////////////////////////
// MyDumpFilter
//
// Static Fn
//
void CDShowUtil::MyDumpFilter(IBaseFilter * pFilter)
{
    HRESULT        hr = S_OK;
    FILTER_INFO    FilterInfo;
    CLSID          clsid;

    if (pFilter == NULL)
    {
        DBG_TRC(("Invalid IBaseFilter interface pointer in MyDumpFilter"));

        return;
    }

    FilterInfo.pGraph = NULL;

    hr = pFilter->QueryFilterInfo(&FilterInfo);

    if (SUCCEEDED(hr))
    {
        hr = pFilter->GetClassID(&clsid);
    }
    else
    {
        DBG_TRC(("Unable to get filter info"));
    }

    if (SUCCEEDED(hr))
    {
        WCHAR  wszGUID[127 + 1]       = {0};
    
        GUIDToString(clsid, wszGUID, sizeof(wszGUID)/sizeof(WCHAR));
    
        DBG_PRT(("Filter Name: '%S', GUID: '%S'", 
                 FilterInfo.achName, 
                 wszGUID));
    
        if (FilterInfo.pGraph) 
        {
            FilterInfo.pGraph->Release();
            FilterInfo.pGraph = NULL;
        }
    
        MyDumpAllPins(pFilter);
    }

    return;
}

///////////////////////////////
// MyDumpAllPins
//
// Static Fn
//
void CDShowUtil::MyDumpAllPins(IBaseFilter *const pFilter)
{
    HRESULT             hr         = S_OK;
    CComPtr<IPin>       pPin       = NULL;
    ULONG               ulCount    = 0;
    CComPtr<IEnumPins>  pEnumPins  = NULL;

    hr = const_cast<IBaseFilter*>(pFilter)->EnumPins(&pEnumPins);

    if (SUCCEEDED(hr))
    {
        while ((SUCCEEDED(pEnumPins->Next(1, &pPin, &ulCount))) && 
               (ulCount > 0))
        {
            MyDumpPin(pPin);
            pPin = NULL;
        }
    }

    return;
}

///////////////////////////////
// MyDumpPin
//
// Static Fn
//
void CDShowUtil::MyDumpPin(IPin* pPin)
{
    if (pPin == NULL)
    {
        DBG_TRC(("Invalid IPin pointer in MyDumpPinInfo"));
        return;
    }

    LPWSTR      pin_id1             = NULL;
    LPWSTR      pin_id2             = NULL;
    PIN_INFO    pin_info1           = {0};
    PIN_INFO    pin_info2           = {0};

    const IPin *p_connected_to = NULL;

    // get the pin info for this pin.
    const_cast<IPin*>(pPin)->QueryPinInfo(&pin_info1);
    const_cast<IPin*>(pPin)->QueryId(&pin_id1);

    (const_cast<IPin*>(pPin))->ConnectedTo( 
                                const_cast<IPin**>(&p_connected_to));

    if (p_connected_to)
    {
        HRESULT         hr                  = S_OK;
        FILTER_INFO     filter_info         = {0};

        const_cast<IPin*>(p_connected_to)->QueryPinInfo(&pin_info2);
        const_cast<IPin*>(p_connected_to)->QueryId(&pin_id2);

        if (pin_info2.pFilter)
        {
            hr = pin_info2.pFilter->QueryFilterInfo(&filter_info);

            if (SUCCEEDED(hr))
            {
                if (filter_info.pGraph) 
                {
                    filter_info.pGraph->Release();
                    filter_info.pGraph = NULL;
                }
            }
        }

        if (pin_info2.pFilter) 
        {
            pin_info2.pFilter->Release();
            pin_info2.pFilter = NULL;
        }

        const_cast<IPin*>(p_connected_to)->Release();

        if (pin_info1.dir == PINDIR_OUTPUT)
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' --> "
                     "Filter: '%S', Pin: '%S', PinID: '%S'",
                     pin_info1.achName, 
                     pin_id1, 
                     filter_info.achName, 
                     pin_info2.achName, 
                     pin_id2));
        }
        else
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' <-- "
                     "Filter: '%S', Pin: '%S', PinID: '%S'",
                     pin_info1.achName, 
                     pin_id1, 
                     filter_info.achName, 
                     pin_info2.achName, 
                     pin_id2));
        }

        // if pin_id2 is NULL, then CoTaskMemFree is a no-op
        CoTaskMemFree(pin_id2);
    }
    else
    {
        if (pin_info1.dir == PINDIR_OUTPUT)
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' --> Not Connected",
                     pin_info1.achName, 
                     pin_id1));
        }
        else
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' <-- Not Connected",
                     pin_info1.achName, 
                     pin_id1));
        }
    }

    // if pin_id1 is NULL, then CoTaskMemFree is a no-op
    CoTaskMemFree(pin_id1);

    if (pin_info1.pFilter) 
    {
        pin_info1.pFilter->Release();
        pin_info1.pFilter = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\dshowutl.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DShowUtl.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Provides supporting DShow utility functions used to build 
 *               preview graph
 *
 *****************************************************************************/

#ifndef _DSHOWUTL_H_
#define _DSHOWUTL_H_

/////////////////////////////////////////////////////////////////////////////
// CAccessLock
//
// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
//
class CAccessLock 
{
public:
    CAccessLock(CRITICAL_SECTION *pCritSec)
    {
        m_pLock = pCritSec;
        EnterCriticalSection(m_pLock);
    };

    ~CAccessLock() 
    {
        LeaveCriticalSection(m_pLock);
    };

    static HRESULT Init(CRITICAL_SECTION  *pCritSec)
    {
        HRESULT hr = S_OK;

        __try 
        {
            if (!InitializeCriticalSectionAndSpinCount(pCritSec, MINLONG))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                CHECK_S_OK2(hr, ("CAccessLock::Init, failed to create Critical "
                                 "section "));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            hr = E_OUTOFMEMORY;
        }

        return hr;
    }

    static HRESULT Term(CRITICAL_SECTION    *pCritSec)
    {
        DeleteCriticalSection(pCritSec);

        return S_OK;
    }

protected:
    CRITICAL_SECTION *m_pLock;

private:
        
    // make copy constructor and assignment operator inaccessible

    CAccessLock(const CAccessLock &refAutoLock);
    CAccessLock &operator=(const CAccessLock &refAutoLock);
};

/////////////////////////////////////////////////////////////////////////////
// CWiaVideoProperties

class CWiaVideoProperties
{
public:

#define PREFERRED_SETTING_MASK_MEDIASUBTYPE             0x00000001
#define PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT       0x00000002
#define PREFERRED_SETTING_MASK_VIDEO_FRAMERATE          0x00000004

    ////////////////////////
    // PictureAttribute_t
    //
    // Contains all information
    // that can be obtained
    // via the IAMVideoProcAmp
    // interface
    //
    typedef struct tagPictureAttribute_t
    {
        BOOL                    bUsed;      // TRUE if attribute is implemented, FALSE otherwise
        VideoProcAmpProperty    Name;
        LONG                    lCurrentValue;
        VideoProcAmpFlags       CurrentFlag;
        LONG                    lMinValue;
        LONG                    lMaxValue;
        LONG                    lDefaultValue;
        LONG                    lIncrement;
        VideoProcAmpFlags       ValidFlags;
    } PictureAttribute_t;

    ////////////////////////
    // CameraAttribute_t
    //
    // Contains all information
    // that can be obtained
    // via the IAMCameraControl
    // interface
    //
    typedef struct tagCameraAttribute_t
    {
        BOOL                    bUsed;      // TRUE if attribute is implemented, FALSE otherwise
        CameraControlProperty   Name;
        LONG                    lCurrentValue;
        CameraControlFlags      CurrentFlag;
        LONG                    lMinValue;
        LONG                    lMaxValue;
        LONG                    lDefaultValue;
        LONG                    lIncrement;
        CameraControlFlags      ValidFlags;
    } CameraAttribute_t;

    CWiaVideoProperties(const TCHAR *pszOptionalWiaDeviceID) :
        pMediaType(NULL),
        pVideoInfoHeader(NULL),
        dwFrameRate(0),
        bPictureAttributesUsed(FALSE),
        bCameraAttributesUsed(FALSE),
        PreferredWidth(0),
        PreferredHeight(0),
        PreferredFrameRate(0),
        PreferredSettingsMask(0)
    {
        ZeroMemory(&Brightness, sizeof(Brightness));
        ZeroMemory(&Contrast, sizeof(Contrast));
        ZeroMemory(&Hue, sizeof(Hue));
        ZeroMemory(&Saturation, sizeof(Saturation));
        ZeroMemory(&Sharpness, sizeof(Sharpness));
        ZeroMemory(&Gamma, sizeof(Gamma));
        ZeroMemory(&ColorEnable, sizeof(ColorEnable));
        ZeroMemory(&WhiteBalance, sizeof(WhiteBalance));
        ZeroMemory(&BacklightCompensation, sizeof(BacklightCompensation));
        ZeroMemory(&Pan, sizeof(Pan));
        ZeroMemory(&Tilt, sizeof(Tilt));
        ZeroMemory(&Roll, sizeof(Roll));
        ZeroMemory(&Zoom, sizeof(Zoom));
        ZeroMemory(&Exposure, sizeof(Exposure));
        ZeroMemory(&Iris, sizeof(Iris));
        ZeroMemory(&Focus, sizeof(Focus));
        ZeroMemory(szWiaDeviceID, sizeof(szWiaDeviceID));
        ZeroMemory(&PreferredMediaSubType, sizeof(PreferredMediaSubType));

        if (pszOptionalWiaDeviceID)
        {
            _tcsncpy(szWiaDeviceID, 
                     pszOptionalWiaDeviceID,
                     sizeof(szWiaDeviceID) / sizeof(TCHAR) - 1);
        }
    }

    virtual ~CWiaVideoProperties()
    {
        if (pMediaType)
        {
            DeleteMediaType(pMediaType);
            pMediaType             = NULL;
            pVideoInfoHeader       = NULL;
            dwFrameRate            = 0;
            bPictureAttributesUsed = FALSE;
            bCameraAttributesUsed  = FALSE;
        }
    }

    TCHAR               szWiaDeviceID[MAX_PATH + 1];
    DWORD               PreferredSettingsMask;
    GUID                PreferredMediaSubType;
    LONG                PreferredWidth;
    LONG                PreferredHeight;
    LONG                PreferredFrameRate;

    AM_MEDIA_TYPE       *pMediaType;
    VIDEOINFOHEADER     *pVideoInfoHeader;
    DWORD               dwFrameRate;

    BOOL                bPictureAttributesUsed;
    PictureAttribute_t  Brightness;
    PictureAttribute_t  Contrast;
    PictureAttribute_t  Hue;
    PictureAttribute_t  Saturation;
    PictureAttribute_t  Sharpness;
    PictureAttribute_t  Gamma;
    PictureAttribute_t  ColorEnable;
    PictureAttribute_t  WhiteBalance;
    PictureAttribute_t  BacklightCompensation;

    BOOL                bCameraAttributesUsed;
    CameraAttribute_t   Pan;
    CameraAttribute_t   Tilt;
    CameraAttribute_t   Roll;
    CameraAttribute_t   Zoom;
    CameraAttribute_t   Exposure;
    CameraAttribute_t   Iris;
    CameraAttribute_t   Focus;
};


/////////////////////////////////////////////////////////////////////////////
// CDShowUtil

class CDShowUtil
{
public:

    static HRESULT SizeVideoToWindow(HWND         hwnd,
                                     IVideoWindow *pVideoWindow,
                                     BOOL         bStretchToFit);

    static HRESULT ShowVideo(BOOL         bShow,
                             IVideoWindow *pVideoWindow);

    static HRESULT SetVideoWindowParent(HWND         hwndParent,
                                        IVideoWindow *pVideoWindow,
                                        LONG         *plOldWindowStyle);

    static HRESULT FindDeviceByEnumPos(LONG          lEnumPos,
                                       CSimpleString *pstrDShowDeviceID,
                                       CSimpleString *pstrFriendlyName,
                                       IMoniker      **ppDeviceMoniker);

    static HRESULT FindDeviceByFriendlyName(const CSimpleString *pstrFriendlyName,
                                            LONG                *plEnumPos,
                                            CSimpleString       *pstrDShowDeviceID,
                                            IMoniker            **ppDeviceMoniker);

    static HRESULT FindDeviceByWiaID(class CWiaLink      *pWiaLink,
                                     const CSimpleString *pstrWiaDeviceID,
                                     CSimpleString       *pstrFriendlyName,
                                     LONG                *plEnumPos,
                                     CSimpleString       *pstrDShowDeviceID,
                                     IMoniker            **ppDeviceMoniker);

    static HRESULT CreateGraphBuilder(ICaptureGraphBuilder2 **ppCaptureGraphBuilder,
                                      IGraphBuilder         **ppGraphBuilder);

    static HRESULT GetMonikerProperty(IMoniker      *pMoniker,
                                      LPCWSTR       pwszProperty,
                                      CSimpleString *pstrProperty);

    static HRESULT SetPreferredVideoFormat(IPin                 *pCapturePin,
                                           const GUID           *pPreferredSubType,
                                           LONG                 lPreferredWidth,
                                           LONG                 lPreferredHeight,
                                           CWiaVideoProperties  *pVideoProperties);

    static HRESULT SetFrameRate(IPin                 *pCapturePin,
                                LONG                 lNewFrameRate,
                                CWiaVideoProperties  *pVideoProperties);

    static HRESULT GetFrameRate(IPin   *pCapturePin,
                                LONG   *plFrameRate);

    static HRESULT GetPin(IBaseFilter       *pFilter,
                          PIN_DIRECTION     PinDirection,
                          IPin              **ppPin);

    static HRESULT GetVideoProperties(IBaseFilter         *pCaptureFilter,
                                      IPin                *pCapturePin,
                                      CWiaVideoProperties *pVideoProperties);

    static HRESULT SetPictureAttribute(IBaseFilter                             *pCaptureFilter,
                                       CWiaVideoProperties::PictureAttribute_t *pPictureAttribute,
                                       LONG                                    lNewValue,
                                       VideoProcAmpFlags                       lNewFlag);

    static HRESULT SetCameraAttribute(IBaseFilter                             *pCaptureFilter,
                                      CWiaVideoProperties::CameraAttribute_t  *pCameraAttribute,
                                      LONG                                    lNewValue,
                                      CameraControlFlags                      lNewFlag);

    static HRESULT TurnOffGraphClock(IGraphBuilder *pGraphBuilder);

    static void GUIDToString(const GUID &clsid,
                             WCHAR      *pwszGUID,
                             ULONG      ulNumChars);

    static void DumpCaptureMoniker(IMoniker *pCaptureDeviceMoniker);

    static void MyDumpVideoProperties(CWiaVideoProperties  *pVideoProperties);

    static void MyDumpGraph(LPCTSTR       Description,
                            IGraphBuilder *pGraphBuilder);

    static void MyDumpFilter(IBaseFilter *pFilter);

    static void MyDumpAllPins(IBaseFilter *const pFilter);

    static void MyDumpPin(IPin *pPin);

private:

    static HRESULT FindDeviceGeneric(UINT          uiFindFlag,
                                     CSimpleString *pstrDShowDeviceID,
                                     LONG          *plEnumPos,
                                     CSimpleString *pstrFriendlyName,
                                     IMoniker      **ppDeviceMoniker);

    static HRESULT GetDeviceProperty(IPropertyBag  *pPropertyBag,
                                     LPCWSTR       pwszProperty,
                                     CSimpleString *pstrProperty);
};

#endif // _DSHOWUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\flnfile.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       FLNFILE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/13/1999
 *
 *  DESCRIPTION: Find the lowest numbered files in a given directory with a given
 *               root filename.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "flnfile.h"

///////////////////////////////
// DoesFileExist
//
bool NumberedFileName::DoesFileExist(LPCTSTR pszFileName)
{
    DWORD dwFileAttr = 0;
    DWORD dwError    = 0;

    dwFileAttr = GetFileAttributes(pszFileName);

    if (dwFileAttr == 0xFFFFFFFF) 
    {
         // file not found

        dwError = GetLastError();
        return false;
    }
    
    if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY) 
    {
        //
        // file name is a directory
        //
        return false;
    }    
    
    return true;
}

///////////////////////////////
// ConstructFilename
//
bool NumberedFileName::ConstructFilename(LPTSTR  pszFile, 
                                         DWORD   cchFile,
                                         LPCTSTR pszDirectory, 
                                         LPCTSTR pszFilename, 
                                         LPCTSTR pszNumber, 
                                         LPCTSTR pszExtension )
{
    if ((pszFile == NULL) || (cchFile == 0))
    {
        return false;
    }

    CSimpleString FullFilePath;

    *pszFile = TEXT('\0');

    if (pszDirectory && *pszDirectory)
    {
        //
        // Start with the directory name
        //

        FullFilePath += CSimpleString(pszDirectory);

        //
        // Ensure there is a trailing slash
        //
        if (!FullFilePath.MatchLastCharacter(TEXT('\\')))
        {
            FullFilePath += CSimpleString(TEXT("\\"));
        }
    }

    if (pszFilename && *pszFilename)
    {
        //
        // Append the filename
        //
        FullFilePath += CSimpleString(pszFilename);
    }

    if (pszNumber && *pszNumber)
    {
        //
        // Append a space
        //
        FullFilePath += CSimpleString(TEXT(" "));

        //
        // Append the number to the file name
        //
        FullFilePath += CSimpleString(pszNumber);

    }

    if (pszExtension && *pszExtension)
    {
        //
        // Append the extension's . if necessary
        //
        if (*pszExtension != TEXT('.'))
        {
            FullFilePath += CSimpleString(TEXT("."));
        }

        //
        // Append the extension
        //
        FullFilePath += CSimpleString(pszExtension);
    }

    if ((pszFile) && (cchFile > 0))
    {
        _tcsncpy(pszFile, 
                 CSimpleStringConvert::NaturalString(FullFilePath).String(),
                 cchFile - 1);

        pszFile[cchFile - 1] = '\0';
    }

    return(lstrlen(pszFile) != 0);
}

///////////////////////////////
// FindLowestAvailableFileSequence
//
int NumberedFileName::FindLowestAvailableFileSequence(LPCTSTR pszDirectory, 
                                                      LPCTSTR pszFilename, 
                                                      LPCTSTR pszNumberFormat, 
                                                      LPCTSTR pszExtension, 
                                                      bool    bAllowUnnumberedFile, 
                                                      int     nCount, 
                                                      int     nStart)
{
    DBG_FN("NumberedFileName::FindLowestAvailableFileSequence");

    if (!pszDirectory       || 
        !pszFilename        || 
        !pszNumberFormat    || 
        !nCount             || 
        !*pszDirectory      || 
        !*pszFilename       || 
        !*pszNumberFormat)
    {
        return -1;
    }

    TCHAR szFile[MAX_PATH + 1] = {0};

    if (nCount == 1 && bAllowUnnumberedFile)
    {
        if (ConstructFilename(szFile, 
                              sizeof(szFile) / sizeof(szFile[0]) - 1, 
                              pszDirectory,
                              pszFilename,
                              NULL,
                              pszExtension))
        {
            if (!DoesFileExist(szFile))
            {
                // 0 is a special return value that says "Don't put a number on this file"
                return 0;
            }
        }
    }

    int i = nStart;
    //
    // Make sure i is a valid number
    //
    if (i <= 0)
    {
        i = 1;
    }

    while (i<0x7FFFFFFF)
    {
        //
        // Assume we'll be able to store the sequence
        //
        bool bEnoughRoom = true;

        for (int j = 0; j < nCount && bEnoughRoom; j++)
        {
            TCHAR szNumber[31 + 1] = {0};

            _sntprintf(szNumber, 
                       sizeof(szNumber) / sizeof(szNumber[0]) - 1,
                       pszNumberFormat, 
                       i + j);

            if (ConstructFilename(szFile, 
                                  sizeof(szFile) / sizeof(szFile[0]) - 1,
                                  pszDirectory,
                                  pszFilename,
                                  szNumber,
                                  pszExtension))
            {
                if (DoesFileExist(szFile))
                {
                    //
                    // Didn't make it
                    //
                    bEnoughRoom = false;

                    //
                    // Skip this series.  No need to start at the bottom.
                    //
                    i += j;
                }
            }
        }

        //
        // If we made it through, return the base number, otherwise increment by one
        //
        if (bEnoughRoom)
        {
            return i;
        }
        else
        {
            i++;
        }
    }

    return -1;
}

///////////////////////////////
// CreateNumberedFileName
//
bool NumberedFileName::CreateNumberedFileName(DWORD     dwFlags, 
                                              LPTSTR    pszPathName, 
                                              DWORD     cchPathName,
                                              LPCTSTR   pszDirectory, 
                                              LPCTSTR   pszFilename, 
                                              LPCTSTR   pszNumberFormat, 
                                              LPCTSTR   pszExtension, 
                                              int       nNumber )
{
    if (nNumber == 0)
    {
        return ConstructFilename(pszPathName,
                                 cchPathName,
                                 (dwFlags&FlagOmitDirectory) ? NULL : pszDirectory,
                                 pszFilename,
                                 NULL,
                                 (dwFlags&FlagOmitExtension) ? NULL : pszExtension);
    }
    else
    {
        TCHAR szNumber[31 + 1] = {0};

        if (pszNumberFormat)
        {
            _sntprintf(szNumber, 
                       sizeof(szNumber)/sizeof(szNumber[0]) - 1, 
                       pszNumberFormat, 
                       nNumber);

            //
            // Paranoid:  NULL terminate
            //
            szNumber[sizeof(szNumber)/sizeof(szNumber[0]) - 1] = '\0';
        }

        return ConstructFilename(pszPathName,
                                 cchPathName,
                                 (dwFlags & FlagOmitDirectory) ? NULL : pszDirectory,
                                 pszFilename,
                                 szNumber,
                                 (dwFlags & FlagOmitExtension) ? NULL : pszExtension);
    }
}

///////////////////////////////
// GenerateLowestAvailableNumberedFileName
//
int NumberedFileName::GenerateLowestAvailableNumberedFileName(DWORD     dwFlags, 
                                                              LPTSTR    pszPathName, 
                                                              DWORD     cchPathName,
                                                              LPCTSTR   pszDirectory, 
                                                              LPCTSTR   pszFilename, 
                                                              LPCTSTR   pszNumberFormat, 
                                                              LPCTSTR   pszExtension, 
                                                              bool      bAllowUnnumberedFile, 
                                                              int       nStart )
{
    //
    // -1 is an error.  Default to failure
    //
    int nResult = -1;

    //
    // Find the lowest available file number
    //
    int nLowest = FindLowestAvailableFileSequence(pszDirectory, 
                                                  pszFilename, 
                                                  pszNumberFormat, 
                                                  pszExtension,
                                                  bAllowUnnumberedFile, 
                                                  1, 
                                                  nStart);
    if (nLowest >= 0)
    {
        //
        // If we can create the filename, return the number of the file
        //
        if (CreateNumberedFileName(dwFlags, 
                                   pszPathName, 
                                   cchPathName,
                                   pszDirectory, 
                                   pszFilename, 
                                   pszNumberFormat, 
                                   pszExtension, 
                                   nLowest))
        {
            //
            // Return the file's number
            //
            nResult = nLowest;
        }
    }

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\prvgrph.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       PrvGrph.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Implements preview graph for capture still images
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop

///////////////////////////////
//
// Constants
//
///////////////////////////////

//
// Amount of time we are willing to wait to take a picture
//
const UINT TIMEOUT_TAKE_PICTURE         = 1000 * 5; // 5 seconds

//
// These 2 values define how many media sample packets the still
// filter should cache
//
const UINT CAPTURE_NUM_SAMPLES_TO_CACHE = 6;
const UINT STILL_NUM_SAMPLES_TO_CACHE   = 1;

//
// Max amount of time we wait for us to transition into a running state
//
const UINT STATE_TRANSITION_TIMEOUT     = 1000 * 2; // 2 seconds


//
// Video size preferrences.  This will not affect DV devices, only
// USB WebCams that support changing their format.
//
const GUID DEFAULT_MEDIASUBTYPE         = MEDIASUBTYPE_IYUV;
const LONG MIN_VIDEO_WIDTH              = 176;
const LONG MIN_VIDEO_HEIGHT             = 144;
const LONG MAX_VIDEO_WIDTH              = 640;
const LONG MAX_VIDEO_HEIGHT             = 480;

const LONG PREFERRED_VIDEO_WIDTH        = 176;
const LONG PREFERRED_VIDEO_HEIGHT       = 144;

const LONG PREFERRED_FRAME_RATE         = 30;  // ideal frame rate
const LONG BACKUP_FRAME_RATE            = 15;  // less than ideal frame rate.


///////////////////////////////
// CPreviewGraph Constructor
//
CPreviewGraph::CPreviewGraph() :
        m_hwndParent(NULL),
        m_lStillPinCaps(0),
        m_lStyle(0),
        m_bPreviewVisible(TRUE),
        m_CurrentState(WIAVIDEO_NO_VIDEO),
        m_pWiaVideo(NULL),
        m_bSizeVideoToWindow(FALSE),
        m_pVideoProperties(NULL)
{
    DBG_FN("CPreviewGraph::CPreviewGraph");
}

///////////////////////////////
// CPreviewGraph Destructor
//
CPreviewGraph::~CPreviewGraph()
{
    DBG_FN("CPreviewGraph::~CPreviewGraph");

    //
    // Term the object if it is not already terminated.
    //

    Term();
}

///////////////////////////////
// Init
//
HRESULT CPreviewGraph::Init(CWiaVideo  *pWiaVideo)
{
    HRESULT hr = S_OK;

    if (pWiaVideo == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::Init, received NULL CWiaVideo "
                         "param, this should never happen"));
    }

    if (pWiaVideo)
    {
        m_pWiaVideo = pWiaVideo;
    }

    m_StillProcessor.Init(this);

    CreateHiddenWindow();

    return hr;
}

///////////////////////////////
// Term
//
HRESULT CPreviewGraph::Term()
{
    HRESULT hr = S_OK;

    m_StillProcessor.Term();

    if (GetState() != WIAVIDEO_NO_VIDEO)
    {
        DestroyVideo();
    }

    DestroyHiddenWindow();

    m_pWiaVideo = NULL;

    return hr;
}

///////////////////////////////
// GetImagesDirectory
//
HRESULT CPreviewGraph::GetImagesDirectory(CSimpleString *pImagesDirectory)
{
    DBG_FN("CPreviewGraph::GetImagesDirectory");

    ASSERT(pImagesDirectory != NULL);

    HRESULT hr = S_OK;

    if (pImagesDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::GetImagesDirectory received a "
                         "NULL parameter"));
    }

    if (hr == S_OK)
    {
        *pImagesDirectory = m_strImagesDirectory;
    }

    return hr;
}

///////////////////////////////
// SetImagesDirectory
//
HRESULT CPreviewGraph::SetImagesDirectory(
                                    const CSimpleString *pImagesDirectory)
{
    DBG_FN("CPreviewGraph::SetImagesDirectory");

    ASSERT(pImagesDirectory != NULL);

    HRESULT hr = S_OK;

    if (pImagesDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::SetImagesDirectory received a "
                         "NULL parameter"));
    }

    if (hr == S_OK)
    {
        m_strImagesDirectory = *pImagesDirectory;

        // 
        // If the graph is created, then we should set the image directory 
        // so that the next image captured will be saved to the new directory.
        //
        if (GetState() == WIAVIDEO_NO_VIDEO)
        {
            hr = m_StillProcessor.CreateImageDir(&m_strImagesDirectory);
            CHECK_S_OK2(hr, 
                    ("CPreviewGraph::SetImagesDirectory, failed to "
                     "create images directory '%ls'",
                     CSimpleStringConvert::WideString(m_strImagesDirectory)));
        }
    }

    return hr;
}

///////////////////////////////
// GetState
//
WIAVIDEO_STATE CPreviewGraph::GetState()
{
    return m_CurrentState;
}

///////////////////////////////
// SetState
//
HRESULT CPreviewGraph::SetState(WIAVIDEO_STATE  NewState)
{
    m_CurrentState = NewState;

    return S_OK;
}

///////////////////////////////
// CreateVideo
//
HRESULT CPreviewGraph::CreateVideo(const TCHAR  *pszOptionalWiaDeviceID,
                                   IMoniker     *pCaptureDeviceMoniker,
                                   HWND         hwndParent, 
                                   BOOL         bStretchToFitParent,
                                   BOOL         bAutoPlay)
{
    DBG_FN("CPreviewGraph::CreateVideo");

    HRESULT         hr      = S_OK;
    WIAVIDEO_STATE  State   = GetState();

    if ((m_strImagesDirectory.Length() == 0)    ||
        (pCaptureDeviceMoniker         == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo, received NULL param"));
        return hr;
    }
    else if ((State == WIAVIDEO_DESTROYING_VIDEO) ||
             (State == WIAVIDEO_CREATING_VIDEO))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo, cannot create video, "
                         "still in the process of creating or destroying "
                         "it, CurrentState = '%lu'", State));

        return hr;
    }
    else if (State != WIAVIDEO_NO_VIDEO)
    {
        //
        // If we are not in the process of creating or destorying the 
        // video, and our state is not NO_VIDEO, then assume everything
        // is okay, and return S_OK.
        //
        return S_OK;
    }

    ASSERT(m_strImagesDirectory.Length() != 0);
    ASSERT(pCaptureDeviceMoniker         != NULL);

    //
    // Set our state to indicate we are creating the video
    //
    SetState(WIAVIDEO_CREATING_VIDEO);

    //
    // Create our image directory
    //

    if (SUCCEEDED(hr))
    {
        //
        // Save the parent window handle.
        //
        m_hwndParent         = hwndParent;
        m_bSizeVideoToWindow = bStretchToFitParent;
    }

    if (SUCCEEDED(hr))
    {
        m_pVideoProperties = new CWiaVideoProperties(pszOptionalWiaDeviceID);

        if (m_pVideoProperties == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo, failed to allocate memory "
                             "for CWiaVideoProperties.  Cannot create video"));
        }
    }

    //
    // Build the DirectShow video preview graph
    //

    if (SUCCEEDED(hr))
    {
        hr = BuildPreviewGraph(pCaptureDeviceMoniker, bStretchToFitParent);

        CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo failed to build the "
                         "preview graph"));
    }

    if (SUCCEEDED(hr))
    {
        //
        // Video graph exists, update our state
        //
        SetState(WIAVIDEO_VIDEO_CREATED);

        //
        // Begin playback automatically
        //
        if (bAutoPlay)
        {
            hr = Play();

            CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo failed begin "
                             "playback"));
        }
    }

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("CreateVideo failed to build the graph, tearing it "
                         "down"));

        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// DestroyVideo
//
HRESULT CPreviewGraph::DestroyVideo()
{
    DBG_FN("CPreviewGraph::DestroyVideo");

    HRESULT hr = S_OK;

    SetState(WIAVIDEO_DESTROYING_VIDEO);

    //
    // Stop the graph first
    //
    Stop();

    //
    // Delete the video properties object.
    //
    if (m_pVideoProperties)
    {
        delete m_pVideoProperties;
        m_pVideoProperties = NULL;
    }

    //
    // Destroys the preview graph and all DShow components associated with it.
    // Even if these are already gone, there is no harm in calling it.
    //
    TeardownPreviewGraph();

    m_hwndParent   = NULL;

    m_pVideoControl         = NULL;       
    m_pStillPin             = NULL;
    m_pCapturePinSnapshot   = NULL; 
    m_pStillPinSnapshot     = NULL;   
    m_pPreviewVW            = NULL; 
    m_pCaptureGraphBuilder  = NULL;
    m_pGraphBuilder         = NULL;
    m_pCaptureFilter        = NULL;
    m_lStillPinCaps         = 0; 
    m_lStyle                = 0;

    SetState(WIAVIDEO_NO_VIDEO);

    //
    // We purposely put this here so that it does NOT get reset after 
    // destroying the video.  This should remain the lifetime of this
    // object instance, unless changed by the user via the
    // get/put_PreviewVisible properties in CWiaVideo.
    //
    m_bPreviewVisible       = m_bPreviewVisible;

    return hr;
}

///////////////////////////////
// TakePicture
//
HRESULT CPreviewGraph::TakePicture(CSimpleString *pstrNewImageFileName)
{
    DBG_FN("CPreviewGraph::TakePicture");

    WIAVIDEO_STATE State = GetState();

    HRESULT         hr = S_OK;
    CSimpleString   strNewImageFullPath;

    if ((State != WIAVIDEO_VIDEO_PLAYING) && 
        (State != WIAVIDEO_VIDEO_PAUSED))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, cannot take a picture "
                         "because we are in an incorrect state, "
                         "current state = '%lu'", State));

        return hr;
    }

    ASSERT((State == WIAVIDEO_VIDEO_PLAYING) || 
           (State == WIAVIDEO_VIDEO_PAUSED));

    //
    // Set this to TRUE.  We reset it when we return from our 
    // WaitForNewImage fn. This allows us to distinguish between 
    // a user initiated take picture event, and an async take picture 
    // event generated by a hardware button push.
    //
    m_StillProcessor.SetTakePicturePending(TRUE);

    //
    // If the device is internal triggerable, trigger it
    // The triggered image will be delivered to the still pin and will
    // then travel down stream until it reaches the WIA StreamSnapshot filter,
    // which will process the image.
    //

    if (m_pVideoControl && (m_lStillPinCaps & VideoControlFlag_Trigger))
    {
        //
        // ignore the time stamp here since we do not need it.
        //

        hr = m_pVideoControl->SetMode(m_pStillPin, VideoControlFlag_Trigger);

        CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, attempted to trigger "
                         "the still pin on the capture filter to take a "
                         "picture, but it failed"));

    }
    else
    {
        if (m_pCapturePinSnapshot)
        {
            hr = m_pCapturePinSnapshot->Snapshot(GetMessageTime());

            CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, attempted to "
                             "trigger the WIA Image filter to take a "
                             "snapshot of the video stream, but it "
                             "failed"));
        }
        else
        {
            hr = E_FAIL;

            CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, attempted to call "
                             "snapshot on the WIA Image filter, but the "
                             "filter pointer is NULL"));
        }
    }

    //
    // If we are taking the picture via the still pin, then taking a 
    // picture is an asynchronous operation, and we have to wait for 
    // the StillProcessor's callback function to complete its work.  
    // It will signal us when it's done. If we are taking the picture 
    // via the WIA image filter, then the operation is  synchronous, 
    // in which case this wait function will return immediately.
    // 
    hr = m_StillProcessor.WaitForNewImage(TIMEOUT_TAKE_PICTURE,
                                          &strNewImageFullPath);

    CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture failed waiting for new "
                     "still image to arrive, our timeout was '%d'",
                     TIMEOUT_TAKE_PICTURE));

    //
    // Set this to TRUE.  We reset it when we return from our 
    // WaitForNewImage fn.
    //
    m_StillProcessor.SetTakePicturePending(FALSE);

    if ((pstrNewImageFileName) && (strNewImageFullPath.Length() > 0))
    {
        *pstrNewImageFileName = strNewImageFullPath;
    }

    CHECK_S_OK(hr);
    return hr;
}

///////////////////////////////
// ResizeVideo
//
HRESULT CPreviewGraph::ResizeVideo(BOOL bSizeVideoToWindow)
{
    DBG_FN("CPreviewGraph::ResizeVideo");

    RECT    rc = {0};
    HRESULT hr = S_OK;

    //
    // Check for invalid args
    //

    if ((m_hwndParent) && (m_pPreviewVW))
    {
        hr = CDShowUtil::SizeVideoToWindow(m_hwndParent,
                                           m_pPreviewVW,
                                           bSizeVideoToWindow);

        m_bSizeVideoToWindow = bSizeVideoToWindow;

        CHECK_S_OK2(hr, ("CPreviewGraph::ResizeVideo, failed to resize "
                         "video window"));
    }
    else
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::ResizeVideo, either the parent "
                         "window is NULL (0x%08lx), or the Video Preview "
                         "pointer is NULL (0x%08lx)",
                         m_hwndParent, m_pPreviewVW));
    }
    
    return hr;
}


///////////////////////////////
// ShowVideo
//
HRESULT CPreviewGraph::ShowVideo(BOOL bShow)
{
    DBG_FN("CPreviewGraph::ShowVideo");

    HRESULT hr = S_OK;

    if (m_pPreviewVW)
    {
        hr = CDShowUtil::ShowVideo(bShow, m_pPreviewVW);

        CHECK_S_OK2(hr, ("CPreviewGraph::ShowVideo failed"));
    }

    m_bPreviewVisible = bShow;

    return hr;
}

///////////////////////////////
// Play
//
HRESULT CPreviewGraph::Play()
{
    DBG_FN("CPreviewGraph::Play");

    HRESULT             hr    = S_OK;
    WIAVIDEO_STATE      State = GetState();

    if ((State != WIAVIDEO_VIDEO_CREATED) && 
        (State != WIAVIDEO_VIDEO_PAUSED))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::Play, cannot begin playback "
                         "because we are in an incorrect state, "
                         "current state = '%lu'", State));

        return hr;
    }
    else if (State == WIAVIDEO_VIDEO_PLAYING)
    {
        DBG_WRN(("CPreviewGraph::Play, play was called, but we are already "
                 "playing, doing nothing."));

        return hr;
    }

    ASSERT(m_pGraphBuilder != NULL);

    if (m_pGraphBuilder == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::Play, m_pGraphBuilder is NULL"));
    }

    if (hr == S_OK)
    {
        CComQIPtr<IMediaControl, &IID_IMediaControl> pMC(m_pGraphBuilder);

        if (pMC)
        {
            DBG_TRC(("CPreviewGraph::Play ***Beginning Playback ***"));

            //
            // Set the graph running...
            //
            hr = pMC->Run();

            if (hr == S_OK)
            {
                DBG_TRC(("CPreviewGraph::Play, graph is running..."));

                SetState(WIAVIDEO_VIDEO_PLAYING);
            }
            else if (hr == S_FALSE)
            {
                OAFilterState   FilterState;

                DBG_TRC(("CPreviewGraph::Play, Waiting '%lu' millisec for "
                         "graph to transition to running state", 
                         STATE_TRANSITION_TIMEOUT));

                //
                // Give the graph a chance to transition into the running 
                // state. Note that this function will wait for 
                // STATE_TRANSITION_TIMEOUT milliseconds, so make sure that
                // this is not a long wait, otherwise the caller could
                // appear unresponsive.
                //
                hr = pMC->GetState(STATE_TRANSITION_TIMEOUT, &FilterState);

                if ((hr == S_OK) && (FilterState == State_Running))
                {
                    SetState(WIAVIDEO_VIDEO_PLAYING);

                    DBG_TRC(("CPreviewGraph::Play, graph is running..."));
                }
                else if (hr == VFW_S_STATE_INTERMEDIATE)
                {
                    //
                    // We fudge our state a little here on the assumption 
                    // that the transition to the run state by DShow is
                    // taking a little longer, but eventually will transition 
                    // to running.
                    //
                    SetState(WIAVIDEO_VIDEO_PLAYING);

                    DBG_TRC(("CPreviewGraph::Play, still transitioning to "
                             "play state..."));
                }
                else
                {
                    CHECK_S_OK2(hr, ("CPreviewGraph::Play, "
                                     "IMediaControl::GetState failed..."));
                }

                hr = S_OK;
            }
            else
            {
                CHECK_S_OK2(hr, ("CPreviewGraph::Play, "
                                 "IMediaControl::Run failed"));
            }
        }
        else
        {
            DBG_ERR(("CPreviewGraph::Play, Unable to get "
                     "MediaControl interface"));
        }
    }

    //
    // If the user of this object specified in the past that the video window
    // should be visible, then show it, otherwise, make sure it is hidden.
    //

    ResizeVideo(m_bSizeVideoToWindow);
    ShowVideo(m_bPreviewVisible);

    return hr;
}


///////////////////////////////
// Stop
//
HRESULT CPreviewGraph::Stop()
{
    DBG_FN("CPreviewGraph::Stop");

    HRESULT hr = S_OK;

    if (m_pGraphBuilder)
    {
        CComQIPtr<IMediaControl, &IID_IMediaControl> pMC(m_pGraphBuilder);

        if (pMC)
        {
            hr = pMC->Stop();
            CHECK_S_OK2(hr, ("CPreviewGraph::Stop, IMediaControl::Stop "
                             "failed"));
        }
        else
        {
            hr = E_FAIL;
            DBG_ERR(("CPreviewGraph::Stop unable to get MediaControl "
                     "interface, returning hr = 0x%08lx", hr));
        }
    }

    CHECK_S_OK(hr);
    return hr;
}

///////////////////////////////
// Pause
//
HRESULT CPreviewGraph::Pause()
{
    DBG_FN("CPreviewGraph::Pause");

    HRESULT         hr    = S_OK;
    WIAVIDEO_STATE  State = GetState();

    if ((State != WIAVIDEO_VIDEO_CREATED) && 
        (State != WIAVIDEO_VIDEO_PLAYING))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::Pause, cannot begin pause "
                         "because we are in an incorrect state, "
                         "current state = '%lu'", State));

        return hr;
    }
    else if (State == WIAVIDEO_VIDEO_PAUSED)
    {
        DBG_WRN(("CPreviewGraph::Pause, pause was called, but we are already "
                 "paused, doing nothing."));

        return hr;
    }

    CComQIPtr<IMediaControl, &IID_IMediaControl> pMC(m_pGraphBuilder);

    if (pMC)
    {
        hr = pMC->Pause();

        if (SUCCEEDED(hr))
        {
            SetState(WIAVIDEO_VIDEO_PAUSED);
        }

        CHECK_S_OK2(hr, ("CPreviewGraph::Pause, failed to pause video"));
    }
    else
    {
        DBG_ERR(("CPreviewGraph::Pause unable to get MediaControl interface"));
    }

    return hr;
}

///////////////////////////////
// ProcessAsyncImage
//
// Called by CPreviewGraph
// when user presses hardware
// button and it is delivered to
// Still Pin.
//
HRESULT CPreviewGraph::ProcessAsyncImage(const CSimpleString *pNewImage)
{
    DBG_FN("CPreviewGraph::ProcessAsyncImage");

    HRESULT hr = S_OK;

    if (m_pWiaVideo)
    {
        hr = m_pWiaVideo->ProcessAsyncImage(pNewImage);
    }
    else
    {
        DBG_WRN(("CPreviewGraph::ProcessAsyncImage failed, m_pWiaVideo "
                 "is NULL"));
    }

    return hr;
}


///////////////////////////////
// GetStillPinCaps
//
HRESULT CPreviewGraph::GetStillPinCaps(IBaseFilter     *pCaptureFilter,
                                       IPin            **ppStillPin,
                                       IAMVideoControl **ppVideoControl,
                                       LONG            *plCaps)
{
    DBG_FN("CPreviewGraph::GetStillPinCaps");

    HRESULT hr = S_OK;

    ASSERT(pCaptureFilter != NULL);
    ASSERT(ppStillPin     != NULL);
    ASSERT(ppVideoControl != NULL);
    ASSERT(plCaps         != NULL);

    if ((pCaptureFilter == NULL) ||
        (ppStillPin     == NULL) ||
        (ppVideoControl == NULL) ||
        (plCaps         == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::GetStillPinCaps received a NULL "
                         "param"));
    }

    if (hr == S_OK)
    {
        // 
        // Attempt to find the still pin on the capture filter
        // This will decide the type of graph we are going to build
        //
        hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_STILL,
                                                   &MEDIATYPE_Video,
                                                   pCaptureFilter,
                                                   IID_IPin,
                                                   (void **)ppStillPin);
    }

    if (hr == S_OK)
    {
        // determine if it is triggerable or not.
        hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_STILL,
                                                   &MEDIATYPE_Video,
                                                   pCaptureFilter,
                                                   IID_IAMVideoControl,
                                                   (void **)ppVideoControl);

        if ((hr == S_OK) && (*ppVideoControl) && (*ppStillPin))
        {
            hr = (*ppVideoControl)->GetCaps(*ppStillPin, plCaps);
        }

        if (hr == S_OK)
        {
            //
            // If the still pin cannot be triggered externally or internally
            // then it is useless to us, so just ignore it.
            //
            if (!(*plCaps & 
                  (VideoControlFlag_ExternalTriggerEnable | 
                   VideoControlFlag_Trigger)))
            {
                *plCaps           = 0;
                *ppStillPin       = NULL;
                *ppVideoControl   = NULL;
            }
        }
    }
    else
    {
        DBG_PRT(("CPreviewGraph::GetStillPinCaps, Capture Filter does not "
                 "have a still pin"));
    }

    return hr;
}

///////////////////////////////
// AddStillFilterToGraph
//
// Add the WIA Stream Snapshot
// filter to our graph
//
HRESULT CPreviewGraph::AddStillFilterToGraph(LPCWSTR        pwszFilterName,
                                             IBaseFilter    **ppFilter,
                                             IStillSnapshot **ppSnapshot)
{
    DBG_FN("CPreviewGraph::AddStillFilterToGraph");

    HRESULT              hr = S_OK;

    ASSERT(pwszFilterName != NULL);
    ASSERT(ppFilter       != NULL);
    ASSERT(ppSnapshot     != NULL);
    
    if ((pwszFilterName == NULL) ||
        (ppFilter       == NULL) ||
        (ppSnapshot     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph received "
                         "NULL params"));
    }

    if (hr == S_OK)
    {
        //
        // Create the still filter
        //
        hr = CoCreateInstance(CLSID_STILL_FILTER,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IBaseFilter,
                              (void**)ppFilter);
    
        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph failed to "
                         "CoCreate Still Image Filter"));
    }

    if (hr == S_OK)
    {
        //
        // Add the still filter to the graph.
        //
        hr = m_pGraphBuilder->AddFilter(*ppFilter, pwszFilterName);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph failed to "
                         "add '%ls' filter to the graph", pwszFilterName));
    }

    if (hr == S_OK)
    {
        hr = (*ppFilter)->QueryInterface(IID_IStillSnapshot,
                                         (void **)ppSnapshot);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph, failed "
                         "to get IStillSnapshot interface on still filter"));
    }

    return hr;
}

///////////////////////////////
// AddColorConverterToGraph
//
// Creates the capture filter
// identified by the device ID
// and returns it.
//
HRESULT CPreviewGraph::AddColorConverterToGraph(LPCWSTR     pwszFilterName,
                                                IBaseFilter **ppColorSpaceConverter)
{
    HRESULT hr = S_OK;

    ASSERT(pwszFilterName        != NULL);
    ASSERT(ppColorSpaceConverter != NULL);

    if ((pwszFilterName        == NULL) ||
        (ppColorSpaceConverter == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddColorConverterToGraph, "
                         "received a NULL pointer"));

        return hr;
    }

    //
    // Create the Color Converter filter.
    //
    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_Colour, 
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IBaseFilter,
                              (void**) ppColorSpaceConverter);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddColorConverterToGraph failed to "
                         "create the DShow Color Converter Filter"));
    }

    if (hr == S_OK)
    {
        hr = m_pGraphBuilder->AddFilter(*ppColorSpaceConverter, pwszFilterName);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddColorConverterToGraph failed to "
                         "add '%ls' filter to the graph", pwszFilterName));
    }

    return hr;
}

///////////////////////////////
// AddVideoRendererToGraph
//
//
HRESULT CPreviewGraph::AddVideoRendererToGraph(LPCWSTR      pwszFilterName,
                                               IBaseFilter  **ppVideoRenderer)
{
    HRESULT                 hr = S_OK;

    ASSERT(pwszFilterName  != NULL);
    ASSERT(ppVideoRenderer != NULL);

    if ((pwszFilterName  == NULL) ||
        (ppVideoRenderer == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddVideoRendererToGraph, "
                         "received a NULL pointer"));

        return hr;
    }

    //
    // Create the Video Renderer filter.
    //

    if (hr == S_OK)
    {
        BOOL bUseVMR = FALSE;
        
        // 
        // even if we fail, in the worst case we don't use the vmr filter.
        // Not the end of the world.
        //
        CWiaUtil::GetUseVMR(&bUseVMR);

        if (bUseVMR)
        {
            hr = CoCreateInstance(CLSID_VideoMixingRenderer, 
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IBaseFilter,
                                  (void**) ppVideoRenderer);
        }
        else
        {
            hr = CoCreateInstance(CLSID_VideoRenderer, 
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IBaseFilter,
                                  (void**) ppVideoRenderer);
        }

        CHECK_S_OK2(hr, ("CPreviewGraph::AddVideoRendererToGraph failed to "
                         "create the DShow Video Renderer Filter"));

    }

    if (hr == S_OK)
    {
        hr = m_pGraphBuilder->AddFilter(*ppVideoRenderer, pwszFilterName);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddVideoRenderer failed to "
                         "add '%ls' filter to the graph", pwszFilterName));
    }

    return hr;
}


///////////////////////////////
// InitVideoWindows
//
// Initialize the video windows
// so that they don't have 
// an owner, and they are not
// visible.
//

HRESULT CPreviewGraph::InitVideoWindows(HWND         hwndParent,
                                        IBaseFilter  *pCaptureFilter,
                                        IVideoWindow **ppPreviewVideoWindow,
                                        BOOL         bStretchToFitParent)
{
    DBG_FN("CPreviewGraph::InitVideoWindows");

    HRESULT hr = S_OK;

    ASSERT(pCaptureFilter       != NULL);
    ASSERT(ppPreviewVideoWindow != NULL);

    if ((pCaptureFilter         == NULL) ||
        (ppPreviewVideoWindow   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::InitVideoWindows received NULL "
                         "params"));
    }


    //
    // If the still pin exists, make sure that the video renderer hanging 
    // off of this path in the graph is NOT visible.
    //

    if (hr == S_OK)
    {
        if (m_pStillPin)
        {
            CComPtr<IVideoWindow> pStillVW;
    
            hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_STILL,
                                                       &MEDIATYPE_Video,
                                                       pCaptureFilter,
                                                       IID_IVideoWindow,
                                                       (void**)&pStillVW);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::InitVideoWindows failed to "
                             "find video renderer off of the still "
                             "filter pin"));
    
            //
            // We hide the video renderer attached to the still pin stream
            // since it will contain the still image, which we save to a 
            // file, rather than show it on the desktop.
            //
            if (hr == S_OK)
            {
                CDShowUtil::ShowVideo(FALSE, pStillVW);
                CDShowUtil::SetVideoWindowParent(NULL, pStillVW, NULL);
            }
        }

        //
        // If this fails, it is not fatal
        //
        hr = S_OK;
    }


    if (hr == S_OK)
    {
        //
        // Find the video renderer hanging off of the capture pin path in 
        // the graph and make sure that it is made the child of the 
        // parent window.
    
        hr = m_pCaptureGraphBuilder->FindInterface(
                                              &PIN_CATEGORY_CAPTURE,
                                              &MEDIATYPE_Video,
                                              pCaptureFilter,
                                              IID_IVideoWindow,
                                              (void **)ppPreviewVideoWindow);
    
        CHECK_S_OK2(hr, ("CPreviewGraph::InitVideoWindows, failed to "
                         "find video renderer off of capture/preview pin"));
    }

    if (hr == S_OK)
    {
        //
        // Hide the video window before we set it's parent.
        //
        CDShowUtil::ShowVideo(FALSE, *ppPreviewVideoWindow);

        // 
        // Set the video window's parent.
        //
        CDShowUtil::SetVideoWindowParent(hwndParent, 
                                         *ppPreviewVideoWindow, 
                                         &m_lStyle);
    }

    return hr;
}

///////////////////////////////
// CreateCaptureFilter
//
// Creates the capture filter
// identified by the device ID
// and returns it.
//
HRESULT CPreviewGraph::CreateCaptureFilter(IMoniker    *pCaptureDeviceMoniker,
                                           IBaseFilter **ppCaptureFilter)
{
    DBG_FN("CPreviewGraph::CreateCaptureFilter");

    ASSERT(pCaptureDeviceMoniker != NULL);
    ASSERT(ppCaptureFilter       != NULL);

    HRESULT hr      = S_OK;

    if ((pCaptureDeviceMoniker == NULL) ||
        (ppCaptureFilter       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateCaptureFilter received NULL "
                         "params"));
    }

#ifdef DEBUG
    CDShowUtil::DumpCaptureMoniker(pCaptureDeviceMoniker);
#endif

    if (hr == S_OK)
    {
        hr = pCaptureDeviceMoniker->BindToObject(0, 
                                                 0, 
                                                 IID_IBaseFilter, 
                                                 (void**)ppCaptureFilter);
    
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateCaptureFilter failed to bind "
                         "to device's moniker."));
    }

    return hr;
}

///////////////////////////////
// AddCaptureFilterToGraph
//
HRESULT CPreviewGraph::AddCaptureFilterToGraph(IBaseFilter  *pCaptureFilter,
                                               IPin         **ppCapturePin)
{
    HRESULT         hr = S_OK;
    CComPtr<IPin>   pCapturePin;
    GUID *pMediaSubType          = NULL;
    LONG lWidth                  = 0;
    LONG lHeight                 = 0;
    LONG lFrameRate              = 0;

    ASSERT(pCaptureFilter != NULL);
    ASSERT(ppCapturePin   != NULL);

    if ((pCaptureFilter == NULL) ||
        (ppCapturePin   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddCaptureFilterToGraph, received "
                         "a NULL pointer"));

        return hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pGraphBuilder->AddFilter(pCaptureFilter, 
                                       L"Capture Filter");    

        CHECK_S_OK2(hr, ("CPreviewGraph::AddCaptureFilterToGraph, failed to "
                         "add capture filter to graph"));
    }

    //
    // Find the capture pin so we can render it.
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_CAPTURE,
                                                   &MEDIATYPE_Video,
                                                   pCaptureFilter,
                                                   IID_IPin,
                                                   (void **)&pCapturePin);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddCaptureFilterToGraph failed to "
                         "find Capture pin on capture filter"));
    }

    //
    // Get all the video properties we can about this filter.
    //
    if (SUCCEEDED(hr))
    {
        hr = CDShowUtil::GetVideoProperties(pCaptureFilter,
                                            pCapturePin,
                                            m_pVideoProperties);
    }

    //
    // We set the video width and height to the preferred setting size if 
    // the driver's inf specifies these settings.  If it does not,
    // then if the registery tells us to override the capture filter's 
    // default settings, then attempt to set it to 176x144 YUV.
    //
    // This is the order we attempt to set preferences:
    //
    // Preferred Settings --> If don't exist --> Set to Driver Default if within MIN/MAX range
    // --> otherwise attempt to set to MINIMUM width/height.
    //
    if (SUCCEEDED(hr))
    {
        GUID *pDefaultMediaSubType = &m_pVideoProperties->pMediaType->subtype;
        LONG lDefaultWidth         = m_pVideoProperties->pVideoInfoHeader->bmiHeader.biWidth;
        LONG lDefaultHeight        = m_pVideoProperties->pVideoInfoHeader->bmiHeader.biHeight;

        //
        // Validate default values are valid.
        //
        if ((lDefaultWidth <= MIN_VIDEO_WIDTH) || (lDefaultHeight <= MIN_VIDEO_HEIGHT))
        {
            lDefaultWidth  = MIN_VIDEO_WIDTH;
            lDefaultHeight = MIN_VIDEO_HEIGHT;
        }
        else if ((lDefaultWidth > MAX_VIDEO_WIDTH) || (lDefaultHeight > MAX_VIDEO_HEIGHT))
        {
            lDefaultWidth  = MIN_VIDEO_WIDTH;
            lDefaultHeight = MIN_VIDEO_HEIGHT;
        }

        //
        // If a preferred media subtype exists, use it, otherwise, use the 
        // default specified by the capture filter.
        //
        if (m_pVideoProperties->PreferredSettingsMask & PREFERRED_SETTING_MASK_MEDIASUBTYPE)
        {
            pMediaSubType = &m_pVideoProperties->PreferredMediaSubType;
            DBG_TRC(("Settings:  Using preferred media subtype -> dump of actual type is below"));
        }
        else
        {
            pMediaSubType = pDefaultMediaSubType;
            DBG_TRC(("Settings:  Using default media subtype, no preferred media subtype "
                     "found -> dump of actual type is below"));
        }

        //
        // If the default width and height exist, use it, otherwise use the 
        // default width and height, provided they are valid values
        //
        if (m_pVideoProperties->PreferredSettingsMask & PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT)
        {
            lWidth  = m_pVideoProperties->PreferredWidth;
            lHeight = m_pVideoProperties->PreferredHeight;

            //
            // Validate preferred settings are valid.  If they are not, then 
            // set to default value.
            //
            if ((lWidth  < MIN_VIDEO_WIDTH)    || 
                (lHeight < MIN_VIDEO_HEIGHT)   ||
                (lWidth  > MAX_VIDEO_WIDTH)    || 
                (lHeight > MAX_VIDEO_HEIGHT))
            {
                DBG_TRC(("Settings:  Using default video width and height, preferred settings were invalid "
                         "-> Invalid Width = %lu, Invalid Height = %lu", lWidth, lHeight));

                lWidth  = lDefaultWidth;
                lHeight = lDefaultHeight;
            }
            else
            {
                DBG_TRC(("Settings:  Using preferred settings of video width and height "
                         "-> dump of actual size is below"));
            }
        }
        else
        {
            lWidth  = lDefaultWidth;
            lHeight = lDefaultHeight;
        }

        hr = CDShowUtil::SetPreferredVideoFormat(pCapturePin, 
                                                 pMediaSubType,
                                                 lWidth,
                                                 lHeight,
                                                 m_pVideoProperties);

        if (hr != S_OK)
        {
            DBG_TRC(("Failed to set width = '%lu' and height = '%lu', "
                     "attempting to set it to its default settings of "
                     "width = '%lu', height = '%lu'",
                     lWidth, lHeight, lDefaultWidth, lDefaultHeight));

            hr = CDShowUtil::SetPreferredVideoFormat(pCapturePin, 
                                                     pDefaultMediaSubType,
                                                     lDefaultWidth,
                                                     lDefaultHeight,
                                                     m_pVideoProperties);
        }

        if (hr != S_OK)
        {
            hr = S_OK;
            DBG_WRN(("Failed on all attempts to set the preferrences of "
                     "the video properties (MediaSubType, width, height). "
                     "Attempting to continue anyway"));
        }
    }

    //
    // 6.  Attempt to set the frame rate to 30 frames per second.  If this
    //     fails for some reason, try 15 frames per second.  If that fails,
    //     then just accept the default and keep going.
    //
    if (SUCCEEDED(hr))
    {
        LONG lDefaultFrameRate = m_pVideoProperties->dwFrameRate;

        if (lDefaultFrameRate < BACKUP_FRAME_RATE)
        {
            lDefaultFrameRate = PREFERRED_FRAME_RATE;
        }

        if (m_pVideoProperties->PreferredSettingsMask & PREFERRED_SETTING_MASK_VIDEO_FRAMERATE)
        {
            lFrameRate = m_pVideoProperties->PreferredFrameRate;

            if (lFrameRate < BACKUP_FRAME_RATE)
            {
                lFrameRate = lDefaultFrameRate;
            }
        }
        else
        {
            lFrameRate = PREFERRED_FRAME_RATE;
        }

        hr = CDShowUtil::SetFrameRate(pCapturePin,
                                      lFrameRate,
                                      m_pVideoProperties);

        if (hr != S_OK)
        {
            DBG_WRN(("WARNING: Failed to set frame rate to %lu.  "
                     "This is not fatal, attempting to set it to %lu, "
                     "hr = 0x%08lx", 
                     lFrameRate, 
                     BACKUP_FRAME_RATE, 
                     hr));

            hr = CDShowUtil::SetFrameRate(pCapturePin,
                                          lDefaultFrameRate,
                                          m_pVideoProperties);

            if (hr != S_OK)
            {
                DBG_WRN(("WARNING: Failed to set frame rate to %lu.  "
                         "This is not fatal, continuing to build graph, "
                         "hr = 0x%08lx", lDefaultFrameRate, hr));
            }
        }

        //
        // This is a nice to have, but if we can't then continue
        // anyway, better low quality video than no video at all.
        //
        hr = S_OK;
    }

    //
    // Set the picture and camera attributes to our preferred settings,
    // if we can.
    // 
    if (SUCCEEDED(hr))
    {
        //
        // If this camera supports setting the picture attributes, then
        // lets make sure that we set the ones we are interested in.
        //
        // This uses the DShow IAMVideoProcAmp interface
        //
        if (m_pVideoProperties->bPictureAttributesUsed)
        {
            //
            // Make sure we are outputing color video (as opposed to black and white)
            //
            hr = CDShowUtil::SetPictureAttribute(pCaptureFilter,
                                                 &m_pVideoProperties->ColorEnable,
                                                 (LONG) TRUE,
                                                 VideoProcAmp_Flags_Manual);

            //
            // Turn on backlight compensation, to get the best video we can.
            //
            hr = CDShowUtil::SetPictureAttribute(pCaptureFilter,
                                                 &m_pVideoProperties->BacklightCompensation,
                                                 (LONG) TRUE,
                                                 VideoProcAmp_Flags_Manual);

            //
            // Make sure white balance is set to auto
            //
            hr = CDShowUtil::SetPictureAttribute(pCaptureFilter,
                                                 &m_pVideoProperties->WhiteBalance,
                                                 m_pVideoProperties->WhiteBalance.lCurrentValue,
                                                 VideoProcAmp_Flags_Auto);
        }

        //
        // If the camera supports setting the camera attributes, then set the
        // camera attributes we are interested in.
        //
        if (m_pVideoProperties->bCameraAttributesUsed)
        {
            //
            // Turn on auto exposure.
            //
            hr = CDShowUtil::SetCameraAttribute(pCaptureFilter,
                                                &m_pVideoProperties->Exposure,
                                                m_pVideoProperties->Exposure.lCurrentValue,
                                                CameraControl_Flags_Auto);
        }

        hr = S_OK;
    }


    //
    // Dump the video properties
    //
    CDShowUtil::MyDumpVideoProperties(m_pVideoProperties);

    if (SUCCEEDED(hr))
    {
        *ppCapturePin = pCapturePin;
        (*ppCapturePin)->AddRef();
    }

    return hr;
}

///////////////////////////////
// ConnectFilters
//
// This function connects the 
// capture filter's still pin
// or it's capture pin to the
// color space converter.  It
// then connects the color space
// converter to the WIA Stream
// snapshot filter.  Last, it
// renders the WIA Stream Snapshot
// filter to bring in any remaining
// required filters (such as the 
// video renderer)
//
HRESULT CPreviewGraph::ConnectFilters(IGraphBuilder  *pGraphBuilder,
                                      IPin           *pMediaSourceOutputPin,
                                      IBaseFilter    *pColorSpaceFilter,
                                      IBaseFilter    *pWiaFilter,
                                      IBaseFilter    *pVideoRenderer)
{
    HRESULT hr = S_OK;
    CComPtr<IPin>   pOutputPinToConnect;

    ASSERT(pGraphBuilder         != NULL);
    ASSERT(pMediaSourceOutputPin != NULL);
    ASSERT(pVideoRenderer        != NULL);

    if ((pGraphBuilder           == NULL) ||
        (pMediaSourceOutputPin   == NULL) ||
        (pVideoRenderer          == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters received a NULL pointer"));
    }

    pOutputPinToConnect = pMediaSourceOutputPin;

    DBG_TRC(("CPreviewGraph::ConnectFilters, PinToRender is the "
             "Capture Filter's Output Pin"));

    if (pColorSpaceFilter)
    {
        CComPtr<IPin>   pColorInputPin;
        CComPtr<IPin>   pColorOutputPin;

        //
        // Get the input pin on the color space filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pColorSpaceFilter,
                                    PINDIR_INPUT,
                                    &pColorInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "color space converter's input pin"));
        }

        //
        // Connect the Capture Filter's output pin to the color space
        // converter's input pin.
        //
        if (hr == S_OK)
        {
            hr = pGraphBuilder->Connect(pMediaSourceOutputPin,
                                        pColorInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to connect the "
                             "capture filter's pin to the color space converter pin"));
        }

        //
        // Get the output pin on the color space converter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pColorSpaceFilter,
                                    PINDIR_OUTPUT,
                                    &pColorOutputPin);

            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "color space converter's output pin"));
        }

        if (hr == S_OK)
        {
            pOutputPinToConnect = pColorOutputPin;
            DBG_TRC(("CPreviewGraph::ConnectFilters, PinToRender is the "
                     "Color Space Converter's Output Pin"));
        }

        //
        // If this fails, so what.  Try to connect WIA Stream Snapshot
        // filter anyway.
        // 

        hr = S_OK;
    }

    if (pWiaFilter)
    {
        CComPtr<IPin> pWiaInputPin;
        CComPtr<IPin> pWiaOutputPin;

        //
        // Get the input pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pWiaFilter,
                                    PINDIR_INPUT,
                                    &pWiaInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "WIA Stream Snapshot filter's input pin"));
        }

        //
        // Connect the output pin of the color space converter to the input
        // pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = pGraphBuilder->Connect(pOutputPinToConnect,
                                        pWiaInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to connect the "
                             "pin to render to the WIA Stream Snapshot "
                             "input pin"));
        }

        //
        // Get the output pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pWiaFilter,
                                    PINDIR_OUTPUT,
                                    &pWiaOutputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "WIA Stream Snapshot filter's output pin"));
        }

        if (hr == S_OK)
        {
            pOutputPinToConnect = pWiaOutputPin;
            DBG_TRC(("CPreviewGraph::ConnectFilters, PinToRender is the "
                     "WIA Stream Snapshot Filter's Output Pin"));
        }
    }

    //
    // Render the output pin of the WIA Stream Snapshot filter.
    // This completes the graph building process.
    //
    if (hr == S_OK)
    {
        CComPtr<IPin> pVideoRendererInputPin;

        //
        // Get the input pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pVideoRenderer,
                                    PINDIR_INPUT,
                                    &pVideoRendererInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "WIA Stream Snapshot filter's input pin"));
        }

        //
        // Connect the output pin of the color space converter to the input
        // pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = pGraphBuilder->Connect(pOutputPinToConnect,
                                        pVideoRendererInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to connect the "
                             "pin to render to the Video Renderer "
                             "input pin"));
        }
    }

    pOutputPinToConnect = NULL;

    return hr;
}


///////////////////////////////
// BuildPreviewGraph
//
// This builds the preview graph
// based on the device ID we
// pass it.
//
HRESULT CPreviewGraph::BuildPreviewGraph(IMoniker *pCaptureDeviceMoniker,
                                         BOOL     bStretchToFitParent)
{
    DBG_FN("CPreviewGraph::BuildPreviewGraph");

    ASSERT(pCaptureDeviceMoniker != NULL);

    HRESULT         hr = S_OK;
    CComPtr<IPin>   pCapturePin;

    if (pCaptureDeviceMoniker == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CPreviewGraph::BuildPreviewGraph "
                         "received a NULL param"));

        return hr;
    }

    //
    // This function will build one of three possible graphs.  
    //
    // (1) The capture filter does NOT have a 
    //     still pin on it (or if it does it is useless because
    //     it is not triggerable either via hardware, or programmatically)
    //
    // CaptureFilter(Capture Pin) -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //
    // (2) The capture filter has a still pin that is programmatically 
    //     triggerable.
    //     
    // CaptureFilter(CapturePin) -> Decoder -> Video Renderer
    //              (StillPin)   -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //
    // (3) The capture filter has a still pin, but it is only
    //     triggered via external hardware button.  In this case, if we 
    //     trigger a snapshot programmatically, the image comes from 
    //     the WIA Snapshot filter off of the Capture/Preview Pin.  
    //     If the hardware button is pressed, the image comes from the 
    //     WIA snapshot filter off of the StillPin.
    //
    // CaptureFilter(CapturePin) -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //              (StillPin)   -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //
    //
    DBG_TRC(("CPreviewGraph::BuildPreviewGraph - Starting to build preview "
             "graph"));

    //
    // 1. Create the capture filter based on the device ID we were given.
    //
    if (SUCCEEDED(hr))
    {
        hr = CreateCaptureFilter(pCaptureDeviceMoniker, 
                                 &m_pCaptureFilter);  // passed by ref

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "create capture filter"));
    }

    // 
    // 2. Create the DShow graph builder objects allowing us to 
    //    manipulate the graph.
    //
    if (SUCCEEDED(hr))
    {
        hr = CDShowUtil::CreateGraphBuilder(&m_pCaptureGraphBuilder,     
                                            &m_pGraphBuilder);           

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "create DShow graph builder object"));
    }

    //
    // 3. Add the capture filter to the graph.
    //
    if (SUCCEEDED(hr))
    {
        hr = AddCaptureFilterToGraph(m_pCaptureFilter, &pCapturePin);
    }

    //
    // 4. Get the Still Pin capabilities of the capture filter (if it has a 
    //    still pin at all)
    //
    if (SUCCEEDED(hr))
    {
        hr = GetStillPinCaps(m_pCaptureFilter,
                             &m_pStillPin,     
                             &m_pVideoControl, 
                             &m_lStillPinCaps);

        if (hr != S_OK)
        {
            // 
            // This is not an error condition, it simply means that the
            // capture filter does not have a still pin on it.  That's
            // okay, we can deal with that below.
            //
            hr = S_OK;
        }

    }

    //
    // Render the preview/capture stream.
    // ==================================
    //
    // If we don't have a still pin, or the still pin cannot be internally 
    // triggered, we build the following preview graph.
    //
    // CaptureFilter(Capture Pin) -> Decoder -> WIA StreamSnapshot -> Renderer
    //
    // If we do have a still pin, and it is internally triggerable, then 
    // we build the following preview graph (and add the still filter to the 
    // still pin)
    //
    // CaptureFilter(CapturePin) -> Decoder -> WIA StreamSnapshot -> Renderer
    //              (StillPin)   -> Decoder -> WIA StreamSnapshot -> Renderer
    //

    //
    // 5.  If we don't have a still pin, or it is only externally triggerable
    //     then add the WIA StreamSnapshot Filter to the preview/capture pin.
    //
    if ((m_pStillPin == NULL) ||
        (m_lStillPinCaps & VideoControlFlag_Trigger) == 0)
    {
        CComPtr<IBaseFilter> pWiaFilter;
        CComPtr<IBaseFilter> pColorSpaceConverter;
        CComPtr<IBaseFilter> pVideoRenderer;

        DBG_TRC(("CPreviewGraph::BuildPreviewGraph, capture filter does NOT have "
                 "a still pin, image captures will be triggered "
                 "through the WIA Snapshot filter"));

        if (hr == S_OK)
        {
            hr = AddColorConverterToGraph(L"Color Converter on Capture Pin Graph",
                                          &pColorSpaceConverter);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add Color Converter to graph"));

            //
            // Even if this fails, we still may be able to successfully build
            // a graph, so attempt to continue.
            // 
            hr = S_OK;
        }

        if (hr == S_OK)
        {
            hr = AddStillFilterToGraph(L"Still Filter On Capture",
                                       &pWiaFilter,
                                       &m_pCapturePinSnapshot);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Still Filter On Capture' to graph"));
        }

        if (hr == S_OK)
        {
            hr = AddVideoRendererToGraph(L"Video Renderer On Capture",
                                         &pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Video Renderer On Capture' to graph"));
        }

        if (hr == S_OK)
        {
            //
            // Connect as follows:
            // 
            // Capture Filter --> Color Space Converter --> WIA Stream Snapshot Filter
            // 
            hr = ConnectFilters(m_pGraphBuilder,
                                pCapturePin,
                                pColorSpaceConverter,
                                pWiaFilter,
                                pVideoRenderer);
        }

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "add still filter to graph off of the capture pin"));
    }
    else
    {
        CComPtr<IBaseFilter> pColorSpaceConverter;
        CComPtr<IBaseFilter> pVideoRenderer;

        if (hr == S_OK)
        {
            hr = AddColorConverterToGraph(L"Color Converter on Capture Pin Graph",
                                          &pColorSpaceConverter);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add Color Converter to graph"));

            //
            // Even if this fails, we still should be able to build the graph,
            // so continue.
            //
            hr = S_OK;
        }

        if (hr == S_OK)
        {
            hr = AddVideoRendererToGraph(L"Video Renderer On Capture",
                                         &pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Video Renderer On Capture' to graph"));
        }

        //
        // Still Pin exists, and it is triggerable, so simply render
        // the capture pin.  We connect the Still Pin below
        //
        hr = ConnectFilters(m_pGraphBuilder,
                            pCapturePin,
                            pColorSpaceConverter,
                            NULL,
                            pVideoRenderer);

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to connect "
                         "filters to render capture pin, therefore won't see video"));
    }

    CDShowUtil::MyDumpGraph(TEXT("Capture Graph before processing Still Pin (if exists)"),
                            m_pGraphBuilder);
    
    //
    // Render the Still Pin stream
    // ===========================
    //
    // If we have a still pin, then add the still filter to the 
    // graph, and render the still pin.  This will produce the 
    // following graph:
    //
    // CaptureFilter(StillPin) -> Decoder -> StillFilter -> Renderer (hidden)

    //
    // 6.  Now add the WIA Stream Snapshot filter to the still pin if it 
    //     exists.
    //
    if (SUCCEEDED(hr) && (m_pStillPin))
    {
        CComPtr<IBaseFilter> pWiaFilter;
        CComPtr<IBaseFilter> pColorSpaceConverter;
        CComPtr<IBaseFilter> pVideoRenderer;

        if (hr == S_OK)
        {
            hr = AddColorConverterToGraph(L"Color Converter on Still Pin Graph",
                                          &pColorSpaceConverter);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add Color Converter to graph"));

            //
            // This is not fatail if we fail.  Ideally we would like it in
            // here, but try going on anyway, in case we can succeed without
            // this filter.
            //
            hr = S_OK;
        }

        if (hr == S_OK)
        {
            hr = AddStillFilterToGraph(L"Still filter on Still",
                                       &pWiaFilter,
                                       &m_pStillPinSnapshot);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to add "
                             "'Still filter on Still' filter to the graph.  "
                             "Probably won't be able to capture still images"));
        }

        if (hr == S_OK)
        {
            hr = AddVideoRendererToGraph(L"Video Renderer On Still",
                                         &pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Video Renderer On Still' to graph"));
        }

        if (hr == S_OK)
        {
            //
            // Connect as follows:
            // 
            // Capture Filter --> Color Space Converter --> WIA Stream Snapshot Filter
            // 
            hr = ConnectFilters(m_pGraphBuilder,
                                m_pStillPin,
                                pColorSpaceConverter,
                                pWiaFilter,
                                pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "connect graph to Still Pin on Capture Filter.  "
                             "This will prevent us from capturing still images"));
        }
    }

    CDShowUtil::MyDumpGraph(TEXT("*** Complete Graph ***"), m_pGraphBuilder);

    //
    // 7.  Turn off the graph's clock.  We do this in case some frames are 
    //     delivered late, at least they will still be delivered, the graph
    //     won't drop them.  Since we don't have any sound, we can do this
    //     without worrying about losing sync with our sound.
    //
    if (SUCCEEDED(hr))
    {
        hr = CDShowUtil::TurnOffGraphClock(m_pGraphBuilder);

        if (hr != S_OK)
        {
            DBG_WRN(("CPreviewGraph::BuildPreviewGraph, failed to turn off the "
                     "graph clock.  This is not fatal, continuing..., hr = 0x%lx",
                     hr));

            hr = S_OK;
        }
    }

    // 
    // 8.  Register ourselves with the WIA StreamSnapshot Filter so that 
    //     a callback of ours will be called if a still image is available.
    //

    if (SUCCEEDED(hr))
    {
        //
        // the graph is ready to run. Initialize still filter and
        // register callback to get notification for new snapshots.
        //

        if (m_pCapturePinSnapshot)
        {
            m_pCapturePinSnapshot->SetSamplingSize(
                                                CAPTURE_NUM_SAMPLES_TO_CACHE);
        }

        if (m_pStillPinSnapshot)
        {
            m_pStillPinSnapshot->SetSamplingSize(STILL_NUM_SAMPLES_TO_CACHE);
        }

        hr = m_StillProcessor.RegisterStillProcessor(m_pCapturePinSnapshot,
                                                     m_pStillPinSnapshot);

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "register our still processor's callback fn"));
    }

    //
    // 9. Get the Video Renderer window off of the preview/capture pin.  
    //    This will allow us to control the renderer position, size, etc.
    //
    if (SUCCEEDED(hr))
    {
        hr = InitVideoWindows(m_hwndParent,
                              m_pCaptureFilter,
                              &m_pPreviewVW,
                              bStretchToFitParent);
    }

    return hr;
}

///////////////////////////////
// TeardownPreviewGraph
//
HRESULT CPreviewGraph::TeardownPreviewGraph()
{
    DBG_FN("CPreviewGraph::TeardownPreviewGraph");

    HRESULT hr = S_OK;

    m_pStillPin           = NULL;
    m_pVideoControl       = NULL;
    m_pStillPinSnapshot   = NULL;
    m_pCapturePinSnapshot = NULL;

    if (m_pPreviewVW)
    {
        CDShowUtil::ShowVideo(FALSE, m_pPreviewVW);
        CDShowUtil::SetVideoWindowParent(NULL, m_pPreviewVW, &m_lStyle);

        m_pPreviewVW = NULL;
    }

    //
    // Remove all the filters from the graph.
    //

    if (m_pGraphBuilder)
    {
        RemoveAllFilters();
    }

    CDShowUtil::MyDumpGraph(TEXT("Graph after removing all filters ")
                            TEXT("(should be empty)"),
                            m_pGraphBuilder);

    m_pCaptureGraphBuilder = NULL;
    m_pGraphBuilder        = NULL;
    m_pCaptureFilter       = NULL;

    return hr;
}

///////////////////////////////
// RemoveAllFilters
//
// Notice this function makes no
// attempt to disconnect each filter
// before removing it.  According to 
// MSDN, you do not need to disconnect
// a filter before removing it, you only
// need to ensure that the graph is stopped.
//
HRESULT CPreviewGraph::RemoveAllFilters()
{
    ASSERT(m_pGraphBuilder != NULL);

    HRESULT               hr         = S_OK;
    CComPtr<IEnumFilters> pEnum      = NULL;
    DWORD                 dwRefCount = 0;
    BOOL                  bDone      = FALSE;

    if (m_pGraphBuilder == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::RemoveAllFilters, m_pGraphBuilder "
                         "is NULL, cannot remove filters"));
    }

    if (hr == S_OK)
    {
        hr = m_pGraphBuilder->EnumFilters(&pEnum);
    }

    if (pEnum)
    {
        // enumerate each filter.
        while (!bDone)
        {
            CComPtr<IBaseFilter> pFilter      = NULL;
            DWORD                dwNumFetched = 0;

            //
            // Notice we reset our enumeration on every iteration since
            // the act of removing a filter from the graph may do some
            // funny things, so we really want to always remove the first
            // filter we get from the list until the list is empty.
            // 
            hr = pEnum->Reset();

            if (hr == S_OK)
            {
                hr = pEnum->Next(1, &pFilter, &dwNumFetched);
            }

            if (hr == S_OK)
            {
                // 
                // This will disconnect the filter's pins and remove
                // it from the graph.  If this fails, we want to get out
                // of the loop because otherwise we'll be in an endless loop
                // since we failed to remove the filter, then we reset our 
                // enum and get the next filter, which will be this
                // filter again.  
                //
                hr = m_pGraphBuilder->RemoveFilter(pFilter);

                CHECK_S_OK2(hr, ("CPreviewGraph::RemoveAllFilters, "
                                 "RemoveFilter failed"));

                //
                // Release our ref count.
                //
                pFilter = NULL;
            }

            if (hr != S_OK)
            {
                bDone = TRUE;
            }
        }
    }

    hr = S_OK;

    return hr;
}

//////////////////////////////////////////////////////////////////////
// HandlePowerEvent
//
LRESULT CPreviewGraph::HandlePowerEvent(WPARAM wParam,
                                        LPARAM lParam)
{
    LRESULT iReturn = TRUE;

    if (wParam == PBT_APMQUERYSUSPEND)
    {
        if (GetState() != WIAVIDEO_NO_VIDEO)
        {
            iReturn = BROADCAST_QUERY_DENY;
        }
    }

    return iReturn;
}

///////////////////////////////
// CreateHiddenWindow
//
// Used to handle power management
// messages.
//
HRESULT CPreviewGraph::CreateHiddenWindow()
{
    HRESULT     hr = S_OK;
    WNDCLASSEX  wc = {0};

    wc.style         = 0;
    wc.cbSize        = sizeof(wc);
    wc.lpfnWndProc   = HiddenWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(this);
    wc.hInstance     = _Module.GetModuleInstance();
    wc.hIcon         = NULL;
    wc.hIconSm       = NULL;
    wc.hCursor       = 0;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = 0;
    wc.lpszClassName = TEXT("WIAVIDEO_POWERMGMT");

    RegisterClassEx(&wc);

    m_hwndPowerMgmt = CreateWindowEx(0,
                                     TEXT("WIAVIDEO_POWERMGMT"), 
                                     TEXT("WIAVIDEO_POWERMGMT"), 
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     NULL,
                                     NULL,
                                     _Module.GetModuleInstance(),
                                     this);
    return hr;
}

///////////////////////////////
// DestroyHiddenWindow
//
HRESULT CPreviewGraph::DestroyHiddenWindow()
{
    HRESULT hr = S_OK;

    if (m_hwndPowerMgmt)
    {
        SendMessage(m_hwndPowerMgmt, WM_CLOSE, 0, 0);
    }

    m_hwndPowerMgmt = NULL;

    return hr;
}

//////////////////////////////////////////////////////////////////////
// HiddenWndProc
//
// Static Function
//
LRESULT CALLBACK CPreviewGraph::HiddenWndProc(HWND   hwnd, 
                                              UINT   uiMessage, 
                                              WPARAM wParam, 
                                              LPARAM lParam)
{
    LRESULT iReturn = 0;

    switch (uiMessage) 
    {
        case WM_CREATE:
        {
            CREATESTRUCT *pCreateInfo = reinterpret_cast<CREATESTRUCT*>(lParam);
            if (pCreateInfo)
            {
                SetWindowLongPtr(hwnd, 0, reinterpret_cast<LONG_PTR>(pCreateInfo->lpCreateParams));
            }
        }
        break;

        case WM_POWERBROADCAST:
        {
            CPreviewGraph *pPreviewGraph = NULL;

            pPreviewGraph = reinterpret_cast<CPreviewGraph*>(GetWindowLongPtr(hwnd, 0));

            if (pPreviewGraph)
            {
                iReturn = pPreviewGraph->HandlePowerEvent(wParam, lParam);
            }
        }
        break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;

        default:
            iReturn = DefWindowProc(hwnd,
                                    uiMessage,
                                    wParam,
                                    lParam);
        break;
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\prvgrph.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       PrvGrph.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Implements preview graph for capture still images
 *
 *****************************************************************************/

#ifndef _PRVGRPH_H_
#define _PRVGRPH_H_

#include "StillPrc.h"
#include "WiaLink.h"

/////////////////////////////////////////////////////////////////////////////
// CPreviewGraph

class CPreviewGraph
{
public:
    
    ///////////////////////////////
    // Constructor
    //
    CPreviewGraph();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CPreviewGraph();

    ///////////////////////////////
    // Init
    //
    HRESULT Init(class CWiaVideo  *pWiaVideo);

    ///////////////////////////////
    // Term
    //
    HRESULT Term();

    ///////////////////////////////
    // CreateVideo
    //
    // bAutoPlay = TRUE will begin
    // graph playback after graph
    // is completely built.
    //
    HRESULT CreateVideo(const TCHAR *pszOptionalWiaDeviceID,
                        IMoniker    *pCaptureDeviceMoniker,
                        HWND        hwndParent, 
                        BOOL        bStretchToFitParent,
                        BOOL        bAutoPlay);

    ///////////////////////////////
    // DestroyVideo
    //
    HRESULT DestroyVideo();

    ///////////////////////////////
    // TakePicture
    //
    HRESULT TakePicture(CSimpleString *pstrNewImageFileName);

    ///////////////////////////////
    // ShowPreview
    //
    HRESULT ShowVideo(BOOL bShow);

    ///////////////////////////////
    // IsPreviewVisible
    //
    BOOL IsPreviewVisible()
    {
        return m_bPreviewVisible;
    }

    ///////////////////////////////
    // ResizeVideo
    //
    HRESULT ResizeVideo(BOOL bSizeVideoToWindow);

    ///////////////////////////////
    // Play
    //
    HRESULT Play();

    ///////////////////////////////
    // Pause
    //
    HRESULT Pause();

    ///////////////////////////////
    // GetState
    //
    WIAVIDEO_STATE GetState();

    ///////////////////////////////
    // GetImagesDirectory
    //
    HRESULT GetImagesDirectory(CSimpleString *pImagesDir);

    ///////////////////////////////
    // SetImagesDirectory
    //
    HRESULT SetImagesDirectory(const CSimpleString *pImagesDir);


    ///////////////////////////////
    // ProcessAsyncImage
    //
    // Called by Still Processor
    // when user presses hardware
    // button and it is delivered to
    // Still Pin.
    //
    HRESULT ProcessAsyncImage(const CSimpleString *pNewImage);


private:

    HRESULT Stop();

    HRESULT GetStillPinCaps(IBaseFilter     *pCaptureFilter,
                            IPin            **ppStillPin,
                            IAMVideoControl **ppVideoControl,
                            LONG            *plCaps);

    HRESULT AddStillFilterToGraph(LPCWSTR        pwszFilterName,
                                  IBaseFilter    **ppFilter,
                                  IStillSnapshot **ppSnapshot);

    HRESULT AddColorConverterToGraph(LPCWSTR     pwszFilterName,
                                     IBaseFilter **ppColorSpaceConverter);

    HRESULT AddCaptureFilterToGraph(IBaseFilter  *pCaptureFilter,
                                    IPin         **ppCapturePin);

    HRESULT AddVideoRendererToGraph(LPCWSTR      pwszFilterName,
                                    IBaseFilter  **ppVideoRenderer);

    HRESULT InitVideoWindows(HWND         hwndParent,
                             IBaseFilter  *pCaptureFilter,
                             IVideoWindow **ppPreviewVideoWindow,
                             BOOL         bStretchToFitParent);

    HRESULT CreateCaptureFilter(IMoniker    *pCaptureDeviceMoniker,
                                IBaseFilter **ppCaptureFilter);

    HRESULT BuildPreviewGraph(IMoniker *pCaptureDeviceMoniker,
                              BOOL     bStretchToFitParent);

    HRESULT TeardownPreviewGraph();

    HRESULT RemoveAllFilters();

    HRESULT SetState(WIAVIDEO_STATE NewState);

    HRESULT ConnectFilters(IGraphBuilder  *pGraphBuilder,
                           IPin           *pMediaSourceOutputPin,
                           IBaseFilter    *pColorSpaceFilter,
                           IBaseFilter    *pWiaFilter,
                           IBaseFilter    *pVideoRenderer);

    LRESULT HandlePowerEvent(WPARAM wParam,
                             LPARAM lParam);

    HRESULT CreateHiddenWindow();
    HRESULT DestroyHiddenWindow();
    static LRESULT CALLBACK HiddenWndProc(HWND   hwnd,
                                          UINT   uiMessage,
                                          WPARAM wParam,
                                          LPARAM lParam);

    CStillProcessor                 m_StillProcessor;
    CSimpleString                   m_strImagesDirectory;
    class CWiaVideo                 *m_pWiaVideo;
    CComPtr<IAMVideoControl>        m_pVideoControl;
    CComPtr<IPin>                   m_pStillPin;
    CComPtr<IStillSnapshot>         m_pCapturePinSnapshot;
    CComPtr<IStillSnapshot>         m_pStillPinSnapshot;
    CComPtr<IVideoWindow>           m_pPreviewVW;
    CComPtr<ICaptureGraphBuilder2>  m_pCaptureGraphBuilder;
    CComPtr<IGraphBuilder>          m_pGraphBuilder;
    CComPtr<IBaseFilter>            m_pCaptureFilter;
    LONG                            m_lStillPinCaps;
    LONG                            m_lStyle;
    BOOL                            m_bPreviewVisible;
    WIAVIDEO_STATE                  m_CurrentState;
    HWND                            m_hwndParent;
    BOOL                            m_bSizeVideoToWindow;
    CWiaVideoProperties             *m_pVideoProperties;
    HWND                            m_hwndPowerMgmt;
};


#endif // _PRVGRPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\flnfile.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       FLNFILE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/13/1999
 *
 *  DESCRIPTION: Find the lowest numbered files in a given directory with a given
 *               root filename.
 *
 *******************************************************************************/
#ifndef __FLNFILE_H_INCLUDED
#define __FLNFILE_H_INCLUDED

#include <windows.h>

namespace NumberedFileName
{
    enum
    {
        FlagOmitDirectory = 0x0000001,
        FlagOmitExtension = 0x0000002
    };
    bool DoesFileExist(LPCTSTR pszFilename);

    bool ConstructFilename(LPTSTR   szFile, 
                           DWORD    cchFile,
                           LPCTSTR  pszDirectory, 
                           LPCTSTR  pszFilename, 
                           LPCTSTR  pszNumberFormat, 
                           LPCTSTR  pszExtension);

    int FindLowestAvailableFileSequence(LPCTSTR pszDirectory, 
                                        LPCTSTR pszFilename, 
                                        LPCTSTR pszNumberFormat, 
                                        LPCTSTR pszExtension, 
                                        bool    bAllowUnnumberedFile, 
                                        int     nCount, 
                                        int     nStart);

    bool CreateNumberedFileName(DWORD   dwFlags, 
                                LPTSTR  pszPathName, 
                                DWORD   cchPathName,
                                LPCTSTR pszDirectory, 
                                LPCTSTR pszFilename, 
                                LPCTSTR pszNumberFormat, 
                                LPCTSTR pszExtension, 
                                int     nNumber );

    int GenerateLowestAvailableNumberedFileName(DWORD   dwFlags, 
                                                LPTSTR  pszPathName,
                                                DWORD   cchPathName,
                                                LPCTSTR pszDirectory, 
                                                LPCTSTR pszFilename, 
                                                LPCTSTR pszNumberFormat, 
                                                LPCTSTR pszExtension, 
                                                bool    bAllowUnnumberedFile, 
                                                int     nStart=1 );
}

#endif __FLNFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\mpdview.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       mpdview.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/27
 *
 *  DESCRIPTION: Implements CMappedView
 *
 *****************************************************************************/
#ifndef _MPDVIEW_H_
#define _MPDVIEW_H_

class CMappedView
{
public:

    ///////////////////////////////
    // Constructor
    //

    CMappedView(LPCTSTR pszFile, 
                LONG    lSize, 
                DWORD   dwOpen) :
       m_pBits(NULL),
       m_hFile(INVALID_HANDLE_VALUE),
       m_hMap(NULL),
       m_lSize(lSize)
    {
        m_hFile = CreateFile(pszFile,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                             NULL,
                             dwOpen,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            DBG_ERR(("CreateFile failed with LastError = %d",GetLastError()));
        }

        DoCreateFileMapping();
    }

    ///////////////////////////////
    // Constructor
    //

    CMappedView( HANDLE hFile, LONG lSize ) :
        m_pBits(NULL),
        m_hFile(hFile),
        m_hMap(INVALID_HANDLE_VALUE),
        m_lSize(lSize)
    {
        DoCreateFileMapping();
    }

    ///////////////////////////////
    // Destructor
    //

    ~CMappedView()
    {
        DBG_FN(("~CMappedView"));
        CloseAndRelease();
    }


    ///////////////////////////////
    // DoCreateFileMapping
    //
    void DoCreateFileMapping()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            m_hMap = CreateFileMapping(m_hFile,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       m_lSize,
                                       NULL);

            if (m_hMap)
            {
                m_pBits = (PBYTE)MapViewOfFileEx(
                                             m_hMap,
                                             FILE_MAP_READ | FILE_MAP_WRITE,
                                             0,
                                             0,
                                             0,
                                             NULL);
            }
            else
            {
                DBG_ERR(("CreateFileMapping failed with LastError = %d",
                         GetLastError()));
            }
        }
    }

    ///////////////////////////////
    // FileSize
    //
    LARGE_INTEGER FileSize()
    {
        LARGE_INTEGER li;

        li.QuadPart = 0;

#ifdef WINNT
        GetFileSizeEx(m_hFile, &li);
#else
        DWORD LowPart = 0;


        LowPart = GetFileSize(m_hFile, (DWORD *)&li.HighPart);

        if (LowPart != -1)
        {
            li.LowPart = LowPart;
        }
#endif

        return li;
    }

    ///////////////////////////////
    // CloseAndRelease
    //
    void CloseAndRelease()
    {
        if (m_pBits)
        {
            if (!UnmapViewOfFile( m_pBits ))
            {
                DBG_ERR(("UnmapViewOfFile failed with LastError = %d",
                         GetLastError()));
            }
            m_pBits = NULL;
        }

        if (m_hMap)
        {
            if (!CloseHandle( m_hMap ))
            {
                DBG_ERR(("CloseHandle( m_hMap ) failed with LastError = %s",
                         GetLastError()));
            }
            m_hMap = NULL;
        }

        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle( m_hFile ))
            {
                DBG_ERR(("CloseHandle( m_hFile ) failed with LastError = %s",
                         GetLastError()));
            }
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }


    ///////////////////////////////
    // Bits
    //
    PBYTE Bits()
    {
        return m_pBits;
    }

private:
    BYTE    *m_pBits;
    HANDLE  m_hFile;
    HANDLE  m_hMap;
    LONG    m_lSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Precompiled header file for video usd
 *
 *****************************************************************************/


#ifndef _WIA_VIDEO_USD_PRECOMP_H_
#define _WIA_VIDEO_USD_PRECOMP_H_

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//#include <windows.h>

#include <psnew.h>
#include <coredbg.h>

#include <streams.h>
#include <mmreg.h>

#include <simstr.h>
#include <simreg.h>
#include <simbstr.h>
#include <simlist.h>
#include <initguid.h>
#include <gdiplus.h>
#include <uuids.h>
#include <sti.h>
#include <stiusd.h>
#include <stierr.h>
#include <resource.h>

#include <wia.h>
#include <istillf.h>    // found in wia\drivers\video\filter
#include <mpdview.h>
#include <wiavideo.h>
#include <dshowutl.h>
#include <wiautil.h>
#include <cwiavideo.h>
#include <prvgrph.h>
#include <stillprc.h>
#include <wialink.h>
#include <vcamprop.h>
#include <flnfile.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\resource.h ===
#define IDS_PROJNAME                    100
#define IDS_WIAVIDEO_DESC               101
#define IDR_WiaVideo                    102
#define IDS_SNAPSHOT                    103
#define IDS_NUM_FORMAT                  104
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\stillprc.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       StillPrc.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/27
 *
 *  DESCRIPTION: Implements Still Image Processing.
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop
#include <gphelper.h>

using namespace Gdiplus;

///////////////////////////////
// CStillProcessor Constructor
//
CStillProcessor::CStillProcessor() :
                    m_bTakePicturePending(FALSE),
                    m_hSnapshotReadyEvent(NULL),
                    m_uiFileNumStartPoint(0)
{
    DBG_FN("CStillProcessor::CStillProcessor");

    //
    // This event is used to wait for a picture to be returned to us from the 
    // still pin on the capture filter (if it exists)
    //
    m_hSnapshotReadyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ASSERT(m_hSnapshotReadyEvent != NULL);
}

///////////////////////////////
// CStillProcessor Destructor
//
CStillProcessor::~CStillProcessor()
{
    DBG_FN("CStillProcessor::~CStillProcessor");

    if (m_hSnapshotReadyEvent)
    {
        CloseHandle(m_hSnapshotReadyEvent);
        m_hSnapshotReadyEvent = NULL;
    }
}

///////////////////////////////
// Init
//
HRESULT CStillProcessor::Init(CPreviewGraph    *pPreviewGraph)
{
    HRESULT hr = S_OK;

    m_pPreviewGraph = pPreviewGraph;

    return hr;
}

///////////////////////////////
// Term
//
HRESULT CStillProcessor::Term()
{
    HRESULT hr = S_OK;

    m_pPreviewGraph = NULL;

    return hr;
}

///////////////////////////////
// SetTakePicturePending
//
HRESULT CStillProcessor::SetTakePicturePending(BOOL bTakePicturePending)
{
    HRESULT hr = S_OK;

    m_bTakePicturePending = bTakePicturePending;

    return hr;
}

///////////////////////////////
// IsTakePicturePending
//
BOOL CStillProcessor::IsTakePicturePending()
{
    return m_bTakePicturePending;
}

///////////////////////////////
// CreateImageDir
//
HRESULT CStillProcessor::CreateImageDir(
                                const CSimpleString *pstrImagesDirectory)
{
    DBG_FN("CStillProcessor::CreateImageDir");

    HRESULT hr = S_OK;

    ASSERT(pstrImagesDirectory != NULL);

    if (pstrImagesDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillProcessor::CreateImage received a NULL "
                         "param"));

        return hr;
    }

    if (hr == S_OK)
    {
        m_strImageDir         = *pstrImagesDirectory;
        m_uiFileNumStartPoint = 0;

        if (!RecursiveCreateDirectory(pstrImagesDirectory))
        {
            DBG_ERR(("ERROR: Failed to create directory '%ls', last "
                     "error = %d",
                     m_strImageDir.String(), 
                     ::GetLastError()));
        }
        else
        {
            DBG_TRC(("*** Images will be stored in '%ls' ***", 
                     m_strImageDir.String()));
        }
    }
    
    return hr;
}

///////////////////////////////
// DoesDirectoryExist
//
// Checks to see whether the given
// fully qualified directory exists.

BOOL CStillProcessor::DoesDirectoryExist(LPCTSTR pszDirectoryName)
{
    DBG_FN("CStillProcessor::DoesDirectoryExist");

    BOOL bExists = FALSE;

    if (pszDirectoryName)
    {
        //
        // Try to determine if this directory exists
        //
    
        DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    
        if ((dwFileAttributes == 0xFFFFFFFF) || 
             !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            bExists = FALSE;
        }
        else
        {
            bExists = TRUE;
        }
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}


///////////////////////////////
// RecursiveCreateDirectory
//
// Take a fully qualified path and 
// create the directory in pieces as 
// needed.
//
BOOL CStillProcessor::RecursiveCreateDirectory(
                                    const CSimpleString *pstrDirectoryName)
{
    DBG_FN("CStillProcessor::RecursiveCreateDirectory");

    ASSERT(pstrDirectoryName != NULL);

    //
    // If this directory already exists, return true.
    //

    if (DoesDirectoryExist(*pstrDirectoryName))
    {
        return TRUE;
    }

    //
    // Otherwise try to create it.
    //

    CreateDirectory(*pstrDirectoryName, NULL);

    //
    // If it now exists, return true
    //

    if (DoesDirectoryExist(*pstrDirectoryName))
    {
        return TRUE;
    }
    else
    {
        //
        // Remove the last subdir and try again
        //

        int nFind = pstrDirectoryName->ReverseFind(TEXT('\\'));
        if (nFind >= 0)
        {
            RecursiveCreateDirectory(&(pstrDirectoryName->Left(nFind)));

            //
            // Now try to create it.
            //

            CreateDirectory(*pstrDirectoryName, NULL);
        }
    }

    //
    //Does it exist now?
    //

    return DoesDirectoryExist(*pstrDirectoryName);
}

///////////////////////////////
// RegisterStillProcessor
//
HRESULT CStillProcessor::RegisterStillProcessor(
                                    IStillSnapshot *pFilterOnCapturePin,
                                    IStillSnapshot *pFilterOnStillPin)
{
    DBG_FN("CStillProcessor::RegisterStillProcessor");

    HRESULT hr = S_OK;

    m_CaptureCallbackParams.pStillProcessor = this;
    m_StillCallbackParams.pStillProcessor   = this;

    if (pFilterOnCapturePin)
    {
        hr = pFilterOnCapturePin->RegisterSnapshotCallback(
                                        CStillProcessor::SnapshotCallback,
                                        (LPARAM) &m_CaptureCallbackParams);

        CHECK_S_OK2(hr, ("Failed to register for callbacks with WIA filter "
                         " on capture pin"));
    }

    if (pFilterOnStillPin)
    {
        hr = pFilterOnStillPin->RegisterSnapshotCallback(
                                        CStillProcessor::SnapshotCallback,
                                        (LPARAM) &m_StillCallbackParams);

        CHECK_S_OK2(hr, ("Failed to register for callbacks with WIA filter "
                         "on still pin"));
    }

    //
    // Reset our file name starting point number
    //
    m_uiFileNumStartPoint = 0;

    return hr;
}

///////////////////////////////
// WaitForNewImage
//
HRESULT CStillProcessor::WaitForNewImage(UINT          uiTimeout,
                                         CSimpleString *pstrNewImageFullPath)

{
    DBG_FN("CStillProcessor::WaitForCompletion");

    HRESULT hr = S_OK;

    //
    // Wait for callback function to return from Still Filter which will
    // trigger this event.
    //

    if (SUCCEEDED(hr) && m_hSnapshotReadyEvent)
    {
        DWORD dwRes = 0;

        //
        // Wait for snapshot to complete for dwTimeout seconds.
        //
        dwRes = WaitForSingleObject(m_hSnapshotReadyEvent, uiTimeout );

        if (dwRes == WAIT_OBJECT_0)
        {
            if (pstrNewImageFullPath)
            {
                pstrNewImageFullPath->Assign(m_strLastSavedFile);
            }
        }
        else
        {
            hr = E_FAIL;

            if (pstrNewImageFullPath)
            {
                pstrNewImageFullPath->Assign(TEXT(""));
            }

            if (dwRes == WAIT_TIMEOUT)
            {
                CHECK_S_OK2(hr, ("***Timed out waiting for "
                                 "m_hSnapshotReadyEvent!***"));
            }
            else if (dwRes == WAIT_ABANDONED)
            {
                CHECK_S_OK2(hr, ("***WAIT_ABANDONED while waiting for "
                                 "m_hSnapshotReadyEvent!***"));
            }
            else
            {
                CHECK_S_OK2(hr, ("***Unknown error (dwRes = %d) waiting "
                                 "for m_hSnapshotReadyEvent***", dwRes));
            }
        }
    }

    return hr;
}

///////////////////////////////
// ProcessImage
//
HRESULT CStillProcessor::ProcessImage(HGLOBAL hDIB)
{
    DBG_FN("CStillProcessor::ProcessImage");

    HRESULT hr = S_OK;

    ASSERT(hDIB != NULL);

    if (hDIB == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CStillProcessor::ProcessImage, received NULL "
                         "image data"));
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        CSimpleString strJPEG;
        CSimpleString strBMP;

        hr = CreateFileName(&strJPEG, &strBMP);

        // 
        // Save the new image to a file
        //
        hr = SaveToFile(hDIB, &strJPEG, &strBMP);

        //
        // Let people know the image is available...
        //

        if (IsTakePicturePending())
        {
            if (m_hSnapshotReadyEvent)
            {
                m_strLastSavedFile = strJPEG;

                SetEvent(m_hSnapshotReadyEvent);
            }
            else
            {
                DBG_WRN(("CStillProcessor::ProcessImage, failed to Set "
                         "SnapshotReady event because it was NULL"));
            }
        }
        else
        {
            if (m_pPreviewGraph)
            {
                hr = m_pPreviewGraph->ProcessAsyncImage(&strJPEG);
            }
            else
            {
                DBG_WRN(("CStillProcessor::ProcessImage failed to call "
                         "ProcessAsyncImage, m_pPreviewGraph is NULL"));
            }
        }
    }

    return hr;
}


///////////////////////////////
// SnapshotCallback
//
// Static Fn
// 
// This function is called by the
// WIA StreamSnapshot Filter 
// in wiasf.ax.  It delivers to us
// the newly captured still image.
//
BOOL CStillProcessor::SnapshotCallback(HGLOBAL hDIB, 
                                       LPARAM lParam)
{
    DBG_FN("CStillProcessor::SnapshotCallback");

    BOOL bSuccess = TRUE;

    SnapshotCallbackParam_t *pCallbackParam = 
                                    (SnapshotCallbackParam_t*) lParam;

    if (pCallbackParam)
    {
        if (pCallbackParam->pStillProcessor)
        {
            pCallbackParam->pStillProcessor->ProcessImage(hDIB);
        }
    }
    else
    {
        bSuccess = FALSE;
        DBG_ERR(("CStillProcessor::SnapshotCallback, pCallbackParam is "
                 "NULL when it should contain the snapshot callback params"));
    }

    return bSuccess;
}

///////////////////////////////
// ConvertToJPEG
//
// Takes a .bmp file and converts
// it to a .jpg file

HRESULT CStillProcessor::ConvertToJPEG(LPCTSTR pszInputFilename,
                                       LPCTSTR pszOutputFilename)
{
    DBG_FN("CStillProcessor::ConvertToJPEG");

    HRESULT hr = CGdiPlusHelper().Convert(
            CSimpleStringConvert::WideString(
                                    CSimpleString(pszInputFilename)).String(),
            CSimpleStringConvert::WideString(
                                    CSimpleString(pszOutputFilename)).String(),
            ImageFormatJPEG);

    CHECK_S_OK(hr);
    return hr;
}

///////////////////////////////
// CreateFileName
//
HRESULT CStillProcessor::CreateFileName(CSimpleString   *pstrJPEG,
                                        CSimpleString   *pstrBMP)
{
    HRESULT hr    = S_OK;
    UINT    uiNum = 0;

    ASSERT(pstrJPEG != NULL);
    ASSERT(pstrBMP  != NULL);

    if ((pstrJPEG == NULL) ||
        (pstrBMP  == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillProcessor::CreateFileName received "
                         "NULL param"));

        return hr;
    }

    TCHAR szJPG[MAX_PATH + 1] = {0};

    CSimpleString strBaseName(IDS_SNAPSHOT, _Module.GetModuleInstance());
    CSimpleString strNumberFormat(IDS_NUM_FORMAT, _Module.GetModuleInstance());

    //
    // Get the lowest number JPG file name we can find.
    //
    m_uiFileNumStartPoint = NumberedFileName::GenerateLowestAvailableNumberedFileName(0, 
                                                       szJPG,
                                                       (sizeof(szJPG) / sizeof(szJPG[0])) - 1,
                                                       m_strImageDir,
                                                       strBaseName,
                                                       strNumberFormat,
                                                       TEXT("jpg"),
                                                       false,
                                                       m_uiFileNumStartPoint);

    //
    // Save the returned JPG file name.
    //
    *pstrJPEG = szJPG;

    //
    // Give the BMP file, which is a temp file, the same name as the JPG
    // but strip off the JPG extension and attach the BMP extension instead.
    //
    pstrBMP->Assign(*pstrJPEG);
    *pstrBMP = pstrBMP->Left(pstrBMP->ReverseFind(TEXT(".jpg")));
    pstrBMP->Concat(TEXT(".bmp"));

    return hr;
}


///////////////////////////////
// SaveToFile
//
// This method is called when the
// DShow filter driver delivers us
// a new set of bits from a snapshot
// that was just taken.  We write these
// bits out to a file.
//
HRESULT CStillProcessor::SaveToFile(HGLOBAL               hDib,
                                    const CSimpleString   *pstrJPEG,
                                    const CSimpleString   *pstrBMP)
{
    DBG_FN("CStillProcessor::SaveToFile");

    ASSERT(hDib     != NULL);
    ASSERT(pstrJPEG != NULL);
    ASSERT(pstrBMP  != NULL);

    HRESULT         hr         = S_OK;
    BITMAPINFO *    pbmi       = NULL;
    LPBYTE          pImageBits = NULL;
    LPBYTE          pColorTable = NULL;
    LPBYTE          pFileBits  = NULL;
    UINT            uNum       = 1;
    UINT            uFileSize  = 0;
    UINT            uDibSize   = 0;
    UINT            uColorTableSize = 0;

    if ((hDib     == NULL) ||
        (pstrJPEG == NULL) ||
        (pstrBMP  == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillProcessor::SaveToFile, received NULL param"));
        return hr;
    }

    //
    // calculate where the bits are -- basically,
    // right after BITMAPINFOHEADER + color table
    //

    pbmi = (BITMAPINFO *)GlobalLock(hDib);

    if (pbmi)
    {
        //
        // Find the image bits
        //

        pImageBits = (LPBYTE)pbmi + sizeof(BITMAPINFOHEADER);
        if (pbmi->bmiHeader.biClrUsed)
        {
            pImageBits += pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD);
        }
        else if (pbmi->bmiHeader.biBitCount <= 8)
        {
            pImageBits += (1 << pbmi->bmiHeader.biBitCount) * sizeof(RGBQUAD);
        }
        else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            pImageBits += (3 * sizeof(DWORD));
        }

        pColorTable     = (LPBYTE)pbmi + pbmi->bmiHeader.biSize;
        uColorTableSize = (DWORD)(pImageBits - pColorTable);

        //
        // calculate the size of the image bits & size of full file
        //

        UINT uiSrcScanLineWidth = 0;
        UINT uiScanLineWidth    = 0;

        // Align scanline to ULONG boundary
        uiSrcScanLineWidth = (pbmi->bmiHeader.biWidth * 
                              pbmi->bmiHeader.biBitCount) / 8;

        uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

        //
        // Calculate DIB size and allocate memory for the DIB.
        uDibSize = (pbmi->bmiHeader.biHeight > 0) ?
                   pbmi->bmiHeader.biHeight  * uiScanLineWidth :
                   -(pbmi->bmiHeader.biHeight) * uiScanLineWidth;

        uFileSize = sizeof(BITMAPFILEHEADER) + 
                    pbmi->bmiHeader.biSize + 
                    uColorTableSize + 
                    uDibSize;

    }
    else
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("Unable to lock hDib"));
        return hr;
    }

    //
    // Create a mapped view to the new file so we can start writing out
    // the bits...
    //
    CMappedView cmv(pstrBMP->String(), uFileSize, OPEN_ALWAYS);

    pFileBits = cmv.Bits();

    if (!pFileBits)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("Filemapping failed"));
        return hr;
    }

    //
    // Write out BITMAPFILEHEADER
    //

    BITMAPFILEHEADER bmfh;

    bmfh.bfType = (WORD)'MB';
    bmfh.bfSize = sizeof(BITMAPFILEHEADER);
    bmfh.bfReserved1 = 0;
    bmfh.bfReserved2 = 0;

    bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + 
                     (DWORD)(pImageBits - (LPBYTE)pbmi);

    memcpy( pFileBits, &bmfh, sizeof(BITMAPFILEHEADER));
    pFileBits += sizeof(BITMAPFILEHEADER);

    //
    // Write out BITMAPINFOHEADER
    //

    memcpy( pFileBits, pbmi, pbmi->bmiHeader.biSize );
    pFileBits += pbmi->bmiHeader.biSize;

    //
    // If there's a color table or color mask, write it out
    //

    if (pImageBits > pColorTable)
    {
        memcpy( pFileBits, pColorTable, pImageBits - pColorTable );
        pFileBits += (pImageBits - pColorTable);
    }

    //
    // Write out the image bits
    //

    memcpy(pFileBits, pImageBits, uDibSize );

    //
    // We're done w/the image bits now & the file mapping
    //

    GlobalUnlock( hDib );
    cmv.CloseAndRelease();

    //
    // Convert image to .jpg file
    //

    if (SUCCEEDED(ConvertToJPEG(*pstrBMP, *pstrJPEG )))
    {
        DeleteFile(*pstrBMP);
    }
    else
    {
        DBG_ERR(("CStillProcessor::SaveToFile, failed to create image file '%ls'",
                 pstrJPEG->String()));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\stillprc.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       StillPrc.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/27
 *
 *  DESCRIPTION: Handles the Still Image processing
 *
 *****************************************************************************/

#ifndef _STILLPRC_H_
#define _STILLPRC_H_

/////////////////////////////////////////////////////////////////////////////
// CStillProcessor

class CStillProcessor
{
public:
    
    ///////////////////////////////
    // SnapshotCallbackParam_t
    //
    typedef struct tagSnapshotCallbackParam_t
    {
        class CStillProcessor   *pStillProcessor;
    } SnapshotCallbackParam_t;

    ///////////////////////////////
    // Constructor
    //
    CStillProcessor();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CStillProcessor();

    ///////////////////////////////
    // Init
    //
    HRESULT Init(class CPreviewGraph *pPreviewGraph);

    ///////////////////////////////
    // Term
    //
    HRESULT Term();

    ///////////////////////////////
    // CreateImageDir
    //
    HRESULT CreateImageDir(const CSimpleString *pstrImageDirectory);

    ///////////////////////////////
    // RegisterStillProcessor
    //
    HRESULT RegisterStillProcessor(IStillSnapshot *pFilterOnCapturePin,
                                   IStillSnapshot *pFilterOnStillPin);

    ///////////////////////////////
    // WaitForNewImage
    //
    HRESULT WaitForNewImage(UINT          uiTimeout,
                            CSimpleString *pstrNewImageFullPath);

    ///////////////////////////////
    // ProcessImage
    //
    HRESULT ProcessImage(HGLOBAL hDIB);

    ///////////////////////////////
    // SetTakePicturePending
    //
    HRESULT SetTakePicturePending(BOOL bPending);

    ///////////////////////////////
    // IsTakePicturePending
    //
    BOOL IsTakePicturePending();

    ///////////////////////////////
    // SnapshotCallback
    //
    // This function is called by the
    // WIA StreamSnapshot Filter 
    // in wiasf.ax.  It delivers to us
    // the newly captured still image.
    //
    static BOOL SnapshotCallback(HGLOBAL hDIB, LPARAM lParam);

private:

    HRESULT CreateFileName(CSimpleString *pstrJPEG,
                           CSimpleString *pstrBMP);

    BOOL DoesDirectoryExist(LPCTSTR pszDirectoryName);

    BOOL RecursiveCreateDirectory(const CSimpleString *pstrDirectoryName);

    HRESULT ConvertToJPEG(LPCTSTR pszInputFilename,
                          LPCTSTR pszOutputFilename);

    HRESULT SaveToFile(HGLOBAL             hDib,
                       const CSimpleString *pstrJPEG,
                       const CSimpleString *pstrBMP);

    SnapshotCallbackParam_t     m_CaptureCallbackParams;
    SnapshotCallbackParam_t     m_StillCallbackParams;
    CSimpleString               m_strImageDir;
    CSimpleString               m_strLastSavedFile;
    HANDLE                      m_hSnapshotReadyEvent;
    class CPreviewGraph         *m_pPreviewGraph;

    // TRUE when caller calls TakePicture on CPreviewGraph
    // If image appears asynchronously, as in the case of a hardware
    // pushbutton event, this will be FALSE.

    BOOL                        m_bTakePicturePending;    

    UINT                        m_uiFileNumStartPoint;

};

#endif // _STILLPRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\wialink.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       WiaLink.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/06
 *
 *  DESCRIPTION: Establishes link between WiaVideo and the WiaVideo Driver
 *
 *****************************************************************************/
 
#include <precomp.h>
#pragma hdrstop

//
// These generate 2 event names which are created in the wia video 
// driver found in wia\drivers\video\usd.  If you must change 
// these, they MUST change in the video driver as well.  Be warned, 
// changing these without knowing what you are doing will lead to problems.
//
const TCHAR* EVENT_PREFIX_GLOBAL        = TEXT("Global\\");
const TCHAR* EVENT_SUFFIX_TAKE_PICTURE  = TEXT("_TAKE_PICTURE");
const TCHAR* EVENT_SUFFIX_PICTURE_READY = TEXT("_PICTURE_READY");
const UINT   THREAD_EXIT_TIMEOUT        = 1000 * 5;     // 5 seconds

///////////////////////////////
// CWiaLink Constructor
//
CWiaLink::CWiaLink() :
                m_pWiaVideo(NULL),
                m_hTakePictureEvent(NULL),
                m_hPictureReadyEvent(NULL),
                m_hTakePictureThread(NULL),
                m_bExitThread(FALSE),
                m_bEnabled(FALSE),
                m_dwWiaItemCookie(0),
                m_dwPropertyStorageCookie(0)
{
    DBG_FN("CWiaLink::CWiaLink");
}

///////////////////////////////
// CWiaLink Constructor
//
CWiaLink::~CWiaLink()
{
    DBG_FN("CWiaLink::~CWiaLink");

    if (m_bEnabled)
    {
        Term();
    }
}

///////////////////////////////
// Init
//
HRESULT CWiaLink::Init(const CSimpleString  *pstrWiaDeviceID,
                       CWiaVideo            *pWiaVideo)
{
    DBG_FN("CWiaLink::Init");

    HRESULT             hr = S_OK;
    CComPtr<IWiaDevMgr> pDevMgr;
    CComPtr<IWiaItem>   pRootItem;

    ASSERT(pstrWiaDeviceID != NULL);
    ASSERT(pWiaVideo       != NULL);

    if ((pstrWiaDeviceID == NULL) ||
        (pWiaVideo       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::Init, received NULL params"));

        return hr;
    }

    m_pWiaVideo     = pWiaVideo;
    m_strDeviceID   = *pstrWiaDeviceID;

    if (hr == S_OK)
    {
        hr = CAccessLock::Init(&m_csLock);
    }

    //
    // Create the WiaDevMgr so we can create the Wia Root Item
    //
    if (hr == S_OK)
    {
        hr = CWiaUtil::CreateWiaDevMgr(&pDevMgr);
    
        CHECK_S_OK2(hr, ("CWiaLink::Init, failed to Create WiaDevMgr"));
    }
    
    //
    // This ensures that the WIA Video Driver is initialized and in the 
    // correct state.
    //
    
    if (hr == S_OK)
    {
        hr = CWiaUtil::CreateRootItem(pDevMgr, pstrWiaDeviceID, &pRootItem);
    
        CHECK_S_OK2(hr, ("CWiaLink::Init, failed to create the WIA "
                         "Device Root Item for WIA Device ID '%ls'",
                         CSimpleStringConvert::WideString(*pstrWiaDeviceID)));
    }

    //
    // Create a Global Interface Table object.  This will enable us to use 
    // the root item (IWiaItem pRootItem) above across any thread we wish.
    // This is required because if we receive async images (as a result of a 
    // hardware button event), a random thread will be calling the 
    // WriteMultiple function on the IWiaItem object.
    //
    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGlobalInterfaceTable,
                              (void **)&m_pGIT);

        CHECK_S_OK2(hr, ("CWiaUtil::Init, failed to create "
                         "StdGlobalInterfaceTable used to use the IWiaItem "
                         "root device item across multiple threads"));
    }

    //
    // Register the WiaItem pointer in a apartment neutral way.
    //
    if (hr == S_OK)
    {
        //
        // This will AddRef the pointer so no need to add a reference
        // to it.
        // 
        hr =  m_pGIT->RegisterInterfaceInGlobal(pRootItem, 
                                                IID_IWiaItem,
                                                &m_dwWiaItemCookie);
                                        
    }

    //
    // Register the IWiaPropertyStorage pointer in an apartment neutral way.
    //
    if (hr == S_OK)
    {
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> 
                                                            pProp(pRootItem);

        if (pProp)
        {
            hr =  m_pGIT->RegisterInterfaceInGlobal(
                                                pProp, 
                                                IID_IPropertyStorage,
                                                &m_dwPropertyStorageCookie);
        }
    }

    if (hr == S_OK)
    {
        m_bEnabled = TRUE;
    }

    //
    // If we failed in initializing, cleanup anything that we created
    //
    if (hr != S_OK)
    {
        Term();
    }

    return hr;
}

///////////////////////////////
// Term
//
HRESULT CWiaLink::Term()
{
    HRESULT hr = S_OK;

    DBG_FN("CWiaLink::Term");

    StopMonitoring();

    m_strDeviceID   = TEXT("");
    m_bEnabled      = FALSE;


    if (m_pGIT)
    {
        CAccessLock Lock(&m_csLock);

        hr = m_pGIT->RevokeInterfaceFromGlobal(m_dwWiaItemCookie);
        CHECK_S_OK2(hr, 
                    ("CWiaLink::Term, failed to RevokeInterfaceFromGlobal "
                     "for WiaItemCookie = '%lu'", 
                     m_dwWiaItemCookie));

        hr = m_pGIT->RevokeInterfaceFromGlobal(m_dwPropertyStorageCookie);
        CHECK_S_OK2(hr, 
                    ("CWiaLink::Term, failed to RevokeInterfaceFromGlobal "
                     "for PropertyStorageCookie = '%lu'", 
                     m_dwPropertyStorageCookie));
    }

    m_pGIT = NULL;
    m_dwWiaItemCookie         = 0;
    m_dwPropertyStorageCookie = 0;

    CAccessLock::Term(&m_csLock);

    return hr;
}

///////////////////////////////
// StartMonitoring
//
HRESULT CWiaLink::StartMonitoring()
{
    HRESULT hr = S_OK;

    if (m_hTakePictureEvent != NULL)
    {
        DBG_WRN(("CWiaLink::StartMonitoring was called but it is already "
                 "monitoring TAKE_PICTURE events.  Why was it called again, "
                 "prior to 'StopMonitoring' being called?"));
        
        return S_OK;
    }

    m_bExitThread = FALSE;

    //
    // create the event that will be opened by the WIA video driver.  
    //

    if (hr == S_OK)
    {
        hr = CreateWiaEvents(&m_hTakePictureEvent,
                             &m_hPictureReadyEvent);

        CHECK_S_OK2(hr, 
                    ("CWiaLink::Init, failed to Create WIA Take "
                     "Picture Events"));
    }

    //
    // Tell the WIA driver to enable the TAKE_PICTURE command.
    //

    if (hr == S_OK)
    {
        CComPtr<IWiaItem> pRootItem;

        hr = GetDevice(&pRootItem);

        if (hr == S_OK)
        {
            CComPtr<IWiaItem> pUnused;
    
            hr = pRootItem->DeviceCommand(0, 
                                          &WIA_CMD_ENABLE_TAKE_PICTURE, 
                                          &pUnused);

            CHECK_S_OK2(hr, ("CWiaLink::StartMonitoring, failed to send "
                             "ENABLE_TAKE_PICTURE command to Wia Video "
                             "Driver"));
        }
    }

    // Start the thread, waiting on the "TakePicture" event.

    if (hr == S_OK)
    {
        DWORD dwThreadID = 0;

        DBG_TRC(("CWiaLink::Init, creating TAKE_PICTURE thread..."));

        m_hTakePictureThread = CreateThread(NULL, 
                                            0, 
                                            CWiaLink::StartThreadProc,
                                            reinterpret_cast<void*>(this),
                                            0,
                                            &dwThreadID);

        if (m_hTakePictureThread == NULL)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr,                          
                        ("CWiaLink::Init, failed to create thread to wait "
                         "for take picture events from the wia video "
                         "driver, last error = %lu", GetLastError()));
        }
    }

    return hr;
}

///////////////////////////////
// StopMonitoring
//
HRESULT CWiaLink::StopMonitoring()
{
    HRESULT hr = S_OK;

    if (m_hTakePictureThread)
    {
        DWORD dwThreadResult = 0;
    
        m_bExitThread = TRUE;
        SetEvent(m_hTakePictureEvent);
    
        dwThreadResult = WaitForSingleObject(m_hTakePictureThread, 
                                             THREAD_EXIT_TIMEOUT);
    
        if (dwThreadResult != WAIT_OBJECT_0)
        {
            DBG_WRN(("CWiaLink::Term, timed out waiting for take picture "
                     "thread to terminate, continuing anyway..."));
        }

        //
        // Tell the WIA driver to disable the TAKE_PICTURE command.
        //
        if (m_dwWiaItemCookie)
        {
            CComPtr<IWiaItem> pRootItem;
    
            hr = GetDevice(&pRootItem);
    
            if (hr == S_OK)
            {
                CComPtr<IWiaItem> pUnused;
        
                hr = pRootItem->DeviceCommand(0, 
                                              &WIA_CMD_DISABLE_TAKE_PICTURE, 
                                              &pUnused);

                CHECK_S_OK2(hr, ("CWiaLink::StopMonitoring, failed to send "
                                 "DISABLE_TAKE_PICTURE command to Wia Video "
                                 "Driver"));
            }
        }
    }

    //
    // Close the Take Picture Event Handles.
    //
    if (m_hTakePictureEvent)
    {
        CloseHandle(m_hTakePictureEvent);
        m_hTakePictureEvent = NULL;
    }

    if (m_hPictureReadyEvent)
    {
        CloseHandle(m_hPictureReadyEvent);
        m_hPictureReadyEvent = NULL;
    }

    if (m_hTakePictureThread)
    {
        CloseHandle(m_hTakePictureThread);
        m_hTakePictureThread = NULL;
    }

    return hr;
}


///////////////////////////////
// CreateWiaEvents
//
HRESULT CWiaLink::CreateWiaEvents(HANDLE *phTakePictureEvent,
                                  HANDLE *phPictureReadyEvent)
{
    DBG_FN("CWiaLink::CreateWiaEvents");

    HRESULT         hr = S_OK;
    CSimpleString   strTakePictureEvent;
    CSimpleString   strPictureReadyEvent;

    ASSERT(phTakePictureEvent  != NULL);
    ASSERT(phPictureReadyEvent != NULL);

    if ((phTakePictureEvent  == NULL) ||
        (phPictureReadyEvent == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::CreateWiaEvents received a NULL Param"));
    }

    if (hr == S_OK)
    {
        INT             iPosition = 0;
        CSimpleString   strModifiedDeviceID;

        // Change the device ID from {6B...}\xxxx, to {6B...}_xxxx

        iPosition = m_strDeviceID.ReverseFind('\\');
        strModifiedDeviceID = m_strDeviceID.MakeUpper();
        strModifiedDeviceID.SetAt(iPosition, '_');

        //
        // Generate the event names.  These names contain the Device ID in 
        // them so that they are unique across devices.
        //
        strTakePictureEvent  = EVENT_PREFIX_GLOBAL;
        strTakePictureEvent += strModifiedDeviceID;
        strTakePictureEvent += EVENT_SUFFIX_TAKE_PICTURE;

        strPictureReadyEvent  = EVENT_PREFIX_GLOBAL;
        strPictureReadyEvent += strModifiedDeviceID;
        strPictureReadyEvent += EVENT_SUFFIX_PICTURE_READY;
    }

    if (hr == S_OK)
    {
        *phTakePictureEvent = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                        FALSE, 
                                        strTakePictureEvent);

        if (*phTakePictureEvent == NULL)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, 
                        ("CWiaLink::CreateWiaEvents, failed to create the "
                         "WIA event '%s', last error = %lu", 
                         strTakePictureEvent.String(), GetLastError()));
        }
        else
        {
            DBG_TRC(("CWiaLink::CreateWiaEvents, created event '%ls'",
                     strTakePictureEvent.String()));
        }
    }

    if (hr == S_OK)
    {
        *phPictureReadyEvent = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                         FALSE, 
                                         strPictureReadyEvent);

        if (*phPictureReadyEvent == NULL)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, 
                        ("CWiaLink::CreateWiaEvents, failed to create the "
                         "WIA event '%s', last error = %lu", 
                         strPictureReadyEvent.String(), GetLastError()));
        }
        else
        {
            DBG_TRC(("CWiaLink::CreateWiaEvents, created event '%ls'",
                     strPictureReadyEvent.String()));
        }
    }

    return hr;
}

///////////////////////////////
// ThreadProc
//
HRESULT CWiaLink::ThreadProc(void *pArgs)
{
    DBG_FN("CWiaLink::ThreadProc");

    HRESULT hr = S_OK;

    DBG_TRC(("CWiaLink::ThreadProc, starting TakePicture thread..."));

    while (!m_bExitThread)
    {
        DWORD dwResult = 0;

        //
        // Reset our HRESULT.  Just because we may have failed before, 
        // does not mean we will fail again.
        //
        hr = S_OK;

        dwResult = WaitForSingleObject(m_hTakePictureEvent, INFINITE);

        if (!m_bExitThread)
        {
            //
            // The only error we can get from WaitForSingle object is 
            // something unexpected, since we can't timeout since we
            // are waiting infinitely.
            //
            if (dwResult != WAIT_OBJECT_0)
            {
                hr = E_FAIL;
                m_bExitThread = TRUE;
                CHECK_S_OK2(hr,
                            ("CWiaLink::ThreadProc, received '%lu' result "
                             "from WaitForSingleObject, unexpected error, "
                             "thread is exiting...", 
                             dwResult));
            }
            else if (m_pWiaVideo == NULL)
            {
                hr = E_FAIL;
                m_bExitThread = TRUE;
                CHECK_S_OK2(hr,
                            ("CWiaLink::ThreadProc, m_pWiaVideo is NULL, "
                             "cannot take picture unexpected error, thread "
                             "is exiting...", dwResult));
            }
    
            if (hr == S_OK)
            {
                BSTR bstrNewImageFileName = NULL;
    
                hr = m_pWiaVideo->TakePicture(&bstrNewImageFileName);
    
                if (hr == S_OK)
                {
                    CSimpleStringWide strNewImageFileName(
                                                    bstrNewImageFileName);

                    if (strNewImageFileName.Length() > 0)
                    {
                        SignalNewImage(
                            &(CSimpleStringConvert::NaturalString(
                              strNewImageFileName)));
                    }
                }

                if (bstrNewImageFileName)
                {
                    SysFreeString(bstrNewImageFileName);
                    bstrNewImageFileName = NULL;
                }
            }
        }

        //
        // Set this event, regardless of an error because the driver
        // will be waiting for this event (with a timeout of course) to 
        // indicate that it can return from the TAKE_PICTURE request.
        //
        SetEvent(m_hPictureReadyEvent);

    }

    DBG_TRC(("CWiaLink::ThreadProc exiting..."));

    return hr;
}

///////////////////////////////
// StartThreadProc
//
// Static Fn.
//
DWORD WINAPI CWiaLink::StartThreadProc(void *pArgs)
{
    DBG_FN("CWiaLink::StartThreadProc");

    DWORD dwReturn = 0;

    if (pArgs)
    {
        CWiaLink *pWiaLink = reinterpret_cast<CWiaLink*>(pArgs);

        if (pWiaLink)
        {
            pWiaLink->ThreadProc(pArgs);
        }
        else
        {
            DBG_ERR(("CWiaLink::StartThreadProc, invalid value for pArgs, "
                     "this should be the 'this' pointer, unexpected error"));
        }
    }
    else
    {
        DBG_ERR(("CWiaLink::StartThreadProc, received NULL pArgs, this "
                 "should be the 'this' pointer, unexpected error"));
    }

    return dwReturn;

}

///////////////////////////////
// SignalNewImage
//
HRESULT CWiaLink::SignalNewImage(const CSimpleString  *pstrNewImageFileName)
{
    HRESULT hr = S_OK;

    DBG_FN("CWiaLink::SignalNewImage");

    //
    // It is possible that this gets called by the Still Image processor if
    // we get an unsolicited image (happens when you press external 
    // hardware button and capture filter has still pin on it).
    // However, if user initialized WiaVideo so that it doesn't use 
    // WIA, simply ignore this request and return.
    //
    if (!m_bEnabled)
    {
        DBG_WRN(("CWiaLink::SignalNewImage was called, but WiaLink is NOT "
                 "enabled"));
        return hr;
    }

    if (pstrNewImageFileName == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaLink::SignalNewImage, received NULL new image "
                         "file name"));
    }
    else if (m_dwWiaItemCookie == 0)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaLink::SignalNewImage, received WIA root "
                         "item not available."));
    }

    if (hr == S_OK)
    {
        CComPtr<IWiaPropertyStorage> pStorage;

        hr = GetDeviceStorage(&pStorage);

        if (hr == S_OK)
        {
            hr = CWiaUtil::SetProperty(pStorage, 
                                       WIA_DPV_LAST_PICTURE_TAKEN,
                                       pstrNewImageFileName);

            CHECK_S_OK2(hr, ("CWiaLink::SignalNewImage, failed to set Last "
                             "Picture Taken property for Wia Video Driver"));
        }
    }

    return hr;
}

///////////////////////////////
// GetDevice
//
HRESULT CWiaLink::GetDevice(IWiaItem  **ppWiaRootItem)
{
    HRESULT hr = S_OK;
    
    ASSERT(ppWiaRootItem != NULL);
    ASSERT(m_pGIT        != NULL);

    if ((ppWiaRootItem == NULL) ||
        (m_pGIT        == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::GetDevice, received NULL params"));
        return hr;
    }

    if (hr == S_OK)
    {
        CAccessLock Lock(&m_csLock);

        hr = m_pGIT->GetInterfaceFromGlobal(
                                    m_dwWiaItemCookie,
                                    IID_IWiaItem,
                                    reinterpret_cast<void**>(ppWiaRootItem));
    }

    return hr;
}

///////////////////////////////
// GetDeviceStorage
//
HRESULT CWiaLink::GetDeviceStorage(IWiaPropertyStorage **ppPropertyStorage)
{
    HRESULT hr = S_OK;
    
    ASSERT(ppPropertyStorage != NULL);
    ASSERT(m_pGIT            != NULL);

    if ((ppPropertyStorage == NULL) ||
        (m_pGIT            == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::GetDeviceStorage, received NULL params"));
        return hr;
    }

    if (hr == S_OK)
    {
        CAccessLock Lock(&m_csLock);

        hr = m_pGIT->GetInterfaceFromGlobal(
                                 m_dwPropertyStorageCookie,
                                 IID_IWiaPropertyStorage,
                                 reinterpret_cast<void**>(ppPropertyStorage));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\wialink.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaLink.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/06
 *
 *  DESCRIPTION: Establishes the link between WiaVideo and the Wia Video Driver
 *
 *****************************************************************************/

#ifndef _WIALINK_H_
#define _WIALINK_H_

/////////////////////////////////////////////////////////////////////////////
// CWiaLink

class CWiaLink
{
public:
    
    ///////////////////////////////
    // Constructor
    //
    CWiaLink();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CWiaLink();

    ///////////////////////////////
    // Init
    //
    HRESULT Init(const CSimpleString *pstrWiaDeviceID,
                 class CWiaVideo     *pWiaVideo);

    ///////////////////////////////
    // Term
    //
    HRESULT Term();

    ///////////////////////////////
    // StartMonitoring
    //
    HRESULT StartMonitoring();

    ///////////////////////////////
    // StopMonitoring
    //
    HRESULT StopMonitoring();

    ///////////////////////////////
    // GetDevice
    //
    HRESULT GetDevice(IWiaItem  **ppWiaRootItem);

    ///////////////////////////////
    // GetDeviceStorage
    //
    HRESULT GetDeviceStorage(IWiaPropertyStorage **ppWiaPropertyStorage);

    ///////////////////////////////
    // SignalNewImage
    //
    HRESULT SignalNewImage(const CSimpleString *pstrNewImageFileName);

    ///////////////////////////////
    // ThreadProc
    //
    HRESULT ThreadProc(void *pArgs);

    ///////////////////////////////
    // IsEnabled
    //
    BOOL IsEnabled()
    {
        return m_bEnabled;
    }

private:

    HRESULT CreateWiaEvents(HANDLE  *phTakePictureEvent,
                            HANDLE  *phPictureReadyEvent);


    static DWORD WINAPI StartThreadProc(void *pArgs);

    CRITICAL_SECTION                m_csLock;
    CSimpleString                   m_strDeviceID;
    class CWiaVideo                 *m_pWiaVideo;
    CComPtr<IGlobalInterfaceTable>  m_pGIT;
    DWORD                           m_dwWiaItemCookie;
    DWORD                           m_dwPropertyStorageCookie;
    HANDLE                          m_hTakePictureEvent;
    HANDLE                          m_hPictureReadyEvent;
    HANDLE                          m_hTakePictureThread;
    BOOL                            m_bExitThread;
    BOOL                            m_bEnabled;
};


#endif // _WIALINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\wiautil.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaUtil.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/07
 *
 *  DESCRIPTION: Provides supporting DShow utility functions used to build 
 *               preview graph
 *
 *****************************************************************************/

#ifndef _WIAUTIL_H_
#define _WIAUTIL_H_

/////////////////////////////////////////////////////////////////////////////
// CWiaUtil

class CWiaUtil
{
public:

    static HRESULT CreateWiaDevMgr(IWiaDevMgr **ppDevMgr);

    static HRESULT CreateRootItem(IWiaDevMgr          *pDevMgr,
                                  const CSimpleString *pstrWiaDeviceId,
                                  IWiaItem            **ppRootItem);

    static HRESULT FindWiaIdByDShowId(const CSimpleString *pstrDShowId,
                                      CSimpleString       *pstrWiaId,
                                      IWiaItem            **ppRootItem = NULL);

    static HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID, 
                               LONG                *pnValue);

    static HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID, 
                               CSimpleStringWide   *pstrPropertyValue);


    static HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               LONG                nValue);

    static HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               const CSimpleString *pstrPropVal);

    static HRESULT GetUseVMR(BOOL   *pbUseVMR);

private:

    static HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               const PROPVARIANT   *ppv, 
                               PROPID              nNameFirst);


    static HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               PROPVARIANT         *pPropVar);
};

/////////////////////////////////////////////////////////////////////////////
// CRegistry

class CRegistry
{
public:

    CRegistry(HKEY          hRoot,
              const TCHAR   *pszKeyPath);

    virtual ~CRegistry();

    HRESULT GetDWORD(const TCHAR   *pszVarName,
                     DWORD         *pdwValue,
                     BOOL          bSetIfNotExist = FALSE);

    HRESULT SetDWORD(const TCHAR *pszVarName,
                     DWORD dwValue);

    HRESULT GetString(const TCHAR   *pszVarName,
                      TCHAR         *pszValue,
                      DWORD         cchValue,
                      BOOL          bSetIfNotExist = FALSE);

    HRESULT SetString(const TCHAR *pszVarName,
                      TCHAR       *pszValue);

    operator HKEY() const
    {
        return m_hRootKey;
    }

private:
    HKEY   m_hRootKey;
    BOOL   m_bReadOnlyKey;
};


#endif // _WIAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\eventhandlerinfo.cpp ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/10/2002
 *
 *  @doc    INTERNAL
 *
 *  @module EventHandlerInfo.cpp - Declaration for <c EventHandlerInfo> |
 *
 *  This file contains the implementation of the <c EventHandlerInfo> class.
 *
 *****************************************************************************/
#include "precomp.h"
/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | EventHandlerInfo | EventHandlerInfo |
 *
 *  We initialize all member variables.  In general, this sets the values to 0,
 *  except:
 *  <nl><md EventHandlerInfo::m_ulSig> is set to be EventHandlerInfo_INIT_SIG.
 *  <nl><md EventHandlerInfo::m_cRef> is set to be 1.
 *
 *****************************************************************************/
EventHandlerInfo::EventHandlerInfo(
    const CSimpleStringWide &cswName,
    const CSimpleStringWide &cswDescription,
    const CSimpleStringWide &cswIcon,
    const CSimpleStringWide &cswCommandline,
    const GUID              &guidCLSID
    ) :
     m_ulSig(EventHandlerInfo_INIT_SIG),
     m_cRef(1),
     m_cswName(cswName),
     m_cswDescription(cswDescription),
     m_cswIcon(cswIcon),
     m_cswCommandline(cswCommandline),
     m_guidCLSID(guidCLSID)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | EventHandlerInfo | ~EventHandlerInfo |
 *
 *  Do any cleanup that is not already done.
 *
 *  Also:
 *  <nl><md EventHandlerInfo::m_ulSig> is set to be EventHandlerInfo_DEL_SIG.
 *
 *****************************************************************************/
EventHandlerInfo::~EventHandlerInfo()
{
    m_ulSig = EventHandlerInfo_DEL_SIG;
    m_cRef = 0;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | EventHandlerInfo | AddRef |
 *
 *  Increments this object's ref count.  We should always AddRef when handing
 *  out a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been incremented.
 *****************************************************************************/
ULONG __stdcall EventHandlerInfo::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | EventHandlerInfo | Release |
 *
 *  Decrement this object's ref count.  We should always Release when finished
 *  with a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been decremented.
 *****************************************************************************/
ULONG __stdcall EventHandlerInfo::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) 
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | EventHandlerInfo | getName |
 *
 *  Accessor method for the friendly Name for this handler
 *  It's usage is something like:
 *  <nl>CSimpleStringWide cswTemp = pEventHandlerInfo->getName();
 *
 *  @rvalue CSimpleStringWide    | 
 *              The handler name.  Notice that the return is a copy by value
 *              of the <md EventHandlerInfo::m_cswName> member.
 *****************************************************************************/
CSimpleStringWide EventHandlerInfo::getName()
{
    return m_cswName;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | EventHandlerInfo | getDescription |
 *
 *  Accessor method for the description for this handler
 *  It's usage is something like:
 *  <nl>CSimpleStringWide cswTemp = pEventHandlerInfo->getDescription();
 *
 *  @rvalue CSimpleStringWide    | 
 *              The handler name.  Notice that the return is a copy by value
 *              of the <md EventHandlerInfo::m_cswDescription> member.
 *****************************************************************************/
CSimpleStringWide EventHandlerInfo::getDescription()
{
    return m_cswDescription;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | EventHandlerInfo | getIconPath |
 *
 *  Accessor method for the icon path for this handler
 *  It's usage is something like:
 *  <nl>CSimpleStringWide cswTemp = pEventHandlerInfo->getIconPath();
 *
 *  @rvalue CSimpleStringWide    | 
 *              The handler name.  Notice that the return is a copy by value
 *              of the <md EventHandlerInfo::m_cswIcon> member.
 *****************************************************************************/
CSimpleStringWide EventHandlerInfo::getIconPath()
{
    return m_cswIcon;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | EventHandlerInfo | getCommandline |
 *
 *  Accessor method for the commandline for this handler.  The commandline
 *  will be the empty string for COM registered apps.
 *  It's usage is something like:
 *  <nl>CSimpleStringWide cswTemp = pEventHandlerInfo->getCommandline();
 *
 *  @rvalue CSimpleStringWide    | 
 *              The handler name.  Notice that the return is a copy by value
 *              of the <md EventHandlerInfo::m_cswCommandline> member.
 *****************************************************************************/
CSimpleStringWide EventHandlerInfo::getCommandline()
{
    return m_cswCommandline;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | EventHandlerInfo | getCLSID |
 *
 *  Accessor method for the CLSID for this handler.
 *
 *  @rvalue GUID    | 
 *              The handler name.  Notice that the return is a copy by value
 *              of the <md EventHandlerInfo::m_guidCLSID> member.
 *****************************************************************************/
GUID EventHandlerInfo::getCLSID()
{
    return m_guidCLSID;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | EventHandlerInfo | getEventGuid |
 *
 *  For debugging: this method dumps the internal fields of this object.
 *
 *****************************************************************************/
VOID EventHandlerInfo::Dump()
{
    WCHAR   wszGuidString[50] = {0};

    DBG_TRC(("EventHandlerInfo for (%p)", this));
    DBG_TRC(("    Name:        [%ws]", m_cswName.String()));
    DBG_TRC(("    Description: [%ws]", m_cswDescription.String()));
    DBG_TRC(("    Icon:        [%ws]", m_cswIcon.String()));
    DBG_TRC(("    Commandline: [%ws]", m_cswCommandline.String()));
    StringFromGUID2(m_guidCLSID, wszGuidString, sizeof(wszGuidString)/sizeof(wszGuidString[0]));
    DBG_TRC(("    CLSID:       [%ws]", wszGuidString));
    DBG_TRC((" "));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\wiavideo.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaVideo.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: 
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop

#include "WiaVideo_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WiaVideo, CWiaVideo)
END_OBJECT_MAP()

///////////////////////////////
// DllMain
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE   hInstance, 
                    DWORD       dwReason, 
                    LPVOID      lpReserved)
{
    lpReserved;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WIAVIDEOLib);
        DisableThreadLibraryCalls(hInstance);

        DBG_INIT(hInstance);

        DBG_FN("DllMain - ProcessAttach");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DBG_TERM();

        _Module.Term();
    }

    return TRUE;    // ok
}

///////////////////////////////
// DllCanUnloadNow
//
// Used to determine whether the 
// DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    DBG_FN("DllCanUnloadNow");

    DBG_TRC(("DllCanUnloadNow - Lock Count = '%lu'", _Module.GetLockCount()));

    return(_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

///////////////////////////////
// DllGetClassObject
//
// Returns a class factory to 
// create an object of the 
// requested type

STDAPI DllGetClassObject(REFCLSID   rclsid, 
                         REFIID     riid, 
                         LPVOID     *ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

///////////////////////////////
// DllRegisterServer
//
// Adds entries to the system 
// registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

///////////////////////////////
// DllUnregisterServer
//
// Removes entries from the 
// system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\sticfunc.c ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       sticfunc.h
*
*  VERSION:     1.0
*
*  DATE:        6 March, 2001
*
*  DESCRIPTION:
*  This file contains "C" style functions used in the STI/WIA service.
*
******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
//  This function is here because of a problem with header files.  Our 
//  precompiled header includes <winnt.h>, which defines NT_INCLUDED.  
//  Unfortuneately, <nt.h> also defines NT_INCLUDED.  However, the definition for
//  the USER_SHARED_DATA structure can only be retrieved from nt.h.  This 
//  creates a problem for us, since we cannot include nt.h in a C++ source file
//  that needs this structure, since we'll get multiple re-definitions of
//  most of the structures in nt.h.  We also cannot include nt.h in the 
//  precompiled header itsself, since our files need certain fields defined
//  in winnt.h (and remember that including nt.h will define NT_INCLUDED, which
//  means everything in winnt.h is skipped).
//  The easiest solution was to put this function in a C file, since the CXX
//  precompiled header will not be used for this file.
//
ULONG GetCurrentSessionID() 
{
    return USER_SHARED_DATA->ActiveConsoleId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\sticfunc.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       sticfunc.h
*
*  VERSION:     1.0
*
*  DATE:        6 March, 2001
*
*  DESCRIPTION:
*   Header file used for "C" functions defined in sticfunc.c
*
******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

ULONG GetCurrentSessionID();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\video\wiautil.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       WiaUtil.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/07
 *
 *  DESCRIPTION: Provides support functions for Wia related activities
 *
 *****************************************************************************/
 
#include <precomp.h>
#pragma hdrstop

///////////////////////////////
// Constants
//
const UINT  CREATE_DEVICE_RETRY_MAX_COUNT = 5;
const UINT  CREATE_DEVICE_RETRY_WAIT      = 300;

const TCHAR* WIAVIDEO_REG_KEY                = _T("System\\CurrentControlSet\\Control\\StillImage\\WiaVideo");
const TCHAR* WIAVIDEO_REG_VAL_USE_VMR        = _T("UseVMR"); 
const BOOL   WIAVIDEO_REG_VAL_DEFAULT_USEVMR = FALSE;

///////////////////////////////
// CreateRootItem
//
// Static Fn
//
HRESULT CWiaUtil::CreateRootItem(IWiaDevMgr          *pDevMgr,
                                 const CSimpleString *pstrWiaDeviceId,
                                 IWiaItem            **ppRootItem)
{
    HRESULT hr = S_OK;

    ASSERT(pDevMgr         != NULL);
    ASSERT(pstrWiaDeviceId != NULL);
    ASSERT(ppRootItem      != NULL);

    if ((pDevMgr         == NULL) ||
        (pstrWiaDeviceId == NULL) ||
        (ppRootItem      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::CreateRootItem, received NULL param"));

        return hr;
    }

    if (hr == S_OK)
    {
        BOOL bRetry = TRUE;

        for (UINT uiRetryCount = 0;
             (uiRetryCount < CREATE_DEVICE_RETRY_MAX_COUNT) && (bRetry);
             ++uiRetryCount)
        {
            hr = pDevMgr->CreateDevice(CSimpleBStr(*pstrWiaDeviceId), 
                                       ppRootItem);

            if (SUCCEEDED(hr))
            {
                //
                // Break out of loop
                //
                bRetry = FALSE;
            }
            else if (hr == WIA_ERROR_BUSY)
            {
                //
                // Wait a little while before retrying
                //
                Sleep(CREATE_DEVICE_RETRY_WAIT);
            }
            else
            {
                //
                // All other errors are considered fatal
                //
                bRetry = FALSE;
            }
        }
    }

    return hr;
}

///////////////////////////////
// FindWiaIdByDShowId
//
// Static Fn
//
HRESULT CWiaUtil::FindWiaIdByDShowId(const CSimpleString *pstrDShowId,
                                     CSimpleString       *pstrWiaId,
                                     IWiaItem            **ppRootItem)
{
    HRESULT                     hr      = S_OK;
    BOOL                        bFound  = FALSE;
    CComPtr<IWiaDevMgr>         pDevMgr;
    CComPtr<IEnumWIA_DEV_INFO>  pEnum;

    ASSERT(pstrDShowId != NULL);
    ASSERT(pstrWiaId   != NULL);

    if ((pstrDShowId == NULL) ||
        (pstrWiaId   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::FindWiaDeviceGeneric received a "
                         "NULL param"));

        return hr;
    }

    if (hr == S_OK)
    {
        hr = CreateWiaDevMgr(&pDevMgr);
    }

    if (hr == S_OK)
    {
        hr = pDevMgr->EnumDeviceInfo(0, &pEnum);
    }

    while ((hr == S_OK) && (!bFound))
    {
        CComPtr<IWiaItem>             pRootItem        = NULL;
        CComPtr<IWiaPropertyStorage>  pPropStorage     = NULL;
        CSimpleString                 strDShowDeviceID = TEXT("");
        CSimpleString                 strWiaDeviceID   = TEXT("");

        //
        // Get the next device in the enumeration.
        //
        hr = pEnum->Next(1, &pPropStorage, NULL);

        //
        // Get the device's Wia Device ID
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, WIA_DIP_DEV_ID, &strWiaDeviceID);
        }

        //
        // Create the new device.  We do this because the driver is only 
        // told by the WIA service to load its DShowDeviceID property 
        // when it is created.
        //
        if (hr == S_OK)
        {
            hr = CreateRootItem(pDevMgr, &strWiaDeviceID, &pRootItem);
        }

        //
        // Attempt to get the DShowDeviceID of the root item.
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, 
                             WIA_DPV_DSHOW_DEVICE_PATH, 
                             &strDShowDeviceID);
            // 
            // We got the DShowDeviceID of the WIA device, now check
            // to see if it is the one we are looking for.
            //
            if (hr == S_OK)
            {
                if (pstrDShowId->CompareNoCase(strDShowDeviceID) == 0)
                {
                    //
                    // We found our DShow device ID, return the Wia Device ID
                    //
                    if (strWiaDeviceID.Length() > 0)
                    {
                        bFound = TRUE;
                        *pstrWiaId = strWiaDeviceID;

                        if (ppRootItem)
                        {
                            *ppRootItem = pRootItem;
                            (*ppRootItem)->AddRef();
                        }
                    }
                    else
                    {
                        bFound = FALSE;
                        hr = E_FAIL;

                        CHECK_S_OK2(hr, 
                                    ("Found DShow Device ID '%ls', but "
                                     "couldn't get its WIA Device ID, "
                                     "this should never happen",
                                     CSimpleStringConvert::WideString(
                                            strDShowDeviceID).String()));
                    }
                }
            }
            else
            {
                //
                // we couldn't get the DShowDeviceID property from the 
                // device, but that's fine since not all imaging devices
                // have this property.

                hr = S_OK;
            }
        }
    }

    return hr;
}

///////////////////////////////
// CreateWiaDevMgr
//
// Static Fn
//
HRESULT CWiaUtil::CreateWiaDevMgr(IWiaDevMgr **ppDevMgr)
{
    HRESULT hr = S_OK;

    ASSERT(ppDevMgr != NULL);

    if (ppDevMgr == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::CreateWiaDevMgr received a NULL param"));

        return hr;
    }

    hr = CoCreateInstance(CLSID_WiaDevMgr, 
                          NULL, 
                          CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,
                          (void**) ppDevMgr);

    CHECK_S_OK2(hr, ("CWiaUtil::CreateWiaDevMgr, failed to create the Wia "
                     "Device Manager object"));

    return hr;
}

///////////////////////////////
// SetProperty
//
// Generic
//
HRESULT CWiaUtil::SetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID,
                              const PROPVARIANT   *ppv, 
                              PROPID              nNameFirst)
{
    DBG_FN("CWiaUtil::SetProperty");

    HRESULT  hr = 0;
    PROPSPEC ps = {0};

    ASSERT(pPropStorage != NULL);
    ASSERT(ppv          != NULL);

    if ((pPropStorage == NULL) ||
        (ppv          == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::SetProperty received NULL param"));

        return hr;
    }

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (hr == S_OK)
    {
        hr = pPropStorage->WriteMultiple(1, &ps, ppv, nNameFirst);
    }

    return hr;
}

///////////////////////////////
// SetProperty
//
// For 'long' properties
//  
//
HRESULT CWiaUtil::SetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID,
                              LONG                nValue)
{
    HRESULT     hr = S_OK;
    PROPVARIANT pv = {0};

    ASSERT(pPropStorage != NULL);

    if (pPropStorage == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::SetProperty received NULL param"));

        return hr;
    }

    pv.vt   = VT_I4;
    pv.lVal = nValue;

    hr = SetProperty(pPropStorage, nPropID, &pv, 2);

    return hr;
}

///////////////////////////////
// SetProperty
//
// For 'string' properties
//  
//
HRESULT CWiaUtil::SetProperty(IWiaPropertyStorage   *pPropStorage, 
                              PROPID                nPropID,
                              const CSimpleString   *pstrPropVal)
{
    HRESULT             hr = S_OK;
    PROPVARIANT         pv = {0};

    ASSERT(pPropStorage != NULL);
    ASSERT(pstrPropVal  != NULL);

    if ((pPropStorage   == NULL) ||
        (pstrPropVal    == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::SetProperty received NULL param"));

        return hr;
    }

    pv.vt        = VT_BSTR;
    pv.bstrVal   = CSimpleBStr(*pstrPropVal);

    hr = SetProperty(pPropStorage, nPropID, &pv, 2);

    return hr;
}

///////////////////////////////
// GetProperty
//
// Generic
//
HRESULT CWiaUtil::GetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID,
                              PROPVARIANT         *pPropVar)
{
    DBG_FN("CWiaUtil::GetProperty");

    HRESULT hr = S_OK;

    ASSERT(pPropStorage != NULL);
    ASSERT(pPropVar     != NULL);

    if ((pPropStorage == NULL) ||
        (pPropVar     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty received NULL param"));
        return hr;
    }

    PropVariantInit(pPropVar);

    PROPSPEC ps = {0};

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (SUCCEEDED(hr))
    {
        hr = pPropStorage->ReadMultiple(1, &ps, pPropVar);

        if (hr != S_OK)
        {
            CHECK_S_OK2(hr, ("CWiaUtil::GetProperty, ReadMultiple failed "
                             "for prop ID '%lu' (0x%08lx)", 
                             nPropID, 
                             nPropID));
        }
    }
    else
    {
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty, QueryInterface failed "
                         "for IWiaPropertyStorage"));
    }

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'long' properties
//
HRESULT CWiaUtil::GetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID, 
                              LONG                *pnValue)
{
    HRESULT hr = S_OK;

    ASSERT(pPropStorage != NULL);
    ASSERT(pnValue      != NULL);

    if ((pPropStorage == NULL) ||
        (pnValue      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty received a NULL param"));

        return hr;
    }
    
    PROPVARIANT pvPropValue;

    *pnValue = 0;

    PropVariantInit(&pvPropValue);

    hr = GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_I4) || 
            (pvPropValue.vt == VT_UI4))
        {
            *pnValue = pvPropValue.lVal;
        }
    }

    PropVariantClear(&pvPropValue);

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'string' properties
//
HRESULT CWiaUtil::GetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID, 
                              CSimpleStringWide   *pstrPropertyValue)
{
    HRESULT hr = S_OK;

    ASSERT(pPropStorage      != NULL);
    ASSERT(pstrPropertyValue != NULL);

    if ((pPropStorage      == NULL) ||
        (pstrPropertyValue == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty received a NULL param"));
        return hr;
    }
    
    PROPVARIANT pvPropValue;

    *pstrPropertyValue = L"";

    PropVariantInit(&pvPropValue);

    hr = GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_LPWSTR) || 
            (pvPropValue.vt == VT_BSTR))
        {
            *pstrPropertyValue = pvPropValue.pwszVal;
        }
    }

    PropVariantClear(&pvPropValue);

    return hr;
}


///////////////////////////////
// GetUseVMR
//
HRESULT CWiaUtil::GetUseVMR(BOOL   *pbUseVMR)
{
    ASSERT(pbUseVMR != NULL);

    HRESULT hr = S_OK;

    CRegistry Reg(HKEY_LOCAL_MACHINE, 
                  WIAVIDEO_REG_KEY);

    if (pbUseVMR == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetUseVMR received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pbUseVMR = WIAVIDEO_REG_VAL_DEFAULT_USEVMR;

        hr = Reg.GetDWORD(WIAVIDEO_REG_VAL_USE_VMR,
                          (DWORD*) pbUseVMR,
                          TRUE);
    }

    return hr;
}

///////////////////////////////
// CRegistry Constructor
//
CRegistry::CRegistry(HKEY         hKeyRoot,
                     const  TCHAR *pszKeyPath) :
            m_hRootKey(NULL),
            m_bReadOnlyKey(FALSE)
{
    LRESULT lr              = ERROR_SUCCESS;
    DWORD   dwDisposition   = 0;

    lr = RegCreateKeyEx(hKeyRoot,
                        pszKeyPath,
                        0,
                        NULL,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &m_hRootKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_ACCESS_DENIED)
        {
            lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              pszKeyPath,
                              0,
                              KEY_READ,
                              &m_hRootKey);

            if (lr == ERROR_SUCCESS)
            {
                m_bReadOnlyKey = TRUE;
                DBG_TRC(("CRegistry::CRegistry, opened key '%ls' for read-access only, "
                         "probably logged on as a non-admin.", pszKeyPath));
            }
            else
            {
                HRESULT hr = E_FAIL;
                CHECK_S_OK2(hr, ("CRegistry::CRegistry, failed to open registry path "
                                 "'%ls', lResult = %d", pszKeyPath, lr));
            }
        }
        else
        {
            HRESULT hr = E_FAIL;
            CHECK_S_OK2(hr, ("CRegistry::CRegistry, failed to create registry path "
                             "'%ls', lResult = %d", pszKeyPath, lr));
        }
    }
}

///////////////////////////////
// CRegistry Destructor
//
CRegistry::~CRegistry()
{
    if (m_hRootKey)
    {
        RegCloseKey(m_hRootKey);
        m_hRootKey = NULL;
    }
}

///////////////////////////////
// GetDWORD
//
HRESULT CRegistry::GetDWORD(const TCHAR   *pszVarName,
                            DWORD         *pdwValue,
                            BOOL          bSetIfNotExist)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pdwValue   != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    if ((pszVarName == NULL) ||
        (pdwValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::GetDWORD, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::GetDWORD, m_hRootKey is NULL"));
        return hr;
    }

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pdwValue,
                         &dwSize);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            if (!m_bReadOnlyKey)
            {
                hr = SetDWORD(pszVarName, *pdwValue);
            }
            else
            {
                DBG_TRC(("CRegistry::GetDWORD, key is marked read-only, "
                         "probably logged on as non-admin, cannot set the "
                         "key.  This is not fatal"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetDWORD
//
HRESULT CRegistry::SetDWORD(const TCHAR *pszVarName,
                            DWORD dwValue)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;

    if (pszVarName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::SetDWORD, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::SetDWORD, m_hRootKey is NULL"));
        return hr;
    }


    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_DWORD,
                       (BYTE*) &dwValue,
                       sizeof(dwValue));

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////
// GetString
//
HRESULT CRegistry::GetString(const TCHAR   *pszVarName,
                             TCHAR         *pszValue,
                             DWORD         cchValue,
                             BOOL          bSetIfNotExist)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pszValue   != NULL);

    HRESULT hr          = S_OK;
    LRESULT lr          = ERROR_SUCCESS;
    DWORD   dwType      = REG_SZ;
    DWORD   dwNumBytes  = 0;

    if ((pszVarName == NULL) ||
        (pszValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::GetString, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::GetString, m_hRootKey is NULL"));
        return hr;
    }

    dwNumBytes = cchValue * sizeof(TCHAR) + 1*sizeof(TCHAR);

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pszValue,
                         &dwNumBytes);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            hr = SetString(pszVarName, pszValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetString
//
HRESULT CRegistry::SetString(const TCHAR *pszVarName,
                             TCHAR       *pszValue)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pszValue   != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwSize = 0;

    if ((pszVarName == NULL) ||
        (pszValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::SetString, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::SetString, m_hRootKey is NULL"));
        return hr;
    }

    dwSize = (_tcslen(pszValue) * sizeof(TCHAR)) + (1 * sizeof(TCHAR));

    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_SZ,
                       (BYTE*) pszValue,
                       dwSize);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\precomp.h ===
#include <windows.h>
#include <aclapi.h>
#include <sddl.h>
#include <stdio.h>
#include "apiutil.h"
#include "coredbg.h"

#include "wia.h"
#include "userenv.h"
#include <stilib.h>

#include "EventIncludes.h"

#ifdef __cplusplus
extern "C"
{
#endif

//
// From Terminal services
//
#include <winsta.h>
#include <syslib.h>

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\eventincludes.h ===
//
//  We have to put these includes here, and not in the precompiled header due to some
//  problems with templates when compiling the C files
//
#include "Simstr.h"
#include "SimReg.h"
#include "Simlist.h"
#include "WiaDeviceKey.h"
#include "EventHandlerInfo.h"
#include "StiEventHandlerInfo.h"
#include "WiaEventHandlerLookup.h"
#include "StiEventHandlerLookup.h"

#define STI_DEVICE_EVENT    0xF0000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\eventhandlerinfo.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/10/2002
 *
 *  @doc    INTERNAL
 *
 *  @module EventHandlerInfo.h - Definitions for <c EventHandlerInfo> |
 *
 *  This file contains the class definition for <c EventHandlerInfo>.
 *
 *****************************************************************************/

//
//  Defines
//

#define EventHandlerInfo_UNINIT_SIG   0x55497645
#define EventHandlerInfo_INIT_SIG     0x49497645
#define EventHandlerInfo_TERM_SIG     0x54497645
#define EventHandlerInfo_DEL_SIG      0x44497645

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class EventHandlerInfo | Holds information pertaining to a WIA persistent event handler
 *  
 *  @comm
 *  This class continas the all information relating to a particular
 *  WIA persistent event handler.  This information can be used to check whether a
 *  given handler supports a device/event pair; and can also be used to
 *  launch the handler itsself.
 *
 *****************************************************************************/
class EventHandlerInfo 
{
//@access Public members
public:

    // @cmember Constructor
    EventHandlerInfo(const CSimpleStringWide &cswName,
                     const CSimpleStringWide &cswDescription,
                     const CSimpleStringWide &cswIcon,
                     const CSimpleStringWide &cswCommandline,
                     const GUID              &guidCLSID);
    // @cmember Destructor
    virtual ~EventHandlerInfo();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Accessor method for the DeviceID this handler is registered for
    CSimpleStringWide   getDeviceID();
    // @cmember Accessor method for the friendly Name for this handler
    CSimpleStringWide   getName();
    // @cmember Accessor method for the description for this handler
    CSimpleStringWide   getDescription();
    // @cmember Accessor method for the icon path for this handler
    CSimpleStringWide   getIconPath();
    // @cmember Accessor method for the Commandline for this handler (if it has one)
    CSimpleStringWide   getCommandline();
    // @cmember Accessor method for the CLSID of this handler
    GUID                getCLSID();

    // @cmember For debugging: dumps the object members
    VOID            Dump();


//@access Private members
private:

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember The friendly Name for this handler
    CSimpleStringWide   m_cswName;
    // @cmember The description for this handler
    CSimpleStringWide   m_cswDescription;
    // @cmember The icon path for this handler
    CSimpleStringWide   m_cswIcon;
    // @cmember The Commandline for this handler (if it has one)
    CSimpleStringWide   m_cswCommandline;
    // @cmember The CLSID of this handler
    GUID            m_guidCLSID;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | EventHandlerInfo | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag EventHandlerInfo_UNINIT_SIG | 'EvIU' - Object has not been successfully
    //       initialized
    //   @flag EventHandlerInfo_INIT_SIG | 'EvII' - Object has been successfully
    //       initialized
    //   @flag EventHandlerInfo_TERM_SIG | 'EvIT' - Object is in the process of
    //       terminating.
    //    @flag EventHandlerInfo_INIT_SIG | 'EvID' - Object has been deleted 
    //       (destructor was called)
    //
    // @mdata ULONG | EventHandlerInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata CSimpleStringWide | EventHandlerInfo | m_cswName | 
    //  The friendly Name for this handler
    //
    // @mdata CSimpleStringWide | EventHandlerInfo | m_cswDescription | 
    //  The description for this handler
    //
    // @mdata CSimpleStringWide | EventHandlerInfo | m_cswIcon | 
    //  The icon path for this handler
    //
    // @mdata CSimpleStringWide | EventHandlerInfo | m_cswCommandline | 
    //  The Commandline for this handler (if it has one)
    //
    // @mdata GUID | EventHandlerInfo | m_guidCLSID | 
    //  The CLSID of this handler
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\stieventhandlerinfo.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/13/2002
 *
 *  @doc    INTERNAL
 *
 *  @module StiEventHandlerInfo.h - Definitions for <c StiEventHandlerInfo> |
 *
 *  This file contains the class definition for <c StiEventHandlerInfo>.
 *
 *****************************************************************************/

//
//  Defines
//

#define StiEventHandlerInfo_UNINIT_SIG   0x55497645
#define StiEventHandlerInfo_INIT_SIG     0x49497645
#define StiEventHandlerInfo_TERM_SIG     0x54497645
#define StiEventHandlerInfo_DEL_SIG      0x44497645

#define STI_DEVICE_TOKEN    L"%1"
#define STI_EVENT_TOKEN     L"%2"

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class StiEventHandlerInfo | Information pertaining to a STI persistent event handler
 *  
 *  @comm
 *  This class contians the all information relating to a particular
 *  STI persistent event handler.  This information is typically used to
 *  launch the handler itsself, although a list of these may be presented for
 *  the user to choose which handler to launch via the STI Event prompt.
 *
 *****************************************************************************/
class StiEventHandlerInfo 
{
//@access Public members
public:

    // @cmember Constructor
    StiEventHandlerInfo(const CSimpleStringWide &cswAppName, const CSimpleStringWide &cswCommandline);
    // @cmember Destructor
    virtual ~StiEventHandlerInfo();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Accessor method for the application name
    CSimpleStringWide getAppName();
    // @cmember Accessor method for the commandline the application registered
    CSimpleStringWide getCommandline();
    // @cmember The commandline used to start the application, after substituting DeviceID and event parameters
    CSimpleStringWide getPreparedCommandline(const CSimpleStringWide &cswDeviceID, const CSimpleStringWide &cswEventGuid);
    // @cmember The commandline used to start the application, after substituting DeviceID and event parameters
    CSimpleStringWide getPreparedCommandline(const CSimpleStringWide &cswDeviceID, const GUID &guidEvent);

    // @cmember Dumps the object info to the trace log
    VOID Dump();

//@access Private members
private:

    CSimpleStringWide ExpandTokenIntoString(const CSimpleStringWide &cswInput,
                                            const CSimpleStringWide &cswToken,
                                            const CSimpleStringWide &cswTokenValue);

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember The STI handler name
    CSimpleStringWide m_cswAppName;
    // @cmember The STI handler commandline
    CSimpleStringWide m_cswCommandline;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | StiEventHandlerInfo | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag StiEventHandlerInfo_UNINIT_SIG | 'EvIU' - Object has not been successfully
    //       initialized
    //   @flag StiEventHandlerInfo_INIT_SIG | 'EvII' - Object has been successfully
    //       initialized
    //   @flag StiEventHandlerInfo_TERM_SIG | 'EvIT' - Object is in the process of
    //       terminating.
    //    @flag StiEventHandlerInfo_INIT_SIG | 'EvID' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @mdata ULONG | StiEventHandlerInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata CSimpleStringWide | StiEventHandlerInfo | m_cswAppName | 
    //  The application name of this STI event handler.
    //
    // @mdata CSimpleStringWide | StiEventHandlerInfo | m_cswCommandline | 
    //  The STI handler's commandline, used to launch the handler.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\stirpc.c ===
//#include "precomp.h"
#include <windows.h>
#include "apiutil.h"
#include "stirpc.h"
#include "stirpc_c.c"


handle_t
   STI_STRING_HANDLE_bind(
                          STI_STRING_HANDLE ServerName
                         )

/*++

Routine Description:

    This routine is called from the STI client stubs when
    it is necessary create an RPC binding to the server end

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       (LPWSTR)ServerName,
                                       STI_INTERFACE_W,
                                       PROT_SEQ_NP_OPTIONS_W
                                      );


    return BindHandle;

} // STI_STRING_HANDLE_bind()


void
   STI_STRING_HANDLE_unbind(
                            STI_STRING_HANDLE ServerName,
                            handle_t BindHandle
                           )

/*++

Routine Description:

    This routine calls a common unbind routine

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // STI_STRING_HANDLE_unbind()

/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\stieventhandlerlookup.cpp ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/14/2002
 *
 *  @doc    INTERNAL
 *
 *  @module StiEventHandlerLookup.cpp - Implementation for <c StiEventHandlerLookup> |
 *
 *  This file contains the implementation of the <c StiEventHandlerLookup> class.
 *
 *****************************************************************************/
#include "precomp.h"

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | StiEventHandlerLookup | StiEventHandlerLookup |
 *
 *  We initialize all member variables.  In general, this sets the values to 0,
 *  except:
 *  <nl><md StiEventHandlerLookup::m_ulSig> is set to be StiEventHandlerLookup_INIT_SIG.
 *  <nl><md StiEventHandlerLookup::m_cRef> is set to be 1.
 *
 *****************************************************************************/
StiEventHandlerLookup::StiEventHandlerLookup() :
     m_ulSig(StiEventHandlerLookup_INIT_SIG),
     m_cRef(1)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | StiEventHandlerLookup | ~StiEventHandlerLookup |
 *
 *  Do any cleanup that is not already done.  We:
 *  <nl> - Call <mf StiEventHandlerLookup::ClearListOfHandlers>
 *
 *  Also:
 *  <nl><md StiEventHandlerLookup::m_ulSig> is set to be StiEventHandlerLookup_DEL_SIG.
 *
 *****************************************************************************/
StiEventHandlerLookup::~StiEventHandlerLookup()
{
    m_ulSig = StiEventHandlerLookup_DEL_SIG;
    m_cRef = 0;

    ClearListOfHandlers();
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | StiEventHandlerLookup | AddRef |
 *
 *  Increments this object's ref count.  We should always AddRef when handing
 *  out a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been incremented.
 *****************************************************************************/
ULONG __stdcall StiEventHandlerLookup::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | StiEventHandlerLookup | Release |
 *
 *  Decrement this object's ref count.  We should always Release when finished
 *  with a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been decremented.
 *****************************************************************************/
ULONG __stdcall StiEventHandlerLookup::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) 
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  bool | StiEventHandlerLookup | getHandlerFromName |
 *
 *  This method is used to create a <c StiEventHandlerInfo> object describing
 *  the handler named <p cswHandlerName>.
 *
 *  @parm   const CSimpleStringWide & | cswHandlerName | 
 *          The STI handler name registered under the StillImage software key.
 *
 *  @rvalue NULL    | 
 *              The handler was not found, therefore no information was returned.
 *  @rvalue non-NULL    | 
 *              A pointer to a new <c StiEventHandlerInfo>.  Caller must release.
 *****************************************************************************/
StiEventHandlerInfo* StiEventHandlerLookup::getHandlerFromName(
    const CSimpleStringWide &cswHandlerName)
{
    StiEventHandlerInfo *pStiEventHandlerInfo = NULL;

    CSimpleReg          csrGlobalHandlers(HKEY_LOCAL_MACHINE, STI_GLOBAL_EVENT_HANDLER_PATH, false, KEY_READ);
    CSimpleStringWide   cswCommandline = csrGlobalHandlers.Query(cswHandlerName, L"");

    if (cswCommandline.Length() > 0)
    {
        pStiEventHandlerInfo = new StiEventHandlerInfo(cswHandlerName,
                                                       cswCommandline);
    }

    return pStiEventHandlerInfo;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  VOID | StiEventHandlerLookup | ClearListOfHandlers |
 *
 *  Frees resources associated with our list of handlers
 *
 *****************************************************************************/
VOID StiEventHandlerLookup::ClearListOfHandlers()
{
    CSimpleLinkedList<StiEventHandlerInfo*>::Iterator iter;
    for (iter = m_ListOfHandlers.Begin(); iter != m_ListOfHandlers.End(); ++iter)
    {
        StiEventHandlerInfo *pStiEventHandlerInfo = *iter;

        if (pStiEventHandlerInfo)
        {
            pStiEventHandlerInfo->Release();
        }
    }
    m_ListOfHandlers.Destroy();
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  VOID | StiEventHandlerLookup | FillListOfHandlers |
 *
 *  This method fills the <md StiEventHandlerLookup::m_ListOfHandlers> with
 *  the appropriate Sti registered handlers.
 *
 *  The hueristic used is:
 *  <nl>1.  Get the "LaunchApplications" value for the event.
 *  <nl>2.  For each App specified in the LauncApplications value,
 *          create a <c StiEventHandlerInfo> and insert it into
 *          <md StiEventHandlerLookup::m_ListOfHandlers>.
 *          Note:  If the "LaunchApplications" value == "*", then
 *          we get all STI registered apps.
 *
 *  Note that this method will destroy the existing list of handlers by calling
 *  <mf ClearListOfHandlers::FillListOfHandlers> as it's first operation.
 *
 *  @parm   const CSimpleStringWide & | cswDeviceID | 
 *          The Device on which the event occured
 *  @parm   const GUID & | guidEvent | 
 *          The Event generated by the device
 *****************************************************************************/
VOID StiEventHandlerLookup::FillListOfHandlers(
    const CSimpleStringWide &cswDeviceID,
    const GUID              &guidEvent)
{
    WiaDeviceKey        wiaDeviceKey(cswDeviceID);
    CSimpleStringWide   cswEventKeyPath = wiaDeviceKey.getDeviceEventKeyPath(guidEvent);

    ClearListOfHandlers();

    //
    //  If we can find the device event key, then
    //  read the LaunchApplications value for this key.
    //  If it was not found, then we assume this is a bogus event for
    //  this device, so we do nothing.
    //
    if (cswEventKeyPath.Length() > 0)
    {
        CSimpleReg          csrEventKey(HKEY_LOCAL_MACHINE, cswEventKeyPath, false, KEY_READ);
        CSimpleStringWide   cswLaunchApplicationsValue = csrEventKey.Query(STI_LAUNCH_APPPLICATIONS_VALUE, 
                                                                           STI_LAUNCH_WILDCARD);
        //
        //  Check whether the value is a wildcard or not.  If it is, we need to process all globally
        //  registered STI Apps.
        //  If it isn't, only add the ones that are specified in the value (it is a 
        //  comma separated list of Handler names).
        //
        if (cswLaunchApplicationsValue.CompareNoCase(STI_LAUNCH_WILDCARD) == 0)
        {
            CSimpleReg          csrRegisteredAppsKey(HKEY_LOCAL_MACHINE, STI_GLOBAL_EVENT_HANDLER_PATH, false, KEY_READ);

            //
            //  Enumerate through all the handler values in the globally registered  and add them to the list
            //
            bool bReturnIgnored = csrRegisteredAppsKey.EnumValues(StiEventHandlerLookup::ProcessHandlers,
                                                                  (LPARAM)this);
        }
        else
        {
            StiEventHandlerInfo *pStiEventHandlerInfo = NULL;
            //
            //  Walk through each element of the comma separated list and add it as a new handler
            //
            StiEventHandlerLookup::SimpleStringTokenizer simpleStringTokenizer(cswLaunchApplicationsValue,
                                                                               STI_LAUNCH_SEPARATOR);
            for (CSimpleStringWide cswAppName = simpleStringTokenizer.getNextToken(); 
                 cswAppName.Length() > 0; 
                 cswAppName = simpleStringTokenizer.getNextToken())
            {
                pStiEventHandlerInfo = getHandlerFromName(cswAppName);
                if (pStiEventHandlerInfo)
                {
                    //
                    //  Handler was found, so add it to the list
                    //  
                    m_ListOfHandlers.Append(pStiEventHandlerInfo);
                    pStiEventHandlerInfo = NULL;
                }
                else
                {
                    //
                    //  Handler not found, so don't add it to the list.  This could happen
                    //  if user chose to list a specific set of apps to choose from, but one
                    //  of the apps in the list has subsequently been unregistered.
                    //
                }
            }
        }
    }
 
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  bool | StiEventHandlerLookup | ProcessHandlers |
 *
 *  This method is called on each value of the registered handlers key.
 *  Our current behavior is to create a new <c StiEventHandlerInfo> describing
 *  the registered handler, and add it to <md StiEventHandlerLookup::m_ListOfHandlers>.
 *
 *  @parm   CValueEnumInfo& | enumInfo | 
 *          Indicates the current value we're on.
 *
 *  @rvalue true     | 
 *              This method always returns true. (Returning false would cause a
 *              enumeration to stop, but we want to enumerate all values)
 *****************************************************************************/
bool StiEventHandlerLookup::ProcessHandlers(
    CSimpleReg::CValueEnumInfo &enumInfo)
{
    //
    //  Check that we have a This pointer
    //
    StiEventHandlerLookup *This = (StiEventHandlerLookup*)enumInfo.lParam;
    if (This)
    {
        //
        //  Create a new StiEventHandlerInfo describing this handler
        //
        StiEventHandlerInfo *pStiEventHandlerInfo = NULL;

        pStiEventHandlerInfo = This->getHandlerFromName(enumInfo.strName);
        if (pStiEventHandlerInfo)
        {
            //
            //  Handler was found, so add it to the list
            //  
            This->m_ListOfHandlers.Append(pStiEventHandlerInfo);
            pStiEventHandlerInfo = NULL;
        }
    }
    return true;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  BSTR | StiEventHandlerLookup | getStiAppListForDeviceEvent |
 *
 *  This method returns a double NULL-terminated BSTR containing multiple 
 *  strings.  The format of the string is:
 *  <nl>App1Name[NULL]
 *  <nl>App1CommandLine[NULL]
 *  <nl>App2Name[NULL]
 *  <nl>App2CommandLine[NULL]
 *  <nl>......
 *  <nl>[NULL]
 *
 *  Caller must free.
 *
 *  @parm   const CSimpleStringWide & | cswDeviceID | 
 *          The STI device ID indicating which device generated the event
 *  @parm   const GUID & | guidEvent | 
 *          The event guid indicating the device event
 *
 *  @rvalue NULL    | 
 *          We could not create a list of registered STI handlers.  This is normal
 *          if there are no applications registered for StillImage events.
 *  @rvalue non-NULL    | 
 *          This contains a double NULL terminated string list.  Caller must free.
 *          
 *****************************************************************************/
BSTR StiEventHandlerLookup::getStiAppListForDeviceEvent(
    const CSimpleStringWide &cswDeviceID,
    const GUID &guidEvent)
{
    BSTR bstrAppList = NULL;

    //
    //  First, fill the list of event handlers.
    //
    FillListOfHandlers(cswDeviceID, guidEvent);

    //
    //  m_ListOfHandlers now contains the handlers we need to put into a double NULL terminated list.
    //  First, we need to calculate the number of bytes needed to store the app list.
    //  For every StiEventHandlerInfo in the ListOfHandlers, add space for:
    //  <nl> App name plus terminating NULL.
    //  <nl> Prepared commandline plus terminating NULL.
    //  <nl>Lastly, add space for terminating NULL (ensuring that the list is double NULL terminated)
    //  Lastly, add space for terminating NULL (ensuring that the list is double NULL terminated)
    //
    int iNumHandlers = m_ListOfHandlers.Count();
    int iSizeInBytes = 0;
    CSimpleLinkedList<StiEventHandlerInfo*>::Iterator iter;
    for (iter = m_ListOfHandlers.Begin(); iter != m_ListOfHandlers.End(); ++iter)
    {
        StiEventHandlerInfo *pStiEventHandlerInfo = *iter;

        if (pStiEventHandlerInfo)
        {
            iSizeInBytes += (pStiEventHandlerInfo->getAppName().Length() * sizeof(WCHAR)) + sizeof(L'\0');
            iSizeInBytes += (pStiEventHandlerInfo->getPreparedCommandline(cswDeviceID, guidEvent).Length() * sizeof(WCHAR)) + sizeof(L'\0');
        }
    }

    //
    //  We now have the size, so allocate the space needed
    //  
    bstrAppList = SysAllocStringByteLen(NULL, iSizeInBytes);
    if (bstrAppList) 
    {
        //
        //  Copy each null terminated string into the BSTR (including the terminating null),
        //  and make sure the end is double terminated.
        //
        WCHAR *wszDest = bstrAppList;
        for (iter = m_ListOfHandlers.Begin(); iter != m_ListOfHandlers.End(); ++iter)
        {
            StiEventHandlerInfo *pStiEventHandlerInfo = *iter;

            if (pStiEventHandlerInfo)
            {
                int iLengthAppName      = pStiEventHandlerInfo->getAppName().Length() + 1; 
                int iLengthCommandline  = pStiEventHandlerInfo->getPreparedCommandline(cswDeviceID, guidEvent).Length() + 1; 

                CSimpleString::GenericCopyLength(wszDest, pStiEventHandlerInfo->getAppName(), iLengthAppName); 
                wszDest += iLengthAppName;
                CSimpleString::GenericCopyLength(wszDest, pStiEventHandlerInfo->getPreparedCommandline(cswDeviceID, guidEvent), iLengthCommandline);
                wszDest += iLengthCommandline;
            }
        }
        wszDest[0] = L'\0';
    }
    return bstrAppList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\stieventhandlerinfo.cpp ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/13/2002
 *
 *  @doc    INTERNAL
 *
 *  @module StiEventHandlerInfo.cpp - Implementation  for <c StiEventHandlerInfo> |
 *
 *  This file contains the implementations for the <c StiEventHandlerInfo> class.
 *
 *****************************************************************************/
#include "precomp.h"

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | StiEventHandlerInfo | StiEventHandlerInfo |
 *
 *  We initialize all member variables.  In general, this sets the values to 0,
 *  except:
 *  <nl><md StiEventHandlerInfo::m_ulSig> is set to be StiEventHandlerInfo_INIT_SIG.
 *  <nl><md StiEventHandlerInfo::m_cRef> is set to be 1.
 *
 *****************************************************************************/
StiEventHandlerInfo::StiEventHandlerInfo(
    const CSimpleStringWide &cswAppName, 
    const CSimpleStringWide &cswCommandline) :
     m_ulSig(StiEventHandlerInfo_INIT_SIG),
     m_cRef(1),
     m_cswAppName(cswAppName),
     m_cswCommandline(cswCommandline)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | StiEventHandlerInfo | ~StiEventHandlerInfo |
 *
 *  Do any cleanup that is not already done.
 *
 *  Also:
 *  <nl><md StiEventHandlerInfo::m_ulSig> is set to be StiEventHandlerInfo_DEL_SIG.
 *
 *****************************************************************************/
StiEventHandlerInfo::~StiEventHandlerInfo()
{
    m_ulSig = StiEventHandlerInfo_DEL_SIG;
    m_cRef = 0;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | StiEventHandlerInfo | AddRef |
 *
 *  Increments this object's ref count.  We should always AddRef when handing
 *  out a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been incremented.
 *****************************************************************************/
ULONG __stdcall StiEventHandlerInfo::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | StiEventHandlerInfo | Release |
 *
 *  Decrement this object's ref count.  We should always Release when finished
 *  with a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been decremented.
 *****************************************************************************/
ULONG __stdcall StiEventHandlerInfo::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) 
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | StiEventHandlerInfo | getAppName |
 *
 *  Accessor method for the application name.  The return is done as a copy by value.
 *
 *  @rvalue CSimpleStringWide    | 
 *              The name of the registered STI handler.
 *****************************************************************************/
CSimpleStringWide StiEventHandlerInfo::getAppName()
{
    return m_cswAppName;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | StiEventHandlerInfo | getCommandline |
 *
 *  Accessor method for the commandline the application registered.  
 *  The return is done as a copy by value.
 *
 *  @rvalue CSimpleStringWide    | 
 *              The commandline for the registered STI handler.
 *****************************************************************************/
CSimpleStringWide StiEventHandlerInfo::getCommandline()
{
    return m_cswCommandline;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | StiEventHandlerInfo | getPreparedCommandline |
 *
 *  The commandline used to start the application, after substituting 
 *  DeviceID and event parameters e.g.
 *  <nl>  The registered commandline may look like: "MyApp.exe /StiDevice:%1 /StiEvent:%2"
 *  <nl>  The prepared commandline returned from this would like something like: 
 *  <nl>  "MyApp.exe /StiDevice:{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}\0001 /StiEvent:{61127f40-e1a5-11d0-b454-00a02438ad48}"
 *
 *  The return is done as a copy by value.
 *
 *  @parm   const CSimpleStringWide & | cswDeviceID | 
 *          The device id to put into the commandline.
 *  @parm   const CSimpleStringWide & | cswEventGuid | 
 *          The event guid string to put into the commandline.
 *
 *  @rvalue CSimpleStringWide    | 
 *              The commandline for the registered STI handler.
 *****************************************************************************/
CSimpleStringWide StiEventHandlerInfo::getPreparedCommandline(
    const CSimpleStringWide &cswDeviceID, 
    const CSimpleStringWide &cswEventGuid)
{
    CSimpleStringWide cswCommandline;

    //
    //  Substitute the DeviceID for the sti device token (/StiDevice:%1)
    //
    cswCommandline = ExpandTokenIntoString(m_cswCommandline,
                                           STI_DEVICE_TOKEN,
                                           cswDeviceID);

    //
    //  Substitute the Event for the sti event token (/StiEvent:%2).
    //  Note we use cswCommandline as the source because it already
    //  has the device ID expanded into it.
    //
    cswCommandline = ExpandTokenIntoString(cswCommandline,
                                           STI_EVENT_TOKEN,
                                           cswEventGuid);
    return cswCommandline;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | StiEventHandlerInfo | ExpandTokenIntoString |
 *
 *  This method inserts a value string in place of a token, similar to how
 *  printf expands:
 *  <nl>CHAR *szMyString = "TokenValue";
 *  <nl>printf("left %s right", szMyString);
 *  <nl>into the string "left TokenValue right".
 *
 *  This method will only substitute the first matching token.
 *
 *  @parm   const CSimpleStringWide & | cswInput | 
 *          The input string containing the tokens to substitute
 *  @parm   const CSimpleStringWide & | cswToken | 
 *          The token we're looking for
 *  @parm   const CSimpleStringWide & | cswTokenValue | 
 *          The value we want to substitute for the token.  It does not have to
 *          be the same size as the token.
 *
 *  @rvalue CSimpleStringWide    | 
 *              The resulting string after the substitution.
 *****************************************************************************/
CSimpleStringWide StiEventHandlerInfo::ExpandTokenIntoString(
    const CSimpleStringWide &cswInput,
    const CSimpleStringWide &cswToken,
    const CSimpleStringWide &cswTokenValue
    )
{
    CSimpleString cswExpandedString;
    //
    //  Look for the token start
    //
    int iTokenStart = cswInput.Find(cswToken, 0); 

    if (iTokenStart != -1)
    {
        //
        //  We found the token, so let's make the substitution.
        //  The original string looks like this:
        //  lllllllTokenrrrrrrr
        //         |
        //         |
        //         iTokenStart
        //  We want the string to look like this:
        //  lllllllTokenValuerrrrrrr
        //  Therefore, take everything before the Token, add the token value, then
        //  everything following the token i.e.
        //  lllllll + TokenValue + rrrrrrr
        //        |                |
        //        iTokenStart -1   |
        //                         iTokenStart + Token.length()
        //
        cswExpandedString =     cswInput.SubStr(0, iTokenStart);
        cswExpandedString +=    cswTokenValue;
        cswExpandedString +=    cswInput.SubStr(iTokenStart + cswToken.Length(), -1);
    }
    else
    {
        cswExpandedString = cswInput;
    }
    return cswExpandedString;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | StiEventHandlerInfo | getPreparedCommandline |
 *
 *  This method is a thin wrapper for the other <mf StiEventHandlerInfo::getPreparedCommandline>.
 *
 *  The commandline used to start the application, after substituting 
 *  DeviceID and event parameters e.g.
 *  <nl>  The registered commandline may look like: "MyApp.exe /StiDevice:%1 /StiEvent:%2"
 *  <nl>  The prepared commandline returned from this would like something like: 
 *  <nl>  "MyApp.exe /StiDevice:{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}\0001 /StiEvent:{61127f40-e1a5-11d0-b454-00a02438ad48}"
 *
 *  The return is done as a copy by value.
 *
 *  @parm   const CSimpleStringWide & | cswDeviceID | 
 *          The device id to put into the commandline.
 *  @parm   const CSimpleStringWide & | cswEventGuid | 
 *          The event guid string to put into the commandline.
 *
 *  @rvalue CSimpleStringWide    | 
 *              The commandline for the registered STI handler.
 *****************************************************************************/
CSimpleStringWide StiEventHandlerInfo::getPreparedCommandline(
    const CSimpleStringWide &cswDeviceID, 
    const GUID &guidEvent)
{
    CSimpleStringWide   cswEventGuidString;
    WCHAR               wszGuid[40];
    if (StringFromGUID2(guidEvent, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0])))
    {
        wszGuid[(sizeof(wszGuid)/sizeof(wszGuid[0])) - 1] = L'\0';
        cswEventGuidString = wszGuid;
    }
    return getPreparedCommandline(cswDeviceID, cswEventGuidString);
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  VOID | StiEventHandlerInfo | Dump |
 *
 *  Description goes here
 *
 *  @parm   LONG | lFlags | 
 *          Operational flags
 *          @flag 0 | No switches
 *
 *  @rvalue S_OK    | 
 *              The method succeeded.
 *****************************************************************************/
VOID StiEventHandlerInfo::Dump(
    )
{
    DBG_TRC(("Sti registration for"));
    DBG_TRC(("    Name:        %ws", getAppName().String()));
    DBG_TRC(("    Commandline: %ws\n", getCommandline().String()));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\wiadevicekey.cpp ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/14/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaDeviceKey.cpp - Implmenentation for <c WiaDeviceKey> |
 *
 *  This file contains the implementation for the <c WiaDeviceKey> class.
 *
 *****************************************************************************/
#include "precomp.h"

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | WiaDeviceKey | WiaDeviceKey |
 *
 *  We initialize all member variables.  In general, this sets the values to 0,
 *  except:
 *  <nl><md WiaDeviceKey::m_ulSig> is set to be WiaDeviceKey_INIT_SIG.
 *  <nl><md WiaDeviceKey::m_cRef> is set to be 1.
 *
 *****************************************************************************/
WiaDeviceKey::WiaDeviceKey(const CSimpleStringWide &cswDeviceID) :
     m_ulSig(WiaDeviceKey_INIT_SIG),
     m_cRef(1),
     m_cswDeviceID(cswDeviceID)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | WiaDeviceKey | ~WiaDeviceKey |
 *
 *  Do any cleanup that is not already done.
 *
 *  Also:
 *  <nl><md WiaDeviceKey::m_ulSig> is set to be WiaDeviceKey_DEL_SIG.
 *
 *****************************************************************************/
WiaDeviceKey::~WiaDeviceKey()
{
    m_ulSig = WiaDeviceKey_DEL_SIG;
    m_cRef = 0;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | WiaDeviceKey | AddRef |
 *
 *  Increments this object's ref count.  We should always AddRef when handing
 *  out a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been incremented.
 *****************************************************************************/
ULONG __stdcall WiaDeviceKey::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | WiaDeviceKey | Release |
 *
 *  Decrement this object's ref count.  We should always Release when finished
 *  with a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been decremented.
 *****************************************************************************/
ULONG __stdcall WiaDeviceKey::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) 
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWIde | WiaDeviceKey | getDeviceKeyPath |
 *
 *  This method retuns the device key path relative to HKLM.
 *
 *  @rvalue CSimpleStringWIde    | 
 *              A string representing the registry path to the device key
 *              relative to HKLM.
 *****************************************************************************/
CSimpleStringWide WiaDeviceKey::getDeviceKeyPath()
{
    //
    //  Start looking uner our devnode device keys
    //
    m_cswRootPath       = IMG_DEVNODE_CLASS_REGPATH;

    CSimpleReg  csrDevNodeDeviceRoot(HKEY_LOCAL_MACHINE, m_cswRootPath, false, KEY_READ);
    bool bDeviceNotFound = csrDevNodeDeviceRoot.EnumKeys(WiaDeviceKey::ProcessDeviceKeys, (LPARAM)this);
    if (bDeviceNotFound)
    {
        m_cswDeviceKeyPath  = L"";
    }
    else
    {
        //
        //  m_cswDeviceKeyPath now contains the path to the Device key
        //
    }
    return m_cswDeviceKeyPath;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  bool | WiaDeviceKey | ProcessDeviceKeys |
 *
 *  This method is called on each sub-key under the class key as part of an 
 *  enumeration to find the key corresponding to a specific deviceID (since
 *  they're not necessarily the same).
 *
 *  On return, we set the <md WiaDeviceKey::m_cswDeviceKeyPath>
 *  member.
 *
 *  @parm   CKeyEnumInfo& | enumInfo | 
 *          Indicates the current sub-key we're on.
 *
 *  @rvalue false    | 
 *              Indicates we can stop with the enumeration.  We found the correct
 *              device.
 *  @rvalue true     | 
 *              Indicates we should continue with the enumeration.
 *****************************************************************************/
bool WiaDeviceKey::ProcessDeviceKeys(
    CSimpleReg::CKeyEnumInfo &enumInfo)
{
    bool bContinueEnumeration = TRUE;

    //
    //  Check that we have a This pointer
    //
    WiaDeviceKey *This = (WiaDeviceKey*)enumInfo.lParam;
    if (This)
    {
        //
        //  Open this sub-key.
        //
        CSimpleReg csrDeviceSubKey(enumInfo.hkRoot, enumInfo.strName);
        if (csrDeviceSubKey.OK())
        {
            //
            //  Check whether this is the one we want.
            //
            CSimpleStringWide cswDeviceID = csrDeviceSubKey.Query(DEVICE_ID_VALUE_NAME, L"");

            if (cswDeviceID.CompareNoCase(This->m_cswDeviceID) == 0)
            {
                CSimpleString cswSlash      = L"\\";
                This->m_cswDeviceKeyPath    =  This->m_cswRootPath + cswSlash + enumInfo.strName;

                bContinueEnumeration    = FALSE;
            }
        }
    }
    return bContinueEnumeration;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  CSimpleStringWide | WiaDeviecKey | getDeviceEventKeyPath |
 *
 *  Returns the path to the device event registry key relative to HKLM
 *
 *  @parm   const GUID& | guidEvent | 
 *          Specifies the event to look up.
 *
 *  @rvalue S_OK    | 
 *              The method succeeded.
 *****************************************************************************/
CSimpleStringWide WiaDeviceKey::getDeviceEventKeyPath(
    const GUID &guidEvent)
{
    CSimpleStringWide cswEventPath;
    CSimpleStringWide cswDeviceKey = getDeviceKeyPath();
    if (cswDeviceKey.Length() > 0)
    {
        //
        //  Save the parameters in member fields so we can search on them during
        //  reg key enumeration.  Enumeration is done via procedure callbacks,
        //  in which we pass (this) as a parameter.
        //
        WCHAR   wszGuid[40];
        if (StringFromGUID2(guidEvent, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0])))
        {
            wszGuid[(sizeof(wszGuid)/sizeof(wszGuid[0])) - 1] = L'\0';
            m_cswEventGuidString = wszGuid;
        }

        m_cswRootPath = cswDeviceKey + EVENT_STR;
        CSimpleReg csrDeviceEventKey(HKEY_LOCAL_MACHINE, m_cswRootPath, false, KEY_READ);
        bool bEventNotFound = csrDeviceEventKey.EnumKeys(WiaDeviceKey::ProcessEventSubKey,
                                                         (LPARAM) this);
        if (bEventNotFound)
        {
            cswEventPath = L"";
        }
        else
        {
            cswEventPath = m_cswRootPath;
        }
    }
    return cswEventPath;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  bool | WiaDeviceKey | ProcessEventSubKey |
 *
 *  This method is called on each sub-key as part of an enumeration of all 
 *  the event sub-keys.  The enumeration will stop if we return false from
 *  this method.
 *
 *  If successful, the <md WiaDeviceKey::m_cswRootPath> will contain the
 *  path to this event key.
 *
 *  @parm   CKeyEnumInfo& | enumInfo | 
 *          Indicates the current sub-key we're on.
 *
 *  @rvalue false    | 
 *              Indicates we can stop with the enumeration.  We found the correct
 *              event key.
 *  @rvalue true     | 
 *              Indicates we should continue with the enumeration.
 *****************************************************************************/
bool WiaDeviceKey::ProcessEventSubKey(
    CSimpleReg::CKeyEnumInfo &enumInfo)
{
    bool bContinueEnumeration = true;

    //
    //  Check that we have a This pointer
    //
    WiaDeviceKey *This = (WiaDeviceKey*)enumInfo.lParam;
    if (This)
    {
        //
        //  Open this sub-key.  We're looking for a sub-key which contains a GUID entry
        //  matching m_cswEventGuidString.
        //
        CSimpleReg csrEventSubKey(enumInfo.hkRoot, enumInfo.strName);
        
        CSimpleStringWide cswGuidValue = csrEventSubKey.Query(GUID_VALUE_NAME, L"{00000000-0000-0000-0000-000000000000}");
        if (cswGuidValue.CompareNoCase(This->m_cswEventGuidString) == 0)
        {
            //
            //  We found the key we're looking for.  Construct the path to this key.  
            //
            This->m_cswRootPath += L"\\";
            This->m_cswRootPath +=  enumInfo.strName;
            bContinueEnumeration = false;
        }
    }
    return bContinueEnumeration;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\stieventhandlerlookup.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/14/2002
 *
 *  @doc    INTERNAL
 *
 *  @module StiEventHandlerLookup.h - Definitions for <c StiEventHandlerLookup> |
 *
 *  This file contains the class definition for <c StiEventHandlerLookup>.
 *
 *****************************************************************************/

//
//  Defines
//
#define StiEventHandlerLookup_UNINIT_SIG   0x55756C45
#define StiEventHandlerLookup_INIT_SIG     0x49756C45
#define StiEventHandlerLookup_TERM_SIG     0x54756C45
#define StiEventHandlerLookup_DEL_SIG      0x44756C45

#define STI_GLOBAL_EVENT_HANDLER_PATH   L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage\\Registered Applications"
#define STI_LAUNCH_APPPLICATIONS_VALUE  L"LaunchApplications"
#define STI_LAUNCH_WILDCARD             L"*"
#define STI_LAUNCH_SEPARATOR            L","
/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class StiEventHandlerLookup | Used to find STI event handlers
 *  
 *  @comm
 *  This class is used to lookup the relevant STI event handler(s) for a given
 *  device event.  This list of handlers is returned as a double NULL terminated
 *  list of strings.  This is encoded into a BSTR for use by the STI event handler prompt.
 *
 *  This class is not thread safe.  Caller should use separate objects or
 *  synchronize access to the single object.
 *
 *****************************************************************************/
class StiEventHandlerLookup 
{
//@access Public members
public:

    // @cmember Constructor
    StiEventHandlerLookup();
    // @cmember Destructor
    virtual ~StiEventHandlerLookup();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    //@cmember Returns a double NULL terminated string list
    BSTR getStiAppListForDeviceEvent(const CSimpleStringWide &cswDeviceID, const GUID &guidEvent);

    // @cmember Returns a <c StiEventHandlerInfo> object describing the specified handler
    StiEventHandlerInfo* getHandlerFromName(const CSimpleStringWide &cswHandlerName);

    //
    //  Innder class used to tokenize the device event handler strings
    //
    class SimpleStringTokenizer
    {
    public:
        //
        //  Constructor which initializes the member fields.  This object is intended to be used
        //  for one pass through a string to grab the tokens.  After that, it is designed to
        //  return Empty tokens.  Therefore, therefore one-time initialization of the start 
        //  position is done here.
        //
        SimpleStringTokenizer(const CSimpleString &csInput, const CSimpleString &csSeparator) :
            m_iStart(0),
            m_csSeparator(csSeparator),
            m_csInput(csInput)
        {
        }
    
        virtual ~SimpleStringTokenizer()
        {
        }
    
        //
        //  Returns the next token.  The last token will be empty.  This indicates the end of
        //  the input string has been reached and there are no more tokens.
        //
        CSimpleString getNextToken()
        {
            CSimpleString csToken;
    
            int iNextSeparator = 0; 
            int iTokenLength   = 0;
            int iTokenStart    = m_iStart;
    
            //
            //  Search for the next token.  We keep searching until we hit a token of
            //  non-zero length i.e. if the separator was ',' we would correctly
            //  ignore the commas in the following string: ",,,,NextString,,"
            //  We do this is by looking for the position
            //  of the next seperator.  If the token length from m_iStart to the
            //  next separator is 0, we need to keep searching (keeping in mind
            //  the end of input case, which is indicated when iNextSeparator == -1)
            //
            while ((iTokenLength == 0) && (iNextSeparator != -1))
            {
                m_iStart = iTokenStart;
                iNextSeparator = m_csInput.Find(m_csSeparator, m_iStart);
                iTokenLength   = iNextSeparator - m_iStart;
                iTokenStart    = iNextSeparator + 1;
            }
    
            //
            //  Return the token.  If we have reached the end, it will
            //  simply be empty.
            //
            csToken = m_csInput.SubStr(m_iStart, iTokenLength);
            if (iNextSeparator == -1)
            {
                m_iStart = -1;
            }
            else
            {
                m_iStart = iTokenStart;
            }
            return csToken;
        }
    
    private:
        int             m_iStart;       // The start position of the next search for a separator.
        CSimpleString   m_csSeparator; // Describes the separator string we use to split tokens from the input.
        CSimpleString   m_csInput;     // The input string to be tokenized
    };

    //  TBD: move to private
    // @cmember Fills in the list of handlers
    VOID FillListOfHandlers(const CSimpleStringWide &cswDeviceID,
                            const GUID              &cswEventGuidString);


//@access Private members
private:

    // @cmember Frees resources associated with our list of handlers
    VOID ClearListOfHandlers();
    // @cmember Callback for each value in the registered handlers key
    static bool ProcessHandlers(CSimpleReg::CValueEnumInfo &enumInfo);

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember Ref count
    CSimpleLinkedList<StiEventHandlerInfo*> m_ListOfHandlers;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | StiEventHandlerLookup | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag StiEventHandlerLookup_UNINIT_SIG | 'EluU' - Object has not been successfully
    //       initialized
    //   @flag StiEventHandlerLookup_INIT_SIG | 'EluI' - Object has been successfully
    //       initialized
    //   @flag StiEventHandlerLookup_TERM_SIG | 'EluT' - Object is in the process of
    //       terminating.
    //    @flag StiEventHandlerLookup_INIT_SIG | 'EluD' - Object has been deleted 
    //       (destructor was called)
    //
    // @mdata ULONG | StiEventHandlerLookup | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata CSimpleLinkeList<lt>StiEventHandlerInfo*<gt> | StiEventHandlerLookup | m_ListOfGlobalHandlers | 
    //   List of global STI handlers registered for StillImage events.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\wiadevicekey.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/14/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaDeviceKey.h - Definitions for <c WiaDeviceKey> |
 *
 *  This file contains the class definitions for <c WiaDeviceKey>.
 *
 *****************************************************************************/

//
//  Defines
//
#define WiaDeviceKey_UNINIT_SIG   0x556B7644
#define WiaDeviceKey_INIT_SIG     0x496B7644
#define WiaDeviceKey_TERM_SIG     0x546B7644
#define WiaDeviceKey_DEL_SIG      0x446B7644

#define IMG_DEVNODE_CLASS_REGPATH   L"SYSTEM\\CurrentControlSet\\Control\\Class\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}"
#define IMG_DEVINTERFACE_REGPATH    L"SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}"

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class WiaDeviceKey | Finds the appropriate WIA Device registry key
 *  
 *  @comm
 *  This class is used to return the device registry key from the DeviceID.
 *
 *****************************************************************************/
class WiaDeviceKey 
{
//@access Public members
public:

    // @cmember Constructor
    WiaDeviceKey(const CSimpleStringWide &cswDeviceID);
    // @cmember Destructor
    virtual ~WiaDeviceKey();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Returns the path to the device registry key relative to HKLM
    CSimpleStringWide   getDeviceKeyPath();
    // @cmember Returns the path to the device event registry key relative to HKLM
    CSimpleStringWide   getDeviceEventKeyPath(const GUID &guidEvent);

//@access Private members
private:

    // @cmember Procedure used in registry key enumeration searching for devices.
    static bool ProcessDeviceKeys(CSimpleReg::CKeyEnumInfo &enumInfo );
    // @cmember Procedure used in registry key enumeration searching for an event.
    static bool ProcessEventSubKey(CSimpleReg::CKeyEnumInfo &enumInfo);
    // @cmember Procedure used in registry key enumeration.
    //static bool ProcessDeviceClassKeys(CKeyEnumInfo &enumInfo );

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember The DeviceID whose key we are searching for
    CSimpleStringWide m_cswDeviceID;
    // @cmember The string path relative to HKLM where we start our search
    CSimpleStringWide m_cswRootPath;
    // @cmember The device key string path relative to HKLM
    CSimpleStringWide m_cswDeviceKeyPath;
    // @cmember String stored for use when searching for a specific event sub-key
    CSimpleStringWide   m_cswEventGuidString;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | WiaDeviceKey | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag WiaDeviceKey_UNINIT_SIG | 'DvkU' - Object has not been successfully
    //       initialized
    //   @flag WiaDeviceKey_INIT_SIG | 'DvkI' - Object has been successfully
    //       initialized
    //   @flag WiaDeviceKey_TERM_SIG | 'DvkT' - Object is in the process of
    //       terminating.
    //    @flag WiaDeviceKey_INIT_SIG | 'DvkD' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @mdata ULONG | WiaDeviceKey | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata CSimpleStringWide | WiaDeviceKey | m_cswDeviceID | 
    //   The DeviceID whose key we are searching for.
    //
    // @mdata CSimpleStringWide | WiaDeviceKey | m_cswRootPath | 
    //  The string path relative to HKLM where we start our search.  Typically,
    //  this is either ...\Control\Class\DEV_CLASS_IMAGE or ...\Control\DeviceClasses\DEV_CLASS_IMAGE\PnPID
    //
    // @mdata CSimpleStringWide | WiaDeviceKey | m_cswDeviceKeyPath | 
    //   The device key string path relative to HKLM
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\wiaeventhandlerlookup.cpp ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/10/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaEventHandlerLookup.cpp - Implementation for <c WiaEventHandlerLookup> |
 *
 *  This file contains the implementation for the <c WiaEventHandlerLookup> class.
 *
 *****************************************************************************/
#include "precomp.h"

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | WiaEventHandlerLookup | WiaEventHandlerLookup |
 *
 *  We initialize all member variables.  In general, this sets the values to 0,
 *  except:
 *  <nl><md WiaEventHandlerLookup::m_ulSig> is set to be WiaEventHandlerLookup_INIT_SIG.
 *  <nl><md WiaEventHandlerLookup::m_cRef> is set to be 1.
 *
 *****************************************************************************/
WiaEventHandlerLookup::WiaEventHandlerLookup(
    const CSimpleStringWide   &cswEventKeyRoot) :
     m_ulSig(WiaEventHandlerLookup_INIT_SIG),
     m_cRef(1),
     m_cswEventKeyRoot(cswEventKeyRoot),
     m_pEventHandlerInfo(NULL)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | WiaEventHandlerLookup | WiaEventHandlerLookup |
 *
 *  We initialize all member variables.  In general, this sets the values to 0,
 *  except:
 *  <nl><md WiaEventHandlerLookup::m_ulSig> is set to be WiaEventHandlerLookup_INIT_SIG.
 *  <nl><md WiaEventHandlerLookup::m_cRef> is set to be 1.
 *
 *****************************************************************************/
WiaEventHandlerLookup::WiaEventHandlerLookup() :
     m_ulSig(WiaEventHandlerLookup_INIT_SIG),
     m_cRef(1),
     m_pEventHandlerInfo(NULL)
{
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc   | WiaEventHandlerLookup | ~WiaEventHandlerLookup |
 *
 *  Do any cleanup that is not already done.
 *
 *  Also:
 *  <nl><md WiaEventHandlerLookup::m_ulSig> is set to be WiaEventHandlerLookup_DEL_SIG.
 *
 *****************************************************************************/
WiaEventHandlerLookup::~WiaEventHandlerLookup()
{
    m_ulSig = WiaEventHandlerLookup_DEL_SIG;
    m_cRef = 0;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | WiaEventHandlerLookup | AddRef |
 *
 *  Increments this object's ref count.  We should always AddRef when handing
 *  out a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been incremented.
 *****************************************************************************/
ULONG __stdcall WiaEventHandlerLookup::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  ULONG | WiaEventHandlerLookup | Release |
 *
 *  Decrement this object's ref count.  We should always Release when finished
 *  with a pointer to this object.
 *
 *  @rvalue Count    | 
 *              The reference count after the count has been decremented.
 *****************************************************************************/
ULONG __stdcall WiaEventHandlerLookup::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) 
    {
        delete this;
        return 0;
    }
    if (m_pEventHandlerInfo)
    {
        m_pEventHandlerInfo->Release();
        m_pEventHandlerInfo = NULL;
    }
    return ulRefCount;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  EventHandlerInfo* | WiaEventHandlerLookup | getPersistentHandlerForDeviceEvent |
 *
 *  This static method is used to find the WIA persistent event handler
 *  registered for a particular device event.
 *
 *  The heuristics used is as follows:
 * 
 *  <nl> 1. First, let's look for the prompt registered for this event.
 *  <nl> 2. If one doesn't exist, try and grab the prompt for the STI_PROXY_EVENT.
 *  <nl> 3. If we cannot find it, grab the first event handler for this event we can find.
 *  <nl> 4. If that doesn't exist, just find the first handler for the STI_PROXY_EVENT.
 *  <nl> 5. If none was found, we have no handlers for this event.
 *
 *  Note:  This method clears <md WiaEventHandlerLookup::m_cswEventKeyRoot>
 *
 *  @parm   CSimpleString& | cswDeviceID | 
 *          The WIA DeviceID on which this event occured
 *  @parm   GUID& | guidEvent | 
 *          The WIA event guid indicating which event occured
 *
 *  @rvalue NULL    | 
 *              There is no handler registered which can accept this device event.
 *  @rvalue non-NULL    | 
 *              A pointer to a <c WiaHandlerInfo> describing  the registered
 *              handler.  Caller must Release.
 *****************************************************************************/
EventHandlerInfo* WiaEventHandlerLookup::getPersistentHandlerForDeviceEvent(
    const CSimpleStringWide &cswDeviceID,
    const GUID              &guidEvent)
{
    EventHandlerInfo *pEventHandlerInfo = NULL;

    m_cswEventKeyRoot = L"";
    //
    //  Get the device key for this device id.  We can then do a lookup on the device's event
    //  subkey to look for a default handler.
    //  We will skip this lookup if we cannot find the Device key path
    //
    WiaDeviceKey    wiaDeviceKey(cswDeviceID);
    if (wiaDeviceKey.getDeviceKeyPath().Length() > 0)
    {
        CSimpleString   cswDeviceEventKey = wiaDeviceKey.getDeviceKeyPath() + EVENT_STR;
        setEventKeyRoot(cswDeviceEventKey);
        pEventHandlerInfo = getHandlerRegisteredForEvent(guidEvent);
    }

    //
    //  If we haven't found it yet, let's check for global handlers
    //
    if (!pEventHandlerInfo)
    {
        //
        //  1. First, let's look for the prompt registered for this event.
        //  2. If one doesn't exist, try and grab the prompt for the STI_PROXY_EVENT.
        //  3. If we cannot find it, grab the first event handler for this event we can find.
        //  4. If that doesn't exist, just find the first handler for the STI_PROXY_EVENT.
        //  5. If none was found, we have no handlers for this event.
        //
        setEventKeyRoot(GLOBAL_HANDLER_REGPATH);
        pEventHandlerInfo = getHandlerFromCLSID(guidEvent, WIA_EVENT_HANDLER_PROMPT);
        if (!pEventHandlerInfo)
        {
            //
            //  2.  Try and grab the prompt for the STI_PROXY_EVENT.
            //
            pEventHandlerInfo = getHandlerFromCLSID(WIA_EVENT_STI_PROXY, WIA_EVENT_HANDLER_PROMPT);
        }
        if (!pEventHandlerInfo)
        {
            //
            //  3.  Grab the first event handler for this event we can find.
            //
            pEventHandlerInfo = getHandlerRegisteredForEvent(guidEvent);
        }
        if (!pEventHandlerInfo)
        {
            //
            //  4.  Just find the first handler for the STI_PROXY_EVENT..
            //
            pEventHandlerInfo = getHandlerRegisteredForEvent(WIA_EVENT_STI_PROXY);
        }
    }
    return pEventHandlerInfo;
}


/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  VOID | WiaEventHandlerLookup | setEventKeyRoot |
 *
 *  Description goes here
 *
 *  @parm   CSimpleString& | cswNewEventKeyPath | 
 *          The new event key path to use as root for our lookups.
 *
 *****************************************************************************/
VOID WiaEventHandlerLookup::setEventKeyRoot(
    const CSimpleString& cswNewEventKeyPath)
{
    m_cswEventKeyRoot = cswNewEventKeyPath;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  EventHandlerInfo* | WiaEventHandlerLookup | getHandlerRegisteredForDeviceEvent |
 *
 *  In WIA, a handler registers for Device/Event pairs.  When an event occurs,
 *  a handler registered for that event needs to be found.
 *  Note that by the time we use this class to look for an event handler, we already
 *  know that we have a match on Device ID (WIA events are always matched by
 *  Event and Device pairs).  This is quitre easily explained with an example:
 *  <nl>When searching for a handler, we might use logic like:
 *  <nl> EventHandlerInfo *pInfo = NULL;
 *  <nl> WiaEventHandlerLookup deviceSpecificLookup(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}\\0003\\Events");
 *  <nl> pInfo = deviceSpecificLookup.getHandlerRegisteredForEvent(guidEvent);
 *  <nl> if (!pInfo)
 *  <nl> {
 *  <nl>    //
 *  <nl>    //  Didn't find a handler registered for that device so let's try the globals
 *  <nl>    //
 *  <nl>    WiaEventHandlerLookup globalLookup(L"SYSTEM\\CurrentControlSet\\Control\\StillImage\\Events");
 *  <nl>    pInfo.globalLookup.getHandlerRegisteredForEvent(guidEvent);
 *  <nl>    .
 *  <nl>    .
 *  <nl>    .  and so on
 *  <nl>    .
 *  <nl> };
 *
 *  This method walks the registry, starting from <md WiaEventHandlerLookup::m_cswEventKeyRoot>,
 *  and returns a pointer to a <c EventHandlerInfo> describing the registered
 *  handler for this device event.
 *
 *  @parm   GUID | guidEvent | 
 *          A guid indicating the WIA event.
 *
 *  @rvalue NULL    | 
 *              There is no handler registered which can accept this device event.
 *  @rvalue non-NULL    | 
 *              A pointer to a <c WiaHandlerInfo> describing  the registered
 *              handler.  Caller must Release.
 *****************************************************************************/
EventHandlerInfo* WiaEventHandlerLookup::getHandlerRegisteredForEvent(
    const GUID  &guidEvent)
{
    EventHandlerInfo *pEventHandlerInfo = NULL;

    //
    //  Ensure we do not have any event info left lying around.
    //  
    if (m_pEventHandlerInfo)
    {
        m_pEventHandlerInfo->Release();
        m_pEventHandlerInfo = NULL;
    }

    //
    //  Save the parameters in member fields so we can search on them during
    //  reg key enumeration.  Enumeration is done via procedure callbacks,
    //  in which we pass (this) as a parameter.
    //
    WCHAR   wszGuid[40];
    if (StringFromGUID2(guidEvent, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0])))
    {
        wszGuid[(sizeof(wszGuid)/sizeof(wszGuid[0])) - 1] = L'\0';
        m_cswEventGuidString = wszGuid;
    }

    //
    //  Open the registery at the desired place.   We only require READ access and
    //  we do not want to create it if it doesn't exist.
    //
    CSimpleReg csrEventRoot(HKEY_LOCAL_MACHINE, m_cswEventKeyRoot, false, KEY_READ, NULL);
    //
    //  Enumerate the sub-keys looking for the sub-key corresponding to guidEvent.
    //
    bool bKeyNotFound = csrEventRoot.EnumKeys(WiaEventHandlerLookup::ProcessEventSubKey, (LPARAM)this);
    if (bKeyNotFound)
    {
        DBG_TRC(("Key was not found!"));
    }
    else
    {
        DBG_TRC(("We found key %ws, looking for default handler...", m_cswEventKey.String()));

        //
        //  First, check whether we have a specific entry for the default handler.
        //
        CSimpleReg csrEventKey(csrEventRoot.GetKey(), m_cswEventKey.String());
        CSimpleStringWide cswDefault = csrEventKey.Query(DEFAULT_HANDLER_VALUE_NAME, L"");
        if (cswDefault.Length() > 0)
        {
            //
            //  Try and open the key specified by the default handler entry.
            //
            CSimpleReg csrDefautHandler(csrEventKey.GetKey(), cswDefault);
            if (csrEventKey.OK())
            {
                //
                //  Fill in the handler info from the handler entry
                //
                pEventHandlerInfo = CreateHandlerInfoFromKey(csrDefautHandler);
            }
        }
        //
        //  If we could not find the default, we will just take the first one we find.
        //  TBD:  Should we enumerate and return the last one registered instead?  WinXP bits
        //  did not do this...
        //
        if (!pEventHandlerInfo)
        {
            //
            //  Set the Handler CLSID to the empty string, since we're not looking for a specific handler,
            //  any one while do.
            //
            m_cswHandlerCLSID = L"";

            csrEventKey.EnumKeys(WiaEventHandlerLookup::ProcessHandlerSubKey, (LPARAM)this);

            //
            //  Swap pEventHandlerInfo with m_pEventHandlerInfo.  m_pEventHandlerInfo will
            //  be non-NULL if we were successfull.
            //  Be sure to set it to NULL so we don't release it if this function is called again
            //  - only the caller should release this object.
            //
            pEventHandlerInfo   = m_pEventHandlerInfo;
            m_pEventHandlerInfo = NULL;
        }


        //  Diagnostic only
        if (pEventHandlerInfo)
        {
            DBG_TRC(("Found handler:"));
            pEventHandlerInfo->Dump();
        }
        else
        {
            DBG_TRC(("No handler could be found"));
        }
    }

    return pEventHandlerInfo;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  EventHandlerInfo* | WiaEventHandlerLookup | getHandlerRegisteredForDeviceEvent |
 *
 *  This method walks the registry, starting from <md WiaEventHandlerLookup::m_cswEventKeyRoot>,
 *  searches for the event subkey matching <p guidEvent>.  It enumerates all handlers
 *  under that key and finds the one whose CLSID matches <p guidHandlerCLSID> and 
 *  returns a pointer to a <c EventHandlerInfo>.
 *
 *  @parm   GUID | guidEvent | 
 *          A guid indicating the WIA event.
 *  @parm   GUID& | guidHandlerCLSID | 
 *          A guid indicating the CLSID of the registered handler.
 *
 *  @rvalue NULL    | 
 *              There is no handler registered with this CLSID.
 *  @rvalue non-NULL    | 
 *              A pointer to a <c WiaHandlerInfo> describing  the registered
 *              handler.  Caller must Release.
 *****************************************************************************/
EventHandlerInfo* WiaEventHandlerLookup::getHandlerFromCLSID(
    const GUID              &guidEvent,
    const GUID              &guidHandlerCLSID)
{
    EventHandlerInfo *pEventHandlerInfo = NULL;

    //
    //  Ensure we do not have any event info left lying around.
    //  
    if (m_pEventHandlerInfo)
    {
        m_pEventHandlerInfo->Release();
        m_pEventHandlerInfo = NULL;
    }

    //
    //  Save the parameters in member fields so we can search on them during
    //  reg key enumeration.  Enumeration is done via procedure callbacks,
    //  in which we pass (this) as a parameter.
    //
    WCHAR   wszGuid[40];
    if (StringFromGUID2(guidHandlerCLSID, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0])))
    {
        wszGuid[(sizeof(wszGuid)/sizeof(wszGuid[0])) - 1] = L'\0';
        m_cswHandlerCLSID = wszGuid;
    }
    if (StringFromGUID2(guidEvent, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0])))
    {
        wszGuid[(sizeof(wszGuid)/sizeof(wszGuid[0])) - 1] = L'\0';
        m_cswEventGuidString = wszGuid;
    }
    DBG_TRC(("Looking for event %ws and CLSID %ws", m_cswEventGuidString.String(), m_cswHandlerCLSID.String()));

    //
    //  Open the registery at the desired place.   We only require READ access and
    //  we do not want to create it if it doesn't exist.
    //
    CSimpleReg csrEventRoot(HKEY_LOCAL_MACHINE, m_cswEventKeyRoot, false, KEY_READ, NULL);
    //
    //  Enumerate the sub-keys looking for the sub-key corresponding to guidEvent.
    //
    bool bKeyNotFound = csrEventRoot.EnumKeys(WiaEventHandlerLookup::ProcessEventSubKey, (LPARAM)this);
    if (bKeyNotFound)
    {
        DBG_TRC(("Key was not found!"));
    }
    else
    {
        DBG_TRC(("We found key %ws, looking for specific handler...", m_cswEventKey.String()));

        CSimpleReg csrEventKey(csrEventRoot.GetKey(), m_cswEventKey.String());
        //
        //  Search for the specific handler.  m_cswHandlerCLSID has been primed with the
        //  CLSID we're looking for.
        //
        csrEventKey.EnumKeys(WiaEventHandlerLookup::ProcessHandlerSubKey, (LPARAM)this);

        //
        //  Swap pEventHandlerInfo with m_pEventHandlerInfo.  m_pEventHandlerInfo will
        //  be non-NULL if we were successfull.
        //  Be sure to set it to NULL so we don't release it if this function is called again
        //  - only the caller should release this object.
        //
        pEventHandlerInfo   = m_pEventHandlerInfo;
        m_pEventHandlerInfo = NULL;

        //  Diagnostic only
        if (pEventHandlerInfo)
        {
            DBG_TRC(("Found specific handler:"));
            pEventHandlerInfo->Dump();
        }
        else
        {
            DBG_TRC(("No specific handler could be found"));
        }
    }

    return pEventHandlerInfo;
}


/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  EventHandlerInfo* | WiaEventHandlerLookup | CreateHandlerInfoFromKey |
 *
 *  Creates a <c EventHandlerInfo> object for the specified handler registry key.
 *
 *  @parm   CSimpleReg | csrHandlerKey | 
 *          Reg key of the handler entry
 *
 *  @rvalue NULL    | 
 *              We could not create the event handler info object.
 *  @rvalue non-NULL    | 
 *              We created the event handler info object.  Caller must Release.
 *****************************************************************************/
EventHandlerInfo* WiaEventHandlerLookup::CreateHandlerInfoFromKey(
    CSimpleReg &csrHandlerKey)
{
    EventHandlerInfo *pEventHandlerInfo = NULL;
    
    if (csrHandlerKey.OK())
    {
        CSimpleString cswCLSID          = csrHandlerKey.GetSubKeyName();
        CSimpleString cswName           = csrHandlerKey.Query(NAME_VALUE, L"");
        CSimpleString cswDescription    = csrHandlerKey.Query(DESC_VALUE_NAME, L"");
        CSimpleString cswIcon           = csrHandlerKey.Query(ICON_VALUE_NAME, L"");;
        CSimpleString cswCommandline    = csrHandlerKey.Query(CMDLINE_VALUE_NAME, L"");
        GUID          guidCLSID         = GUID_NULL;
        CLSIDFromString((LPOLESTR)cswCLSID.String(), &guidCLSID);

        pEventHandlerInfo = new EventHandlerInfo(cswName,       
                                                 cswDescription,
                                                 cswIcon,       
                                                 cswCommandline,
                                                 guidCLSID);
    }

    return pEventHandlerInfo;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  bool | WiaEventHandlerLookup | ProcessEventSubKey |
 *
 *  This method is called on each sub-key as part of an enumeration of all 
 *  the event sub-keys.  The enumeration will stop if we return false from
 *  this method.
 *
 *  @parm   CKeyEnumInfo& | enumInfo | 
 *          Indicates the current sub-key we're on.
 *
 *  @rvalue false    | 
 *              Indicates we can stop with the enumeration.  We found the correct
 *              event key.
 *  @rvalue true     | 
 *              Indicates we should continue with the enumeration.
 *****************************************************************************/
bool WiaEventHandlerLookup::ProcessEventSubKey(
    CSimpleReg::CKeyEnumInfo &enumInfo)
{
    bool bContinueEnumeration = TRUE;

    //
    //  Check that we have a This pointer
    //
    WiaEventHandlerLookup *This = (WiaEventHandlerLookup*)enumInfo.lParam;
    if (This)
    {
        //
        //  Open this sub-key.  We're looking for a sub-key which contains a GUID entry
        //  matching m_cswEventGuidString.
        //
        CSimpleReg csrEventSubKey(enumInfo.hkRoot, enumInfo.strName);
        
        CSimpleStringWide cswGuidValue = csrEventSubKey.Query(GUID_VALUE_NAME, L"{00000000-0000-0000-0000-000000000000}");
        if (cswGuidValue.CompareNoCase(This->m_cswEventGuidString) == 0)
        {
            //
            //  We found the key we're looking for.  All we need to store is the name.  
            //
            This->m_cswEventKey = enumInfo.strName;
            bContinueEnumeration = FALSE;
        }
    }
    return bContinueEnumeration;
}

/*****************************************************************************
 *  @doc    INTERNAL 
 *
 *  @mfunc  bool | WiaEventHandlerLookup | ProcessHandlerSubKey |
 *
 *  This method is called on each sub-key as part of an enumeration of 
 *  the handler sub-keys.  Our current behavior is one of two options:
 *  <nl>  If <md WiaEventHandlerLookup::m_cswHandlerCLSID> is empty, stop enumeration after the
 *  first one.  
 *  <nl>  If <md WiaEventHandlerLookup::m_cswHandlerCLSID> is not empty, stop enumeration
 *  only after finding the handler corresponding to that CLSID.  
 *
 *  On return, we set the <md WiaEventHandlerLookup::m_pEventHandlerInfo>
 *  member.
 *
 *  @parm   CKeyEnumInfo& | enumInfo | 
 *          Indicates the current sub-key we're on.
 *
 *  @rvalue false    | 
 *              Indicates we can stop with the enumeration.  We found the correct
 *              handler.
 *  @rvalue true     | 
 *              Indicates we should continue with the enumeration.
 *****************************************************************************/
bool WiaEventHandlerLookup::ProcessHandlerSubKey(
    CSimpleReg::CKeyEnumInfo &enumInfo)
{
    bool bContinueEnumeration = TRUE;

    //
    //  Check that we have a This pointer
    //
    WiaEventHandlerLookup *This = (WiaEventHandlerLookup*)enumInfo.lParam;
    if (This)
    {
        //
        //  Open this sub-key.
        //
        CSimpleReg csrHandlerSubKey(enumInfo.hkRoot, enumInfo.strName);
        if (csrHandlerSubKey.OK())
        {
            //
            //  Check whether we have to find a specific handler or just the first one.
            //
            if (This->m_cswHandlerCLSID.Length() > 0)
            {
                if (enumInfo.strName.CompareNoCase(This->m_cswHandlerCLSID) == 0)
                {
                    //
                    //  This is the specific handler we're looking for.
                    //
                    This->m_pEventHandlerInfo = This->CreateHandlerInfoFromKey(csrHandlerSubKey);
                    bContinueEnumeration    = FALSE;
                }
            }
            else
            {
                //
                //  We only want the first one, so this one will do
                //
                This->m_pEventHandlerInfo = This->CreateHandlerInfoFromKey(csrHandlerSubKey);
                bContinueEnumeration    = FALSE;
            }
        }
    }
    return bContinueEnumeration;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\wiaeventhandlerlookup.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/10/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaEventHandlerLookup.h - Definitions for <c WiaEventHandlerLookup> |
 *
 *  This file contains the class definition for <c WiaEventHandlerLookup>.
 *
 *****************************************************************************/

//
//  Defines
//

#define WiaEventHandlerLookup_UNINIT_SIG   0x55756C45
#define WiaEventHandlerLookup_INIT_SIG     0x49756C45
#define WiaEventHandlerLookup_TERM_SIG     0x54756C45
#define WiaEventHandlerLookup_DEL_SIG      0x44756C45

#define GUID_VALUE_NAME             L"GUID"
#define DEFAULT_HANDLER_VALUE_NAME  L"DefaultHandler"
#define NAME_VALUE                  L"Name"
#define DESC_VALUE_NAME             L"Desc"
#define ICON_VALUE_NAME             L"Icon"
#define CMDLINE_VALUE_NAME          L"Cmdline"

#define GLOBAL_HANDLER_REGPATH  L"SYSTEM\\CurrentControlSet\\Control\\StillImage\\Events"
#define DEVNODE_REGPATH         L"SYSTEM\\CurrentControlSet\\Control\\Class\\"
#define DEVNODE_CLASS_REGPATH   L"SYSTEM\\CurrentControlSet\\Control\\Class\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}"
#define DEVINTERFACE_REGPATH    L"SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}"
#define EVENT_STR               L"\\Events"
#define DEVICE_ID_VALUE_NAME    L"DeviceID"

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class WiaEventHandlerLookup | Walks the a registry subtree looking for the appropriate persistent handler
 *  
 *  @comm
 *  This class starts from the given registry location, and walks the sub-tree
 *  looking for the appropriately registered WIA persistent event handler.
 *  Note that it can only return handlers from the specific sub-trees.  To
 *  search for default handler for a given event, multiple of these objects
 *  may be needed e.g. one to search the device event key, one to search the
 *  global event key and so on.
 *
 *  This class is not thread safe - multiple threads should not use an object of class
 *  simultaneously.  Either the caller should synchronize access, or preferably, each 
 *  should use it's own object instance.
 *
 *****************************************************************************/
class WiaEventHandlerLookup 
{
//@access Public members
public:

    // @cmember Constructor
    WiaEventHandlerLookup(const CSimpleString &cswEventKeyPath);
    // @cmember Constructor
    WiaEventHandlerLookup();
    // @cmember Destructor
    virtual ~WiaEventHandlerLookup();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Find the appropriate WIA handler
    EventHandlerInfo* getPersistentHandlerForDeviceEvent(const CSimpleStringWide &cswDeviceID, const GUID &guidEvent);

    // @cmember Change the root event key path for this object
    VOID    setEventKeyRoot(const CSimpleString &cswNewEventKeyPath);
    // @cmember Return the event handler registered for this WIA event
    EventHandlerInfo* getHandlerRegisteredForEvent(const GUID &guidEvent);
    // @cmember Return the event handler with this CLSID
    EventHandlerInfo* getHandlerFromCLSID(const GUID &guidEvent, const GUID &guidHandlerCLSID);

//@access Private members
private:
    // @cmember Enumeration procedure called to process each event sub-key
    static bool ProcessEventSubKey(CSimpleReg::CKeyEnumInfo &enumInfo);
    // @cmember Enumeration procedure called to rocess each handler sub-key
    static bool ProcessHandlerSubKey(CSimpleReg::CKeyEnumInfo &enumInfo);

    // @cmember Helper which creates a handler info object from the handler registry key
    EventHandlerInfo* CreateHandlerInfoFromKey(CSimpleReg &csrHandlerKey);

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember The registry path of the start of our search
    CSimpleStringWide   m_cswEventKeyRoot;
    // @cmember Stores the event guid in string form.  The event is the one specified in <mf WiaEventHandlerLookup::getHandlerRegisteredForEvent>
    CSimpleStringWide   m_cswEventGuidString;
    // @cmember Stores the event sub-key name set after event key enumeration
    CSimpleStringWide   m_cswEventKey;
    // @cmember Stores the handler CLSID used when searching for a specific handler
    CSimpleStringWide   m_cswHandlerCLSID;
    // @cmember Stores the handler information set after event handler enumeration
    EventHandlerInfo    *m_pEventHandlerInfo;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | WiaEventHandlerLookup | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag WiaEventHandlerLookup_UNINIT_SIG | 'EluU' - Object has not been successfully
    //       initialized
    //   @flag WiaEventHandlerLookup_INIT_SIG | 'EluI' - Object has been successfully
    //       initialized
    //   @flag WiaEventHandlerLookup_TERM_SIG | 'EluT' - Object is in the process of
    //       terminating.
    //    @flag WiaEventHandlerLookup_INIT_SIG | 'EluD' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @mdata ULONG | WiaEventHandlerLookup | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata CSimpleStringWide | WiaEventHandlerLookup | m_cswEventKeyRoot | 
    //  This string is used to indicate the registry path of the start of our search.
    //  The registry key at this location is opened, and the sub-keys searched
    //  for appropriate registered handlers.  
    //
    // @mdata CSimpleStringWide | WiaEventHandlerLookup | m_cswEventGuidString | 
    //  Stores the event guid in string form.  The event is the one specified in <mf WiaEventHandlerLookup::getHandlerRegisteredForEvent>
    //
    // @mdata CSimpleStringWide | WiaEventHandlerLookup | m_cswEventKey | 
    //  Stores the event sub-key name set after event key enumeration
    //
    // @mdata CSimpleStringWide | WiaEventHandlerLookup | m_cswHandlerCLSID | 
    //  Stores the handler CLSID used to test for a match when searching for a specific handler
    //
    // @mdata <c EventHandlerInfo>* | WiaEventHandlerLookup | m_EventHandlerInfo | 
    //  Stores the handler information set after event handler enumeration
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\collect.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	collect.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 14:40:17 1999
 * Description:
 * 	Implementation of the CCollection object helper class.
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

/*-----------------------------------------------------------------------------
 * CCollection::CCollection
 *
 * Create a new CCollection object. this initializes the collection to be
 * an empty collection, a collection with no elements.
 *---------------------------------------------------------------------------*/
CCollection::CCollection() 
: m_lLength( 0 ), m_rgpDispatch( NULL ), m_lCursor( 0 ) 
{
    TRACK_OBJECT( "CCollection" );
}

STDMETHODIMP_(void)
CCollection::FinalRelease()
{
    // free our dispatch array, release our referance
    // back to our owner
    FreeDispatchArray();
}

/*-----------------------------------------------------------------------------
 * CCollection::FreeDispatchArray()
 *
 * This handles freeing the array of IDispatch pointers we have. this 
 * will free all the pointers, then delete the array.
 *---------------------------------------------------------------------------*/
void CCollection::FreeDispatchArray()
{
    // step 1, call release on all the pointers
    for ( unsigned long i = 0; i < m_lLength; i++ )
    {
        m_rgpDispatch[i]->Release();
    }

    // step 2, free the array
    {
        CoTaskMemFree( m_rgpDispatch );
        m_rgpDispatch = NULL;
        m_lLength = 0;
    }
}

/*-----------------------------------------------------------------------------
 * CCollection:SetDispatchArray
 *
 * This handles setting the dispatch array for this collection.  You cannot
 * call this unless you don't have an array yet.  The array must be allocated
 * with CoTaskMemAlloc.
 *
 * rgpDispatch:		the array of IDispatch pointers
 * lSize:			the number of elements within the array.
 *---------------------------------------------------------------------------*/
bool CCollection::SetDispatchArray( IDispatch** rgpDispatch, unsigned long lSize )
{
    Assert( m_rgpDispatch == NULL );

    if ( NULL == rgpDispatch )
    {
        TraceTag((tagError, "Invalid argument passed to SetDispatchArray"));
        return false;
    }

    // assign the pointers.  It is assumed that the caller has
    // already addref'd the pointers
    m_rgpDispatch = rgpDispatch;
    m_lLength = lSize;

    return true;
}

/*-----------------------------------------------------------------------------
 * Collection::AllocateDispatchArray
 *
 * This handles the allocation of the Dispatch array.  This will allocate
 * an array with lSize elements and initialize it to NULL, This cannot be 
 * called after the array has been set.
 *
 * lSize:		the size of the array to allocate.
 *---------------------------------------------------------------------------*/
HRESULT CCollection::AllocateDispatchArray( unsigned long lSize )
{
    Assert( m_rgpDispatch == NULL );

    // if the array is zero in length we are done.
    if ( lSize == 0 )
        return S_OK;

    ULONG cb = sizeof( IDispatch* ) * lSize;
    m_rgpDispatch = static_cast<IDispatch**>(CoTaskMemAlloc( cb ));
    if ( !m_rgpDispatch )
        return E_OUTOFMEMORY;

    // clear the memory, set the length
    ZeroMemory( m_rgpDispatch, cb );
    m_lLength = lSize;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::CopyFrom
 *
 * This handles creating this collection from an existing collection, this 
 * copies the members from pCollection, and then sets punkToRelease so that
 * the owner will live.
 *
 * pCollection:	the collection to copy from
 *---------------------------------------------------------------------------*/
HRESULT CCollection::CopyFrom( CCollection* pCollection )
{
    Assert( m_rgpDispatch == NULL );
    Assert( pCollection != NULL );

    HRESULT hr;
    // Allocate the array
    hr = AllocateDispatchArray( pCollection->m_lLength );
    if ( FAILED(hr) ) {
        return hr;
    }

    // copy the fields
    m_lLength = pCollection->m_lLength;
    m_lCursor = pCollection->m_lCursor;

    // Copy and AddRef the elements in the collection
    for ( int i = 0; i < m_lLength; i++ ) {
        m_rgpDispatch[i] = pCollection->m_rgpDispatch[i];
        m_rgpDispatch[i]->AddRef();
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_Count()	[ICollection]
 *
 * This returns the length of the collection.
 *
 * plLength:	our param, to recieve the length of the collection
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get_Count( /*out*/ long* plLength )
{
    if ( NULL == plLength )
        return E_POINTER;

    *plLength = m_lLength;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_Length()	[ICollection]
 *
 * This returns the length of the collection.
 *
 * plLength:	our param, to recieve the length of the collection
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get_Length( /*out*/ unsigned long* plLength )
{
    if ( NULL == plLength )
        return E_POINTER;

    *plLength = m_lLength;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_Item()		[ICollection]
 *
 * This returns the desired item from our dispatch array.  If the index
 * is invalid then will put NULl into the out param.
 *
 * lItem:		the item that we want to retrieve
 * ppDispItem:	Out param to recieve the item's IDispatch
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get_Item( long Index, /*out*/ IDispatch** ppDispItem )
{   
    if ( NULL == ppDispItem )
        return E_POINTER;

    // initialize the out param
    *ppDispItem = NULL;
    if ( Index >= m_lLength || Index < 0)
    {
        TraceTag((tagError, "CCollection: access item %ld, only %ld items", Index, m_lLength ));
        return S_OK;
    }

    *ppDispItem = m_rgpDispatch[Index];
    Assert( *ppDispItem );
    (*ppDispItem)->AddRef();
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_NewEnum()	[ICollection]
 *
 * This create a new enumeration which is a copy of this one. this creates
 * an exact copy of this enumeration and returns it.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get__NewEnum( /*out*/ IUnknown** ppEnum )
{
    HRESULT hr;
    CComObject<CCollection>* pCollection = NULL;

    if ( NULL == ppEnum )
        return E_POINTER;

    // initialize the out param
    *ppEnum = NULL;

    // attempt to create a new collection object
    hr = THR( CComObject<CCollection>::CreateInstance( &pCollection ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // attempt to copy this collection
    hr = THR( pCollection->CopyFrom( this ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // fill the our param
    hr = THR( pCollection->QueryInterface( IID_IUnknown, 
                                           reinterpret_cast<void**>(ppEnum) ) );

    Cleanup:
    if ( FAILED( hr ) )
        delete pCollection;

    return hr;
}

/*-----------------------------------------------------------------------------
 * CCollection::Next()			[IEnumVARIANT]
 *
 * Copies celt elements int the rgvar array.  returns the number of elements
 * retrieved.
 * 
 * celt:			the number of elements the caller wants
 * rgvar:			a place to put these elements 
 * pceltFetched:	How many elements we actually we able to get.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Next( unsigned long celt, VARIANT* rgvar, unsigned long* pceltFetched )
{
    unsigned long celtFetched = 0;

    // verify the argments
    if ( NULL == rgvar && celt )
        return E_POINTER;

    // figure out how many we can return
    celtFetched = celt;
    if ( m_lCursor + celtFetched >= m_lLength )
        celtFetched = m_lLength - m_lCursor;

    // Init, and copy the results
    for ( unsigned long i = 0; i < celt; i++ )
        VariantInit( &rgvar[i] );

    for ( i = 0; i < celtFetched; i++ )
    {
        rgvar[i].vt = VT_DISPATCH;
        rgvar[i].pdispVal = m_rgpDispatch[m_lCursor+i];
        rgvar[i].pdispVal->AddRef();
    }

    // Return the number of elements fetched, if required
    if ( pceltFetched ) {
        *pceltFetched = celtFetched;
    }
    m_lCursor += celtFetched;
    return( celt == celtFetched ? S_OK : S_FALSE );
}

/*-----------------------------------------------------------------------------
 * CCollection::Skip()			[IEnumVARIANT]
 *
 * Skips celt elements in the array.
 *
 * celt:	the number of elements that we want to skip.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Skip( unsigned long celt )
{
    m_lCursor += celt;
    if ( m_lCursor >= m_lLength )
    {
        m_lCursor = m_lLength;
        return S_FALSE; // no more left
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::Reset()			[IEnumVARIANT]
 *
 * Resets the cursor to the start of the collection
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Reset()
{
    // simply point to element 0, I don't know how this can fail.
    m_lCursor = 0;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::Clone()			[IEnumVARIANT]
 *
 * Copies this collection including its current position
 *
 * ppEnum:		Out, recieves a pointer to the new enumeration
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Clone( /*out*/ IEnumVARIANT** ppEnum )
{   
    // delegate the work to get_NewEnum()
    IUnknown*   pUnk = NULL;
    HRESULT     hr;

    if ( NULL == ppEnum )
        return E_POINTER;
    *ppEnum = NULL;

    hr = THR( get__NewEnum( &pUnk ) );
    if ( FAILED( hr ) )
        return hr;

    hr = THR( pUnk->QueryInterface( IID_IEnumVARIANT,
                                    reinterpret_cast<void**>(ppEnum) ) );

    // release the temporary pointer
    pUnk->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiarpc\wiarpc.cpp ===
#include "precomp.h"
#include "wia.h"
#include "stirpc.h"

#define INIT_GUID
// {8144B6F5-20A8-444a-B8EE-19DF0BB84BDB}
DEFINE_GUID( CLSID_StiEventHandler, 0x8144b6f5, 0x20a8, 0x444a, 0xb8, 0xee, 0x19, 0xdf, 0xb, 0xb8, 0x4b, 0xdb );

#define WIA_SERVICE_STARTING_EVENT_NAME TEXT("Global\\WiaServiceStarted")

//
// (A;;GA;;;SY) becomes (A;;0x1f003;;;SY) when converted back to string
// 0x1f0000 is SYNCHORNIZE | STANDARD_RIGHTS_REQUIRED
// 0x000003 is specific rigts for ??? 
//
#define WIA_SERVICE_STARTING_EVENT_DACL \
    TEXT("D:(A;;0x1f0003;;;SY)(A;;0x1f0003;;;LS)(A;;0x1f0003;;;LA)")

const TCHAR g_szWiaServiceStartedEventName[] = WIA_SERVICE_STARTING_EVENT_NAME;
const TCHAR g_WiaESDString[] = WIA_SERVICE_STARTING_EVENT_DACL;

// event and event wait handles
HANDLE g_hWiaServiceStarted = NULL;     // event 
HANDLE g_hWaitForWiaServiceStarted = NULL; // wait
HANDLE g_hWiaEventArrived = NULL;       // event
HANDLE g_hWaitForWiaEventArrived = NULL; // wait

// async RPC request
RPC_BINDING_HANDLE g_AsyncRpcBinding = NULL;
RPC_STATUS g_LastRpcCallStatus = RPC_S_OK;
RPC_ASYNC_STATE g_Async = { 0 };
PRPC_ASYNC_STATE g_pAsync = &g_Async;

// event structure filled by async RPC call
WIA_ASYNC_EVENT_NOTIFY_DATA g_Event = { 0 };

#ifdef DEBUG
#define DBG_TRACE(x) DebugTrace x
#else
#define DBG_TRACE(x)
#endif

void DebugTrace(LPCSTR fmt, ...)
{
    char buffer[1024] = "WIARPC:";
    const blen = 7;
    size_t len = (sizeof(buffer) / sizeof(buffer[0])) - blen;
    va_list marker;

    va_start(marker, fmt);
    _vsnprintf(buffer + blen, len - 3, fmt, marker);

    buffer[len - 3] = 0;
    len = strlen(buffer);
    if(len > 0) {
        if(buffer[len - 1] != '\n') {
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }
        OutputDebugStringA(buffer);
    }
    va_end(marker);
}

// aux function to call LocalFree() safely on a pointer and zero it
template <typename t>
   void WiaELocalFree(t& ptr) {
    if(ptr) {
        LocalFree(static_cast<HLOCAL>(ptr));
        ptr = NULL;
    }
}

// aux function to call CloseHanlde() on a valid handle and zero it
void WiaECloseHandle(HANDLE& h)
{
    if(h && h != INVALID_HANDLE_VALUE) {
        CloseHandle(h);
        h = NULL;
    }
}


//
// Returns TRUE if event's security descriptor is exactly the one we'd
// set it to be, FALSE otherwise
//
BOOL WiaECheckEventSecurity(HANDLE hEvent)
{
    BOOL success = FALSE;
    PACL pDacl;
    PSECURITY_DESCRIPTOR pDescriptor = NULL;
    LPTSTR stringDescriptor = NULL;
    ULONG stringLength;
    
    if(ERROR_SUCCESS != GetSecurityInfo(hEvent, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
                                        NULL, NULL, &pDacl, NULL, &pDescriptor))
    {
        //
        // failed to retrieve event's security descriptor -- this is a
        // failure
        //
        DBG_TRACE(("Failed to retrieve event security descriptor (Error %d)", GetLastError()));
        goto Done;
    }

    if(!ConvertSecurityDescriptorToStringSecurityDescriptor(pDescriptor,
        SDDL_REVISION_1, DACL_SECURITY_INFORMATION, &stringDescriptor, &stringLength))
    {
        //
        // failed to convert event's security descriptor to string --
        // this is also a failure
        //
        DBG_TRACE(("Failed to convert security descriptor to string (Error %d)", GetLastError()));
        goto Done;
    }

    if(lstrcmp(g_WiaESDString, stringDescriptor) != 0)
    {
        //
        // descriptors are different, this is a failure
        //
        DBG_TRACE(("String security descriptor of WIA event is unexpected: \r\n'%S'\r\n instead of \r\n'%S'\r\n)",
                   stringDescriptor, g_WiaESDString));
        goto Done;
    }

    success = TRUE;
    
Done:
    WiaELocalFree(pDescriptor);
    WiaELocalFree(stringDescriptor);
    
    return success;
}

//
// 
//
RPC_STATUS WiaEPrepareAsyncCall(PRPC_ASYNC_STATE pAsync)
{
    RPC_STATUS status;
    LPTSTR binding = NULL;

    status = RpcStringBindingCompose(NULL, STI_LRPC_SEQ, NULL, STI_LRPC_ENDPOINT, NULL, &binding);
    if(status) {
        DBG_TRACE(("Failed to compose string binding (Error %d)", status));
        goto Done;
    }
                                     
    
    status = RpcBindingFromStringBinding(binding, &g_AsyncRpcBinding);
    if(status) {
        DBG_TRACE(("Failed to build async RPC binding (Error %d)", status));
        goto Done;
    }

    status = RpcAsyncInitializeHandle(pAsync, sizeof(RPC_ASYNC_STATE));
    if(status) {
        DBG_TRACE(("Failed to initialize RPC handle (Error %d)", status));
        goto Done;
    }

    pAsync->UserInfo = NULL;
    pAsync->NotificationType = RpcNotificationTypeEvent;
    pAsync->u.hEvent = g_hWiaEventArrived;

    // store the pointer to async into global, so that if
    // the result of R_WiaGetEventDataAsync() arrives soon, it would
    // not land without it
    InterlockedExchangePointer((PVOID*)&g_pAsync, pAsync);
    
    RpcTryExcept {
        R_WiaGetEventDataAsync(pAsync, g_AsyncRpcBinding, &g_Event);
    } RpcExcept(1) {
        status = RpcExceptionCode();
        DBG_TRACE(("Exception 0x%x calling WIA RPC server", status));
    } RpcEndExcept;

Done:
    
    if(status && g_AsyncRpcBinding) {
        RpcTryExcept {
            RpcBindingFree(&g_AsyncRpcBinding);
        } RpcExcept(1) {
            status = RpcExceptionCode();
            DBG_TRACE(("Exception 0x%x while freeing binding handle", status));
        } RpcEndExcept;
        
        g_AsyncRpcBinding = NULL;
    }
    
    if(binding) RpcStringFree(&binding);
    
    return status;
}



#define SESSION_MONIKER TEXT("Session:Console!clsid:")
#include <initguid.h>
DEFINE_GUID(CLSID_DefWiaHandler,
            0xD13E3F25, 0x1688, 0x45A0,
            0x97, 0x43, 0x75, 0x9E, 0xB3, 0x5C, 0xDF, 0x9A);

#include "sticfunc.h"
/**************************************************************************\
* _CoCreateInstanceInConsoleSession
*
*   This helper function acts the same as CoCreateInstance, but will launch
*   a out-of-process COM server on the correct user's desktop, taking
*   fast user switching into account. (Normal CoCreateInstance will
*   launch it on the first logged on user's desktop, instead of the currently
*   logged on one).
*
*   This code was taken with permission from the Shell's Hardware
*   Notification service, on behalf of StephStm.
*
* Arguments:
*
*  rclsid,      // Class identifier (CLSID) of the object
*  pUnkOuter,   // Pointer to controlling IUnknown
*  dwClsContext // Context for running executable code
*  riid,        // Reference to the identifier of the interface
*  ppv          // Address of output variable that receives
*               //  the interface pointer requested in riid
*
* Return Value:
*
*   Status
*
* History:
*
*    03/01/2001 Original Version
*
\**************************************************************************/

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid,
                                          IUnknown* punkOuter,
                                          DWORD dwClsContext,
                                          REFIID riid,
                                          void** ppv)
{
    IBindCtx    *pbc    = NULL;
    HRESULT     hr      = CreateBindCtx(0, &pbc);   // Create a bind context for use with Moniker

    //
    // Set the return
    //
    *ppv = NULL;

    if (SUCCEEDED(hr)) {
        WCHAR wszCLSID[39];

        //
        // Convert the riid to GUID string for use in binding to moniker
        //
        if (StringFromGUID2(rclsid, wszCLSID, sizeof(wszCLSID)/sizeof(wszCLSID[0]))) {
            ULONG       ulEaten     = 0;
            IMoniker*   pmoniker    = NULL;
            WCHAR       wszDisplayName[sizeof(SESSION_MONIKER)/sizeof(WCHAR) + sizeof(wszCLSID)/sizeof(wszCLSID[0]) + 2] = SESSION_MONIKER;

            //
            // We want something like: "Session:Console!clsid:760befd0-5b0b-44d7-957e-969af35ce954"
            // Notice that we don't want the leading and trailing brackets {..} around the GUID.
            // So, first get rid of trailing bracket by overwriting it with termintaing '\0'
            //
            wszCLSID[lstrlenW(wszCLSID) - 1] = L'\0';

            //
            // Form display name string.  To get rid of the leading bracket, we pass in the
            // address of the next character as the start of the string.
            //
            if (lstrcatW(wszDisplayName, &(wszCLSID[1]))) {

                //
                // Parse the name and get a moniker:
                //

                hr = MkParseDisplayName(pbc, wszDisplayName, &ulEaten, &pmoniker);
                if (SUCCEEDED(hr)) {
                    IClassFactory *pcf = NULL;

                    //
                    // Attempt to get the class factory
                    //
                    hr = pmoniker->BindToObject(pbc, NULL, IID_IClassFactory, (void**)&pcf);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Attempt to create the object
                        //
                        hr = pcf->CreateInstance(punkOuter, riid, ppv);

                        DBG_TRACE(("_CoCreateInstanceInConsoleSession, pcf->CreateInstance returned: hr = 0x%08X", hr));
                        pcf->Release();
                    } else {

                        DBG_TRACE(("_CoCreateInstanceInConsoleSession, pmoniker->BindToObject returned: hr = 0x%08X", hr));
                    }
                    pmoniker->Release();
                } else {
                    DBG_TRACE(("_CoCreateInstanceInConsoleSession, MkParseDisplayName returned: hr = 0x%08X", hr));
                }
            } else {
                DBG_TRACE(("_CoCreateInstanceInConsoleSession, string concatenation failed"));
                hr = E_INVALIDARG;
            }
        } else {
            DBG_TRACE(("_CoCreateInstanceInConsoleSession, StringFromGUID2 failed"));
            hr = E_INVALIDARG;
        }

        pbc->Release();
    } else {
        DBG_TRACE(("_CoCreateInstanceInConsoleSession, CreateBindCtxt returned: hr = 0x%08X", hr));
    }

    return hr;
}

/**************************************************************************\
* GetUserTokenForConsoleSession
*
*   This helper function will grab the currently logged on interactive
*   user's token, which can be used in a call to CreateProcessAsUser.
*   Caller is responsible for closing this Token handle.
*
*   It first grabs the impersontaed token from the current session (our
*   service runs in session 0, but with Fast User Switching, the currently
*   active user may be in a different session).  It then creates a
*   primary token from the impersonated one.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   HANDLE to Token for logged on user in the currently active session.
*   NULL otherwise.
*
* History:
*
*    03/05/2001 Original Version
*
\**************************************************************************/

HANDLE GetUserTokenForConsoleSession()
{
    HANDLE  hImpersonationToken = NULL;
    HANDLE  hTokenUser = NULL;


    //
    // Get interactive user's token
    //

    if (GetWinStationUserToken(GetCurrentSessionID(), &hImpersonationToken)) {

        //
        // Maybe nobody is logged on, so do a check first.
        //

        if (hImpersonationToken) {

            //
            //  We duplicate the token, since the returned token is an
            //  impersonated one, and we need it to be primary for
            //  use in CreateProcessAsUser.
            //
            if (!DuplicateTokenEx(hImpersonationToken,
                                  0,
                                  NULL,
                                  SecurityImpersonation,
                                  TokenPrimary,
                                  &hTokenUser)) {
                DBG_TRC(("CEventNotifier::StartCallbackProgram, DuplicateTokenEx failed!  GetLastError() = 0x%08X", GetLastError()));
            }
        } else {
            DBG_PRT(("CEventNotifier::StartCallbackProgram, No user appears to be logged on..."));
        }

    } else {
        DBG_TRACE(("CEventNotifier::StartCallbackProgram, GetWinStationUserToken failed!  GetLastError() = 0x%08X", GetLastError()));
    }

    //
    //  Close the impersonated token, since we no longer need it.
    //
    if (hImpersonationToken) {
        CloseHandle(hImpersonationToken);
    }

    return hTokenUser;
}

/**************************************************************************\
* PrepareCommandline
*
*   This helper function will prepare the commandline for apps not registered
*   as local out-of-process COM servers.  We place the event guid and device
*   id in the command line.
*
*
* Arguments:
*
*   CSimpleStringWide &cswDeviceID - the device which generated this event
*   GUID              &guidEvent   - the GUID indicating which event occured.
*   CSimpleStringWide &cswRegisteredCOmmandline - the commandline this handler
*                                                 registered with.  This commandline
*                                                 contains the tokens that must
*                                                 be substituted.
*
* Return Value:
*
*   CSimpleStringWide - contians the parsed commandline which has the
*                       device id and event guid substituted.
*
* History:
*
*    03/05/2001 Original Version
*
\**************************************************************************/
CSimpleStringWide PrepareCommandline(
    const CSimpleStringWide &cswDeviceID,
    const GUID              &guidEvent,
    const CSimpleStringWide &cswRegisteredCommandline)
{
    WCHAR                   wszGUIDStr[40];
    WCHAR                   wszCommandline[MAX_PATH];
    WCHAR                  *pPercentSign;
    WCHAR                  *pTest = NULL;
    CSimpleStringWide       cswCommandLine;

    //
    //  ISSUE:  This code could be written better.  For now, we're not touching it
    //  and keeping it the same as the WinXP code base.
    //

    //
    // Fix up the commandline.  First check that it has at least two %
    //
    pTest = wcschr(cswRegisteredCommandline.String(), '%');
    if (pTest) {
        pTest = wcschr(pTest + 1, '%');
    }
    if (!pTest) {
        _snwprintf(
            wszCommandline,
            sizeof(wszCommandline) / sizeof( wszCommandline[0] ),
            L"%s /StiDevice:%%1 /StiEvent:%%2",
            cswRegisteredCommandline.String());
    } else {
        wcsncpy(wszCommandline, cswRegisteredCommandline.String(), sizeof(wszCommandline) / sizeof( wszCommandline[0] ));
    }

    //
    // enforce null termination
    //
    wszCommandline[ (sizeof(wszCommandline) / sizeof(wszCommandline[0])) - 1 ] = 0;

    //
    // Change the number {1|2} into s
    //
    pPercentSign = wcschr(wszCommandline, L'%');
    *(pPercentSign + 1) = L's';
    pPercentSign = wcschr(pPercentSign + 1, L'%');
    *(pPercentSign + 1) = L's';

    //
    // Convert the GUID into string
    //
    StringFromGUID2(guidEvent, wszGUIDStr, 40);

    //
    // Final comand line
    //
    //swprintf(pwszResCmdline, wszCommandline, bstrDeviceID, wszGUIDStr);
    cswCommandLine.Format(wszCommandline, cswDeviceID.String(), wszGUIDStr);

    return cswCommandLine;
}

void FireStiEvent()
{
    StiEventHandlerLookup stiLookup;

    //
    //  Get the STI handler list for this device event.  This will be returned as a double-NULL
    //  terminated BSTR.
    //
    BSTR bstrAppList = stiLookup.getStiAppListForDeviceEvent(g_Event.bstrDeviceID, g_Event.EventGuid);
    if (bstrAppList)
    {
        HRESULT             hr          = S_OK;
        IWiaEventCallback   *pIEventCB  = NULL;
        ULONG               ulEventType = WIA_ACTION_EVENT;
        //
        //  CoCreate our event UI handler.  Note that it will not display any UI
        //  if there is only one application.
        //
        hr = CoCreateInstance(
                 CLSID_StiEventHandler,
                 NULL,
                 CLSCTX_LOCAL_SERVER,
                 IID_IWiaEventCallback,
                 (void**)&pIEventCB);

        if (SUCCEEDED(hr)) {
    
            //
            //  Make the callback.  This will display a prompt if our AppList contains more
            //  than one application.
            //
            pIEventCB->ImageEventCallback(&g_Event.EventGuid,
                                          g_Event.bstrEventDescription,
                                          g_Event.bstrDeviceID,
                                          g_Event.bstrDeviceDescription,
                                          g_Event.dwDeviceType,
                                          bstrAppList,
                                          &g_Event.ulEventType,
                                          0);
            pIEventCB->Release();
        }
        SysFreeString(bstrAppList);
        bstrAppList = NULL;
    }
}

void WiaEFireEvent()
{
    HRESULT hr;
    IWiaEventCallback      *pIEventCB;

    //
    //  ISSUE:  For now, we assume this is a WIA event.  Really, it could
    //  be either WIA or STI.  STI events need special handling.
    //
    if (g_Event.ulEventType & STI_DEVICE_EVENT)
    {
        FireStiEvent();
    }
    else
    {
        //
        //  Find the persistent event handler for this device event
        //
        EventHandlerInfo *pEventHandlerInfo = NULL;
        WiaEventHandlerLookup eventLookup;

        pEventHandlerInfo = eventLookup.getPersistentHandlerForDeviceEvent(g_Event.bstrDeviceID, g_Event.EventGuid);
        if (pEventHandlerInfo)
        {
            //
            //  Check whether this is a out-of-process COM server registed handler or
            //  a commandline registered handler.
            //
            if (pEventHandlerInfo->getCommandline().Length() < 1)
            {
                //
                //  This is a COM registered handler
                //
                hr = _CoCreateInstanceInConsoleSession(pEventHandlerInfo->getCLSID(),
                                                       NULL,
                                                       CLSCTX_LOCAL_SERVER,
                                                       IID_IWiaEventCallback,
                                                       (void**)&pIEventCB);

                if (SUCCEEDED(hr)) {
                    pIEventCB->ImageEventCallback(&g_Event.EventGuid,
                                                 g_Event.bstrEventDescription,
                                                 g_Event.bstrDeviceID,
                                                 g_Event.bstrDeviceDescription,
                                                 g_Event.dwDeviceType,
                                                 g_Event.bstrFullItemName,
                                                 &g_Event.ulEventType,
                                                 0);
                    //
                    // Release the callback interface
                    //

                    pIEventCB->Release();

                } else {
                    DBG_ERR(("NotifySTIEvent:CoCreateInstance of event callback failed (0x%X)", hr));
                }
            }
            else
            {
                //
                //  This is a commandline registered handler
                //
                HANDLE                  hTokenUser  = NULL;
                STARTUPINFO             startupInfo = {0};
                PROCESS_INFORMATION     processInfo = {0};
                LPVOID                  pEnvBlock   = NULL;
                BOOL                    bRet        = FALSE;
                //
                // Get interactive user's token
                //
                hTokenUser = GetUserTokenForConsoleSession();

                //
                // Check that somebody is logged in
                //
                if (hTokenUser)
                {
                    //
                    // Set up start up info
                    //
                    ZeroMemory(&startupInfo, sizeof(startupInfo));
                    startupInfo.lpDesktop   = L"WinSta0\\Default";
                    startupInfo.cb          = sizeof(startupInfo);
                    startupInfo.wShowWindow = SW_SHOWNORMAL;

                    //
                    // Create the user's environment block
                    //
                    bRet = CreateEnvironmentBlock(
                               &pEnvBlock,
                               hTokenUser,
                               FALSE);
                    if (bRet) 
                    {
                        //
                        // Prepare the command line.  Make sure we pass in the EVENT guid, not the STI proxy guid.
                        //
                        CSimpleStringWide cswCommandLine;
                        cswCommandLine = PrepareCommandline(g_Event.bstrDeviceID,
                                                            g_Event.EventGuid,
                                                            pEventHandlerInfo->getCommandline());
                        //
                        // Create the process in user's context
                        //
                        bRet = CreateProcessAsUserW(
                                   hTokenUser,
                                   NULL,                    // Application name
                                   (LPWSTR)cswCommandLine.String(),
                                   NULL,                    // Process attributes
                                   NULL,                    // Thread attributes
                                   FALSE,                   // Handle inheritance
                                   NORMAL_PRIORITY_CLASS |
                                   CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_PROCESS_GROUP,
                                   pEnvBlock,               // Environment
                                   NULL,                    // Current directory
                                   &startupInfo,
                                   &processInfo);

                        if (! bRet) {
                            DBG_ERR(("CreateProcessAsUser failed!  GetLastError() = 0x%08X", GetLastError()));
                        }
                    }
                    else
                    {
                        DBG_ERR(("CreateEnvironmentBlock failed!  GetLastError() = 0x%08X", GetLastError()));
                    }
                }

                //
                // Garbage collection
                //
                if (processInfo.hProcess)
                {
                    CloseHandle(processInfo.hProcess);
                }
                if (processInfo.hThread)
                {
                    CloseHandle(processInfo.hThread);
                }
                if (hTokenUser) 
                {
                    CloseHandle(hTokenUser);
                }
                if (pEnvBlock) 
                {
                    DestroyEnvironmentBlock(pEnvBlock);
                }
            }

            pEventHandlerInfo->Release();
            pEventHandlerInfo = NULL;
        }
    }
}

void WiaEProcessAsyncCallResults(PRPC_ASYNC_STATE pAsync)
{
    RPC_STATUS callstatus, status;
    int nStatus;

    if(g_LastRpcCallStatus) {
        DBG_TRACE(("Last RPC call was not successful (error 0x%x, therefore we are not going to look at the results",
                  g_LastRpcCallStatus));
        return;
    }

    callstatus = RpcAsyncGetCallStatus(pAsync);

    RpcTryExcept {
        status = RpcAsyncCompleteCall(pAsync, &nStatus);
    } RpcExcept(1) {
        status = RpcExceptionCode();
    } RpcEndExcept;

    if(callstatus == RPC_S_OK && status == RPC_S_OK) {
        DBG_TRACE(("\r\n\r\n#### Event arrived on '%S', firing it\r\n\r\n", g_Event.bstrDeviceID));
        WiaEFireEvent();
    } else {
        DBG_TRACE(("Failed to complete async RPC call, error 0x%x", status));
    }
}

//
// 
//
void WiaECleanupAsyncCall(PRPC_ASYNC_STATE pAsync)
{
    RPC_STATUS status;
    int nReply;
    
    status = RpcAsyncGetCallStatus(pAsync);
    switch(status) {
    case RPC_S_ASYNC_CALL_PENDING: 
        DBG_TRACE(("Cancelling pending async RPC call."));
        RpcTryExcept {
            status = RpcAsyncCancelCall(pAsync, TRUE);
        } RpcExcept(1) {
            status = RpcExceptionCode();
            DBG_TRACE(("Exception 0x%x cancelling outstanding async RPC call", status));
        } RpcEndExcept;
        break;
            
    case RPC_S_OK:
        // already completed, don't do anything with it
        break;
            
    default:    
        DBG_TRACE(("Cleaning up async RPC call status is 0x%x.", status));
        RpcTryExcept {
            status = RpcAsyncCompleteCall(pAsync, &nReply);
        } RpcExcept(1) {
            status = RpcExceptionCode();
            DBG_TRACE(("Exception 0x%x cancelling outstanding async RPC call", status));
        } RpcEndExcept;
    }

    if(g_AsyncRpcBinding) {
        RpcTryExcept {
            RpcBindingFree(&g_AsyncRpcBinding);
        } RpcExcept(1) {
            status = RpcExceptionCode();
            DBG_TRACE(("Exception 0x%x while freeing binding handle", status));
        } RpcEndExcept;
        g_AsyncRpcBinding = NULL;
    }

    //
    // cleanup any BSTRs in g_Event
    //

    SysFreeString(g_Event.bstrEventDescription);
    g_Event.bstrEventDescription = NULL;
    SysFreeString(g_Event.bstrDeviceID);
    g_Event.bstrDeviceID = NULL;
    SysFreeString(g_Event.bstrDeviceDescription);
    g_Event.bstrDeviceDescription = NULL;
    SysFreeString(g_Event.bstrFullItemName);
    g_Event.bstrFullItemName = NULL;
}

VOID CALLBACK
WiaEServiceStartedCallback(LPVOID, BOOLEAN)
{
    PRPC_ASYNC_STATE pAsync;
    
    DBG_TRACE(("WIA service is starting"));
    
    pAsync = (PRPC_ASYNC_STATE) InterlockedExchangePointer((PVOID*)&g_pAsync, NULL);
    if(pAsync) {

        // at this point we are garanteed that
        // WiaERpcCallBack will not get to g_Async
        
        // abort any pending RPC calls
        WiaECleanupAsyncCall(pAsync);

        // initiate new async call
        g_LastRpcCallStatus = WiaEPrepareAsyncCall(pAsync);
        
    } else {
        DBG_TRACE(("No async pointer"));
    }
}

VOID CALLBACK
WiaERpcCallback(PVOID, BOOLEAN)
{
    PRPC_ASYNC_STATE pAsync;

    DBG_TRACE(("Async RPC event arrived"));
    
    pAsync = (PRPC_ASYNC_STATE) InterlockedExchangePointer((PVOID*)&g_pAsync, NULL);
    if(pAsync) {
        // at this point we are garanteed that
        // WiaEServiceStartedCallback will not get to g_Async

        WiaEProcessAsyncCallResults(pAsync);

        // cleanup the call
        WiaECleanupAsyncCall(pAsync);

        // initiate new async call
        g_LastRpcCallStatus = WiaEPrepareAsyncCall(pAsync);
    } else {
        DBG_TRACE(("No async pointer"));
    }
}

HRESULT WINAPI WiaEventsInitialize()
{
    HRESULT hr = S_OK;
    SECURITY_ATTRIBUTES sa = { sizeof(sa), FALSE, NULL };
    HANDLE hEvent = NULL;

    if(g_hWiaServiceStarted) {
        return S_OK;
    }

    // allocate appropriate security attributes for the named event we
    // use to learn about WIA service startup
    if(!ConvertStringSecurityDescriptorToSecurityDescriptor(g_WiaESDString,
        SDDL_REVISION_1, &(sa.lpSecurityDescriptor), NULL))
    {
        DBG_TRACE(("WiaEventsInitialize failed to produce event security descriptor (Error %d)", GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    hEvent = CreateEvent(&sa, FALSE, FALSE, WIA_SERVICE_STARTING_EVENT_NAME);
    if(hEvent == NULL) {
        DBG_TRACE(("WiaEventsInitialize failed to create named event (Error %d)", GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {

        // interrogate the security descriptor on this event -- does it
        // look like ours or is it squatted by a bad guy?

        if(!WiaECheckEventSecurity(hEvent)) {
            // we don't like how it looks, bail out
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            goto Cleanup;
        }
    }

    // we already have the event, try to mark our initialization
    // complete
    hEvent = InterlockedCompareExchangePointer(&g_hWiaServiceStarted, hEvent, NULL);

    if(hEvent != NULL) {
        //
        // oops, another thread beat us to this!
        //
        
        // we only allocated our security descriptor, free it
        WiaELocalFree(sa.lpSecurityDescriptor);

        //
        // return right away, don't do any more cleanup
        //
        // please, note that we did not really complete our
        // initialization yet, so we still may fail
        //
        return S_FALSE;
    }

    //
    // only one thread can make it to this point 
    //

    g_hWiaEventArrived = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(g_hWiaEventArrived == NULL) {
        DBG_TRACE(("WiaEventsInitialize failed to create async RPC event (Error %d)", GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // register for g_hWiaServiceStarted notification
    if(!RegisterWaitForSingleObject(&g_hWaitForWiaServiceStarted,
                                    g_hWiaServiceStarted,
                                    WiaEServiceStartedCallback,
                                    NULL,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT))
    {
        DBG_TRACE(("WiaEventsInitialize failed to register wait for ServiceStarted event event (Error %d)", GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    if(!RegisterWaitForSingleObject(&g_hWaitForWiaEventArrived,
                                    g_hWiaEventArrived,
                                    WiaERpcCallback,
                                    NULL,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT))
    {
        DBG_TRACE(("WiaEventsInitialize failed to register wait for RPC result event (Error %d)", GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    // attempt to issue first async RPC call 
    //
    g_LastRpcCallStatus = WiaEPrepareAsyncCall(g_pAsync);

Cleanup:
    if(FAILED(hr)) {
        if(g_hWaitForWiaServiceStarted) {
            UnregisterWaitEx(g_hWaitForWiaServiceStarted, INVALID_HANDLE_VALUE);
            g_hWaitForWiaServiceStarted = NULL;
        }

        if(g_hWaitForWiaEventArrived) {
            UnregisterWaitEx(g_hWaitForWiaEventArrived, INVALID_HANDLE_VALUE);
            g_hWaitForWiaEventArrived = NULL;
        }
        
        WiaECloseHandle(g_hWiaServiceStarted);
        WiaECloseHandle(g_hWiaEventArrived);
    }

    WiaELocalFree(sa.lpSecurityDescriptor);
    
    return hr;
}

void WINAPI WiaEventsTerminate()
{
    // TBD
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\collect.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	collect.h
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 11:43:19 1999
 * Description:
 * 	This defines the CCollection class. This is a object which will manage a 
 * 	collection of interface pointers and pass them out as IDispatch
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef __COLLECT_H_
#define __COLLECT_H_

/*-----------------------------------------------------------------------------
 * 
 * Class:		CCollection
 * Synopsis:	This implements a collection using the ICollection interface.
 * 				This also exposes an IEnumVARIANT interface so other callers
 * 				can use that.  This represents a collection of objects only.
 * 
 *---------------------------------------------------------------------------*/

class ATL_NO_VTABLE CCollection : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ICollection, &IID_ICollection, &LIBID_WIALib>,
	public IObjectSafetyImpl<CCollection, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
	public IEnumVARIANT
{
public:
	CCollection();

	DECLARE_TRACKED_OBJECT
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CCollection)
		COM_INTERFACE_ENTRY(ICollection)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	STDMETHOD_(void, FinalRelease)();

public:
	// Our methods, used locally inside of the server not exposed
	// via com.
	bool SetDispatchArray( IDispatch** rgpDispatch, unsigned long lSize );
	HRESULT AllocateDispatchArray( unsigned long lSize );
	inline unsigned long GetArrayLength() { return m_lLength; }
	inline IDispatch** GetDispatchArray() { return m_rgpDispatch; }
	HRESULT CopyFrom( CCollection* pCollection );
	
	// ICollection
	STDMETHOD(get_Count)( /*[out, retval]*/ long* plLength );
	STDMETHOD(get_Length)( /*[out, retval]*/ unsigned long* plLength );
	STDMETHOD(get_Item)( long Index, /*[out, retval]*/ IDispatch** ppDispItem );
	STDMETHOD(get__NewEnum)( /*[out, retval]*/ IUnknown** ppEnum );

	// IEnumVARIANT
    STDMETHOD(Next)( unsigned long celt, VARIANT* rgvar, unsigned long* pceltFetched );
    STDMETHOD(Skip)( unsigned long celt );
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum );
	
protected:
	void FreeDispatchArray();

	unsigned long 	m_lLength;
	unsigned long	m_lCursor;
	IDispatch**		m_rgpDispatch;
};

#endif //__COLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\cwia.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:    wia.cpp
 * Author:  Samuel Clement
 * Date:    Thu Aug 12 11:35:38 1999
 * Description:
 *  Implementation of the CWia class
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * History:
 *  12 Aug 1999:        Created.
 *  27 Aug 1999:        Added, _DebugDialog implementation
 *  10 Sep 1999:        Use CWiaCacheManager when creating devices (samclem)
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

// register our window messages
const UINT WEM_TRANSFERCOMPLETE = RegisterWindowMessage( TEXT("wem_transfercomplete") );

// the window property to retrieve the CWia pointer
const TCHAR* CWIA_WNDPROP        = TEXT("cwia_ptr");
const TCHAR* CWIA_EVENTWNDCLS    = TEXT("cwia hidden window");

/*-----------------------------------------------------------------------------
 * CWia::CWia
 *
 * This creates a new CWia object. this initializes the variables to a
 * known state so they can do things.
 *--(samclem)-----------------------------------------------------------------*/
CWia::CWia()
    : m_pWiaDevMgr( NULL ), 
      m_pDeviceCollectionCache( NULL ),
      m_hwndEvent(NULL),
      m_pCWiaEventCallback(NULL)
{
    TRACK_OBJECT( "CWia" );
}

/*-----------------------------------------------------------------------------
 * CWia::FinalRelease
 *
 * This is called when we are finally released. this will clear all the
 * pointers that we have and set them to null so that we know they were
 * released.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWia::FinalRelease()
{
    if ( m_hwndEvent )
        DestroyWindow( m_hwndEvent );

    //
    //  Make sure we unregister for WIA Devices.  Note that it is safe to call
    //  unregister multiple times.
    //
    if (m_pCWiaEventCallback)
    {
        m_pCWiaEventCallback->UnRegisterForConnectDisconnect();
        m_pCWiaEventCallback->setOwner(NULL);
        m_pCWiaEventCallback->Release();
    }
    m_pCWiaEventCallback = NULL;


    if ( m_pWiaDevMgr )
        m_pWiaDevMgr->Release();
    m_pWiaDevMgr = NULL;
    if ( m_pDeviceCollectionCache )
        m_pDeviceCollectionCache->Release();
    m_pDeviceCollectionCache = NULL;
}

/*-----------------------------------------------------------------------------
 * CWia::FinalContruct
 *
 * This creates the IWiaDevMgr that we need to perform our work.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWia::FinalConstruct()
{
    HRESULT     hr;
    WNDCLASSEX  wc;

    // first we want to create our hidden event window
    if ( !GetClassInfoEx( _Module.GetModuleInstance(),
                CWIA_EVENTWNDCLS, &wc ) )
        {
        // we need to register this window
        ZeroMemory( &wc, sizeof( wc ) );
        wc.cbSize = sizeof( wc );
        wc.lpszClassName = CWIA_EVENTWNDCLS;
        wc.hInstance = _Module.GetModuleInstance();
        wc.lpfnWndProc = CWia::EventWndProc;

        if ( !RegisterClassEx( &wc ) )
            {
            TraceTag(( tagError, "unable to register window class" ));
            return E_FAIL;
            }
        }

    // now we can create our window
    m_hwndEvent = CreateWindowEx( 0,
            CWIA_EVENTWNDCLS,
            NULL,
            0,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            0,
            0,
            NULL,
            NULL,
            _Module.GetModuleInstance(),
            this );

    if ( !m_hwndEvent )
        {
        TraceTag(( tagError, "Error creating the window" ));
        return E_FAIL;
        }

    hr = THR( CoCreateInstance( CLSID_WiaDevMgr,
                NULL,
                CLSCTX_SERVER,
                IID_IWiaDevMgr,
                reinterpret_cast<void**>(&m_pWiaDevMgr) ) );

    if ( FAILED( hr ) )
        {
        TraceTag(( tagError, "Failed to create WiaDevMgr instance" ));
        return hr;
        }

    /*
     * Setup the event callbacks that this object cares about. we
     * register both connect/disconnect on this object. since the
     * callback tells us the GUID of the event, we can add
     * more logic there.  This is more efficent that having a
     * proxy object which handles the events.
     */
    hr = CComObject<CWiaEventCallback>::CreateInstance(&m_pCWiaEventCallback);
    if (SUCCEEDED(hr))
    {
        m_pCWiaEventCallback->AddRef();
        m_pCWiaEventCallback->setOwner(this);
        hr = m_pCWiaEventCallback->RegisterForConnectDisconnect(m_pWiaDevMgr);
    }
    else
    {
        TraceTag(( tagError, "Failed to create WiaEventCallback instance" ));
        return hr;
    }

    if ( FAILED( hr ) )
        {

        m_pWiaDevMgr->Release();
        m_pWiaDevMgr = NULL;
        }

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWia::_DebugDialog
 *
 * This shows a debugging dialog if you are using the debug build, or simply
 * returns S_OK in the retail build.
 *
 * fWait:   true if we want to wait for the dialog to finish in order to
 *          return. Or false to return immediatly.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWia::_DebugDialog( BOOL fWait )
{

    #if defined(_DEBUG)
    DoTracePointsDialog( fWait );
    #endif //defined(_DEBUG)

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWia::get_Devices
 *
 * This returns a collection of the devices currently connected. this can
 * return an empty collection of there are no devices currently attached.
 *
 * This will cache the collection object that we create. This allows for
 * increased performace since we don't want to recreate it each time, that
 * requires called to an Out-Of-Proc server which is expensive. Therefore
 * since this method is called a lot, we cache the results in:
 *
 *      m_pDeviceCollectionCache
 *
 * ppCol:   out, a point to recieve the collection interface.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CWia::get_Devices( ICollection** ppCol )
{
    HRESULT hr;
    CComObject<CCollection>* pCollection = NULL;
    IEnumWIA_DEV_INFO* pEnum = NULL;
    IWiaPropertyStorage* pWiaStg = NULL;
    IDispatch** rgpDispatch = NULL;
    CComObject<CWiaDeviceInfo>* pDevInfo = NULL;
    unsigned long cDevices = 0;
    unsigned long celtFetched = 0;
    unsigned long iDevice = 0;

    // validate our arguments
    if ( NULL == ppCol )
        return E_POINTER;
    *ppCol = NULL;

    // do we already have a collection cache? if so then we want
    // to use that.
    if ( m_pDeviceCollectionCache )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        return S_OK;
        }

    // first we need an instance of the collection
    hr = THR( CComObject<CCollection>::CreateInstance( &pCollection ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // are we vaild?
    Assert( m_pWiaDevMgr );
    hr = THR( m_pWiaDevMgr->EnumDeviceInfo( WIA_DEVINFO_ENUM_LOCAL, &pEnum ) );
    if ( FAILED(hr) )
        goto Cleanup;

    // we can now enumerate over the device info, if we have them
    // otherwise we don't want to do anything
    hr = THR( pEnum->GetCount( &cDevices ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( cDevices )
        {
        // we need storage for these items
        rgpDispatch = static_cast<IDispatch**>(CoTaskMemAlloc( cDevices * sizeof( IDispatch* ) ));
        if ( !rgpDispatch )
            {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
            }

        ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * cDevices );
        while ( SUCCEEDED( hr ) && hr != S_FALSE )
            {
            // release the old stream if it is hanging around
            if ( pWiaStg )
                pWiaStg->Release();
            pWiaStg = NULL;

            hr = THR( pEnum->Next( 1, &pWiaStg, &celtFetched ) );
            if ( SUCCEEDED( hr ) && hr == S_OK )
                {
                // we got this item successfully, so we need to create
                // a CWiaDeviceInfo and add it to our dispatch array
                Assert( celtFetched == 1 );

                hr = THR( CComObject<CWiaDeviceInfo>::CreateInstance( &pDevInfo ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->AttachTo( pWiaStg, static_cast<IWia*>(this) ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->QueryInterface( IID_IDispatch,
                        reinterpret_cast<void**>(&rgpDispatch[iDevice++]) ) );

                if ( FAILED( hr ) )
                    goto Cleanup;
                }
            }

        if( !pCollection->SetDispatchArray(rgpDispatch, cDevices))
            {
            hr = E_FAIL;
            goto Cleanup;
            }
        }


    // fill the out param with the proper value
    hr = THR( pCollection->QueryInterface( IID_ICollection,
            reinterpret_cast<void**>(&m_pDeviceCollectionCache) ) );

    if ( SUCCEEDED( hr ) )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        }

Cleanup:
    if ( pEnum )
        pEnum->Release();
    if ( pWiaStg )
        pWiaStg->Release();

    if ( FAILED( hr ) )
        {
        if ( m_pDeviceCollectionCache )
            m_pDeviceCollectionCache->Release();
        m_pDeviceCollectionCache = NULL;
        if ( pCollection )
            delete pCollection;
        if ( rgpDispatch )
            {
            for ( unsigned long i = 0; i < cDevices; i++ )
                if ( rgpDispatch[i] )
                    rgpDispatch[i]->Release();
            CoTaskMemFree( rgpDispatch );
            }
        }

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWia::Create             [IWia]
 *
 * The handles creating a device. This will create a dispatch object which
 * can represent the device.
 *
 * This can take several different paramaters to determine what device to
 * create.
 *
 *  VT_UNKNOWN, VT_DISPATCH --> An IWiaDeviceInfo dispatch object which
 *                              holds information about the device.
 *  VT_BSTR                 --> The DeviceID of the device to create
 *  VT_I4                   --> The index of the device in the Devices()
 *                              collection.
 *  VT_xx                   --> Not currently supported.
 *
 *  pvaDevice:  A variant which contains the device to create
 *  ppDevice:   Out, recieves the newly created device object
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWia::Create( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice )
{
    HRESULT hr                  = E_NOTIMPL;
    IWiaDeviceInfo* pDeviceInfo = NULL;
    ICollection* pCollection    = NULL;
    IDispatch* pDispatch        = NULL;
    BSTR bstrDeviceId           = NULL;
    IWiaItem* pWiaItem          = NULL;
    CComObject<CWiaItem>* pItem = NULL;
    CWiaCacheManager* pCache    = CWiaCacheManager::GetInstance();

    if ( !pvaDevice || !ppDevice )
        return E_POINTER;


    //BUG (Aug, 18) samclem:
    //
    // make sure that the variant is the proper type, or at least
    // one that we want to deal with. this isn't perfect and probally
    // be revistied at some point in life. this will miss handle things
    // like:
    //
    //      camera = wiaObject.create( "0" );
    //

    // If nothing was passed in, we end up showing the selection UI.
    // Use an empty BSTR to indicate this. Note that script can also
    // pass an empty string ("") to get the selection UI.
    if ( pvaDevice->vt == VT_EMPTY || pvaDevice->vt == VT_NULL ||
        ( pvaDevice->vt == VT_ERROR && pvaDevice->scode == DISP_E_PARAMNOTFOUND ) )
        {
        pvaDevice->vt = VT_BSTR;
        pvaDevice->bstrVal = NULL;
        }

    if ( pvaDevice->vt != VT_DISPATCH &&
        pvaDevice->vt != VT_UNKNOWN &&
        pvaDevice->vt != VT_BSTR )
        {
        hr = THR( VariantChangeType( pvaDevice, pvaDevice, 0, VT_I4 ) );
        if ( FAILED( hr ) )
            return hr;
        }

    if ( pvaDevice->vt == VT_DISPATCH )
        {
        // pvaDevice->pdispVal == NULL if we're supposed to show WIA's device
        // selection, so only QI if pdispVal is valid.
        if (pvaDevice->pdispVal != NULL)
            {
            hr = THR( pvaDevice->pdispVal->QueryInterface( IID_IWiaDeviceInfo,
                        reinterpret_cast<void**>(&pDeviceInfo) ) );
            if ( FAILED( hr ) )
                goto Cleanup;
            }
        }
    else if ( pvaDevice->vt == VT_UNKNOWN )
        {
        hr = THR( pvaDevice->punkVal->QueryInterface( IID_IWiaDeviceInfo,
                    reinterpret_cast<void**>(&pDeviceInfo) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }
    else if ( pvaDevice->vt == VT_BSTR )
        {
        if ( pvaDevice->bstrVal && *pvaDevice->bstrVal )
            bstrDeviceId = SysAllocString( pvaDevice->bstrVal );
        }
    else if ( pvaDevice->vt == VT_I4 )
        {
        hr = THR( get_Devices( &pCollection ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        // get the item with that index
        hr = THR( pCollection->get_Item( pvaDevice->lVal, &pDispatch ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        // did we get an item, if we didn't then we were out of
        // range in our collection would return a null dispatch
        //BUG (Aug, 18) samclem:  Perhaps CCollection::get_Item() should
        // return false in this case.
        if ( !pDispatch )
            goto Cleanup;

        hr = THR( pDispatch->QueryInterface( IID_IWiaDeviceInfo,
                    reinterpret_cast<void**>(&pDeviceInfo) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }
    else
        goto Cleanup;

    // if we have a valid IWiaDeviceInfo then we can query that for
    // the bstr to create.
    if ( pDeviceInfo )
        {
        hr = THR( pDeviceInfo->get_Id( &bstrDeviceId ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }

    // either we call CreateDevice from the WIA device manager, or we
    // bring up WIA's device selection UI to return a IWiaItem interface.
    if (bstrDeviceId != NULL)
        {
        if ( !pCache->GetDevice( bstrDeviceId, &pWiaItem ) )
            {
            // at this point we should have a valid device id to create
            // our device from
            hr = THR( m_pWiaDevMgr->CreateDevice( bstrDeviceId, &pWiaItem ) );
            if ( FAILED( hr ) )
                goto Cleanup;
            }
        }
    else
        {
        // bring up the selection UI
        hr = THR( m_pWiaDevMgr->SelectDeviceDlg(NULL,
                                                0,
                                                0,
                                                &bstrDeviceId,
                                                &pWiaItem ) );
        // have to check against S_OK since cancel produces S_FALSE
        if ( hr != S_OK )
            goto Cleanup;
        }

    // add our created device to our cache so that we don't have
    // to create it again.
    // NOTE: We effectively disable the  device list cache 
    // by not adding the device here.  The cache doesn't really buy us
    // anything since the driver caches thumbnails, and you shouldn't cache
    // devices, so we simply ignore it here.
    //pCache->AddDevice( bstrDeviceId, pWiaItem );

    hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->AttachTo( this, pWiaItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->QueryInterface( IID_IDispatch,
            reinterpret_cast<void**>(ppDevice) ) );

Cleanup:
    if ( pItem && FAILED( hr ) )
        delete pItem;
    if ( pDispatch )
        pDispatch->Release();
    if ( pWiaItem )
        pWiaItem->Release();
    if ( pDeviceInfo )
        pDeviceInfo->Release();
    if ( pCollection )
        pCollection->Release();
    if ( bstrDeviceId )
        SysFreeString( bstrDeviceId );

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWia::ImageEventCallback [IWiaEventCallback]
 *
 * This is called by Wia when something interesting happens. this is used to
 * fire these events off to scripting for them to do do something.
 *
 * pEventGUID:              the GUID of the event which happend
 * bstrEventDescription:    A string description of the event?? [not in docs]
 * bstrDeviceID:            The device id of the device?? [not in docs]
 * bstrDeviceDescription:   The description of the device?? [nid]
 * dwDeviceType:            ?? [nid]
 * pulEventType:            ?? [nid]
 * Reserved:                Reserved (0)
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CWia::ImageEventCallback( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved )
{
    #if _DEBUG
    USES_CONVERSION;
    #endif

    if ( m_pDeviceCollectionCache )
        {
        m_pDeviceCollectionCache->Release();
        m_pDeviceCollectionCache = NULL;
        }

    // we are listening to both connections, and disconnections so we need
    // to decice what is happening
    //TODO: we want to handle these using the window message not by directly
    // sending them through here.
    if ( *pEventGUID == WIA_EVENT_DEVICE_CONNECTED )
        {
        TraceTag((0, "firing event connected: %s", OLE2A( bstrDeviceID )));
        Fire_OnDeviceConnected( bstrDeviceID );
        }
    else if ( *pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED )
        {
        TraceTag((0, "firing event disconnected: %s", OLE2A( bstrDeviceID )));
        CWiaCacheManager::GetInstance()->RemoveDevice( bstrDeviceID );
        Fire_OnDeviceDisconnected( bstrDeviceID );
        }
    else
        {
        TraceTag((0, "ImageEventCallback -> unexpected event type" ) );
        return E_UNEXPECTED;
        }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWia::EventWndProc
 *
 * This is the window proc that is used for the hidden window which
 * handles posting the events.  This recieves messages that should be posted
 * back to the client. This ensures that the notifications get posted back
 * from the expected thread.
 *--(samclem)-----------------------------------------------------------------*/
LRESULT CALLBACK CWia::EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    CWia* pWia = reinterpret_cast<CWia*>(GetProp( hwnd, CWIA_WNDPROP ));

    switch ( iMsg )
        {
    case WM_CREATE:
        {
        LPCREATESTRUCT pcs = reinterpret_cast<LPCREATESTRUCT>(lParam);
        pWia = reinterpret_cast<CWia*>(pcs->lpCreateParams);
        if ( !pWia )
            return -1;
        if ( !SetProp( hwnd, CWIA_WNDPROP, reinterpret_cast<HANDLE>(pWia) ) )
            return -1;
        }
        return 0;

    case WM_DESTROY:
        {
        if ( pWia )
            RemoveProp( hwnd, CWIA_WNDPROP );
        }
        return 0;
        }

    // since our custom window messages are obtained using
    // RegisterWindowMessage(), they are not constant and therfore
    // can't be processed in a switch() statement.
    if ( WEM_TRANSFERCOMPLETE == iMsg )
        {
        if ( pWia )
            {
            TraceTag((0, "EventWndProc - firing onTransferComplete"));
            pWia->Fire_OnTransferComplete(
                    reinterpret_cast<IDispatch*>(wParam),
                    reinterpret_cast<BSTR>(lParam) );
            }
        if ( lParam ) 
            {
            SysFreeString(reinterpret_cast<BSTR>(lParam));
            lParam = 0;
            }
        return 0;
        }

    return DefWindowProc( hwnd, iMsg, wParam, lParam );
}

/*
 *
 *
 */

CSafeWia::CSafeWia() :
    m_pWiaDevMgr( NULL ),
    m_pWiaDevConEvent( NULL ),
    m_pWiaDevDisEvent( NULL ),
    m_pDeviceCollectionCache( NULL ),
    m_SafeInstance(TRUE)
{

    TRACK_OBJECT( "CSafeWia" );
}

STDMETHODIMP_(void)
CSafeWia::FinalRelease()
{
    if ( m_hwndEvent )
        DestroyWindow( m_hwndEvent );

    if ( m_pWiaDevMgr )
        m_pWiaDevMgr->Release();
    m_pWiaDevMgr = NULL;
    if ( m_pWiaDevConEvent )
        m_pWiaDevConEvent->Release();
    m_pWiaDevConEvent = NULL;
    if ( m_pWiaDevDisEvent )
        m_pWiaDevDisEvent->Release();
    m_pWiaDevDisEvent = NULL;
    if ( m_pDeviceCollectionCache )
        m_pDeviceCollectionCache->Release();
    m_pDeviceCollectionCache = NULL;
}

/*-----------------------------------------------------------------------------
 * CSafeWia::FinalContruct
 *
 * This creates the IWiaDevMgr that we need to perform our work.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CSafeWia::FinalConstruct()
{
    HRESULT     hr;

    hr = THR( CoCreateInstance( CLSID_WiaDevMgr,
                NULL,
                CLSCTX_SERVER,
                IID_IWiaDevMgr,
                reinterpret_cast<void**>(&m_pWiaDevMgr) ) );

    if ( FAILED( hr ) )
        {
        TraceTag(( tagError, "Failed to create WiaDevMgr instance" ));
        return hr;
        }

    if ( FAILED( hr ) )
        {
        if ( m_pWiaDevConEvent )
            m_pWiaDevConEvent->Release();
        m_pWiaDevConEvent = NULL;
        if ( m_pWiaDevDisEvent )
            m_pWiaDevDisEvent->Release();
        m_pWiaDevDisEvent = NULL;

        m_pWiaDevMgr->Release();
        m_pWiaDevMgr = NULL;
        }

    return hr;
}

/*-----------------------------------------------------------------------------
 * CSafeWia::_DebugDialog
 *
 * This shows a debugging dialog if you are using the debug build, or simply
 * returns S_OK in the retail build.
 *
 * fWait:   true if we want to wait for the dialog to finish in order to
 *          return. Or false to return immediatly.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CSafeWia::_DebugDialog( BOOL fWait )
{
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CSafeWia::get_Devices
 *
 * This returns a collection of the devices currently connected. this can
 * return an empty collection of there are no devices currently attached.
 *
 * This will cache the collection object that we create. This allows for
 * increased performace since we don't want to recreate it each time, that
 * requires called to an Out-Of-Proc server which is expensive. Therefore
 * since this method is called a lot, we cache the results in:
 *
 *      m_pDeviceCollectionCache
 *
 * ppCol:   out, a point to recieve the collection interface.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CSafeWia::get_Devices( ICollection** ppCol )
{
    HRESULT hr;
    CComObject<CCollection>* pCollection = NULL;
    IEnumWIA_DEV_INFO* pEnum = NULL;
    IWiaPropertyStorage* pWiaStg = NULL;
    IDispatch** rgpDispatch = NULL;
    CComObject<CWiaDeviceInfo>* pDevInfo = NULL;
    unsigned long cDevices = 0;
    unsigned long celtFetched = 0;
    unsigned long iDevice = 0;

    // validate our arguments
    if ( NULL == ppCol )
        return E_POINTER;
    *ppCol = NULL;

    // do we already have a collection cache? if so then we want
    // to use that.
    if ( m_pDeviceCollectionCache )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        return S_OK;
        }

    // first we need an instance of the collection
    hr = THR( CComObject<CCollection>::CreateInstance( &pCollection ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // are we vaild?
    Assert( m_pWiaDevMgr );
    hr = THR( m_pWiaDevMgr->EnumDeviceInfo( WIA_DEVINFO_ENUM_LOCAL, &pEnum ) );
    if ( FAILED(hr) )
        goto Cleanup;

    // we can now enumerate over the device info, if we have them
    // otherwise we don't want to do anything
    hr = THR( pEnum->GetCount( &cDevices ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( cDevices )
        {
        // we need storage for these items
        rgpDispatch = static_cast<IDispatch**>(CoTaskMemAlloc( cDevices * sizeof( IDispatch* ) ));
        if ( !rgpDispatch )
            {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
            }

        ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * cDevices );
        while ( SUCCEEDED( hr ) && hr != S_FALSE )
            {
            // release the old stream if it is hanging around
            if ( pWiaStg )
                pWiaStg->Release();

            hr = THR( pEnum->Next( 1, &pWiaStg, &celtFetched ) );
            if ( SUCCEEDED( hr ) && hr == S_OK )
                {
                // we got this item successfully, so we need to create
                // a CWiaDeviceInfo and add it to our dispatch array
                Assert( celtFetched == 1 );

                hr = THR( CComObject<CWiaDeviceInfo>::CreateInstance( &pDevInfo ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->AttachTo( pWiaStg, static_cast<IWia*>(this) ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->QueryInterface( IID_IDispatch,
                        reinterpret_cast<void**>(&rgpDispatch[iDevice++]) ) );

                if ( FAILED( hr ) )
                    goto Cleanup;
                }
            }

        if( !pCollection->SetDispatchArray(rgpDispatch, cDevices))
            {
            hr = E_FAIL;
            goto Cleanup;
            }
        }


    // fill the out param with the proper value
    hr = THR( pCollection->QueryInterface( IID_ICollection,
            reinterpret_cast<void**>(&m_pDeviceCollectionCache) ) );

    if ( SUCCEEDED( hr ) )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        }

Cleanup:
    if ( pEnum )
        pEnum->Release();
    if ( pWiaStg )
        pWiaStg->Release();

    if ( FAILED( hr ) )
        {
        if ( m_pDeviceCollectionCache )
            m_pDeviceCollectionCache->Release();
        m_pDeviceCollectionCache = NULL;
        if ( pCollection )
            delete pCollection;
        if ( rgpDispatch )
            {
            for ( unsigned long i = 0; i < cDevices; i++ )
                if ( rgpDispatch[i] )
                    rgpDispatch[i]->Release();
            CoTaskMemFree( rgpDispatch );
            }
        }

    return hr;
}

STDMETHODIMP
CSafeWia::Create( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice )
{
    HRESULT hr                  = E_NOTIMPL;

    #ifdef MAXDEBUG
    ::OutputDebugString(TEXT("WIA script object: CSafeWia::Create rejected\n\r "));
    #endif

    return hr;

}

STDMETHODIMP
CSafeWia::ImageEventCallback( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved )
{
    return S_OK;
}

LRESULT CALLBACK CSafeWia::EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc( hwnd, iMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\cwia.h ===
/*-----------------------------------------------------------------------------
 *
 * File:    Wia.h
 * Author:  Samuel Clement (samclem)
 * Date:    Thu Aug 12 11:29:07 1999
 * Description:
 *  Declares the CWia class which wraps an IWiaDevMgr with a IDispatch
 *  interface.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * History:
 *  12 Aug 1999:        Created. (samclem)
 *  27 Aug 1999:        Added, _DebugDialog for debugging only
 *----------------------------------------------------------------------------*/

#ifndef __WIA_H_
#define __WIA_H_

#include "resource.h"       // main symbols
#include "wiaeventscp.h"
#include "wiaeventscp.h"

// windows event messages

// signals a transfer complete, wParam = IDispatch*, lParam = BSTR
extern const UINT WEM_TRANSFERCOMPLETE;

class CWiaEventCallback;

/*-----------------------------------------------------------------------------
 *
 * Class:       CWia
 * Synopsis:    Exposes the functionality of the IWiaDevMgr using IDispatch
 *
 *---------------------------------------------------------------------------*/

class ATL_NO_VTABLE CWia :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWia, &CLSID_Wia>,
    public IDispatchImpl<IWia, &IID_IWia, &LIBID_WIALib>,
    public IObjectSafetyImpl<CWia, 0 /*INTERFACESAFE_FOR_UNTRUSTED_CALLER*/>,
    /*public IWiaEventCallback,*/
    public CProxy_IWiaEvents< CWia >,
    public IConnectionPointContainerImpl<CWia>,
    public IProvideClassInfo2Impl<&CLSID_Wia, &DIID__IWiaEvents, &LIBID_WIALib>
{
public:
    CWia();

    DECLARE_TRACKED_OBJECT
    DECLARE_REGISTRY_RESOURCEID(IDR_WIA)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWia)
        COM_INTERFACE_ENTRY(IWia)
        COM_INTERFACE_ENTRY(IDispatch)
        //COM_INTERFACE_ENTRY(IWiaEventCallback)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CWia)
        CONNECTION_POINT_ENTRY(DIID__IWiaEvents)
    END_CONNECTION_POINT_MAP()

    STDMETHOD(FinalConstruct)();
    STDMETHOD_(void, FinalRelease)();

    // event methods
    inline LRESULT SendEventMessage( UINT iMsg, WPARAM wParam, LPARAM lParam )
        { return PostMessage( m_hwndEvent, iMsg, wParam, lParam ); }

    // IWia
    public:
    STDMETHOD(_DebugDialog)( BOOL fWait );
    STDMETHOD(get_Devices)( ICollection** ppCol );
    STDMETHOD(Create)( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice );

    // IWiaEventCallback
    STDMETHOD(ImageEventCallback)( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                                   BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved );

protected:
    IWiaDevMgr*     m_pWiaDevMgr;
    ICollection*    m_pDeviceCollectionCache;
    HWND            m_hwndEvent;
    CComObject<CWiaEventCallback>    *m_pCWiaEventCallback;

    // event window proc
    static LRESULT CALLBACK EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

private:

};

/*-----------------------------------------------------------------------------
 *
 * Class:       CWiaEventCallback
 * Synopsis:    Exposes the functionality of the IWiaEventCallback interface
 *              used by the CWia object to receive notifications of 
 *              device arrival/removals.
 *
 *---------------------------------------------------------------------------*/

class ATL_NO_VTABLE CWiaEventCallback : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public IWiaEventCallback
{
public:
    BEGIN_COM_MAP(CWiaEventCallback)
        COM_INTERFACE_ENTRY(IWiaEventCallback)
    END_COM_MAP()

    STDMETHOD(FinalConstruct)()
    {
        m_pCWia            = NULL; 
        m_pWiaDevConCookie = NULL;
        m_pWiaDevDisCookie = NULL;

        return S_OK;
    }

    STDMETHOD_(void, FinalRelease)()
    {
    }

    //
    //  This method is used to store a pointer to the owning CWia object.  When the owning CWia object is going
    //  away (i.e. in FinalRelease()), it should call this method with NULL.
    //  Note that this method is used because the owning CWia object cannot be AddRef'd/Release'd like normal
    //  due to the circular reference it introduces.
    //
    VOID setOwner(CWia *pCWia)
    {
        m_pCWia = pCWia;
    }

    //
    //  Register this interface for run-time event notifications.  Specifically,
    //  we are interested in WIA_EVENT_DEVICE_CONNECTED and WIA_EVENT_DEVICE_DISCONNECTED.
    //
    HRESULT RegisterForConnectDisconnect(IWiaDevMgr *pWiaDevMgr)
    {
        HRESULT hr = S_OK;
        if (pWiaDevMgr)
        {
            IUnknown*       pWiaDevConCookie = NULL;
            IUnknown*       pWiaDevDisCookie = NULL;

            //
            //  Register for connect events
            //
            hr = pWiaDevMgr->RegisterEventCallbackInterface(
                        WIA_REGISTER_EVENT_CALLBACK,
                        NULL,
                        &WIA_EVENT_DEVICE_CONNECTED,
                        static_cast<IWiaEventCallback*>(this),
                        &pWiaDevConCookie);
            if (hr == S_OK)
            {
                //
                //  Save the registration cookie for the connect events
                //
                m_pWiaDevConCookie = pWiaDevConCookie;

                //
                //  Register for disconnect events
                //
                hr = pWiaDevMgr->RegisterEventCallbackInterface(
                            WIA_REGISTER_EVENT_CALLBACK,
                            NULL,
                            &WIA_EVENT_DEVICE_DISCONNECTED,
                            static_cast<IWiaEventCallback*>(this),
                            &pWiaDevDisCookie);
                if (hr == S_OK)
                {
                    //
                    //  Save the rregistration cookie for the disconnect events
                    //
                    m_pWiaDevDisCookie = pWiaDevDisCookie;
                } 
                else
                {
                    hr = E_UNEXPECTED;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_POINTER;
        }

        return hr;
    }

    //
    //  Ensures that this object is no longer registered for events.  Note that you may safely
    //  call this method multiple times within the lifetime of this object.
    //
    VOID UnRegisterForConnectDisconnect()
    {
        if (m_pWiaDevConCookie)
        {
            m_pWiaDevConCookie->Release();
        }
        m_pWiaDevConCookie = NULL;
        if (m_pWiaDevDisCookie)
        {
            m_pWiaDevDisCookie->Release();
        }
        m_pWiaDevDisCookie = NULL;
    }

    //
    //  This is called by Wia when something interesting happens. We simply pass this to the owning 
    //  CWia object to fire these events off to scripting for them to do do something.
    //
    HRESULT STDMETHODCALLTYPE ImageEventCallback(const GUID *pEventGUID, BSTR bstrEventDescription, BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType, BSTR bstrFullItemName, ULONG *pulEventType, ULONG ulReserved)
    {
        if (m_pCWia)
        {
            HRESULT hr = m_pCWia->ImageEventCallback(pEventGUID, bstrEventDescription, bstrDeviceID, bstrDeviceDescription, dwDeviceType, bstrFullItemName, pulEventType, ulReserved);
        }
        return S_OK;
    }

private:
    CWia*           m_pCWia;
    IUnknown*       m_pWiaDevConCookie;
    IUnknown*       m_pWiaDevDisCookie;
};



//
//  Separate "safe" class wrapper
//

class ATL_NO_VTABLE CSafeWia :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSafeWia, &CLSID_SafeWia>,
    public IDispatchImpl<IWia, &IID_IWia, &LIBID_WIALib>,
    public IObjectSafetyImpl<CSafeWia, INTERFACESAFE_FOR_UNTRUSTED_CALLER >,
    public CProxy_IWiaEvents< CSafeWia >,
    public IConnectionPointContainerImpl<CSafeWia>,
    public IProvideClassInfo2Impl<&CLSID_SafeWia, &DIID__IWiaEvents, &LIBID_WIALib>
{
public:
    CSafeWia();

    DECLARE_TRACKED_OBJECT
    DECLARE_REGISTRY_RESOURCEID(IDR_WIA)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSafeWia)
        COM_INTERFACE_ENTRY(IWia)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CATEGORY_MAP(CSafeWia)
        IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
        IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    END_CATEGORY_MAP()

    BEGIN_CONNECTION_POINT_MAP(CSafeWia)
        CONNECTION_POINT_ENTRY(DIID__IWiaEvents)
    END_CONNECTION_POINT_MAP()

    STDMETHOD(FinalConstruct)();
    STDMETHOD_(void, FinalRelease)();

    // event methods
    inline LRESULT SendEventMessage( UINT iMsg, WPARAM wParam, LPARAM lParam )
        { return PostMessage( m_hwndEvent, iMsg, wParam, lParam ); }

    // IWia
    public:
    STDMETHOD(_DebugDialog)( BOOL fWait );
    STDMETHOD(get_Devices)( ICollection** ppCol );
    STDMETHOD(Create)( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice );

    // Used to process IWiaEventCallback::ImageEventCallback messages from a CWiaEventCallback object
    STDMETHOD(ImageEventCallback)( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                                   BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved );

protected:
    IWiaDevMgr*     m_pWiaDevMgr;
    IUnknown*       m_pWiaDevConEvent;
    IUnknown*       m_pWiaDevDisEvent;
    ICollection*    m_pDeviceCollectionCache;
    HWND            m_hwndEvent;

    // Flag indicating whether current instance is safe , i.e. all methods should check
    // access rights
    BOOL            m_SafeInstance;

    // event window proc
    static LRESULT CALLBACK EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

private:

    BOOL            IsAllowed(HRESULT *phr)
    {
        BOOL    bRet = FALSE;

        *phr = E_FAIL;

        if (m_SafeInstance) {
            // BUGBUG Placeholder for strict access rights checks, based on client site
            // security zone. For now return FALSE always
            *phr = E_ACCESSDENIED;
            bRet =  FALSE;
        }
        else {
            *phr = S_OK;
            bRet = TRUE;
        }

        return bRet;
    }

};

#endif //__WIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\hfdebug.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    hfdebug.h

    Debugging stuff for use in Hyperfine.  See core/debug/hfdebug.txt for more
    information.

*******************************************************************************/

#ifndef _HFDEBUG_H_
#define _HFDEBUG_H_

#include "crtdbg.h"
#include <stdio.h>

//+-------------------------------------------------------------------------
//
//  VC 5 compiler requires these templates to be outside of extern C
//
//--------------------------------------------------------------------------

#if _DEBUG
    template <class t> inline t
    TraceFail(t errExpr, int errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
    {
        return (t) TraceFailL((long) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
    }

    template <class t, class v> inline t
    TraceWin32(t errExpr, v errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
    {
        return (t) TraceWin32L((long) errExpr, (long)errTest, fIgnore, pstrExpr, pstrFile, line);
    }
#endif

#ifdef __cplusplus
extern "C"
{
#endif


//--------------------------------------------------------------------------
// Assert & Verify
//--------------------------------------------------------------------------

#define Assert(x)
#define Verify(x)   x
#define StartupAssert(x)

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

typedef int TAG;

#define TraceTag(x)
#define TraceTagEx(x)
#define TraceCallers(tag, iStart, cTotal)
#define DeclareTag(tag, szOwner, szDescription)
#define DeclareTagOther(tag, szOwner, szDescription)

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#define BEGIN_LEAK
#define END_LEAK

#define SET_ALLOC_HOOK
#define DUMPMEMORYLEAKS

#define DbgPreAlloc(cb)             cb
#define DbgPostAlloc(pv)            pv
#define DbgPreFree(pv)              pv
#define DbgPostFree()
#define DbgPreRealloc(pv, cb, ppv)  cb
#define DbgPostRealloc(pv)          pv
#define DbgPreGetSize(pv)           pv
#define DbgPostGetSize(cb)          cb
#define DbgPreDidAlloc(pv)          pv
#define DbgPostDidAlloc(pv, fAct)   fAct
#define DbgRegisterMallocSpy()
#define DbgRevokeMallocSpy()
#define DbgMemoryTrackDisable(fb)

//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#define WATCHINTERFACE(iid, p, pstr)  (p)

//--------------------------------------------------------------------------
// Miscelleanous
//--------------------------------------------------------------------------

#define RESTOREDEFAULTDEBUGSTATE
#define DebugCode(block) // Nothing

//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#define TFAIL(x, e)             (x)
#define TW32(x, e)              (x)
#define THR(x)                  (x)

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (x)
#define IGNORE_W32(e,x)         (x)
#define IGNORE_HR(x)            (x)

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#define SRETURN(hr)                 return (hr)
#define RRETURN(hr)                 return (hr)
#define RRETURN1(hr, s1)            return (hr)
#define RRETURN2(hr, s1, s2)        return (hr)
#define RRETURN3(hr, s1, s2, s3)    return (hr)

#define SRETURN_NOTRACE(hr)                 return (hr)
#define RRETURN_NOTRACE(hr)                 return (hr)
#define RRETURN1_NOTRACE(hr, s1)            return (hr)
#define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
#define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)

//+-------------------------------------------------------------------------
//  Debug view
//--------------------------------------------------------------------------

void DebugView(HWND hwndOwner, IUnknown *pUnk);

#ifdef __cplusplus
}
#endif


//+-------------------------------------------------------------------------
//  Object Tracker stuff
//--------------------------------------------------------------------------

#define DUMPTRACKEDOBJECTS
#define DECLARE_TRACKED_OBJECT
#define TRACK_OBJECT(_x_)

/*    class __declspec( dllexport) CObjectCheck
    {
        CObjectCheck(void) {};
        ~CObjectCheck(void) {};
	
        void Append(void * pv) {};
    };*/

#endif // _HFDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\ifaccach.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	ifaccach.h
 * Author:	Samuel Clement (samclem)
 * Date:	Wed Sep 01 14:36:33 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 * 	This contains the declarations of the templated interface caching
 * 	objects. These are local objects which have a referance count.
 *
 * 	Usage:	CInterfaceCache<string,IUnknown>* pUnkCache;
 *			pFoo = pFooCache->GetFromCache( "foo" );
 *			if ( pFoo )
 * 				pUnkCache->AddToCache( "foo", pFoo );
 *
 * History:
 * 	01 Sep 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _IFACCACH_H_
#define _IFACCACH_H_

template<class K, class T>
class CInterfaceCache 
{
public:
	DECLARE_TRACKED_OBJECT
		
	CInterfaceCache() : m_cRefs( 0 )
	{
		TRACK_OBJECT("CInterfaceCache");
	}

	~CInterfaceCache()
	{
		// we need to release all our interfaces by
		// iterating over our map.
		CCacheEntry* pEntry;
		CCacheMap::iterator it = m_cacheMap.begin();
		for ( ; it != m_cacheMap.end(); it++ )
		{
			pEntry = it->second;
			Assert( pEntry != NULL );
			delete pEntry;
		}

		// clear the map so its empty
		m_cacheMap.clear();
	}

	inline bool HasRefs() { return ( m_cRefs > 0 ); }
	inline void AddRef() { m_cRefs++; TraceTag((0, "CInterfaceCahe: addref: %ld", m_cRefs )); }
	inline void Release() { m_cRefs--; TraceTag((0, "CInterfaceCahe: release: %ld", m_cRefs )); }
	
	// returns the cached pointer, non-AddRef'd
	// if the caller wants to hold it then they
	// need to AddRef it.
	inline T* GetFromCache( K key )
	{
		CCacheEntry* pEntry = m_cacheMap[key];
		if ( !pEntry )
			return NULL;
		else
			return reinterpret_cast<T*>(pEntry->GetCOMPtr());
	}

	// Adds the pointer to the map. IF the key
	// already exists then this will simply overwrite
	// that one, freeing the existing one
	inline bool AddToCache( K key, T* pT )
	{
		Assert( pT != NULL );

		RemoveFromCache( key );
		CCacheEntry* pEntry = new CCacheEntry( reinterpret_cast<IUnknown*>(pT) );
		if ( !pEntry )
			return false;
		m_cacheMap[key] = pEntry;

		return true;
	}

	// remove the specified key from the cache, returns true if it
	// was there or false if it was not
	inline bool RemoveFromCache( const K& key )
	{
		CCacheEntry* pEntry = m_cacheMap[key];
		if ( pEntry )
			delete pEntry;

		return ( m_cacheMap.erase( key ) != 0 );
	}

private:
	class CCacheEntry
	{
	public:
		CCacheEntry( IUnknown* pif ) : m_pInterface( pif )
		{
			// add a referance, this forces the interface to
			// live for the duration of our lifetime. we we are
			// destroyed we will release the last referance on
			// the interface. 
			Assert( m_pInterface );
			m_pInterface->AddRef();
		}

		~CCacheEntry()
		{
			m_pInterface->Release();
			m_pInterface = NULL;
		}

		inline IUnknown* GetCOMPtr() { return m_pInterface; }
		
	private:
		IUnknown*	m_pInterface;
	};

private:
	typedef std::map<K,CCacheEntry*> CCacheMap;

	CCacheMap	m_cacheMap;
	long		m_cRefs;
};

#endif //_IFACCACH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiascr.rc
//
#define IDS_PROJNAME                    100
#define IDR_WIA                         103
#define IDR_WIAPROTOCOL                 104
#define IDR_SAFEWIA                     105


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\sources.inc ===
#
# Copyright (C) Microsoft Corporation, 2000
#
# Module Name:
#
#    sources.inc
#

!include $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=ndm
MINORCOMP=wia

TARGETNAME=wiascr
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)


#
# Build UNICODE or not?
#
#C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE

USE_STATIC_ATL=1
ATL_VER=30
USE_STL=1

DLLENTRY=_DllMainCRTStartup
DLLDEF = ..\$(TARGETNAME).def

TARGETLIBS= \
    $(TARGETLIBS)                                                         \
    $(SDK_LIB_PATH)\wiaguid.lib

SOURCES =\
    cwia.cpp            \
    wiacache.cpp        \
    wiadevinf.cpp       \
    wiaitem.cpp         \
    wiaproto.cpp        \
    wiautil.cpp         \
    $(TARGETNAME).rc    \
    $(TARGETNAME).cpp   \
    collect.cpp

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_OBJ = precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\stdafx.h ===
//
// stdafx.h : include file for standard system include files,
//            or project specific include files that are used frequently,
//            but are changed infrequently

#if !defined(AFX_STDAFX_H_DF73D7B3)
#define AFX_STDAFX_H_DF73D7B3

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

// Turn off ATL tracing
#if _DEBUG
#ifdef ATLTRACE
#undef ATLTRACE
#endif
#define ATLTRACE
#define ATLTRACE2
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <map>
#include <mshtml.h>
#include <exdisp.h>
#include <mshtmhst.h>
#include <mshtmdid.h>
#include <wininet.h>
#include "sti.h"
#include "wia.h"
#include "wiadef.h"

#include "hfdebug.h"
#include "wiascr.h"
#include "ifaccach.h"
#include "wiautil.h"
#include "resource.h"

// Objects
#include "collect.h"

// Wia Objects
#include "cwia.h"
#include "wiadevinf.h"
#include "wiaitem.h"
#include "wiaproto.h"
#include "wiacache.h"


#endif // !defined(AFX_STDAFX_H_DF73D7B3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiacache.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiacache.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Thu Sep 09 16:15:11 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 *
 * This contains the implementation of the CWiaCacheManager. Which handles
 * managing items/data that we want to cache for performance reasons
 *
 * History:
 * 	09 Sep 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

DeclareTag( tagWiaCache, "!WiaCache", "Wia cache debug information" );

CWiaCacheManager* CWiaCacheManager::sm_pManagerInstance = NULL;

/*-----------------------------------------------------------------------------
 * CWiaCacheManager
 *
 * This creates a new CWiaCacheManager object. This simply initalizes all 
 * the variables to a known state. Initialize handles actually creating
 * the objects that we need.
 *--(samclem)-----------------------------------------------------------------*/
CWiaCacheManager::CWiaCacheManager() : m_hThumbHeap( 0 )
{
	TraceTag((0,"** Creating WiaCache" ));
	TRACK_OBJECT( "CWiaCacheManager - SINGLETON" );
}

/*-----------------------------------------------------------------------------
 * ~CWiaCacheManager
 *
 * This destroyes the CWiaCacheManager object. This will handle taking all
 * the memory it has away with it. including any thumbnail memory we might be
 * carrying around.
 *--(samclem)-----------------------------------------------------------------*/
CWiaCacheManager::~CWiaCacheManager()
{
	TraceTag((0, "** Destroying WiaCache" ));

	// Destroying the heap will free any memory
	// allocated by the heap, so this will keep us
	// from leaking
	if ( m_hThumbHeap )
	{
		HeapDestroy( m_hThumbHeap );
		m_hThumbHeap = 0;
	}

	// destroy our critical section
	DeleteCriticalSection( &m_cs );
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::Initialize
 *
 * This is called following a call to new in order to get this object ready
 * to use. Without calling this the cache manager will be unusable.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::Initialize()
{
	SYSTEM_INFO si;
	
	// initialize our critical section
    __try {
        if(!InitializeCriticalSectionAndSpinCount( &m_cs, MINLONG )) {
            return false;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return false;
    }

	// we need to create the heap we are going to allocate
	// out thumbnail memory from
	GetSystemInfo( &si );
	m_hThumbHeap = TW32( HeapCreate( HEAP_NO_SERIALIZE, si.dwPageSize, 0 ), HANDLE(0) );
	
	return ( m_hThumbHeap != 0 );
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::GetDevice
 *
 * This returns a cached pointer to the device. This returns true if the 
 * device was found, (and the out param is valid) or false if we didn't
 * find it.  Example:
 *
 * 		CWiaCacheManager* pCache = CWiaCacheManager::GetInstance();
 * 		IWiaItem* pItem = NULL;
 * 		
 * 		if ( pCache->GetDevice( bstrId, &pItem ) )
 * 		{
 * 			// use pItem
 * 			.
 * 			.
 * 			pItem->Release();
 * 		}
 * 		else
 * 		{
 * 			// create pItem and use
 * 			.
 * 			.
 * 			pCache->AddDevice( bstrId, pItem );
 * 			pItem->Release();
 * 		}
 *
 * bstrId:		the id of the device that we want.
 * ppDevice:	Out, recieves the cached device pointer.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::GetDevice( CComBSTR bstrId, IWiaItem** ppDevice )
{
    return FALSE;

    //
    // NOTE: We've effectively disabled the device cache by always returning
    // FALSE here and not calling AddDevice anywhere else.
    //
    /*
	bool fRet = true;
	Assert( ppDevice );

	// our member class does most of the work for us, however we need
	// to ensure that we are thread safe
	Lock();
	*ppDevice = m_icItemCache.GetFromCache( bstrId );
	Unlock();
	if ( !(*ppDevice) )
		fRet = false;
	else
		(*ppDevice)->AddRef();
	
	return fRet;
    */
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::AddDevice
 *
 * This adds a device item pointer to the cache. See GetDevice() for an
 * complete example. Returns true if we successfully added the device
 *
 * bstrId:		the ID of the new device to add
 * pDevice:		The pointer to add to the cache
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::AddDevice( CComBSTR bstrId, IWiaItem* pDevice )
{
	bool fRet = true;
	
	Assert( pDevice );

	// again our member class does a majority of the work so all we
	// need to do is to call through.  However, we make sure that
	// we are thread safe when we do that
	Lock();
	fRet = m_icItemCache.AddToCache( bstrId, pDevice );
	Unlock();

	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::RemoveDevice
 *
 * This removes a device from the cache.  This returns true of the item
 * was found in the cache, or false if it was not.
 *
 * bstrId:		the ID of the device to remove from the cache
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::RemoveDevice( CComBSTR bstrId )
{
	bool fRet 		= false;
	
	Lock();
	// remove the item from the cache
	fRet = m_icItemCache.RemoveFromCache( bstrId );
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::GetThumbnail
 * 
 * This attempts to get a thumbnail from the cache.  There might not
 * be one there, in which case this simply returns 'false'
 *
 * bstrFullItemName:	the name of the item we want the thumb for
 * ppbThumb:			Out, pointer to the thumbnail bites
 * pcbThumb:			Out, recieves the size of the thumbnail
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::GetThumbnail( CComBSTR bstrFullItemName, BYTE** ppbThumb, DWORD* pcbThumb )
{
	bool fRet = false;
	THUMBNAILCACHEITEM* ptci = 0;
	
	Assert( ppbThumb && pcbThumb );

	*ppbThumb = 0;
	*pcbThumb = 0;
	
	Lock();
	ptci = m_tcThumbnails[bstrFullItemName];
	if ( ptci )
	{
		*ppbThumb = ptci->pbThumb;
		*pcbThumb = ptci->cbThumb;
		fRet = true;
	}
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::AddThumbnail
 *
 * This attempts to add a thumbnail to the cache. this will return true
 * if the item was successfully added or false if it failed.
 *
 * bstrFullItemName:	the name of the item to cache the thumb for
 * pbThumb:				Pointer to the thumbnail memory
 * cbThumb:				the number of bytes in the thumbnail.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::AddThumbnail( CComBSTR bstrFullItemName, BYTE* pbThumb, DWORD cbThumb )
{
	bool fRet = false;
	THUMBNAILCACHEITEM* ptci = 0;
	
	Assert( pbThumb && cbThumb );
	Assert( m_hThumbHeap && "Need a valid thumbnail heap" );
	RemoveThumbnail( bstrFullItemName );

	Lock();
	ptci = reinterpret_cast<THUMBNAILCACHEITEM*>(TW32(HeapAlloc( m_hThumbHeap, 
				HEAP_NO_SERIALIZE, sizeof( THUMBNAILCACHEITEM ) ), LPVOID(0) ) );
	if ( ptci )
	{
		ptci->pbThumb = pbThumb;
		ptci->cbThumb = cbThumb;
		m_tcThumbnails[bstrFullItemName] = ptci;
		fRet = true;
	}
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::RemoveThumbnail
 * 
 * THis removes a thumbnail from the cache.  This will return true if found
 * an item to remove, or false if it removed nothing.
 *
 * bstrFullItemName:	the name of the item to remove from the cache.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::RemoveThumbnail( CComBSTR bstrFullItemName )
{
	bool fRet = false;
	THUMBNAILCACHEITEM* ptci = 0;

	Lock();
	ptci = m_tcThumbnails[bstrFullItemName];
	if ( ptci )
	{
		m_tcThumbnails.erase( bstrFullItemName );
		TW32( HeapFree( m_hThumbHeap, HEAP_NO_SERIALIZE, ptci ), FALSE );
		fRet = true;
	}
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::AllocThumbnail
 *
 * This allocates memory for a thumbnail from our thumbnail heap. 
 *
 * cbThumb:		the size of the thumbnail to allocate
 * ppbThumb:	Out, recieves the pointer to the memory
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::AllocThumbnail( DWORD cbThumb, BYTE** ppbThumb )
{
	Assert( m_hThumbHeap && "Error: NULL thumbnail heap" );
	Assert( ppbThumb && cbThumb != 0 );

	Lock();
	*ppbThumb = reinterpret_cast<BYTE*>(TW32( HeapAlloc( m_hThumbHeap, 
			HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, cbThumb ), LPVOID(0) ));
	Unlock();
	
	return ( *ppbThumb != NULL );
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::FreeThumbnail
 *
 * This frees the thumbnail memory.  This _SHOULD_NOT_ be called if the
 * thumbnail is cached. This should only be called to cleanup after an error
 * generating the thumbnail.
 *
 * pbThumb:	the memory to free
 *--(samclem)-----------------------------------------------------------------*/
void CWiaCacheManager::FreeThumbnail( BYTE* pbThumb )
{
	Assert( m_hThumbHeap && "Error: NULL thumbnail heap" );
	Assert( pbThumb );

	Lock();
	TW32( HeapFree( m_hThumbHeap, HEAP_NO_SERIALIZE, pbThumb ), FALSE );
	Unlock();
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::Init	[static]
 *
 * This is called to initalize the cache manager. This simply creates and 
 * instance of the cache manager and then initalizes it.
 *
 * Notes:	This can only be called once
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::Init()
{
	Assert( !sm_pManagerInstance &&
			"\nInit() can only be called once. Expected NULL instance" );

	sm_pManagerInstance = new CWiaCacheManager();
	if ( !sm_pManagerInstance )
		return false;
	
	return sm_pManagerInstance->Initialize();
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::Uninit		[static]
 *
 * This is called to uninitialize the cache manager. basically this is called
 * to destroy the instance we have. If we have one.
 *
 * Notes:	This should only be called once
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::Uninit()
{
	if ( sm_pManagerInstance )
		delete sm_pManagerInstance;

	sm_pManagerInstance = 0;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiadevinf.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiadevinf.h
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 14:48:39 1999
 * Description:
 * 	This defines the CWiaDeviceInfo object.  This class provides the scripting
 *	interface to IWiaPropertyStorage on the devices.
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIADEVINF_H_
#define _WIADEVINF_H_

/*-----------------------------------------------------------------------------
 * 
 * Class:		CWiaDeviceInfo
 * Syniosis:	Acts a proxy between scripting and the device properties
 * 				
 *--(samclem)-----------------------------------------------------------------*/

class ATL_NO_VTABLE CWiaDeviceInfo :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IWiaDeviceInfo, &IID_IWiaDeviceInfo, &LIBID_WIALib>,
	public IObjectSafetyImpl<CWiaDeviceInfo, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CWiaDeviceInfo();
	
	DECLARE_TRACKED_OBJECT
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	STDMETHOD_(void, FinalRelease)();


	BEGIN_COM_MAP(CWiaDeviceInfo)
		COM_INTERFACE_ENTRY(IWiaDeviceInfo)
		COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()

	// Non-interface methods for internal use
	HRESULT AttachTo( IWiaPropertyStorage* pStg, IWia* pWia );

	// IWiaDeviceInfo
	STDMETHOD(Create)( IWiaDispatchItem** ppDevice );

	STDMETHOD(get_Id)( BSTR* pbstrDeviceId );
	STDMETHOD(get_Name)( BSTR* pbstrName );
	STDMETHOD(get_Type)( BSTR* pbstrType );
	STDMETHOD(get_Port)( BSTR* pbstrPort );
	STDMETHOD(get_UIClsid)( BSTR* pbstrGuidUI );
	STDMETHOD(get_Manufacturer)( BSTR* pbstrVendor );
	STDMETHOD(GetPropById)( WiaDeviceInfoPropertyId Id, VARIANT* pvaOut );

protected:
	IWiaPropertyStorage*	m_pWiaStorage;
	IWia*					m_pWia;
};

#endif //_WIADEVINF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiaeventscp.h ===
#ifndef _WIAEVENTSCP_H_
#define _WIAEVENTSCP_H_


template <class T>
class CProxy_IWiaEvents : public IConnectionPointImpl<T, &DIID__IWiaEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnDeviceConnected(BSTR bstrDeviceId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bstrDeviceId;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnDeviceDisconnected(BSTR bstrDeviceId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bstrDeviceId;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnTransferComplete(IDispatch * pItem, BSTR bstrPath)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = pItem;
				pvars[0] = bstrPath;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				HRESULT hr = THR( pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL) );
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiaitem.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:    wiaitem.cpp
 * Author:  Samuel Clement (samclem)
 * Date:    Tue Aug 17 17:26:17 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 *      Contains the implementation of the CWiaItem object. This object provides
 *      the automation interface to the IWiaItem interface.
 *
 * History:
 *  17 Aug 1999:        Created.
 *  27 Aug 1999:        Added the tagWiaDataTrans (samclem)
 *  10 Sep 1999:        Moved thumbnail transfer to a static method.  Hooked
 *                      thumbnails up to CWiaProtocol for transfer, no more
 *                      temporary files. (samclem)
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

HRESULT VerticalFlip(BYTE    *pBuf);

DeclareTag( tagWiaDataTrans, "!WiaTrans", "Display output during the transfer" );

//const WORD k_wBitmapType        = static_cast<WORD>('BM');
const WORD k_wBitmapType  = 0x4d42; // "BM"

/*-----------------------------------------------------------------------------
 * CWiaItem::CWiaItem
 *
 * Create a new wrapper around an IWiaItem for a device. This doesn't do
 * anything besides initialize the variables to a known state.
 *--(samclem)-----------------------------------------------------------------*/
CWiaItem::CWiaItem()
    : m_pWiaItem( NULL ), m_pWiaStorage( NULL ), m_dwThumbWidth( -1 ), m_dwThumbHeight( -1 ),
    m_bstrThumbUrl( NULL ), m_dwItemWidth( -1), m_dwItemHeight( -1 )
{
    TRACK_OBJECT( "CWiaItem" );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::FinalRelease
 *
 * Called while destroying the object, releases all the interfaces that this
 * object is attached to.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaItem::FinalRelease()
{
    if ( m_pWiaItem )
        m_pWiaItem->Release();
    m_pWiaItem = NULL;

    if ( m_pWiaStorage )
        m_pWiaStorage->Release();
    m_pWiaStorage = NULL;

    if ( m_bstrThumbUrl )
        SysFreeString( m_bstrThumbUrl );
    m_bstrThumbUrl = NULL;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::CacheProperties
 *
 * This is called to handle caching the important (frequently used)
 * properties so we don't have to talk to the camera when we want these.
 *
 * pWiaStg: the property storage to read the properties from
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaItem::CacheProperties( IWiaPropertyStorage* pWiaStg )
{
    HRESULT hr;
    enum
    {
        PropThumbWidth  = 0,
        PropThumbHeight = 1,
        PropItemWidth   = 2,
        PropItemHeight  = 3,
        PropCount       = 4,
    };
    PROPSPEC aspec[PropCount] = {
        { PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH        },
        { PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT       },
        { PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE    },
        { PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES    },
    };
    PROPVARIANT avaProps[PropCount];


    hr = THR( pWiaStg->ReadMultiple( PropCount, aspec, avaProps ) );
    if ( FAILED( hr ) )
        return hr;

    // store the values away if they were valid
    if ( avaProps[PropThumbWidth].vt != VT_EMPTY )
        m_dwThumbWidth = avaProps[PropThumbWidth].lVal;
    if ( avaProps[PropThumbHeight].vt != VT_EMPTY )
        m_dwThumbHeight = avaProps[PropThumbHeight].lVal;
    if ( avaProps[PropItemWidth].vt != VT_EMPTY )
        m_dwItemWidth = avaProps[PropItemWidth].lVal;
    if ( avaProps[PropItemHeight].vt != VT_EMPTY )
        m_dwItemHeight = avaProps[PropItemHeight].lVal;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::AttachTo
 *
 * Called to attach this object to an IWiaItem that represents the device
 *
 * pWia:        The CWia object that is the root of all evils, used to
 *              handle callbacks and collection cache.
 * pWiaItem:    the device item to attach this wrapper to.
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaItem::AttachTo( CWia* pWia, IWiaItem* pWiaItem )
{
    Assert( NULL != pWiaItem );
    Assert( NULL == m_pWiaItem );

    HRESULT hr;
    IWiaPropertyStorage* pWiaStg = NULL;

    hr = THR( pWiaItem->QueryInterface( IID_IWiaPropertyStorage,
            reinterpret_cast<void**>(&pWiaStg) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CacheProperties( pWiaStg ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // set our pointers
    m_pWiaItem = pWiaItem;
    m_pWiaItem->AddRef();

    m_pWiaStorage = pWiaStg;
    m_pWiaStorage->AddRef();

    // don't addref this, otherwise we have a circular referance
    // problem.  We will keep a weak referance.
    m_pWia = pWia;

Cleanup:
    if ( pWiaStg )
        pWiaStg->Release();

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::GetItemsFromUI         [IWiaDispatchItem]
 *
 * This handles showing the Data Acquisition U.I.  Note that this is only valid
 * off a root item.
 *
 *
 * dwFlags:         flags specifying UI operations.
 * dwIntent:        the intent value specifying attributes such as Color etc.
 * ppCollection:    the return collection of Wia Items
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::GetItemsFromUI( WiaFlag Flags, WiaIntent Intent, ICollection** ppCollection )
{
    HRESULT     hr           = S_OK;
    LONG        lCount       = 0;
    IWiaItem    **ppIWiaItem = NULL;
    CComObject<CCollection>* pCol   = NULL;
    IDispatch** rgpDispatch         = NULL;
    LONG        lItemType    = 0;

    if ( NULL == ppCollection )
        return E_POINTER;

    // first we want the item type of this item
    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( !(lItemType & WiaItemTypeRoot) )
        {
        hr = E_INVALIDARG;
        goto Cleanup;
        }

    DWORD dwFlags = (DWORD)Flags;
    DWORD dwIntent = (DWORD)Intent;

    // Show the get image dialog.
    hr = m_pWiaItem->DeviceDlg((HWND)NULL,
                              dwFlags,
                              dwIntent,
                              &lCount,
                              &ppIWiaItem);
    if (SUCCEEDED(hr))
        {

        // Check if user cancelled
        if ( S_FALSE == hr )
            {
            goto Cleanup;
            }

        // Put returned items into a collection

        // allocate our arrays, zeroing them if we are successful.
        // Note: we check for failure after each one
        if ( lCount > 0 )
            {
            hr = E_OUTOFMEMORY;
            rgpDispatch = reinterpret_cast<IDispatch**>
                (CoTaskMemAlloc( sizeof( IDispatch* ) * lCount ) );
            if ( rgpDispatch )
                ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * lCount );
            else
                goto Cleanup;

            // we have all our items, so we simply need to iterate
            // over them and create the CWiaItem to attach to them
            for ( LONG i = 0; i < lCount; i++ )
                {
                if ( !(ppIWiaItem[i]) )
                    continue;

                CComObject<CWiaItem>* pItem;
                hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pItem->AttachTo( m_pWia, ppIWiaItem[i] ) );
                if ( FAILED( hr ) )
                    {
                    delete pItem;
                    goto Cleanup;
                    }

                hr = THR( pItem->QueryInterface( &rgpDispatch[i] ) );
                Assert( SUCCEEDED( hr ) ); // this shouldn't fail.
                }
            }

        hr = THR( CComObject<CCollection>::CreateInstance( &pCol ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( rgpDispatch )
            {
            if( !pCol->SetDispatchArray( rgpDispatch, lCount ) )
                {
                hr = E_FAIL;
                goto Cleanup;
                }
            }

        hr = THR( pCol->QueryInterface( ppCollection ) );

        }

Cleanup:
    if (ppIWiaItem)
        {
        for ( LONG i = 0; i < lCount; i++ )
            {
            if ( !(ppIWiaItem[i]) )
                continue;
            ppIWiaItem[i]->Release();
            ppIWiaItem[i] = NULL;
            }

        LocalFree( ppIWiaItem );
        }
    if (FAILED(hr) && rgpDispatch)
        {

        for (LONG index = 0; index < lCount; index ++)
            {
            if (rgpDispatch[index])
                rgpDispatch[index]->Release();
                rgpDispatch[index] = NULL;
            }
        CoTaskMemFree( rgpDispatch );
        }
    return hr;
}


/*-----------------------------------------------------------------------------
 * CWiaItem::Transfer           [IWiaDispatchItem]
 *
 * This handles transfering this item to a file.  This does several things:
 *
 *      1. Verifies that the item can actually be tranferred to a file
 *      2. begins the async trans, by spawning a thread
 *      3. following the completion of the async transfer the client is
 *         sent a onTransferComplete( item, filename ) event.
 *
 * Note: we need to consider how to handle this methods, this object is currently
 *       unsafe for scripting because this could potentially overwrite system
 *       files. Proposed fixes:
 *
 *       1. Don't over write existing files
 *       2. If the file exists, then check its attributes if the system
 *          attribute is present then abort
 *       3. If the file name starts with %WinDir% then abort
 *
 * bstrFilename:    the name of the file to save this item to
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::Transfer( BSTR bstrFilename, VARIANT_BOOL bAsyncTransfer )
{
    TraceTag((0, "attempting to transfer image to: %S", bstrFilename ));

    DWORD   dwThreadId  = NULL;
    HANDLE  hThread     = NULL;
    LONG    lItemType   = 0;
    HRESULT hr;
    IStream* pStrm      = NULL;
    CWiaDataTransfer::ASYNCTRANSFERPARAMS* pParams;

    if (bstrFilename == NULL)
        return E_INVALIDARG; // No file name specified

    if (SysStringLen(bstrFilename) >= MAX_PATH)
        return E_INVALIDARG; // don't allow pathologicaly long file names

    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( !( lItemType & WiaItemTypeFile ) && !( lItemType & WiaItemTypeTransfer ) )
        return E_INVALIDARG; // can't download this guy


    // we need to marshall the m_pWiaItem interface to another thread so that
    // we can accessit inside of that object.
    hr = THR( CoMarshalInterThreadInterfaceInStream( IID_IWiaItem,
                                                     m_pWiaItem,
                                                     &pStrm ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pParams = reinterpret_cast<CWiaDataTransfer::ASYNCTRANSFERPARAMS*>
              (CoTaskMemAlloc( sizeof( CWiaDataTransfer::ASYNCTRANSFERPARAMS ) ) );
    if (!pParams) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // setup the params
    pParams->pStream = pStrm;
    pParams->pStream->AddRef();
    pParams->pItem = this;
    pParams->pItem->AddRef();
    pParams->bstrFilename = SysAllocString( bstrFilename );

    if ( bAsyncTransfer == VARIANT_TRUE )
        {
        hThread = CreateThread( NULL,
                                0,
                                CWiaDataTransfer::DoAsyncTransfer,
                                pParams,
                                0,
                                &dwThreadId );
        // did we create the thread?
        if ( hThread == NULL )
            {
            TraceTag((0, "error creating the async transfer thread" ));
            return E_FAIL;
            }
        TraceTag((0, "create async download thread:  id(%ld)", dwThreadId ));
        }
    else
        hr = CWiaDataTransfer::DoAsyncTransfer(pParams);


    Cleanup:
    if ( pStrm )
        pStrm->Release();
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::TakePicture        [IWiaDispatchItem]
 *
 *  This method sends the take picture command to the driver.  It will return
 *  a new dispatch item representing the new picture.
 *
 *--(byronc)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::TakePicture( IWiaDispatchItem** ppDispItem )
{
    TraceTag((0, "attempting to take new picture" ));
    HRESULT     hr              = S_OK;
    IWiaItem    *pNewIWiaItem   = NULL;
    CComObject<CWiaItem>*pItem  = NULL;

    if ( !ppDispItem )
        return E_POINTER;

    //  Initialize the returned item to NULL
    *ppDispItem = NULL;

    //  Send device command "TakePicture"
    hr = m_pWiaItem->DeviceCommand(0,
                                   &WIA_CMD_TAKE_PICTURE,
                                   &pNewIWiaItem);
    if (SUCCEEDED(hr)) {

        //  Check for new item created
        if (pNewIWiaItem) {
            //  Set the returned item
            hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pItem->AttachTo( m_pWia, pNewIWiaItem ) );
            if ( FAILED( hr ) )
                {
                delete pItem;
                goto Cleanup;
                }

            hr = THR( pItem->QueryInterface( ppDispItem ) );
            Assert( SUCCEEDED( hr ) ); // this shouldn't fail.
        }
    } else {
        // Call failed, so we'll set hr to false and return a NULL item.
        hr = S_FALSE;
    }

    Cleanup:
    if (FAILED(hr)) {
        if (pItem) {
            delete pItem;
            pItem = NULL;
        }
        if (*ppDispItem) {
            *ppDispItem = NULL;
        }
    }

    return hr;
}


/*-----------------------------------------------------------------------------
 * CWiaItem::SendTransferCompelete
 *
 * Called to send a transfer complete notification.
 *
 * pchFilename:     the filename that we transfered to
 *--(samclem)-----------------------------------------------------------------*/
void
CWiaItem::SendTransferComplete(BSTR bstrFilename )
{
    //TODO(Aug, 24) samclem:  implement this
    TraceTag((0, "SendTransferComplete -- %S done.", bstrFilename ));
    CComBSTR bstrPathname = bstrFilename;

    m_pWia->SendEventMessage( WEM_TRANSFERCOMPLETE,
            reinterpret_cast<WPARAM>(static_cast<IDispatch*>(this)),
            reinterpret_cast<LPARAM>(bstrPathname.Detach()) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Children           [IWiaDispatchItem]
 *
 * This returns a collection of the children this item has. this will return
 * and empty collection if the doesn't or can't have any children.
 *
 * ppCollection:    Out, recieves the ICollection pointer for our collection
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Children( ICollection** ppCollection )
{
    CComObject<CCollection>* pCol   = NULL;
    HRESULT hr;
    IDispatch** rgpDispatch         = NULL;
    IEnumWiaItem* pEnum             = NULL;
    IWiaItem** rgpChildren          = NULL;
    // code below assumes cChildren is initialized to 0!!!!
    ULONG cChildren                 = 0;
    ULONG celtFetched               = 0;
    LONG ulItemType                 = 0;

    //TODO(Aug, 18) samclem:  for performance reasons we will want to
    // cache the collection of our children. In order to do that however,
    // we need to be able sink to the WIA_EVENT_ITEM_ADDED and the
    // WIA_EVENT_ITEM_DELTED events.  Currently this object doesn't
    // do any syncing so we will create the collection each time it
    // is requested. This however can be very slow.

    if ( NULL == ppCollection )
        return E_POINTER;

    // first we want the item type of this item
    hr = THR( m_pWiaItem->GetItemType( &ulItemType ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // You can enumerate the children of a wia item if an only if
    // it contains the WiaItemTypeFolder flag.  We however, want to
    // return an empty enumeration anyhow, so we will make this
    // test upfront and get the enumeration and the child count
    // only if we can support them
    if ( ulItemType & WiaItemTypeFolder )
        {
        // enum the children
        hr = THR( m_pWiaItem->EnumChildItems( &pEnum ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pEnum->GetCount( &cChildren ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }

    // allocate our arrays, zeroing them if we are successful.
    // Note: we check for failure after each one
    if ( cChildren > 0 )
        {
        hr = E_OUTOFMEMORY;
        rgpChildren = new IWiaItem*[cChildren];
        if ( rgpChildren )
            ZeroMemory( rgpChildren, sizeof( IWiaItem* ) * cChildren );
        else
            goto Cleanup;

        rgpDispatch = reinterpret_cast<IDispatch**>
            (CoTaskMemAlloc( sizeof( IDispatch* ) * cChildren ) );
        if ( rgpDispatch )
            ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * cChildren );
        else
            goto Cleanup;


        //BUG (Aug, 18) samclem:  You can't retrieve all the items at
        // once, WIA doesn't want to do it, so we have another loop here
        // but we still use the array, hoping that we can do this in
        // the future.

        // get the items from the enum
        for ( ULONG iChild = 0; iChild < cChildren; iChild++ )
            {
        hr = THR( pEnum->Next( 1, &rgpChildren[iChild], &celtFetched ) );
        if ( FAILED( hr ) || celtFetched != 1 )
            goto Cleanup;
            }
        // we now have all our items, so we simply need iterate
        // over them and create the CWiaItem to attach to them
        for ( ULONG i = 0; i < cChildren; i++ )
            {
            if ( !rgpChildren[i] )
                continue;

            CComObject<CWiaItem>* pItem;
            hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pItem->AttachTo( m_pWia, rgpChildren[i] ) );
            if ( FAILED( hr ) )
                {
                delete pItem;
                goto Cleanup;
                }

            hr = THR( pItem->QueryInterface( &rgpDispatch[i] ) );
            Assert( SUCCEEDED( hr ) ); // this shouldn't fail.
            }
        }

    hr = THR( CComObject<CCollection>::CreateInstance( &pCol ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( rgpDispatch )
        {
        if( !pCol->SetDispatchArray( rgpDispatch, cChildren ) )
            {
            hr = E_FAIL;
            goto Cleanup;
            }
        }

    hr = THR( pCol->QueryInterface( ppCollection ) );

Cleanup:
    if ( pEnum )
        pEnum->Release();

    if ( pCol && FAILED( hr ) )
        delete pCol;

    if ( rgpChildren )
        {
        for ( ULONG i = 0; i < cChildren; i++ )
            if ( rgpChildren[i] ) rgpChildren[i]->Release();
        delete[] rgpChildren;
        }

    if ( rgpDispatch && FAILED( hr ) )
        {
        for ( ULONG i = 0; i < cChildren; i++ )
            if ( rgpDispatch[i] ) rgpDispatch[i]->Release();

        CoTaskMemFree( rgpDispatch );
        }

    return hr;
}

// macro which helps inside of get_ItemType
#define CAT_SEMI( buf, str ) \
    { \
        if( *buf ) \
            _tcscat( buf, TEXT( ";" ) ); \
        _tcscat( buf, str ); \
    }

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ItemType       [IWiaDispatchItem]
 *
 * Retrieves the item type as a BSTR.  This will have the format as follows:
 *
 *      "device;folder", "image;file", "audio;file"
 *
 * The format is single strings seperated by ';'.  there will be no semi-colon
 * at the end of the string.
 *
 * pbstrType:   recieves the type of the item as a bstr.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ItemType( BSTR* pbstrType )
{
    TCHAR tch[MAX_PATH] = { 0, 0 };
    HRESULT hr;
    LONG lItemType;
USES_CONVERSION;

    if ( !pbstrType )
        return E_POINTER;
    *pbstrType = NULL;

    // we will construct an array of tchar's that contain the
    // property types. (note: an alternate approach would use CComBSTR)
    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        return hr;

    // process our flags, and create the item type.
    if ( lItemType & WiaItemTypeAnalyze )
        CAT_SEMI( tch, TEXT("analyze") );
    if ( lItemType & WiaItemTypeAudio )
        CAT_SEMI( tch, TEXT("audio") );
    if ( lItemType & WiaItemTypeDeleted )
        CAT_SEMI( tch, TEXT("deleted") );
    if ( lItemType & WiaItemTypeDevice )
        CAT_SEMI( tch, TEXT("device") );
    if ( lItemType & WiaItemTypeDisconnected )
        CAT_SEMI( tch, TEXT("disconnected") );
    if ( lItemType & WiaItemTypeFile )
        CAT_SEMI( tch, TEXT("file") );
    if ( lItemType & WiaItemTypeFolder )
        CAT_SEMI( tch, TEXT("folder") );
    if ( lItemType & WiaItemTypeFree )
        CAT_SEMI( tch, TEXT("free") );
    if ( lItemType & WiaItemTypeImage )
        CAT_SEMI( tch, TEXT("image") );
    if ( lItemType & WiaItemTypeRoot )
        CAT_SEMI( tch, TEXT("root") );
    if ( lItemType & WiaItemTypeTransfer)
        CAT_SEMI( tch, TEXT("transfer") );

    //
    //  Original version:
    //  WCHAR awch[MAX_PATH];
    //  if ( MultiByteToWideChar( CP_ACP, 0, ach, -1, awch, MAX_PATH ) )
    //
    //  Replaced with ATL conversion T2W.
    //

    *pbstrType = SysAllocString( T2W(tch) );

    if ( !*pbstrType )
        return E_OUTOFMEMORY;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::GetPropById        [IWiaDispatchItem]
 *
 * This returns the unchanged variant value of the property with the given
 * id.
 *
 * This will return a an empty variant if the property doesn't exist or
 * it can't be easily converted to a variant.
 *
 * propid:      the id of the property that we want
 * pvaOut:      Out, gets the value of the property.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::GetPropById( WiaItemPropertyId Id, VARIANT* pvaOut )
{
    HRESULT hr;
    PROPVARIANT vaProp;
    DWORD dwPropID = (DWORD)Id;

    hr = THR( GetWiaProperty( m_pWiaStorage, dwPropID, &vaProp ) );
    if ( FAILED( hr ) )
        return hr;

    // attempt to convert
    hr = THR( PropVariantToVariant( &vaProp, pvaOut ) );
    if ( FAILED( hr ) )
        {
        TraceTag((0, "forcing device property %ld to VT_EMPTY", dwPropID ));
        VariantInit( pvaOut );
        pvaOut->vt = VT_EMPTY;
        }

    // clear and return
    PropVariantClear( &vaProp );
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ConnectStatus      [IWiaDispatchItem]
 *
 * returns the connect status of the item. This is only applicatable to devices
 * and otherwise it will return NULL.
 *
 * Values:  "connected", "disconnected" or NULL if not applicable
 *
 * pbstrStatus:     Out, recieves the current connect status of the item
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ConnectStatus( BSTR* pbstrStatus )
{
    PROPVARIANT vaProp;
    HRESULT hr;

    STRING_TABLE( stConnectStatus )
        STRING_ENTRY( WIA_DEVICE_CONNECTED,     "connected" )
        STRING_ENTRY( WIA_DEVICE_NOT_CONNECTED, "disconnected" )
        STRING_ENTRY( WIA_DEVICE_CONNECTED + 2, "not supported" )
    END_STRING_TABLE()

    if ( !pbstrStatus )
        return E_POINTER;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPA_CONNECT_STATUS, &vaProp ) );
    if (hr != S_OK) {
        if ( FAILED( hr ) ) {
            return hr;
        }
        else {
            //
            // Property not found, so return "not supported"
            //

            vaProp.vt   = VT_I4;
            vaProp.lVal = WIA_DEVICE_CONNECTED + 2;
        }
    }

    *pbstrStatus = SysAllocString( GetStringForVal( stConnectStatus, vaProp.lVal ) );
    PropVariantClear( &vaProp );

    if ( !*pbstrStatus )
        return E_OUTOFMEMORY;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Time               [IWiaDispatchItem]
 *
 * Retrieves the current time from this item.
 *
 * pbstrTime:   Out, recieves the time as a BSTR.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Time( BSTR* pbstrTime )
{
    if ( !pbstrTime )
        return E_POINTER;

    PROPVARIANT vaProp;
    HRESULT     hr          = S_OK;
    LONG        lItemType   = 0;
    WCHAR       wszStr[MAX_PATH];

    UNALIGNED SYSTEMTIME *pSysTime;

    PropVariantInit(&vaProp);

    //
    //  If this is the root item, get WIA_DPA_DEVICE_TIME, else get
    //  WIA_IPA_ITEM_ITEM.
    //

    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        return hr;
    if (lItemType & WiaItemTypeRoot) {

        hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPA_DEVICE_TIME, &vaProp ) );
    } else {
        hr = THR( GetWiaProperty( m_pWiaStorage, WIA_IPA_ITEM_TIME, &vaProp ) );
    }
    if ( FAILED( hr ) )
        return hr;

    //
    //  Convert the value in vaProp to a string.  First check that the variant
    //  contains enough words to make up a SYSTEMTIME structure.
    //

    if (vaProp.caui.cElems >= (sizeof(SYSTEMTIME) / sizeof(WORD))) {

        pSysTime = (SYSTEMTIME*) vaProp.caui.pElems;

        swprintf(wszStr, L"%.4d/%.2d/%.2d:%.2d:%.2d:%.2d", pSysTime->wYear,
                                                           pSysTime->wMonth,
                                                           pSysTime->wDay,
                                                           pSysTime->wHour,
                                                           pSysTime->wMinute,
                                                           pSysTime->wSecond);
        *pbstrTime = SysAllocString( wszStr );
    } else {
        hr = S_FALSE;
    }

    if ( hr != S_OK ) {
        *pbstrTime = SysAllocString( L"not supported" );
    }

    if ( !*pbstrTime )
        hr = E_OUTOFMEMORY;

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_FirmwareVersion    [IWiaDispatchItem]
 *
 * Retrieves the firmware version from the device. Only applicatble on devices,
 * if its not applicable NULL is returned.
 *
 * pbstrVersion:    Out, recieves the version from the device
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_FirmwareVersion( BSTR* pbstrVersion )
{
    if ( !pbstrVersion )
        return E_POINTER;

    PROPVARIANT vaProp;
    HRESULT hr;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPA_FIRMWARE_VERSION, &vaProp ) );
    if ( FAILED( hr ) )
        return hr;

    // if it is already a bstr then leave it alone
    if ( vaProp.vt == VT_BSTR )
        *pbstrVersion = SysAllocString( vaProp.bstrVal );
    else if ( vaProp.vt == VT_I4 )
        {
        WCHAR rgwch[255];

        wsprintf(rgwch, L"%d", vaProp.lVal);
        *pbstrVersion = SysAllocString( rgwch );
        }
    else
        {
        *pbstrVersion = SysAllocString( L"unknown" );
        }

    PropVariantClear( &vaProp );

    if ( !*pbstrVersion )
        return E_OUTOFMEMORY;

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Name           [IWiaDispatchItem]
 *
 * Retrieves the name of the item.  Applicable to all items.
 *
 * pbstrName:   Out, recieves the name of the item
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Name( BSTR* pbstrName )
{
    if ( !pbstrName )
        return E_POINTER;

    return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_IPA_ITEM_NAME, pbstrName ) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_FullName       [IWiaDispatchItem]
 *
 * Retrieves the full name of the item, Applicable to all items
 * Format:  "Root\blah\blah"
 *
 * pbstrFullName:   Out, recieves the full name of the item
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_FullName( BSTR* pbstrFullName )
{
    if ( !pbstrFullName )
        return E_POINTER;

    return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_IPA_FULL_ITEM_NAME, pbstrFullName ) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Width          [IWiaDispatchItem]
 *
 * Retrieves the width of the item, most items will support getting thier
 * width.
 *
 * plWidth:    Out, recieves the items with in pixels
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP CWiaItem::get_Width( long* plWidth )
{
    if ( !plWidth )
        return E_POINTER;

    *plWidth = (long)m_dwItemWidth;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Height         [IWiaDispatchItem]
 *
 * Retrieves the height of the item, most items will support getting thier
 * width. Will return 0, if there is no with to get
 *
 * plHeight:   Out, recieves the itmes height in pixels
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP CWiaItem::get_Height( long* plHeight )
{
    if ( !plHeight )
        return E_POINTER;

    *plHeight = (long)m_dwItemHeight;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ThumbWidth     [IWiaDispatchItem]
 *
 * Retrieves the thumbnail width for the thumbnail associated with this item,
 * if this item doesn't support thumbnails this will be 0.
 *
 * plWidth:    Out, recieves the width of the thumbnail image
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ThumbWidth( long* plWidth )
{
    if ( !plWidth )
        return E_POINTER;

    *plWidth = (long)m_dwThumbWidth;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ThumbHeight    [IWiaDispatchItem]
 *
 * Retrieves the thumbnail height for the thumbnail image. If this item doesn't
 * support thumbnails then this will return 0.
 *
 * plHeight:   Out, recieces the height of the thumbnail image
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ThumbHeight( long* plHeight )
{
    if ( !plHeight )
        return E_POINTER;

    *plHeight = (long)m_dwThumbHeight;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Thumbnail      [IWIaDispatchItem]
 *
 * This recieves a URL to the thumbnail. This returns a magic URL that
 * will transfer the bits directly to trident. This will return
 * E_INVALIDARG if the given item doesn't support thumbnails.  Or NULL if
 * we are unable to build a URL for the item.
 *
 * pbstrPath:   Out, recieces teh full path tot the thumbnail
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Thumbnail( BSTR* pbstrPath )
{
    LONG lItemType = 0;
    HRESULT hr;

    if ( !pbstrPath )
        return E_POINTER;
    *pbstrPath = NULL;

    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        return hr;

    if ( !( lItemType & ( WiaItemTypeFile | WiaItemTypeImage ) ) )
    {
        TraceTag((tagError, "Requested thumbnail on an invaild item type" ));
        return E_INVALIDARG;
    }

    // Do we already have the URL? if not then we can ask our custom
    // protocol to create the URL for us.
    if ( !m_bstrThumbUrl )
    {
        hr = THR( CWiaProtocol::CreateURL( m_pWiaItem, &m_bstrThumbUrl ) );
        if ( FAILED( hr ) )
            return hr;
    }

    *pbstrPath = SysAllocString( m_bstrThumbUrl );
    if ( !*pbstrPath )
        return E_OUTOFMEMORY;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_PictureWidth       [IWiaDispatchItem]
 *
 * Retrieces the width of the picture produced by this camera. this will return
 * -1, if its not supported or on error.
 *
 * plWidth:    Out, recieves the width of the picture
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_PictureWidth( long* plWidth )
{
    PROPVARIANT vaProp;
    HRESULT     hr;

    if ( !plWidth )
        return E_POINTER;

    *plWidth = -1;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPC_PICT_WIDTH, &vaProp ) );
    if ( SUCCEEDED( hr ) )
        {
        if ( vaProp.vt == VT_I4 )
            *plWidth = vaProp.lVal;
        }

    PropVariantClear( &vaProp );
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_PictureHeight      [IWiaDispatchItem]
 *
 * Retrieves the height of the pictures produced by this camera, or -1
 * if the item doesn't support this property.
 *
 * plHeight:   the height of the pictures produced.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_PictureHeight( long* plHeight )
{
    PROPVARIANT vaProp;
    HRESULT     hr;

    if ( !plHeight )
        return E_POINTER;

    *plHeight = -1;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPC_PICT_HEIGHT, &vaProp ) );
    if ( SUCCEEDED( hr ) )
        {
        if ( vaProp.vt == VT_I4 )
            *plHeight = vaProp.lVal;
        }

    PropVariantClear( &vaProp );
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::TransferThumbnailToCache
 *
 * This transfers a thumbnail for this bitmap to our internal cache.
 * this will return S_OK if its successful or an error code if something
 * goes wrong. It will also fill in the out params with the new thumbnail
 *
 * pItem:       the item to get the thumbnail from
 * ppbThumb:    Out, recieves a pointer to the in-memory cached bitmap
 * pcbThumb:    Out, recieves the size of the in-memory bitmap
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaItem::TransferThumbnailToCache( IWiaItem* pItem, BYTE** ppbThumb, DWORD* pcbThumb )
{
    enum
    {
        PropWidth       = 0,
        PropHeight      = 1,
        PropThumbnail   = 2,
        PropFullName    = 3,
        PropCount       = 4,
    };

    HRESULT hr;
    CComPtr<IWiaItem> pItemK = pItem;
    DWORD cb        = NULL;
    BYTE* pbBitmap  = NULL;
    BYTE* pbData    = NULL;
    CComQIPtr<IWiaPropertyStorage> pWiaStg;
    CWiaCacheManager* pCache = CWiaCacheManager::GetInstance();
    PROPVARIANT avaProps[PropCount];
    PROPSPEC aspec[PropCount] =
    {
        { PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH },
        { PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT },
        { PRSPEC_PROPID, WIA_IPC_THUMBNAIL },
        { PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME },
    };

    Assert( pItem && ppbThumb && pcbThumb );
    *ppbThumb = 0;
    *pcbThumb = 0;

    // initalize our prop variants
    for ( int i = 0; i < PropCount; i++ )
        PropVariantInit( &avaProps[i] );

    // we need to access the WIA property storage. So if we can't
    // access that then we better just bail, because everything else
    // will be useless
    pWiaStg = pItem;
    if ( !pWiaStg )
    {
        TraceTag((tagError, "item didn't support IWiaPropertyStorage" ));
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR( pWiaStg->ReadMultiple( PropCount, aspec, avaProps ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // validate the types, we want to make sure we actually have a
    // thumbnail to save, if we don't bail with a failure code
    if ( avaProps[PropThumbnail].vt == VT_EMPTY ||
        !( avaProps[PropThumbnail].vt & ( VT_VECTOR | VT_UI1 ) ) )
    {
        TraceTag((tagError, "item didn't return a useful thumbnail property" ));
        hr = E_FAIL;
        goto Cleanup;
    }

    // we now need to build our bitmap from the data, in order to do that
    // we need to allocate a chunk of memory. Since we are putting
    // this data in the cache, we want to allocate it using the
    // cache
    cb = sizeof( BITMAPFILEHEADER ) + sizeof( BITMAPINFOHEADER ) +
            ( sizeof( UCHAR ) * ( avaProps[PropThumbnail].caul.cElems ) );
    if ( !pCache->AllocThumbnail( cb, &pbBitmap ) )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    BITMAPINFOHEADER   bmi;
    BITMAPFILEHEADER   bmf;
    //
    //  We need to set the BMP header info.  To avoid data misalignment problems
    //  on 64bit, we'll modify the data structures on the stacj, then just copy them
    //  to the buffer.
    //
    
    // step 0, zero our memory
    ZeroMemory(pbBitmap, sizeof( BITMAPINFOHEADER ) + sizeof( BITMAPFILEHEADER ) );
    ZeroMemory(&bmf, sizeof(bmf));
    ZeroMemory(&bmi, sizeof(bmi));

    // step 1, setup the bitmap file header
    bmf.bfType        = k_wBitmapType;
    bmf.bfSize        = cb;
    bmf.bfOffBits     = sizeof(BITMAPINFOHEADER);
    
    // step 2, setup the bitmap info header
    bmi.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.biWidth       = avaProps[PropWidth].lVal;
    bmi.biHeight      = avaProps[PropHeight].lVal;
    bmi.biPlanes      = 1;
    bmi.biBitCount    = 24;
    bmi.biCompression = BI_RGB;
    
    // step 3, copy the new header info. to the buffer
    memcpy(pbBitmap, &bmf, sizeof(BITMAPFILEHEADER));
    memcpy(pbBitmap + sizeof(BITMAPFILEHEADER), &bmi, sizeof(BITMAPINFOHEADER));
    
    pbData = (pbBitmap + (sizeof(BITMAPINFOHEADER) + sizeof(BITMAPFILEHEADER)));

    // copy the data that WIA gave us into the bitmap buffer. once we
    // done this, our thumbnail is ready for the cache
    memcpy( pbData, avaProps[PropThumbnail].caul.pElems,
            sizeof( UCHAR ) * ( avaProps[PropThumbnail].caul.cElems ) );

    pCache->AddThumbnail(
            avaProps[PropFullName].bstrVal,
            pbBitmap,
            cb );

    // setup the out params
    *pcbThumb = cb;
    *ppbThumb = pbBitmap;

Cleanup:
    FreePropVariantArray( PropCount, avaProps );
    if ( FAILED( hr ) )
    {
        if ( pbBitmap )
            pCache->FreeThumbnail( pbBitmap );
    }

    return hr;
}

//------------------------------- CWiaDataTransfer ----------------------------

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::DoAsyncTransfer
 *
 * This is called to begin an Async transfer of the data. This will be
 * called via a call to create thread.
 *
 * Note: You can't use any of the interfaces inside of pItem, you must
 *       query for them through the marshaled interface pointer.
 *
 * pvParams:    AsyncTransferParams structure which has the data we need
 *--(samclem)-----------------------------------------------------------------*/
DWORD WINAPI
CWiaDataTransfer::DoAsyncTransfer( LPVOID pvParams )
{
    TraceTag((0, "** DoAsyncTransfer --> Begin Thread" ));

    HRESULT             hr;
    HRESULT             hrCoInit;
    IWiaDataCallback*   pCallback   = NULL;
    IWiaDataTransfer*   pWiaTrans   = NULL;
    IWiaItem*           pItem       = NULL;
    IWiaPropertyStorage* pWiaStg    = NULL;
    CComObject<CWiaDataTransfer>* pDataTrans = NULL;
    WIA_DATA_TRANSFER_INFO wdti;
    STGMEDIUM              stgMedium;

    enum
    {
        PropTymed   = 0,
        PropFormat  = 1,
        PropCount   = 2,
    };
    PROPSPEC spec[PropCount] =
    {
        { PRSPEC_PROPID, WIA_IPA_TYMED },
        { PRSPEC_PROPID, WIA_IPA_FORMAT },
    };
    PROPVARIANT rgvaProps[PropCount];
    ASYNCTRANSFERPARAMS* pParams = reinterpret_cast<ASYNCTRANSFERPARAMS*>(pvParams);
    Assert( pParams );

    // wait 50ms so that things can settle down
    Sleep( 50 );

    for ( int i = 0; i < PropCount; i++ )
        PropVariantInit( &rgvaProps[i] );

    hrCoInit = THR( CoInitialize( NULL ) );
    if ( FAILED( hrCoInit ) )
        goto Cleanup;

    // force a yield and let everyone else process what they
    // would like to do.
    Sleep( 0 );

    // first we need to unmarshal our interface
    hr = THR( CoGetInterfaceAndReleaseStream( pParams->pStream,
                IID_IWiaItem,
                reinterpret_cast<void**>(&pItem) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // we need the wia property storage
    hr = THR( pItem->QueryInterface( IID_IWiaPropertyStorage,
                reinterpret_cast<void**>(&pWiaStg) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // first query this object for the IWiaDataTransfer interface
    hr = THR( pItem->QueryInterface( IID_IWiaDataTransfer,
                reinterpret_cast<void**>(&pWiaTrans) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    ZeroMemory( &wdti, sizeof( wdti ) );
    rgvaProps[PropTymed].vt = VT_I4;
    rgvaProps[PropFormat].vt = VT_CLSID;

    if ( 0 == wcscmp( pParams->bstrFilename, CLIPBOARD_STR_W ) )
        {
        rgvaProps[PropTymed].lVal = TYMED_CALLBACK;
        rgvaProps[PropFormat].puuid = (GUID*)&WiaImgFmt_MEMORYBMP;
        }
    else
        {
        rgvaProps[PropTymed].lVal = TYMED_FILE;
        rgvaProps[PropFormat].puuid = (GUID*)&WiaImgFmt_BMP;
        }

    // write these properties out to the storage
    hr = THR( pWiaStg->WriteMultiple( PropCount, spec, rgvaProps, WIA_IPC_FIRST ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CComObject<CWiaDataTransfer>::CreateInstance( &pDataTrans ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pDataTrans->Initialize( pParams->pItem, pParams->bstrFilename ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pDataTrans->QueryInterface( IID_IWiaDataCallback,
                reinterpret_cast<void**>(&pCallback) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // we have everything we need, so setup the info and
    // get ready to transfer
    wdti.ulSize = sizeof( wdti );
    wdti.ulBufferSize = ( 1024 * 64 ); // 64k transfer

    if ( 0 == _wcsicmp( pParams->bstrFilename, CLIPBOARD_STR_W ) )
        //  Do the banded transfer.
        hr = THR( pWiaTrans->idtGetBandedData( &wdti, pCallback ) );
    else
        {
        ZeroMemory(&stgMedium, sizeof(STGMEDIUM));
        stgMedium.tymed          = TYMED_FILE;
        stgMedium.lpszFileName   = pParams->bstrFilename;

        //  Do the file transfer.
        hr = THR( pWiaTrans->idtGetData( &stgMedium, pCallback ) );
        }


Cleanup:
    if ( pItem )
        pItem->Release();
    if ( pWiaStg )
        pWiaStg->Release();
    if ( pCallback )
        pCallback->Release();
    if ( pWiaTrans )
        pWiaTrans->Release();

    //
    // Since the GUID we supplied as CLSID for PropFormat is a global const
    // we must not free it.  So we don't call FreePropVariantArry here,
    // since there is nothing to free
    //

    ZeroMemory(rgvaProps, sizeof(rgvaProps));

    // free the params that we were passed.
    if ( pParams )
        {
        SysFreeString( pParams->bstrFilename );
        pParams->pItem->Release();
        CoTaskMemFree( pParams );
        }

    if ( SUCCEEDED( hrCoInit ) )
        CoUninitialize();

    TraceTag((0, "** DoAsyncTransfer --> End Thread" ));
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::TransferComplete
 *
 * This is called when the transfer completed successfully, this will save
 * the data out to the proper place.
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaDataTransfer::TransferComplete()
{
    TraceTag((tagWiaDataTrans, "CWiaDataTransfer::TransferComplete *********" ));
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    bRes  = TRUE;
    DWORD   cbw   = 0;
    HGLOBAL pBuf  = NULL;
    BYTE*   pbBuf = NULL;

    if ( m_pbBuffer )
        {
        // Check whether we save the data to clipboard or file
        if ( 0 == _wcsicmp( m_bstrOutputFile, CLIPBOARD_STR_W ) )
            {
            pBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, m_sizeBuffer);
            if (!pBuf)
                return E_OUTOFMEMORY;

            if ( bRes = OpenClipboard(NULL) )
                {
                if ( bRes = EmptyClipboard() )
                    {
                    pbBuf = (BYTE*) GlobalLock(pBuf);
                    if ( pbBuf )
                        {
                        memcpy(pbBuf, m_pbBuffer, m_sizeBuffer);
                        // Callback dibs come back as TOPDOWN, so flip
                        VerticalFlip(pbBuf);

                        GlobalUnlock(pBuf);
                        if ( SetClipboardData(CF_DIB, pBuf) == NULL )
                            {
                            TraceTag((0, "TransferComplete - SetClipboardData failed" ));
                            // redundant statement added to get rid of "error C4390: ';' : empty controlled statement found;"
                            bRes = FALSE;
                            }
                        }
                    else
                        TraceTag((0, "TransferComplete - GlobalLock failed" ));
                    }
                else
                    {
                    TraceTag((0, "TransferComplete - EmptyClipboard failed" ));
                    // redundant statement added to get rid of "error C4390: ';' : empty controlled statement found;"
                    bRes = FALSE;
                    }

                bRes = CloseClipboard();
                if ( !bRes )
                    {
                    TraceTag((0, "TransferComplete - CloseClipboard failed" ));
                    // redundant statement added to get rid of "error C4390: ';' : empty controlled statement found;"
                    bRes = FALSE;
                    }
                }
            else
                TraceTag((0, "TransferComplete - OpenClipboard failed" ));
            GlobalFree(pBuf);
            }

        m_pItem->SendTransferComplete(m_bstrOutputFile);
        CoTaskMemFree( m_pbBuffer );
        m_pbBuffer = NULL;
        }
    else
        {
        //
        // File transfer complete, so signal the event
        //
        m_pItem->SendTransferComplete(m_bstrOutputFile);
        }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::CWiaDataTransfer
 *
 * This creates a new CWiaDataTransfer object. This initializes the member
 * variables of this object to a know state.
 *--(samclem)-----------------------------------------------------------------*/
CWiaDataTransfer::CWiaDataTransfer()
    : m_pbBuffer( NULL ), m_sizeBuffer( 0 ), m_pItem( NULL )
{
    TRACK_OBJECT("CWiaDataTransfer")
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::FinalRelease
 *
 * This is called when the object is finally released. This is responsible
 * for cleaning up any memory allocated by this object.
 *
 * NOTE: this currently has a hack to get around the fact that the
 *      IT_MSG_TERMINATION is not always sent by WIA.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaDataTransfer::FinalRelease()
{
    // do we have a buffer?
    if ( m_pbBuffer )
        {
        TraceTag((tagError, "CWiaDataTransfer - buffer should have been freed!!!!" ));
        TraceTag((tagError, " **** HACK HACK ***** Calling TansferComplete" ));
        TraceTag((tagError, " **** This could write a bogus file which might be unsable" ));
        TransferComplete();
        }

    if ( m_pItem )
        m_pItem->Release();
    m_pItem = NULL;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::Initialize
 *
 * This handles the internal initialization of the CWiaDataTransfer. This
 * should be called immediatly after it is created but before you attempt
 * to do anything with it.
 *
 * pItem:           the CWiaItem that we want to transfer from (AddRef'd)
 * bstrFilename:    the file where we want to save the data
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaDataTransfer::Initialize( CWiaItem* pItem, BSTR bstrFilename )
{
    // copy the filename into our output buffer
	m_bstrOutputFile = bstrFilename;

    // set our owner item, we want to ensure the item exists
    // as long as we do, so we will AddRef here and release
    // in final release.
    m_pItem = pItem;
    m_pItem->AddRef();
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::BandedDataCallback [IWiaDataTransfer]
 *
 * This is the callback from WIA which tells us what is going on.  This
 * copies the memory into our own buffer so that we can eventually save it
 * out.  In any error conditions this returns S_FALSE to abort the transfer.
 *
 * lMessage:            what is happening one of IT_MSG_xxx values
 * lStatus:             Sub status of whats happening
 * lPercentComplete:    Percent of the operation that has completed
 * lOffset:             the offset inside of pbBuffer where this operation is
 * lLength:             The length of the valid data inside of the buffer
 * lReserved:           Reserved.
 * lResLength:          Reserved.
 * pbBuffer:            The buffer we can read from in order to process the
 *                      data. Exact use depends on lMessage
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDataTransfer::BandedDataCallback( LONG lMessage, LONG lStatus, LONG lPercentComplete,
            LONG lOffset, LONG lLength, LONG lReserved, LONG lResLength, BYTE *pbBuffer )
{
    switch ( lMessage )
        {
    case IT_MSG_DATA:
        TraceTag((tagWiaDataTrans, "IT_MSG_DATA: %ld%% complete", lPercentComplete ));
        if ( m_pbBuffer )
            {
            // copy the data into our buffer
            memcpy( m_pbBuffer + lOffset, pbBuffer, lLength );
            }
        break;

    case IT_MSG_DATA_HEADER:
        {
        TraceTag((tagWiaDataTrans, "IT_MSG_DATA_HEADER" ));
        UNALIGNED WIA_DATA_CALLBACK_HEADER* pHeader =
            reinterpret_cast<WIA_DATA_CALLBACK_HEADER*>(pbBuffer);
        TraceTag((tagWiaDataTrans, "-------> %ld bytes", pHeader->lBufferSize ));

        // allocate our buffer
        m_sizeBuffer = pHeader->lBufferSize;
        m_pbBuffer = static_cast<BYTE*>(CoTaskMemAlloc( pHeader->lBufferSize ));
        if ( !m_pbBuffer )
            return S_FALSE; // abort
        }
        break;

    case IT_MSG_NEW_PAGE:
        TraceTag((tagWiaDataTrans, "IT_MSG_NEW_PAGE" ));
        break;

    case IT_MSG_STATUS:
        TraceTag((tagWiaDataTrans, "IT_MSG_STATUS: %ld%% complete", lPercentComplete ));
        break;

    case IT_MSG_TERMINATION:
        TraceTag((tagWiaDataTrans, "IT_MSG_TERMINATION: %ld%% complete", lPercentComplete ));
        if ( FAILED( THR( TransferComplete() ) ) )
            return S_FALSE;
        break;
        }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * VerticalFlip
 *
 * Vertically flips a DIB buffer.  It assumes a non-NULL pointer argument.
 *
 * pBuf:    pointer to the DIB image
 *--(byronc)-----------------------------------------------------------------*/
HRESULT VerticalFlip(
    BYTE    *pBuf)
{
    HRESULT             hr = S_OK;
    LONG                lHeight;
    LONG                lWidth;
    BITMAPINFOHEADER    *pbmih;
    PBYTE               pTop    = NULL;
    PBYTE               pBottom = NULL;

    pbmih = (BITMAPINFOHEADER*) pBuf;

    //
    //  If not a TOPDOWN dib then no need to flip
    //

    if (pbmih->biHeight > 0) {
        return S_OK;
    }
    //
    //  Set Top pointer, width and height.  Make sure the bitmap height
    //  is positive.
    //

    pTop = pBuf + pbmih->biSize + ((pbmih->biClrUsed) * sizeof(RGBQUAD));
    lWidth = ((pbmih->biWidth * pbmih->biBitCount + 31) / 32) * 4;
    pbmih->biHeight = abs(pbmih->biHeight);
    lHeight = pbmih->biHeight;

    //
    //  Allocat a temp scan line buffer
    //

    PBYTE pTempBuffer = (PBYTE)LocalAlloc(LPTR, lWidth);

    if (pTempBuffer) {
        LONG  index;

        pBottom = pTop + (lHeight-1) * lWidth;
        for (index = 0;index < (lHeight/2);index++) {

            //
            //  Swap Top and Bottom lines
            //

            memcpy(pTempBuffer, pTop, lWidth);
            memcpy(pTop, pBottom, lWidth);
            memcpy(pBottom,pTempBuffer, lWidth);

            pTop    += lWidth;
            pBottom -= lWidth;
        }
        LocalFree(pTempBuffer);
    } else {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiaitem.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiaitem.h
 * Author:	Samuel Clement (samclem)
 * Date:	Tue Aug 17 17:20:49 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Description:
 * 	Contains the the dispatch interface to IWiaItems which represent devices
 *	Images and other useful wia things.
 *
 * History:
 * 	17 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIAITEM_H_
#define _WIAITEM_H_

#define CLIPBOARD_STR_W   L"clipboard"

/*-----------------------------------------------------------------------------
 * 
 * Class:		CWiaItem
 * Syniosis:	Provides a scriptable interface to the IWiaItem which
 * 				corresponds to a particular device.
 * 				
 *--(samclem)-----------------------------------------------------------------*/

class ATL_NO_VTABLE CWiaItem :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IWiaDispatchItem, &IID_IWiaDispatchItem, &LIBID_WIALib>,
	public IObjectSafetyImpl<CWiaDeviceInfo, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CWiaItem();
	
	DECLARE_TRACKED_OBJECT
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	STDMETHOD_(void, FinalRelease)();


	BEGIN_COM_MAP(CWiaItem)
		COM_INTERFACE_ENTRY(IWiaDispatchItem)
		COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()

	// Non-interface methods for internal use
	HRESULT CacheProperties( IWiaPropertyStorage* pWiaStg );
	HRESULT AttachTo( CWia* pWia, IWiaItem* pWiaItem );
	void SendTransferComplete(BSTR bstrFilename );

	// IWiaDispatchItem
    STDMETHOD(GetItemsFromUI)( WiaFlag Flags, WiaIntent Intent, ICollection** ppCollection );
	STDMETHOD(GetPropById)( WiaItemPropertyId Id, VARIANT* pvaOut );
	STDMETHOD(Transfer)( BSTR bstrFilename, VARIANT_BOOL bAsyncTransfer);
    STDMETHOD(TakePicture)( IWiaDispatchItem** ppDispItem );
	STDMETHOD(get_Children)( ICollection** ppCollection );
	STDMETHOD(get_ItemType)( BSTR* pbstrType );

	// WIA_DPC_xxx
	STDMETHOD(get_ConnectStatus)( BSTR* pbstrStatus );
	STDMETHOD(get_Time)( BSTR* pbstrTime );
	STDMETHOD(get_FirmwareVersion)( BSTR* pbstrVersion );

	// WIA_IPA_xxx
	STDMETHOD(get_Name)( BSTR* pbstrName );
	STDMETHOD(get_FullName)( BSTR* pbstrFullName );
	STDMETHOD(get_Width)( long* plWidth );
	STDMETHOD(get_Height)( long* plHeight );

	// WIA_IPC_xxx
	STDMETHOD(get_ThumbWidth)( long* plWidth );
	STDMETHOD(get_ThumbHeight)( long* plHeight );
	STDMETHOD(get_Thumbnail)( BSTR* pbstrPath );
	STDMETHOD(get_PictureWidth)( long* plWidth );
	STDMETHOD(get_PictureHeight)( long* pdwHeight );

	// Static methods for transfering and caching a thumbnail
	// bitmap. Currently this only works for bitmaps.
	static HRESULT TransferThumbnailToCache( IWiaItem* pItem, BYTE** ppbThumb, DWORD* pcbThumb );

protected:
	CWia*					m_pWia;
	IWiaItem*				m_pWiaItem;
	IWiaPropertyStorage*	m_pWiaStorage;	

	// Commonly used properties, prevent: Process -> WIA -> Device 
	DWORD					m_dwThumbWidth;
	DWORD					m_dwThumbHeight;
	BSTR					m_bstrThumbUrl;
	DWORD					m_dwItemWidth;
	DWORD					m_dwItemHeight;

	friend class CWiaDataTransfer;
};


/*-----------------------------------------------------------------------------
 * 
 * Class: 		CWiaDataTransfer
 * Synopsis:	This handles the async transfer of the data from WIA. this 
 * 				object is only used from within this function object and
 * 				therefore doesn't need to be exposed anywhere else.
 * 				
 *--(samclem)-----------------------------------------------------------------*/
class ATL_NO_VTABLE CWiaDataTransfer :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IWiaDataCallback
{
public:
	// used in making the call to DoAsyncTransfer
	struct ASYNCTRANSFERPARAMS
	{
		// this is the stream which contians the marshalled interface
		IStream*	pStream;
		// the file name that we want to transfer to
		BSTR		bstrFilename;
		// the CWiaItem object that we are transferring from
		CWiaItem*	pItem;
	};

	DECLARE_TRACKED_OBJECT
	BEGIN_COM_MAP(CWiaDataTransfer)
		COM_INTERFACE_ENTRY(IWiaDataCallback)
	END_COM_MAP()

	CWiaDataTransfer();
	STDMETHOD_(void, FinalRelease)();

	// this is called to do an async transfer. You must pass an 
	// ASYNCTRANSFERPARAMS structure in for pvParams.
	static DWORD WINAPI DoAsyncTransfer( LPVOID pvParams );

	HRESULT TransferComplete();
	HRESULT Initialize( CWiaItem* pItem, BSTR bstrFilename );
	STDMETHOD(BandedDataCallback)( LONG lMessage, LONG lStatus, LONG lPercentComplete,
	        LONG lOffset, LONG lLength, LONG lReserved, LONG lResLength, BYTE *pbBuffer );

private:
	size_t		m_sizeBuffer;
	BYTE*		m_pbBuffer;
	CComBSTR    m_bstrOutputFile;
	CWiaItem*	m_pItem;
};

#endif //_WIAITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiacache.h ===
/*-----------------------------------------------------------------------------
 *
 * File: 	wiacache.h	
 * Author:	Samuel Clement (samclem)
 * Date:	Thu Sep 09 15:02:42 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 * 
 * This declares the CWiaCacheManager this object is used to cache various
 * things that we want to keep around.  For example, we always want to keep
 * the devices around. We also want to keep thumbnails cached.  
 *
 * History:
 * 	09 Sep 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIACACHE_H_
#define _WIACACHE_H_

struct THUMBNAILCACHEITEM
{
	BYTE*	pbThumb;
	DWORD	cbThumb;
};

typedef CInterfaceCache<CComBSTR,IWiaItem> CWiaItemCache;
typedef std::map<CComBSTR, THUMBNAILCACHEITEM*> CThumbnailCache;

/*-----------------------------------------------------------------------------
 * 
 * Class:		CWiaCacheManager
 * Synopsis:	This is a singleton class which handles managing the WIA
 * 				protocol. This handles cacheing device pointers and bitmap
 * 				data so that it only needs to be transfered once.  It exists 
 * 				for the entire lifetime of the DLL. 
 *
 * Note:		You must call CWiaCacheManager::Init() before trying to
 * 				use this object. 
 * 				In order to free te memory it contains you must call 
 * 				CWiaCacheManager::DeInit().
 * 				You cannot actually directly create an instance of this class
 * 				instead you must do this:
 *
 * 				CWiaCacheManager* pCache = CWiaCacheManager::GetInstance();
 * 				CFoo::CFoo() : m_pWiaCache( CWiaCacheManager::GetInstance() )
 * 				
 *--(samclem)-----------------------------------------------------------------*/
class CWiaCacheManager
{
public:
	DECLARE_TRACKED_OBJECT

	// Device caching methods
	bool GetDevice( CComBSTR bstrId, IWiaItem** ppDevice );
	bool AddDevice( CComBSTR bstrId, IWiaItem* pDevice );
	bool RemoveDevice( CComBSTR bstrId );

	// thumbnail caching methods (including allocation).  In order
	// to cache a thumbnail it must be allocated using
	// 	AllocThumbnail() which puts it on our local heap
	bool GetThumbnail( CComBSTR bstrFullItemName, BYTE** ppbThumb, DWORD* pcbThumb );
	bool AddThumbnail( CComBSTR bstrFullItemName, BYTE* pbThumb, DWORD cbThumb );
	bool RemoveThumbnail( CComBSTR bstrFullItemName );
	bool AllocThumbnail( DWORD cbThumb, BYTE** ppbThumb );
	void FreeThumbnail( BYTE* pbThumb );

	// this is the only way to get an instance of this class. You
	// cannot new or declare this class a a stack variable it will
	// fail to compile.
	static inline CWiaCacheManager* GetInstance()
	{
		Assert( sm_pManagerInstance != NULL && "Need to call CWiaCacheManager::Init() first" );
		return sm_pManagerInstance;
	}
	
private:
	// Construction/Descruction methods
	CWiaCacheManager();
	~CWiaCacheManager();
	bool Initialize();
	
	// We are thread safe, so we need to provide methods for locking
	// and unlocking ourselves.
	inline void Lock() { EnterCriticalSection( &m_cs ); }
	inline void Unlock() { LeaveCriticalSection( &m_cs ); }
	
	// member variables
	CWiaItemCache		m_icItemCache;
	CThumbnailCache		m_tcThumbnails;
	CRITICAL_SECTION	m_cs;
	HANDLE				m_hThumbHeap;

	// single static instance, setup in Init()
	static CWiaCacheManager* 	sm_pManagerInstance;
	
public:
	// Static initialization and destruction which need to called in 
	// order to use this object
	static bool Init();
	static bool Uninit();
};

#endif //_WIACACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiaproto.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:    wiaproto.cpp
 * Author:  Samuel Clement (samclem)
 * Date:    Fri Aug 27 15:16:44 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 *  This contains the implementation of the "wia" internet protocol. This
 *  is a pluggable protocol that handles downloading thumbnails from a wia
 *  device.
 *
 * History:
 *  27 Aug 1999:        Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

// declare some debugging tags
DeclareTag( tagWiaProto, "!WiaProto", "Wia Protocol debug information" );

const WCHAR*    k_wszProtocolName   = L"wia";
const WCHAR*    k_wszColonSlash     = L":///";
const WCHAR*    k_wszSeperator      = L"?";
const WCHAR*    k_wszThumb          = L"thumb";
const WCHAR*    k_wszExtension      = L".bmp";

const int       k_cchProtocolName   = 3;
const int       z_cchThumb          = 5;

const WCHAR     k_wchSeperator      = L'?';
const WCHAR     k_wchColon          = L':';
const WCHAR     k_wchFrontSlash     = L'/';
const WCHAR     k_wchPeriod         = L'.';
const WCHAR     k_wchEOS            = L'\0';

enum 
{
    k_dwTransferPending             = 0,
    k_dwTransferComplete            = 1,
};

/*-----------------------------------------------------------------------------
 * CWiaProtocol
 *
 * Create a new CWiaProtocol. This simply initializes all the members to
 * a known state so that we can then test against them
 *--(samclem)-----------------------------------------------------------------*/
CWiaProtocol::CWiaProtocol() 
    : m_pFileItem( NULL ), m_ulOffset( 0 )
{
    TRACK_OBJECT( "CWiaProtocol" );
    m_pd.dwState = k_dwTransferPending;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::FinalRelease
 *
 * Called when we are finally released to cleanup any resources that we 
 * want to cleanup.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaProtocol::FinalRelease()
{
    if ( m_pFileItem )
        m_pFileItem->Release();
    m_pFileItem = NULL;
}

/*-----------------------------------------------------------------------------
 *
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Start( LPCWSTR szUrl, IInternetProtocolSink* pOIProtSink,
            IInternetBindInfo* pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved )
{
    CWiaCacheManager* pCache= CWiaCacheManager::GetInstance();
    CComPtr<IWiaItem> pDevice;
    CComBSTR bstrDeviceId   ;
    CComBSTR bstrItem       ;
    TTPARAMS* pParams       = NULL;
    HANDLE hThread          = NULL;
    DWORD dwThreadId        = 0;
    LONG lItemType          = 0;
    BYTE* pbThumb           = NULL;
    DWORD cbThumb           = 0;
    HRESULT hr;

    // the first thing that we want to do is to attempt to crack the URL,
    // this can be an involved process so we have a helper method that
    // handles doing this for us.
    hr = THR( CrackURL( szUrl, &bstrDeviceId, &bstrItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // do we already have a cached version of this item, if so we can avoid
    // having to do anything else
    if ( pCache->GetThumbnail( bstrItem, &pbThumb, &cbThumb ) )
    {
        TraceTag((tagWiaProto, "Using cached thumbnail" ));

        m_pd.pData = pbThumb;
        m_pd.cbData = cbThumb;
        m_pd.dwState = k_dwTransferComplete;

        hr = THR( pOIProtSink->ReportData( BSCF_LASTDATANOTIFICATION, cbThumb, cbThumb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pOIProtSink->ReportResult( hr, hr, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }
    else
    {
        if ( !pCache->GetDevice( bstrDeviceId, &pDevice ) )
        {
            hr = THR( CreateDevice( bstrDeviceId, &pDevice ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        
            pCache->AddDevice( bstrDeviceId, pDevice );
        }
        else
        {
            TraceTag((tagWiaProto, "Using cached device pointer" ));
        }

        hr = THR( pDevice->FindItemByName( 0, bstrItem, &m_pFileItem ) );
        if ( FAILED( hr ) || S_FALSE == hr )
        {
            TraceTag((tagWiaProto, "unable to locate item: %S", bstrItem ));
            hr = INET_E_RESOURCE_NOT_FOUND;
            goto Cleanup;
        }

        // the last thing we want to verify is that the item is an image
        // and a file, otherwise we don't want anything to do with it
        hr = THR( m_pFileItem->GetItemType( &lItemType ) );
        if ( !( lItemType & WiaItemTypeFile ) && 
                !( lItemType & WiaItemTypeImage ) )
        {
            TraceTag((tagWiaProto, "unsupported wia item type for download" ));
            hr = INET_E_INVALID_REQUEST;
            goto Cleanup;
        }

        // at this point everything is happy in our land. we have a valid
        // thing to download from. We now need to create the thread which
        // will do the main work
        pParams = reinterpret_cast<TTPARAMS*>(CoTaskMemAlloc( sizeof( TTPARAMS ) ) );
        if ( !pParams )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( CoMarshalInterThreadInterfaceInStream(
                    IID_IWiaItem,
                    m_pFileItem,
                    &pParams->pStrm ) );
        if ( FAILED( hr ) )
        {
            TraceTag((tagWiaProto, "error marshalling interface" ));
            goto Cleanup;
        }
        
        pParams->pInetSink = pOIProtSink;
        pParams->pInetSink->AddRef();

        hThread = CreateThread( NULL,
                        0,
                        CWiaProtocol::TransferThumbnail,
                        pParams,
                        0,
                        &dwThreadId );
        
        if ( NULL == hThread )
        {
            pParams->pInetSink->Release();
            pParams->pStrm->Release();
            CoTaskMemFree( pParams );
            hr = E_FAIL;
            goto Cleanup;
        }
        else
        {
            CloseHandle(hThread);
        }
    
        TraceTag((tagWiaProto, "Started transfer thread: id(%x)", dwThreadId ));
    }

Cleanup:
    if ( FAILED( hr ) )
    {
        if ( m_pFileItem )
            m_pFileItem->Release();
        m_pFileItem = NULL;
    }
    
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Continue
 *
 * This is called to pass data back from the the other threads. It lets
 * the controlling thread know we have data.
 * 
 * Note:    Copy the data from the pointer, DON'T use thier pointer, they will
 *          free it following the return of this call.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Continue( PROTOCOLDATA* pProtocolData )
{
    if ( k_dwTransferComplete == m_pd.dwState )
        return E_UNEXPECTED;

    memcpy( &m_pd, pProtocolData, sizeof( PROTOCOLDATA ) );
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocl::Abort
 *
 * This is called to abort our transfer.  this is NYI.  However, it would
 * need to kill our thread if it is still running and free our data. However,
 * it is perfectly harmless if the thread keeps running.
 *
 * hrReason:    the reason for the abort
 * dwOptions:   the options for this abourt
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Abort( HRESULT hrReason, DWORD dwOptions )
{

    TraceTag((tagWiaProto, "NYI: Abort hrReason=%hr", hrReason ));
    return E_NOTIMPL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Terminate
 *
 * This is called when the transfer is finished. This is responsible for
 * cleaning anything up that we might need to do. We currently don't have
 * anything to clean up.  So this simply returns S_OK.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Terminate( DWORD dwOptions )
{
    // Nothing to do.
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Suspend
 *
 * This is called to suspend the transfer. This is currently not implemenet
 * inside of trident, so our methods just return E_NOTIMPL
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Suspend()
{
    TraceTag((tagWiaProto, "NYI: Suspend" ));
    return E_NOTIMPL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Resume
 *
 * This is called to resume a suspended transfer. This is not suppored 
 * inside of URLMON, so we just return E_NOTIMPL
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Resume()
{
    TraceTag((tagWiaProto, "NYI: Resume" ));
    return E_NOTIMPL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Read
 *
 * This is called to read data from our protocol. this copies cb bytes to
 * the buffer passed in. Or it will copy what ever we have.
 *
 * pv:      the buffer that we want to copy the data to
 * cb:      the size fo buffer, max bytes to copy
 * pcbRead: Out, the number of bytes that we actually copied to the buffer
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Read( void* pv, ULONG cb, ULONG* pcbRead)
{
    // validate our arguments
    if ( !pv || !pcbRead )
        return E_POINTER;

    *pcbRead = 0;
    
    // is the transfer currently pending? if so then
    // we don't actually want to do anything here.
    if ( k_dwTransferPending == m_pd.dwState )
        return E_PENDING;

    // do we actually have data to copy? if the offset is greater
    // or equal to the size of our data then we don't have an data to
    // copy so return S_FALSE
    if ( m_ulOffset >= m_pd.cbData )
        return S_FALSE;

    // figure out how much we are going to copy
    DWORD dwCopy = m_pd.cbData - m_ulOffset;
    if ( dwCopy >= cb )
        dwCopy = cb;

    // if we have negative memory to copy, or 0, then we are done and we don't
    // actually want to do anything besides return S_FALSE
    if ( dwCopy <= 0 )
        return S_FALSE;

    // do the memcpy and setup our state and the return value
    memcpy( pv, reinterpret_cast<BYTE*>(m_pd.pData) + m_ulOffset, dwCopy );
    m_ulOffset += dwCopy;
    *pcbRead = dwCopy;

    return ( dwCopy == cb ? S_OK : S_FALSE );
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Seek
 *
 * Called to seek our data. However, we don't support seeking so this just
 * returns E_FAIL
 *
 * dlibMove:            how far to move the offset
 * dwOrigin:            indicates where the move shoudl begin
 * plibNewPosition:     The new position of the offset
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // Don't support
    return E_FAIL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::LockRequest
 *
 * Called to lock the data. we don't need to lock our data, so this just 
 * returns S_OK
 *
 * dwOptions:   reserved, will be 0.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::LockRequest( DWORD dwOptions )
{
    //Don't support locking
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::UnlockRequest
 *
 * Called to unlock our data. We don't need or support locking, so this
 * doesn't do anything besides return S_OK.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::UnlockRequest()
{
    //Don't support locking
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::CrackURL
 *
 * This handles breaking appart a URL which is passed in to us. This will 
 * return S_OK if it is a valid URL and we can work with it. otherwise this
 * will return INET_E_INVALID_URL
 *
 * bstrUrl:         the full url to be cracked
 * pbstrDeviceId:   Out, recieves the device id portion of the URL
 * pbstrItem:       Out, recieves the item portion of the URL
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaProtocol::CrackURL( CComBSTR bstrUrl, BSTR* pbstrDeviceId, BSTR* pbstrItem )
{
    WCHAR* pwchUrl = reinterpret_cast<WCHAR*>((BSTR)bstrUrl);
    WCHAR* pwch = NULL;
    WCHAR awch[INTERNET_MAX_URL_LENGTH] = { 0 };
    HRESULT hr = INET_E_INVALID_URL;
    
    Assert( pbstrDeviceId && pbstrItem );
    
    *pbstrDeviceId = NULL;
    *pbstrItem = NULL;

    if (SysStringLen(bstrUrl) >= INTERNET_MAX_URL_LENGTH)
        goto Cleanup;
    
    /*
     * We are going to use the SHWAPI functions to parse this URL. Our format
     * is very simple.
     *
     * proto:///<deviceId>?<item>
     */
    if ( StrCmpNIW( k_wszProtocolName, pwchUrl, k_cchProtocolName ) )
        goto Cleanup;

    pwchUrl += k_cchProtocolName;
    while ( *pwchUrl == k_wchColon || *pwchUrl == k_wchFrontSlash )
        pwchUrl++;

    if ( !(*pwchUrl ) )
        goto Cleanup;

    // get the device portion of the URL
    pwch = StrChrIW( pwchUrl, k_wchSeperator );
    if ( !pwch )
        goto Cleanup;
    
    StrCpyNW( awch, pwchUrl, ( pwch - pwchUrl + 1 ) );
    *pbstrDeviceId = SysAllocString( awch );
    if ( !*pbstrDeviceId )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // adjust our pointer past the '?'
    pwchUrl = pwch + 1;
    if ( !*pwchUrl )
        goto Cleanup;

    if ( StrCmpNIW( k_wszThumb, pwchUrl, z_cchThumb ) )
        goto Cleanup;

    // get the command portion of the URL
    pwch = StrChrIW( pwchUrl, k_wchSeperator );
    
    if ( !pwch )
        goto Cleanup;

    // adjust our pointer past the '?'
    pwchUrl = pwch + 1;
    if ( !*pwchUrl )
        goto Cleanup;
    
    // attempt to get the item portion of the url
    pwch = StrRChrIW( pwchUrl, 0, k_wchPeriod );
    awch[0] = k_wchEOS;
    
    if ( pwch )
        StrCpyNW( awch, pwchUrl, ( pwch - pwchUrl + 1) );
    else
        StrCpyW( awch, pwchUrl );
    
    *pbstrItem = SysAllocString( awch );
    if ( !*pbstrItem )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TraceTag((tagWiaProto, "URL: Device=%S, Item=%S",
                *pbstrDeviceId, *pbstrItem ));
    
    // everything was ok
    return S_OK;
    
Cleanup:
    if ( FAILED( hr ) )
    {
        SysFreeString( *pbstrDeviceId );
        SysFreeString( *pbstrItem );
    }

    return INET_E_INVALID_URL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::CreateDevice
 *
 * This is a helper method which handles creating a wia device with the
 * specified id. this instances a IWiaDevMgr object and then attempts
 * to create the device.
 *
 * bstrId:      the id of the device to create
 * ppDevice:    Out, recieves the pointer to the newly created device
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaProtocol::CreateDevice( BSTR bstrId, IWiaItem** ppDevice )
{
    CComPtr<IWiaItem>   pDevice;
    CComPtr<IWiaDevMgr> pDevMgr;
    HRESULT hr;

    Assert( ppDevice );
    *ppDevice = 0;

    // first we need to create our device manager
    hr = THR( pDevMgr.CoCreateInstance( CLSID_WiaDevMgr ) );
    if ( FAILED( hr ) )
        return hr;

    // now we need the device manager to create a device
    hr = THR( pDevMgr->CreateDevice( bstrId, &pDevice ) );
    if ( FAILED( hr ) )
        return hr;

    // copy our device pointer over
    return THR( pDevice.CopyTo( ppDevice ) );
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::CreateURL      [static]
 *
 * This method creates a URL for the given item.  This doesn't verifiy the
 * item. Other than making sure it has a root so that we can build the URL.
 * This may return an invalid URL.  It is important to verify that the item
 * can actually have a thumbnail before calling this.  
 *
 * Note: in order to create a thumbnail:
 *          lItemType & ( WiaItemTypeFile | WiaItemTypeImage )
 *
 * pItem:       The wia item that we want to generate the URL for.
 * pbstrUrl:    Out, recieves the finished URL
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaProtocol::CreateURL( IWiaItem* pItem, BSTR* pbstrUrl )
{
    HRESULT hr;
    CComBSTR bstrUrl;
    CComPtr<IWiaItem> pRootItem;
    CComQIPtr<IWiaPropertyStorage> pWiaStg;
    CComQIPtr<IWiaPropertyStorage> pRootWiaStg;
    PROPSPEC spec = { PRSPEC_PROPID, WIA_DIP_DEV_ID };
    PROPVARIANT va;
    
    if ( !pbstrUrl || !pItem )
        return E_POINTER;

    PropVariantInit( &va );


    // get the interfaces that we need
    pWiaStg = pItem;
    if ( !pWiaStg )
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR( pItem->GetRootItem( &pRootItem ) );
    if ( FAILED( hr ) || !pRootItem )
        goto Cleanup;

    pRootWiaStg = pRootItem;
    if ( !pRootWiaStg )
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    // We need the device ID of the root item, and if we can't
    // get it then we don't have anything else to do.
    hr = THR( pRootWiaStg->ReadMultiple( 1, &spec, &va ) );
    if ( FAILED( hr ) || va.vt != VT_BSTR )
        goto Cleanup;

    // start building our URL
    bstrUrl.Append( k_wszProtocolName );
    bstrUrl.Append( k_wszColonSlash );
    bstrUrl.AppendBSTR( va.bstrVal );
    bstrUrl.Append( k_wszSeperator );
    bstrUrl.Append( k_wszThumb ); 
    bstrUrl.Append( k_wszSeperator );

    // we need to get the full item name from the item, because
    // we need to tack that on to the end
    PropVariantClear( &va );
    spec.propid = WIA_IPA_FULL_ITEM_NAME;
    hr = THR( pWiaStg->ReadMultiple( 1, &spec, &va ) );
    if ( FAILED( hr ) || va.vt != VT_BSTR )
        goto Cleanup;

    bstrUrl.AppendBSTR( va.bstrVal );
    bstrUrl.Append( k_wszExtension );

    TraceTag((tagWiaProto, "Created URL: %S", (BSTR)bstrUrl ));
    
    *pbstrUrl = bstrUrl.Copy();
    if ( !*pbstrUrl )
        hr = E_OUTOFMEMORY;
    
Cleanup:
    PropVariantClear( &va );
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::TransferThumbnail  [static]
 *
 * This handles the actual transfer of the thumbnail.  This is only called
 * however, if we don't already have a cached copy of the thumbnail. Otherwise
 * we can simply use that one.
 *
 * Note: we spawn a thread with this function, which is why its static
 *
 * pvParams:    a pointer to a TTPARAMS structure, which contains a pointer
 *              to the IInternetProtoclSink and the IStream where the
 *              item is marshalled.
 *--(samclem)-----------------------------------------------------------------*/
DWORD WINAPI
CWiaProtocol::TransferThumbnail( LPVOID pvParams )
{
    CComPtr<IWiaItem> pItem;
    CComPtr<IInternetProtocolSink> pProtSink;
    IStream* pStrm                      = NULL;
    DWORD cbData                        = 0;
    BYTE* pbData                        = NULL;
    TTPARAMS* pParams = reinterpret_cast<TTPARAMS*>(pvParams);
    PROTOCOLDATA* ppd = NULL;
    HRESULT hr;
    HRESULT hrCoInit;
    
    Assert( pParams );

    pProtSink = pParams->pInetSink;
    pStrm = pParams->pStrm;

    hrCoInit = THR( CoInitialize( NULL ) );
    
    // we no longer need our params, so we can free them now. we
    // will handle freeing the params here since its simpler
    pParams->pInetSink->Release();
    CoTaskMemFree( pParams );
    pParams = NULL;
    
    // get the IWiaItem from the stream
    hr = THR( CoGetInterfaceAndReleaseStream(
                pStrm,
                IID_IWiaItem,
                reinterpret_cast<void**>(&pItem) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // allocate a protocol data structure so that we can give this back to 
    // the other thread.  We will allocate this here. it may be freed if
    // something fails
    ppd = reinterpret_cast<PROTOCOLDATA*>(LocalAlloc( LPTR, sizeof( PROTOCOLDATA ) ) );
    if ( !ppd )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // use the utility method on CWiaItem to do the transfer
    hr = THR( CWiaItem::TransferThumbnailToCache( pItem, &pbData, &cbData ) );
    if ( FAILED( hr ) )
        goto Cleanup;
    
    ppd->pData = pbData;
    ppd->cbData = cbData;
    ppd->dwState = k_dwTransferComplete;

    // we are all done now, we can tell trident that we are 100% done
    // and then call switch
    hr = THR( pProtSink->Switch( ppd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pProtSink->ReportData(BSCF_LASTDATANOTIFICATION, cbData, cbData ) ); 
    
Cleanup:
    // post our result status back to the sink
    //TODO(Aug, 27) samclem:  implement the error string param
    if ( pProtSink )
        THR( pProtSink->ReportResult( hr, hr, NULL ) );

    if ( ppd )
        LocalFree( ppd );
    
    if ( SUCCEEDED( hrCoInit ) )
        CoUninitialize();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiadevinf.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiadevinf.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 15:47:16 1999
 * Description:
 * 	Defines the CWiaDeviceInfo object
 *
 * Copyright 1999 Microsoft Corporation
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::CWiaDeviceInfo
 *
 * Creates a new CWiaDevice info shell, does nothing until AttachTo() is 
 * called.
 *--(samclem)-----------------------------------------------------------------*/
CWiaDeviceInfo::CWiaDeviceInfo()
	: m_pWiaStorage( NULL ), m_pWia( NULL )
{
	TRACK_OBJECT( "CWiaDeviceInfo" );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::FinalRelease
 *
 * This handles the final release of this object. We need to release our 
 * pointer to the wia property storage.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaDeviceInfo::FinalRelease()
{
	if ( m_pWiaStorage )
		{
		m_pWiaStorage->Release();
		m_pWiaStorage = NULL;
		}
	
	if ( m_pWia )
		{
		m_pWia = NULL;
		}
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::AttachTo
 *
 * This method is internal to the server it is called when we want to attach
 * to a IWiaPropertyStorage for a device. this is used when building the
 * collection of device info. 
 *
 * see:	CWia::get_Devices()
 * 		
 * pStg:	the IWiaPropertyStorage to attach to. 		
 * pWia:	An IWia pointer for creating the device
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaDeviceInfo::AttachTo( IWiaPropertyStorage* pStg, IWia* pWia )
{
	if ( !pStg || !pWia )
		return E_POINTER;

	if ( m_pWiaStorage )
		return E_UNEXPECTED;
	
	m_pWiaStorage = pStg;
	m_pWiaStorage->AddRef();

	// Inorder to avoid a nasty circular referance this doesn't
	// AddRef the pWia pointer. This should be okay, since as long
	// as we exist the pWia can't go away anyhow.
	// Basically, the only thing we need this for is for calling
	m_pWia = pWia;

	return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::Create
 *
 * This creates a connection the IWiaItem which represents the device.
 * This simply delegates the call to IWia::Create() using the m_pWia 
 * member.
 *
 * ppDevice:	Out, recieves the IDispatch pointer for the device
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::Create( IWiaDispatchItem** ppDevice )
{
	VARIANT vaThis;
	HRESULT hr;

	if ( !m_pWia )
		return E_UNEXPECTED;
	
	VariantInit( &vaThis );
	vaThis.vt = VT_DISPATCH;
	hr = QueryInterface( IID_IDispatch, reinterpret_cast<void**>(&vaThis.pdispVal) );
	Assert( SUCCEEDED( hr ) );
	
	hr = m_pWia->Create( &vaThis, ppDevice );

	VariantClear( &vaThis );
	return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Id			[IWiaDeviceInfo]
 *
 * This gets the device Id for this device.  (WIA_DIP_DEV_ID)
 *
 * pbstrDeviceId:	Out, recieces the id of the device
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Id( BSTR* pbstrDeviceId )
{
	if ( !pbstrDeviceId )
		return E_POINTER;
	
	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_DEV_ID, pbstrDeviceId ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Name			[IWiaDeviceInfo]
 *
 * This gets the name of the device, this is a human readable name for
 * the device.	(WIA_DIP_DEV_NAME)
 *
 * pbstrName:	Out, recieves the device name
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Name( BSTR* pbstrName )
{
	if ( !pbstrName )
		return E_POINTER;

	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_DEV_NAME, pbstrName ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Type			[IWiaDeviceInfo]
 *
 * This gets the type of the device. This will return a BSTR representation
 * of the device, not the integer constant.  (WIA_DIP_DEV_TYPE)
 *
 * pBstrType:	Out, recieves the BSTR rep. of the device type
 * 				Values:	DigitalCamer, Scanner, Default.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Type( BSTR* pbstrType )
{
	PROPVARIANT vaProp;
	HRESULT hr;
	
	// WIA currently uses the STI device constants.  they also use the 
	// GET_STIDEVICE_TYPE() macro. This simply does a HIWORD() on the
	// value since the real property value is split into a major device
	// type and a minor device type.
	STRING_TABLE_DEF( StiDeviceTypeDefault, 		"Default" )
		STRING_ENTRY( StiDeviceTypeScanner, 		"Scanner" )
		STRING_ENTRY( StiDeviceTypeDigitalCamera,	"DigitalCamera" )
        STRING_ENTRY( StiDeviceTypeStreamingVideo,  "StreamingVideo")
	END_STRING_TABLE()

	if ( !pbstrType )
		return E_POINTER;

	hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DIP_DEV_TYPE, &vaProp ) );
	if ( FAILED( hr ) )
		return hr;

	DWORD devType = vaProp.ulVal;
	PropVariantClear( &vaProp );
	*pbstrType = SysAllocString( GetStringForVal( StiDeviceTypeDefault, GET_STIDEVICE_TYPE( devType ) ) );
	
	if ( !*pbstrType )
		return E_OUTOFMEMORY;
	
	return S_OK;	
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Port			[IWiaDeviceInfo]
 *
 * Gets the port that this device is attached to.  (WIA_DIP_PORT_NAME)
 *
 * pbstrPort:	Out, Recieves the name of the port.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Port( BSTR* pbstrPort )
{
	if ( !pbstrPort )
		return E_POINTER;
	
	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_PORT_NAME, pbstrPort ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_UIClsid		[IWiaDeviceInfo]
 *
 * Gets the CLSID for the UI associated with this device.  This returns the 
 * string representation of the GUID.	(WIA_DIP_UI_CLSID)
 *
 * pbstrGuidUI:		Out, recieves the CLSID for the UI.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_UIClsid( BSTR* pbstrGuidUI )
{
	if ( !pbstrGuidUI )
		return E_POINTER;

	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_UI_CLSID, pbstrGuidUI ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Manufacturer		[IWiaDeviceInfo]
 *
 * Gets the vendor of the device.	(WIA_DIP_VEND_DESC)
 *
 * pbstrVendor:		Out, recieves the vendor name
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Manufacturer( BSTR* pbstrVendor )
{
	if ( !pbstrVendor )
		return E_POINTER;
	
	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_VEND_DESC, pbstrVendor ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDevInfo::GetPropById				[IWiaDeviceInfo]
 *
 * Gets the valu of the property with the given prop id. this will return
 * the raw value of the property no translation.
 *
 * If the property is not found, or its a type that can't be converted into
 * a VARIANT. then VT_EMPTY is returned.
 *
 * propid:		the propid of the property as a dword
 * pvaOut:		the variant to fill with the value of the propery
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::GetPropById( WiaDeviceInfoPropertyId Id, VARIANT* pvaOut )
{
	PROPVARIANT vaProp;
	HRESULT hr;
	DWORD dwPropId = (DWORD)Id;

	if ( NULL == pvaOut )
		return E_POINTER;

	hr = THR( GetWiaProperty( m_pWiaStorage, dwPropId, &vaProp ) );
	if ( FAILED( hr ) )
		return hr;

	// Force this to VT_EMPTY if it failed
	hr = THR( PropVariantToVariant( &vaProp, pvaOut ) );
	if ( FAILED( hr ) )
		{
		TraceTag((0, "forcing value of property %ld to VT_EMPTY", dwPropId ));
		VariantInit( pvaOut );
		pvaOut->vt = VT_EMPTY;
		}

	PropVariantClear( &vaProp );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiascr.cpp ===
// ndmedia.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f ndmediaps.mk in the project directory.

#include "stdafx.h"
#include <initguid.h>
#include "wiadef.h"     // this is done on purpose to get the GUID for the commands
#include "wiascr_i.c"
#include "wiaproto.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Wia,         CWia)
    OBJECT_ENTRY(CLSID_SafeWia,     CSafeWia)
    OBJECT_ENTRY(CLSID_WiaProtocol, CWiaProtocol)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        RESTOREDEFAULTDEBUGSTATE

        _Module.Init(ObjectMap, hInstance, &LIBID_WIALib);
        DisableThreadLibraryCalls(hInstance);

        if ( !CWiaCacheManager::Init() )
        {
            TraceTag((tagError, "An error occured while initializing our cache" ));
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if ( !CWiaCacheManager::Uninit() )
        {
            TraceTag((tagError, "An error occured while Uninitializing our cache" ));
        }

        DUMPTRACKEDOBJECTS

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\child.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2001, MICROSOFT CORP.
*
*  TITLE:       Child.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for child items.
*
*******************************************************************************/

#include "pch.h"

// extern FORMAT_INFO *g_FormatInfo;
// extern UINT g_NumFormatInfo;

/**************************************************************************\
* BuildChildItemProperties
*
*   This helper creates the properties for a child item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildChildItemProperties(
    BYTE *pWiasContext
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::BuildChildItemProperties");

    HRESULT hr = S_OK;

    BOOL bBitmap;
    FORMAT_INFO *pFormatInfo;
    LONG pTymedArray[] = { TYMED_FILE, TYMED_CALLBACK };
    GUID *pFormatArray = NULL;

    BSTR      bstrFileExt       = NULL;


    //
    // Get the driver item context
    //
    ITEM_CONTEXT *pItemCtx;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, GetDrvItemContext failed"));
        return hr;
    }

    ITEM_INFO *pItemInfo = pItemCtx->ItemHandle;

    //
    // Set up properties that are used for all item types
    //
    CWiauPropertyList ItemProps;

    const INT NUM_ITEM_PROPS = 21;
    hr = ItemProps.Init(NUM_ITEM_PROPS);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, iten prop Init failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    INT index;

    //
    // WIA_IPA_ITEM_TIME
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    ItemProps.SetCurrentValue(index, &pItemInfo->Time);

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_FLAG);
    if (FAILED(hr)) goto failure;

    //
    // If device supports changing the read-only status, item access rights is r/w
    //
    LONG AccessRights;
    if (pItemInfo->bReadOnly)
        AccessRights = WIA_ITEM_READ;
    else
        AccessRights = WIA_ITEM_RD;

    if (pItemInfo->bCanSetReadOnly)
    {
        ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_FLAG);
        ItemProps.SetValidValues(index, AccessRights, AccessRights, WIA_ITEM_RD);
    }
    else
    {
        ItemProps.SetCurrentValue(index, AccessRights);
    }

    //
    // Set up non-folder properties
    //
    if (!(pItemInfo->bIsFolder))
    {
        //
        // WIA_IPA_PREFERRED_FORMAT
        //
        pFormatInfo = FormatCode2FormatInfo(pItemInfo->Format);
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, &(pFormatInfo->FormatGuid));

        bBitmap = IsEqualGUID(WiaImgFmt_BMP, pFormatInfo->FormatGuid);

        //
        // WIA_IPA_FILENAME_EXTENSION
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        if( pFormatInfo->ExtensionString[0] )
        {
            bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
        }
        else // unknown file extension, get it from filename
        {
            WCHAR *pwcsTemp = wcsrchr(pItemInfo->pName, L'.');
            if( pwcsTemp )
            {
                bstrFileExt = SysAllocString(pwcsTemp+1);
            }
            else
            {
                bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
            }
        }
        ItemProps.SetCurrentValue(index, bstrFileExt);

        //
        // WIA_IPA_TYMED
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_TYMED, WIA_IPA_TYMED_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        if (FAILED(hr)) goto failure;
        ItemProps.SetValidValues(index, TYMED_FILE, TYMED_FILE,
                                 sizeof(pTymedArray) / sizeof(pTymedArray[0]), pTymedArray);

        //
        // WIA_IPA_FORMAT
        //
        // First call drvGetWiaFormatInfo to get the valid formats
        //
        int NumFormats = 0;
        GUID *pFormatArray = NULL;
        hr = GetValidFormats(pWiasContext, TYMED_FILE, &NumFormats, &pFormatArray);
        if (FAILED(hr) || NumFormats == 0)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, GetValidFormats failed"));
            goto failure;
        }

        hr = ItemProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        if (FAILED(hr)) goto failure;
        ItemProps.SetValidValues(index, &(pFormatInfo->FormatGuid), &(pFormatInfo->FormatGuid),
                                 NumFormats, &pFormatArray);

        //
        // WIA_IPA_COMPRESSION
        //
        // This property is mainly used by scanners. Set to no compression.
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_COMPRESSION_NONE);

        //
        // WIA_IPA_ITEM_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        ItemProps.SetCurrentValue(index, pItemInfo->Size);

        //
        // WIA_IPA_MIN_BUFFER_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        LONG minBufSize;
        if (!bBitmap && pItemInfo->Size > 0)
            minBufSize = min(MIN_BUFFER_SIZE, pItemInfo->Size);
        else
            minBufSize = MIN_BUFFER_SIZE;
        ItemProps.SetCurrentValue(index, minBufSize);

    }

    //
    // Set up the image-only properties
    //
    if (m_FormatInfo[pItemInfo->Format].ItemType == ITEMTYPE_IMAGE)
    {
        //
        // WIA_IPA_DATATYPE
        //
        // This property is mainly used by scanners. Set to color since most camera
        // images will be color.
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_COLOR);

        //
        // WIA_IPA_PLANAR
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_PACKED_PIXEL);

        //
        // WIA_IPA_DEPTH
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Depth);

        //
        // WIA_IPA_CHANNELS_PER_PIXEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Channels);

        //
        // WIA_IPA_BITS_PER_CHANNEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->BitsPerChannel);


        //
        // WIA_IPA_PIXELS_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Width);

        //
        // WIA_IPA_BYTES_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        if (bBitmap)
            ItemProps.SetCurrentValue(index, pItemInfo->Width * 3);
        else
            ItemProps.SetCurrentValue(index, (LONG) 0);

        //
        // WIA_IPA_NUMBER_OF_LINES
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Height);


        //
        // WIA_IPC_THUMBNAIL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);

        //
        // WIA_IPC_THUMB_WIDTH
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbWidth);

        //
        // WIA_IPC_THUMB_HEIGHT
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbHeight);

        //
        // WIA_IPC_SEQUENCE
        //
        if (pItemInfo->SequenceNum > 0)
        {
            hr = ItemProps.DefineProperty(&index, WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            if (FAILED(hr)) goto failure;
            ItemProps.SetCurrentValue(index, pItemInfo->SequenceNum);
        }
    }

    // For video
#if 1
    if( ( pItemInfo->Format < (FORMAT_CODE)m_NumFormatInfo) &&
            (ITEMTYPE_VIDEO == m_FormatInfo[pItemInfo->Format].ItemType) )
    {
        //
        // WIA_IPC_THUMBNAIL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);

        //
        // WIA_IPC_THUMB_WIDTH
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbWidth);

        //
        // WIA_IPC_THUMB_HEIGHT
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbHeight);
    }
#endif
    //
    // Last step: send all the properties to WIA
    //
    hr = ItemProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, SendToWia failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    // Nb: hr is used for routine return code - careful to not overwrite it from here till return statement

    if (bstrFileExt) {
        SysFreeString(bstrFileExt);
        bstrFileExt = NULL;
    }

    if (pFormatArray)
        delete []pFormatArray;

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //
    failure:
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, DefineProperty failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);

        if (bstrFileExt) {
            SysFreeString(bstrFileExt);
            bstrFileExt = NULL;
        }

        if (pFormatArray)
            delete []pFormatArray;
        return hr;
}

/**************************************************************************\
* GetValidFormats
*
*   Calls drvGetWiaFormatInfo and makes a list of valid formats given
*   a tymed value. Caller is responsible for freeing the format array.
*
* Arguments:
*
*    pWiasContext - WIA service context
*    TymedValue - tymed value to search for
*    pNumFormats - pointer to value to receive number of formats
*    ppFormatArray - pointer to a pointer location to receive array address
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::GetValidFormats(
    BYTE *pWiasContext,
    LONG TymedValue,
    int *pNumFormats,
    GUID **ppFormatArray
    )
{
    HRESULT hr = S_OK;

    if (!ppFormatArray || !pNumFormats)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetValidFormats, invalid arg"));
        return E_INVALIDARG;
    }
    *ppFormatArray = NULL;
    *pNumFormats = 0;

    LONG NumFi = 0;
    WIA_FORMAT_INFO *pFiArray = NULL;
    LONG lErrVal = 0;
    hr = drvGetWiaFormatInfo(pWiasContext, 0, &NumFi, &pFiArray, &lErrVal);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetValidFormats, drvGetWiaFormatInfo failed"));
        return hr;
    }

    //
    // This will allocate more spots than necessary, but pNumFormats will be set correctly
    //
    GUID *pFA = new GUID[NumFi];

    if( !pFA )
        return E_OUTOFMEMORY;

    for (int count = 0; count < NumFi; count++)
    {
        if (pFiArray[count].lTymed == TymedValue)
        {
            pFA[*pNumFormats] = pFiArray[count].guidFormatID;
            (*pNumFormats)++;
        }
    }

    *ppFormatArray = pFA;

    return hr;
}

/**************************************************************************\
* ReadChildItemProperties
*
*   Update the properties for the child items.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::ReadChildItemProperties(
    BYTE           *pWiasContext,
    LONG            NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::ReadChildItemProperties");
    HRESULT hr = S_OK;

    if (!NumPropSpecs || !pPropSpecs)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, invalid arg"));
        return E_INVALIDARG;
    }

    //
    // Get the driver item context
    //
    ITEM_CONTEXT *pItemCtx;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, GetDrvItemContext failed"));
        return hr;
    }

    ITEM_INFO *pItemInfo = pItemCtx->ItemHandle;

    //
    // The only child property on a camera that could change is the item time
    //
    if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_ITEM_TIME))
    {
        PROPVARIANT propVar;
        PROPSPEC    propSpec;
        propVar.vt = VT_VECTOR | VT_UI2;
        propVar.caui.cElems = sizeof(SYSTEMTIME) / sizeof(WORD);
        propVar.caui.pElems = (WORD *) &pItemInfo->Time;
        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPA_ITEM_TIME;
        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar );
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, wiasWriteMultiple failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }


    //
    // For images & video, update the thumbnail properties if requested
    //
    ULONG uItemType;

    uItemType = m_FormatInfo[pItemInfo->Format].ItemType;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID, WIALOG_LEVEL1, ("ReadChildItemProperties, File %S, Type =%d", pItemInfo->pName, uItemType));

    PROPSPEC propSpecs[9];
    PROPVARIANT propVars[9];
    UINT nNumProps;

    // The following is needed because we delayed parsing these properties until read
    if( uItemType == ITEMTYPE_IMAGE || uItemType == ITEMTYPE_VIDEO )
    {
        //
        // Get the thumbnail if requested to update any of the thumbnail properties and
        // the thumbnail is not already cached.
        //
        PROPID propsToUpdate[] = {
            WIA_IPA_DEPTH,
            WIA_IPA_CHANNELS_PER_PIXEL,
            WIA_IPA_BITS_PER_CHANNEL,
            WIA_IPA_PIXELS_PER_LINE,
            WIA_IPA_BYTES_PER_LINE,
            WIA_IPA_NUMBER_OF_LINES,
            WIA_IPC_THUMB_WIDTH,
            WIA_IPC_THUMB_HEIGHT,
            WIA_IPC_THUMBNAIL
        };

        if (wiauPropsInPropSpec(NumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {

            if (!pItemCtx->pThumb)
            {
                hr = CacheThumbnail(pItemCtx, uItemType);
                if (FAILED(hr))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, CacheThumbnail failed"));
                    pItemInfo->ThumbWidth = 0;
                    pItemInfo->ThumbHeight = 0;
                    pItemCtx->ThumbSize = 0;
                    pItemCtx->pThumb = NULL;
                    // return hr;
                }
            }

           //
            // Update the related thumbnail properties. Update the thumb width and height in case
            // the device didn't report them in the ObjectInfo structure (they are optional there).
            //
            propSpecs[0].ulKind = PRSPEC_PROPID;
            propSpecs[0].propid = WIA_IPC_THUMB_WIDTH;
            propVars[0].vt = VT_I4;
            propVars[0].lVal = pItemInfo->ThumbWidth;

            propSpecs[1].ulKind = PRSPEC_PROPID;
            propSpecs[1].propid = WIA_IPC_THUMB_HEIGHT;
            propVars[1].vt = VT_I4;
            propVars[1].lVal = pItemInfo->ThumbHeight;

            propSpecs[2].ulKind = PRSPEC_PROPID;
            propSpecs[2].propid = WIA_IPC_THUMBNAIL;
            propVars[2].vt = VT_VECTOR | VT_UI1;
            propVars[2].caub.cElems = pItemCtx->ThumbSize;
            propVars[2].caub.pElems = pItemCtx->pThumb;

            if( uItemType == ITEMTYPE_IMAGE )
            {
                propSpecs[3].ulKind = PRSPEC_PROPID;
                propSpecs[3].propid = WIA_IPA_DEPTH;
                propVars[3].vt = VT_I4;
                propVars[3].lVal = pItemInfo->Depth;

                propSpecs[4].ulKind = PRSPEC_PROPID;
                propSpecs[4].propid = WIA_IPA_CHANNELS_PER_PIXEL;
                propVars[4].vt = VT_I4;
                propVars[4].lVal = pItemInfo->Channels;

                propSpecs[5].ulKind = PRSPEC_PROPID;
                propSpecs[5].propid = WIA_IPA_BITS_PER_CHANNEL;
                propVars[5].vt = VT_I4;
                propVars[5].lVal = pItemInfo->BitsPerChannel;

                propSpecs[6].ulKind = PRSPEC_PROPID;
                propSpecs[6].propid = WIA_IPA_PIXELS_PER_LINE;
                propVars[6].vt = VT_I4;
                propVars[6].lVal = pItemInfo->Width;

                propSpecs[7].ulKind = PRSPEC_PROPID;
                propSpecs[7].propid = WIA_IPA_BYTES_PER_LINE;
                propVars[7].vt = VT_I4;
                propVars[7].lVal = (pItemInfo->Width * pItemInfo->Depth) >> 3;

                propSpecs[8].ulKind = PRSPEC_PROPID;
                propSpecs[8].propid = WIA_IPA_NUMBER_OF_LINES;
                propVars[8].vt = VT_I4;
                propVars[8].lVal = pItemInfo->Height;

                nNumProps = 9;
            } else {
                nNumProps = 3;
            }

            hr = wiasWriteMultiple(pWiasContext, nNumProps, propSpecs, propVars);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, wiasWriteMultiple for size properties failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
        }  // end of IF wiauPropsInProp

    }  // end of IF Image or Video

    return hr;
}



//
// This function caches the thumbnail into the given ITEM_CONTEXT
//
// Input:
//   pItemCtx -- the designated ITEM_CONTEXT
//
HRESULT
CWiaCameraDevice::CacheThumbnail(ITEM_CONTEXT *pItemCtx, ULONG uItemType)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::CacheThumbnail");
    HRESULT hr = S_OK;

    //
    // Local variables
    //
    ITEM_INFO *pItemInfo = NULL;
    BYTE *pDest = NULL;
    INT iThumbSize = 0;
    BYTE *pNativeThumb = NULL;
    BOOL bGotNativeThumbnail=TRUE;
    BMP_IMAGE_INFO BmpImageInfo;
    INT iSize=0;

    //
    // Check arguments
    //
    if (!pItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CacheThumbnail, invalid arg"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Make sure thumbnail isn't already created
    //
    if (pItemCtx->pThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CacheThumbnail, thumbnail is already cached"));
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Get the thumbnail from the camera in it's native format
    //
    pItemInfo = pItemCtx->ItemHandle;
    pItemInfo->ThumbWidth = 0;
    pItemInfo->ThumbHeight = 0;
    pItemCtx->ThumbSize = 0;
    pItemCtx->pThumb = NULL;


    pDest=NULL;
    iSize=0;

    if( uItemType == ITEMTYPE_VIDEO )
    {
        hr = m_pDevice->CreateVideoThumbnail(pItemInfo, &iSize, &pDest, &BmpImageInfo);
    }
    else
    {
        hr = m_pDevice->CreateThumbnail(pItemInfo, &iSize, &pDest, &BmpImageInfo);
    }

    if (FAILED(hr))
    {
       WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CacheThumbnail, CreateThumbnail failed"));
       goto Cleanup;
    }

    pItemInfo->ThumbWidth = BmpImageInfo.Width;
    pItemInfo->ThumbHeight = BmpImageInfo.Height;
 //   pItemInfo->ThumbFormat = TYPE_BMP;

    //
    // Cache the buffer returned from ConvertToBmp in the driver item context. Set pDest
    // to NULL, so it won't be freed below.
    //
    pItemCtx->ThumbSize = iSize;
    pItemCtx->pThumb = pDest;
    pDest = NULL;


Cleanup:
    if (pNativeThumb) {
        delete []pNativeThumb;
        pNativeThumb = NULL;
    }

    if (pDest) {
        delete []pDest;
        pDest = NULL;
    }

    return hr;
}

//
// This function transfers native data to the application without translating it.
//
HRESULT
CWiaCameraDevice::AcquireData(
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pBuf,
    LONG lBufSize,
    BOOL bConverting
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::AcquireData");

    HRESULT hr = S_OK;

    BYTE *pCur = NULL;
    LONG lState = STATE_FIRST;
    LONG lPercentComplete = 0;
    LONG lTotalToRead = pItemCtx->ItemHandle->Size;
    LONG lOffset = 0;
    DWORD dwBytesToRead = 0;
    BOOL bFileTransfer = pmdtc->tymed & TYMED_FILE;
    LONG lMessage = 0;
    LONG lStatus = 0;

    //
    // If pBuf is non-null use that as the buffer, otherwise use the buffer
    // and size in pmdtc
    //
    if (pBuf)
    {
        pCur = pBuf;
        dwBytesToRead = lBufSize;
    }
    else
    {
        pCur = pmdtc->pTransferBuffer;
        dwBytesToRead = pmdtc->lBufferSize;
    }

    //
    // If the transfer size is the entire item, split it into approximately
    // 10 equal transfers in order to show progress to the app
    //
    if (dwBytesToRead == (DWORD) lTotalToRead)
    {
        dwBytesToRead = (lTotalToRead / 10 + 3) & ~0x3;
    }

    //
    // Set up parameters for the callback function
    //
    if (bConverting)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_FROM_DEVICE;
    }
    else if (bFileTransfer)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }
    else  // e.g. memory transfer
    {
        lMessage = IT_MSG_DATA;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }

    //
    // Read data until finished
    //
    while (lOffset < lTotalToRead)
    {
        //
        // If this is the last read, adjust the amount of data to read
        // and the state
        //
        if (dwBytesToRead >= (DWORD) (lTotalToRead - lOffset))
        {
            dwBytesToRead = (lTotalToRead - lOffset);
            lState |= STATE_LAST;
        }

        //
        // Get the data from the camera
        //
        hr = m_pDevice->GetItemData(pItemCtx->ItemHandle, lState, pCur, dwBytesToRead);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, GetItemData failed"));
            goto Cleanup;
        }

        //
        // Calculate the percent complete for the callback function. If converting,
        // report the percent complete as TRANSFER_PERCENT of the actual. From
        // TRANSFER_PERCENT to 100% will be reported during format conversion.
        //
        if (bConverting)
            lPercentComplete = (lOffset + dwBytesToRead) * TRANSFER_PERCENT / lTotalToRead;
        else
            lPercentComplete = (lOffset + dwBytesToRead) * 100 / lTotalToRead;


        //
        // Call the callback function to send status and/or data to the app
        //
        hr = pmdtc->pIWiaMiniDrvCallBack->
            MiniDrvCallback(lMessage, lStatus, lPercentComplete,
                            lOffset, dwBytesToRead, pmdtc, 0);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, callback failed"));
            goto Cleanup;
        }
        if (hr == S_FALSE)
        {
            //
            // Transfer is being cancelled by the app
            //
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, transfer cancelled"));
            goto Cleanup;
        }

        //
        // Increment buffer pointer only if converting or this is a
        // file transfer
        //
        if (bConverting || bFileTransfer)
        {
            pCur += dwBytesToRead;
        }

        //
        // For a memory transfer not using a buffer allocated by the minidriver,
        // update the buffer pointer and size from the transfer context in case
        // of double buffering
        //
        else if (!pBuf)
        {
            pCur = pmdtc->pTransferBuffer;
            //  dwBytesToRead = pmdtc->lBufferSize;
        }

        //
        // Adjust variables for the next iteration
        //
        lOffset += dwBytesToRead;
        lState &= ~STATE_FIRST;
    }

    //
    // For file transfers, write the data to file
    //
    if (!pBuf && bFileTransfer)
    {
        //
        // Call WIA to write the data to the file
        //
        hr = wiasWriteBufToFile(0, pmdtc);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, wiasWriteBufToFile failed"));
            return hr;
        }
    }

Cleanup:
    //
    // If the transfer wasn't completed, send cancel to the device
    //
    if (!(lState & STATE_LAST))
    {
        lState = STATE_CANCEL;
        m_pDevice->GetItemData(pItemCtx->ItemHandle, lState, NULL, 0);
    }

    return hr;
}


//
// This function translates native data to BMP and sends the data to the app
//
HRESULT
CWiaCameraDevice::Convert(
    BYTE *pWiasContext,
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pNativeImage,
    LONG lNativeSize
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::Convert");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG  lMsg = 0;                 // Parameter to the callback function
    LONG  lPercentComplete = 0;     // Parameter to the callback function
    BOOL  bUseAppBuffer = FALSE;    // Indicates whether to transfer directly into the app's buffer
    BYTE *pBmpBuffer = NULL;        // Buffer used to hold converted image
    INT   iBmpBufferSize = 0;       // Size of the converted image buffer
    LONG  lBytesToCopy = 0;
    LONG  lOffset = 0;
    BYTE *pCurrent = NULL;
    BMP_IMAGE_INFO BmpImageInfo;
    SKIP_AMOUNT iSkipAmt = SKIP_OFF;

    //
    // Check arguments
    //
    if (!pNativeImage)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, invalid arg"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // The msg to send to the app via the callback depends on whether
    // this is a file or callback transfer
    //
    lMsg = ((pmdtc->tymed & TYMED_FILE) ? IT_MSG_STATUS : IT_MSG_DATA);

    //
    // If the class driver allocated a buffer and the buffer is large
    // enough, convert directly into that buffer. Otherwise, pass NULL
    // to the ConvertToBmp function so that it will allocate a buffer.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize >= pmdtc->lItemSize) {

        bUseAppBuffer = TRUE;
        pBmpBuffer = pmdtc->pTransferBuffer;
        iBmpBufferSize = pmdtc->lBufferSize;
    }

    //
    // Convert the image to BMP. Skip the BMP file header if the app asked
    // for a "memory bitmap" (aka DIB).
    //
    memset(&BmpImageInfo, 0, sizeof(BmpImageInfo));
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        iSkipAmt = SKIP_FILEHDR;
    }
    hr = m_Converter.ConvertToBmp(pNativeImage, lNativeSize, &pBmpBuffer,
                                  &iBmpBufferSize, &BmpImageInfo, iSkipAmt);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, ConvertToBmp failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        goto Cleanup;
    }

    //
    // Send the data to the app. If the class driver allocated the buffer,
    // but it was too small, send the data back one chunk at a time.
    // Otherwise send all the data back at once.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize < BmpImageInfo.Size) {

        pCurrent = pBmpBuffer;

        while (lOffset < BmpImageInfo.Size)
        {
            lBytesToCopy = BmpImageInfo.Size - lOffset;
            if (lBytesToCopy > pmdtc->lBufferSize) {

                lBytesToCopy = pmdtc->lBufferSize;

                //
                // Calculate how much of the data has been sent back so far. Report percentages to
                // the app between TRANSFER_PERCENT and 100 percent. Make sure it is never larger
                // than 99 until the end.
                //
                lPercentComplete = TRANSFER_PERCENT + ((100 - TRANSFER_PERCENT) * lOffset) / pmdtc->lItemSize;
                if (lPercentComplete > 99) {
                    lPercentComplete = 99;
                }
            }

            //
            // This will complete the transfer, so set the percentage to 100
            else {
                lPercentComplete = 100;
            }

            memcpy(pmdtc->pTransferBuffer, pCurrent, lBytesToCopy);

            //
            // Call the application's callback transfer to report status and/or transfer data
            //
            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                              lPercentComplete, lOffset, lBytesToCopy, pmdtc, 0);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, sending data to app failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                goto Cleanup;
            }
            if (hr == S_FALSE)
            {
                WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, transfer cancelled"));
                hr = S_FALSE;
                goto Cleanup;
            }

            pCurrent += lBytesToCopy;
            lOffset += lBytesToCopy;
        }
    }

    else
    {
        //
        // Send the data to the app in one big chunk
        //
        pmdtc->pTransferBuffer = pBmpBuffer;
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, 0, BmpImageInfo.Size, pmdtc, 0);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, sending data to app failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            goto Cleanup;
        }
    }

Cleanup:
    if (!bUseAppBuffer) {
        if (pBmpBuffer) {
            delete []pBmpBuffer;
            pBmpBuffer = NULL;
            iBmpBufferSize = 0;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA File System Device driver IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"


/**************************************************************************\
* CWiaCameraDevice::CWiaCameraDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::CWiaCameraDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    
    m_pIStiDevControl(NULL),
    m_pStiDevice(NULL),
    m_dwLastOperationError(0),
    
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pRootItem(NULL),

    m_NumSupportedCommands(0),
    m_NumSupportedEvents(0),
    m_NumCapabilities(0),
    m_pCapabilities(NULL),

    m_pDevice(NULL),

    m_ConnectedApps(0),
    m_pIWiaLog(NULL),
    m_FormatInfo(NULL),
    m_NumFormatInfo(0)
{
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }
}

/**************************************************************************\
* CWiaCameraDevice::~CWiaCameraDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::~CWiaCameraDevice(void)
{
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("~CWiaCameraDevice, executing ~CWiaCameraDevice destructor"));
    // Close the connection with the camera and delete it
    if( m_pDevice )
	{
		m_pDevice->Close();
		delete m_pDevice;
		m_pDevice = NULL;
	}

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }
    
    if(m_pIWiaLog)
        m_pIWiaLog->Release();
}

/**************************************************************************\
* CWiaCameraDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT hr = S_OK;
    
    //
    // Create logging object
    //
    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC,
                          IID_IWiaLog, (void**)&m_pIWiaLog);
    
    if (SUCCEEDED(hr) &&
        (m_pIWiaLog != NULL))
    {
        //
        // This will not really work on 64 bit!!!
        //
        hr = m_pIWiaLog->InitializeLog((LONG)(LONG_PTR) g_hInst);
        if (SUCCEEDED(hr))
        {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("CWiaCameraDevice::Initialize, logging initialized"));
        }
        else
            OutputDebugString(TEXT("Failed to initialize log for fsusd.dll\n"));
    }
    else
    {
        OutputDebugString(TEXT("Failed to CoCreateInstance on WiaLog for fsusd.dll\n"));
    }
    
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::Initialize");

    //
    // Check and cache the pointer to the IStiDeviceControl interface
    //
    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWiaCameraDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    pIStiDevControl->AddRef();
    m_pIStiDevControl = pIStiDevControl;

    //
    // Retrieve the port name from the IStiDeviceControl interface
    //
    hr = m_pIStiDevControl->GetMyDevicePortName(m_pPortName, sizeof(m_pPortName) / sizeof(m_pPortName[0]));
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, GetMyDevicePortName failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Create the device
    //
    m_pDevice = new FakeCamera;
    if (!m_pDevice)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, memory allocation failed"));
        return E_OUTOFMEMORY;
    }
    
#if 1
//    DBG_TRC(("IStiPortName=%S [%d]", m_pPortName, wcslen(m_pPortName)));
    WIAS_LTRACE(m_pIWiaLog, WIALOG_NO_RESOURCE_ID, WIALOG_LEVEL1, ("IStiPortName=%S [%d]", m_pPortName, wcslen(m_pPortName)));
#endif

    m_pIWiaLog->AddRef();
    m_pDevice->SetWiaLog(&m_pIWiaLog);

    //
    // Initialize access to the camera
    //
    // ISSUE-10/17/2000-davepar Also need to pass in event callback
    //
    hr = m_pDevice->Open(m_pPortName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Init failed"));
        goto Cleanup;
    }

    if( !m_pCapabilities )
    {
        hr = BuildCapabilities();
        if( hr != S_OK )
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, BuildCapabilities failed"));
            goto Cleanup;
        }
    }

    //
    // Intialize image format converter
    //
    hr = m_Converter.Init();
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Init converter failed"));
        goto Cleanup;
    }

Cleanup:
    if( hr != S_OK )
    {
        if( m_pDevice )
		{
			delete m_pDevice;
			m_pDevice = NULL;
		}
    }
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetCapabilities");
    HRESULT hr = S_OK;

    memset(pUsdCaps, 0, sizeof(*pUsdCaps));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetStatus");
    HRESULT hr = S_OK;

    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWiaCameraDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If asked, verify the device is online
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        pDevStatus->dwOnlineState = 0L;

        hr = m_pDevice->Status();

        if (hr == S_OK) {
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }

        else if (hr == S_FALSE) {
            hr = S_OK;
        }
        else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Status failed"));
            return hr;
        }
    }

    // If asked, verify state of event
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {
        pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

        // ISSUE-10/17/2000-davepar See if camera wants polling, and then poll for events

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::DeviceReset");
    HRESULT hr = S_OK;

    hr = m_pDevice->Reset();
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeviceReset, Reset failed"));
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::Diagnostic");
    HRESULT hr = S_OK;

    // ISSUE-10/17/2000-davepar Should call m_pDevice->Diagnostic

    // Initialize response buffer
    memset(&pBuffer->sErrorInfo, 0, sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::SetNotificationHandle");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetNotificationData
*
*   Provides data from an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetNotificationData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::Escape");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetLastError");
    HRESULT hr = S_OK;

    if (!pdwLastDeviceError) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetLastError, invalid arg"));
        return E_INVALIDARG;
    }

    *pdwLastDeviceError = m_dwLastOperationError;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetLastErrorInfo");
    HRESULT hr = S_OK;

    if (!pLastErrorInfo) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetLastErrorInfo, invalid arg"));
        return E_INVALIDARG;
    }

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::LockDevice");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::UnLockDevice");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawReadData");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawWriteData");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadCommand
*
*   Read a command from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawReadCommand");
    HRESULT hr = S_OK;

    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteCommand
*
*   Write a command to the device.
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawWriteCommand");
    HRESULT hr = S_OK;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiaproto.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiaproto.h
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 27 15:11:43 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 * 	This implements a pluggable protocol which handles transfering thumbnails
 * 	from a WIA device.
 *
 * History:
 * 	27 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef __WIAPROTO_H_
#define __WIAPROTO_H_

#include "resource.h"

/*-----------------------------------------------------------------------------
 *
 * Class:		CWiaProtocol
 * Synopsis:	This implements a pluggable protocol for trident that will
 * 				download thumbnails from WIA devices.
 *
 *--(samclem)-----------------------------------------------------------------*/
class ATL_NO_VTABLE CWiaProtocol : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWiaProtocol, &CLSID_WiaProtocol>,
	public IInternetProtocol
{
public:
	CWiaProtocol();

	DECLARE_REGISTRY_RESOURCEID(IDR_WIAPROTOCOL)
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_TRACKED_OBJECT

	BEGIN_COM_MAP(CWiaProtocol)
		COM_INTERFACE_ENTRY(IInternetProtocolRoot)
		COM_INTERFACE_ENTRY(IInternetProtocol)
	END_COM_MAP()

	STDMETHOD_(void,FinalRelease)();
	
	//IInternetProtocolRoot

    STDMETHOD(Start)( LPCWSTR szUrl, IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved );
    STDMETHOD(Continue)( PROTOCOLDATA* pProtocolData );        
    STDMETHOD(Abort)( HRESULT hrReason, DWORD dwOptions );
    STDMETHOD(Terminate)( DWORD dwOptions );
	STDMETHOD(Suspend)();   
    STDMETHOD(Resume)();	

	//IInternetProtocol

	STDMETHOD(Read)( void* pv, ULONG cb, ULONG* pcbRead);
	STDMETHOD(Seek)( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
	STDMETHOD(LockRequest)( DWORD dwOptions );
	STDMETHOD(UnlockRequest)( void );

	static HRESULT CreateURL( IWiaItem* pItem, BSTR* pbstrUrl );

private:
	HRESULT CreateDevice( BSTR bstrId, IWiaItem** ppDevice );
	HRESULT CrackURL( CComBSTR bstrUrl, BSTR* pbstrDeviceId, BSTR* pbstrItem );

	// Member variables
	IWiaItem*		m_pFileItem;
	PROTOCOLDATA	m_pd;
	ULONG			m_ulOffset;

	// this runs the thread which handles the download from the device to
	// a data block which is then transfered back to trident.
	struct TTPARAMS
	{
		IStream*				pStrm;
		IInternetProtocolSink*	pInetSink;
	};

	static DWORD WINAPI TransferThumbnail( LPVOID pvParams );
	static BYTE* SetupBitmapHeader( BYTE* pbBmp, DWORD cbBmp, DWORD dwWidth, DWORD dwHeight );
};

#endif //__WIAPROTOCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\fscam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       FScam.h
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   File System Device object library
*
***************************************************************************/
//
// Macro for getting size of array
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))
#endif

#ifndef _CAMAPI_H
#define _CAMAPI_H

//
// GetItemData state bit masks
//
const LONG STATE_NEXT   = 0x00;
const LONG STATE_FIRST  = 0x01;
const LONG STATE_LAST   = 0x02;
const LONG STATE_CANCEL = 0x04;

//
// Constants and structures for supporting a generic camera
//
typedef LONG FORMAT_CODE;
/*
const FORMAT_CODE TYPE_UNKNOWN    = 0x00;
const FORMAT_CODE TYPE_FOLDER     = 0x01;
const FORMAT_CODE TYPE_TXT        = 0x02;
const FORMAT_CODE TYPE_HTML       = 0x03;
const FORMAT_CODE TYPE_RTF        = 0x04;
const FORMAT_CODE TYPE_DPOF       = 0x05;
const FORMAT_CODE TYPE_AIFF       = 0x06;
const FORMAT_CODE TYPE_WAV        = 0x07;
const FORMAT_CODE TYPE_MP3        = 0x08;
const FORMAT_CODE TYPE_AVI        = 0x09;
const FORMAT_CODE TYPE_MPEG       = 0x0a;

const FORMAT_CODE TYPE_UNKNOWNIMG = 0x10;
const FORMAT_CODE TYPE_JPEG       = 0x11;
const FORMAT_CODE TYPE_TIFF       = 0x12;
const FORMAT_CODE TYPE_FLASHPIX   = 0x13;
const FORMAT_CODE TYPE_BMP        = 0x14;
const FORMAT_CODE TYPE_DIB        = 0x15;
const FORMAT_CODE TYPE_GIF        = 0x16;
const FORMAT_CODE TYPE_JPEG2000   = 0x17;

const FORMAT_CODE TYPE_IMAGEMASK  = 0x10;
*/

typedef struct _DEVICE_INFO {
    BOOL        bSyncNeeded;        // Should be set if the driver can get out-of-sync with the camera (i.e. for serial cameras)
    BSTR        FirmwareVersion;    // String allocated and freed by camera library
    LONG        PicturesTaken;      // Number of pictures stored on the camera
    LONG        PicturesRemaining;  // Space available on the camera, in pictures at the current resolution
    LONG        TotalItems;         // Total number of items on the camera, including folders, images, audio, etc.
    SYSTEMTIME  Time;               // Current time on the device
    LONG        ExposureMode;       // See WIA_DPC_EXPOSURE_MODE
    LONG        ExposureComp;       // See WIA_DPC_EXPOSURE_COMP
} DEVICE_INFO, *PDEVICE_INFO;

typedef struct _ITEM_INFO {
    struct _ITEM_INFO
               *Parent;             // Pointer to this item's parent, equal to ROOT_ITEM if this is a top level item
    BSTR        pName;              // String allocated and freed by camera library
    SYSTEMTIME  Time;               // Last modified time of the item
    FORMAT_CODE Format;             // Index to g_FormatInfo[] array.
    BOOL        bHasAttachments;    // Indicates whether an image has attachments
    LONG        Width;              // Width of the image in pixels, zero for non-images
    LONG        Height;             // Height of the image in pixels, zero for non-images
    LONG        Depth;              // Pixel depth in pixels (e.g. 8, 16, 24)
    LONG        Channels;           // Number of color channels per pixel (e.g. 1, 3)
    LONG        BitsPerChannel;     // Number of bits per color channel, normally 8
    LONG        Size;               // Size of the image in bytes
    LONG        SequenceNum;        // If image is part of a sequence, the sequence number
//    FORMAT_CODE ThumbFormat;        // Indicates the format of the thumbnail
    LONG        ThumbWidth;         // Width of thumbnail (can be set to zero until thumbnail is read by app)
    LONG        ThumbHeight;        // Height of thumbnail (can be set to zero until thumbnail is read by app)
    BOOL        bReadOnly;          // Indicates if item can or cannot be deleted by app
    BOOL        bCanSetReadOnly;    // Indicates if the app can change the read-only status on and off
    BOOL        bIsFolder;          // Indicates if the item is a folder
} ITEM_INFO, *PITEM_INFO;

typedef ITEM_INFO *ITEM_HANDLE;
const ITEM_HANDLE ROOT_ITEM_HANDLE = NULL;

typedef CWiaArray<ITEM_HANDLE> ITEM_HANDLE_ARRAY;

#define FFD_ALLOCATION_INCREMENT 64  // this must be a power of 2 !!!
typedef struct _FSUSD_FILE_DATA {
    DWORD     dwFileAttributes;
    FILETIME  ftFileTime;
    DWORD     dwFileSize;
    TCHAR     cFileName[MAX_PATH];
    DWORD     dwProcessed;
} FSUSD_FILE_DATA, *PFSUSD_FILE_DATA;

#ifndef FORMAT_INFO_STRUCTURE
#define FORMAT_INFO_STRUCTURE

#define MAXEXTENSIONSTRINGLENGTH 8
typedef struct _FORMAT_INFO
{
    GUID    FormatGuid;         // WIA format GUID
    WCHAR   ExtensionString[MAXEXTENSIONSTRINGLENGTH];   // File extension
    LONG    ItemType;           // WIA item type
} FORMAT_INFO, *PFORMAT_INFO;
#endif 

//
// Generic camera class definition
//

class FakeCamera
{
public:
    //
    // Methods for accessing the camera
    //
    FakeCamera();
    ~FakeCamera();

    HRESULT Open(LPWSTR pPortName);
    HRESULT Close();
    HRESULT GetDeviceInfo(DEVICE_INFO *pDeviceInfo);
    VOID    FreeDeviceInfo(DEVICE_INFO *pDeviceInfo);
    HRESULT GetItemList(ITEM_HANDLE *pItemArray);
    HRESULT SearchDirEx(ITEM_HANDLE_ARRAY *pItemArray,
                      ITEM_HANDLE ParentHandle, LPOLESTR Path);
    HRESULT SearchForAttachments(ITEM_HANDLE_ARRAY *pItemArray,
                                 ITEM_HANDLE ParentHandle, LPOLESTR Path, FSUSD_FILE_DATA *pFFD, DWORD dwNumFiles);
    HRESULT CreateFolderEx(ITEM_HANDLE ParentHandle,
                          FSUSD_FILE_DATA *pFindData, ITEM_HANDLE *pFolderHandle);
    HRESULT CreateItemEx(ITEM_HANDLE ParentHandle,
                        FSUSD_FILE_DATA *pFileData, ITEM_HANDLE *pImageHandle, UINT nFormatCode);
    VOID    ConstructFullName(WCHAR *pFullName, ITEM_INFO *pItemInfo, BOOL bAddExt = TRUE);

    VOID    FreeItemInfo(ITEM_INFO *pItemInfo);
    HRESULT GetNativeThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb);
    HRESULT CreateThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb, BMP_IMAGE_INFO *pBmpInfo);
    HRESULT CreateVideoThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb, BMP_IMAGE_INFO *pBmpInfo);
    VOID    FreeThumbnail(BYTE *pThumb);
    HRESULT GetItemData(ITEM_HANDLE ItemHandle, LONG lState, BYTE *pBuf, DWORD lLength);
    HRESULT DeleteItem(ITEM_HANDLE ItemHandle);
    HRESULT TakePicture(ITEM_HANDLE *pItemHandle);
    HRESULT Status();
    HRESULT Reset();
    ULONG   GetImageTypeFromFilename(WCHAR *pFilename, UINT *pFormatCode);
    void    SetWiaLog(IWiaLog **ppILog) { m_pIWiaLog = *ppILog; };

private:
    WCHAR               m_RootPath[MAX_PATH];
    ITEM_HANDLE_ARRAY   m_ItemHandles;
    int                 m_NumImages;
    int                 m_NumItems;
    HANDLE              m_hFile;
    IWiaLog            *m_pIWiaLog;

public:
    FORMAT_INFO        *m_FormatInfo;
    UINT                m_NumFormatInfo;
};

//
// Constants for reading Exif files
//
const WORD TIFF_XRESOLUTION =   0x11a;
const WORD TIFF_YRESOLUTION =   0x11b;
const WORD TIFF_JPEG_DATA =     0x201;
const WORD TIFF_JPEG_LEN =      0x202;

const int APP1_OFFSET = 6;      // Offset between the start of the APP1 segment and the start of the TIFF tags

//
// Structures for reading Exif files
//
typedef struct _DIR_ENTRY
{
    WORD    Tag;
    WORD    Type;
    DWORD   Count;
    DWORD   Offset;
} DIR_ENTRY, *PDIR_ENTRY;

typedef struct _IFD
{
    DWORD       Offset;
    WORD        Count;
    DIR_ENTRY  *pEntries;
    DWORD       NextIfdOffset;
} IFD, *PIFD;

//
// Functions for reading Exif files
//
HRESULT ReadDimFromJpeg(LPOLESTR FullName, WORD *pWidth, WORD *pHeight);
HRESULT ReadJpegHdr(LPOLESTR FileName, BYTE **ppBuf);
HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap);
VOID    FreeIfd(IFD *pIfd);
WORD    ByteSwapWord(WORD w);
DWORD   ByteSwapDword(DWORD dw);
WORD    GetWord(BYTE *pBuf, BOOL bSwap);
DWORD   GetDword(BYTE *pBuf, BOOL bSwap);
DWORD   GetRational(BYTE *pBuf, BOOL bSwap);

#endif // #ifndef _CAMAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\fscam.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       FSCam.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   File System Device object function implementations.
*
***************************************************************************/

#include "pch.h"

#include "private.h"
#include "gdiplus.h"

#ifdef USE_SHELLAPI
#include "shlguid.h"
#include "shlobj.h"
#endif

using namespace Gdiplus;

// extern FORMAT_INFO *g_FormatInfo;
// extern UINT g_NumFormatInfo;
//
// Constructor
//
FakeCamera::FakeCamera() :
    m_NumImages(0),
    m_NumItems(0),
    m_hFile(NULL),
    m_pIWiaLog(NULL),
    m_FormatInfo(NULL),
    m_NumFormatInfo(0)
{
}

//
// Destructor
//
FakeCamera::~FakeCamera()
{
    if( m_pIWiaLog )
        m_pIWiaLog->Release();
}

ULONG  FakeCamera::GetImageTypeFromFilename(WCHAR *pFilename, UINT *pFormatCode)
{
    WCHAR *pExt;

    pExt = wcsrchr(pFilename, L'.');

    if( pExt )
    {
        for(UINT i=0; i<m_NumFormatInfo; i++)
        {
            if( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, 
                               NORM_IGNORECASE, 
                               pExt+1,
                               -1,
                               m_FormatInfo[i].ExtensionString,
                               -1))
            {
                *pFormatCode = i;
                return (m_FormatInfo[i].ItemType);         
            }
        }
    }
	*pFormatCode = 0;
    return (m_FormatInfo[0].ItemType);
}

HRESULT GetClsidOfEncoder(REFGUID guidFormatID, CLSID *pClsid = 0)
{
    UINT nCodecs = -1;
    ImageCodecInfo *pCodecs = 0;
    HRESULT hr;

    if(!pClsid)
    {
        return S_FALSE;
    }

    if (nCodecs == -1)
    {
        UINT cbCodecs;
        GetImageEncodersSize(&nCodecs, &cbCodecs);
        if (nCodecs)
        {
            pCodecs = new ImageCodecInfo [cbCodecs];
            if (!pCodecs) 
            {
                return E_OUTOFMEMORY;
            }
            GetImageEncoders(nCodecs, cbCodecs, pCodecs);
        }
    }

    hr = S_FALSE;
    for (UINT i = 0; i < nCodecs; ++i)
    {
        if (pCodecs[i].FormatID == guidFormatID)
        {
            // *pClsid = pCodecs[i].Clsid;
            memcpy((BYTE *)pClsid, (BYTE *)&(pCodecs[i].Clsid), sizeof(CLSID));
            hr = S_OK;
        }
    }

    if( pCodecs )
    {
        delete [] pCodecs;
    }
    return hr;
}

BOOL IsFormatSupportedByGDIPlus(REFGUID guidFormatID)
{
    UINT nCodecs = -1;
    ImageCodecInfo *pCodecs = 0;
    BOOL bRet=FALSE;
    UINT cbCodecs;
    
    GetImageEncodersSize(&nCodecs, &cbCodecs);
    if (nCodecs)
    {
        pCodecs = new ImageCodecInfo [cbCodecs];
         GetImageEncoders(nCodecs, cbCodecs, pCodecs);
    }
    
    for (UINT i = 0; i < nCodecs; ++i)
    {
        if (pCodecs[i].FormatID == guidFormatID)
        {
            bRet=TRUE;
            break;
        }
    }

    if( pCodecs )
    {
        delete [] pCodecs;
    }
    return bRet;
}

//
// Initializes access to the camera
//
HRESULT FakeCamera::Open(LPWSTR pPortName)
{
    StringCbCopyW(m_RootPath, sizeof(m_RootPath), pPortName);

	HRESULT hr = S_OK;
	DWORD FileAttr = 0;
    if (-1 == (FileAttr = GetFileAttributes(m_RootPath)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            if (!CreateDirectory(m_RootPath, NULL))	 
			{
                hr = HRESULT_FROM_WIN32(::GetLastError());
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Open, CreateDirectory failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }
        else
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Open, GetFileAttributes failed %S, 0x%08x", m_RootPath, hr));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }
    
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Open, path set to %S", m_RootPath));

    return hr;
}

//
// Closes the connection with the camera
//
HRESULT FakeCamera::Close()
{
    HRESULT hr = S_OK;

    return hr;
}

//
// Returns information about the camera
//
HRESULT FakeCamera::GetDeviceInfo(DEVICE_INFO *pDeviceInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetDeviceInfo");
    
    HRESULT hr = S_OK;

    //
    // Build a list of all items available
    //
    //m_ItemHandles.RemoveAll();
    hr = SearchDirEx(&m_ItemHandles, ROOT_ITEM_HANDLE, m_RootPath);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDeviceInfo, SearchDir failed"));
        return hr;
    }

    pDeviceInfo->FirmwareVersion = SysAllocString(L"04.18.65");

    // ISSUE-8/4/2000-davepar Put properties into an INI file

    pDeviceInfo->PicturesTaken = m_NumImages;
    pDeviceInfo->PicturesRemaining = 100 - pDeviceInfo->PicturesTaken;
    pDeviceInfo->TotalItems = m_NumItems;

    GetLocalTime(&pDeviceInfo->Time);

    pDeviceInfo->ExposureMode = EXPOSUREMODE_MANUAL;
    pDeviceInfo->ExposureComp = 0;

    return hr;
}

//
// Frees the item info structure
//
VOID FakeCamera::FreeDeviceInfo(DEVICE_INFO *pDeviceInfo)
{
    if (pDeviceInfo)
    {
        if (pDeviceInfo->FirmwareVersion)
        {
            SysFreeString(pDeviceInfo->FirmwareVersion);
            pDeviceInfo->FirmwareVersion = NULL;
        }
    }
}

//
// This function searches a directory on the hard drive for
// items.
//
HRESULT FakeCamera::GetItemList(ITEM_HANDLE *pItemArray)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetItemList");
    HRESULT hr = S_OK;

    memcpy(pItemArray, m_ItemHandles.GetData(), sizeof(ITEM_HANDLE) * m_NumItems);

    return hr;
}


 
//
// This function searches a directory on the hard drive for
// items.
//
// ***NOTE:***
// This function assumes that one or more attachments 
// associated with an image will be in the same folder
// as the image.  So, for example, if an image is found
// in one folder and its attachment is found in a subfolder
// this algorithm will not associate the image with that 
// attachment.  This is not a serious limitation since
// all cameras store their attachments in the same
// folder as their image.
//
HRESULT FakeCamera::SearchDirEx(ITEM_HANDLE_ARRAY *pItemArray,
                                ITEM_HANDLE ParentHandle,
                                LPOLESTR Path)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::SearchDirEx");
    
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR TempStr[MAX_PATH];
    FSUSD_FILE_DATA *pFFD_array=NULL;
    DWORD     dwNumFilesInArray=0;
    DWORD     dwCurArraySize=0;


    //
    // Search for everything, except ".", "..", and hidden files, put them in pFFD_array
    //
    StringCchPrintfW(TempStr, ARRAYSIZE(TempStr), L"%s\\%s", Path, L"*");
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SearchDirEx, searching directory %S", TempStr));

    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFile(TempStr, &FindData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, empty directory %S", TempStr));
            hr = S_OK;
        }
        else
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, FindFirstFile failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
        goto Cleanup;
    }

    pFFD_array = (FSUSD_FILE_DATA *)CoTaskMemAlloc(sizeof(FSUSD_FILE_DATA)*FFD_ALLOCATION_INCREMENT);
    if( !pFFD_array )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    dwCurArraySize = FFD_ALLOCATION_INCREMENT;

    while (hr == S_OK)
    {
        if( wcscmp(FindData.cFileName, L".") &&
            wcscmp(FindData.cFileName, L"..") &&
            !(FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) )
        {
             pFFD_array[dwNumFilesInArray].dwFileAttributes = FindData.dwFileAttributes;
             pFFD_array[dwNumFilesInArray].ftFileTime = FindData.ftLastWriteTime;
             pFFD_array[dwNumFilesInArray].dwFileSize = FindData.nFileSizeLow;
             pFFD_array[dwNumFilesInArray].dwProcessed = 0;
             StringCchCopy(pFFD_array[dwNumFilesInArray].cFileName, ARRAYSIZE(pFFD_array[dwNumFilesInArray].cFileName), FindData.cFileName);
             dwNumFilesInArray++;

             if( (dwNumFilesInArray & (FFD_ALLOCATION_INCREMENT-1)) == (FFD_ALLOCATION_INCREMENT-1) )
             {   // Time to allocate more memory 
                pFFD_array = (FSUSD_FILE_DATA *)CoTaskMemRealloc(pFFD_array, (sizeof(FSUSD_FILE_DATA)*(dwCurArraySize+FFD_ALLOCATION_INCREMENT)));
                if( !pFFD_array )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                dwCurArraySize += FFD_ALLOCATION_INCREMENT;
             }
        }
        
        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, FindNextFile failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    hFind = INVALID_HANDLE_VALUE;
    
    
    // Now that all names under current directory are in the array, do analysis on them
    
    // 1. Find JPG images and their attachments
    ULONG uImageType;
    UINT nFormatCode;
    ITEM_HANDLE ImageHandle;
    for(DWORD i=0; i<dwNumFilesInArray; i++)
    {
        if( pFFD_array[i].dwProcessed )
            continue;
        if( !((pFFD_array[i].dwFileAttributes) & FILE_ATTRIBUTE_DIRECTORY))
        {
            uImageType = GetImageTypeFromFilename(pFFD_array[i].cFileName, &nFormatCode);
            if( nFormatCode > m_NumFormatInfo )
            {   // Something really weird happened
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Aborting SearchDirEx, Format index overflow"));
                hr = E_FAIL;
                goto Cleanup;
            }
            if( m_FormatInfo[nFormatCode].FormatGuid == WiaImgFmt_JPEG )
            {
                // Add this item
                hr = CreateItemEx(ParentHandle, &(pFFD_array[i]), &ImageHandle, nFormatCode);
                if (FAILED(hr))
                {
                   WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, CreateImage failed"));
                   goto Cleanup;
                }

                if (!pItemArray->Add(ImageHandle))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, Add failed"));
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                pFFD_array[i].dwProcessed = 1;
                ImageHandle->bHasAttachments = FALSE;
                m_NumImages ++;

                StringCchPrintfW(TempStr, ARRAYSIZE(TempStr), L"%s\\%s", Path, pFFD_array[i].cFileName);
                hr = SearchForAttachments(pItemArray, ImageHandle, TempStr, pFFD_array, dwNumFilesInArray);
                if (FAILED(hr))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, SearchForAttachments failed"));
                    goto Cleanup;
                }

                if (hr == S_OK)
                {
                    ImageHandle->bHasAttachments = TRUE;
                }
                ImageHandle->bIsFolder = FALSE;
                hr = S_OK;

            }
        }
    }   // end of JPEG images and attachments

    // 2. For other items that are not processed.
    for(i=0; i<dwNumFilesInArray; i++)
    {
        if( pFFD_array[i].dwProcessed )
            continue;

        if ((pFFD_array[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))  // for folder
        {
             hr = CreateFolderEx(ParentHandle, &(pFFD_array[i]), &ImageHandle);
             if (FAILED(hr))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, CreateFolder failed"));
                 goto Cleanup;
             }

             if (!pItemArray->Add(ImageHandle))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, Add failed"));
                 hr = E_OUTOFMEMORY;
                 goto Cleanup;
             }

             StringCchPrintfW(TempStr, ARRAYSIZE(TempStr), L"%s\\%s", Path, pFFD_array[i].cFileName);
             hr = SearchDirEx(pItemArray, ImageHandle, TempStr);
             if (FAILED(hr))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, recursive SearchDir failed"));
                 goto Cleanup;
             }
             pFFD_array[i].dwProcessed = 1;
             ImageHandle->bHasAttachments = FALSE;
             ImageHandle->bIsFolder = TRUE;
         } 
         else 
         {   // for files

             uImageType = GetImageTypeFromFilename(pFFD_array[i].cFileName, &nFormatCode);

 #ifdef GDIPLUS_CHECK
             if( (ITEMTYPE_IMAGE == uImageType) && 
                 !IsFormatSupportedByGDIPlus(m_FormatInfo[nFormatCode].FormatGuid))
             {
                 uImageType = ITEMTYPE_FILE;    // Force to create non-image item
                 m_FormatInfo[nFormatCode].ItemType = uImageType;
                 m_FormatInfo[nFormatCode].FormatGuid = WiaImgFmt_UNDEFINED;
             }
 #endif            
             hr = CreateItemEx(ParentHandle, &(pFFD_array[i]), &ImageHandle, nFormatCode);
             if (FAILED(hr))
             {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, CreateImage failed"));
                goto Cleanup;
             }

             if (!pItemArray->Add(ImageHandle))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, Add failed"));
                 hr = E_OUTOFMEMORY;
                 goto Cleanup;
             }

             pFFD_array[i].dwProcessed = 1;
             ImageHandle->bHasAttachments = FALSE;
             ImageHandle->bIsFolder = FALSE;

             if(ITEMTYPE_IMAGE == uImageType) 
             {
                 m_NumImages ++;
             }
             hr = S_OK;
         }
    }
    hr = S_OK;

Cleanup:
    if( hFind != INVALID_HANDLE_VALUE ) 
        FindClose(hFind);
    if( pFFD_array )
        CoTaskMemFree(pFFD_array);
    return hr;
}

//
// Searches for attachments to an image item
//

inline BOOL CompareAttachmentStrings(WCHAR *pParentStr, WCHAR *pStr2)
{
    WCHAR *pSlash = wcsrchr(pStr2, L'\\');
    WCHAR *pStrTmp;

    if( pSlash )
        pStrTmp = pSlash+1;
    else
        pStrTmp = pStr2;
    
    if( wcslen(pParentStr) == 8 && wcscmp(pParentStr+4, L"0000") > 0 && wcscmp(pParentStr+4, L"9999") < 0 )
    {
        if( wcslen(pStrTmp) < 8 ) 
            return FALSE;
        return (CSTR_EQUAL == CompareString( LOCALE_SYSTEM_DEFAULT, 0, pParentStr+4, 4, pStrTmp+4, 4) );
    }
    else
    {
        WCHAR pStr22[MAX_PATH];
        StringCchCopyW(pStr22, ARRAYSIZE(pStr22), pStrTmp);
        WCHAR *pDot = wcsrchr(pStr22, L'.');

        if(pDot )
            *pDot = L'\0';
        return (CSTR_EQUAL == CompareString( LOCALE_SYSTEM_DEFAULT, 0, pParentStr, -1, pStr22, -1) );
    }
}

HRESULT FakeCamera::SearchForAttachments(ITEM_HANDLE_ARRAY *pItemArray,
                                         ITEM_HANDLE ParentHandle,
                                         LPOLESTR Path,
                                         FSUSD_FILE_DATA *pFFD_Current,
                                         DWORD dwNumOfFiles)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::SearchForAttachments");
    HRESULT hr = S_FALSE;

    int NumAttachments = 0;

    //
    //  Attachment is defined as any non-image item whose extension is different than the parent but 
    //  the filename is the same except the first 4 letters.
    //
    
    WCHAR TempStrParent[MAX_PATH];
    WCHAR *pTemp;

    pTemp = wcsrchr(Path, L'\\');
    if (pTemp)
    {
        StringCchCopyW(TempStrParent, ARRAYSIZE(TempStrParent), pTemp+1);
    }
    else
    {
        StringCchCopyW(TempStrParent, ARRAYSIZE(TempStrParent), Path);
    }

    //
    // Chop the extension
    //
    
    WCHAR *pDot = wcsrchr(TempStrParent, L'.');
    
    if (pDot)
    {
        *(pDot) = L'\0';
    }
    else
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchForAttachments, filename did not contain a dot"));
        return E_INVALIDARG;
    }

    ITEM_HANDLE NonImageHandle;
    UINT nFormatCode;
    ULONG uImageType; 
    for(DWORD i=0; i<dwNumOfFiles; i++)
    {
        if (!(pFFD_Current[i].dwProcessed) && !(pFFD_Current[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            nFormatCode=0;
            uImageType = GetImageTypeFromFilename(pFFD_Current[i].cFileName, &nFormatCode);

            if( (uImageType != ITEMTYPE_IMAGE) &&
                CompareAttachmentStrings(TempStrParent, pFFD_Current[i].cFileName) )
            {
                hr = CreateItemEx(ParentHandle, &(pFFD_Current[i]), &NonImageHandle, nFormatCode);
                if (FAILED(hr))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchForAttachments, CreateItemEx failed"));
                    return hr;
                }
                if (!pItemArray->Add(NonImageHandle))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchForAttachments, Add failed"));
                    return E_OUTOFMEMORY;
                }

                pFFD_Current[i].dwProcessed = 1;
                NonImageHandle->bIsFolder = FALSE;
                NumAttachments++;
            }
        }
    } // end of FOR loop
 
    if( NumAttachments > 0 )
        hr = S_OK;
    else
        hr = S_FALSE;
    return hr;    
}


HRESULT FakeCamera::CreateFolderEx(ITEM_HANDLE ParentHandle,
                                 FSUSD_FILE_DATA *pFindData,
                                 ITEM_HANDLE *pFolderHandle)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::CreateFolder");
    HRESULT hr = S_OK;

    if (!pFolderHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateFolder, invalid arg"));
        return E_INVALIDARG;
    }

    *pFolderHandle = new ITEM_INFO;
    if (!*pFolderHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateFolder, memory allocation failed"));
        return E_OUTOFMEMORY;
    }


    //
    // Initialize the ItemInfo structure
    //
    ITEM_INFO *pItemInfo = *pFolderHandle;
    memset(pItemInfo, 0, sizeof(ITEM_INFO));
    
    //
    // Fill in the other item information
    //
    pItemInfo->Parent = ParentHandle;
    pItemInfo->pName = SysAllocString(pFindData->cFileName);
    memset(&pItemInfo->Time, 0, sizeof(SYSTEMTIME));
    FILETIME ftLocalFileTime;
    FileTimeToLocalFileTime(&pFindData->ftFileTime, &ftLocalFileTime);
    if (!FileTimeToSystemTime(&ftLocalFileTime, &pItemInfo->Time))
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateFolder, couldn't convert file time to system time"));
    pItemInfo->Format = 0;
    pItemInfo->bReadOnly = pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY;
    pItemInfo->bCanSetReadOnly = TRUE;
    pItemInfo->bIsFolder = TRUE;

    m_NumItems++;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,
                ("CreateFolder, created folder %S at 0x%08x under 0x%08x",
                 pFindData->cFileName, pItemInfo, ParentHandle));

    return hr;
}


HRESULT FakeCamera::CreateItemEx(ITEM_HANDLE ParentHandle,
                                   FSUSD_FILE_DATA *pFileData,
                                   ITEM_HANDLE *pItemHandle,
                                   UINT nFormatCode)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::CreateNonImage");
    HRESULT hr = S_OK;

    if (!pItemHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateNonImage, invalid arg"));
        return E_INVALIDARG;
    }

    *pItemHandle = new ITEM_INFO;
    if (!*pItemHandle )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateNonImage, memory allocation failed"));
        return E_OUTOFMEMORY;
    }


    //
    // The name cannot contain a dot and the name needs to be unique
    // wrt the parent image, so replace the dot with an underline character.
    //
    WCHAR TempStr[MAX_PATH];
    StringCchCopyW(TempStr, ARRAYSIZE(TempStr), pFileData->cFileName);

    //
    // Initialize the ItemInfo structure
    //
    ITEM_INFO *pItemInfo = *pItemHandle;
    memset(pItemInfo, 0, sizeof(ITEM_INFO));
    
    pItemInfo->Format = nFormatCode;
    if (nFormatCode) {  // if known extension, it will be handled by the format code
        WCHAR *pDot = wcsrchr(TempStr, L'.');
        if (pDot)
            *pDot = L'\0';
    }

    //
    // Fill in the other item information
    //
    pItemInfo->Parent = ParentHandle;
    pItemInfo->pName = SysAllocString(TempStr);
    memset(&pItemInfo->Time, 0, sizeof(SYSTEMTIME));
    FILETIME ftLocalFileTime;
    FileTimeToLocalFileTime(&pFileData->ftFileTime, &ftLocalFileTime);
    if (!FileTimeToSystemTime(&ftLocalFileTime, &pItemInfo->Time))
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateNonImage, couldn't convert file time to system time"));
    pItemInfo->Size = pFileData->dwFileSize;
    pItemInfo->bReadOnly = pFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY;
    pItemInfo->bCanSetReadOnly = TRUE;
    pItemInfo->bIsFolder = FALSE;
                                
    m_NumItems++;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,
                ("CreateNonImage, created non-image %S at 0x%08x under 0x%08x",
                 pFileData->cFileName, pItemInfo, ParentHandle));

    return hr;
}

//
// Construct the full path name of the item by traversing its parents
//
VOID FakeCamera::ConstructFullName(WCHAR *pFullName, ITEM_INFO *pItemInfo, BOOL bAddExt)
{
    if (pItemInfo->Parent)
        ConstructFullName(pFullName, pItemInfo->Parent, FALSE);
    else
        StringCchCopyW(pFullName, MAX_PATH, m_RootPath);

    //
    // If this item has attachments and we're creating the name for its children,
    // don't add its name (it's a repeat of the child's name)
    //
    WCHAR *pTmp;
    if( pItemInfo->Parent && pItemInfo->Parent->bHasAttachments )
    {
        pTmp = wcsrchr(pFullName, L'\\');
        if( pTmp )
        {
            *pTmp = L'\0';
        }
    }
    
    StringCchCatW(pFullName, MAX_PATH, L"\\");
    StringCchCatW(pFullName, MAX_PATH, pItemInfo->pName);
    
    if (bAddExt)
    {
        if( pItemInfo->Format > 0 && pItemInfo->Format < (INT)m_NumFormatInfo )
        {
            StringCchCatW(pFullName, MAX_PATH, L".");
            StringCchCatW(pFullName, MAX_PATH, m_FormatInfo[pItemInfo->Format].ExtensionString);
        }
    }
}

//
// Frees the item info structure
//
VOID FakeCamera::FreeItemInfo(ITEM_INFO *pItemInfo)
{
    if (pItemInfo)
    {
        if (pItemInfo->pName)
        {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("FreeItemInfo, removing %S", pItemInfo->pName));

            SysFreeString(pItemInfo->pName);
            pItemInfo->pName = NULL;
        }

        if (!m_ItemHandles.Remove(pItemInfo))
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FreeItemInfo, couldn't remove handle from array"));

        if (m_FormatInfo[pItemInfo->Format].ItemType == ITEMTYPE_IMAGE)
        {
            m_NumImages--;
        }

        m_NumItems--;

        delete pItemInfo;
    }
}

//
// Retrieves the thumbnail for an item
//
/*
HRESULT FakeCamera::GetNativeThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetThumbnail");
    HRESULT hr = S_OK;
     
    if (!ppThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, invalid arg"));
        return E_INVALIDARG;
    }
    *ppThumb = NULL;
    *pThumbSize = 0;

    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    BYTE *pBuffer;
    hr = ReadJpegHdr(FullName, &pBuffer);
    if (FAILED(hr) || !pBuffer)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, ReadJpegHdr failed"));
        return hr;
    }

    IFD ImageIfd, ThumbIfd;
    BOOL bSwap;
    hr = ReadExifJpeg(pBuffer, &ImageIfd, &ThumbIfd, &bSwap);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, GetExifJpegDimen failed"));
        delete []pBuffer;
        return hr;
    }

    LONG ThumbOffset = 0;

    for (int count = 0; count < ThumbIfd.Count; count++)
    {
        if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_DATA) {
            ThumbOffset = ThumbIfd.pEntries[count].Offset;
        }
        else if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_LEN) {
            *pThumbSize = ThumbIfd.pEntries[count].Offset;
        }
    }

    if (!ThumbOffset || !*pThumbSize)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, thumbnail not found"));
        return E_FAIL;
    }

    *ppThumb = new BYTE[*pThumbSize];
    if (!*ppThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, memory allocation failed"));
        return E_OUTOFMEMORY;
    }

    memcpy(*ppThumb, pBuffer + APP1_OFFSET + ThumbOffset, *pThumbSize);

    delete []pBuffer;

    FreeIfd(&ImageIfd);
    FreeIfd(&ThumbIfd);

    return hr;
}
*/


HRESULT FakeCamera::CreateThumbnail(ITEM_HANDLE ItemHandle, 
                                 int *pThumbSize, 
                                 BYTE **ppThumb,
                                 BMP_IMAGE_INFO *pBmpImageInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FSCamera::GetThumbnail");
    HRESULT hr = S_OK;
    GpStatus Status = Gdiplus::Ok;
    SizeF  gdipSize;
    BYTE *pTempBuf=NULL;
    CImageStream *pOutStream = NULL;
    Image *pImage=NULL, *pThumbnail=NULL;
    CLSID ClsidBmpEncoder;
    INT iBmpHeadSize = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
    ITEM_INFO *pItemInfo=NULL;

    if (!ppThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, invalid arg"));
        return E_INVALIDARG;
    }
    *ppThumb = NULL;
    *pThumbSize = 0;

    if( S_OK != (hr=GetClsidOfEncoder(ImageFormatBMP, &ClsidBmpEncoder)))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, Cannot get Encode"));
        hr = E_FAIL;
        goto Cleanup;
    }
     
    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    pItemInfo = (ITEM_INFO *)ItemHandle;

    pImage = new Image(FullName);

    if( !pImage ||  Gdiplus::ImageTypeBitmap != pImage->GetType() )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, Cannot get Full GDI+ Image for %S", FullName));
        hr = E_FAIL;
        goto Cleanup;
    }

    // Calculate Thumbnail size
    Status = pImage->GetPhysicalDimension(&gdipSize);
    if (Status != Gdiplus::Ok)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, Failed in GetPhysicalDimension"));
        hr = E_FAIL;
        goto Cleanup;
    }

    if(  gdipSize.Width < 1.0 || gdipSize.Height < 1.0 )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, PhysicalDimension abnormal"));
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pItemInfo->Width = (LONG)gdipSize.Width;
    pItemInfo->Height = (LONG)gdipSize.Height;
    PixelFormat PixFmt = pImage->GetPixelFormat();
	pItemInfo->Depth = (PixFmt & 0xFFFF) >> 8;   // Cannot assume image is always 24bits/pixel
    if( (pItemInfo->Depth) < 24 )
        pItemInfo->Depth = 24; 
    pItemInfo->BitsPerChannel = 8;
    pItemInfo->Channels = (pItemInfo->Depth)/(pItemInfo->BitsPerChannel);

	
    if(  gdipSize.Width > gdipSize.Height )
    {
        pBmpImageInfo->Width = 120;
        pBmpImageInfo->Height = (INT)(gdipSize.Height*120.0/gdipSize.Width);
        pBmpImageInfo->Height = (pBmpImageInfo->Height + 0x3) & (~0x3);
    }
    else
    {
        pBmpImageInfo->Height = 120;
        pBmpImageInfo->Width = (INT)(gdipSize.Width*120.0/gdipSize.Height);
        pBmpImageInfo->Width = (pBmpImageInfo->Width + 0x3 ) & (~0x3);
    }
 
    pThumbnail = pImage->GetThumbnailImage(pBmpImageInfo->Width,pBmpImageInfo->Height);

    if( !pThumbnail ||  Gdiplus::ImageTypeBitmap != pThumbnail->GetType() )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Cannot get Thumbnail GDI+ Image"));
        hr = E_FAIL;
        goto Cleanup;
    }

    if( pImage )
    {
        delete pImage;
        pImage=NULL;
    }

#if 0
    pThumbnail->Save(L"C:\\thumbdmp.bmp", &ClsidBmpEncoder, NULL);
#endif

    //
    // Ask GDI+ for the image dimensions, and fill in the
    // passed structure
    //
    Status = pThumbnail->GetPhysicalDimension(&gdipSize);
    if (Status != Gdiplus::Ok)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Failed in GetPhysicalDimension"));
        hr = E_FAIL;
        goto Cleanup;
    }

    pBmpImageInfo->Width = (INT) gdipSize.Width;
    pBmpImageInfo->Height = (INT) gdipSize.Height;
    pBmpImageInfo->ByteWidth = (pBmpImageInfo->Width) << 2;
    pBmpImageInfo->Size = pBmpImageInfo->ByteWidth * pBmpImageInfo->Height;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetThumbnail, W=%d H=%d", pBmpImageInfo->Width, pBmpImageInfo->Height));

    if (pBmpImageInfo->Size == 0)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Thumbnail size is zero"));
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // See if the caller passed in a destination buffer, and make sure
    // it is big enough.
    //
    if (*ppThumb) {
        if (*pThumbSize < pBmpImageInfo->Size) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Input Buffer too small"));
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // Otherwise allocate memory for a buffer
    //
    else
    {
        pTempBuf = new BYTE[pBmpImageInfo->Size];
        if (!pTempBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        *ppThumb = pTempBuf;
   }

    //
    // Create output IStream
    //
    pOutStream = new CImageStream;
    if (!pOutStream) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pOutStream->SetBuffer(*ppThumb, pBmpImageInfo->Size, SKIP_BOTHHDR);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    //
    // Write the Image to the output IStream in BMP format
    //
    pThumbnail->Save(pOutStream, &ClsidBmpEncoder, NULL);



    // pack
    DWORD i, k;

    for(k=0, i=0; k<(DWORD)(pBmpImageInfo->Size); k+=4, i+=3)
    {
        (*ppThumb)[i] = (*ppThumb)[k];
        (*ppThumb)[i+1] = (*ppThumb)[k+1];
        (*ppThumb)[i+2] = (*ppThumb)[k+2];
    }
 
    *pThumbSize = ((pBmpImageInfo->Size)>>2)*3;
    pBmpImageInfo->Size = *pThumbSize;

Cleanup:
    if (FAILED(hr)) {
        if (pTempBuf) {
            delete []pTempBuf;
            pTempBuf = NULL;
            *ppThumb = NULL;
            *pThumbSize = 0;
        }
    }
    
    if (pOutStream) 
    {
        pOutStream->Release();
    }

    if( pImage )
    {
        delete pImage;
    }
    
    if( pThumbnail )
    {
        delete pThumbnail;
    }

    return hr; 
}

PBITMAPINFO CreateBitmapInfoStruct(HBITMAP hBmp)
{ 
    BITMAP bmp; 
    PBITMAPINFO pbmi; 
    WORD    cClrBits; 

    // Retrieve the bitmap's color format, width, and height. 
    if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bmp)) 
	{
        return NULL;
	}

    // Convert the color format to a count of bits. 
    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits <= 4) 
        cClrBits = 4; 
    else if (cClrBits <= 8) 
        cClrBits = 8; 
    else if (cClrBits <= 16) 
        cClrBits = 16; 
    else if (cClrBits <= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 

     if (cClrBits != 24) 
         pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                    sizeof(BITMAPINFOHEADER) + 
                    sizeof(RGBQUAD) * (1<< cClrBits)); 

     // There is no RGBQUAD array for the 24-bit-per-pixel format. 

     else 
         pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                    sizeof(BITMAPINFOHEADER)); 

    
     if( !pbmi ) 
         return NULL;

    // Initialize the fields in the BITMAPINFO structure. 
    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
    pbmi->bmiHeader.biWidth = bmp.bmWidth; 
    pbmi->bmiHeader.biHeight = bmp.bmHeight; 
    pbmi->bmiHeader.biPlanes = bmp.bmPlanes; 
    pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel; 
    if (cClrBits < 24) 
        pbmi->bmiHeader.biClrUsed = (1<<cClrBits); 

    // If the bitmap is not compressed, set the BI_RGB flag. 
    pbmi->bmiHeader.biCompression = BI_RGB; 

    // Compute the number of bytes in the array of color 
    // indices and store the result in biSizeImage. 
    // For Windows NT/2000, the width must be DWORD aligned unless 
    // the bitmap is RLE compressed. This example shows this. 
    // For Windows 95/98, the width must be WORD aligned unless the 
    // bitmap is RLE compressed.
    pbmi->bmiHeader.biSizeImage = ((pbmi->bmiHeader.biWidth * cClrBits +31) & ~31) /8
                                  * pbmi->bmiHeader.biHeight; 
    // Set biClrImportant to 0, indicating that all of the 
    // device colors are important. 
    pbmi->bmiHeader.biClrImportant = 0; 
    return pbmi; 
} 

HRESULT FakeCamera::CreateVideoThumbnail(ITEM_HANDLE ItemHandle, 
                                 int *pThumbSize, 
                                 BYTE **ppThumb,
                                 BMP_IMAGE_INFO *pBmpImageInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FSCamera::CreateVideoThumbnail");
   HRESULT hr = S_OK;
   HBITMAP hBmp=NULL;
   PBITMAPINFO pBMI=NULL;
   BYTE *pTempBuf=NULL;

#ifdef USE_SHELLAPI

 	IShellFolder *pDesktop=NULL;
	IShellFolder *pFolder=NULL;
    ITEMIDLIST *pidlFolder=NULL;
    ITEMIDLIST *pidlFile=NULL;
    IExtractImage *pExtract=NULL;
    SIZE rgSize;
    WCHAR *wcsTmp, wcTemp;
    DWORD dwPriority, dwFlags;

    if (!ppThumb || !pThumbSize || !pBmpImageInfo)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, invalid arg"));
        return E_INVALIDARG;
    }
    
	*ppThumb = NULL;
    *pThumbSize = 0;

   
    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    // Calculate Thumbnail size, BUGBUG
	rgSize.cx = 120;
	rgSize.cy = 90;

    // Get thumbnail using Shell APIs
	hr = SHGetDesktopFolder(&pDesktop);
    if( S_OK != hr || !pDesktop )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot open Desktop"));
		goto Cleanup;
	}

	wcsTmp = wcsrchr(FullName, L'\\');

	if( wcsTmp )
	{
//		wcTemp = *(wcsTmp+1);
		*(wcsTmp) = NULL;
	}
	else 
	{
		hr = E_INVALIDARG;
		goto Cleanup;
	}

	hr = pDesktop->ParseDisplayName(NULL, NULL, FullName, NULL, &pidlFolder, NULL);
    if( S_OK != hr || !pidlFolder )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot open IDL Folder=%S", FullName));
		goto Cleanup;
	}

    hr = pDesktop->BindToObject(pidlFolder, NULL, IID_IShellFolder, (LPVOID *)&pFolder);
    if( S_OK != hr || !pFolder )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot bind to Folder=%S", FullName));
		goto Cleanup;
	}

//    *(wcsTmp+1) = wcTemp;  // restore the char
	hr = pFolder->ParseDisplayName(NULL, NULL, wcsTmp+1, NULL, &pidlFile, NULL);
    if( S_OK != hr || !pidlFile )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot open IDL File=%S", wcsTmp+1));
		goto Cleanup;
	}

    hr = pFolder->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidlFile, IID_IExtractImage, NULL, (LPVOID *)&pExtract);
    if( S_OK != hr || !pExtract )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot get extract pointer=%S, hr=0x%x", wcsTmp+1, hr));
		goto Cleanup;
	}

 
	dwFlags = 0;
	dwPriority=0;
	hr = pExtract->GetLocation(FullName, MAX_PATH, &dwPriority, &rgSize, 0, &dwFlags);
    if( S_OK != hr )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Failed in GetLocation"));
		goto Cleanup;
	}

	hr = pExtract->Extract(&hBmp);

#else
	
    hBmp = (HBITMAP)LoadImage(g_hInst, MAKEINTRESOURCE(IDB_BITMAP_VIDEO), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if( !hBmp )
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
	}
#endif  // end of if use ShellAPI
    if( S_OK != hr || !hBmp )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot extract Image hr=0x%x", hr));
		goto Cleanup;
	}


    pBMI = CreateBitmapInfoStruct(hBmp);
    if( !pBMI )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot create BitmapInfoStruct"));
		goto Cleanup;
	}


    pBmpImageInfo->Width = pBMI->bmiHeader.biWidth;
    pBmpImageInfo->Height = pBMI->bmiHeader.biHeight;
    pBmpImageInfo->ByteWidth = ((pBMI->bmiHeader.biWidth * 24 + 31 ) & ~31 ) >> 3;
    pBmpImageInfo->Size = pBMI->bmiHeader.biWidth * pBmpImageInfo->Height * 3;
   
    //
    // See if the caller passed in a destination buffer, and make sure
    // it is big enough.
    //
    if (*ppThumb) {
        if (*pThumbSize < pBmpImageInfo->Size) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Input Buffer too small"));
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

     //
    // Otherwise allocate memory for a buffer
    //
    else
    {
        pTempBuf = new BYTE[(pBmpImageInfo->ByteWidth)*(pBmpImageInfo->Height)];
        if (!pTempBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        *ppThumb = pTempBuf;
        *pThumbSize = pBmpImageInfo->Size;
    }


    //
    // Create output buffer
	//

	if (!GetDIBits(GetDC(NULL), hBmp, 0, (WORD)pBMI->bmiHeader.biHeight, *ppThumb, pBMI, DIB_RGB_COLORS)) 
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Failed in GetDIBits"));
		hr = E_FAIL;
		goto Cleanup;
   }

#if 0
    // pack
    DWORD i, k;

    for(k=0, i=0; k<(DWORD)(pBmpImageInfo->Size); k+=4, i+=3)
    {
        pTempBuf[i] = pTempBuf[k];
        pTempBuf[i+1] = pTempBuf[k+1];
        pTempBuf[i+2] = pTempBuf[k+2];
    }
#endif 
 
Cleanup:
    if (FAILED(hr)) {
        if (pTempBuf) {
            delete []pTempBuf;
            pTempBuf = NULL;
            *ppThumb = NULL;
            *pThumbSize = 0;
        }
    }
    
    if (pBMI) 
		LocalFree(pBMI);
    
#ifdef USE_SHELLAPI
	if( pDesktop )
		pDesktop->Release();
	
	if( pFolder )
		pFolder->Release();
	
	if( pidlFolder )
		CoTaskMemFree(pidlFolder);

    if( pidlFile )
		CoTaskMemFree(pidlFile);

	if( pExtract )
		pExtract->Release();
#endif

	if( hBmp )
	{
		DeleteObject(hBmp);
	}
	return hr; 
}


VOID FakeCamera::FreeThumbnail(BYTE *pThumb)
{
    if (pThumb)
    {
        delete []pThumb;
        pThumb = NULL;
    }
}

//
// Retrieves the data for an item
//
HRESULT FakeCamera::GetItemData(ITEM_HANDLE ItemHandle, LONG lState,
                                BYTE *pBuf, DWORD lLength)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetItemData");
    
    HRESULT hr = S_OK;

    if (lState & STATE_FIRST)
    {
        if (m_hFile != NULL)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, file handle is already open"));
            return E_FAIL;
        }

        WCHAR FullName[MAX_PATH];
        ConstructFullName(FullName, ItemHandle);

        m_hFile = CreateFile(FullName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, CreateFile failed %S", FullName));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }

    if (!(lState & STATE_CANCEL))
    {
        DWORD Received = 0;
        if (!ReadFile(m_hFile, pBuf, lLength, &Received, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, ReadFile failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        if (lLength != Received)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, incorrect amount read %d", Received));
            return E_FAIL;
        }

        Sleep(100);
    }

    if (lState & (STATE_LAST | STATE_CANCEL))
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }

    return hr;
}

//
// Deletes an item
//
HRESULT FakeCamera::DeleteItem(ITEM_HANDLE ItemHandle)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::DeleteItem");
    
    HRESULT hr = S_OK;
    DWORD   dwErr = 0; 
    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributes(FullName) )
    {
        dwErr = RemoveDirectory(FullName);
    } else {
        dwErr = DeleteFile(FullName);
    }
 
    if (!dwErr )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItem, DeleteFile failed %S", FullName));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

//
// Captures a new image
//
HRESULT FakeCamera::TakePicture(ITEM_HANDLE *pItemHandle)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::TakePicture");
    
    HRESULT hr = S_OK;

    if (!pItemHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TakePicture, invalid arg"));
        return E_INVALIDARG;
    }

    return hr;
}

//
// See if the camera is active
//
HRESULT
FakeCamera::Status()
{
    HRESULT hr = S_OK;

    //
    // This sample device is always active, but your driver should contact the
    // device and return S_FALSE if it's not ready.
    //
    // if (NotReady)
    //   return S_FALSE;

    return hr;
}

//
// Reset the camera
//
HRESULT FakeCamera::Reset()
{
    HRESULT hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiautil.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiautil.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Mon Aug 16 13:22:36 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Description:
 *	Contains the implementation of the Wia utility methods.	
 *
 * History:
 * 	16 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

/*-----------------------------------------------------------------------------
 * GetStringForVal
 *
 * This returns the string assioctiated with value (dwVal) in the string
 * table. If it is not found it will return the default value, or NULL if
 * not default was provided.
 *
 * pStrTable:	the table to search for the given string
 * dwVal:		what value ypu want to look for.
 *--(samclem)-----------------------------------------------------------------*/
WCHAR* GetStringForVal( const STRINGTABLE* pStrTable, DWORD dwVal )
{
	Assert( pStrTable != NULL );
	
	// there is always at least 2 entries in the
	// string table. the 0th entry is what to return 
	// if we don't find anything.
	
	int iStr = 1;
	while ( pStrTable[iStr].pwchValue )
		{
		if ( pStrTable[iStr].dwStartRange >= dwVal &&
			pStrTable[iStr].dwEndRange <= dwVal )
			return pStrTable[iStr].pwchValue;

		iStr++;
		}

	// didn't find anything return the value at entry 0
	return pStrTable->pwchValue;
}
	
/*-----------------------------------------------------------------------------
 * GetWiaProperty
 *
 * This will get the desired property from the given property storage and 
 * fill the our param pvaProp with the value. This prop variant doesn't have
 * to be initialized.
 *
 * pStg:		the IWiaPropertyStorage to query for the property
 * propid:		the property id of the property that we want
 * pvaProp:		Out, recieves the value of the prop, or VT_EMPTY if not found.
 *--(samclem)-----------------------------------------------------------------*/
HRESULT GetWiaProperty( IWiaPropertyStorage* pStg, PROPID propid, PROPVARIANT* pvaProp )
{
	Assert( pStg != NULL );
	Assert( pvaProp != NULL );
	
	PROPSPEC pr;
	HRESULT hr;

	pr.ulKind = PRSPEC_PROPID;
	pr.propid = propid;
	
	PropVariantInit( pvaProp );
	hr = pStg->ReadMultiple( 1, &pr, pvaProp );

	return hr;
}

/*-----------------------------------------------------------------------------
 * GetWiaPropertyBSTR
 *
 * This will get the desired property for the given property storage, and 
 * then attempt to convert it to a BSTR.  If it can't convert the property
 * then an error is returned, and the out param is null.
 *
 * pStg:		The IWiaPropertyStorage that we want to read the property from
 * propid:		the property that we want to read and coherce
 * pbstrProp:	Out, recieves the value of the property, or NULL on error
 *--(samclem)-----------------------------------------------------------------*/
HRESULT GetWiaPropertyBSTR( IWiaPropertyStorage* pStg, PROPID propid, BSTR* pbstrProp )
{
	Assert( pbstrProp != NULL );
	Assert( pStg != NULL );
	
	PROPVARIANT vaProp;
	*pbstrProp = NULL;
	
	if ( FAILED( GetWiaProperty( pStg, propid, &vaProp ) ) )
		return E_FAIL;

	switch ( vaProp.vt )
		{
	case VT_EMPTY:
		*pbstrProp = SysAllocString( L"" );
		break;
		
	case VT_BSTR:
	case VT_LPWSTR:
		*pbstrProp = SysAllocString( vaProp.pwszVal );
		break;

	case VT_CLSID:
		{
		OLECHAR rgoch[100] = { 0 }; // more than enough for a clsid
		if ( SUCCEEDED( StringFromGUID2( *vaProp.puuid, rgoch, 100 ) ) )
			{
			*pbstrProp = SysAllocString( rgoch );
			}
		}
		break;		
		}

	PropVariantClear( &vaProp );
	if ( NULL == *pbstrProp )
		return E_FAIL;

	return S_OK;
}

// helper macro
#define SETVAR( vti, in, out, field ) \
	(out)->vt = vti; \
	(out)->field = (in)->field; \
	break

#define SETVAR_( vti, val, out, field, err ) \
	(out)->vt = vti; \
	(out)->field = val; \
	if ( !((out)->field) ) \
		return (err); \
	break

/*-----------------------------------------------------------------------------
 * PropVariantToVariant
 *
 * This copies the contents of the PropVariant to a variant.
 *
 * pvaProp:	the prop variant to copy from
 * pvaOut:	the variant to copy into
 *--(samclem)-----------------------------------------------------------------*/
HRESULT PropVariantToVariant( const PROPVARIANT* pvaProp, VARIANT* pvaOut )
{
	Assert( pvaProp && pvaOut );

	// init the out param
	VariantInit( pvaOut );
	
	switch ( pvaProp->vt )
		{
	case VT_EMPTY:
		VariantInit( pvaOut );
		pvaOut->vt = VT_EMPTY;
		break;
	case VT_UI1:
		SETVAR( VT_UI1, pvaProp, pvaOut, bVal );
	case VT_I2:
		SETVAR( VT_I2, pvaProp, pvaOut, iVal );
	case VT_I4:
		SETVAR( VT_I4, pvaProp, pvaOut, lVal );
	case VT_R4:
		SETVAR( VT_R4, pvaProp, pvaOut, fltVal );
	case VT_R8:
		SETVAR( VT_R8, pvaProp, pvaOut, dblVal );
	case VT_CY:
		SETVAR( VT_CY, pvaProp, pvaOut, cyVal );
	case VT_DATE:
		SETVAR( VT_DATE, pvaProp, pvaOut, date );
	case VT_BSTR:
		SETVAR_( VT_BSTR, SysAllocString( pvaProp->bstrVal ), pvaOut, bstrVal, E_OUTOFMEMORY );
	case VT_BOOL:
		SETVAR( VT_BOOL, pvaProp, pvaOut, boolVal );
	case VT_LPWSTR:
		SETVAR_( VT_BSTR, SysAllocString( pvaProp->pwszVal ), pvaOut, bstrVal, E_OUTOFMEMORY );
	case VT_LPSTR:
		{
			if ( pvaProp->pszVal )
				{
				WCHAR* pwch = NULL;
				size_t len = strlen( pvaProp->pszVal ) + 1;
				pwch = new WCHAR[len];
				if ( !pwch )
					return E_OUTOFMEMORY;

				if ( !MultiByteToWideChar( CP_ACP, 0, 
							pvaProp->pszVal, -1, pwch, len ) )
					{
					delete[] pwch;
					return E_FAIL;
					}
			
				pvaOut->vt = VT_BSTR;
				pvaOut->bstrVal = SysAllocString( pwch );
				
				delete[] pwch;
				if ( !pvaOut->bstrVal )
					return E_OUTOFMEMORY;
				break;
				}
			else
				{
				SETVAR_( VT_BSTR, SysAllocString( L"" ), pvaOut, bstrVal, E_OUTOFMEMORY );
				}
		}
#if defined(LATERW2K_PLATSDK)
	case VT_UNKNOWN:
		pvaOut->vt = VT_UNKNOWN;
		pvaOut->punkVal = pvaProp->punkVal;
		pvaOut->punkVal->AddRef();
		break;

	case VT_DISPATCH:
		pvaOut->vt = VT_DISPATCH;
		pvaOut->pdispVal = pvaProp->pdispVal;
		pvaOut->pdispVal->AddRef();
		break;
	case VT_SAFEARRAY:
		if ( FAILED( SafeArrayCopy( pvaProp->parray, &pvaOut->parray ) ) )
			return E_FAIL;

		pvaOut->vt = VT_SAFEARRAY;
		break;
#endif //defined(LATERW2K_PLATSDK)

	default:
		return E_FAIL;
		}

	return S_OK;
}

HRESULT VariantToPropVariant( const VARIANT* pvaIn, PROPVARIANT* pvaProp )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\core\wiascr\wiautil.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiautil.h
 * Author:	Samuel Clement (samclem)
 * Date:	Mon Aug 16 13:22:36 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Description:
 * 	This contains the declaration of the wia util functions
 *
 * History:
 * 	16 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIAUTIL_H_
#define _WIAUTIL_H_

// this is the structure of a string table. A string table is used to look
// up a string for a specified value.  And to look up the value for a specified
// string. This supports assigning a string to range of numbers.
struct STRINGTABLE
{
	DWORD 	dwStartRange;
	DWORD 	dwEndRange;
	WCHAR*	pwchValue;
};

// define a new string table with name "x"
#define STRING_TABLE(x) \
	static const STRINGTABLE x[] = { \
	{ 0, 0, NULL },

// define a new string table with name "x" and the default value of "str"
#define STRING_TABLE_DEF( x, str ) \
	static const STRINGTABLE x[] = { \
	{ 0, 0, ( L ## str ) },

// add an entry to the string table.  
#define STRING_ENTRY( s, str )	\
	{ (s), (s),	( L ## str ) },

// Add a ranged entry to the string table
#define STRING_ENTRY2( s, e, str ) \
	{ (s), (e), ( L ## str ) },

// end the string table
#define END_STRING_TABLE() \
	{ 0, 0, NULL } \
	};

// returns the string for the specified value, or the default
// value if not found.  If no default was supplied then this
// returns NULL.
WCHAR* GetStringForVal( const STRINGTABLE* pStrTable, DWORD dwVal );

// this retrieves the desired property from the IWiaPropertyStorage, it will fill
// the variant passed it.  It doesn't have to be initialized.
HRESULT GetWiaProperty( IWiaPropertyStorage* pStg, PROPID propid, PROPVARIANT* pvaProp );

// this will retrieve the desired property from the IWiaPropertyStorage and 
// coherce the type to a BSTR and allocate one for the out param pbstrProp.
HRESULT GetWiaPropertyBSTR( IWiaPropertyStorage* pStg, PROPID propid, BSTR* pbstrProp );

// Conversion methods which copy a PROPVARIANT from a variant
// structure
HRESULT PropVariantToVariant( const PROPVARIANT* pvaProp, VARIANT* pvaOut );
HRESULT VariantToPropVariant( const VARIANT* pvaIn, PROPVARIANT* pvaProp );

#endif //_WIAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\wiatempl.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    wiatempl.h

Abstract:

    This module declares useful types such as CWiaArray and CWiaMap.
    These were lifted from the ATL library (atlbase.h).

Author:

    DavePar
    
Revision History:


--*/

#ifndef TYPEUTIL__H_
#define TYPEUTIL__H_

#ifndef ASSERT
#define ASSERT(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CWiaArray & CWiaMap

template <class T>
class CWiaArray
{
public:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

// Construction/destruction
    CWiaArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CWiaArray()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL GrowTo(int size)
    {
        if (size > m_nAllocSize)
        {
            T* aT;
            aT = (T*) realloc(m_aT, size * sizeof(T));
            if (aT == NULL)
                return FALSE;
            m_nAllocSize = size;
            m_aT = aT;
        }
        return TRUE;
    }
    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
            if (!GrowTo(nNewAllocSize))
                return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    int AddN(T& t) // Adds the new item and returns its index
    {
        if (Add(t))
            return m_nSize - 1;
        else
            return -1;
    }
    BOOL Push(T& t)
    {
        return Add(t);
    }
    BOOL Pop(T& t)
    {
        if (m_nSize == 0)
            return FALSE;
        t = m_aT[m_nSize - 1];
        return RemoveAt(m_nSize - 1);
    }
    BOOL Remove(const T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {

        //---- always call the dtr ----
#if _MSC_VER >= 1200
        m_aT[nIndex].~T();
#else
        T* MyT;
                MyT = &m_aT[nIndex];
                MyT->~T();
#endif

        //---- if target entry is not at end, compact the array ----
        if(nIndex != (m_nSize - 1))
        {
            
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
        }

        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aT != NULL)
        {
            for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
                m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
            free(m_aT);
            m_aT = NULL;
        }
        m_nSize = 0;
        m_nAllocSize = 0;
    }
    T& operator[] (int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

// Implementation
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <class _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, T& t)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aT + nIndex) Wrapper(t);
    }
    int Find(const T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
    BOOL Parse(BYTE **ppRaw, int NumSize = 4)
    {
        if (!ppRaw || !*ppRaw)
            return FALSE;
    
        RemoveAll();
    
        // Get the number of elements from the raw data
        int NumElems;
        DWORD *pDword = (DWORD *) *ppRaw;
        WORD *pWord = (WORD *) *ppRaw;
        switch (NumSize)
        {
        case 4:
            NumElems = *pDword;
            break;
        case 2:
            NumElems = *pWord;
            break;
        case 1:
            NumElems = **ppRaw;
            break;
        default:
            return FALSE;
        }

        *ppRaw += NumSize;
    
        // Allocate space for the array
        if (!GrowTo(NumElems))
            return FALSE;
    
        // Copy in the elements
        memcpy(m_aT, *ppRaw, NumElems * sizeof(T));
        m_nSize = NumElems;
    
        // Advance the raw pointer past the array and number of elements field
        *ppRaw += NumElems * sizeof(T);
    
        return TRUE;
    }
};

// for arrays of simple types
template <class T>
class CWiaValArray : public CWiaArray< T >
{
public:
    BOOL Add(T t)
    {
        return CWiaArray< T >::Add(t);
    }
    BOOL Remove(T t)
    {
        return CWiaArray< T >::Remove(t);
    }
    T operator[] (int nIndex) const
    {
        return CWiaArray< T >::operator[](nIndex);
    }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CWiaMap
{
public:
    TKey* m_aKey;
    TVal* m_aVal;
    int m_nSize;

// Construction/destruction
    CWiaMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
    { }

    ~CWiaMap()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Add(TKey key, TVal val)
    {
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
        if(pKey == NULL)
            return FALSE;
        m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
        if(pVal == NULL)
            return FALSE;
        m_aVal = pVal;
        m_nSize++;
        SetAtIndex(m_nSize - 1, key, val);
        return TRUE;
    }
    BOOL Remove(TKey key)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        if(nIndex != (m_nSize - 1))
        {
            m_aKey[nIndex].~TKey();
#if _MSC_VER >= 1200
            m_aVal[nIndex].~TVal();
#else
            TVal * t1;
            t1 = &m_aVal[nIndex];
            t1->~TVal();
#endif
            memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
            memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
        }
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
        if(pKey != NULL || m_nSize == 1)
            m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
        if(pVal != NULL || m_nSize == 1)
            m_aVal = pVal;
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aKey != NULL)
        {
            for(int i = 0; i < m_nSize; i++)
            {
                m_aKey[i].~TKey();
#if _MSC_VER >= 1200
                m_aVal[i].~TVal();
#else
                TVal * t1;
                t1 = &m_aVal[i];
                t1->~TVal();
#endif
            }
            free(m_aKey);
            m_aKey = NULL;
        }
        if(m_aVal != NULL)
        {
            free(m_aVal);
            m_aVal = NULL;
        }

        m_nSize = 0;
    }
    BOOL SetAt(TKey key, TVal val)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        SetAtIndex(nIndex, key, val);
        return TRUE;
    }
    TVal Lookup(TKey key) const
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetValueAt(nIndex);
    }
    TKey ReverseLookup(TVal val) const
    {
        int nIndex = FindVal(val);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetKeyAt(nIndex);
    }
    TKey& GetKeyAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aKey[nIndex];
    }
    TVal& GetValueAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aVal[nIndex];
    }

// Implementation

    template <typename T>
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <typename _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, TKey& key, TVal& val)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aKey + nIndex) Wrapper<TKey>(key);
        new(m_aVal + nIndex) Wrapper<TVal>(val);
    }
    int FindKey(TKey& key) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aKey[i] == key)
                return i;
        }
        return -1;  // not found
    }
    int FindVal(TVal& val) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aVal[i] == val)
                return i;
        }
        return -1;  // not found
    }
};

#endif // TYPEUTIL__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\pch.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 2001
*
*  TITLE:       pch.h
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Procomplied header for WIA File System Device driver object
*
*******************************************************************************/

#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef UNICODE
#define UNICODE
#endif

#include <stdio.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include <wiamindr.h>
#include <wiautil.h>

#include "wiatempl.h"
#include "resource.h"
#include "FScam.h"
#include "wiacam.h"
//#include "coreDbg.h"

#include <strsafe.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\root.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2001, MICROSOFT CORP.
*
*  TITLE:       Root.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for the root item.
*
*******************************************************************************/

#include "pch.h"

/**************************************************************************\
* BuildRootItemProperties
*
*   Create the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildRootItemProperties(
    BYTE *pWiasContext
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::BuildRootItemProperties");
    
    HRESULT hr = S_OK;

    //
    // Create a WIA property list and allocate enough space for all
    // the properties created below
    //
    CWiauPropertyList RootProps;

    hr = RootProps.Init(50);

    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, initializing property list failed"));
        return hr;
    }

    //
    // These are the WHQL required properties for cameras:
    //
    INT index;

    hr = RootProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, (LONG) WIA_ITEM_READ | WIA_ITEM_WRITE);

    hr = RootProps.DefineProperty(&index, WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.FirmwareVersion);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.PicturesTaken);

#ifdef COUNT_PIC_REMAINING
    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.PicturesRemaining);
#endif

    //
    // These are WHQL optional properties
    //

#if DEADCODE
    
    hr = RootProps.DefineProperty(&index, WIA_DPA_DEVICE_TIME, WIA_DPA_DEVICE_TIME_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, &m_DeviceInfo.Time);


    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_MODE, WIA_DPC_EXPOSURE_MODE_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureMode);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_COMP, WIA_DPC_EXPOSURE_COMP_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureComp);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_TIME, WIA_DPC_EXPOSURE_TIME_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureTime);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FNUMBER, WIA_DPC_FNUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FLASH_MODE, WIA_DPC_FLASH_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FlashMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_MODE, WIA_DPC_FOCUS_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocusMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PAN_POSITION, WIA_DPC_PAN_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PanPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TILT_POSITION, WIA_DPC_TILT_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TiltPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_MODE, WIA_DPC_TIMER_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TimerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_VALUE, WIA_DPC_TIMER_VALUE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TimerValue);

    hr = RootProps.DefineProperty(&index, WIA_DPC_POWER_MODE, WIA_DPC_POWER_MODE_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PowerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BATTERY_STATUS, WIA_DPC_BATTERY_STATUS_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.BatteryStatus);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_WIDTH, WIA_DPC_THUMB_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ThumbWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_HEIGHT, WIA_DPC_THUMB_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ThumbHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PictWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PictHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_COMPRESSION_SETTING, WIA_DPC_COMPRESSION_SETTING_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.CompressionSetting);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMELAPSE_INTERVAL, WIA_DPC_TIMELAPSE_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TimelapseInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_INTERVAL, WIA_DPC_BURST_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.BurstInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_NUMBER, WIA_DPC_BURST_NUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.BurstNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EFFECT_MODE, WIA_DPC_EFFECT_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.EffectMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_DIGITAL_ZOOM, WIA_DPC_DIGITAL_ZOOM_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.DigitalZoom);

    hr = RootProps.DefineProperty(&index, WIA_DPC_SHARPNESS, WIA_DPC_SHARPNESS_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.Sharpness);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CONTRAST, WIA_DPC_CONTRAST_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.Constrast);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_MODE, WIA_DPC_CAPTURE_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.CaptureMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_DELAY, WIA_DPC_CAPTURE_DELAY_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.CaptureDelay);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_INDEX, WIA_DPC_EXPOSURE_INDEX_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureIndex);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_METERING_MODE, WIA_DPC_EXPOSURE_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_METERING_MODE, WIA_DPC_FOCUS_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocusMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_DISTANCE, WIA_DPC_FOCUS_DISTANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocusDistance);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCAL_LENGTH, WIA_DPC_FOCAL_LENGTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocalLength);

    hr = RootProps.DefineProperty(&index, WIA_DPC_RGBGAIN, WIA_DPC_RGBGAIN_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.RGBGain);

    hr = RootProps.DefineProperty(&index, WIA_DPC_WHITE_BALANCE, WIA_DPC_WHITE_BALANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.WhiteBalance);

#endif // DEADCODE

    //
    // TODO: Add other optional properties that your device supports here
    //


    // Last step: send all the properties to WIA

    hr = RootProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, SendToWia failed"));
    }

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //
failure:
    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, DefineProperty failed"));
    return hr;
}

/**************************************************************************\
* ReadRootItemProperties
*
*   Update the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::ReadRootItemProperties(
    BYTE           *pWiasContext,
    LONG            NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::ReadRootItemProperties");
    HRESULT hr = S_OK;

    if (!NumPropSpecs || !pPropSpecs)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadRootItemProperties, invalid arg"));
        return E_INVALIDARG;
    }

    //
    // Loop through all of the PropSpecs
    //
    for (int count = 0; count < NumPropSpecs; count++)
    {
        PROPID propId = pPropSpecs[count].propid;
        
        switch (propId)
        {
        case WIA_DPC_PICTURES_TAKEN:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, m_DeviceInfo.PicturesTaken);
            break;

#ifdef COUNT_PIC_REMAINING
        case WIA_DPC_PICTURES_REMAINING:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_REMAINING, m_DeviceInfo.PicturesRemaining);
            break;
#endif
        default:
            break;
        }
        
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadRootItemProperties, wiasWritePropLong failed 0x%08x", propId));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2001, MICROSOFT CORP.
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA File System Device driver IWiaMiniDrv methods. This file
*   contains 3 sections. The first is the WIA minidriver entry points, all
*   starting with "drv". The next section is public help methods. The last
*   section is private helper methods.
*
*******************************************************************************/

#include "pch.h"

//
// This structure is a convenient way to map between the FORMAT_CODEs and info
// useful for WIA, such as the format GUIDs and item types. These need to
// correspond to the constants defined in FakeCam.h.
//

// FORMAT_INFO *g_FormatInfo;
// extern UINT g_NumFormatInfo=0;


// The following are utility functions for populate the g_FormatInfo array
LONG GetTypeInfoFromRegistry(HKEY *phKeyExt, WCHAR *wcsKeyName, GUID *pFormatGuid)
{
	if( !pFormatGuid )
	{
		return ITEMTYPE_FILE;  // In this case, no info from Registry about file type.
	}

    HKEY hKeyCur;
	const int c_nMaxValueLength = 64;

    DWORD dwRet = RegOpenKeyExW(*phKeyExt, wcsKeyName, 0, KEY_READ | KEY_QUERY_VALUE, &hKeyCur);

    if( dwRet != ERROR_SUCCESS )
    {
        return ITEMTYPE_FILE;
    }

    WCHAR wcsValueName[c_nMaxValueLength] = L"Generic";
    WCHAR wcsData[MAX_PATH];
    DWORD dwType = REG_SZ;
    DWORD dwSize = MAX_PATH;

    dwRet = RegQueryValueExW(hKeyCur,
        wcsValueName, NULL, &dwType, (LPBYTE)wcsData, &dwSize );

    DWORD dwItemType = ITEMTYPE_FILE;

    if( ERROR_SUCCESS == dwRet )
    {
         if( CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
             NORM_IGNORECASE, L"image", 5, wcsData, 5) )
         {
            dwItemType = ITEMTYPE_IMAGE;
         }
         else if ( CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
             NORM_IGNORECASE, L"audio", 5, wcsData, 5) )
         {
            dwItemType = ITEMTYPE_AUDIO;
         }
         else if ( CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
             NORM_IGNORECASE, L"video", 5, wcsData, 5) )
         {
            dwItemType = ITEMTYPE_VIDEO;
         }
         else
         {
            dwItemType = ITEMTYPE_FILE;
         }
    }

	StringCchCopyW(wcsValueName, c_nMaxValueLength, L"FormatGUID");
 
    dwType = REG_SZ;
    dwSize = MAX_PATH;
    dwRet = RegQueryValueExW(hKeyCur,
        wcsValueName,
        NULL,
        &dwType,
        (LPBYTE)wcsData,
        &dwSize );

    if( ERROR_SUCCESS == dwRet )
    {
        wcsData[dwSize]=0;
        if( NOERROR != CLSIDFromString(wcsData, pFormatGuid))
        {
            CopyMemory(pFormatGuid, (CONST VOID *)&WiaImgFmt_UNDEFINED, sizeof(GUID));
        }
    }
    else
    {
        CopyMemory(pFormatGuid, (CONST VOID *)&WiaImgFmt_UNDEFINED, sizeof(GUID));
    }

    RegCloseKey(hKeyCur);
    return dwItemType;
}

DWORD CWiaCameraDevice::PopulateFormatInfo(void)
{
    HKEY hKeyExt = NULL;
    DWORD dwRet, dwCurAllocation = 32;
    DWORD dwIndex=0, dwIndexBase=0, dwKeyNameSize=32;

    m_FormatInfo = (FORMAT_INFO *)CoTaskMemAlloc(sizeof(FORMAT_INFO)*dwCurAllocation);

    if( !m_FormatInfo )
    {
        dwRet = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    m_FormatInfo[0].FormatGuid = WiaImgFmt_UNDEFINED;
    m_FormatInfo[0].ItemType = ITEMTYPE_FILE;
    m_FormatInfo[0].ExtensionString[0] = L'\0';
    dwIndexBase=1;
    dwIndex=0;

    dwRet = RegOpenKeyExW(HKEY_CLASSES_ROOT,
        L"CLSID\\{D2923B86-15F1-46FF-A19A-DE825F919576}\\SupportedExtension",
        0, KEY_READ | KEY_QUERY_VALUE, &hKeyExt);

    if( ERROR_SUCCESS != dwRet )   // No Key exist
    {
        goto Compilation;
    }

    WCHAR wcsKeyName[32], *pExt;
    FILETIME ftLWT;
    dwRet = RegEnumKeyExW(hKeyExt, dwIndex, wcsKeyName, &dwKeyNameSize, NULL, NULL, NULL, &ftLWT);

    if( ERROR_SUCCESS != dwRet )  // No key exist
    {
        goto Compilation;
    }

    while ( dwRet == ERROR_SUCCESS )
    {
        pExt = (wcsKeyName[0]==L'.'?(&wcsKeyName[1]):(&wcsKeyName[0])); // remove the dot
        pExt[MAXEXTENSIONSTRINGLENGTH-1] = NULL;  // Truncate to avoid overrun

        // Set values in FORMAT_INFO structure
        StringCchCopyW(m_FormatInfo[dwIndex+dwIndexBase].ExtensionString, MAXEXTENSIONSTRINGLENGTH, pExt);
		m_FormatInfo[dwIndex+dwIndexBase].ItemType = GetTypeInfoFromRegistry(&hKeyExt, wcsKeyName, &(m_FormatInfo[dwIndex+dwIndexBase].FormatGuid));

        dwIndex++;
        if( dwIndex+dwIndexBase > dwCurAllocation-1 )  // need allocate more memory
        {
            dwCurAllocation += 32;
            m_FormatInfo = (FORMAT_INFO *)CoTaskMemRealloc(m_FormatInfo, sizeof(FORMAT_INFO)*dwCurAllocation);
            if( !m_FormatInfo )
            {
                dwRet = ERROR_OUTOFMEMORY;
                dwIndex --;
                goto Exit;
            }
        }
        dwKeyNameSize=32;
        dwRet = RegEnumKeyExW(hKeyExt, dwIndex, wcsKeyName, &dwKeyNameSize, NULL, NULL, NULL, &ftLWT);
    }

    if(dwRet == ERROR_NO_MORE_ITEMS )
    {
        dwRet = ERROR_SUCCESS;
        goto Exit;
    }

Compilation:   // Compile a fixed list of formats when error occurs

    dwIndex=dwIndexBase=0;
    dwRet = ERROR_SUCCESS;

    DEFAULT_FORMAT_INFO g_DefaultFormats[] =
    {
        { (GUID *)&WiaImgFmt_UNDEFINED,       ITEMTYPE_FILE,     L""   },  // Unknown
        { (GUID *)&WiaImgFmt_JPEG,  ITEMTYPE_IMAGE, L"JPG"  },  // JPEG or EXIF
        { (GUID *)&WiaImgFmt_TIFF,  ITEMTYPE_IMAGE, L"TIF"  },  // TIFF
        { (GUID *)&WiaImgFmt_BMP,   ITEMTYPE_IMAGE, L"BMP"  },  // BMP
        { (GUID *)&WiaImgFmt_GIF,   ITEMTYPE_IMAGE, L"GIF"  },  // GIF
        { NULL, 0, NULL }
    };

    while( g_DefaultFormats[dwIndex].pFormatGuid )
    {
          m_FormatInfo[dwIndex].FormatGuid = *g_DefaultFormats[dwIndex].pFormatGuid;
          m_FormatInfo[dwIndex].ItemType = g_DefaultFormats[dwIndex].ItemType;
          StringCchCopyW(m_FormatInfo[dwIndex].ExtensionString, MAXEXTENSIONSTRINGLENGTH, g_DefaultFormats[dwIndex].ExtensionString);
          dwIndex++;
    }

Exit:
    m_NumFormatInfo = dwIndex+dwIndexBase;
    if (hKeyExt != NULL ) {
        RegCloseKey(hKeyExt);
        hKeyExt = NULL;
    }
    return dwRet;
}

void CWiaCameraDevice::UnPopulateFormatInfo(void)
{
    CoTaskMemFree(m_FormatInfo);
}

/**************************************************************************\
* CWiaCameraDevice::drvInitializeWia
*
*   Initialize the WIA mini driver. This function will be called each time an
*   application creates a device. The first time through, the driver item tree
*   will be created and other initialization will be done.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvInitializeWia");
    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("drvInitializeWia, device ID: %ws", bstrDeviceID));

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    m_ConnectedApps++;;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, number of connected apps is now %d", m_ConnectedApps));

    if (m_ConnectedApps == 1)
    {
        if (ERROR_SUCCESS != PopulateFormatInfo() ) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to populate FormatInfo array"));
            return E_OUTOFMEMORY;
        }

        //
        // Save STI device interface for calling locking functions
        //
        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID
        //
        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root item name
        //
        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate root item name"));
            return E_OUTOFMEMORY;
        }

        if( m_pDevice )
        {
            m_pDevice->m_FormatInfo = m_FormatInfo;
            m_pDevice->m_NumFormatInfo = m_NumFormatInfo;
        }
        else
        {
            return (HRESULT_FROM_WIN32(ERROR_INVALID_ACCESS));
        }

        //
        // Get information from the device
        //
        hr = m_pDevice->GetDeviceInfo(&m_DeviceInfo);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, GetDeviceInfo failed"));
            return hr;
        }

        //
        // Build the capabilities array
        //
        hr = BuildCapabilities();
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
            return hr;
        }

        //
        //  Build the device item tree
        //
        hr = BuildItemTree();
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildItemTree failed"));
            return hr;
        }

    }

    *ppIDrvItemRoot = m_pRootItem;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnInitializeWia(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvUnInitializeWia");
    HRESULT hr = S_OK;

    m_ConnectedApps--;

    if (m_ConnectedApps == 0)
    {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvUnInitializeWia, connected apps is zero, freeing resources..."));

        // Destroy the driver item tree
        hr = DeleteItemTree(WiaItemTypeDisconnected);
        if (FAILED(hr))
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvUnInitializeWia, UnlinkItemTree failed"));

        // Delete allocated arrays
        DeleteCapabilitiesArrayContents();

        // Free the device info structure
        m_pDevice->FreeDeviceInfo(&m_DeviceInfo);

        // Free the item handle map
        m_HandleItemMap.RemoveAll();

        // Free the storage for the device ID
        if (m_bstrDeviceID) {
            SysFreeString(m_bstrDeviceID);
        }

        // Free the storage for the root item name
        if (m_bstrRootFullItemName) {
            SysFreeString(m_bstrRootFullItemName);
        }

        UnPopulateFormatInfo();

        //
        // Do not delete the device here, because GetStatus may still be called later
        //

    /*
        // Kill notification thread if it exists.
        SetNotificationHandle(NULL);

        // Close event for syncronization of notifications shutdown.
        if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
            CloseHandle(m_hShutdownEvent);
            m_hShutdownEvent = NULL;
        }


        //
        // WIA member destruction
        //

        // Cleanup the WIA event sink.
        if (m_pIWiaEventCallback) {
            m_pIWiaEventCallback->Release();
            m_pIWiaEventCallback = NULL;
        }

    */

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree. For the root item, just set the properties already
*   set up in drvInitializeWia. For child items, access the camera for
*   information about the item and for images also get the thumbnail.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildRootItemProperties(pWiasContext);

    } else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildChildItemProperties(pWiasContext);

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(100);
}

/**************************************************************************\
* CWiaCameraDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvUnLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWiaCameraDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvFreeDrvItemContext");
    *plDevErrVal = 0;

    ITEM_CONTEXT *pItemCtx = (ITEM_CONTEXT *) pSpecContext;

    if (pItemCtx)
    {
        if (!m_HandleItemMap.Remove(pItemCtx->ItemHandle))
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvFreeDrvItemContext, remove on handle item map failed"));

        if (pItemCtx->ItemHandle)
            m_pDevice->FreeItemInfo(pItemCtx->ItemHandle);
        pItemCtx->ItemHandle = NULL;

        if (pItemCtx->pFormatInfo)
        {
            delete []pItemCtx->pFormatInfo;
            pItemCtx->pFormatInfo = NULL;
        }
        pItemCtx->NumFormatInfo = 0;

        if (pItemCtx->pThumb)
        {
            delete []pItemCtx->pThumb;
            pItemCtx->pThumb = NULL;
        }
        pItemCtx->ThumbSize = 0;
    }

    return S_OK;
}

/**************************************************************************\
* CWiaCameraDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvReadItemProperties");
    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvReadItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadRootItemProperties(pWiasContext, nPropSpec, pPropSpec);

    } else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadChildItemProperties(pWiasContext, nPropSpec, pPropSpec);

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;

    //
    // This function doesn't need to do anything, because all of the camera
    // properties are written in drvValidateItemProperties
    //

    *plDevErrVal = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAcquireItemData
*
*   Transfer data from a mini driver item to device manger.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvAcquireItemData");
    HRESULT hr = S_OK;

    plDevErrVal = 0;

    //
    // Locals
    //
    BYTE *pTempBuf = NULL;
    LONG lBufSize = 0;

    //
    // Get item context
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, GetDrvItemContext"));
        return hr;
    }

    //
    // If the format requested is BMP or DIB, and the image is not already in BMP
    // format, convert it
    //
    BOOL bConvert = (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) && !(IsEqualGUID(m_FormatInfo[pItemCtx->ItemHandle->Format].FormatGuid, WiaImgFmt_BMP)) ) ||
                    (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP) && !(IsEqualGUID(m_FormatInfo[pItemCtx->ItemHandle->Format].FormatGuid, WiaImgFmt_MEMORYBMP)) );

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("drvAcquireItemData, FormatCode=%d, bConvert=%d", pItemCtx->ItemHandle->Format, bConvert));

    //
    // If the class driver did not allocate the transfer buffer or the image is being
    // converted to DIB or BMP, allocate a temporary buffer.
    //
    if (bConvert || !pmdtc->bClassDrvAllocBuf) {
        lBufSize = pItemCtx->ItemHandle->Size;
        pTempBuf = new BYTE[lBufSize];
        if (!pTempBuf)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, buffer allocation failed"));
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    // Acquire the data from the device
    //
    hr = AcquireData(pItemCtx, pmdtc, pTempBuf, lBufSize, bConvert);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, AcquireData failed"));
        goto Cleanup;
    }
    if (hr == S_FALSE)
    {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, transfer cancelled"));
        goto Cleanup;
    }

    //
    // Now convert the data to BMP, if necessary
    //
    if (bConvert)
    {
        hr = Convert(pWiasContext, pItemCtx, pmdtc, pTempBuf, lBufSize);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, Convert failed"));
            goto Cleanup;
        }
    }

Cleanup:
    if (pTempBuf)
    {
        delete []pTempBuf;
        pTempBuf = NULL;
        lBufSize = 0;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    *pcelt = 0;
    *ppwfi = NULL;

    IWiaDrvItem *pWiaDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, wiasGetDrvItem failed"));
        return hr;
    }

    ITEM_CONTEXT *pItemCtx = NULL;
    hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **) &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, GetDeviceSpecContext failed"));
        return hr;
    }

    if (!pItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, item context is null"));
        return E_FAIL;
    }

    FORMAT_CODE FormatCode;
    WIA_FORMAT_INFO *pwfi;

    if (!pItemCtx->pFormatInfo)
    {
        //
        // The format info list is not intialized. Do it now.
        //
        LONG ItemType;
        DWORD ui32;

        hr = wiasGetItemType(pWiasContext, &ItemType);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, wiasGetItemType failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }


        if ((ItemType&WiaItemTypeFile)&&(ItemType&WiaItemTypeImage) )
        {
            //
            // Create the supported format for the item, based on the format stored in the
            // ObjectInfo structure.
            //
            if (!pItemCtx->ItemHandle)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, ItemHandle is not initialized"));
                return E_FAIL;
            }

            //
            // If the format is not BMP, add the BMP types to the format array,
            // since this driver must support converting those to BMP
            //
            FormatCode = pItemCtx->ItemHandle->Format;

            BOOL bIsBmp = (IsEqualGUID(m_FormatInfo[FormatCode].FormatGuid, WiaImgFmt_BMP)) ||
                          (IsEqualGUID(m_FormatInfo[FormatCode].FormatGuid, WiaImgFmt_MEMORYBMP));

            ULONG NumWfi = bIsBmp ? 1 : 2;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            pwfi = new WIA_FORMAT_INFO[2 * NumWfi];
            if (!pwfi)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, memory allocation failed"));
                return E_OUTOFMEMORY;
            }

            pwfi[0].guidFormatID = WiaImgFmt_BMP;
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].guidFormatID = WiaImgFmt_MEMORYBMP;
            pwfi[1].lTymed = TYMED_CALLBACK;

            FORMAT_INFO *pFormatInfo = FormatCode2FormatInfo(FormatCode);

            //
            // Add entries when appropriate
            //
            if (!bIsBmp)
            {
                pwfi[2].guidFormatID = pFormatInfo->FormatGuid;
                pwfi[2].lTymed = TYMED_FILE;
                pwfi[3].guidFormatID = pFormatInfo->FormatGuid;
                pwfi[3].lTymed = TYMED_CALLBACK;
           }

            pItemCtx->NumFormatInfo = 2 * NumWfi;
            pItemCtx->pFormatInfo = pwfi;
        }
        else if (ItemType & WiaItemTypeFile) {

            if (!pItemCtx->ItemHandle)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, ItemHandle is not initialized"));
                return E_FAIL;
            }

            FormatCode = pItemCtx->ItemHandle->Format;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            pwfi = new WIA_FORMAT_INFO[2];
            if (!pwfi)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, memory allocation failed"));
                return E_OUTOFMEMORY;
            }

            FORMAT_INFO *pFormatInfo = FormatCode2FormatInfo(FormatCode);

            if( !pFormatInfo )
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, FormatCode2FormatInfo failed"));
                return E_FAIL;
            }

            pwfi[0].guidFormatID = pFormatInfo->FormatGuid;
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].guidFormatID = pFormatInfo->FormatGuid;
            pwfi[1].lTymed = TYMED_CALLBACK;

            //
            // Add entries when appropriate
            //
            pItemCtx->NumFormatInfo = 2;
            pItemCtx->pFormatInfo = pwfi;
        }
        else
        //  ((ItemType & WiaItemTypeFolder) || (ItemType & WiaItemTypeRoot))
        {
            //
            // Folders and the root don't really need format info, but some apps may fail
            // without it. Create a fake list just in case.
            //
            pItemCtx->pFormatInfo = new WIA_FORMAT_INFO[2];

            if (!pItemCtx->pFormatInfo)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, memory allocation failed"));
                return E_OUTOFMEMORY;
            }

            pItemCtx->NumFormatInfo = 2;
            pItemCtx->pFormatInfo[0].lTymed = TYMED_FILE;
            pItemCtx->pFormatInfo[0].guidFormatID = FMT_NOTHING;
            pItemCtx->pFormatInfo[1].lTymed = TYMED_CALLBACK;
            pItemCtx->pFormatInfo[1].guidFormatID = FMT_NOTHING;
        }

    }   // end of IF

    *pcelt = pItemCtx->NumFormatInfo;
    *ppwfi = pItemCtx->pFormatInfo;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
***************************************************************************/

HRESULT CWiaCameraDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvValidateItemProperties");

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Have the service validate against the valid values for each property
    //
    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed"));
        return hr;
    }

    //
    // Get the item type
    //
    LONG lItemType  = 0;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        return hr;
    }

    //
    // Validate root item properties
    //
    if (lItemType & WiaItemTypeRoot) {

        //
        // None yet
        //

    }

    //
    // Validate child item properties
    //
    else {

        //
        // If tymed property was changed, update format and item size
        //
        if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_TYMED))
        {
            //
            // Create a property context needed by some WIA Service
            // functions used below.
            //
            WIA_PROPERTY_CONTEXT Context;
            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed"));
                return hr;
            }

            //
            // Use the WIA Service to update the valid values
            // for format. It will pull the values from the
            // structure returnd by drvGetWiaFormatInfo, using the
            // new value for tymed.
            //
            hr = wiasUpdateValidFormat(pWiasContext, &Context, (IWiaMiniDrv*) this);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                return hr;
            }

            //
            // Free the property context
            //
            hr = wiasFreePropContext(&Context);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasFreePropContext failed"));
                return hr;
            }

            //
            //  Update the item size
            //
            hr = SetItemSize(pWiasContext);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                return hr;
            }
        }

        //
        // If the format was changed, just update the item size
        //
        else if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_FORMAT))
        {
            //
            //  Update the item size
            //
            hr = SetItemSize(pWiasContext);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                return hr;
            }
        }

        //
        // Unconditionally update WIA_IPA_FILE_EXTENSION to match the current format
        //

        ITEM_CONTEXT *pItemCtx;
        hr = GetDrvItemContext(pWiasContext, &pItemCtx);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, GetDrvItemContext failed"));
            return hr;
        }

        BSTR      bstrFileExt       = NULL;
        ITEM_INFO *pItemInfo        = pItemCtx->ItemHandle;
        FORMAT_INFO *pFormatInfo    = NULL;
        if (pItemInfo)
        {
            pFormatInfo = FormatCode2FormatInfo(pItemInfo->Format);
            if( pFormatInfo->ExtensionString[0] )
            {
                bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
            }
            else // unknown file extension, get it from filename
            {
                WCHAR *pwcsTemp = wcsrchr(pItemInfo->pName, L'.');
                if( pwcsTemp )
                {
                    bstrFileExt = SysAllocString(pwcsTemp+1);
                }
                else
                {
                    bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
                }
            }
        }

        hr = wiasWritePropStr(pWiasContext, WIA_IPA_FILENAME_EXTENSION, bstrFileExt);
        if (bstrFileExt)
        {
            SysFreeString(bstrFileExt);
            bstrFileExt = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeleteItem
*
*   Delete an item from the device.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    plDevErrVal = 0;
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvDeleteItem");
    HRESULT hr = S_OK;

    ITEM_CONTEXT *pItemCtx = NULL;
    IWiaDrvItem *pDrvItem;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx, &pDrvItem);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, GetDrvItemContext failed"));
        return hr;
    }

    hr = m_pDevice->DeleteItem(pItemCtx->ItemHandle);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, delete item failed"));
        return hr;
    }

    //
    // Get the item's full name
    //
    BSTR bstrFullName;
    hr = pDrvItem->GetFullItemName(&bstrFullName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, GetFullItemName failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Queue an "item deleted" event
    //

    hr = wiasQueueEvent(m_bstrDeviceID,
                        &WIA_EVENT_ITEM_DELETED,
                        bstrFullName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, wiasQueueEvent failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);

        // Continue to free the string and return hr
    }


    SysFreeString(bstrFullName);

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::DrvNotifyPnpEvent");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvGetCapabilites");
    *plDevErrVal = 0;

    if( !m_pCapabilities )
    {
        HRESULT hr = BuildCapabilities();
        if( hr != S_OK )
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
            return (hr);
        }
    }
    //
    //  Return values depend on the passed flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    switch (ulFlags) {
        case WIA_DEVICE_COMMANDS:

                //
                //  report commands only
                //

                *pcelt          = m_NumSupportedCommands;
                *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
                break;
        case WIA_DEVICE_EVENTS:

                //
                //  report events only
                //

                *pcelt          = m_NumSupportedEvents;
                *ppCapabilities = m_pCapabilities;
                break;
        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

                //
                //  report both events and commands
                //

                *pcelt          = m_NumCapabilities;
                *ppCapabilities = m_pCapabilities;
                break;
        default:

                //
                //  invalid request
                //

                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
                return E_INVALIDARG;
    }
    return S_OK;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvDeviceCommand");
    *plDevErrVal = 0;
    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Re-build the item tree, if the device needs it.
        //

        if (m_DeviceInfo.bSyncNeeded)
        {
            hr = DeleteItemTree(WiaItemTypeDisconnected);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, DeleteItemTree failed"));
                return hr;
            }

            m_pDevice->FreeDeviceInfo(&m_DeviceInfo);
            memset(&m_DeviceInfo, 0, sizeof(m_DeviceInfo));

            hr = m_pDevice->GetDeviceInfo(&m_DeviceInfo);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, GetDeviceInfo failed"));
                return hr;
            }

            hr = BuildItemTree();
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, BuildItemTree failed"));
                return hr;
            }
        }
    }

#if DEADCODE

    //
    // Not implemented yet
    //
    else if (*plCommand == WIA_CMD_TAKE_PICTURE) {

        //
        // TAKE_PICTURE - Command the camera to capture a new image.
        //

        ITEM_HANDLE NewImage = 0;
        hr = m_pDevice->TakePicture(&NewImage);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, take picture failed"));
            return hr;
        }

        // ISSUE-10/17/2000-davepar Create a new driver item for the new image
    }
#endif

    else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command"));
        hr = E_NOTIMPL;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvAnalyzeItem");
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvGetDeviceErrorStr");
    HRESULT hr = S_OK;
    *plDevErr  = 0;

    //
    //  Map device errors to a string appropriate for showing to the user
    //

    // ISSUE-10/17/2000-davepar These should be read from the resource file

    switch (lDevErrVal) {
        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            hr = E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
\**************************************************************************/

HRESULT CWiaCameraDevice::SetItemSize(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::SetItemSize");
    HRESULT  hr = S_OK;

    LONG lItemSize     = 0;
    LONG lWidthInBytes = 0;
    GUID guidFormatID  = GUID_NULL;

    LONG lNumProperties = 2;
    PROPVARIANT pv[2];
    PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE}};

    //
    // Get the driver item context
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, GetDrvItemContext failed"));
        return hr;
    }

    //
    // Read the format GUID
    //
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }

    if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP) ||
        IsEqualCLSID(guidFormatID, WiaImgFmt_MEMORYBMP))
    {

        if( !(pItemCtx->ItemHandle->Width) ||
            !(pItemCtx->ItemHandle->Depth) ||
            !(pItemCtx->ItemHandle->Height) )
        { // Since we are going to use these, make sure they are filled in
            LONG lNumPropToRead = 3;
            PROPSPEC pPropsToRead[3] = {    {PRSPEC_PROPID, WIA_IPA_DEPTH},
                                            {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
                                            {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE} };

            hr = ReadChildItemProperties(pWiasContext, lNumPropToRead, pPropsToRead);

            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadItemProperties failed"));
                return hr;
            }
        }

        lItemSize = sizeof(BITMAPINFOHEADER);

        //
        // if this is a file, add file header to size
        //
        if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP))
        {
            lItemSize += sizeof(BITMAPFILEHEADER);
        }

        //
        // Calculate number of bytes per line, width must be
        // aligned to 4 byte boundary.
        //
        lWidthInBytes = ((pItemCtx->ItemHandle->Width * pItemCtx->ItemHandle->Depth + 31) & ~31) / 8;

        //
        // Calculate image size
        //
        lItemSize += lWidthInBytes * pItemCtx->ItemHandle->Height;
    }
    else
    {
        lItemSize = pItemCtx->ItemHandle->Size;
        lWidthInBytes = 0;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = lItemSize;
    pv[1].lVal = lWidthInBytes;

    //
    // Write WIA_IPA_ITEM_SIZE and WIA_IPA_BYTES_PER_LINE property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, wiasWriteMultiple failed"));
        return hr;
    }

    return hr;
}

/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* DeleteItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::DeleteItemTree(LONG lReason)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pRootItem) {
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pRootItem->UnlinkItemTree(lReason);

    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, UnlinkItemTree failed"));
        return hr;
    }

    m_pRootItem->Release();
    m_pRootItem = NULL;

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildItemTree()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::BuildItemTree");
    HRESULT hr = S_OK;

    //
    // Make sure the item tree doesn't already exist
    //
    if (m_pRootItem)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, item tree already exists"));
        return E_FAIL;
    }

    //
    //  Create the root item name
    //
    BSTR bstrRoot = SysAllocString(L"Root");
    if (!bstrRoot)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, SysAllocString failed"));
        hr = E_OUTOFMEMORY;
    }

    //
    //  Create the root item
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = wiasCreateDrvItem(WiaItemTypeFolder | WiaItemTypeDevice | WiaItemTypeRoot,
                           bstrRoot,
                           m_bstrRootFullItemName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &m_pRootItem);

    SysFreeString(bstrRoot);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
        return hr;
    }

    //
    // Initialize item context fields for the root
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));
    pItemCtx->ItemHandle = ROOT_ITEM_HANDLE;

    //
    // Put the root item in the handle map
    //
    m_HandleItemMap.Add(ROOT_ITEM_HANDLE, m_pRootItem);

    //
    // Get the list of items from the camera
    //
    ITEM_HANDLE *pItemArray = new ITEM_HANDLE[m_DeviceInfo.TotalItems];
    if (!pItemArray)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, memory allocation failed"));
        return E_OUTOFMEMORY;
    }
    m_pDevice->GetItemList(pItemArray);

    //
    // Create a driver item for each item on the camera
    //
    for (int count = 0; count < m_DeviceInfo.TotalItems; count++)
    {
        hr = AddObject(pItemArray[count]);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddObject failed"));
            return hr;
        }
    }

    return hr;
}

/**************************************************************************\
* AddObject
*
*   Helper function to add an object to the tree
*
* Arguments:
*
*    pItemHandle    - Pointer to the item handle
*
\**************************************************************************/
HRESULT CWiaCameraDevice::AddObject(ITEM_HANDLE ItemHandle, BOOL bQueueEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::AddObject");

    HRESULT hr = S_OK;

    LONG ExtraFlags = 0;

    //
    // Get information about the item from the camera
    //
    ITEM_INFO *pItemInfo = ItemHandle;
    if (!pItemInfo)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, invalid arg"));
        return E_INVALIDARG;
    }

    //
    // Look up the item's parent in the map
    //
    IWiaDrvItem *pParent = NULL;
    pParent = m_HandleItemMap.Lookup(pItemInfo->Parent);

    //
    // If a parent wasn't found, just use the root as the parent
    //
    if (!pParent)
    {
        pParent = m_pRootItem;
    }


#ifdef CHECK_DOT_IN_FILENAME
    //
    // Make sure there is no filename extension in the name
    //
    if (wcschr(pItemInfo->pName, L'.'))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, item name=%S", pItemInfo->pName));
        return E_FAIL;
    }
#endif

    //
    // Create the item's full name
    //
    BSTR bstrItemFullName = NULL;
    BSTR bstrParentName = NULL;

    hr = pParent->GetFullItemName(&bstrParentName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, GetFullItemName failed"));
        return hr;
    }

    WCHAR wcsName[MAX_PATH];
	StringCchPrintfW(wcsName, MAX_PATH, L"%s\\%s", bstrParentName, pItemInfo->pName);


    bstrItemFullName = SysAllocString(wcsName);
    if (!bstrItemFullName)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, SysAllocString failed"));
        return E_OUTOFMEMORY;
    }

    //
    // Look up information about the item's format
    //
    LONG lItemType=0;

    //
    // See if the item has attachments
    //
    if (pItemInfo->bHasAttachments)
        ExtraFlags |= WiaItemTypeHasAttachments;

    if( pItemInfo->bIsFolder)
    {
        lItemType = ITEMTYPE_FOLDER;
    }
    else
    {
        lItemType = m_FormatInfo[pItemInfo->Format].ItemType;
    }

    //
    // Create the driver item
    //
    IWiaDrvItem *pItem = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = wiasCreateDrvItem(lItemType | ExtraFlags,
                           pItemInfo->pName,
                           bstrItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &pItem);

    SysFreeString(bstrParentName);

    if (FAILED(hr) || !pItem || !pItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, wiasCreateDrvItem failed"));
        return hr;
    }

    //
    // Fill in the driver item context. Wait until the thumbnail is requested before
    // reading it in.
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));
    pItemCtx->ItemHandle = ItemHandle;

    //
    // Place the new item under it's parent
    //
    hr = pItem->AddItemToFolder(pParent);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, AddItemToFolder failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Add the item to the item handle/driver item map
    //
    if (!m_HandleItemMap.Add(ItemHandle, pItem))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, handle item map Add failed"));
        return E_OUTOFMEMORY;
    }

    //
    // Eventhough, there is still a reference to the item in the handle/item map, release
    // it here, because there isn't a convenient place to do it later
    //
    pItem->Release();

    //
    // Post an item added event, if requested
    //
    if (bQueueEvent)
    {
        hr = wiasQueueEvent(m_bstrDeviceID, &WIA_EVENT_ITEM_CREATED, bstrItemFullName);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, wiasQueueEvent failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }

    SysFreeString(bstrItemFullName);

    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = 3;
    m_NumCapabilities       = (m_NumSupportedCommands + m_NumSupportedEvents);


    m_pCapabilities = new WIA_DEV_CAP_DRV[m_NumCapabilities];
    if (m_pCapabilities) {

        //
        // Initialize EVENTS
        //

        // WIA_EVENT_DEVICE_CONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[0].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[0].wszDescription),TRUE);
        m_pCapabilities[0].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
        m_pCapabilities[0].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[0].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

        // WIA_EVENT_DEVICE_DISCONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[1].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[1].wszDescription),TRUE);
        m_pCapabilities[1].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
        m_pCapabilities[1].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[1].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

        // WIA_EVENT_ITEM_DELETED
        GetOLESTRResourceString(IDS_EVENT_ITEM_DELETED_NAME,&(m_pCapabilities[2].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_ITEM_DELETED_DESC,&(m_pCapabilities[2].wszDescription),TRUE);
        m_pCapabilities[2].guid           = (GUID*)&WIA_EVENT_ITEM_DELETED;
        m_pCapabilities[2].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[2].wszIcon        = WIA_ICON_ITEM_DELETED;


        //
        // Initialize COMMANDS
        //

        // WIA_CMD_SYNCHRONIZE
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[3].wszName),TRUE);
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[3].wszDescription),TRUE);
        m_pCapabilities[3].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
        m_pCapabilities[3].ulFlags        = 0;
        m_pCapabilities[3].wszIcon        = WIA_ICON_SYNCHRONIZE;

        // ISSUE-10/17/2000-davepar Add TakePicture if the camera supports it
    }
    else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildCapabilities, memory allocation failed"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::DeleteCapabilitiesArrayContents()
{
    HRESULT hr = S_OK;

    if (m_pCapabilities) {
        for (LONG i = 0; i < m_NumCapabilities; i++) {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }

        delete []m_pCapabilities;
        m_pCapabilities = NULL;
    }

    m_NumSupportedCommands = 0;
    m_NumSupportedEvents = 0;
    m_NumCapabilities = 0;

    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
\**************************************************************************/
HRESULT CWiaCameraDevice::GetBSTRResourceString(LONG lResourceID, BSTR *pBSTR, BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[MAX_PATH];
    if (bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst, lResourceID, szStringValue, MAX_PATH);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[MAX_PATH];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           ARRAYSIZE(wszStringValue));

       *pBSTR = SysAllocString(wszStringValue);
#endif

       if (!*pBSTR) {
           WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetBSTRResourceString, SysAllocString failed"));
           return E_OUTOFMEMORY;
       }

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }

    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
\**************************************************************************/
HRESULT CWiaCameraDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    HRESULT hr = S_OK;
	const int c_nMaxCharPerString = 255;
	TCHAR szStringValue[c_nMaxCharPerString];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
		   StringCchCopyW(*ppsz, c_nMaxCharPerString, szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[c_nMaxCharPerString];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           ARRAYSIZE(wszStringValue));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
		   StringCchCopyW(*ppsz, c_nMaxCharPerString, wszStringValue); 
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* VerticalFlip
*
*
*
* Arguments:
*
*
*
\**************************************************************************/

VOID CWiaCameraDevice::VerticalFlip(
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext
    )

{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::VerticalFlip");
    HRESULT hr = S_OK;

    LONG        iHeight;
    LONG        iWidth        = pItemCtx->ItemHandle->Width;
    ULONG       uiDepth       = pItemCtx->ItemHandle->Depth;
    LONG        ScanLineWidth = iWidth * uiDepth / 8;
    PBITMAPINFO pbmi          = NULL;
    PBYTE       pImageTop     = NULL;

    //
    // find out if data is TYMED_FILE or TYMED_HGLOBAL
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer + sizeof(BITMAPFILEHEADER));

    } else if (pDataTransferContext->tymed == TYMED_HGLOBAL) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer);

    } else {
        return;
    }

    //
    // init memory pointer and height
    //

    pImageTop = &pDataTransferContext->pTransferBuffer[0] + pDataTransferContext->lHeaderSize;
    iHeight = pbmi->bmiHeader.biHeight;

    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,ScanLineWidth);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * ScanLineWidth;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,ScanLineWidth);
            memcpy(pImageTop,pImageBottom,ScanLineWidth);
            memcpy(pImageBottom,pBuffer,ScanLineWidth);

            pImageTop    += ScanLineWidth;
            pImageBottom -= ScanLineWidth;
        }

        LocalFree(pBuffer);
    }
}

/**************************************************************************\
* FormatCode2FormatInfo
*
*   This helper function looks up information about an item's format based
*   on the format code.
*
* Arguments:
*
*   ItemType - the item's type
*
\**************************************************************************/

FORMAT_INFO *CWiaCameraDevice::FormatCode2FormatInfo(FORMAT_CODE FormatCode)
{
    if (FormatCode > (LONG)m_NumFormatInfo)
        FormatCode = 0;
    if (FormatCode < 0)
        FormatCode = 0;

    return &m_FormatInfo[FormatCode];
}

/**************************************************************************\
* GetDrvItemContext
*
*   This helper function gets the driver item context.
*
* Arguments:
*
*   pWiasContext - service context
*   ppItemCtx    - pointer to pointer to item context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::GetDrvItemContext(BYTE *pWiasContext, ITEM_CONTEXT **ppItemCtx,
                                            IWiaDrvItem **ppDrvItem)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::GetDrvItemContext");
    HRESULT hr = S_OK;

    if (!pWiasContext || !ppItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, invalid arg"));
        return E_INVALIDARG;
    }

    IWiaDrvItem *pWiaDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    *ppItemCtx = NULL;
    hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **) ppItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, GetDeviceSpecContext failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    if (!*ppItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, item context is null"));
        return E_FAIL;
    }

    if (ppDrvItem)
    {
        *ppDrvItem = pWiaDrvItem;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\private.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        private.h
*
*  VERSION:     1.0
*
*  DATE:        11/8/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Definitions for the wiautil.lib library, which should not be public.
*
*****************************************************************************/

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

class CImageStream : public IStream
{
public:
	CImageStream();
	~CImageStream();

    STDMETHOD(SetBuffer)(BYTE *pBuffer, INT iSize, SKIP_AMOUNT iSkipAmt = SKIP_OFF);
    
    // IUnknown 

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISequentialStream

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
    LONG                m_cRef;         // Reference count
    
    BYTE               *m_pBuffer;      // Buffer to use for reads and writes
    INT                 m_iSize;        // Size of the buffer
    INT                 m_iPosition;    // Current position in the buffer
    INT                 m_iOffset;      // Offset to apply to reads and writes
    BYTE                m_Header[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)];
                                        // Location to store bmp file and info headers
};

#endif // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiacam.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_ITEM_DELETED_NAME        121
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_EVENT_ITEM_DELETED_DESC        122
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDC_STATIC                      -1

#define IDB_BITMAP_VIDEO                   120

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\wiacam.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       wiacam.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA File System Device driver Class Factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
// IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    return TRUE;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

//    WIAS_LTRACE(g_pIWiaLog,
//                WIALOG_NO_RESOURCE_ID,
//                WIALOG_LEVEL3,
//                ("CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory, (creating)"));
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
{
    // Destructor logic
//    WIAS_LTRACE(g_pIWiaLog,
//                WIALOG_NO_RESOURCE_ID,
//                WIALOG_LEVEL3,
//                ("CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    CWiaCameraDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new CWiaCameraDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWiaCameraDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWiaCameraDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWiaCameraDevice::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
\**************************************************************************/

extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
//            DBG_INIT(hinst);
            DisableThreadLibraryCalls(hinst);
//          if( ERROR_SUCCESS != PopulateFormatInfo() )
//              return FALSE;
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {

            }
//          UnPopulateFormatInfo();
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_FSUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_FSUsd)) {
        CWiaCameraDeviceClassFactory *pcf = new CWiaCameraDeviceClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\wiacam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       wiacam.h
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*       Definition of WIA File System Device driver object
*
***************************************************************************/

#ifndef WIACAM__H_
#define WIACAM__H_

extern HINSTANCE  g_hInst;     // DLL module instance
// extern IWiaLog   *g_pIWiaLog;  // pointer to WIA logging interface

#if defined( _WIN32 ) && !defined( _NO_COM)

// {D2923B86-15F1-46FF-A19A-DE825F919576}
DEFINE_GUID(CLSID_FSUsd, 0xD2923B86, 0x15F1, 0x46FF, 0xA1, 0x9A, 0xDE, 0x82, 0x5F, 0x91, 0x95, 0x76);

#endif

//////////////////////////////////////////////////////////////////////////
// DLL #define Section                                                  //
//////////////////////////////////////////////////////////////////////////

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"
#define DATASEG_DEFAULT         DATASEG_SHARED

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);

#pragma data_seg(DATASEG_PERINSTANCE)
#pragma data_seg(DATASEG_DEFAULT)

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);
extern void DllAddRef(void);
extern void DllRelease(void);


/***************************************************************************\
*
*  CWiaCameraDeviceClassFactory
*
\****************************************************************************/

class CWiaCameraDeviceClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    CWiaCameraDeviceClassFactory();
    ~CWiaCameraDeviceClassFactory();
};


//
// Base structure for supporting non-delegating IUnknown for contained objects
//
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD (NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef) (THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease) (THIS) PURE;
};

//
// General purpose GUIDs
//
DEFINE_GUID(GUID_NULL, 0,0,0,0,0,0,0,0,0,0,0);

DEFINE_GUID(FMT_NOTHING,
            0x81a566e7,0x8620,0x4fba,0xbc,0x8e,0xb2,0x7c,0x17,0xad,0x9e,0xfd);

//
// Driver item context
//
typedef struct _ITEM_CONTEXT{
    ITEM_HANDLE         ItemHandle;     // Handle to the camera item
    LONG                NumFormatInfo;  // Number of entries in format info array
    WIA_FORMAT_INFO    *pFormatInfo;    // Pointer to format info array 
    LONG                ThumbSize;      // Size of the thumbnail data in bytes
    BYTE               *pThumb;         // Thumbnail data
} ITEM_CONTEXT, *PITEM_CONTEXT;

//
// Handy constants for common item types
//
const ULONG ITEMTYPE_FILE   = WiaItemTypeFile;
const ULONG ITEMTYPE_IMAGE  = WiaItemTypeFile | WiaItemTypeImage;
const ULONG ITEMTYPE_AUDIO  = WiaItemTypeFile | WiaItemTypeAudio;
const ULONG ITEMTYPE_VIDEO  = WiaItemTypeFile | WiaItemTypeVideo;
const ULONG ITEMTYPE_FOLDER = WiaItemTypeFolder;
const ULONG ITEMTYPE_BURST  = WiaItemTypeFolder | WiaItemTypeBurst;
const ULONG ITEMTYPE_HPAN   = WiaItemTypeFolder | WiaItemTypeHPanorama;
const ULONG ITEMTYPE_VPAN   = WiaItemTypeFolder | WiaItemTypeVPanorama;

//
// Structure which holds everything needed for each format type.
//
#ifndef FORMAT_INFO_STRUCTURE
#define FORMAT_INFO_STRUCTURE

#define MAXEXTENSIONSTRINGLENGTH 8
typedef struct _FORMAT_INFO
{
    GUID    FormatGuid;         // WIA format GUID
    WCHAR   ExtensionString[MAXEXTENSIONSTRINGLENGTH];   // File extension
    LONG    ItemType;           // WIA item type
} FORMAT_INFO, *PFORMAT_INFO;
#endif 

typedef struct _DEFAULT_FORMAT_INFO
{
    GUID    *pFormatGuid;         // WIA format GUID
    LONG    ItemType;           // WIA item type
    WCHAR   *ExtensionString;   // File extension
} DEFAULT_FORMAT_INFO, *PDEFAULT_FORMAT_INFO;

//
// Minimum data call back transfer buffer size
//
const LONG MIN_BUFFER_SIZE   = 0x8000;

//
// When doing a transfer and convert to BMP, this value
// represents how much of the time is spent doing the
// transfer of data from the device.
//
const LONG TRANSFER_PERCENT = 90;

//
// Class definition for sample WIA scanner object
//

class CWiaCameraDevice : public IStiUSD,               // STI USD interface
                         public IWiaMiniDrv,           // WIA Minidriver interface
                         public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWiaCameraDevice(LPUNKNOWN punkOuter);
    ~CWiaCameraDevice();

private:

    // COM object data
    ULONG                m_cRef;                 // Device object reference count
    LPUNKNOWN            m_punkOuter;            // Pointer to outer unknown

    // STI data
    PSTIDEVICECONTROL    m_pIStiDevControl;      // Device control interface
    IStiDevice          *m_pStiDevice;           // Sti object
    DWORD                m_dwLastOperationError; // Last error
    WCHAR                m_pPortName[MAX_PATH];  // Port name for accessing the device

    // WIA data
    BSTR                 m_bstrDeviceID;         // WIA unique device ID
    BSTR                 m_bstrRootFullItemName; // Root item name
    IWiaDrvItem         *m_pRootItem;            // Root item

    LONG                 m_NumSupportedCommands; // Number of supported commands
    LONG                 m_NumSupportedEvents;   // Number of supported events
    LONG                 m_NumCapabilities;      // Number of capabilities
    WIA_DEV_CAP_DRV     *m_pCapabilities;        // Capabilities array

    // Device data
    FakeCamera          *m_pDevice;              // Pointer to device class
    DEVICE_INFO          m_DeviceInfo;           // Device information
    CWiaMap<ITEM_HANDLE, IWiaDrvItem *>
                         m_HandleItemMap;        // Maps item handles to drv items
    
    // Misc data
    int                  m_ConnectedApps;        // Number of app connected to this driver
    CWiauFormatConverter m_Converter;
    IWiaLog             *m_pIWiaLog;

public:

    FORMAT_INFO         *m_FormatInfo;
    UINT                 m_NumFormatInfo;

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHODIMP Initialize(PSTIDEVICECONTROL pHelDcb, DWORD dwStiVersion, HKEY hParametersKey);
    STDMETHODIMP GetCapabilities(PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus(PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPDIAG pBuffer);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE EscapeFunction, LPVOID lpInData, DWORD cbInDataSize,
                        LPVOID pOutData, DWORD dwOutDataSize, LPDWORD pdwActualData);
    STDMETHODIMP GetLastError(LPDWORD pdwLastDeviceError);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHODIMP drvInitializeWia(BYTE *pWiasContext, LONG lFlags, BSTR bstrDeviceID, BSTR bstrRootFullItemName,
                                  IUnknown *pStiDevice, IUnknown *pIUnknownOuter, IWiaDrvItem  **ppIDrvItemRoot,
                                  IUnknown **ppIUnknownInner, LONG *plDevErrVal);
    STDMETHODIMP drvUnInitializeWia(BYTE* pWiasContext);
    STDMETHODIMP drvDeviceCommand(BYTE *pWiasContext, LONG lFlags, const GUID *pGUIDCommand,
                                  IWiaDrvItem **ppMiniDrvItem, LONG *plDevErrVal);
    STDMETHODIMP drvDeleteItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetCapabilities(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                    WIA_DEV_CAP_DRV **ppCapabilities, LONG *plDevErrVal);
    STDMETHODIMP drvInitItemProperties(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvLockWiaDevice(BYTE  *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvUnLockWiaDevice(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvAnalyzeItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetWiaFormatInfo(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                     WIA_FORMAT_INFO **ppwfi, LONG *plDevErrVal);
    STDMETHODIMP drvNotifyPnpEvent(const GUID *pEventGUID, BSTR bstrDeviceID, ULONG ulReserved);
    STDMETHODIMP drvReadItemProperties(BYTE *pWiaItem, LONG lFlags, ULONG nPropSpec,
                                       const PROPSPEC *pPropSpec, LONG  *plDevErrVal);
    STDMETHODIMP drvWriteItemProperties(BYTE *pWiasContext, LONG lFLags,
                                        PMINIDRV_TRANSFER_CONTEXT pmdtc, LONG *plDevErrVal);
    STDMETHODIMP drvValidateItemProperties(BYTE *pWiasContext, LONG lFlags, ULONG nPropSpec,
                                           const PROPSPEC *pPropSpec, LONG *plDevErrVal);
    STDMETHODIMP drvAcquireItemData(BYTE *pWiasContext, LONG lFlags,
                                    PMINIDRV_TRANSFER_CONTEXT pDataContext, LONG *plDevErrVal);
    STDMETHODIMP drvGetDeviceErrorStr(LONG lFlags, LONG lDevErrVal, LPOLESTR *ppszDevErrStr, LONG *plDevErrVal);
    STDMETHODIMP drvFreeDrvItemContext(LONG lFlags, BYTE *pDevContext, LONG *plDevErrVal);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////

    //
    // WIA Item Management Helpers
    //
    HRESULT BuildItemTree(void);
    HRESULT AddObject(ITEM_HANDLE ItemHandle, BOOL bQueueEvent = FALSE);
    HRESULT DeleteItemTree(LONG lReason);

    //
    // WIA Property Management Helpers
    //
    HRESULT BuildRootItemProperties(BYTE *pWiasContext);
    HRESULT ReadRootItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    
    HRESULT BuildChildItemProperties(BYTE *pWiasContext);
    HRESULT GetValidFormats(BYTE *pWiasContext, LONG TymedValue, int *pNumFormats, GUID **ppFormatArray);
    HRESULT ReadChildItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT CacheThumbnail(ITEM_CONTEXT *pItemCtx, ULONG uItemType);
    HRESULT AcquireData(ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                        BYTE *pBuf, LONG lBufSize, BOOL bConverting);
    HRESULT Convert(BYTE *pWiasContext, ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                    BYTE *pNativeImage, LONG lNativeSize);

    //
    // WIA Capability Management Helpers
    //
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();
    HRESULT SetItemSize(BYTE *pWiasContext);

    //
    // WIA Resource file Helpers
    //
    HRESULT GetBSTRResourceString(LONG lLocalResourceID, BSTR *pBSTR, BOOL bLocal);
    HRESULT GetOLESTRResourceString(LONG lLocalResourceID, LPOLESTR *ppsz, BOOL bLocal);

    //
    // Miscellaneous Helpers
    //
    HRESULT GetDrvItemContext(BYTE *pWiasContext, ITEM_CONTEXT **ppItemCtx, IWiaDrvItem **ppDrvItem = NULL);
    
    VOID VerticalFlip(
        PITEM_CONTEXT              pDrvItemContext,
        PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);

    FORMAT_INFO *FormatCode2FormatInfo(FORMAT_CODE ItemType);
    DWORD PopulateFormatInfo(void);
    void  UnPopulateFormatInfo(void);
                                     
public:
    VOID RunNotifications(VOID);
};

typedef CWiaCameraDevice *PWIACAMERADEVICE;

#endif // #ifndef WIACAM__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\camopen.cpp ===
//-------------------------------------------------------------------------
//
//  Copyright (c) 1999  Microsoft Corporation.
//
//  camopen.cpp
//
//  Abstract:
//
//     Enumerate disk images to emulate camera
//
//  Author:
//
//     Edward Reus    27/Jul/99
//     modeled after code by Mark Enstrom
//
//-------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <tchar.h>

#include "sti.h"
#include "ircamera.h"
#include <irthread.h>

extern HINSTANCE g_hInst; // Global hInstance

#define  __GLOBALPROPVARS__

#include "resource.h"
#include "defprop.h"

//-------------------------------------------------------------------------
//  IrUsdDevice::CamOpenCamera()
//
//   Initialize the IrTran-P camera driver.
//
//   This is a helper called by IrUsdDevice::Initialize().
//
// Arguments:
//
//   pGenericStatus    -    camera status
//
// Return Value:
//
//   HRESULT - S_OK
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::CamOpenCamera( IN OUT CAMERA_STATUS *pCameraStatus )
    {
    HRESULT    hr = S_OK;
    SYSTEMTIME SystemTime;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamOpenCamerai()"));

    //
    // Initialize camera state:
    //
    memset( pCameraStatus, 0, sizeof(CAMERA_STATUS) );

    pCameraStatus->FirmwareVersion = 0x00000001;
    pCameraStatus->NumPictTaken = 20;
    pCameraStatus->NumPictRemaining = 0;
    pCameraStatus->ThumbWidth = 80;
    pCameraStatus->ThumbHeight= 60;
    pCameraStatus->PictWidth  = 300;
    pCameraStatus->PictHeight = 300;

    GetSystemTime( &(pCameraStatus->CameraTime) );

    return hr;
    }


//-------------------------------------------------------------------------
// IrUsdDevice::CamBuildImageTree()
//
//    Build the tree of camera images by enumerating a disk directory for
//    all .JPG files.
//
// Arguments:
//
//    pCamStatus  -    device status
//    ppRootFile  -    return new root of item tree
//
// Return Value:
//
//    status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::CamBuildImageTree( OUT CAMERA_STATUS  *pCamStatus,
                                        OUT IWiaDrvItem   **ppRootFile )
    {
    HRESULT  hr = S_OK;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamBuildImageTree()"));

    //
    // Create the new image root:
    //
    BSTR bstrRoot = SysAllocString(L"Root");

    if (!bstrRoot)
        {
        return E_OUTOFMEMORY;
        }

    //
    // Call Wia service library to create new root item:
    //
    hr = wiasCreateDrvItem( WiaItemTypeFolder | WiaItemTypeRoot | WiaItemTypeDevice,
                            bstrRoot,
                            m_bstrRootFullItemName,
                            (IWiaMiniDrv*)this,
                            sizeof(IRCAM_IMAGE_CONTEXT),
                            NULL,
                            ppRootFile );

    SysFreeString(bstrRoot);

    if (FAILED(hr))
        {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, CreateDeviceItem failed"));
        return hr;
        }

    //
    // Enumerate the root directory:
    //
    CHAR  *pszImageDirectory = GetImageDirectory();

    if (!pszImageDirectory)
        {
        return E_OUTOFMEMORY;
        }

    #ifdef UNICODE

    WCHAR  wszPath[MAX_PATH];

    mbstowcs( wszPath, pszImageDirectory, strlen(pszImageDirectory) );

    hr = EnumDiskImages( *ppRootFile, wszPath );

    #else

    hr = EnumDiskImages( *ppRootFile, pszImageDirectory );

    #endif


    // Don't free pszImageDirectory!!

    return (hr);
    }

//-------------------------------------------------------------------------
// IrUsdDevice::EnumDiskImages()
//
//   Walk through camera temp directory looking for JPEG files to pick up.
//
// Arguments:
//
//   pRootFile
//   pwszDirName
//
// Return Value:
//
//   status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::EnumDiskImages( IWiaDrvItem *pRootFile,
                                     TCHAR       *pszDirName )
    {
    HRESULT          hr = E_FAIL;
    WIN32_FIND_DATA  FindData;
    TCHAR           *pTempName;

    WIAS_TRACE((g_hInst,"IrUsdDevice::EnumDiskImages()"));

    pTempName = (TCHAR*)ALLOC(MAX_PATH);
    if (!pTempName)
        {
        return E_OUTOFMEMORY;
        }

    _tcscpy( pTempName, pszDirName);
    _tcscat( pTempName, TEXT("\\*.jpg") );

    //
    // Look for files at the specified directory:
    //
    HANDLE hFile = FindFirstFile( pTempName, &FindData );

    if (hFile != INVALID_HANDLE_VALUE)
        {
        BOOL bStatus;

        do {
            //
            // Add an image to this folder.
            //
            // Create file name:
            //

            _tcscpy(pTempName, pszDirName);
            _tcscat(pTempName, TEXT("\\"));
            _tcscat(pTempName, FindData.cFileName);

            //
            // Create a new DrvItem for this image and add it to the
            // DrvItem tree.
            //

            IWiaDrvItem *pNewImage;

            hr = CreateItemFromFileName(
                         WiaItemTypeFile | WiaItemTypeImage,
                         pTempName,
                         FindData.cFileName,
                         &pNewImage);

            if (FAILED(hr))
                {
                break;
                }

            hr = pNewImage->AddItemToFolder(pRootFile);

            pNewImage->Release();

            //
            // Look for the next image:
            //
            bStatus = FindNextFile(hFile,&FindData);

        } while (bStatus);

        FindClose(hFile);
    }

    //
    // Now look for directories,
    // add a new PCAMERA_FILE for each sub directory found
    //

    _tcscpy(pTempName, pszDirName);
    _tcscat(pTempName, TEXT("\\*.*"));

    hFile = FindFirstFile( pTempName,&FindData );

    if (hFile != INVALID_HANDLE_VALUE)
        {
        BOOL bStatus;

        do {
            if (  (FindData.cFileName[0] != L'.')
               && (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                //
                // Found a subdirectory:
                //

                _tcscpy(pTempName, pszDirName);
                _tcscat(pTempName, TEXT("\\"));
                _tcscat(pTempName, FindData.cFileName);

                //
                // Create a new folder for the sub-directory:
                //

                IWiaDrvItem *pNewFolder;

                hr = CreateItemFromFileName(
                                 WiaItemTypeFolder,
                                 pTempName,
                                 FindData.cFileName,
                                 &pNewFolder);

                if (FAILED(hr))
                    {
                    continue;
                    }

                hr = pNewFolder->AddItemToFolder(pRootFile);

                pNewFolder->Release();

                if (hr == S_OK)
                    {
                    //
                    // Enumerate the sub-folder
                    //
                    EnumDiskImages(pNewFolder, pTempName);
                    }
                }

            bStatus = FindNextFile(hFile,&FindData);

        } while (bStatus);

        FindClose(hFile);
        }

    FREE(pTempName);

    return S_OK;
    }

//-------------------------------------------------------------------------
// IrUsdDevice::CreateItemFromFileName()
//
//    Helper funtion used by EnumDiskImages to create dev items and names.
//
// Arguments:
//
//    FolderType  - type of item to create
//    pszPath     - complete path name
//    pszName     - file name
//    ppNewFolder - return new item
//
// Return Value:
//
//   status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::CreateItemFromFileName( LONG          FolderType,
                                             TCHAR        *pszPath,
                                             TCHAR        *pszName,
                                             IWiaDrvItem **ppNewFolder )
    {
    HRESULT  hr = S_OK;
    WCHAR    wszFullItemName[MAX_PATH];
    WCHAR    wszTemp[MAX_PATH];
    BSTR     bstrItemName;
    BSTR     bstrFullItemName;
    IWiaDrvItem  *pNewFolder = 0;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CreateItemFromFileName()"));

    *ppNewFolder = NULL;

    //
    // Convert path to wide char
    //
    CHAR *pszImageDirectory = ::GetImageDirectory();

    if (!pszImageDirectory)
        {
        return E_OUTOFMEMORY;
        }

    DWORD dwImageDirectoryLen = strlen(pszImageDirectory);

    #ifndef UNICODE
    MultiByteToWideChar( CP_ACP,
                         0,
                         pszPath + dwImageDirectoryLen,
                         strlen(pszPath) - dwImageDirectoryLen - 4,
                         wszTemp,
                         MAX_PATH);
    #else
    wcscpy(wszTemp, pszPath+dwImageDirectoryLen);
    #endif

    if (FolderType & ~WiaItemTypeFolder)
        {
        wszTemp[_tcslen(pszPath) - strlen(pszImageDirectory) - 4] = 0;
        }

    wcscpy(wszFullItemName, m_bstrRootFullItemName);
    wcscat(wszFullItemName, wszTemp);

    //
    // Convert item name to wide char:
    //

    #ifndef UNICODE
    MultiByteToWideChar( CP_ACP,
                         0,
                         pszName,
                         strlen(pszName)-4,
                         wszTemp,
                         MAX_PATH);
    #else
    wcscpy(wszTemp, pszName);
    #endif

    if (FolderType & ~WiaItemTypeFolder)
        {
        wszTemp[_tcslen(pszName)-4] = 0;
        }

    bstrItemName = SysAllocString(wszTemp);

    if (bstrItemName)
        {
        bstrFullItemName = SysAllocString(wszFullItemName);

        if (bstrFullItemName)
            {
            //
            // Call WIA to create new DrvItem
            //

            IRCAM_IMAGE_CONTEXT *pContext = 0;

            hr = wiasCreateDrvItem( FolderType,
                                    bstrItemName,
                                    bstrFullItemName,
                                    (IWiaMiniDrv *)this,
                                    sizeof(IRCAM_IMAGE_CONTEXT),
                                    (BYTE **)&pContext,
                                    &pNewFolder);

            if (hr == S_OK)
                {
                //
                // init device specific context (image path)
                //
                pContext->pszCameraImagePath = _tcsdup(pszPath);
                }
            else
                {
                WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, wiasCreateDrvItem failed"));
                }

            SysFreeString(bstrFullItemName);
            }
        else
            {
            WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate full item name"));
            hr = E_OUTOFMEMORY;
            }

        SysFreeString(bstrItemName);
        }
    else
        {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate item name"));
        hr = E_OUTOFMEMORY;
        }

    //
    // Assign output value and cleanup
    //

    if (hr == S_OK)
        {
        *ppNewFolder = pNewFolder;
        }
    else
        {
        //
        // delete item
        //
        }

    return hr;
}

//-------------------------------------------------------------------------
// SetItemSize()
//
//   Helper function to call wias to calc new item size
//
// Arguments:
//
//   pWiasContext       - item
//
// Return Value:
//
//    Status
//
//-------------------------------------------------------------------------
HRESULT SetItemSize( BYTE* pWiasContext )
    {
    HRESULT                    hr;
    MINIDRV_TRANSFER_CONTEXT   drvTranCtx;

    memset( &drvTranCtx, 0, sizeof(MINIDRV_TRANSFER_CONTEXT) );

    hr = wiasReadPropGuid( pWiasContext,
                           WIA_IPA_FORMAT,
                           (GUID*)&drvTranCtx.guidFormatID,
                           NULL,
                           false );
    if (FAILED(hr))
        {
        return hr;
        }

    hr = wiasReadPropLong( pWiasContext,
                           WIA_IPA_TYMED,
                           (LONG*)&drvTranCtx.tymed,
                           NULL,
                           false );
    if (FAILED(hr))
        {
        return hr;
        }

    WIAS_TRACE((g_hInst,"SetItemSize(): tymed: %d",drvTranCtx.tymed));

    //
    // wias works for DIB and TIFF formats.
    //
    // Driver doesn't support JPEG
    //

    hr = wiasGetImageInformation(pWiasContext,
                                 WIAS_INIT_CONTEXT,
                                 &drvTranCtx);

    if (hr == S_OK)
        {
        WIAS_TRACE((g_hInst,"SetItemSize(): lItemSize: %d",drvTranCtx.lItemSize));
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, drvTranCtx.lItemSize);
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_BYTES_PER_LINE, drvTranCtx.cbWidthInBytes);
        }

    return hr;
    }

//-------------------------------------------------------------------------
// IrUsdDevice::InitImageInformation()
//
//    Init image properties
//
// Arguments:
//
//
// Return Value:
//
//    Status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::InitImageInformation( BYTE                *pWiasContext,
                                           IRCAM_IMAGE_CONTEXT *pContext,
                                           LONG                *plDevErrVal)
    {
    int                      i;
    HRESULT                  hr = S_OK;
    CAMERA_PICTURE_INFO      camInfo;
    PROPVARIANT              propVar;

    WIAS_TRACE((g_hInst,"IrUsdDevice::InitImageInformation()"));

    //
    // GET image info
    //

    hr = CamGetPictureInfo( pContext,
                            &camInfo );

    if (hr != S_OK)
        {
        return hr;
        }

    //
    // Use WIA services to write image properties:
    //
    wiasWritePropLong( pWiasContext,
                       WIA_IPC_THUMB_WIDTH,
                       camInfo.ThumbWidth);

    wiasWritePropLong( pWiasContext,
                       WIA_IPC_THUMB_HEIGHT,
                       camInfo.ThumbHeight );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_PIXELS_PER_LINE,
                       camInfo.PictWidth );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_NUMBER_OF_LINES,
                       camInfo.PictHeight );

    wiasWritePropGuid( pWiasContext,
                       WIA_IPA_PREFERRED_FORMAT,
                       WiaImgFmt_JPEG );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_DEPTH,
                       camInfo.PictBitsPerPixel );

    wiasWritePropBin( pWiasContext,
                      WIA_IPA_ITEM_TIME,
                      sizeof(SYSTEMTIME),
                      (PBYTE)&camInfo.TimeStamp );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_DATATYPE,
                       WIA_DATA_COLOR );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_ITEM_SIZE,
                       camInfo.PictCompSize );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_BYTES_PER_LINE,
                       camInfo.PictBytesPerRow );

    //
    // Calculate item size
    //
    // hr = SetItemSize(pWiasContext); BUGBUG

    //
    // Load a thumbnail of the image:
    //
    PBYTE pThumb;
    LONG  lSize;

    hr = CamLoadThumbnail(pContext, &pThumb, &lSize);

    if (hr == S_OK)
        {
        //
        // write thumb property
        //
        PROPSPEC    propSpec;
        PROPVARIANT propVar;

        propVar.vt          = VT_VECTOR | VT_UI1;
        propVar.caub.cElems = lSize;
        propVar.caub.pElems = pThumb;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPC_THUMBNAIL;

        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);

        FREE(pThumb);
        }

    //
    // Use WIA services to set the extended property access and
    // valid value information from gWiaPropInfoDefaults.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_ITEM_PROPS,
                                 gPropSpecDefaults,
                                 gWiaPropInfoDefaults);
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\camxfer.cpp ===
//------------------------------------------------------------------------------
//  Copyright (c) 1999  Microsoft Corporation
//
//  camxfer.cpp
//
//  Abstract:
//
//     Core ircamera (IrUseDevice object) imaging methods.
//
//  Author:
//     Edward Reus   03-Aug-99
//     modeled after code by Mark Enstrom
//
//------------------------------------------------------------------------------

#include <stdio.h>
#include <objbase.h>
#include <tchar.h>
#include <sti.h>
#include <malloc.h>
#include "jpegutil.h"

extern HINSTANCE g_hInst; // Global hInstance

#include "ircamera.h"


#if FALSE
//------------------------------------------------------------------------------
// IrUsdDevice::OpenAndMapJPEG()
//
// Open and memory map the JPEG file. The JPEG file is opened read only and
// a pointer to the memory map is returned.
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::OpenAndMapJPEG( IN  IRCAM_IMAGE_CONTEXT *pIrCamContext,
                                     OUT BYTE               **ppJpeg )
    {
    HRESULT  hr = S_OK;

    *ppJpeg = 0;


    return hr;
    }
#endif

//------------------------------------------------------------------------------
// IrUsdDevice::CamLoadPicture()
//
//    Read a .JPG image from the disk and copy it to the application.
//
// Arguments:
//
//   pIrCamContext --
//   pDataTransCtx --
//   plCamErrVal   --
//
// Return Value:
//
//   status
//
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::CamLoadPicture( IRCAM_IMAGE_CONTEXT      *pIrCamContext,
                                     PMINIDRV_TRANSFER_CONTEXT pDataTransCtx,
                                     PLONG                     plCamErrVal )
    {
    HRESULT               hr = S_OK;
    LONG                  cbNeeded;
    IWiaMiniDrvCallBack  *pIProgressCB;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamLoadPicture()"));

    //
    // Verify call arguments:
    //
    if ( (!pIrCamContext) || (!plCamErrVal))
        {
        return E_INVALIDARG;
        }

    if (pDataTransCtx->guidFormatID != WiaImgFmt_JPEG)
        {
        return E_NOTIMPL;
        }

    pIProgressCB = pDataTransCtx->pIWiaMiniDrvCallBack;

    //
    // Simulate the download of data from the camera
    //
    if (pIProgressCB)
        {
        hr = pIProgressCB->MiniDrvCallback(
                               IT_MSG_STATUS,
                               IT_STATUS_TRANSFER_FROM_DEVICE,
                               (LONG)0,     // Percentage Complete,
                               0,
                               0,
                               pDataTransCtx,
                               0);
        if (hr != S_OK)
            {
            return hr;   // Client wants to cancel the transfer or error.
            }
        }

    HANDLE hFile = CreateFile(
                       pIrCamContext->pszCameraImagePath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    else
        {
        if (pIProgressCB)
            {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)25,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
            }
        }

    if (hr != S_OK)
        {
        if (hFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hFile);
            }
        return hr;
        }

    //
    // Get the size of the JPEG:
    //
    BY_HANDLE_FILE_INFORMATION  FileInfo;

    if (!GetFileInformationByHandle(hFile,&FileInfo))
       {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       CloseHandle(hFile);
       return hr;
       }

    //
    // Map the JPEG into memory:
    //
    HANDLE hMap = CreateFileMapping( hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL );
    if (hMap == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    else
        {
        if (pIProgressCB)
            {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)50,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0 );
            }
        }

    if (hr != S_OK)
        {
        CloseHandle(hFile);
        return hr;
        }

    PBYTE pFile = (PBYTE)MapViewOfFile(
                             hMap,
                             FILE_MAP_READ,
                             0,
                             0,
                             0 );
    if (pFile == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    else
        {
        if (pIProgressCB)
            {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)100,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
            }
        }

    if (hr != S_OK)
        {
        CloseHandle(hFile);
        CloseHandle(hMap);
        return hr;
        }

    #if FALSE
    //
    // File contains BITMAPFILEHEADER + BITMAPINFO structure.
    //
    // DIB Data is located bfOffBits after start of file
    //

    PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
    PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile +
                                               sizeof(BITMAPFILEHEADER));

    //
    // validate bitmap
    //

    if (pbmFile->bfType != 'MB')
        {
        //
        // file is not a bitmap
        //
        UnmapViewOfFile(pFile);
        CloseHandle(hMap);
        CloseHandle(hFile);
        return(E_FAIL);
        }

    //
    // write image size
    //
    // make sure to align scanline to ULONG boundary
    //
    // calculate byte width
    //

    lScanLineWidth = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;

    //
    // round up to nearenst DWORD
    //

    lScanLineWidth = (lScanLineWidth + 31) >> 3;

    lScanLineWidth &= 0xfffffffc;
    #endif

    cbNeeded = FileInfo.nFileSizeLow;

    if (cbNeeded > ((LONG)pDataTransCtx->lItemSize - (LONG)pDataTransCtx->cbOffset))
        {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        }
    else
        {
        //
        // Copy the JPEG image...
        //
        memcpy(
            pDataTransCtx->pTransferBuffer + pDataTransCtx->cbOffset,
            pFile,
            cbNeeded);
        }

    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return hr;
    }

//------------------------------------------------------------------------------
//  IrUsdDevice::CamLoadPictureCB()
//
//    Return data by filling the data buffer and calling back to the client.
//
// Arguments:
//
//    pIrCamContext --
//    pTransCtx     -- mini driver transfer contect
//    plCamErrVal   --
//
// Return Value:
//
//   HRESULT  -- E_INVALIDARG
//               E_NOTIMPL
//               E_FAIL
//
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::CamLoadPictureCB( IRCAM_IMAGE_CONTEXT      *pIrCamContext,
                                       MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                                       PLONG                     plCamErrVal )
    {
    LONG     lScanLineWidth;
    HRESULT  hr = E_FAIL;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamLoadPictureCB()"));

    //
    // Verify parameters:
    //
    if ((!pIrCamContext) || (!plCamErrVal))
        {
        return E_INVALIDARG;
        }

    if (pTransCtx == NULL)
        {
        return E_INVALIDARG;
        }

    if (pTransCtx->guidFormatID != WiaImgFmt_JPEG)
        {
        return E_NOTIMPL;
        }

    //
    // try to open disk file
    //

    HANDLE hFile = CreateFile(
                       pIrCamContext->pszCameraImagePath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    //
    // Get the size of the JPEG file:
    //
    BY_HANDLE_FILE_INFORMATION  FileInfo;

    if (!GetFileInformationByHandle(hFile,&FileInfo))
       {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       CloseHandle(hFile);
       return hr;
       }

    HANDLE hMap = CreateFileMapping( hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL );
    if (hMap == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        CloseHandle(hFile);
        return hr;
        }

    PBYTE pFile = (PBYTE)MapViewOfFile(
                             hMap,
                             FILE_MAP_READ,
                             0,
                             0,
                             0 );
    if (pFile == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        CloseHandle(hFile);
        CloseHandle(hMap);
        return hr;
        }

    //
    // Callback loop
    //
    PBYTE pSrc = pFile;

    LONG  lBytesRemaining = FileInfo.nFileSizeLow;
    LONG  lTransferSize;
    LONG  lPercentComplete;

    do {

        PBYTE pDst = pTransCtx->pTransferBuffer;

        //
        // Transfer as much data as the transfer buffer will hold:
        //
        lTransferSize = lBytesRemaining;

        if (lBytesRemaining > pTransCtx->lBufferSize)
            {
            lTransferSize = pTransCtx->lBufferSize;
            }

        //
        // Copy data:
        //
        memcpy( pDst, pSrc, lTransferSize);

        lPercentComplete = 100 * (pTransCtx->cbOffset + lTransferSize);
        lPercentComplete /= pTransCtx->lItemSize;

        //
        // Make callback:
        //
        hr = pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                     IT_MSG_DATA,
                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                     lPercentComplete,
                                     pTransCtx->cbOffset,
                                     lTransferSize,
                                     pTransCtx,
                                     0);
        //
        // increment pointers (redundant pointers here):
        //
        pSrc                += lTransferSize;
        pTransCtx->cbOffset += lTransferSize;
        lBytesRemaining     -= lTransferSize;

        if (hr != S_OK)
            {
            break;
            }
    } while (lBytesRemaining > 0);

    //
    // Cleanup:
    //
    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return hr;
}



//------------------------------------------------------------------------------
// IrUsdDevice::CamGetPictureInfo()
//
//    Load file and get information from image
//
// Arguments:
//
//    pIrCamContext   --
//    pPictInfo       -- Infomation about the image
//    ppBITMAPINFO    -- Alloc and fill out BITMAPINFO
//    pBITMAPINFOSize -- Size
//
// Return Value:
//
//    HRESULT -- S_OK    - No problem.
//               E_FAIL  - If we can't parse the JPEG.
//               HRESULT mapped Win32 Errors from CreateFile()
//
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::CamGetPictureInfo(
                        IRCAM_IMAGE_CONTEXT  *pIrCamContext ,
                        CAMERA_PICTURE_INFO  *pPictInfo )
    {
    HRESULT     hr = S_OK;
    FILETIME    ftCreate;
    SYSTEMTIME  stCreate;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamGetPictureInfo()"));

    memset(pPictInfo,0,sizeof(CAMERA_PICTURE_INFO));

    //
    // Try to open disk file
    //
    HANDLE hFile = CreateFile(
                       pIrCamContext->pszCameraImagePath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    //
    // Get the size of the JPEG:
    //
    BY_HANDLE_FILE_INFORMATION  FileInfo;

    if (!GetFileInformationByHandle(hFile,&FileInfo))
       {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       CloseHandle(hFile);
       return hr;
       }

    //
    // Get the creation time for this image:
    //
    if (  !GetFileTime( hFile, &ftCreate, NULL, NULL)
       || !FileTimeToSystemTime( &ftCreate, &stCreate) )
        {
        //
        // If either of those fail, then return the system time:
        //
        GetLocalTime( &stCreate );
        }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READONLY,
                       0,
                       0,
                       NULL
                       );
    if (hMap == NULL)
        {
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    PBYTE pJpeg = (PBYTE)MapViewOfFile(
                             hMap,
                             FILE_MAP_READ,
                             0,
                             0,
                             0 );
    if (pJpeg == NULL)
        {
        CloseHandle(hFile);
        CloseHandle(hMap);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    //
    // Get JPEG image dimensions:
    //
    int    iStatus;
    long   lWidth = 0;
    long   lHeight = 0;
    WORD   wNumChannels = 0;
    DWORD  dwJpegSize = FileInfo.nFileSizeLow;

    iStatus = GetJPEGDimensions( pJpeg,
                                 dwJpegSize,
                                 &lWidth,
                                 &lHeight,
                                 &wNumChannels );
    if (iStatus != JPEGERR_NO_ERROR)
        {
        UnmapViewOfFile(pJpeg);
        CloseHandle(hFile);
        CloseHandle(hMap);
        return E_FAIL;
        }

    //
    // Fill out image information:
    //
    pPictInfo->PictNumber       = 0;    // Unknown
    pPictInfo->ThumbWidth       = 80;
    pPictInfo->ThumbHeight      = 60;
    pPictInfo->PictWidth        = lWidth;
    pPictInfo->PictHeight       = lHeight;
    pPictInfo->PictCompSize     = FileInfo.nFileSizeLow;
    pPictInfo->PictFormat       = CF_JPEG;
    pPictInfo->PictBitsPerPixel = wNumChannels * 8;
    pPictInfo->PictBytesPerRow  = lWidth*wNumChannels;

    memcpy( &pPictInfo->TimeStamp, &stCreate, sizeof(pPictInfo->TimeStamp) );

    //
    // Cleanup:
    //
    UnmapViewOfFile(pJpeg);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return hr;
}

//--------------------------------------------------------------------------
// IrUsdDevice::CamLoadThumbnail()
//
//   Load the thumbnail of the specified picture. The picture is saved as
//   a .JPG file, so it needs to be uncompressed into a DIB, then the DIB
//   needs to be resized down to thumbnail size. The thumbnail DIBs are saved
//   into *.tmb files the first time that they are read so that we only need
//   to process them into DIBs once.
//
// Arguments:
//
//   pCameraImage    - image item
//   pThumbnail      - buffer for thumbnail
//   pThumbSize      - size of thumbnail
//
// Return Value:
//
//   HRESULT: S_OK
//            E_OUTOFMEMORY
//            E_FAIL
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::CamLoadThumbnail(
                        IN  IRCAM_IMAGE_CONTEXT *pIrCamContext,
                        OUT BYTE               **ppThumbnail,
                        OUT LONG                *pThumbSize )
    {
    HRESULT  hr = S_OK;
    DWORD    dwStatus = 0;
    TCHAR    pszThumbName[MAX_PATH];
    BOOL     bThumbExists = TRUE;  // True if there is a thumbnail file already.
    BOOL     bCacheThumb  = TRUE;  // Should we try to cache the thumbnail if it
                                   //   isn't already cached? (TRUE == Yes).
    BYTE    *pTmbPixels = NULL;
    HBITMAP  hbmThumb = NULL;
    BYTE    *pThumb = NULL;

    HANDLE   hTmbFile = INVALID_HANDLE_VALUE;
    HANDLE   hTmbMap = NULL;
    BYTE    *pTmbFile = NULL;

    HANDLE   hFile = INVALID_HANDLE_VALUE;
    HANDLE   hMap = NULL;
    BYTE    *pFile = NULL;

    BYTE    *pDIB = NULL;

    BITMAPINFO bmiDIB;
    BITMAPINFO bmiJPEG;
    HDC        hdc = NULL;
    HDC        hdcm1 = NULL;

    BY_HANDLE_FILE_INFORMATION  FileInfo;

    long    lThumbWidth;
    long    lThumbHeight;
    double  fImageWidth;
    double  fImageHeight;
    double  fAspect;
    double  fDefAspect = 80.0 / 60.0;

    HBITMAP hbmDef;

    int   iStatus;
    long  lWidth;
    long  lHeight;
    WORD  wNumChannels;
    DWORD dwBytesPerScanLine;
    DWORD dwDIBSize;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamLoadThumbnail()"));

    //
    // Initialize the return values
    //
    *ppThumbnail = NULL;
    *pThumbSize = 0;

    //
    // Fill in the size of the tumbnail pixel buffer
    //

    bmiDIB.bmiHeader.biSizeImage = 80*60*3;

    //
    // Build thumbnail filename: <file>.bmp.tmb
    //
    _tcscpy(pszThumbName, pIrCamContext->pszCameraImagePath);
    _tcscat(pszThumbName, SZ_TMB );

    //
    // See if a saved copy of the thumbnail already exists:
    //
    hTmbFile = CreateFile( pszThumbName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

    if (hTmbFile == INVALID_HANDLE_VALUE)
        {
        //
        // It didn't, try to create a new one:
        //
        hTmbFile = CreateFile( pszThumbName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_NEW,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

        //
        // So, we need to write into the thumbnail file:
        //
        bThumbExists = FALSE;
        }

    //
    // If we could open (or create a new) .tmb file to hold the
    // cached thumbnail then we are Ok to go on...
    //
    if (hTmbFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }


    hTmbMap = CreateFileMapping( hTmbFile,
                                 NULL,   // No special security
                                 PAGE_READWRITE,
                                 0,      // Size high 32bits.
                                 80*60*3,// Size low 32bits. (80*60*3).
                                 NULL);  // No handle name.

    if (hTmbMap != NULL)
        {
        pTmbFile = (PBYTE)MapViewOfFile(
                                 hTmbMap,
                                 FILE_MAP_READ | FILE_MAP_WRITE,
                                 0, 0,   // Offset (64bit).
                                 0 );    // Map entire file.

        if (pTmbFile)
            {
            if (bThumbExists)
                {
                //
                // Allocate memory for thumbnail pixels:
                //
                pTmbPixels = (PBYTE)ALLOC(80*60*3);

                if (!pTmbPixels)
                    {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                    }

                //
                // Pull the thumbnail from the cached file:
                //
                memcpy( pTmbPixels,
                        pTmbFile,
                        80*60*3);

                //
                // All done for the cached thumbnail case, set
                // return values and goto cleanup...
                //
                *ppThumbnail = pTmbPixels;
                *pThumbSize = 80*60*3;

                goto cleanup;
                }
            else
                {
                //
                // No existing thumbnail file, but opened a new
                // file, so we will need to write out to cache:
                //
                bCacheThumb = TRUE;
                }
            }
        else
            {
            //
            // Couldn't memory map the thumbnail file, so don't
            // try to cache it:
            //
            bCacheThumb  = FALSE;
            }
        }
    else
        {
        //
        // Can't open/create thumbnail file, so we can't cache
        // thumbnail:
        //
        bCacheThumb  = FALSE;
        }

    //
    // Try to create a thumbnail from the full-size image
    // and cache it if the thumbnail cache file was created.
    //

    //
    // Open the .JPEG image file:
    //
    hFile = CreateFile(
                    pIrCamContext->pszCameraImagePath,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    if (!GetFileInformationByHandle(hFile,&FileInfo))
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    //
    // Map the file into memory:
    //
    hMap = CreateFileMapping( hFile,
                              NULL,          // No special security.
                              PAGE_READONLY, // Only read needed.
                              FileInfo.nFileSizeHigh,  // File Size.
                              FileInfo.nFileSizeLow,
                              NULL );        // No handle name.

    if (hMap == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    pFile = (PBYTE)MapViewOfFile(
                           hMap,
                           FILE_MAP_READ,
                           0, 0, // 64-bit file offset = 0.
                           0 );  // Bytes to map. 0 == Entire file.

    if (pFile == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    //
    // Here is where we will parse out the full JPEG into a DIB. We
    // need to read the full JPEG, then squeeze it down to thumbnail
    // size.
    //
    // First, we need to dimensions of the JPEG image:
    //
    iStatus = GetJPEGDimensions( pFile,
                                 FileInfo.nFileSizeLow,
                                 &lWidth,
                                 &lHeight,
                                 &wNumChannels );

    if (iStatus != JPEGERR_NO_ERROR)
        {
        hr = E_FAIL;
        goto cleanup;
        }

    //
    // Allocate memory to hold a DIB of the entire JPEG:
    //
    dwBytesPerScanLine = lWidth * wNumChannels;
    dwBytesPerScanLine = (dwBytesPerScanLine + wNumChannels) & 0xFFFFFFFC;
    dwDIBSize = dwBytesPerScanLine * lHeight;

    pDIB = (BYTE*)ALLOC(dwDIBSize);

    if (!pDIB)
        {
        hr = E_OUTOFMEMORY;
        goto cleanup;
        }

    //
    // Convert the full JPEG image into a DIB:
    //
    iStatus = DecompJPEG( pFile,
                          FileInfo.nFileSizeLow,
                          pDIB,
                          dwBytesPerScanLine );

    if (iStatus != JPEGERR_NO_ERROR)
        {
        hr = E_FAIL;
        goto cleanup;
        }

    //
    // Generate the thumbnail from the full-size image:
    //
    hdc   = GetDC(NULL);
    hdcm1 = CreateCompatibleDC(hdc);
    SetStretchBltMode( hdcm1, COLORONCOLOR );

    //
    // Create a BITMAP for rendering the thumbnail:
    //
    bmiDIB.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmiDIB.bmiHeader.biBitCount      = 24;
    bmiDIB.bmiHeader.biWidth         = 80;
    bmiDIB.bmiHeader.biHeight        = 60;
    bmiDIB.bmiHeader.biPlanes        = 1;
    bmiDIB.bmiHeader.biCompression   = BI_RGB;
    bmiDIB.bmiHeader.biXPelsPerMeter = 100;
    bmiDIB.bmiHeader.biYPelsPerMeter = 100;
    bmiDIB.bmiHeader.biClrUsed       = 0;
    bmiDIB.bmiHeader.biClrImportant  = 0;

    hbmThumb = CreateDIBSection( hdc,
                                 &bmiDIB,
                                 DIB_RGB_COLORS,
                                 (VOID**)&pThumb,
                                 NULL,
                                 0 );
    if (!hbmThumb)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    hbmDef = (HBITMAP)SelectObject(hdcm1, hbmThumb);

    //
    // Initialize the DIB:
    //
    memset( pThumb, 0, bmiDIB.bmiHeader.biSizeImage );

    //
    // We want to create 80x60 thumbnail while preserving the original
    // image aspect ratio.
    //
    fImageWidth  = (double)lWidth;
    fImageHeight = (double)lHeight;
    fAspect      = fImageWidth / fImageHeight;

    if (fAspect > fDefAspect)
        {
        lThumbWidth  = 80;
        lThumbHeight = (LONG)(80.0 / fAspect);
        }
    else
        {
        lThumbHeight = 60;
        lThumbWidth  = (LONG)(60.0 * fAspect);
        }

    memset(&bmiJPEG,0,sizeof(bmiJPEG));

    bmiJPEG.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmiJPEG.bmiHeader.biBitCount      = 24;     // Use 0 for JPEG content.
    bmiJPEG.bmiHeader.biWidth         = lWidth;
    bmiJPEG.bmiHeader.biHeight        = lHeight;
    bmiJPEG.bmiHeader.biPlanes        = 1;
    bmiJPEG.bmiHeader.biCompression   = BI_RGB; // BI_JPEG;
    bmiJPEG.bmiHeader.biXPelsPerMeter = 1000;
    bmiJPEG.bmiHeader.biYPelsPerMeter = 1000;
    bmiJPEG.bmiHeader.biClrUsed       = 0;
    bmiJPEG.bmiHeader.biClrImportant  = 0;
    bmiJPEG.bmiHeader.biSizeImage     = FileInfo.nFileSizeLow;

    iStatus = StretchDIBits( hdcm1,
                             0,
                             0,
                             lThumbWidth,
                             lThumbHeight,
                             0,
                             0,
                             lWidth,
                             lHeight,
                             pDIB,  // pFile is our JPEG.
                             &bmiJPEG,
                             DIB_RGB_COLORS,
                             SRCCOPY );
    if (iStatus == GDI_ERROR)
        {
        dwStatus = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);
        }

    SelectObject(hdcm1, hbmDef);

    //
    // If necessary, cache the thumbnail:
    //
    if (bCacheThumb)
        {
        memcpy( pTmbFile, pThumb, bmiDIB.bmiHeader.biSizeImage );
        }

    //
    // Allocate memory for thumbnail pixels:
    //
    pTmbPixels = (PBYTE)ALLOC(bmiDIB.bmiHeader.biSizeImage);
    if (! pTmbPixels)
        {
        hr = E_OUTOFMEMORY;
        goto cleanup;
        }

    //
    // Write out the thumbnail data to the cache file:
    //
    memcpy( pTmbPixels, pThumb, bmiDIB.bmiHeader.biSizeImage);
    *ppThumbnail = pTmbPixels;
    *pThumbSize = bmiDIB.bmiHeader.biSizeImage;


    cleanup:
        if (pTmbFile)
            {
            UnmapViewOfFile(pTmbFile);
            }
        if (hTmbMap)
            {
            CloseHandle(hTmbMap);
            }
        if (hTmbFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hTmbFile);
            }

        if (pFile)
            {
            UnmapViewOfFile(pFile);
            }
        if (hMap)
            {
            CloseHandle(hMap);
            }
        if (hFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hFile);
            }

        if (hbmThumb)
            {
            DeleteObject(hbmThumb);
            }

        if (hdcm1)
            {
            DeleteDC(hdcm1);
            }
        if (hdc)
            {
            ReleaseDC(NULL, hdc);
            }

    return hr;
}


//--------------------------------------------------------------------------
// CamDeletePicture()
//
// Delete the specified picture from the temp directory. In this case, all
// that we have to do is delete image (.jpg) and the temporary thumbnail
// file that we created (.tmb).
//
// Arguments:
//
//    pIrCamContext --
//
// Return Value:
//
//    HRESULT    S_OK
//               S_FAIL
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::CamDeletePicture( IRCAM_IMAGE_CONTEXT *pIrCamContext )
    {
    DWORD  dwStatus;

    WIAS_TRACE((g_hInst,"CamDeletePicture(): %s",pIrCamContext->pszCameraImagePath));

    //
    // First, delete the thumbnail (.tmb) file:
    //
    DWORD  dwLen = _tcslen(pIrCamContext->pszCameraImagePath);
    TCHAR *pszThumb = (TCHAR*)_alloca(sizeof(TCHAR)*(dwLen+1) + sizeof(SZ_TMB));

    _tcscpy(pszThumb,pIrCamContext->pszCameraImagePath);
    _tcscat(pszThumb,SZ_TMB);

    if (!DeleteFile(pszThumb))
        {
        dwStatus = ::GetLastError();
        }

    //
    // Now, delete the image (.jpg):
    //
    if (!DeleteFile(pIrCamContext->pszCameraImagePath))
        {
        dwStatus = ::GetLastError();
        }

    return S_OK;
    }


//--------------------------------------------------------------------------
// CamTakePicture()
//
// Tell the camera to snap a picture. IrTran-P doesn't support this.
//
// Arguments:
//
//    pIrCamContext --
//
//    pHandle       --
//
//
// Return Value:
//
//    HRESULT     E_NOTIMPL
//
//--------------------------------------------------------------------------
HRESULT CamTakePicture( IRCAM_IMAGE_CONTEXT  *pIrCamContext ,
                        ULONG                 *pHandle)
    {
    return E_NOTIMPL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\ircamera.inc ===
#
#  Common settings for the IrTran-P USD
#

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\camevent.cpp ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    camevent.cpp

Abstract:

    Enumerate disk images to emulate camera

Author:

    Mark Enstrom (marke) 1/13/1999


Environment:

    user mode

Revision History:

--*/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "ircamera.h"
#include "tcamprop.h"
#include "resource.h"

extern HINSTANCE g_hInst; // Global hInstance

CAM_EVENT gCamEvent[] = {

    {
        TEXT("Pathname Change"),
        &WIA_EVENT_NAME_CHANGE
    },
    {
        TEXT("Disconnect"),
        &WIA_EVENT_DEVICE_DISCONNECTED
    },
    {
        TEXT("Connect"),
        &WIA_EVENT_DEVICE_CONNECTED
    }
};

TCHAR   gpszPath[MAX_PATH];


/**************************************************************************\
* CameraEventDlgProp
*
*
* Arguments:
*
*   hDlg
*   message
*   wParam
*   lParam
*
* Return Value:
*
*    Status
*
* History:
*
*    1/11/1999 Original Version
*
\**************************************************************************/
BOOL  _stdcall
CameraEventDlgProc(
   HWND       hDlg,
   unsigned   message,
   DWORD      wParam,
   LONG       lParam )

/*++

Routine Description:

   Process message for about box, show a dialog box that says what the
   name of the program is.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    static IrUsdDevice *pDevice;

    switch (message) 
        {
        case WM_INITDIALOG:
            {
            //
            // get event list from device
            //
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 0, (long)gCamEvent[0].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 1, (long)gCamEvent[1].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 2, (long)gCamEvent[2].pszEvent);

            SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, 0, 0);

            pDevice = (IrUsdDevice*)lParam;
            pDevice->m_hDlg = hDlg;

            SetDlgItemText(hDlg, IDC_EDIT1, gpszPath);

            }
            break;

        case WM_COMMAND:
            switch(wParam) 
                {

                case IDCANCEL:
                case IDOK:
                    {
                    //if (IDYES == MessageBox( hDlg, TEXT("Are you sure you want to close the event dialog?"), TEXT("IR Camera"), MB_ICONQUESTION|MB_YESNOCANCEL ))
                        EndDialog( hDlg, wParam );
                    }
                    break;

            case IDD_GEN_EVENT:
                    {
                    //
                    // if event is not already set
                    //

                    //
                    // get selected
                    //

                    int i = SendDlgItemMessage(
                                hDlg,
                                IDC_COMBO1,
                                CB_GETCURSEL, 0, 0);

                    pDevice->m_guidLastEvent = *gCamEvent[i].pguid;

                    //
                    // private event
                    //

                    if (IsEqualIID(pDevice->m_guidLastEvent,WIA_EVENT_NAME_CHANGE)) 
                        {
                        UINT ui = GetDlgItemText( hDlg, IDC_EDIT1, gpszPath, MAX_PATH );
                        }

                    SetEvent(pDevice->m_hSignalEvent);
                    WIAS_TRACE((g_hInst,"CameraEventDlgProc(): SetEvent()"));
                    return TRUE;
                    }
                }
            break;
        }

    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\device.cpp ===
//------------------------------------------------------------------------------
// Copyright (c) 1999-2000  Microsoft Corporation.
//
//  device.cpp
//
//  Implement IrTran-P device methods.
//
//  Author:
//
//     EdwardR   12-Aug-1999   Modeled from code by ReedB.
//
//------------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <irthread.h>

#include "ircamera.h"
#include "resource.h"
#include "tcamprop.h"

// #include "/nt/private/windows/imagein/ui/uicommon/simstr.h"
// #include "/nt/private/windows/imagein/ui/inc/shellext.h"

extern HINSTANCE g_hInst;
extern DWORD EnableDisableIrCOMM( IN BOOL fDisable );  // irtranp\irtranp.cpp

DWORD  WINAPI EventMonitorThread( IN void *pvIrUsdDevice );  // Forward Ref.

#define SZ_REG_KEY_INFRARED    TEXT("Control Panel\\Infrared")
#define SZ_REG_KEY_IRTRANP     TEXT("Control Panel\\Infrared\\IrTranP")
#define SZ_REG_DISABLE_IRCOMM  TEXT("DisableIrCOMM")

HKEY  g_hRegistryKey = 0;

//--------------------------------------------------------------------------
// SignalWIA()
//
// Helper function used by the IrTran-P code to signal WIA that a new
// picture has arrived.
//
// Arguments:
//
//    pvIrUsdDevice  -- Device object. IrTran-P only knows this as a void*.
//
//--------------------------------------------------------------------------
DWORD SignalWIA( IN char *pszPathPlusFileName,
                 IN void *pvIrUsdDevice )
    {
    HRESULT hr;
    DWORD   dwStatus = 0;
    IrUsdDevice *pIrUsdDevice = (IrUsdDevice*)pvIrUsdDevice;


    //
    // First, add the new picture to the tree representing the images:
    //
    if (pIrUsdDevice && pIrUsdDevice->IsInitialized())
        {
        TCHAR *ptszPath;
        TCHAR *ptszFileName;

        #ifdef UNICODE

        int      iStatus;
        WCHAR    wszTemp[MAX_PATH];

        iStatus = MultiByteToWideChar( CP_ACP,
                                       0,
                                       pszPathPlusFileName,
                                       -1, // Auto-calculate length...
                                       wszTemp,
                                       MAX_PATH);

        ptszPath = wszTemp;
        ptszFileName = wcsrchr(wszTemp,L'\\');
        ptszFileName++;

        #else

        ptszPath = pszPathPlusFileName;
        ptszFileName = strrchr(pszPathPlusFileName,'\\');
        ptszFileName++;

        #endif

        IrUsdDevice *pIrUsdDevice = (IrUsdDevice*)pvIrUsdDevice;
        IWiaDrvItem *pNewImage;

        hr = pIrUsdDevice->CreateItemFromFileName(
                             WiaItemTypeFile | WiaItemTypeImage,
                             ptszPath,
                             ptszFileName,
                             &pNewImage);

        if (!FAILED(hr))
            {
            IWiaDrvItem *pDrvItemRoot = pIrUsdDevice->GetDrvItemRoot();

            hr = pNewImage->AddItemToFolder(pDrvItemRoot);

            pNewImage->Release();
            }
        else
            {
            WIAS_ERROR((g_hInst,"SignalWIA(): CreateItemFromFileName() Failed: %x",hr));
            }
        }

    //
    // Now, signal WIA:
    //
    if (pIrUsdDevice)
        {
        DWORD dwNewTime = GetTickCount();
        DWORD dwDelta = dwNewTime - pIrUsdDevice->m_dwLastConnectTime;

        if (dwDelta > RECONNECT_TIMEOUT)
            {
            pIrUsdDevice->m_guidLastEvent = WIA_EVENT_DEVICE_CONNECTED;
            if (!SetEvent(pIrUsdDevice->m_hSignalEvent))
                {
                dwStatus = GetLastError();
                WIAS_ERROR((g_hInst,"SignalWIA(): SetEvent() Failed: %d",dwStatus));
                }
            }
        else
            {
            pIrUsdDevice->m_guidLastEvent = WIA_EVENT_ITEM_CREATED;
            if (!SetEvent(pIrUsdDevice->m_hSignalEvent))
                {
                dwStatus = GetLastError();
                WIAS_ERROR((g_hInst,"SignalWIA(): SetEvent() Failed: %d",dwStatus));
                }
            }

        pIrUsdDevice->m_dwLastConnectTime = dwNewTime;
        }
    else
        {
        WIAS_ERROR((g_hInst,"SignalWIA(): null pvIrUsdDevice object"));
        return dwStatus;
        }

    //
    // Display IrCamera browser if it's not already up:
    //
#if FALSE
    HINSTANCE hInst = LoadLibrary(TEXT("WIASHEXT.DLL"));
    if (hInst)
        {
        WIAMAKEFULLPIDLFORDEVICE pfn =
              (WIAMAKEFULLPIDLFORDEVICE)GetProcAddress(hInst, "MakeFullPidlForDevice");

        if (pfn)
            {
            LPITEMIDLIST pidl = NULL;

            pfn( pIrUsdDevice->m_bstrDeviceID, &pidl );

            if (pidl)
                {
                SHELLEXECUTEINFO sei;

                memset( &sei, 0, sizeof(sei) );

                sei.cbSize      = sizeof(sei);
                // sei.hwnd        = hDlg;
                sei.fMask       = SEE_MASK_IDLIST;
                sei.nShow       = SW_SHOW;
                sei.lpIDList    = pidl;

                ShellExecuteEx( &sei );

                LPMALLOC pMalloc = NULL;
                if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
                    {
                    pMalloc->Free(pidl);
                    pMalloc->Release();
                    }
                }
            }


        FreeLibrary( hInst );
        }
#endif

    return dwStatus;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::IrUsdDevice()
//
//   Device class constructor
//
// Arguments:
//
//    punkOuter
//
// Return Value:
//
//    None
//
//--------------------------------------------------------------------------
IrUsdDevice::IrUsdDevice( LPUNKNOWN punkOuter ):
                  m_cRef(1),
                  m_punkOuter(NULL),
                  m_dwLastConnectTime(0),
                  m_fValid(FALSE),
                  m_pIStiDevControl(NULL),
                  m_hShutdownEvent(INVALID_HANDLE_VALUE),
                  m_hRegistryEvent(INVALID_HANDLE_VALUE),
                  m_hSignalEvent(INVALID_HANDLE_VALUE),
                  m_hIrTranPThread(NULL),
                  m_hEventMonitorThread(NULL),
                  m_guidLastEvent(GUID_NULL),
                  m_pIWiaEventCallback(NULL),
                  m_pStiDevice(NULL),
                  m_bstrDeviceID(NULL),
                  m_bstrRootFullItemName(NULL),
                  m_pIDrvItemRoot(NULL)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::IrUsdDevice"));

    //
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    //

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        }
    else
        {
        //
        // Cast below is needed in order to point to right virtual table
        //
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
        }
    }

HRESULT IrUsdDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;
    
    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"IrUsdDevice::PrivateInitialize, create shutdown CritSect failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {

        //
        // Create event for syncronization of notifications shutdown.
        //
        m_hShutdownEvent =  CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent))
        {
            m_fValid = TRUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"IrUsdDevice::PrivateInitialize, create shutdown event failed"));
        }
    }
    
    return hr;
}

                  

//------------------------------------------------------------------------
// IrUsdDevice::~IrUsdDevice
//
//   Device class destructor
//
// Arguments:
//
//    None
//
// Return Value:
//
//    None
//
//------------------------------------------------------------------------
IrUsdDevice::~IrUsdDevice(void)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::~IrUsdDevice"));


    //
    // Kill notification thread if it exists.
    //

    SetNotificationHandle(NULL);

    //
    // Close event for syncronization of notifications shutdown.
    //

    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE))
        {
        CloseHandle(m_hShutdownEvent);
        }

    if (m_hRegistryEvent && (m_hRegistryEvent != INVALID_HANDLE_VALUE))
        {
        CloseHandle(m_hRegistryEvent);
        }

    //
    // Release the device control interface.
    //

    if (m_pIStiDevControl)
        {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
        }

    //
    // WIA member destruction
    //
    // Cleanup the WIA event sink.
    //

    if (m_pIWiaEventCallback)
        {
        m_pIWiaEventCallback->Release();
        }

    //
    // Free the storage for the device ID.
    //

    if (m_bstrDeviceID)
        {
        SysFreeString(m_bstrDeviceID);
        }

    //
    // Release the objects supporting device property storage.
    //

    if (m_bstrRootFullItemName)
        {
        SysFreeString(m_bstrRootFullItemName);
        }

    //
    // Free the critical section.
    //
    DeleteCriticalSection(&m_csShutdown);
    
    }

/**************************************************************************\
* IrUsdDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    //
    // We do support device notifications, but do not requiring polling.
    //

    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return STI_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::GetStatus()
//
//   Query device online and/or event status.
//
// Arguments:
//
//   pDevStatus  - Pointer to device status data.
//
// Return Value:
//
//    HRESULT - STI_OK
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::GetStatus( IN OUT PSTI_DEVICE_STATUS pDevStatus )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::GetStatus()"));

    //
    // Validate parameters.
    //
    if (!pDevStatus)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::GetStatus, NULL device status"));
        return E_INVALIDARG;
        }

    //
    // If we are asked, verify whether device is online.
    //
    pDevStatus->dwOnlineState = 0L;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)
        {
        //
        // The IrTran-P device is always on-line:
        //
        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }

    //
    // If we are asked, verify state of event.
    //
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE)
        {
        //
        // Generate an event the first time we load.
        //
        if (m_bUsdLoadEvent)
            {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_bUsdLoadEvent = FALSE;
            }

        //
        // event pending ???
        //
        }

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::DeviceReset()
//
//   Reset data file pointer to start of file. For IrTran-P, we don't need
//   to do anything.
//
// Arguments:
//
//    None
//
// Return Value:
//
//    HRESULT - STI_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::DeviceReset(void)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::DeviceReset()"));

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::Diagnostic()
//
//   Run the camera through a test diagnostic. The IrTran-P device will
//   always pass the diagnostic.
//
// Arguments:
//
//    pBuffer    - Pointer o diagnostic results data.
//
// Return Value:
//
//    HRESULT - STI_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::Diagnostic( IN OUT LPSTI_DIAG pBuffer )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::Diagnostic()"));

    //
    // Initialize response buffer
    //
    pBuffer->dwStatusMask = 0;

    memset( &pBuffer->sErrorInfo, 0, sizeof(pBuffer->sErrorInfo) );

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::StartIrTranPThread()
//
//--------------------------------------------------------------------------
DWORD IrUsdDevice::StartIrTranPThread()
    {
    DWORD   dwStatus = S_OK;
    DWORD   dwThread;

    if (!m_hIrTranPThread)
        {
        m_hIrTranPThread = CreateThread( NULL,       // Default security
                                         0,          // Default stack size
                                         IrTranP,    // IrTran-P protocol eng.
                                         (LPVOID)this,
                                         0,          // Creation flags
                                         &dwThread); // New thread ID.

        if (!m_hIrTranPThread)
            {
            dwStatus = ::GetLastError();
            WIAS_ERROR((g_hInst,"IrUsdDevice::SetNotificationHandle(): unable to create IrTran-P thread: %d",dwStatus));
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::StopIrTranPThread()
//
//--------------------------------------------------------------------------
DWORD IrUsdDevice::StopIrTranPThread()
    {
    DWORD   dwStatus;

    //
    // Shutdown the listen on IrCOMM, this will cause the IrTran-P thread
    // to exit.
    //
    dwStatus = EnableDisableIrCOMM(TRUE);  // TRUE == Disable.

    m_hIrTranPThread = NULL;

    return dwStatus;
    }
//--------------------------------------------------------------------------
// IrUsdDevice::StartEventMonitorThread()
//
//--------------------------------------------------------------------------
DWORD IrUsdDevice::StartEventMonitorThread()
    {
    DWORD   dwStatus = S_OK;
    DWORD   dwThread;

    //
    //  Event to signal for registry changes:
    //
    if ((!m_hRegistryEvent)||(m_hRegistryEvent == INVALID_HANDLE_VALUE))
        {
        m_hRegistryEvent = CreateEvent( NULL,    // Security
                                        FALSE,   // Auto-reset
                                        FALSE,   // Initially not set
                                        NULL );  // No name
        }

    if (!m_hRegistryEvent)
        {
        dwStatus = ::GetLastError();

        WIAS_ERROR((g_hInst,"IrUsdDevice::StartEventMonitorThread(): unable to create Registry Monitor Event: %d",dwStatus));

        return dwStatus;
        }

    //
    //  Start monitoring the registry to look for enable/disable changes
    //  for access to the IrCOMM port.
    //
    if (!m_hEventMonitorThread)
        {
        m_hEventMonitorThread = CreateThread(
                                        NULL,        // Default security
                                        0,           // Default stack size
                                        EventMonitorThread,
                                        (LPVOID)this,// Function data
                                        0,           // Creation flags
                                        &dwThread ); // New thread ID
        if (!m_hEventMonitorThread)
            {
            dwStatus = ::GetLastError();
            WIAS_ERROR((g_hInst,"IrUsdDevice::StartEventMonitorThread(): unable to create Registry Monitor Thread: %d",dwStatus));
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::SetNotificationHandle()
//
//   Starts and stops the event notification thread.
//
// Arguments:
//
//    hEvent -   Event to use in signaling WIA of events (like CONNECT etc.)
//               If valid start the notification thread otherwise kill the
//               notification thread.
//
// Return Value:
//
//    HRESULT  - STI_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::SetNotificationHandle( IN HANDLE hEvent )
    {
    DWORD   dwStatus;
    HRESULT hr = STI_OK;

    WIAS_TRACE((g_hInst,"IrUsdDevice::SetNotificationHandle"));


    EnterCriticalSection(&m_csShutdown);

    //
    // Are we starting or stopping the notification thread?
    //
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE))
        {
        m_hSignalEvent = hEvent;

        //
        // Initialize to no event.
        //
        m_guidLastEvent = GUID_NULL;

#if FALSE
        //
        // Create the notification thread.
        //
        if (!m_hIrTranPThread)
            {
            DWORD   dwThread;

            m_hIrTranPThread = CreateThread(
                                         NULL,       // Default security
                                         0,          // Default stack size
                                         IrTranP,    // IrTran-P protocol eng.
                                         (LPVOID)this,
                                         0,          // Creation flags
                                         &dwThread); // New thread ID.

            if (m_hIrTranPThread)
                {
                WIAS_TRACE((g_hInst,"IrUsdDevice::SetNotificationHandle(): Enabling IrTran-P"));
                }
            else
                {
                dwStatus = ::GetLastError();
                WIAS_ERROR((g_hInst,"IrUsdDevice::SetNotificationHandle(): unable to create IrTran-P thread: %d",dwStatus));
                hr = HRESULT_FROM_WIN32(dwStatus);
                }
            }
        else
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::SetNotificationHandle(): spurious IrTran-P thread"));
            hr = STI_OK;   // STIERR_UNSUPPORTED;
            }
#endif

        dwStatus = StartEventMonitorThread();

        if (dwStatus)
            {
            hr = HRESULT_FROM_WIN32(dwStatus);
            }
        }
    else
        {
        //
        // Disable event notifications.
        //
        SetEvent(m_hShutdownEvent);

        if (m_hIrTranPThread)
            {
            WIAS_TRACE((g_hInst,"IrUsdDevice::SetNotificationHandle(): stopping IrTran-P thread"));
            UninitializeIrTranP(m_hIrTranPThread);
            }
        }

    LeaveCriticalSection(&m_csShutdown);

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::GetNotificationData()
//
//   WIA calls this function to get data on the event. Currently for IrTran-P,
//   we get one of two events either WIA_EVENT_DEVICE_CONNECTED or
//   WIA_EVENT_ITEM_CREATED.
//
// Arguments:
//
//    pStiNotify - Pointer to event data.
//
// Return Value:
//
//    HRESULT  - STI_OK
//               STIERR_NOEVENT (not currently returned).
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::GetNotificationData( IN OUT LPSTINOTIFY pStiNotify )
    {
    DWORD  dwStatus;

    WIAS_TRACE((g_hInst,"IrUsdDevice::GetNotificationData()"));

    memset(pStiNotify,0,sizeof(STINOTIFY));

    pStiNotify->dwSize = sizeof(STINOTIFY);

    pStiNotify->guidNotificationCode =  m_guidLastEvent;

    //
    // If we are to return a device connected then follow it by an item
    // created event.
    //
    if (IsEqualGUID(m_guidLastEvent,WIA_EVENT_DEVICE_CONNECTED))
        {
        m_guidLastEvent = WIA_EVENT_ITEM_CREATED;
        if (!SetEvent(m_hSignalEvent))
            {
            dwStatus = ::GetLastError();
            WIAS_ERROR((g_hInst,"SignalWIA(): SetEvent() Failed: %d",dwStatus));
            }
        }

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::Escape()
//
//   Used to issue a command to the device. IrTran-P doesn't support this.
//
// Arguments:
//
//    EscapeFunction - Command to be issued.
//    pInData        - Input data to be passed with command.
//    cbInDataSize   - Size of input data.
//    pOutData       - Output data to be passed back from command.
//    cbOutDataSize  - Size of output data buffer.
//    pcbActualData  - Size of output data actually written.
//
// Return Value:
//
//    HRESULT - STI_OK
//              STIERR_UNSUPPORTED
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::Escape(
                            STI_RAW_CONTROL_CODE EscapeFunction,
                            LPVOID               pInData,
                            DWORD                cbInDataSize,
                            LPVOID               pOutData,
                            DWORD                cbOutDataSize,
                            LPDWORD              pcbActualData )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::Escape(): unsupported"));

    //
    // Write command to device if needed.
    //

    return STIERR_UNSUPPORTED;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::GetLastError()
//
//   Get the last error from the device.
//
// Arguments:
//
//    pdwLastDeviceError - Pointer to last error data.
//
// Return Value:
//
//    HRESULT - STI_OK
//              STIERR_INVALID_PARAM
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::GetLastError( OUT LPDWORD pdwLastDeviceError )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::GetLastError()"));

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD)))
        {
        return STIERR_INVALID_PARAM;
        }

    *pdwLastDeviceError = m_dwLastOperationError;

    return STI_OK;
    }

/**************************************************************************\
* IrUsdDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    WIAS_TRACE((g_hInst,"IrUsdDevice::GetLastErrorInfo"));

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return STI_OK;
}

/**************************************************************************\
* IrUsdDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::LockDevice(void)
    {
    return STI_OK;
    }

/**************************************************************************\
* IrUsdDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::UnLockDevice(void)
{
    return STI_OK;
}

/**************************************************************************\
* IrUsdDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawReadData"));

    return STI_OK;
}

/**************************************************************************\
* IrUsdDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawWriteData"));

    return STI_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::RawReadCommand()
//
//    Raw read of bytes directly from the camera. Not supported by IrTran-P
//    device.
//
// Arguments:
//
//    lpBuffer           -
//    lpdwNumberOfBytes  -
//    lpOverlapped       -
//
// Return Value:
//
//    HRESULT  - STIERR_UNSUPPORTED
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::RawReadCommand(
                             IN LPVOID          lpBuffer,
                             IN LPDWORD         lpdwNumberOfBytes,
                             IN LPOVERLAPPED    lpOverlapped)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawReadCommand() not supported"));

    return STIERR_UNSUPPORTED;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::RawWriteCommand()
//
//    Raw write of byte directly to a camera. Not supported by IrTran-P device.
//
// Arguments:
//
//    lpBuffer       -
//    nNumberOfBytes -
//    lpOverlapped   -
//
// Return Value:
//
//    HRESULT  - STIERR_UNSUPPORTED
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::RawWriteCommand(
                             IN LPVOID          lpBuffer,
                             IN DWORD           nNumberOfBytes,
                             IN LPOVERLAPPED    lpOverlapped )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawWriteCommand(): not supported"));

    return STIERR_UNSUPPORTED;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::Initialize()
//
//   Initialize the device object.
//
// Arguments:
//
//    pIStiDevControlNone    -
//    dwStiVersion           -
//    hParametersKey         -
//
// Return Value:
//
//    HRESULT  STI_OK
//             STIERR_INVALID_PARAM
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::Initialize(
                               PSTIDEVICECONTROL pIStiDevControl,
                               DWORD             dwStiVersion,
                               HKEY              hParametersKey )
    {
    HRESULT  hr = STI_OK;
    UINT     uiNameLen = 0;
    CAMERA_STATUS   camStatus;

    WIAS_TRACE((g_hInst,"IrUsdDevice::Initialize"));

    if (!pIStiDevControl)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::Initialize(): invalid device control interface"));
        return STIERR_INVALID_PARAM;
        }

    //
    // Cache the device control interface:
    //
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Try to open the camera only once here during Initialize:
    //
    hr = CamOpenCamera(&camStatus);

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::RunNotifications()
//
//   Monitor changes to the source data file parent directory.
//
// Arguments:
//
//    None
//
// Return Value:
//
//    None
//
//--------------------------------------------------------------------------
VOID IrUsdDevice::RunNotifications(void)
    {
    //
    // Start up camera event dlg
    //
    WIAS_TRACE((g_hInst,"IrUsdDevice::RunNotifications: start up event dlg"));

    HWND hWnd = GetDesktopWindow();

    int iret = DialogBoxParam( g_hInst,
                               MAKEINTRESOURCE(IDD_EVENT_DLG),
                               hWnd,
                               CameraEventDlgProc,
                               (LPARAM)this );

    WIAS_TRACE((g_hInst,"IrUsdDevice::RunNotifications, iret = 0x%lx",iret));

    if (iret == -1)
        {
        DWORD dwStatus = ::GetLastError();
        WIAS_TRACE((g_hInst,"IrUsdDevice::RunNotifications, dlg error = 0x%lx",dwStatus));
        }
    }

//--------------------------------------------------------------------------
// NotificationsThread()
//
//   Calls RunNotifications() to put up a dialog to start events.
//
// Arguments:
//
//    lpParameter    - Pointer to device object.
//
// Return Value:
//
//    None
//
//--------------------------------------------------------------------------
VOID NotificationsThread( LPVOID lpParameter )
    {
    WIAS_TRACE((g_hInst,"NotificationsThread(): Start"));

    IrUsdDevice *pThisDevice = (IrUsdDevice*)lpParameter;

    pThisDevice->RunNotifications();
    }


//--------------------------------------------------------------------------
//  OpenIrTranPKey()
//
//  Open and return a registry handle to the IrTranP key in the registry.
//  This key will be monitored for changes in value.
//--------------------------------------------------------------------------
DWORD OpenIrTranPKey( HKEY *phRegistryKey )
    {
    DWORD dwStatus = 0;
    DWORD dwDisposition = 0;
    HKEY  hKey;

    *phRegistryKey = 0;

    //
    // If we've been called before, then we don't need to reopen the key.
    //
    if (g_hRegistryKey)
        {
        *phRegistryKey = g_hRegistryKey;
        return 0;
        }

    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                       SZ_REG_KEY_INFRARED,
                       0,              // reserved MBZ
                       0,              // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       0,              // security attributes
                       &hKey,
                       &dwDisposition))
        {
        // Create failed.
        dwStatus = GetLastError();
        WIAS_TRACE((g_hInst,"OpenIrTranPKey(): RegCreateKeyEx(): '%' failed %d", SZ_REG_KEY_INFRARED, dwStatus));
        }

    if (RegCloseKey(hKey))
        {
        // Close failed.
        }

    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                       SZ_REG_KEY_IRTRANP,
                       0,              // reserved, MBZ
                       0,              // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       0,
                       &hKey,          // security attributes
                       &dwDisposition))
        {
        // Create failed
        dwStatus = GetLastError();
        WIAS_TRACE((g_hInst,"OpenIrTranPKey(): RegCreateKeyEx(): '%' failed %d", SZ_REG_KEY_IRTRANP, dwStatus));
        }

    *phRegistryKey = g_hRegistryKey = hKey;

    return dwStatus;
    }

//--------------------------------------------------------------------------
//  CheckForIrCOMMEnabled()
//
//  Check the registry to see if IrCOMM for IrTran-P is enabled, if it is
//  then return TRUE, else return FALSE.
//
//  Note: Don't close the key, it is maintained globally and will be closed
//  at shutdown.
//--------------------------------------------------------------------------
BOOL  CheckForIrCOMMEnabled( IN IrUsdDevice *pIrUsdDevice )
    {
    DWORD dwStatus;
    DWORD dwType;
    DWORD dwDisabled;
    DWORD dwValueSize = sizeof(dwDisabled);
    HKEY  hKey;

    dwStatus = OpenIrTranPKey(&hKey);
    if (dwStatus)
        {
        // If the key doesn't exist, or can't be opened, then assume that
        // we are enabled...
        return TRUE;
        }

    //
    // Check the value of the "DisableIrCOMM" value. Zero or missing value
    // means fEnabled == TRUE, non-zero value means fEnabled == FALSE.
    //
    if (RegQueryValueEx( hKey,         // IrTranP registry key
                         SZ_REG_DISABLE_IRCOMM,
                         NULL,         // reserved, MB NULL
                         &dwType,      // out, value type (expect: REG_DWORD)
                         (BYTE*)&dwDisabled, // out, value
                         &dwValueSize))      // in/out, size of value
        {
        // Query disabled flag registry value failed, assume enabled.
        return TRUE;
        }

    if ((dwType == REG_DWORD) && (dwDisabled))
        {
        // Disabled flag is set.
        return FALSE;
        }

    return TRUE;
    }

//--------------------------------------------------------------------------
//  EventMonitorThread()
//
//--------------------------------------------------------------------------
DWORD WINAPI EventMonitorThread( IN void *pvIrUsdDevice )
    {
    DWORD  dwStatus = 0;
    BOOL   fEnabled;
    HANDLE hHandles[2];
    HKEY   hRegistryKey;
    IrUsdDevice *pIrUsdDevice = (IrUsdDevice*)pvIrUsdDevice;

    //
    // Get the IrTranP registry key. We will monitor this key for
    // changes...
    //
    dwStatus = OpenIrTranPKey(&hRegistryKey);
    if (dwStatus)
        {
        return dwStatus;
        }

    //
    // We will Monitor two events. One for shutdown of the USD, the
    // other for registry state changes (to enable/disable listen on
    // IrCOMM).
    //
    hHandles[0] = pIrUsdDevice->m_hShutdownEvent;
    hHandles[1] = pIrUsdDevice->m_hRegistryEvent;

    while (TRUE)
        {
        fEnabled = CheckForIrCOMMEnabled(pIrUsdDevice);

        if ((fEnabled) && (!pIrUsdDevice->m_hIrTranPThread))
            {
            // Start IrTran-P listen/protocol thread.
            dwStatus = pIrUsdDevice->StartIrTranPThread();
            }
        else if (pIrUsdDevice->m_hIrTranPThread)
            {
            // Stop IrTran-P listen/protocol thread.
            dwStatus = pIrUsdDevice->StopIrTranPThread();
            }

        dwStatus = RegNotifyChangeKeyValue( hRegistryKey,  // IrTranP key
                                            FALSE,    // don't watch subtree
                                            REG_NOTIFY_CHANGE_LAST_SET,
                                            pIrUsdDevice->m_hRegistryEvent,
                                            TRUE );   // Asynchronous

        dwStatus = WaitForMultipleObjects( 2,
                                           hHandles,
                                           FALSE,
                                           INFINITE);
        if (dwStatus == WAIT_FAILED)
            {
            dwStatus = GetLastError();
            break;
            }

        if (dwStatus == WAIT_OBJECT_0)
            {
            // Received a shutdown event. If the IrTranP thread is running
            // then shut it down. Break out of this while loop to stop this
            // monitor thread.
            break;
            }

        if (dwStatus == WAIT_OBJECT_0+1)
            {
            // Received a registry change event. We'll continue around the
            // while loop and check to see if IrTranP over IrCOMM has been
            // disabled...
            continue;
            }

        else if (dwStatus == WAIT_ABANDONED_0)
            {
            // Wait abandonded on the shutdown event
            }
        else if (dwStatus == WAIT_ABANDONED_0+1)
            {
            // Wait abandonded on the registry change event
            }
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\ircamera.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// TITLE:       ircamera.cpp
//
// VERSION:     1.0
//
// AUTHOR:
//
//    EdwardR    22/Jul/99   Original coding.
//
// DESCRIPTION:
//
//    Implementation of the WIA IrTran-P USD.
//
//------------------------------------------------------------------------------

#define INITGUID

#include "ircamera.h"
#include "resource.h"

#include "wiamindr_i.c"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.

// Can we use UNICODE APIs
//BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

// Debugging interface, has IrUsdClassFactory lifetime.
WIA_DECLARE_DEBUGGER();

/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  IrUsdClassFactory
*
\****************************************************************************/

class IrUsdClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    IrUsdClassFactory();
    ~IrUsdClassFactory();
};

/**************************************************************************\
* IrUsdClassFactory::IrUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

IrUsdClassFactory::IrUsdClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_TRACE((g_hInst,"Creating IrUsdClassFactory"));
}

/**************************************************************************\
* IrUsdClassFactory::~IrUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

IrUsdClassFactory::~IrUsdClassFactory(void)
{
    // Destructor logic
    WIAS_TRACE((g_hInst,"Destroying IrUsdClassFactory"));
}

/**************************************************************************\
* IrUsdClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR  *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* IrUsdClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* IrUsdClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* IrUsdClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                       riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{

    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IWiaItem) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    IrUsdDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new IrUsdDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* IrUsdClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* IrUsdDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::NonDelegatingQueryInterface(
    REFIID   riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* IrUsdDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* IrUsdDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* IrUsdDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* IrUsdDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* IrUsdDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C"
BOOL APIENTRY
DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {
                OutputDebugStringA("IrUsd: Unloaded before all objects releaseed!\n");
            }

            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_IrUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_IrUsd)) {
        IrUsdClassFactory *pcf = new IrUsdClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\ircamera.h ===
//---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999, All rights reserved
//
//  ircamera.h
//
//  Microsoft Confidential
//  
//  Author:  EdwardR        22/July/99      Initial Coding.
//
//
//---------------------------------------------------------------------------

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"
#include "wiamindr.h"

//---------------------------------------------------------------------------
// Temp (cached) thumbnail file name extension:
//---------------------------------------------------------------------------

#define SZ_TMB    TEXT(".tmb")

//---------------------------------------------------------------------------
// Timeout for sending a reconnect signal to WIA. Currently set to three
// minutes (in milliseconds):
//---------------------------------------------------------------------------

#define RECONNECT_TIMEOUT    (3*60*1000)

//---------------------------------------------------------------------------
// GUID's
//---------------------------------------------------------------------------

#if defined( _WIN32 ) && !defined( _NO_COM)

//  {26d2e349-10ca-4cc2-881d-3e8025d9b6de}
DEFINE_GUID(CLSID_IrUsd, 0x26d2e349L, 0x10ca, 0x4cc2, 0x88, 0x1d, 0x3e, 0x80, 0x25, 0xd9, 0xb6, 0xde);

// {b62d000a-73b3-4c0c-9a4d-9eb4886d147c}
DEFINE_GUID(guidEventTimeChanged, 0xb62d000aL, 0x73b3, 0x4c0c, 0x9a, 0x4d, 0x9e, 0xb4, 0x88, 0x6d, 0x14, 0x7c);

// {d69b7fbd-9f21-4acf-96b7-86c2aca97ae1}
DEFINE_GUID(guidEventSizeChanged, 0xd69b7fbdL, 0x9f21, 0x4acf, 0x96, 0xb7, 0x86, 0xc2, 0xac, 0xa9, 0x7a, 0xe1);

// {ad89b522-0986-45eb-9ec3-803989197af8}
DEFINE_GUID(guidEventFirstLoaded, 0xad89b522L, 0x0986, 0x45eb, 0x9e, 0xc3, 0x80, 0x39, 0x89, 0x19, 0x7a, 0xf8);

#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//---------------------------------------------------------------------------
//
// Module ref counting
//
//---------------------------------------------------------------------------

extern UINT g_cRefThisDll;
extern UINT g_cLocks;

extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);

extern void DllAddRef(void);
extern void DllRelease(void);

typedef struct _IRCAM_IMAGE_CONTEXT
    {
	PTCHAR	pszCameraImagePath;
    } IRCAM_IMAGE_CONTEXT, *PIRCAM_IMAGE_CONTEXT;

typedef struct _CAMERA_PICTURE_INFO
    {
    LONG    PictNumber;
    LONG    ThumbWidth;
    LONG    ThumbHeight;
    LONG    PictWidth;
    LONG    PictHeight;
    LONG    PictCompSize;
    LONG    PictFormat;
    LONG    PictBitsPerPixel;
    LONG    PictBytesPerRow;
    SYSTEMTIME TimeStamp;
    } CAMERA_PICTURE_INFO, *PCAMERA_PICTURE_INFO;


typedef struct _CAMERA_STATUS
    {
    LONG    FirmwareVersion;
    LONG    NumPictTaken;
    LONG    NumPictRemaining;
    LONG    ThumbWidth;
    LONG    ThumbHeight;
    LONG    PictWidth;
    LONG    PictHeight;
    SYSTEMTIME CameraTime;
    } CAMERA_STATUS, *PCAMERA_STATUS;

#define ALLOC(s) LocalAlloc(0,s)
#define FREE(s)  LocalFree(s)


//---------------------------------------------------------------------------
//
// Base class for supporting non-delegating IUnknown for contained objects
//
//---------------------------------------------------------------------------

struct INonDelegatingUnknown
    {
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
    };


//---------------------------------------------------------------------------
//
// Class definition for object
//
//---------------------------------------------------------------------------

class IrUsdDevice : public IStiUSD,
                    public IWiaMiniDrv,
                    public INonDelegatingUnknown
{
private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.

public:
    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hIrTranPThread;       // IrTran-P camera protocol.

    HANDLE              m_hRegistryEvent;
    HANDLE              m_hEventMonitorThread;

    // WIA information, one time initialization.
    IStiDevice         *m_pStiDevice;           // Sti object.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback  *m_pIWiaEventCallback;   // WIA event sink.
    IWiaDrvItem        *m_pIDrvItemRoot;        // root item

    HANDLE              m_hSignalEvent;         // Signal event handle.
    HWND                m_hDlg;
    GUID                m_guidLastEvent;        // Last event ID.

    DWORD               m_dwLastConnectTime;    // msec since last connect.

    // *** IUnknown-like methods ***
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey)  ;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps)  ;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus)  ;
    STDMETHOD(DeviceReset)(THIS )  ;
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer)  ;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError)  ;
    STDMETHOD(LockDevice) (THIS )  ;
    STDMETHOD(UnLockDevice) (THIS )  ;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent)  ;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify)  ;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo);

    //
    // MiniDrv methods
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE         *pWiasContext, 
        LONG          lFlags,
        BSTR          bstrDeviceID,          
        BSTR          bstrRootFullItemName, 
        IUnknown     *pStiDevice,           
        IUnknown     *pIUnknownOuter,       
        IWiaDrvItem **ppIDrvItemRoot,       
        IUnknown    **ppIUnknownInner,
        LONG         *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_ 
        LONG          lFlags, 
        LONG          lDevErrVal, 
        LPOLESTR     *ppszDevErrStr, 
        LONG         *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_ 
        BYTE         *pWiasContext,
        LONG          lFlags,
        const GUID   *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG         *plErr);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE         *pWiasContext, 
        LONG          lFlags,
        PMINIDRV_TRANSFER_CONTEXT pDataContext, 
        LONG         *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_ 
        BYTE         *pWiasContext, 
        LONG          lFlags,
        LONG         *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_ 
        BYTE         *pWiasContext, 
        LONG          lFlags,
        ULONG         nPropSpec, 
        const PROPSPEC *pPropSpec, 
        LONG         *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_ 
        BYTE         *pWiasContext, 
        LONG          lFLags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG         *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_ 
        BYTE         *pWiaItem, 
        LONG          lFlags,
        ULONG         nPropSpec, 
        const PROPSPEC *pPropSpec, 
        LONG         *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal );

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal);

	 STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG          lFlags,
        BYTE         *pSpecContext,
        LONG         *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE         *pWiasContext,
        LONG          ulFlags,
        LONG         *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG         *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE         *pWiasContext,
        LONG          ulFlags,
        LONG         *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG         *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID   *pEventGUID,
        BSTR          bstrDeviceID,
        ULONG         ulReserved );

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);

    //
    // Public helper methods:
    //
    HRESULT CreateItemFromFileName(
        LONG            FolderType,
        PTCHAR          pszPath,
        PTCHAR          pszName,
        IWiaDrvItem   **ppNewFolder);

    IWiaDrvItem *GetDrvItemRoot(VOID);
    BOOL         IsInitialized(VOID);
    BOOL         IsValid(VOID);

private:
    //
    // Private helper methods:
    //
    HRESULT InitImageInformation(
        BYTE                  *,
        IRCAM_IMAGE_CONTEXT   *,
        LONG                  *);


    HRESULT EnumDiskImages(
        IWiaDrvItem  *pRootFile,
        TCHAR        *pwszPath );

    HRESULT CamLoadPicture(
        IRCAM_IMAGE_CONTEXT      *pCameraImage,
        MINIDRV_TRANSFER_CONTEXT *pDataTransCtx,
        LONG                     *plDevErrVal );

    HRESULT CamLoadPictureCB(
        IRCAM_IMAGE_CONTEXT      *pCameraImage,
        MINIDRV_TRANSFER_CONTEXT *pDataTransCtx,
        LONG                     *plDevErrVal );

    HRESULT CamGetPictureInfo(
        IRCAM_IMAGE_CONTEXT        *pCameraImage,
        CAMERA_PICTURE_INFO        *pPictureInfo );

    HRESULT CamLoadThumbnail( IN  IRCAM_IMAGE_CONTEXT *pIrCamContext, 
                              OUT BYTE               **ppThumbnail,
                              OUT LONG                *pThumbSize );

    HRESULT CamDeletePicture( IRCAM_IMAGE_CONTEXT *pIrCamContext );

    HRESULT CamBuildImageTree(CAMERA_STATUS *,IWiaDrvItem **);

    HRESULT CamOpenCamera(CAMERA_STATUS *);
    
    HRESULT BuildDeviceItemTree(LONG *plDevErrVal);
    HRESULT DeleteDeviceItemTree(LONG *plDevErrVal);
    HRESULT InitDeviceProperties(BYTE *, LONG *plDevErrVal);

    void    InitializeCapabilities();

public:
    DWORD   StartEventMonitorThread();
    DWORD   StartIrTranPThread();
    DWORD   StopIrTranPThread();

public:
    IrUsdDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~IrUsdDevice();
    
    VOID RunNotifications(VOID);
};

inline IWiaDrvItem *IrUsdDevice::GetDrvItemRoot(VOID)
    {
    return m_pIDrvItemRoot;
    }

inline BOOL IrUsdDevice::IsValid(VOID)
    {
    return m_fValid;
    }

inline BOOL IrUsdDevice::IsInitialized(VOID)
    {
    return (m_bstrRootFullItemName != NULL);
    }

typedef IrUsdDevice *PIrUsdDevice;


HRESULT SetItemSize(BYTE*);

//
// Syncronization mechanisms
//
#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);


// Device constants:
const LEN_INQUIRE_BUTTON = 8;
const BYTE INQUIRE_BUTTON[LEN_INQUIRE_BUTTON + 1] = "INQUIREB";

const LEN_INQUIRE_BUTTON_READ = 10;

const LEN_CLEAR_BUTTON = 5;
const BYTE CLEAR_BUTTON[LEN_CLEAR_BUTTON + 1] = "CLRBT";

const LEN_CURRENT_ERROR = 7;
const BYTE CURRENT_ERROR[LEN_CURRENT_ERROR + 1] = "CURERR";

const LEN_DIAGS = 5;
const BYTE TURN_ON_LAMP[LEN_DIAGS + 1] = "LAMPO";
const BYTE TURN_OFF_LAMP[LEN_DIAGS + 1] = "LAMPF";
const BYTE SELF_TEST[LEN_DIAGS + 1] = "SELFT";
const BYTE STATUS_STRING[LEN_DIAGS + 1] = "STATS";


BOOL
_stdcall CameraEventDlgProc(
   HWND     hDlg,
   unsigned message,
   DWORD    wParam,
   LONG     lParam );

typedef struct _CAM_EVENT
    {
    PTCHAR       pszEvent;
    const GUID  *pguid;
    } CAM_EVENT,*PCAM_EVENT;


//
// Useful helper functions:
//

extern int LoadStringResource( IN  HINSTANCE hInst,
                        IN  UINT      uID,
                        OUT WCHAR    *pwszBuff,
                        IN  int       iBuffMax );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\defprop.h ===
//------------------------------------------------------------------------------
//  Copyright (c) 1999  Microsoft Corporation.
//
//  defprop.h
//
//     Property Declarations and definitions for the IrTran-P WIA USD.
//
//  Author:
//
//     EdwardR    12-Aug-1999
//
//------------------------------------------------------------------------------

#include  "tcamprop.h"

#define  NUM_CAP_ENTRIES         4
#define  NUM_EVENTS              3


#define PREFFERED_FORMAT_NOM        &WiaImgFmt_JPEG
#define FORMAT_NOM                  &WiaImgFmt_JPEG

#define NUM_CAM_ITEM_PROPS  (19)
#define NUM_CAM_DEV_PROPS   (17)

#ifdef __GLOBALPROPVARS__

PROPID gItemPropIDs[NUM_CAM_ITEM_PROPS] =
    {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPC_THUMBNAIL,
    WIA_IPA_ITEM_TIME,
    WIA_IPC_THUMB_WIDTH,
    WIA_IPC_THUMB_HEIGHT,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_COMPRESSION,
    WIA_IPA_CHANNELS_PER_PIXEL,
    WIA_IPA_BITS_PER_CHANNEL,
    WIA_IPA_PLANAR,
    WIA_IPA_BYTES_PER_LINE,
    WIA_IPA_ACCESS_RIGHTS,
    WIA_IPA_MIN_BUFFER_SIZE
    };

LPOLESTR gItemPropNames[NUM_CAM_ITEM_PROPS] =
    {
    WIA_IPA_DATATYPE_STR,
    WIA_IPA_DEPTH_STR,
    WIA_IPA_PIXELS_PER_LINE_STR,
    WIA_IPA_NUMBER_OF_LINES_STR,
    WIA_IPC_THUMBNAIL_STR,
    WIA_IPA_ITEM_TIME_STR,
    WIA_IPC_THUMB_WIDTH_STR,
    WIA_IPC_THUMB_HEIGHT_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_COMPRESSION_STR,
    WIA_IPA_CHANNELS_PER_PIXEL_STR,
    WIA_IPA_BITS_PER_CHANNEL_STR,
    WIA_IPA_PLANAR_STR,
    WIA_IPA_BYTES_PER_LINE_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
    WIA_IPA_MIN_BUFFER_SIZE_STR
    };

PROPID gItemCameraPropIDs[WIA_NUM_IPC] =
    {
    WIA_IPC_AUDIO_AVAILABLE,
    WIA_IPC_AUDIO_DATA
    };

LPOLESTR gItemCameraPropNames[WIA_NUM_IPC] =
    {
    WIA_IPC_AUDIO_AVAILABLE_STR,
    WIA_IPC_AUDIO_DATA_STR,
    };

PROPID gDevicePropIDs[NUM_CAM_DEV_PROPS] =
    {
    WIA_DPA_FIRMWARE_VERSION,
    WIA_DPA_CONNECT_STATUS,
    WIA_DPA_DEVICE_TIME,
    WIA_DPC_PICTURES_TAKEN,
    WIA_DPC_PICTURES_REMAINING,
    WIA_DPC_THUMB_WIDTH,
    WIA_DPC_THUMB_HEIGHT,
    WIA_DPC_PICT_WIDTH,
    WIA_DPC_PICT_HEIGHT,
    WIA_DPC_EXPOSURE_MODE,
    WIA_DPC_FLASH_MODE,
    WIA_DPC_FOCUS_MODE,
    WIA_DPC_ZOOM_POSITION,
    WIA_DPC_BATTERY_STATUS,
    WIA_DPC_TIMER_MODE,
    WIA_DPC_TIMER_VALUE,
    WIA_DPP_TCAM_ROOT_PATH
    };

LPOLESTR gDevicePropNames[NUM_CAM_DEV_PROPS] =
    {
    WIA_DPA_FIRMWARE_VERSION_STR,
    WIA_DPA_CONNECT_STATUS_STR,
    WIA_DPA_DEVICE_TIME_STR,
    WIA_DPC_PICTURES_TAKEN_STR,
    WIA_DPC_PICTURES_REMAINING_STR,
    WIA_DPC_THUMB_WIDTH_STR,
    WIA_DPC_THUMB_HEIGHT_STR,
    WIA_DPC_PICT_WIDTH_STR,
    WIA_DPC_PICT_HEIGHT_STR,
    WIA_DPC_EXPOSURE_MODE_STR,
    WIA_DPC_FLASH_MODE_STR,
    WIA_DPC_FOCUS_MODE_STR,
    WIA_DPC_ZOOM_POSITION_STR,
    WIA_DPC_BATTERY_STATUS_STR,
    WIA_DPC_TIMER_MODE_STR,
    WIA_DPC_TIMER_VALUE_STR,
    WIA_DPP_TCAM_ROOT_PATH_STR
    };

PROPSPEC gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS] =
    {
    {PRSPEC_PROPID, WIA_DPA_FIRMWARE_VERSION},
    {PRSPEC_PROPID, WIA_DPA_CONNECT_STATUS},
    {PRSPEC_PROPID, WIA_DPA_DEVICE_TIME},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_REMAINING},
    {PRSPEC_PROPID, WIA_DPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_EXPOSURE_MODE},
    {PRSPEC_PROPID, WIA_DPC_FLASH_MODE},
    {PRSPEC_PROPID, WIA_DPC_FOCUS_MODE},
    {PRSPEC_PROPID, WIA_DPC_ZOOM_POSITION},
    {PRSPEC_PROPID, WIA_DPC_BATTERY_STATUS},
    {PRSPEC_PROPID, WIA_DPC_TIMER_MODE},
    {PRSPEC_PROPID, WIA_DPC_TIMER_VALUE},
    {PRSPEC_PROPID, WIA_DPP_TCAM_ROOT_PATH}
    };

WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS] =
    {
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_FIRMWARE_VERSION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_CONNECT_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_DEVICE_TIME
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_TAKEN
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_REMAINING
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_EXPOSURE_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FLASH_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FOCUS_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_ZOOM_POSITION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_BATTERY_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_VALUE
    {WIA_PROP_RW   | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}  // WIA_DPP_ROOT_PATH
    };

PROPSPEC gPropSpecDefaults[NUM_CAM_ITEM_PROPS] =
    {
    {PRSPEC_PROPID, WIA_IPA_DATATYPE},
    {PRSPEC_PROPID, WIA_IPA_DEPTH},
    {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
    {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
    {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
    {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
    {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
    {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
    {PRSPEC_PROPID, WIA_IPA_FORMAT},
    {PRSPEC_PROPID, WIA_IPA_TYMED},
    {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
    {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
    {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL},
    {PRSPEC_PROPID, WIA_IPA_PLANAR},
    {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
    {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
    {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
    };

LONG  gPropVarDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_CAM_ITEM_PROPS)] =
    {
    // VARTYPE                 reserved    val               pad/array ptr
    (LONG)VT_I4,               0x00000000, WIA_DATA_GRAYSCALE,0x00000000,            // WIA_IPA_DATATYPE
    (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_DEPTH

    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_PIXELS_PER_LINE
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_NUMBER_OF_LINES

    (LONG)VT_VECTOR | VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMBNAIL
    (LONG)VT_VECTOR | VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_TIME
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_WIDTH
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_HEIGHT
    (LONG)VT_CLSID,            0x00000000, (LONG)PREFFERED_FORMAT_NOM,0x00000000,    // WIA_IPA_PREFERRED_FORMAT
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_SIZE
    (LONG)VT_CLSID,            0x00000000, (LONG)FORMAT_NOM,  0x00000000,            // WIA_IPA_FORMAT
    (LONG)VT_I4,               0x00000000, TYMED_CALLBACK,    0x00000000,            // WIA_IPA_TYMED
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_COMPRESSION
    (LONG)VT_I4,               0x00000000, 3,                 0x00000000,            // WIA_IPA_CHANNELS PER PIXEL
    (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_BITS PER CHANNEL
    (LONG)VT_I4,               0x00000000, WIA_PACKED_PIXEL,  0x00000000,            // WIA_IPA_PLANAR
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_WIDTH IN BYTES
    (LONG)VT_I4,               0x00000000, WIA_ITEM_RD,       0x00000000,             // WIA_IPA_ACCESS_RIGHTS

    (LONG)VT_I4,               0x00000000, 65535,             0x00000000,            // WIA_IPA_MIN_BUFFER_SIZE
    };


//
// Default device extended properties.
//

#define NUM_DATATYPE 3

LONG lDataTypes[NUM_DATATYPE] =
    {
    WIA_DATA_THRESHOLD,
    WIA_DATA_GRAYSCALE,
    WIA_DATA_COLOR
    };

#define NUM_DEPTH 3
LONG lDepths[NUM_DEPTH] =
    {
    1,
    8,
    24
    };

//
//  Different formats supported
//

#define NUM_FORMAT 2

GUID *pguidFormats[NUM_FORMAT] =
    {
    (GUID*) &WiaImgFmt_JPEG,
    (GUID*) &WiaImgFmt_JPEG
    };

GUID g_guidFormats[NUM_FORMAT];   // FormatID's specified in pguidFormats are copied to g_guidFormats
                                  // during SetFormatAttribs

//
//  This is an array of WIA_FORMAT_INFOs, describing the different formats
//  and their corresponding media types.  Initialized in wiadev.cpp
//

WIA_FORMAT_INFO* g_wfiTable = NULL;

//
//  Different media types supported
//
#define NUM_TYMED  2
LONG lTymeds [NUM_TYMED]=
    {
    TYMED_CALLBACK,
    TYMED_FILE
    };

//
// Extended information for each property
//

WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS] =
    {

    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DATATYPE, WIA_DATA_GRAYSCALE, (LONG) lDataTypes, 0}, // WIA_IPA_DATATYPE
    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DEPTH,    8,                  (LONG) lDepths,    0}, // WIA_IPA_DEPTH

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PIXELS_PER_LINE
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_NUMBER_OF_LINES
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMBNAIL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_TIME
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_PREFERRED_FORMAT, set later
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_SIZE

    {WIA_PROP_RW   | WIA_PROP_LIST, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_FORMAT, set later
    {WIA_PROP_RW   | WIA_PROP_LIST, VT_I4,    NUM_TYMED,    TYMED_CALLBACK, (LONG)lTymeds,     0}, // WIA_IPA_TYMED
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_COMPRESSION
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_CHANNELS
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BITS_PER_CHANNEL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PLANAR
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BYTES_PER_LINE
    {WIA_PROP_RW   | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ACCESS_RIGHTS

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_MIN_BUFFER_SIZE

    };

//
// Device capabilities.  Events are listed before commands to simplify the
// implementation of drvGetCapabilities(...)
//

#define  N   WIA_NOTIFICATION_EVENT
#define  A   WIA_ACTION_EVENT
#define  NA  (WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT)

WIA_DEV_CAP_DRV gCapabilities[NUM_CAP_ENTRIES] =
    {
    //
    // GUID                             ulFlags  wszName  wszDescription wszIcon
    //
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,    NA, NULL,    NULL, WIA_ICON_DEVICE_CONNECTED},
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED, N,  NULL,    NULL, WIA_ICON_DEVICE_DISCONNECTED},
    {(GUID *)&WIA_EVENT_ITEM_CREATED,        NA, NULL,    NULL, WIA_ICON_ITEM_CREATED},
    {(GUID *)&WIA_CMD_SYNCHRONIZE,           0,  NULL,    NULL, WIA_ICON_SYNCHRONIZE}
    };

//
// The device name and description strings are kept in the resource file. This
// table maps the IDS_ values (in the resource file for each of the
// gCapabilities[] array entries. gDefaultStrings[] are backup names in case
// we can't load the strings from the resource file (should never actually
// happen).
//

UINT gCapabilityIDS[NUM_CAP_ENTRIES] =
    {
    IDS_DEVICE_CONNECTED,
    IDS_DEVICE_DISCONNECTED,
    IDS_NEW_PICTURE_SENT,
    IDS_SYNCHRONIZE
    };

WCHAR *gDefaultStrings[NUM_CAP_ENTRIES] =
    {
    L"Device connected",
    L"Device disconnected",
    L"New picture sent",
    L"Synchronize"
    };


#else

extern PROPID             gItemPropIDs[NUM_CAM_ITEM_PROPS];
extern LPOLESTR           gItemPropNames[NUM_CAM_ITEM_PROPS];
extern PROPID             gItemCameraPropIDs[WIA_NUM_IPC];
extern LPOLESTR           gItemCameraPropNames[WIA_NUM_IPC];
extern PROPID             gDevicePropIDs[NUM_CAM_DEV_PROPS];
extern LPOLESTR           gDevicePropNames[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS];
extern WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gPropSpecDefaults[NUM_CAM_ITEM_PROPS];
extern LONG               gPropVarDefaults[];
extern WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS];
extern WIA_DEV_CAP_DRV    gCapabilities[NUM_CAP_ENTRIES];
extern UINT               gCapabilityIDS[NUM_CAP_ENTRIES];
extern WCHAR             *gDefaultStrings[NUM_CAP_ENTRIES];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\resource.h ===
//--------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  resource.h
//
//  Resource constants for testing shell progress bar, this is the IR
//  animation.
//
//--------------------------------------------------------------------------

#define IDD_EVENT_DLG                   101
#define IDD_GEN_EVENT                   1000

#define IDC_COMBO1                      1001
#define IDC_EDIT1                       1002
#define IDC_STATIC                      -1

#define IDS_PROGRESS_TITLE              2001
#define IDS_CANCEL_MSG                  2002
#define IDS_DEVICE_CONNECTED            2003
#define IDS_DEVICE_DISCONNECTED         2004
#define IDS_NEW_PICTURE_SENT            2005
#define IDS_SYNCHRONIZE                 2006

#define IDR_TRANSFER_AVI                7001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\miniitem.cpp ===
//----------------------------------------------------------------------------
// Copyright (c) 1998, 1999  Microsoft Corporation.
//
//
//  miniitem.cpp
//
//  Implementation of the WIA IrTran-P camera item methods.
//
//  Author:  MarkE    30-Aug-98   Original TestCam version.
//
//           EdwardR  11-Aug-99   Rewritten for IrTran-P devices.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "ircamera.h"

#include "defprop.h"

extern HINSTANCE g_hInst;    // Global DLL hInstance

//----------------------------------------------------------------------------
//  ValidateDataTransferContext()
//
//    Validate the data transfer context. This is a helper function, called
//    by IrUsdDevice::drvAcquireItemData().
//
//  Parameters:
//
//    pDataTransferContext --
//
//  Return:
//
//    HRESULT    S_OK
//               E_INVALIDARG
//----------------------------------------------------------------------------
HRESULT ValidateDataTransferContext(
                IN MINIDRV_TRANSFER_CONTEXT *pDataTransferContext )
   {
   //
   // Check the context size:
   //
   if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT))
       {
       WIAS_ERROR((g_hInst,"ValidateDataTransferContext(): invalid data transfer context size"));
       return E_INVALIDARG;;
       }

   //
   // For tymed file or hglobal, only WiaImgFmt_JPEG is allowed:
   //
   if (  (pDataTransferContext->tymed == TYMED_FILE)
      || (pDataTransferContext->tymed == TYMED_HGLOBAL))
       {
       if (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG)
           {
           WIAS_ERROR((g_hInst,"ValidateDataTransferContext(): invalid format for TYMED_FILE"));
           return E_INVALIDARG;;
           }

       }

   //
   // For tymed CALLBACK, only WiaImgFmt_JPEG is allowed:
   //
   if (pDataTransferContext->tymed == TYMED_CALLBACK)
       {
       if (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG)
           {
           WIAS_ERROR((g_hInst,"ValidateDataTransferContext(): Invalid format for TYMED_CALLBACK"));
           return E_INVALIDARG;;
           }

       //
       // The callback is always double buffered, non-callback case
       // (TYMED_FILE) never is:
       //
       if (pDataTransferContext->pTransferBuffer == NULL)
           {
           WIAS_ERROR((g_hInst, "ValidateDataTransferContext(): Null transfer buffer"));
           return E_INVALIDARG;
           }
       }

   return S_OK;
}


//----------------------------------------------------------------------------
// SendBitmapHeader()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT   S_OK
//
//----------------------------------------------------------------------------
HRESULT SendBitmapHeader(
                  IN IWiaDrvItem              *pDrvItem,
                  IN MINIDRV_TRANSFER_CONTEXT *pTranCtx )
    {
    HRESULT hr;

    WIAS_ASSERT(g_hInst, pDrvItem != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx->tymed == TYMED_CALLBACK);

    //
    // driver is sending TOPDOWN data, must swap biHeight
    //
    // this routine assumes pTranCtx->pHeader points to a
    // BITMAPINFO header (TYMED_FILE doesn't use this path
    // and DIB is the only format supported now)
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pTranCtx->pTransferBuffer;

    if (pTranCtx->guidFormatID == WiaImgFmt_BMP)
        {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
        }

    hr = pTranCtx->
            pIWiaMiniDrvCallBack->
                MiniDrvCallback(
                    IT_MSG_DATA,
                    IT_STATUS_TRANSFER_TO_CLIENT,
                    0,
                    0,
                    pTranCtx->lHeaderSize,
                    pTranCtx,
                    0 );

    if (hr == S_OK)
        {
        //
        // advance offset for destination copy
        //
        pTranCtx->cbOffset += pTranCtx->lHeaderSize;
        }

    return hr;
}

//----------------------------------------------------------------------------
// IrUsdDevice::drvDeleteItem()
//
//   Try to delete a device item.
//
//   BUGBUG: Not yet implemented.
//
// Arguments:
//
//   pWiasContext - The context of the item to delete
//   lFlags       - unused
//   plDevErrVal  - unused
//
// Return Value:
//
//    HRESULT  - STG_E_ACCESSDENIED
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvDeleteItem(
                                 IN  BYTE *pWiasContext,
                                 IN  LONG  lFlags,
                                 OUT LONG *plDevErrVal )
    {
    HRESULT      hr = S_OK;
    IWiaDrvItem *pDrvItem = 0;
    IRCAM_IMAGE_CONTEXT *pContext = 0;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvDeleteItem()"));

    *plDevErrVal = 0;

    hr = wiasGetDrvItem( pWiasContext, &pDrvItem );
    if (FAILED(hr))
        {
        return hr;
        }

    hr = pDrvItem->GetDeviceSpecContext( (BYTE**)&pContext );
    if (FAILED(hr))
        {
        return hr;
        }

    hr = CamDeletePicture( pContext );

    return hr;
    }

//----------------------------------------------------------------------------
// IrUsdDevice::drvAcquireItemData()
//
//   Scan data into buffer. This routine scans the entire contents into
//   the destination buffer in one call. Status will be sent back if
//   the callback routine is provided
//
// Arguments:
//
//   pWiasContext    - Identifies what item we are working with.
//   lFlags          - unused
//   pTranCtx        - Buffer and callback information
//   plDevErrVal     - Return error value
//
// Return Value:
//
//   HRESULT   - S_OK
//               E_POINTER
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvAcquireItemData(
                                 IN  BYTE                     *pWiasContext,
                                 IN  LONG                      lFlags,
                                 IN  MINIDRV_TRANSFER_CONTEXT *pTranCtx,
                                 OUT LONG                     *plDevErrVal)
    {
    HRESULT  hr;

    *plDevErrVal = 0;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvAcquireItemData()"));

    //
    // Get a pointer to the associated driver item.
    //
    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

    if (FAILED(hr))
        {
        return hr;
        }

    //
    // Validate the data transfer context.
    //
    hr = ValidateDataTransferContext(pTranCtx);

    if (FAILED(hr))
        {
        return hr;
        }

    //
    // Get item specific driver data:
    //
    IRCAM_IMAGE_CONTEXT  *pMCamContext;

    pDrvItem->GetDeviceSpecContext((BYTE **)&pMCamContext);

    if (!pMCamContext)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::drvAcquireItemData(): NULL item context"));
        return E_POINTER;
        }

    //
    // Use WIA services to fetch format specific info.
    //
    hr = wiasGetImageInformation(pWiasContext,
                                 0,
                                 pTranCtx);

    if (hr != S_OK)
        {
        return hr;
        }

    //
    // Determine if this is a callback or buffered transfer
    //
    if (pTranCtx->tymed == TYMED_CALLBACK) {

        //
        // For formats that have a data header, send it to the client
        //

        if (pTranCtx->lHeaderSize > 0)
            {
            hr = SendBitmapHeader(
                     pDrvItem,
                     pTranCtx);
            }

        if (hr == S_OK)
            {
            hr = CamLoadPictureCB(
                     pMCamContext,
                     pTranCtx,
                     plDevErrVal);
            }
        }
    else
        {

        //
        // Offset past the header in the buffer and get the picture data:
        //
        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

        hr = CamLoadPicture(
                 pMCamContext,
                 pTranCtx,
                 plDevErrVal);

        }

    return hr;
    }

//----------------------------------------------------------------------------
// IrUsdDevice::drvInitItemProperties()
//
//   Initialize the device item properties.
//
// Arguments:
//
//   pWiasContext - Pointer to WIA item context.
//   lFLags       - unused
//   plDevErrVal  - pointer to hardware error value.
//
//
// Return Value:
//
//    HRESULT - S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvInitItemProperties(
                                 IN  BYTE *pWiasContext,
                                 IN  LONG  lFlags,
                                 OUT LONG *plDevErrVal )
    {
    HRESULT     hr;
    LONG        lItemType;
    IRCAM_IMAGE_CONTEXT *pContext;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvInitItemProperties()"));

    //
    // NOTE: This device doesn't touch hardware to initialize the
    // device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //
    if (!pWiasContext)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): invalid input pointers"));
        return E_INVALIDARG;
        }

    //
    // Get a pointer to the associated driver item:
    //
    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem( pWiasContext, &pDrvItem );

    if (FAILED(hr))
        {
        return hr;
        }

    //
    // The root item has the all the device properties
    //
    hr = pDrvItem->GetItemFlags(&lItemType);

    if (FAILED(hr))
        {
        return hr;
        }

    if (lItemType & WiaItemTypeRoot)
        {
        //
        // Root item property initialization finishes here:
        //
        return InitDeviceProperties( pWiasContext, plDevErrVal);
        }

    //
    // If this is a file, init the properties
    //
    if (lItemType & WiaItemTypeFile)
        {
        //
        // Add the item property names:
        //
        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_CAM_ITEM_PROPS,
                                  gItemPropIDs,
                                  gItemPropNames);

        if (FAILED(hr))
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): wiasSetItemPropNames() failed"));
            return hr;
            }

        //
        // Use WIA services to set default item properties:
        //
        hr = wiasWriteMultiple( pWiasContext,
                                NUM_CAM_ITEM_PROPS,
                                gPropSpecDefaults,
                                (PROPVARIANT*)gPropVarDefaults);

        if (FAILED(hr))
            {
            return hr;
            }

        hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        if (FAILED(hr))
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): GetDeviceSpecContext failed"));
            return hr;
            }

        hr = InitImageInformation(pWiasContext,
                                  pContext,
                                  plDevErrVal);

        if (FAILED(hr))
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): InitImageInformation() failed"));
            return hr;
            }
        }

    return S_OK;
}

//----------------------------------------------------------------------------
// IrUsdDevice::drvValidateItemProperties()
//
//   Validate the device item properties.
//
// Arguments:
//
//   pWiasContext    - wia item context
//   lFlags          - unused
//   nPropSpec       -
//   pPropSpec       -
//   plDevErrVal     - device error value
//
// Return Value:
//
//   HRESULT
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvValidateItemProperties(
                                 BYTE           *pWiasContext,
                                 LONG            lFlags,
                                 ULONG           nPropSpec,
                                 const PROPSPEC *pPropSpec,
                                 LONG           *plDevErrVal )
    {
    //
    // This device doesn't touch hardware to validate the device item properties
    //
    *plDevErrVal = 0;

    //
    // Parameter validation.
    //
    if (!pWiasContext || !pPropSpec)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::drvValidateItemProperties(): Invalid input pointers"));
        return E_POINTER;
        }

    //
    // validate size
    //
    HRESULT hr = S_OK;

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr))
        {
        return hr;
        }

    LONG lItemType;

    hr = pDrvItem->GetItemFlags(&lItemType);

    if (hr == S_OK)
        {
        if (lItemType & WiaItemTypeFile)
            {
            //
            // calc item size
            //

            hr = SetItemSize(pWiasContext);

            //
            //  Change MinBufferSize property.  Need to get Tymed and
            //  ItemSize first, since MinBufferSize in dependant on these
            //  properties.
            //

            LONG        lTymed;
            LONG        lItemSize;
            LONG        lMinBufSize = 0;
            HRESULT     hr = S_OK;

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_TYMED, &lTymed, NULL, TRUE);
            if (FAILED(hr))
                {
                WIAS_ERROR((g_hInst,"drvValidateItemProperties, could not read TYMED property"));
                return hr;
                }

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_ITEM_SIZE, &lItemSize, NULL, TRUE);
            if (SUCCEEDED(hr))
                {
                //
                //  Update the MinBufferSize property.
                //

                switch (lTymed)
                    {
                    case TYMED_CALLBACK:
                        lMinBufSize = 65535;
                        break;

                    default:
                        lMinBufSize = lItemSize;
                    }

                if (lMinBufSize)
                    {
                    hr = wiasWritePropLong(pWiasContext, WIA_IPA_MIN_BUFFER_SIZE, lMinBufSize);
                    if (FAILED(hr))
                        {
                        WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not write value for WIA_IPA_MIN_BUFFER_SIZE"));
                        }
                    }
                }
            else
                {
                WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not read value for ItemSize"));
                }

            }
        else if (lItemType & WiaItemTypeRoot)
            {
            //
            // Find out whether the Root Path property is changed
            //
#if FALSE
            for (ULONG i = 0; i < nPropSpec; i++)
                {

                if (((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                          (pPropSpec[i].propid == WIA_DPP_TCAM_ROOT_PATH)) ||
                    ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) &&
                          (wcscmp(pPropSpec[i].lpwstr, WIA_DPP_TCAM_ROOT_PATH_STR) == 0)))
                    {
                    BSTR   bstrRootPath;

                    //
                    // Retrieve the new value for Root Path property
                    //

                    hr = wiasReadPropStr(
                             pWiasContext,
                             WIA_DPP_TCAM_ROOT_PATH,
                             &bstrRootPath,
                             NULL,
                             TRUE);
                    if (FAILED(hr))
                        {
                        return hr;
                        }

#ifdef UNICODE
                    wcscpy(gpszPath, bstrRootPath);
#else
                    wcstombs(gpszPath, bstrRootPath, MAX_PATH);
#endif
                    //
                    // Release the Root Path bstr
                    //

                    SysFreeString(bstrRootPath);

                    //
                    // Rebuild the item tree and send event notification
                    //

                    hr = DeleteDeviceItemTree(plDevErrVal);
                    if (FAILED(hr))
                        {
                        break;
                        }

                    hr = BuildDeviceItemTree(plDevErrVal);
                    if (FAILED(hr))
                        {
                        break;
                        }

                    m_guidLastEvent = WIA_EVENT_DEVICE_CONNECTED;
                    SetEvent(m_hSignalEvent);

                    break;
                    }
                }
#endif
            }
        }

    return hr;
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.
*
* Arguments:
*
*   pWiasContext    - the corresponding wia item context
*   pmdtc           - pointer to mini driver context
*   pFlags          - unused
*   plDevErrVal     - the device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvWriteItemProperties(
    BYTE                       *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                       *plDevErrVal)
{
    //
    // Assume no device hardware errors.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if ((! pWiasContext) || (! pmdtc)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    HRESULT hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    IRCAM_IMAGE_CONTEXT *pItemContext;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, NULL item context"));
        return E_POINTER;
    }

    //
    // Write the device item properties to the hardware here.
    //

    return hr;
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvReadItemProperties
*
*   Read the device item properties from the hardware.
*
* Arguments:
*
*   pWiasContext    - wia item context
*   lFlags          - unused
*   nPropSpec       -
*   pPropSpec       -
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvReadItemProperties(
    BYTE            *pWiasContext,
    LONG                lFlags,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec,
    LONG                *plDevErrVal)
{
    // For most scanner devices, item properties are stored in the driver
    // and written out at acquire image time. Some devices support properties
    // which should be updated on every property read. This can be done here.


    *plDevErrVal = 0;

    return S_OK;
}


//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused,
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT IrUsdDevice::drvLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(100);
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT IrUsdDevice::drvUnLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvAnalyzeItem
*
*   The test camera does not support imag analysis.
*
* Arguments:
*
*   pWiasContext    - Pointer to the device item context to be analyzed.
*   lFlags          - Operation flags.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvAnalyzeItem(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *plDevErrVal)
{
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvFreeDrvItemContext
*
*   The test scanner does not support imag analysis.
*
* Arguments:
*
*   lFlags          - unused
*   pSpecContext    - Pointer to item specific context.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvFreeDrvItemContext(
                                 LONG   lFlags,
                                 BYTE  *pSpecContext,
                                 LONG  *plDevErrVal )
    {
    IRCAM_IMAGE_CONTEXT *pContext = (IRCAM_IMAGE_CONTEXT*)pSpecContext;

    if (pContext != NULL)
        {
        if (pContext->pszCameraImagePath != NULL)
            {
            free(pContext->pszCameraImagePath);
            pContext->pszCameraImagePath = NULL;
            }
        }

    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\progress.cpp ===
//--------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  progress.cpp
//
//  IR ProgressBar object.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <shlobj.h>
#include <malloc.h>
#include "ircamera.h"
#include "progress.h"


//--------------------------------------------------------------------------
// CIrProgress::CIrProgress()
//
//--------------------------------------------------------------------------
CIrProgress::CIrProgress() :
                 m_hInstance(NULL),
                 m_pPD(NULL)
    {
    }

//--------------------------------------------------------------------------
// CIrProgress::~CIrProgress()
//
//--------------------------------------------------------------------------
CIrProgress::~CIrProgress()
    {
    if (m_pPD)
        {
        m_pPD->Release();
        m_pPD = NULL;
        }
    }

//--------------------------------------------------------------------------
// CIrProgress::Initialize()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::Initialize( IN HINSTANCE hInstance,
                                 IN DWORD     dwIdrAnimationAvi )
    {
    HRESULT hr;
    CHAR    szStr[MAX_PATH];
    WCHAR   wszStr[MAX_PATH];


    if (!hInstance)
         {
         return E_INVALIDARG;
         }

    m_hInstance = hInstance;

    //
    // Create a shell progress object to do the work for us.
    //
    hr = CoCreateInstance( CLSID_ProgressDialog,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IProgressDialog,
                           (void**)&m_pPD );
    if (FAILED(hr))
        {
        return hr;
        }

    //
    // Get the title string and place it on the progress dialog:
    //
    if (::LoadStringResource(m_hInstance,
                           IDS_PROGRESS_TITLE,
                           wszStr,
                           MAX_PATH ))
        {
        hr = m_pPD->SetTitle(wszStr);
        }
    else
        {
        // Couldn't load string, default title...
        hr = m_pPD->SetTitle(L"Image Transfer Progress");
        }

    //
    // Setup the file transfer animation
    //
    hr = m_pPD->SetAnimation( m_hInstance, dwIdrAnimationAvi );
    if (FAILED(hr))
        {
        goto error;
        }

    //
    // Setup the cancel string (displayed when the cancel button
    // is pressed.
    //
    if (::LoadStringResource(m_hInstance,
                           IDS_CANCEL_MSG,
                           wszStr,
                           MAX_PATH ))
        {
        hr = m_pPD->SetCancelMsg( wszStr, NULL );
        }
    else
        {
        // Couldn't load string, use default cancel message...
        hr = m_pPD->SetCancelMsg( L"Cleaning up...", NULL );
        }

    return hr;

error:
    m_pPD->Release();
    m_pPD = NULL;
    m_hInstance = NULL;
    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::SetText()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::SetText( IN TCHAR *pText )
    {
    HRESULT hr = S_OK;

    if (m_pPD)
        {
        #ifdef UNICODE

        hr = m_pPD->SetLine( 1, pText, FALSE, NULL );

        #else

        WCHAR wszText[MAX_PATH];

        if (!MultiByteToWideChar( CP_ACP,
                                  0,
                                  pText,
                                  1+strlen(pText),
                                  wszText,
                                  MAX_PATH) )
            {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            return hr;
            }

        hr = m_pPD->SetLine( 1, wszText, FALSE, NULL );

        #endif
        }

    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::StartProgressDialog()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::StartProgressDialog()
    {
    HRESULT  hr = S_OK;

    if (m_pPD)
        {
        DWORD dwFlags = PROGDLG_NORMAL|PROGDLG_AUTOTIME|PROGDLG_NOMINIMIZE;

        HRESULT hr = m_pPD->StartProgressDialog( NULL, // hwndParent
                                                 NULL, 
                                                 dwFlags,
                                                 NULL  );
        }

    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::UpdateProgressDialog()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::UpdateProgressDialog( IN DWORD dwCompleted,
                                           IN DWORD dwTotal )
    {
    HRESULT hr = S_OK;

    if (m_pPD)
        {
        hr = m_pPD->SetProgress( dwCompleted, dwTotal );
        }

    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::HasUserCancelled()
//
//--------------------------------------------------------------------------
BOOL CIrProgress::HasUserCancelled()
    {
    if (m_pPD)
        {
        return m_pPD->HasUserCancelled();
        }
    else
        {
        return S_OK;
        }
    }

//--------------------------------------------------------------------------
// CIrProgress::EndProgressDialog()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::EndProgressDialog()
    {
    HRESULT hr = S_OK;

    if (m_pPD)
        {
        hr = m_pPD->StopProgressDialog();
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\progress.h ===
//--------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  progress.h
//
//  IR ProgressBar object. Use the shell progress indicator for progress
//  during image transfer from the camera.
//
//--------------------------------------------------------------------------


#include "resource.h"


class CIrProgress
{
public:
    CIrProgress(VOID);
    ~CIrProgress(VOID);

    HRESULT Initialize( IN HINSTANCE hInstance,
                        IN DWORD     dwIdrAnimationAvi );

    HRESULT SetText( IN TCHAR *pText );

    HRESULT StartProgressDialog(VOID);

    HRESULT UpdateProgressDialog( IN DWORD dwCompleted,
                                  IN DWORD dwTotal );

    BOOL    HasUserCancelled(VOID);

    HRESULT EndProgressDialog(VOID);
                      

private:

    HINSTANCE        m_hInstance;
    IProgressDialog *m_pPD;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\jpegutil.cpp ===
/***********************************************************************
 *
 * JPEG decompression utility functions
 *
 *   Implement (1) JPEG memory data source
 *             (2) JPEG error manager using setjmp/longjmp
 *
 *   Author : Indy Zhu    [indyz]
 *   Date   : 5/20/98
 *  
 ***********************************************************************/

#include  <stdio.h>
// #include  <stdlib.h>
#include  <setjmp.h>

// Workaround for redefinition of INT32
#define   XMD_H  1

extern "C"
{
// Header file for JPEG library
#include  "jpeglib.h"
}

#include  <windows.h>
#include  "jpegutil.h"

//
// Buf source manager definition
//

typedef struct _buf_source_mgr
{
    struct jpeg_source_mgr  pub;
    
    // Fields specific to buf_source_mgr
    LPBYTE                  pJPEGBlob;
    DWORD                   dwSize;   
} buf_source_mgr;

//
// Jump error manager definition
//

typedef struct _jmp_error_mgr
{
    struct jpeg_error_mgr  pub;

    // Private fields for jump error manager
    jmp_buf                stackContext;
} jmp_error_mgr;

/******************************************************************************\
*
* init_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void    init_source(j_decompress_ptr pDecompInfo)
{
    // No working necessary here
}

/******************************************************************************\
*
* fill_input_buffer()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static boolean fill_input_buffer(j_decompress_ptr pDecompInfo)
{
    buf_source_mgr  *pBufSrcMgr;

    // Recover buf source manager itself
    pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;

    // buf_source_mgr can only fire one shot    
    pBufSrcMgr->pub.next_input_byte = pBufSrcMgr->pJPEGBlob;
    pBufSrcMgr->pub.bytes_in_buffer = pBufSrcMgr->dwSize;
  
    return(TRUE);
}

/******************************************************************************\
*
* skip_input_data()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void    skip_input_data(j_decompress_ptr pDecompInfo, long lBytes)
{
    buf_source_mgr  *pBufSrcMgr;

    // For buf source manager, it is very easy to implement
    if (lBytes > 0) {

        pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;
    
        pBufSrcMgr->pub.next_input_byte += lBytes;
        pBufSrcMgr->pub.bytes_in_buffer -= lBytes;
    }
}

/******************************************************************************\
*
* term_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void    term_source(j_decompress_ptr pDecompInfo)
{
}

/******************************************************************************\
*
* jpeg_buf_src()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void jpeg_buf_src(j_decompress_ptr pDecompInfo, 
                         LPBYTE pJPEGBlob, DWORD dwSize)
{
    buf_source_mgr  *pBufSrcMgr;

    // Allocate memory for the buf source manager
    pBufSrcMgr = (buf_source_mgr *)
        (pDecompInfo->mem->alloc_small)((j_common_ptr)pDecompInfo, 
                                       JPOOL_PERMANENT, 
                                       sizeof(buf_source_mgr));
    // Record the pJPEGBlob
    pBufSrcMgr->pJPEGBlob = pJPEGBlob;
    pBufSrcMgr->dwSize    = dwSize;

    // Fill in the function pointers
    pBufSrcMgr->pub.init_source = init_source;
    pBufSrcMgr->pub.fill_input_buffer = fill_input_buffer;
    pBufSrcMgr->pub.skip_input_data = skip_input_data;
    pBufSrcMgr->pub.resync_to_restart = jpeg_resync_to_restart;
    pBufSrcMgr->pub.term_source = term_source;

    // Initialize the pointer into the buffer
    pBufSrcMgr->pub.bytes_in_buffer = 0;
    pBufSrcMgr->pub.next_input_byte = NULL;

    // Ask the decompression context to remember it
    pDecompInfo->src = (struct jpeg_source_mgr *)pBufSrcMgr;
}

/******************************************************************************\
*
* jmp_error_exit()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void  jmp_error_exit(j_common_ptr pDecompInfo)
{
    jmp_error_mgr  *pJmpErrorMgr;

    // Get the jump error manager back
    pJmpErrorMgr = (jmp_error_mgr *)pDecompInfo->err;

    // Display the error message
#ifdef _DEBUG
    (pDecompInfo->err->output_message)(pDecompInfo);
#endif

    // Recover the original stack
    longjmp(pJmpErrorMgr->stackContext, 1);
}

/******************************************************************************\
*
* jpeg_jmp_error()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

struct jpeg_error_mgr *jpeg_jmp_error(jmp_error_mgr *pJmpErrorMgr)
{
    // Initialize the public part
    jpeg_std_error(&pJmpErrorMgr->pub);

    // Set up jump error manager exit method
    pJmpErrorMgr->pub.error_exit = jmp_error_exit;

    return((jpeg_error_mgr *)pJmpErrorMgr);
}

/******************************************************************************\
*
* GetJPEGDimensions()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

int GetJPEGDimensions(LPBYTE pJPEGBlob, DWORD dwSize,
                      LONG   *pWidth, LONG *pHeight, WORD *pChannel)
{
    int                            ret;
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    ret = jpeg_read_header(&decompInfo, TRUE);

    // Release the decompression context
    jpeg_destroy_decompress(&decompInfo);

    // Fill in the dimension info for the caller
    *pWidth   = decompInfo.image_width;
    *pHeight  = decompInfo.image_height;
    *pChannel = decompInfo.num_components;

    if (ret != JPEG_HEADER_OK) {
        return(JPEGERR_INTERNAL_ERROR);
    }

    return(JPEGERR_NO_ERROR);
}

/******************************************************************************\
*
* DecompProgressJPEG()
*
* Arguments:
*
* Assumption : The JPEG  is 24bits.
*              pDIBPixel is the pixel buffer of a DIB
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

short __stdcall 
DecompProgressJPEG(
    LPBYTE                         pJPEGBlob, 
    DWORD                          dwSize, 
    LPBYTE                         pDIBPixel, 
    DWORD                          dwBytesPerScanLine,
    JPEGCallbackProc               pProgressCB, 
    PVOID                          pCBContext)
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    LPBYTE                         pCurScanBuf;
    JSAMPLE                        sampleTemp;
    LPBYTE                         pCurPixel;
    DWORD                          i;
    //
    // Callback related variables
    //
    ULONG                          ulImageSize;
    ULONG                          ulOffset;
    ULONG                          ulNewScanlines;
    ULONG                          ulCBInterval;
    BOOL                           bRet = FALSE;

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK) {

        jpeg_destroy_decompress(&decompInfo);
        return(JPEGERR_INTERNAL_ERROR);
    }
    
    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion

    // Step 5 : Start the real action
    jpeg_start_decompress(&decompInfo);

    //
    // Prepare for the final decompression
    //

    pCurScanBuf = pDIBPixel + 
                  (decompInfo.image_height - 1) * dwBytesPerScanLine;
    if (pProgressCB) {

        ulImageSize    = decompInfo.image_height * dwBytesPerScanLine;
        ulCBInterval   = decompInfo.image_height / 10;
        ulOffset       = 0;
        ulNewScanlines = 0;
    }

    // Step 6 : Acquire the scan line
    while (decompInfo.output_scanline < decompInfo.output_height) {

        jpeg_read_scanlines(&decompInfo, &pCurScanBuf, 1);

        // Famous swapping for the unique format of Windows
        pCurPixel = pCurScanBuf;
        for (i = 0; i < decompInfo.image_width; 
             i++, pCurPixel += decompInfo.num_components) {

            sampleTemp = *pCurPixel;
            *pCurPixel = *(pCurPixel + 2);
            *(pCurPixel + 2) = sampleTemp;
        }
        
        pCurScanBuf -= dwBytesPerScanLine;

        //
        // Fire the callback when possible and necessary
        //

        if (pProgressCB) {

            ulNewScanlines++;
            ulOffset += dwBytesPerScanLine;

            if ((ulNewScanlines == ulCBInterval) || 
                (decompInfo.output_scanline == decompInfo.output_height)) {

                bRet = pProgressCB(
                           ulImageSize, ulNewScanlines,
                           ulNewScanlines * dwBytesPerScanLine,
                           pDIBPixel, pCBContext);

                if (! bRet) {
                    break;
                }
            }
        }
    }

    // Step 7 : Finish the job
    jpeg_finish_decompress(&decompInfo);

    // Step 8 : Garbage collection
    jpeg_destroy_decompress(&decompInfo);

    if (bRet) {
        return(JPEGERR_NO_ERROR);
    } else {
        return(JPEGERR_CALLBACK_ERROR);
    }
}

/******************************************************************************\
*
* DecompTransferJPEG()
*
* Arguments:
*
*     ppDIBPixel - *ppDIBPixel will change between callback if multiple buffer is
*                  used, but dwBufSize is assumed to be constant.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/1999 Original Version
*
\******************************************************************************/

short __stdcall
DecompTransferJPEG(
    LPBYTE                         pJPEGBlob,
    DWORD                          dwSize,
    LPBYTE                        *ppDIBPixel,
    DWORD                          dwBufSize,
    DWORD                          dwBytesPerScanLine,
    JPEGCallbackProc               pProgressCB,
    PVOID                          pCBContext)
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    LPBYTE                         pCurScanLine;
    JSAMPLE                        sampleTemp;
    LPBYTE                         pCurPixel;
    DWORD                          i;
    //
    // Callback related variables
    //
    ULONG                          ulImageSize;
    ULONG                          ulOffset = 0;
    ULONG                          ulBufferLeft;
    BOOL                           bRet = FALSE;

    //
    // Parameter checking
    //

    if ((! ppDIBPixel) || (! *ppDIBPixel) || (! pProgressCB)) {
        return (JPEGERR_INTERNAL_ERROR);
    }

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK) {

        jpeg_destroy_decompress(&decompInfo);
        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion

    // Step 5 : Start the real action
    jpeg_start_decompress(&decompInfo);

    //
    // Prepare for the final decompression
    //

    ulImageSize  = decompInfo.image_height * dwBytesPerScanLine;
    ulBufferLeft = dwBufSize;
    pCurScanLine = *ppDIBPixel;

    // Step 6 : Acquire the scan line
    while (decompInfo.output_scanline < decompInfo.output_height) {

        jpeg_read_scanlines(&decompInfo, &pCurScanLine, 1);

        // Famous swapping for the unique format of Windows
        pCurPixel = pCurScanLine;
        for (i = 0; i < decompInfo.image_width;
             i++, pCurPixel += decompInfo.num_components) {

            sampleTemp = *pCurPixel;
            *pCurPixel = *(pCurPixel + 2);
            *(pCurPixel + 2) = sampleTemp;
        }

        pCurScanLine += dwBytesPerScanLine;
        ulBufferLeft -= dwBytesPerScanLine;

        //
        // Fire the callback when possible and necessary
        //

        if ((ulBufferLeft < dwBytesPerScanLine) ||
            (decompInfo.output_scanline == decompInfo.output_height)) {

            bRet = pProgressCB(
                       ulImageSize, 
                       ulOffset,
                       dwBufSize - ulBufferLeft,
                       *ppDIBPixel, pCBContext);

            if (! bRet) {
                break;
            }

            //
            // Reset the buffer, which may have been switched by the callback 
            //

            ulBufferLeft = dwBufSize;
            pCurScanLine = *ppDIBPixel;

            ulOffset = decompInfo.output_scanline * dwBytesPerScanLine;
        }
    }

    // Step 7 : Finish the job
    jpeg_finish_decompress(&decompInfo);

    // Step 8 : Garbage collection
    jpeg_destroy_decompress(&decompInfo);

    if (bRet) {
        return(JPEGERR_NO_ERROR);
    } else {
        return(JPEGERR_CALLBACK_ERROR);
    }
}

/******************************************************************************\
*
* DecompJPEG()
*
* Arguments:
*
* Assumption : The JPEG  is 24bits.
*              pDIBPixel is the pixel buffer of a DIB
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

SHORT __stdcall
DecompJPEG(
    LPBYTE                         pJPEGBlob, 
    DWORD                          dwSize,
    LPBYTE                         pDIBPixel, 
    DWORD                          dwBytesPerScanLine)
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    LPBYTE                         pCurScanBuf;
    JSAMPLE                        sampleTemp;
    LPBYTE                         pCurPixel;
    DWORD                          i;

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(-1);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK) {

        jpeg_destroy_decompress(&decompInfo);
        return(-1);
    }

    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion

    // Step 5 : Start the real action
    jpeg_start_decompress(&decompInfo);

    pCurScanBuf = pDIBPixel +
                  (decompInfo.image_height - 1) * dwBytesPerScanLine;
    // Step 6 : Acquire the scan line
    while (decompInfo.output_scanline < decompInfo.output_height) {

        jpeg_read_scanlines(&decompInfo, &pCurScanBuf, 1);

        // Famous swapping for the unique format of Windows
        pCurPixel = pCurScanBuf;
        for (i = 0; i < decompInfo.image_width;
             i++, pCurPixel += decompInfo.num_components) {

            sampleTemp = *pCurPixel;
            *pCurPixel = *(pCurPixel + 2);
            *(pCurPixel + 2) = sampleTemp;
        }

        pCurScanBuf -= dwBytesPerScanLine;
    }

    // Step 7 : Finish the job
    jpeg_finish_decompress(&decompInfo);

    // Step 8 : Garbage collection
    jpeg_destroy_decompress(&decompInfo);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\jpegutil.h ===
#include  <wtypes.h>

 
//
// JPEG erro code
//
 
#define JPEGERR_NO_ERROR         0
#define JPEGERR_INTERNAL_ERROR  -1
#define JPEGERR_CALLBACK_ERROR  -2

//
// Prototype for JPEG callback
//

typedef BOOL (__stdcall *JPEGCallbackProc)(
    ULONG,                  // Total byte to download
    ULONG,                  // Bytes downloaded so far
    ULONG,                  // Bytes newly downloaded
    PBYTE,                  // Buffer containing the image data
    PVOID);                 // User supplied context

//
// Prototype for JPEG utility functions
//

int GetJPEGDimensions(LPBYTE pJPEGBlob, DWORD dwSize,
                      LONG   *pWidth, LONG *pHeight, WORD *pChannel);

SHORT __stdcall
DecompProgressJPEG(
    PBYTE,                  // Buffer containing the JPEG data
    ULONG,                  // Size of the JPEG buffer
    PBYTE,                  // Buffer to receive DIB data
    ULONG,                  // Scanline picth
    JPEGCallbackProc,       // Progress callback
    PVOID);                 // User supplied callback context

SHORT __stdcall
DecompTransferJPEG(
    PBYTE,                  // Buffer containing the JPEG data
    ULONG,                  // Size of the JPEG buffer
    PBYTE *,                // POINTER to the buffer to receive DIB data
    DWORD,                  // Size of the DIB buffer
    ULONG,                  // Scanline picth
    JPEGCallbackProc,       // Progress callback
    PVOID);                 // User supplied callback context

SHORT __stdcall
DecompJPEG(
    LPBYTE,                 // Buffer containing the JPEG data
    DWORD,                  // Size of the JPEG buffer
    LPBYTE,                 // Buffer to receive DIB data
    DWORD);                 // Scanline picth
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\sources.inc ===
#-----------------------------------------------------------------
#  Copyright (c) 1999  Microsoft Corporation
#
#  Author:
#     EdwardR
#
#  Date:
#     22-Jul-1999
#
#  Module Name:
#     sources.inc
#
#  Abstract:
#    The build sources file for the IrTran-P USD.
#
#  This directory builds
#    IrTran-P USD
#
#-----------------------------------------------------------------

!include $(IMAGE_DIR)\wiaenv.inc

TARGETNAME=ircamera
TARGETTYPE=DYNLINK
TARGETPATH=obj
TARGETEXT=dll

DLLDEF = $O\ircamera.def
DLLENTRY=DllEntryPoint

# SYNCHRONIZE_DRAIN=1

#
# Set calling convention to __cdecl
#

386_STDCALL=0

INCLUDES=.;..\irtranp;$(INCLUES);$(IMAGE_DIR)\inc;$(IMAGE_DIR)\common\jpeglib

C_DEFINES=$(C_DEFINES) -DHAVE_BOOLEAN

SOURCES=            \
    ..\camevent.cpp \
    ..\camopen.cpp  \
    ..\camxfer.cpp  \
    ..\device.cpp   \
    ..\miniitem.cpp \
    ..\ircamera.cpp \
    ..\wiadev.cpp   \
    ..\jpegutil.cpp \
    ..\progress.cpp \
    ..\ircamera.rc

TARGETLIBS= $(TARGETLIBS) \
        $(BASEDIR)\public\sdk\lib\*\kernel32.lib           \
        $(BASEDIR)\public\sdk\lib\*\wsock32.lib            \
        $(BASEDIR)\public\sdk\lib\*\shell32.lib            \
        $(IMAGE_DIR)\lib\$(PLATFORM_SUFFIX)\*\wiaguid.lib  \
        $(IMAGE_DIR)\lib\$(PLATFORM_SUFFIX)\*\wiaservc.lib \
        $(IMAGE_DIR)\lib\$(PLATFORM_SUFFIX)\*\jpeg.lib     \
        ..\irtranp\i386\irtranp.lib


#       $(LIBRARY_PATH)\sti.lib                            \
#       $(BASEDIR)\public\sdk\lib\*\ole32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\tcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TCamProp.H
*
*  VERSION:     1.0
*
*  AUTHOR:      IndyZ
*
*  DATE:        16 May, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for test camera's private properties.
*
*******************************************************************************/

#ifndef __TCAMPROP_H__
#define __TCAMPROP_H__

#include  <guiddef.h>

//
// Path where test camera builds its item tree, BSTR & RW
//

#define  WIA_DPP_TCAM_ROOT_PATH         WIA_PRIVATE_DEVPROP
#define  WIA_DPP_TCAM_ROOT_PATH_STR     L"Test Camera Root Path"

//
// Private event after the Root Path is changed
//

const GUID WIA_EVENT_NAME_CHANGE =
{ /* 88f80f75-af08-11d2-a094-00c04f72dc3c */
    0x88f80f75,
    0xaf08,
    0x11d2,
    {0xa0, 0x94, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\version.h ===
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "IrTran-P Windows Image Acquisition USD"
#define VER_INTERNALNAME_STR            "ircamera"
#define VER_LEGALCOPYRIGHT_YEARS        "1999"
#define VER_ORIGINALFILENAME_STR        "ircamera.dll"

#include <ntverp.h>
#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\wiadev.cpp ===
//------------------------------------------------------------------------------
//  (C) COPYRIGHT MICROSOFT CORP., 1998
//
//  wiadev.cpp
//
//  Implementation of device methods for the IrTran-P USD mini driver.
//
//  Author
//     EdwardR     05-Aug-99    Initial code.
//     Modeled after code written by ReedB.
//
//------------------------------------------------------------------------------

#define __FORMATS_AND_MEDIA_TYPES__

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "ircamera.h"
#include "defprop.h"
#include "resource.h"
#include <irthread.h>
#include <malloc.h>

extern HINSTANCE        g_hInst;     // Global hInstance
extern WIA_FORMAT_INFO *g_wfiTable;

//----------------------------------------------------------------------------
// IrUsdDevice::InitializWia()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT  S_OK
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvInitializeWia(
                                 BYTE         *pWiasContext,
                                 LONG          lFlags,
                                 BSTR          bstrDeviceID,
                                 BSTR          bstrRootFullItemName,
                                 IUnknown     *pStiDevice,
                                 IUnknown     *pIUnknownOuter,
                                 IWiaDrvItem **ppIDrvItemRoot,
                                 IUnknown    **ppIUnknownInner,
                                 LONG         *plDevErrVal )
    {
    HRESULT              hr;
    LONG                 lDevErrVal;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvInitializeWia(): Device ID: %ws", bstrDeviceID));

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;
    *plDevErrVal = 0;

    //
    // Initialize names and STI pointer?
    //
    if (m_pStiDevice == NULL)
        {
        //
        // save STI device inteface for locking:
        //
        m_pStiDevice = (IStiDevice*)pStiDevice;

        //
        // Cache the device ID:
        //
        m_bstrDeviceID = SysAllocString(bstrDeviceID);
        if (! m_bstrDeviceID)
            {
            return E_OUTOFMEMORY;
            }

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (! m_bstrRootFullItemName)
            {
            return E_OUTOFMEMORY;
            }
        }

    //
    // Build the device item tree
    //
    hr = drvDeviceCommand( NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal );

    if (SUCCEEDED(hr))
        {
        *ppIDrvItemRoot = m_pIDrvItemRoot;
        }

    return hr;
    }


//----------------------------------------------------------------------------
// IrUsdDevice::drvUnInitializeWia
//
//   Gets called when a client connection is going away.
//
// Arguments:
//
//   pWiasContext    - Pointer to the WIA Root item context of the client's
//                     item tree.
//
// Return Value:
//    Status
//
// History:
//
//   30/12/1999 Original Version
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


//----------------------------------------------------------------------------
//
//   Mini Driver Device Services
//
//----------------------------------------------------------------------------



/**************************************************************************\
* drvGetDeviceErrorStr
*
*     Map a device error value to a string.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall IrUsdDevice::drvGetDeviceErrorStr(
    LONG        lFlags,
    LONG        lDevErrVal,
    LPOLESTR    *ppszDevErrStr,
    LONG        *plDevErr)
{
    *plDevErr = 0;
    if (!ppszDevErrStr) {
        WIAS_ERROR((g_hInst,"drvGetDeviceErrorStr, NULL ppszDevErrStr"));
        return E_POINTER;
    }

    // Map device errors to a string to be placed in the event log.
    switch (lDevErrVal) {

        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            return E_FAIL;
    }
    return S_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::DeleteDeviceItemTree()
//
//   Recursive device item tree delete routine. Deletes the whole tree.
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::DeleteDeviceItemTree( OUT LONG *plDevErrVal )
    {
    HRESULT hr;

    //
    // does tree exist
    //
    if (m_pIDrvItemRoot == NULL)
        {
        return S_OK;
        }

    //
    // Unlink and release the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    m_pIDrvItemRoot = NULL;

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::BuildDeviceItemTree()
//
//   The device uses the IWiaDrvServices methods to build up a tree of
//   device items. The test scanner supports only a single scanning item so
//   build a device item tree with one entry.
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::BuildDeviceItemTree( OUT LONG  *plDevErrVal )
    {
    HRESULT hr = S_OK;

    //
    // Note: This device doesn't touch hardware to build the tree.
    //

    if (plDevErrVal)
        {
        *plDevErrVal = 0;
        }

    //
    // Rebuild the new device item tree (of JPEG images):
    //
    CAMERA_STATUS camStatus;

    if (!m_pIDrvItemRoot)
        {
        hr = CamBuildImageTree( &camStatus, &m_pIDrvItemRoot );
        }

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::InitDeviceProperties()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT  -- S_OK
//                E_POINTER
//                E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::InitDeviceProperties(
                         BYTE  *pWiasContext,
                         LONG  *plDevErrVal )
    {
    int         i;
    HRESULT     hr;
    BSTR        bstrFirmwreVer;
    SYSTEMTIME  camTime;
    PROPVARIANT propVar;

    //
    // This device doesn't actually touch any hardware to initialize
    // the device properties.
    //
    if (plDevErrVal)
        {
        *plDevErrVal = 0;
        }

    //
    // Parameter validation.
    //
    if (!pWiasContext)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::InitDeviceProperties(): NULL WIAS context"));
        return E_POINTER;
        }

    //
    // Write standard property names
    //
    hr = wiasSetItemPropNames(pWiasContext,
                              sizeof(gDevicePropIDs)/sizeof(PROPID),
                              gDevicePropIDs,
                              gDevicePropNames);
    if (FAILED(hr))
        {
        WIAS_TRACE((g_hInst,"IrUsdDevice::InitDeviceProperties(): WritePropertyNames() failed: 0x%x",hr));
        return hr;
        }

    //
    // Write the properties supported by all WIA devices
    //
    bstrFirmwreVer = SysAllocString(L"02161999");
    if (bstrFirmwreVer)
        {
        wiasWritePropStr( pWiasContext,
                          WIA_DPA_FIRMWARE_VERSION,
                          bstrFirmwreVer );
        SysFreeString(bstrFirmwreVer);
        }

    wiasWritePropLong( pWiasContext, WIA_DPA_CONNECT_STATUS, 1);

    wiasWritePropLong( pWiasContext, WIA_DPC_PICTURES_TAKEN, 0);

    GetSystemTime(&camTime);
    wiasWritePropBin( pWiasContext,
                      WIA_DPA_DEVICE_TIME,
                      sizeof(SYSTEMTIME),
                      (PBYTE)&camTime );

    //
    // Write the camera properties, just default values, it may vary with items
    //

    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICTURES_REMAINING, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_WIDTH, 80);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_HEIGHT, 60);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_WIDTH, 1024);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_HEIGHT, 768);

    // Give WIA_DPC_EXPOSURE_MODE to WIA_DPC_TIMER_VALUE some default.

    wiasWritePropLong(
        pWiasContext, WIA_DPC_EXPOSURE_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FLASH_MODE, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FOCUS_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_ZOOM_POSITION, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_BATTERY_STATUS, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_VALUE, 0);

    //
    // Write the WIA_DPP_TCAM_ROOT_PATH property
    //

    BSTR    bstrRootPath;
    CHAR   *pszPath = ::GetImageDirectory();   // Don't try to free...
    WCHAR   wszPath[MAX_PATH];

    if (!pszPath)
        {
        return E_OUTOFMEMORY;
        }

    mbstowcs( wszPath, pszPath, strlen(pszPath) );

    bstrRootPath = SysAllocString(wszPath);

    if (! bstrRootPath)
        {
        return E_OUTOFMEMORY;
        }

    wiasWritePropStr(pWiasContext, WIA_DPP_TCAM_ROOT_PATH, bstrRootPath);

    //
    // Use WIA services to set the property access and
    // valid value information from gDevPropInfoDefaults.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_DEV_PROPS,
                                 gDevicePropSpecDefaults,
                                 gDevPropInfoDefaults);
    return S_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::drvDeviceCommand()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT   S_OK
//              E_NOTIMPL
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvDeviceCommand(
                                 BYTE         *pWiasContext,
                                 LONG          lFlags,
                                 const GUID   *plCommand,
                                 IWiaDrvItem **ppWiaDrvItem,
                                 LONG         *plErr)
    {
    HRESULT hr;

    //
    // init return value
    //
    if (ppWiaDrvItem != NULL)
        {
        *ppWiaDrvItem = NULL;
        }

    //
    // dispatch command
    //
    if (*plCommand == WIA_CMD_SYNCHRONIZE)
        {
        WIAS_TRACE((g_hInst,"IrUsdDevice::drvDeviceCommand(): WIA_CMD_SYNCHRONIZE"));

        hr = drvLockWiaDevice(pWiasContext, lFlags, plErr);
        if (FAILED(hr))
            {
            return (hr);
            }

        //
        // SYNCHRONIZE - make sure tree is up to date with device
        //
        // The dirver's responsibility is to make sure the tree is accurate.
        //

        hr = BuildDeviceItemTree(plErr);

        drvUnLockWiaDevice( pWiasContext, lFlags, plErr );
        }
    else
        {
        WIAS_TRACE((g_hInst,"drvDeviceCommand: Unsupported command"));

        hr = E_NOTIMPL;
        }

    return hr;
}

//--------------------------------------------------------------------------
// LoadStringResource()
//
//
//--------------------------------------------------------------------------
int LoadStringResource( IN  HINSTANCE hInst,
                        IN  UINT      uID,
                        OUT WCHAR    *pwszBuff,
                        IN  int       iBuffMax )
    {
    #ifdef UNICODE
    return LoadString(hInst,uID,pwszBuff,iBuffMax);
    #else
    CHAR *pszBuff = (CHAR*)_alloca(sizeof(CHAR)*iBuffMax);

    int  iCount = LoadString(hInst,uID,pszBuff,iBuffMax);

    if (iCount > 0)
        {
        MultiByteToWideChar( CP_ACP, 0, pszBuff, -1, pwszBuff, iBuffMax );
        }

    return iCount;

    #endif
    }

//--------------------------------------------------------------------------
// IrUsdDevice::InitializeCapabilities()
//
// This helper function is called by IrUsdDevice::drvGetCapabilities() to
// make sure that the string resources are setup in the gCapabilities[]
// array before it is passed back to WIA.
//
//--------------------------------------------------------------------------
void IrUsdDevice::InitializeCapabilities()
    {
    int    i;
    UINT   uIDS;
    WCHAR *pwszName;
    WCHAR *pwszDescription;
#   define MAX_IDS_WSTR      64

    //
    // If we have entries already, then this function was already called
    // and  we can just return:
    //
    if (gCapabilities[0].wszName)
        {
        return;
        }

    for (i=0; i<NUM_CAP_ENTRIES; i++)
        {
        //
        // Get the string table string ID for this entry:
        //
        uIDS = gCapabilityIDS[i];

        //
        // Get the name string for this entry fron the resource file:
        //
        pwszName = new WCHAR [MAX_IDS_WSTR];
        if (  (pwszName)
           && (LoadStringResource(g_hInst,uIDS,pwszName,MAX_IDS_WSTR)))
            {
            gCapabilities[i].wszName = pwszName;
            }
        else
            {
            gCapabilities[i].wszName = gDefaultStrings[i];
            }

        //
        // Get the Discription string for this entry from the resource file:
        //
        pwszDescription = new WCHAR [MAX_IDS_WSTR];
        if (  (pwszDescription)
           && (LoadStringResource(g_hInst,uIDS,pwszDescription,MAX_IDS_WSTR)))
            {
            gCapabilities[i].wszDescription = pwszDescription;
            }
        else
            {
            gCapabilities[i].wszDescription = gDefaultStrings[i];
            }
        }
    }

//--------------------------------------------------------------------------
// IrUsdDevice::drvGetCapabilities()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT   -- S_OK
//              -- E_INVALIDARG
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvGetCapabilities(
                                 BYTE             *pWiasContext,
                                 LONG              ulFlags,
                                 LONG             *pCelt,
                                 WIA_DEV_CAP_DRV **ppCapabilities,
                                 LONG             *plDevErrVal )
    {
    HRESULT  hr = S_OK;

    *plDevErrVal = 0;

    //
    // Make sure the device capabilities array is setup
    //
    InitializeCapabilities();

    //
    // Return Commmand and/or Events depending on flags:
    //
    switch (ulFlags)
        {
        case WIA_DEVICE_COMMANDS:
            //
            //  Only asked for commands:
            //
            *pCelt = NUM_CAP_ENTRIES - NUM_EVENTS;
            *ppCapabilities = &gCapabilities[NUM_EVENTS];
            break;

        case WIA_DEVICE_EVENTS:
            //
            //  Return only events:
            //
            *pCelt = NUM_EVENTS;
            *ppCapabilities = gCapabilities;
            break;

        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):
            //
            //  Return both events and commands:
            //
            *pCelt = NUM_CAP_ENTRIES;
            *ppCapabilities = gCapabilities;
            break;

        default:
            //
            // Flags is invalid
            //
            WIAS_ERROR((g_hInst, "drvGetCapabilities, flags was invalid"));
            hr = E_INVALIDARG;
        }

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::drvGetFormatEtc()
//
//     Return an array of the supported formats and mediatypes.
//
// Arguments:
//
//     pWiasConext -
//     ulFlags     -
//     plNumFE     - Number of returned formats.
//     ppFE        - Pointer to array of FORMATETC for supported formats
//                   and mediatypes.
//     plDevErrVal - Return error number.
//
// Return Value:
//
//     HRESULT  - S_OK
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvGetWiaFormatInfo(
                                 IN  BYTE       *pWiasContext,
                                 IN  LONG        ulFlags,
                                 OUT LONG       *plNumWFI,
                                 OUT WIA_FORMAT_INFO **ppWFI,
                                 OUT LONG       *plDevErrVal)
    {
    #define NUM_WIA_FORMAT_INFO  2

    WIAS_TRACE((g_hInst, "IrUsdDevice::drvGetWiaFormatInfo()"));

    //
    // If necessary, setup the g_wfiTable.
    //
    if (!g_wfiTable)
        {
        g_wfiTable = (WIA_FORMAT_INFO*) CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * NUM_WIA_FORMAT_INFO);
        if (!g_wfiTable)
            {
            WIAS_ERROR((g_hInst, "drvGetWiaFormatInfo(): out of memory"));
            return E_OUTOFMEMORY;
            }

        //
        // Set the format/tymed pairs:
        //
        g_wfiTable[0].guidFormatID = WiaImgFmt_JPEG;
        g_wfiTable[0].lTymed = TYMED_CALLBACK;
        g_wfiTable[1].guidFormatID = WiaImgFmt_JPEG;
        g_wfiTable[1].lTymed = TYMED_FILE;
        }

    *plNumWFI = NUM_WIA_FORMAT_INFO;
    *ppWFI = g_wfiTable;
    *plDevErrVal = 0;

    return S_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::drvNotifyPnpEvent()
//
// Notify PnP event received by device manager.
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvNotifyPnpEvent(
                                 IN const GUID *pEventGUID,
                                 IN BSTR        bstrDeviceID,
                                 IN ULONG       ulReserved )
    {
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\bftp.h ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// bftp.h
//
// Constants and Types for the Binary File Transfer Protocol
// (bFTP). This is the file transfer protocol for IrTran-P V1.0.
//
// NOTE: That IrTran-P is a big-endian protocol when on the net.
//
// NOTE: That the protocol data structures below assume that the
//       compiler generates structures with natural alignment by
//       field type.
//
// Author:
//
//   Edward Reus (edwardr)     02-26-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _BFTP_H_
#define _BFTP_H_

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#define  BFTP_NAME_SIZE              4

#define  ATTR_TYPE_BINARY         0x00
#define  ATTR_TYPE_CHAR           0x01
#define  ATTR_TYPE_TIME           0x06

#define  ATTR_FLAG_DEFAULT        0x00

// These are the attribute names, converted from character strings
// to values (see: FTP_ATTRIBUTE_MAP_ENTRY field dwWhichAttr):
#define  FIL0                        0
#define  LFL0                        1
#define  TIM0                        2
#define  TYP0                        3
#define  TMB0                        4
#define  BDY0                        5
#define  CMD0                        6
#define  WHT0                        7
#define  ERR0                        8
#define  RPL0                        9

#define  RIMG                      100  // Convert WHT0 values as well.
#define  RINF                      101
#define  RCMD                      102

#define  CMD0_ATTR_VALUE    0x40001000  // Byte swapped: 0x00010040.
#define  INVALID_ATTR       0xffffffff

// bFTP Operations:
#define  BFTP_QUERY         0x00000001
#define  BFTP_QUERY_RIMG    0x00000011
#define  BFTP_QUERY_RINF    0x00000021
#define  BFTP_QUERY_RCMD    0x00000031
#define  BFTP_PUT           0x00000100
#define  BFTP_ERROR         0x00000200
#define  BFTP_UNKNOWN       0xffffffff

#define  BFTP_QUERY_MASK    0x00000001

// bFTP WHT0 subtypes:
#define  WHT0_ATTRIB_SIZE            4
#define  SZ_RINF                 "RINF"
#define  SZ_RCMD                 "RCMD"
#define  SZ_RIMG                 "RIMG"


// UPF File Constants:
#define  UPF_HEADER_SIZE           240
#define  UPF_ENTRY_SIZE             36

#define  UPF_TOTAL_HEADER_SIZE     384

//--------------------------------------------------------------------
//  Macro functions
//--------------------------------------------------------------------

#define  Match4( pName1, pName2 )    \
             (  ((pName1)[0] == (pName2)[0]) \
             && ((pName1)[1] == (pName2)[1]) \
             && ((pName1)[2] == (pName2)[2]) \
             && ((pName1)[3] == (pName2)[3]) )

#define  IsBftpQuery(dwBftpOp)       \
             (((dwBftpOp)&BFTP_QUERY_MASK) != 0)

#define  IsBftpPut(dwBftpOp)         \
             ((dwBftpOp) == BFTP_PUT)

#define  IsBftpError(dwBftpOp)       \
             ((dwBftpOp) == BFTP_ERROR)

#define  BftpValueLength(length)     \
              ((length) - 2)
//            Note: that the Length field in the BFTP_ATTRIBUE is
//            two bytes longer than the actual value length.

//--------------------------------------------------------------------
//  bFTP Protocol Headers:
//--------------------------------------------------------------------

// There can (optionally) be a bFTP attribute for the picture
// create/modify date/time. If there then it will be exactly
// this size:
//
#define  BFTP_DATE_TIME_SIZE    14

// Turn off warning for zero-sized array...
#pragma warning(disable:4200)
#pragma pack(1)

typedef struct _BFTP_ATTRIBUTE
   {
   UCHAR  Name[BFTP_NAME_SIZE]; // Attribute Name.
   DWORD  Length;               // Attribute Length.
   UCHAR  Type;                 // Attribute Type (see ATTR_TYPE_xxx).
   UCHAR  Flag;                 // Attribute Flag.
   UCHAR  Value[];              // Attribute Data.
   } BFTP_ATTRIBUTE;

typedef struct _BFTP_ATTRIBUTE_MAP_ENTRY
   {
   DWORD  dwWhichAttr;
   CHAR  *pName;
   UCHAR  Type;
   } BFTP_ATTRIBUTE_MAP_ENTRY;

//--------------------------------------------------------------------
//  Internal parts of a .UPF file:
//--------------------------------------------------------------------

typedef struct _UPF_HEADER
   {
   UCHAR  UpfDeclaration[8];   // "SSS V100", no trailing zero.
   UCHAR  FileDeclaration[8];  // "UPF V100", no trailing zero.
   USHORT FileId;              // Should be 0x0100
   USHORT FileVersion;         // Should be 0x0100
   UCHAR  CreateDate[8];       // See "Date Format" note below.
   UCHAR  EditDate[8];         // See "Date Format" note below.
   UCHAR  MarkerModelCode[4];  // 
   UCHAR  EditMarkerModelCode[4];
   UCHAR  Reserve[16];
   UCHAR  NumDataEntries;
   UCHAR  NumTables;
   UCHAR  Reserve1;
   UCHAR  CharSetCode;         // See "Character Set Codes" below.
   UCHAR  Title[128];
   UCHAR  Reserve2[48];
   } UPF_HEADER;               // 240 Bytes

// NOTE: Date format for the UPF header:
//
// Date/time are held in an 8-byte binary block:
//
//   Field          Size       Meaning
//   -----------    ----       -------
//   Time Offset       1       Difference from UTC (in 15 minute
//                             units). 0x80 implies N/A.
//
//   Year              2       4-digit year (0xFFFF == N/A).
//   Month             1       Month        (0xFF == N/A).
//   Day               1       Day of month (0xFF == N/A).
//   Hour              1       Hour 0-23    (0xFF == N/A).
//   Minute            1       Minute 0-59  (0xFF == N/A).
//   Second            1       Second 0-59  (0xFF == N/A).
//
// So, below are the char[] array offsets for each of the date/time
// fields:
#define  UPF_GMT_OFFSET       0
#define  UPF_YEAR             1
#define  UPF_MONTH            3
#define  UPF_DAY              4
#define  UPF_HOUR             5
#define  UPF_MINUTE           6
#define  UPF_SECOND           7

//
// Character Set Codes:
//
#define  UPF_CCODE_ASCII      0x00
#define  UPF_CCODE_ISO_8859_1 0x01
#define  UPF_CCODE_SHIFT_JIS  0x02
#define  UPF_CCODE_NONE       0xFF

//
// There are usually two of these, one for a thumbnail and one for 
// the image itself. Note that the UPF_ENTRY for the thumbnail will
// usually be present event if there isn't a thumbnail. There is 
// space for four of these in the UPF header area.
//
typedef struct _UPF_ENTRY
   {
   DWORD  dwStartAddress;
   DWORD  dwDataSize;
   UCHAR  DataTypeId;
   UCHAR  Reserve;
   UCHAR  InformationData[26];
   } UPF_ENTRY;                // 36 Bytes.

typedef struct _PICTURE_INFORMATION_DATA
   {
   USHORT ImageWidth;
   USHORT ImageHieght;
   UCHAR  PixelConfiguration;
   UCHAR  RotationSet;      // Amount to rotate image (counter-clockwise).
   UCHAR  Reserved1;
   UCHAR  CompressionRatio;
   UCHAR  WhiteLevel;
   UCHAR  InputDevice;
   UCHAR  Reserved2[3];
   UCHAR  DummyData;        // This is like a border.
   USHORT XBegin;           // This is the inset of the picture.
   USHORT YBegin;
   USHORT XSize;            // Embedded size of the picture.
   USHORT YSize;
   UCHAR  NonCompressionId;
   UCHAR  Reserved3[3];
   } PICTURE_INFORMATION_DATA;  // 26 Bytes.


// Image Rotation Flags. This is the amount to rotate the image in
// a counter clockwise direction. Note that most cameras don't know
// the camera orientation, so ROTATE_0 means upright or unknown
// orientation:
//
#define ROTATE_0           0x00
#define ROTATE_90          0x01
#define ROTATE_180         0x02
#define ROTATE_270         0x03


typedef struct _CAMERA_INFORMATION_TABLE
   {
   UCHAR  TableID;    // 0x24
   UCHAR  NextTableOffset;
   USHORT ShutterSpeed;     // In 1/100ths APEX units (0x8000=Undefined).
   USHORT Aperture;         // In 1/100ths APEX units (0x8000=Undefined).
   USHORT Brightness;       // In 1/100ths APEX units (0x8000=Undefined).
   USHORT Exposurebias;     // In 1/100ths APEX units (0x8000=Undefined).
   USHORT MaxApertureRatio; // In 1/100ths APEX units (0x8000=Undefined).
   USHORT FocalLength;      // In 1/10th mm (0xFFFF=Undefined)
   USHORT SubjectDistance;  // In 1/10th m  (0xFFFE=Infinite,0xFFFF=Undefined)
   UCHAR  MeteringMode;
   UCHAR  LightSource;
   UCHAR  FlashMode;
   UCHAR  Reserved1;
   USHORT IntervalInformation;
   UCHAR  Reserved2[2];
   } CAMERA_INFORMATION_TABLE;  // 24 Bytes.

// APEX Units:
//
// ShutterSpeed to Exposure Time (seconds)
//
//  APEX          -5   -4   -3   -2   -1    0    1    2     3      4
//  Exposure Time 30   15    8    4    2    1   1/2  1/4   1/8    1/16
//
//  APEX           5     6     7      8      9      10     11
//  Exposure Time 1/30  1/60  1/125  1/250  1/500  1/1000 1/2000
//
// Aperture to F-Number
//
//   APEX        0    1    2    3    4    5    6    7    8    9    10
//   F-Number    1   1.4   2   2.8   5   5.6   8   11   16   22    32
// 
// Brightness to Foot Lambert
//
//   APEX         -2   -1    0    1    2    3    4    5
//   Foot Lambert 1/4  1/2   1    2    4    8   15   30
//


// MeteringMode:
#define  METERING_AVERAGED         0x00
#define  METERING_CENTER_WEIGHTED  0x01
#define  METERING_SPOT             0x02
#define  METERING_MULTI_SPOT       0x03

// LightSource:
#define  LIGHT_SOURCE_DAYLIGHT     0x00
#define  LIGHT_SOURCE_FLUORESCENT  0x01
#define  LIGHT_SOURCE_TUNGSTEN     0x03
#define  LIGHT_SOURCE_STANDARD_A   0x10
#define  LIGHT_SOURCE_STANDARD_B   0x11
#define  LIGHT_SOURCE_STANDARD_C   0x12
#define  LIGHT_SOURCE_D55          0x20
#define  LIGHT_SOURCE_D65          0x21
#define  LIGHT_SOURCE_D75          0x22
#define  LIGHT_SOURCE_UNDEFINED    0xFF

// FlashMode:
#define  FLASH_NO_FLASH            0x00
#define  FLASH_FLASH               0x01
#define  FLASH_UNKNOWN             0xFF

#pragma warning(default:4200)
#pragma pack()

#endif //_BFTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\byteswap.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// byteswap.cpp
//
// Routines to byteswap SCEP and bFTP headers from the wire format 
// (which is Big-Endian) to Little-Endian (Intel) format.
//
// Author:
//
//   Edward Reus (EdwardR)   02-26-98  Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

//--------------------------------------------------------------------
//  ByteSwapCommandHeader()
//
//  A command header is a 28 byte sub-header embedded in some of the
//  SCEP headers.
//--------------------------------------------------------------------
void ByteSwapCommandHeader( COMMAND_HEADER *pCommandHeader )
    {
    pCommandHeader->Length4 = ByteSwapLong(pCommandHeader->Length4);
    pCommandHeader->DestPid = ByteSwapShort(pCommandHeader->DestPid);
    pCommandHeader->SrcPid = ByteSwapShort(pCommandHeader->SrcPid);
    pCommandHeader->CommandId = ByteSwapShort(pCommandHeader->CommandId);
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderShortNonFrag()
//
//  Short non-fragmented SCEP request header.
//--------------------------------------------------------------------
void ByteSwapReqHeaderShortNonFrag( SCEP_REQ_HEADER_SHORT *pReqHeaderShort )
    {
    pReqHeaderShort->Length3 = ByteSwapShort(pReqHeaderShort->Length3);

    if (pReqHeaderShort->Length3 >= COMMAND_HEADER_SIZE)
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderShort->CommandHeader );
        }
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderLongNonFrag()
//
//  Long non-fragmented SCEP request header.
//--------------------------------------------------------------------
void ByteSwapReqHeaderLongNonFrag( SCEP_REQ_HEADER_LONG *pReqHeaderLong )
    {
    pReqHeaderLong->Length2 = ByteSwapShort(pReqHeaderLong->Length2);
    pReqHeaderLong->Length3 = ByteSwapShort(pReqHeaderLong->Length3);

    if (pReqHeaderLong->Length3 >= COMMAND_HEADER_SIZE)
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderLong->CommandHeader );
        }
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderShortFrag()
//
//  Short fragmented SCEP request header. SCEP PDUs can be fragmented.
//
//  Note: In practice a short fragmented PDU will probably never
//  show up, but its part of the spec...
//--------------------------------------------------------------------
void ByteSwapReqHeaderShortFrag( 
                   SCEP_REQ_HEADER_SHORT_FRAG *pReqHeaderShortFrag )
    {
    pReqHeaderShortFrag->Length3 = ByteSwapShort(pReqHeaderShortFrag->Length3);
    pReqHeaderShortFrag->SequenceNo = ByteSwapLong(pReqHeaderShortFrag->SequenceNo);
    pReqHeaderShortFrag->RestNo = ByteSwapLong(pReqHeaderShortFrag->RestNo);

    if ( (pReqHeaderShortFrag->Length3 >= COMMAND_HEADER_SIZE)
       && (pReqHeaderShortFrag->DFlag == DFLAG_FIRST_FRAGMENT) )
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderShortFrag->CommandHeader );
        }
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderLongFrag()
//
//  Long fragmented SCEP request header.
//--------------------------------------------------------------------
void ByteSwapReqHeaderLongFrag( SCEP_REQ_HEADER_LONG_FRAG *pReqHeaderLongFrag )
    {
    pReqHeaderLongFrag->Length2 = ByteSwapShort(pReqHeaderLongFrag->Length2);
    pReqHeaderLongFrag->Length3 = ByteSwapShort(pReqHeaderLongFrag->Length3);
    pReqHeaderLongFrag->SequenceNo = ByteSwapLong(pReqHeaderLongFrag->SequenceNo);
    pReqHeaderLongFrag->RestNo = ByteSwapLong(pReqHeaderLongFrag->RestNo);

    if ( (pReqHeaderLongFrag->Length3 >= COMMAND_HEADER_SIZE)
       && (pReqHeaderLongFrag->DFlag == DFLAG_FIRST_FRAGMENT) )
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderLongFrag->CommandHeader );
        }
    }

//--------------------------------------------------------------------
// ByteSwapReqHeaderShort()
//
//--------------------------------------------------------------------
void ByteSwapReqHeaderShort( SCEP_REQ_HEADER_SHORT *pReqHeaderShort )
    {
    if ( (pReqHeaderShort->DFlag == DFLAG_SINGLE_PDU)
       || (pReqHeaderShort->DFlag == DFLAG_INTERRUPT)
       || (pReqHeaderShort->DFlag == DFLAG_CONNECT_REJECT) )
        {
        ByteSwapReqHeaderShortNonFrag( pReqHeaderShort );
        }
    else
        {
        ByteSwapReqHeaderShortFrag( 
                       (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort );
        }
    }

//--------------------------------------------------------------------
// ByteSwapReqHeaderLong()
//
//--------------------------------------------------------------------
void ByteSwapReqHeaderLong( SCEP_REQ_HEADER_LONG *pReqHeaderLong )
    {
    if ( (pReqHeaderLong->DFlag == DFLAG_SINGLE_PDU)
       || (pReqHeaderLong->DFlag == DFLAG_INTERRUPT)
       || (pReqHeaderLong->DFlag == DFLAG_CONNECT_REJECT) )
        {
        ByteSwapReqHeaderLongNonFrag( pReqHeaderLong );
        }
    else
        {
        ByteSwapReqHeaderLongFrag( 
                        (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong );
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\complete.cpp ===
//---------------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  complete.cpp
//
//  This is the main for the IrTran-P service.
//---------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE        g_hInst;           // Instance of ircamera.dll
extern void            *g_pvIrUsdDevice;   // Devined: irtranp.cpp

extern CCONNECTION_MAP *g_pConnectionMap;  // Defined: irtranp.cpp
extern BOOL  ReceivesAllowed();            // Defined: irtranp.cpp
extern BOOL  CheckSaveAsUPF();             // Defined: irtranp.cpp

extern DWORD SignalWIA( IN char *pszFileName,
                        IN void *pvIrUsdDevice );  // see ../device.cpp

//---------------------------------------------------------------------
// Constants:
//---------------------------------------------------------------------

#define DEFAULT_TIMEOUT      10000

//---------------------------------------------------------------------
// ReceiveComplete()
//
//---------------------------------------------------------------------
void ReceiveComplete( IN CCONNECTION *pConnection,
                      IN DWORD        dwStatusCode )
    {
    DWORD    dwError = 0;

    if (  (dwStatusCode == NO_ERROR)
       || (dwStatusCode == ERROR_SCEP_UNSPECIFIED_DISCONNECT)
       || (dwStatusCode == ERROR_SCEP_USER_DISCONNECT)
       || (dwStatusCode == ERROR_SCEP_PROVIDER_DISCONNECT) )
        {
        //
        // A new picture has just been received, so we need to signal
        // WIA...
        //
        SignalWIA( pConnection->GetPathPlusFileName(), g_pvIrUsdDevice );
        }
    }

//---------------------------------------------------------------------
// ProcessConnectRequest()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_CONNECT_REQ.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectRequest()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessConnectRequest( IN CCONNECTION *pConnection,
                             IN SCEP_HEADER *pPdu,
                             IN DWORD        dwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwRespPduSize;
    BOOL   fReceivesAllowed = ::ReceivesAllowed();
    SCEP_HEADER *pRespPdu;
    CIOPACKET   *pNewIoPacket;    // Posted IO packet (by SendPdu()).

    CSCEP_CONNECTION *pScepConnection
                 = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    if (fReceivesAllowed)
        {
        // Build an connection accept acknowledgement:
        dwStatus = pScepConnection->BuildConnectRespPdu(&pRespPdu,
                                                        &dwRespPduSize);
        }
    else
        {
        // Build a connect NACK:
        dwStatus = pScepConnection->BuildConnectNackPdu(&pRespPdu,
                                                        &dwRespPduSize);
        }

    if (dwStatus == NO_ERROR)
        {
        pConnection->SendPdu(pRespPdu,dwRespPduSize,&pNewIoPacket);
        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pRespPdu);
            }
        else
            {
            DeletePdu(pRespPdu);
            }

        if (!fReceivesAllowed)
            {
            // Note: After sending a NACK, the camera should close
            // the connection, but at lease some don't, so I'm
            // forced to slam the connection...
            pConnection->CloseSocket();  // Was: ShutdownSocket().
            }
        }

    DeletePdu(pPdu);

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessConnectResponse()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_CONNECT_RESP.
//
// NOTE: Note implemented in the IrTran-P server, because the server
//       is not currently setup to connect to a camera to download
//       pictures back to the camera... We should never get this PDU
//       during normal operation.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectResponse()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessConnectResponse( CCONNECTION *pConnection,
                              SCEP_HEADER *pPdu,
                              DWORD        dwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;

    WIAS_TRACE((g_hInst,"ProcessClient(): Unimplemented MSG_TYPE_CONNECT_RESP"));

    DeletePdu(pPdu);

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessData()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_DATA.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectResponse()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessData( CCONNECTION    *pConnection,
                   SCEP_HEADER    *pPdu,
                   DWORD           dwPduSize,
                   COMMAND_HEADER *pCommandHeader,
                   UCHAR          *pUserData,
                   DWORD           dwUserDataSize )
    {
    DWORD        dwStatus = NO_ERROR;
    DWORD        dwRespPduSize;
    DWORD        dwBftpOp;
    UCHAR       *pPutData;
    DWORD        dwPutDataSize;
    DWORD        dwJpegOffset;
    DWORD        dwJpegSize;
    SCEP_HEADER *pRespPdu;
    CIOPACKET   *pNewIoPacket;    // Posted IO packet (by SendPdu()).


    CSCEP_CONNECTION *pScepConnection
                 = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    // First, check to see if this is an abort PDU, send by the camera:
    if ( (pCommandHeader) && (pCommandHeader->PduType == PDU_TYPE_ABORT) )
        {
        DeletePdu(pPdu);
        return ERROR_SCEP_ABORT;
        }

    // Is one of the 2nd through Nth fragments of a fragmented PDU?
    if ( (pScepConnection->IsFragmented())
       && (pScepConnection->GetSequenceNo() > 0))
        {
        #ifdef DBG_IO
        WIAS_TRACE((g_hInst,"ProcessClient(): Put Fragment: SequenceNo: %d RestNo: %d", pScepConnection->GetSequenceNo(), pScepConnection->GetRestNo() ));
        #endif

        pConnection->WritePictureFile( pUserData,
                                       dwUserDataSize,
                                       &pNewIoPacket );
        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pPdu);
            }
        else
            {
            DeletePdu(pPdu);
            }

        if (pScepConnection->GetDFlag() == DFLAG_LAST_FRAGMENT)
            {
            pScepConnection->BuildPutRespPdu( PDU_TYPE_REPLY_ACK,
                                              ERROR_PUT_NO_ERROR,
                                              &pRespPdu,
                                              &dwRespPduSize);
            pConnection->SendPdu( pRespPdu,
                                  dwRespPduSize,
                                  &pNewIoPacket);

            if (pNewIoPacket)
                {
                pNewIoPacket->SetWritePdu(pRespPdu);
                }
            else
                {
                DeletePdu(pRespPdu);
                }
            }
        }
    else if (pCommandHeader)
        {
        // Length4 in the COMMAN_HEADER is the user data size
        // plus the bytes for machine ids (16), the DestPid (2),
        // SrcPid (2) and CommandId (2) so offset by 22.

        dwStatus = pScepConnection->ParseBftp( pUserData,
                                               dwUserDataSize,
                                               pConnection->CheckSaveAsUPF(),
                                               &dwBftpOp,
                                               &pPutData,
                                               &dwPutDataSize );
        if ((dwStatus == NO_ERROR) && (IsBftpQuery(dwBftpOp)))
            {
            pScepConnection->BuildWht0RespPdu(dwBftpOp,
                                              &pRespPdu,
                                              &dwRespPduSize);

            pConnection->SendPdu( pRespPdu,
                                  dwRespPduSize,
                                  &pNewIoPacket );

            if (pNewIoPacket)
                {
                pNewIoPacket->SetWritePdu(pRespPdu);
                }
            else
                {
                DeletePdu(pRespPdu);
                }

            DeletePdu(pPdu);
            }
        else if ((dwStatus == NO_ERROR) && (IsBftpPut(dwBftpOp)))
            {
            //
            // Ok, we have a bFTP PUT command, so open a file
            // and get ready to start collecting image data.
            //
            dwStatus = pScepConnection->ParseUpfHeaders( pPutData,
                                                         dwPutDataSize,
                                                         &dwJpegOffset,
                                                         &dwJpegSize );

            pConnection->SetJpegOffsetAndSize(dwJpegOffset,dwJpegSize);

            dwStatus = pConnection->Impersonate();

            dwStatus = pConnection->CreatePictureFile();

            dwStatus = pConnection->SetPictureFileTime( pScepConnection->GetCreateTime() );

            dwStatus = pConnection->RevertToSelf();

            dwStatus = pConnection->WritePictureFile( pPutData,
                                                      dwPutDataSize,
                                                      &pNewIoPacket );
            if (pNewIoPacket)
                {
                pNewIoPacket->SetWritePdu(pPdu);
                }
            else
                {
                DeletePdu(pPdu);
                }
            }
        else if (IsBftpError(dwBftpOp))
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"ProcessClient(): bFTP Error: %d", dwStatus));
            #endif

            DeletePdu(pPdu);
            dwStatus = ERROR_BFTP_INVALID_PROTOCOL;
            }
        else
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"ProcessClient(): Unknown bFTP Command: %d",dwBftpOp));
            #endif

            DeletePdu(pPdu);
            dwStatus = ERROR_BFTP_INVALID_PROTOCOL;
            }
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessDisconnect()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_DISCONNECT.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectResponse()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessDisconnect( CCONNECTION *pConnection,
                         SCEP_HEADER *pPdu,
                         DWORD        dwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;

    // Don't need to do anything special here, since
    // ParsePdu() will set dwStatus to one of:
    //          ERROR_SCEP_UNSPECIFIED_DISCONNECT  (5002)
    //          ERROR_SCEP_USER_DISCONNECT         (5003)
    //      or  ERROR_SCEP_PROVIDER_DISCONNECT     (5004)

    pConnection->SetReceiveComplete(TRUE);

    DeletePdu(pPdu);

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessClient()                       Synchronous Version
//
//---------------------------------------------------------------------
DWORD ProcessClient( CIOSTATUS   *pIoStatus,
                     CCONNECTION *pConnection,
                     char        *pBuffer,
                     DWORD        dwNumBytes )
    {
    DWORD           dwStatus = NO_ERROR;
    CSCEP_CONNECTION *pScepConnection;
    SCEP_HEADER    *pPdu;
    DWORD           dwPduSize;
    COMMAND_HEADER *pCommandHeader;
    UCHAR          *pUserData;       // Location of bFTP data.
    DWORD           dwUserDataSize;
    DWORD           dwError = 0;


    pScepConnection = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    WIAS_ASSERT(g_hInst,pScepConnection!=NULL);

    while (dwStatus == NO_ERROR)
        {
        dwStatus = pScepConnection->AssemblePdu( pBuffer,
                                                 dwNumBytes,
                                                 &pPdu,
                                                 &dwPduSize );
        if (dwStatus == NO_ERROR)
            {
            dwStatus = pScepConnection->ParsePdu( pPdu,
                                                  dwPduSize,
                                                  &pCommandHeader,
                                                  &pUserData,
                                                  &dwUserDataSize );

            switch (pPdu->MsgType)
                {
                case MSG_TYPE_CONNECT_REQ:
                    //
                    // Message was an SCEP Connection Request:
                    //
                    dwStatus = ProcessConnectRequest(pConnection,
                                                     pPdu,
                                                     dwPduSize );

                    if ((dwStatus) || (!ReceivesAllowed()))
                        {
                        pConnection->ClosePictureFile();
                        ReceiveComplete(pConnection,dwStatus);
                        }
                    else
                        {
                        pConnection->StartProgress();
                        }
                    break;

                case MSG_TYPE_CONNECT_RESP:
                    // Message was a reply from a connection request:
                    dwStatus = ProcessConnectResponse(pConnection,
                                                      pPdu,
                                                      dwPduSize );
                    break;

                case MSG_TYPE_DATA:
                    // Message is a SCEP command of some sort:
                    dwStatus = ProcessData(pConnection,
                                           pPdu,
                                           dwPduSize,
                                           pCommandHeader,
                                           pUserData,
                                           dwUserDataSize );
                    pConnection->UpdateProgress();
                    break;

                case MSG_TYPE_DISCONNECT:
                    // Message from the camera was a disconnect:
                    ProcessDisconnect(pConnection,
                                      pPdu,
                                      dwPduSize );
                    pConnection->ClosePictureFile();
                    ReceiveComplete(pConnection,dwStatus);
                    pConnection->EndProgress();
                    break;

                default:
                    #ifdef DBG_ERROR
                    WIAS_ERROR((g_hInst,"ProcessClient(): Unknown MSG_TYPE_xxx: %d", pPdu->MsgType));
                    #endif
                    DeletePdu(pPdu);
                    pConnection->EndProgress();
                    break;
                }
            }
        else
            {
            break;
            }

        pBuffer = 0;
        dwNumBytes = 0;
        }

    if (dwStatus == ERROR_CONTINUE)
        {
        dwStatus = NO_ERROR;
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// SendAbortPdu()
//
// Stop the camera.
//
// I should be able to send a Stop PDU, followed by a Disconnect, or
// maybe an Abort PDU, but these don't work on all the cameras, so I
// currently end up just doing a hard close on the connection to the
// camera.
//---------------------------------------------------------------------
DWORD SendAbortPdu( IN CCONNECTION *pConnection )
    {
    DWORD  dwStatus = NO_ERROR;

    #if TRUE
    pConnection->CloseSocket();

    #else
    DWORD  dwPduSize;
    SCEP_HEADER *pPdu;
    CIOPACKET        *pNewIoPacket = 0;
    CSCEP_CONNECTION *pScepConnection
                 = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    if (pScepConnection)
        {
        dwStatus = pScepConnection->BuildStopPdu(&pPdu,&dwPduSize);

        if (dwStatus != NO_ERROR)
            {
            pConnection->CloseSocket();
            return dwStatus;
            }

        dwStatus = pConnection->SendPdu(pPdu,dwPduSize,&pNewIoPacket);

        if (dwStatus != NO_ERROR)
            {
            DeletePdu(pPdu);
            pConnection->CloseSocket();
            return dwStatus;
            }

        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pPdu);
            }

        dwStatus = pScepConnection->BuildDisconnectPdu(
                                         REASON_CODE_PROVIDER_DISCONNECT,
                                         &pPdu,
                                         &dwPduSize);

        if (dwStatus != NO_ERROR)
            {
            pConnection->CloseSocket();
            return dwStatus;
            }

        dwStatus = pConnection->SendPdu(pPdu,dwPduSize,&pNewIoPacket);

        if (dwStatus != NO_ERROR)
            {
            DeletePdu(pPdu);
            pConnection->CloseSocket();
            return dwStatus;
            }

        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pPdu);
            }
        }
    #endif

    return dwStatus;
    }

//---------------------------------------------------------------------
// MapStatusCode()
//
//---------------------------------------------------------------------
DWORD MapStatusCode( DWORD dwStatus,
                     DWORD dwDefaultStatus )
    {
    // The Facility part of an error code are the first 12 bits of the
    // high word (16bits):
    #define FACILITY_MASK   0x0FFF0000

    // If the error code is already an IrTran-P error code, then don't
    // remap it:
    if ( ((dwStatus&FACILITY_MASK) >> 16) == FACILITY_IRTRANP)
        {
        return dwStatus;
        }

    // Map other errors:
    if (dwStatus != NO_ERROR)
        {
        if (  (dwStatus == ERROR_DISK_FULL)
           || (dwStatus == ERROR_WRITE_FAULT)
           || (dwStatus == ERROR_WRITE_PROTECT)
           || (dwStatus == ERROR_GEN_FAILURE)
           || (dwStatus == ERROR_NOT_DOS_DISK) )
            {
            dwStatus = ERROR_IRTRANP_DISK_FULL;
            }
        else
            {
            dwStatus = dwDefaultStatus;
            }
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessIoPackets()               Synchronous Version
//
//---------------------------------------------------------------------
DWORD ProcessIoPackets( CIOSTATUS *pIoStatus )
    {
    DWORD   dwStatus = NO_ERROR;
    DWORD   dwProcessStatus = NO_ERROR;   // Processing IO status.
    DWORD   dwNumBytes;
    DWORD   dwState;
    SOCKET  Socket = INVALID_SOCKET;
    CCONNECTION    *pConnection;
    CCONNECTION    *pNewConnection;
    CSCEP_CONNECTION *pScepConnection;
    DWORD   dwKind = PACKET_KIND_LISTEN;
    int     iCount;


    while (TRUE)
        {
        if (dwKind == PACKET_KIND_LISTEN)
            {
            dwState = 0;

            Socket = g_pConnectionMap->ReturnNextSocket(&dwState);

            pConnection = g_pConnectionMap->Lookup(Socket);
            if (!pConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Lookup(%d) Failed."));
                #endif
                continue;
                }

            //
            // New connection:
            //
            SOCKET NewSocket = accept(Socket,NULL,NULL);

            if (NewSocket == INVALID_SOCKET)
                {
                dwStatus = WSAGetLastError();

                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Accept() failed: %d",dwStatus));
                #endif

                break;
                }

            WIAS_TRACE((g_hInst,"ProcessIoPackets(): Accept(): Socket: %d",NewSocket));

            pScepConnection = new CSCEP_CONNECTION;
            if (!pScepConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Out of memeory on allocate of new SCEP connection object."));
                #endif

                closesocket(NewSocket);
                continue;
                }

            pNewConnection = new CCONNECTION(
                                        PACKET_KIND_READ,
                                        NewSocket,
                                        NULL, // No IO Completion port...
                                        pScepConnection,
                                        ::CheckSaveAsUPF() );
            if (!pNewConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Out of memeory on allocate of new connection object."));
                #endif

                delete pScepConnection;
                closesocket(NewSocket);
                continue;
                }

            g_pConnectionMap->Add(pNewConnection,
                                  pNewConnection->GetSocket() );

            Socket = NewSocket;
            dwKind = PACKET_KIND_READ;
            }
        else
            {
            //
            // Incomming data from connected client:
            //
            DWORD   dwFlags = 0;

            char  ReadBuffer[DEFAULT_READ_BUFFER_SIZE];
            int   iReadBufferSize = DEFAULT_READ_BUFFER_SIZE;


            pConnection = g_pConnectionMap->Lookup(Socket);
            if (!pConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Lookup(%d) Failed."));
                #endif

                dwKind = PACKET_KIND_LISTEN;
                continue;
                }

            iCount = recv(Socket,ReadBuffer,iReadBufferSize,dwFlags);

            if (iCount == SOCKET_ERROR)
                {
                //
                // Error on Recv().
                //
                dwStatus = WSAGetLastError();

                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Recv() failed: %d",dwStatus));
                #endif

                g_pConnectionMap->Remove(Socket);

                delete pConnection;

                dwKind = PACKET_KIND_LISTEN;
                continue;
                }

            if (iCount == 0)
                {
                //
                // Graceful close.
                //
                g_pConnectionMap->Remove(Socket);

                delete pConnection;

                dwKind = PACKET_KIND_LISTEN;
                continue;
                }

            WIAS_ASSERT(g_hInst, iCount>0 );

            dwNumBytes = iCount;

            dwProcessStatus 
                = ProcessClient(pIoStatus,
                                pConnection,
                                ReadBuffer,
                                dwNumBytes);

            if (dwProcessStatus != NO_ERROR)
                {
                #ifdef DBG_ERROR
                if (  (dwProcessStatus != ERROR_SCEP_UNSPECIFIED_DISCONNECT)
                   && (dwProcessStatus != ERROR_SCEP_USER_DISCONNECT)
                   && (dwProcessStatus != ERROR_SCEP_PROVIDER_DISCONNECT) )
                    {
                    WIAS_ERROR((g_hInst,"ProcessIoPackets(): ProcessClient(): Failed: 0x%x",dwProcessStatus));
                    }
                #endif

                SendAbortPdu(pConnection);
                pConnection->ClosePictureFile();
                pConnection->EndProgress();
                pConnection->DeletePictureFile();
                g_pConnectionMap->Remove(Socket);
                delete pConnection;

                dwProcessStatus = MapStatusCode(
                                             dwProcessStatus,
                                             ERROR_SCEP_INVALID_PROTOCOL );
                // pConnection->ClosePictureFile();
                // ReceiveComplete(pConnection,dwProcessStatus);

                dwKind = PACKET_KIND_LISTEN;
                }
            }
        }

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\bftp.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// bftp.cpp
//
// Author
//
//   Edward Reus (EdwardR)  02-26-98   Initial Coding.
//
//--------------------------------------------------------------------

#include "precomp.h"
#include <stdlib.h>

extern HINSTANCE  g_hInst;   // Instance of ircamera.dll

static BFTP_ATTRIBUTE_MAP_ENTRY Attributes[] = {
    //Attr   Name    Type
    { FIL0, "FIL0",  ATTR_TYPE_CHAR },   // ASCII 8.3 File Name.
    { LFL0, "LFL0",  ATTR_TYPE_CHAR },   // SJIS or ISO8859-1 Long File Name.
    { TIM0, "TIM0",  ATTR_TYPE_TIME },   // File create/modify time.
    { TYP0, "TYP0",  ATTR_TYPE_BINARY }, // File or Thumbnail Information.
    { TMB0, "TMB0",  ATTR_TYPE_BINARY }, // The scaled down image.
    { BDY0, "BDY0",  ATTR_TYPE_BINARY }, // (?).
    { CMD0, "CMD0",  ATTR_TYPE_BINARY }, // Command Name (?).
    { WHT0, "WHT0",  ATTR_TYPE_CHAR },   // Category Data.
    { ERR0, "ERR0",  ATTR_TYPE_BINARY }, // Error code.
    { RPL0, "RPL0",  ATTR_TYPE_CHAR },   // Result: Stored File Name.
    { INVALID_ATTR,  0,      0 }
    };

//
// This is the bFTP for an RIMG query by the camera:
//
#define BFTP_RIMG_ATTR_VALUE_SIZE         14
#define BFTP_RIMG_RESP_SIZE               12 + BFTP_RIMG_ATTR_VALUE_SIZE

static UCHAR BftpRimgRespAttrValue[BFTP_RIMG_ATTR_VALUE_SIZE] =
    {
    0x00, 0xff, 0xff,                   // Pixel aspect ratio (any).
    0x02, 0x01, 0xff, 0xff, 0xff, 0xff, // Accept image size (any).
    0x05, 0xff, 0xff, 0xff, 0xff        // Accept file size (any).
    };

//
// This is the bFTP for an RINF query by the camera:
//
#define BFTP_RINF_ATTR_VALUE_SIZE          3
#define BFTP_RINF_RESP_SIZE               12 + BFTP_RINF_ATTR_VALUE_SIZE

static UCHAR BftpRinfRespAttrValue[BFTP_RINF_ATTR_VALUE_SIZE] =
    {
    0x10, 0xff, 0xff                    // Memory available (lots).
    };

//
// This is the bFTP for an RCMD query by the camera:
//
#define BFTP_RCMD_ATTR_VALUE_SIZE          5
#define BFTP_RCMD_RESP_SIZE               12 + BFTP_RCMD_ATTR_VALUE_SIZE

static UCHAR BftpRcmdRespAttrValue[BFTP_RCMD_ATTR_VALUE_SIZE] =
    {
    0x20, 0x00, 0xff, 0x00, 0x01        // Accept up to 255 puts/connect.
    };

//
// Map bFTP error codes:
static DWORD dwBftpErrorCodeMap[][2] =
    {
    { ERROR_PUT_UNDEFINED_ERROR,    ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_ILLEGAL_DATA,       ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_UNSUPPORTED_PID,    ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_ILLEGAL_ATTRIBUTE,  ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_UNSUPPORTED_CMD,    ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_FILE_SYSTEM_FULL,   ERROR_IRTRANP_DISK_FULL },
    { ERROR_PUT_NO_FILE_OR_DIR,     ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_LOW_BATTERY,        ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_ABORT_EXECUTION,    ERROR_SCEP_ABORT },
    { ERROR_PUT_NO_ERROR,           NO_ERROR }
    };

//--------------------------------------------------------------------
//  CharToValue()
//
//  Used in parsing the bFTP date string. In this case the maximum
//  value to parse is the year (YYYY).
//--------------------------------------------------------------------
static WORD CharToValue( IN UCHAR *pValue,
                         IN DWORD  dwLength )
    {
    #define MAX_VALUE_STR_LEN    4
    WORD    wValue = 0;
    CHAR    szTemp[MAX_VALUE_STR_LEN];

    if (dwLength < MAX_VALUE_STR_LEN)
        {
        memcpy(szTemp,pValue,dwLength);
        szTemp[dwLength] = 0;
        wValue =  (WORD)atoi(szTemp);
        }

    return wValue;
    }

//--------------------------------------------------------------------
// MapBftpErrorCode()
//
//--------------------------------------------------------------------
DWORD  MapBftpErrorCode( IN DWORD dwBftpErrorCode )
    {
    DWORD  dwErrorCode = NO_ERROR;
    DWORD  dwNumCodes = sizeof(dwBftpErrorCodeMap)/(2*sizeof(DWORD));

    for (DWORD i=0; i<dwNumCodes; i++)
        {
        if (dwBftpErrorCode == dwBftpErrorCodeMap[i][0])
            {
            dwErrorCode = dwBftpErrorCodeMap[i][1];
            break;
            }
        }

    return dwErrorCode;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseBftpAttributeName()
//
//--------------------------------------------------------------------
BFTP_ATTRIBUTE *CSCEP_CONNECTION::ParseBftpAttributeName(
                                     IN BFTP_ATTRIBUTE *pAttr,
                                     IN OUT DWORD      *pdwSize,
                                     OUT    DWORD      *pdwWhichAttr )
    {
    BFTP_ATTRIBUTE_MAP_ENTRY *pAttrMapEntry = Attributes;

    *pdwWhichAttr = INVALID_ATTR;

    while (pAttrMapEntry->pName)
       {
       if (Match4(pAttr->Name,pAttrMapEntry->pName))
           {
           *pdwWhichAttr = pAttrMapEntry->dwWhichAttr;

           break;
           }

       pAttrMapEntry++;
       }

    // Note: that the Length paramter is 8 bytes in from the start
    // of pAttr, hence the extra 8 (bytes) below:
    *pdwSize = *pdwSize - 8UL - pAttr->Length;
    pAttr = (BFTP_ATTRIBUTE*)( 8UL + pAttr->Length + (UCHAR*)pAttr );

    return pAttr;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::SaveBftpCreateDate()
//
// The bFTP create date/time is a character array of the form:
// YYYYMMDDHHMMSS (not zero terminated).
//
// If it was specifed then we want to use it as the create date
// of the picture file that we save the JPEG to.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::SaveBftpCreateDate( IN UCHAR  *pDate,
                                            IN DWORD   dwDateLength )
    {
    DWORD  dwStatus = NO_ERROR;
    SYSTEMTIME     SystemTime;
    FILETIME       LocalTime;
    FILETIME       FileTime;

    memset(&SystemTime,0,sizeof(SystemTime));

    if (dwDateLength == BFTP_DATE_TIME_SIZE)
        {
        //
        // Note that system time is in UTC, we will need to convert
        // this to local time...
        //
        SystemTime.wYear = CharToValue( pDate, 4 );
        SystemTime.wMonth = CharToValue( &(pDate[4]), 2 );
        SystemTime.wDay = CharToValue( &(pDate[6]), 2 );
        SystemTime.wHour = CharToValue( &(pDate[8]), 2 );
        SystemTime.wMinute = CharToValue( &(pDate[10]), 2 );
        SystemTime.wSecond = CharToValue( &(pDate[12]), 2 );

        if (SystemTimeToFileTime(&SystemTime,&LocalTime))
            {
            //
            // Before we use the time zone, we need to convert it to
            // UTC (its currently in "local time". Note that:
            //
            if (LocalFileTimeToFileTime(&LocalTime,&FileTime))
                {
                m_CreateTime = FileTime;
                }
            else
                {
                WIAS_ERROR((g_hInst,"IrTranP: SaveBftpCreateDate(): LocalFileTimeToFileTime() Failed: %d",GetLastError()));
                }
            }
        else
            {
            dwStatus = GetLastError();
            WIAS_ERROR((g_hInst,"IrTranP: SaveBftpCreateDate(): SystemTimeToFileTime(): Failed: %d", dwStatus));
            dwStatus = NO_ERROR;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseBftp()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseBftp( IN  UCHAR  *pBftpData,
                                   IN  DWORD   dwBftpDataSize,
                                   IN  BOOL    fSaveAsUPF,
                                   OUT DWORD  *pdwBftpOp,
                                   OUT UCHAR **ppPutData,
                                   OUT DWORD  *pdwPutDataSize )
    {
    DWORD   i;
    DWORD   dwStatus = NO_ERROR;
    DWORD   dwAttrSize;
    DWORD   dwWhichAttr;
    DWORD   dwLength;
    DWORD   dwSaveLength;
    USHORT  usNumAttr;
    char   *pszTemp;
    BFTP_ATTRIBUTE *pAttr;
    BFTP_ATTRIBUTE *pNextAttr;

    *pdwBftpOp = 0;
    *ppPutData = 0;
    *pdwPutDataSize = 0;

    #ifdef LITTLE_ENDIAN
    usNumAttr = ByteSwapShort( *((USHORT*)pBftpData) );
    #endif

    pAttr = (BFTP_ATTRIBUTE*)(pBftpData + sizeof(USHORT));
    dwAttrSize = dwBftpDataSize - sizeof(USHORT);

    for (i=0; i<usNumAttr; i++)
        {
        #ifdef LITTLE_ENDIAN
        pAttr->Length = ByteSwapLong( pAttr->Length );
        #endif

        pNextAttr = ParseBftpAttributeName( pAttr,
                                            &dwAttrSize,
                                            &dwWhichAttr );

        if (dwWhichAttr == INVALID_ATTR)
            {
            return ERROR_BFTP_INVALID_PROTOCOL;
            }

        if (dwWhichAttr == CMD0)
            {
            if (pAttr->Length == 2+sizeof(DWORD))
                {
                #ifdef LITTLE_ENDIAN
                *((DWORD*)(pAttr->Value)) = ByteSwapLong( *((DWORD*)(pAttr->Value)) );
                #endif
                }

            // Expect Value == 0x00010040 for a Query "WHT0" Request.
            //        Value == 0x00000000 for a Put Request.
            if ( *((DWORD*)(pAttr->Value)) == 0x00010040 )
                {
                *pdwBftpOp = BFTP_QUERY_RIMG;
                }
            else if ( *((DWORD*)(pAttr->Value)) == 0 )
                {
                *pdwBftpOp = BFTP_PUT;
                }
            else
                {
                *pdwBftpOp = BFTP_UNKNOWN;
                }
            }
        else if (dwWhichAttr == WHT0)
            {
            if (Match4("RIMG",pAttr->Value))
                {
                dwWhichAttr = RIMG;
                *pdwBftpOp = BFTP_QUERY_RIMG;
                }
            else if (Match4("RINF",pAttr->Value))
                {
                dwWhichAttr = RINF;
                *pdwBftpOp = BFTP_QUERY_RINF;
                }
            else if (Match4("RCMD",pAttr->Value))
                {
                dwWhichAttr = RCMD;
                *pdwBftpOp = BFTP_QUERY_RCMD;
                }
            else
                {
                dwWhichAttr = INVALID_ATTR;
                *pdwBftpOp = BFTP_UNKNOWN;
                return ERROR_BFTP_INVALID_PROTOCOL;
                }
            }
        //
        // Short (8.3) file name:
        //
        else if (dwWhichAttr == FIL0)
            {
            // Note: That the specification limits the file
            //       name to 8.3...
            dwLength = BftpValueLength(pAttr->Length);
            if (dwLength > FILE_NAME_SIZE)
                {
                dwLength = FILE_NAME_SIZE;
                }

            if (m_pszFileName)
                {
                FreeMemory(m_pszFileName);
                }

            m_pszFileName = (CHAR*)AllocateMemory(1+dwLength);
            if (!m_pszFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            memcpy(m_pszFileName,pAttr->Value,dwLength);
            m_pszFileName[dwLength] = 0;

            //
            // Create the name that the file will actually be saved as:
            //
            if (m_pszSaveFileName)
                {
                FreeMemory(m_pszSaveFileName);
                }

            dwSaveLength = sizeof(CHAR)*(1+dwLength) + sizeof(SZ_JPEG);
            m_pszSaveFileName = (CHAR*)AllocateMemory(dwSaveLength);
            if (!m_pszSaveFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            strcpy(m_pszSaveFileName,m_pszFileName);

            // File name is currently XXXXXX.UPF. Change to
            // XXXXXX.JPG or XXXXXX.UPF as appropriate:
            CHAR *psz = strrchr(m_pszSaveFileName,PERIOD);
            if (psz)
                {
                *psz = 0;  // Remove old suffix.
                }

            if (fSaveAsUPF)
                {
                strcat(m_pszSaveFileName,SZ_UPF);    // UPF file.
                }
            else
                {
                strcat(m_pszSaveFileName,SZ_JPEG);   // JPG file.
                }
            }
        //
        // UPF body: headers + thumbnail + jpeg image ...
        //
        else if (dwWhichAttr == BDY0)
            {
            // This is a PUT.
            ASSERT(*pdwBftpOp == BFTP_PUT);
            *ppPutData = pAttr->Value;
            *pdwPutDataSize = dwBftpDataSize - (DWORD)(pAttr->Value - pBftpData);
            }
        //
        // Long file name:
        //
        else if (dwWhichAttr == LFL0)
            {
            if (m_pszLongFileName)
                {
                FreeMemory(m_pszLongFileName);
                }

            dwLength = BftpValueLength(pAttr->Length);
            m_pszLongFileName = (CHAR*)AllocateMemory(1+dwLength);
            if (!m_pszLongFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            memcpy(m_pszLongFileName,pAttr->Value,dwLength);
            m_pszLongFileName[dwLength] = 0;

            CHAR *pszLongFileName = strrchr(m_pszLongFileName,'\\');
            if (pszLongFileName)
                {
                pszLongFileName++;  // Skip over the file separator...
                }
            else
                {
                pszLongFileName = m_pszLongFileName;
                }

            dwLength = strlen(pszLongFileName);

            if (m_pszSaveFileName)
                {
                FreeMemory(m_pszSaveFileName);
                }

            dwSaveLength = sizeof(CHAR)*(1+dwLength) + sizeof(SZ_JPEG);
            m_pszSaveFileName = (CHAR*)AllocateMemory(dwSaveLength);
            if (!m_pszSaveFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            // File name is now XXXXXX.JPG. Change to
            // XXXXXX.JPEG or XXXXXX.UPF as appropriate:
            CHAR *psz = strrchr(m_pszSaveFileName,PERIOD);
            if (psz)
                {
                *psz = 0;
                }

            if (fSaveAsUPF)
                {
                strcat(m_pszSaveFileName,SZ_UPF);
                }
            else
                {
                strcat(m_pszSaveFileName,SZ_JPEG);
                }

            #ifdef DBG_IO
            WIAS_TRACE((g_hInst,"CSCEP_CONNECTION::ParseBftp(): File: %s", m_pszSaveFileName));
            #endif
            }
        //
        // Create Date/Time:
        //
        else if (dwWhichAttr == TIM0)
            {
            dwLength = BftpValueLength(pAttr->Length);

            SaveBftpCreateDate(pAttr->Value,dwLength);

            #ifdef DBG_DATE
            pszTemp = (char*)AllocateMemory(1+dwLength);
            if (pszTemp)
                {
                memcpy(pszTemp,pAttr->Value,dwLength);
                pszTemp[dwLength] = 0;
                FreeMemory(pszTemp);
                }
            #endif
            }
        //
        // Camera sent back a bFTP error code:
        //
        else if (dwWhichAttr == ERR0)
            {
            *pdwBftpOp = BFTP_ERROR;

            *ppPutData = pAttr->Value;
            *pdwPutDataSize = BftpValueLength(pAttr->Length);

            dwStatus = ByteSwapShort( *((USHORT*)(pAttr->Value)) );
            }

        // BUGBUG: May need to byte swap other attributes as well when
        // the protocol is extended...

        pAttr = pNextAttr;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseUpfHeaders()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseUpfHeaders( IN  UCHAR  *pPutData,
                                         IN  DWORD   dwPutDataSize,
                                         OUT DWORD  *pdwJpegOffset,
                                         OUT DWORD  *pdwJpegSize )
    {
    DWORD   dwStatus = NO_ERROR;
    DWORD   dwStartAddress;
    DWORD   dwDataSize;
    INT     iGmtOffset = 0;
    WORD    wYear;
    WORD    wMonth;
    WORD    wDay;
    SYSTEMTIME  SystemTime;
    FILETIME    LocalTime;
    FILETIME    FileTime;
    UPF_HEADER *pUpfHeader;
    UPF_ENTRY  *pUpfEntry1;
    UPF_ENTRY  *pUpfEntry2;
    PICTURE_INFORMATION_DATA *pThumbnailInfo = 0;
    PICTURE_INFORMATION_DATA *pPictureInfo = 0;

    ASSERT(dwPutDataSize >= UPF_TOTAL_HEADER_SIZE);

    if (!pPutData)
        {
        *pdwJpegOffset = 0;
        *pdwJpegSize = 0;
        return ERROR_BFTP_INVALID_PROTOCOL;
        }

    pUpfHeader = (UPF_HEADER*)pPutData;

    pUpfEntry1 = (UPF_ENTRY*)(UPF_HEADER_SIZE + (UCHAR*)pUpfHeader);
    pUpfEntry2 = (UPF_ENTRY*)(UPF_ENTRY_SIZE + (UCHAR*)pUpfEntry1);

    dwStartAddress = ByteSwapLong(pUpfEntry2->dwStartAddress);

    dwDataSize = ByteSwapLong(pUpfEntry2->dwDataSize);

    #ifdef DBG_PROPERTIES
    WIAS_TRACE((g_hInst,"CSCEP_CONNECTION::ParseUpfHeaders(): NumTables: %d", pUpfHeader->NumTables));

    pPictureInfo = (PICTURE_INFORMATION_DATA*)pUpfEntry2->InformationData;

    WIAS_TRACE((g_hInst,"CSCEP_CONNECTION::ParseUpfHeaders(): Rotation: %d", pPictureInfo->RotationSet));
    #endif

    *pdwJpegOffset = UPF_HEADER_SIZE + 4*UPF_ENTRY_SIZE + dwStartAddress;
    *pdwJpegSize = dwDataSize;

    #ifdef UPF_FILES
    *pdwJpegOffset = 0;
    *pdwJpegSize = 0;
    #endif

    // Ok, now parse the picture creation date/time, if one is
    // defined.
    //
    // Note that the date/time is local time, with a GMT offset.
    // Since we will use local system time conversions, we will
    // not need the GMT offset.
    if (pUpfHeader->CreateDate[UPF_GMT_OFFSET] != 0x80)
        {
        iGmtOffset = (pUpfHeader->CreateDate[UPF_GMT_OFFSET])/4;
        }

    memcpy(&wYear,&(pUpfHeader->CreateDate[UPF_YEAR]),sizeof(SHORT) );
    wYear = ByteSwapShort(wYear);

    wMonth = pUpfHeader->CreateDate[UPF_MONTH];
    wDay = pUpfHeader->CreateDate[UPF_DAY];

    // At least the Year/Month/Day must be specified, else we
    // won't use the date. If the Hour/Minute/Second are known,
    // then we will use them as well.
    if ((wYear != 0xffff) && (wMonth != 0xff) && (wDay != 0xff))
        {
        memset(&SystemTime,0,sizeof(SystemTime));
        SystemTime.wYear = wYear;
        SystemTime.wMonth = wMonth;
        SystemTime.wDay = wDay;
        if (pUpfHeader->CreateDate[UPF_HOUR] != 0xff)
            {
            SystemTime.wHour = pUpfHeader->CreateDate[UPF_HOUR];

            if (pUpfHeader->CreateDate[UPF_MINUTE] != 0xff)
                {
                SystemTime.wMinute = pUpfHeader->CreateDate[UPF_MINUTE];

                if (pUpfHeader->CreateDate[UPF_SECOND] != 0xff)
                    {
                    SystemTime.wSecond = pUpfHeader->CreateDate[UPF_SECOND];
                    }
                }
            }


        if (SystemTimeToFileTime(&SystemTime,&LocalTime))
            {
            // 
            // Before we save the date/time, we need to convert it to
            // UTC (its currently in "local time". Note that:
            //
            if (LocalFileTimeToFileTime(&LocalTime,&FileTime))
                { 
                m_CreateTime = FileTime;
                }
            else
                {
                WIAS_ERROR((g_hInst,"IrTranP: SaveBftpCreateDate(): LocalFileTimeToFileTime() Failed: %d",GetLastError()));
                }
            }
        else
            {
            dwStatus = GetLastError();
            WIAS_ERROR((g_hInst,"IrTranP: ParseUpfHeaders(): Invalid Picture Create Date/Time. Status: %d", dwStatus));
            dwStatus = NO_ERROR;
            }
        }
    else
        {
        WIAS_TRACE((g_hInst,"IrTranP: ParseUpfHeaders(): No Picture Create Date/Time."));
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildBftpWht0RinfPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildBftpWht0RinfPdu(
                             OUT SCEP_HEADER          **ppPdu,
                             OUT DWORD                 *pdwPduSize,
                             OUT SCEP_REQ_HEADER_LONG **ppCommand,
                             OUT COMMAND_HEADER       **ppCommandHeader )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_HEADER          *pHeader;
    SCEP_REQ_HEADER_LONG *pCommand;
    COMMAND_HEADER       *pCommandHeader;
    UCHAR                *pUserData;
    USHORT               *pwNumAttributes;
    BFTP_ATTRIBUTE       *pAttrib;

    *ppPdu = 0;
    *pdwPduSize = 0;
    *ppCommand = 0;
    *ppCommandHeader = 0;

    pHeader = NewPdu();  // Size is MAX_PDU_SIZE by default...
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    // This is the total size of the PDU that we will construct:
    DWORD  dwPduSize = sizeof(SCEP_HEADER)
                     + sizeof(SCEP_REQ_HEADER_LONG)
                     + sizeof(USHORT)        // Num Attributes
                     + sizeof(BFTP_ATTRIBUTE)
                     + sizeof(DWORD)
                     + sizeof(BFTP_ATTRIBUTE)
                     + WHT0_ATTRIB_SIZE;

    // Length2 is the total size of the PDU minus the offset+size
    // of Length2:
    USHORT wLength2 = (USHORT)dwPduSize - 6;

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pCommand = (SCEP_REQ_HEADER_LONG*)(pHeader->Rest);
    pCommand->InfType = INF_TYPE_USER_DATA;
    pCommand->Length1 = USE_LENGTH2;           // 0xff
    pCommand->Length2 = wLength2;
    pCommand->InfVersion = INF_VERSION;
    pCommand->DFlag = DFLAG_SINGLE_PDU;
    pCommand->Length3 = pCommand->Length2 - 4; //

    pCommandHeader = (COMMAND_HEADER*)(pCommand->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_REQUEST;
    pCommandHeader->Length4 = pCommand->Length2 - 10;
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    memcpy( pCommandHeader->DestMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pCommandHeader->SrcMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    #ifdef LITTLE_ENDIAN
    pCommand->Length2 = ByteSwapShort(pCommand->Length2);
    pCommand->Length3 = ByteSwapShort(pCommand->Length3);
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    // Setup the bFTP:
    pUserData = pCommand->UserData;
    pwNumAttributes = (USHORT*)pUserData;

    *pwNumAttributes = 2;     // Two bFTP attributes.
    #ifdef LITTLE_ENDIAN
    *pwNumAttributes = ByteSwapShort(*pwNumAttributes);
    #endif
    pUserData += sizeof(*pwNumAttributes);

    // First attribute is CMD0:
    DWORD  dwCmd0AttrValue = CMD0_ATTR_VALUE; // Fixed constant!
    pAttrib = (BFTP_ATTRIBUTE*)pUserData;
    memcpy( pAttrib->Name, Attributes[CMD0].pName, BFTP_NAME_SIZE );
    pAttrib->Length = sizeof(pAttrib->Type)
                    + sizeof(pAttrib->Flag)
                    + sizeof(dwCmd0AttrValue);
    pAttrib->Type = ATTR_TYPE_BINARY;   // 0x00
    pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
    memcpy( pAttrib->Value, &dwCmd0AttrValue, sizeof(dwCmd0AttrValue) );

    #ifdef LITTLE_ENDIAN
    pAttrib->Length = ByteSwapLong(pAttrib->Length);
    #endif

    // Second attribute is WHT0:RINF
    pAttrib = (BFTP_ATTRIBUTE*)(pUserData
                                + sizeof(BFTP_ATTRIBUTE)
                                + sizeof(dwCmd0AttrValue));
    memcpy( pAttrib->Name, Attributes[WHT0].pName, BFTP_NAME_SIZE );
    pAttrib->Length = sizeof(pAttrib->Type)
                    + sizeof(pAttrib->Flag)
                    + WHT0_ATTRIB_SIZE;
    pAttrib->Type = ATTR_TYPE_CHAR;     // 0x00
    pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
    memcpy( pAttrib->Value, SZ_RINF, WHT0_ATTRIB_SIZE );

    #ifdef LITTLE_ENDIAN
    pAttrib->Length = ByteSwapLong(pAttrib->Length);
    #endif


    // Done.
    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;
    *ppCommand = pCommand;
    *ppCommandHeader = pCommandHeader;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildBftpPutPdu()
//
// The PUT command will span multiple PDUs, this function builds the
// Nth fragment. Note that the first will also hold the attributes
// for the UPF file to be sent (in addition to the SCEP header stuff).
//
// Each PDU will also contain (MAX_PDU_SIZE - *pdwPduSize) bytes
// of the UPF file, but that isn't added in here. You add that
// yourself in the PDU starting at *ppCommand->UserData[].
//
// On success, return NO_ERROR, else return a non-zero error code.
//
// dwUpfFileSize   -- The total UPF file size.
//
// pszUpfFile      -- The 8.3 name of the UPF file.
//
// pdwFragNo       -- The fragment number that was built, cycle this
//                    back into each successive call to BuildBftpPutPdu().
//                    Initialize *pdwFragNo to zero before the first
//                    iteration, then leave it alone.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildBftpPutPdu(
                             IN  DWORD             dwUpfFileSize,
                             IN  CHAR             *pszUpfFileName,
                             IN OUT DWORD         *pdwFragNo,
                             OUT SCEP_HEADER     **ppPdu,
                             OUT DWORD            *pdwHeaderSize,
                             OUT SCEP_REQ_HEADER_LONG_FRAG **ppCommand )
    {
    DWORD            dwStatus = NO_ERROR;
    SCEP_HEADER     *pHeader;
    SCEP_REQ_HEADER_LONG_FRAG *pCommand;
    COMMAND_HEADER  *pCommandHeader;
    UCHAR           *pUserData;
    USHORT          *pwNumAttributes;
    BFTP_ATTRIBUTE  *pAttrib;
    DWORD            dwUpfFileNameLength = strlen(pszUpfFileName);


    *ppPdu = 0;
    *pdwHeaderSize = 0;
    *ppCommand = 0;

    pHeader = NewPdu();  // Size is MAX_PDU_SIZE by default...
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    // This is the size of the SCEP (and bFTP) headers part of the
    // PDU that we will construct. dwHeaderSize1 is the header size for
    // the first PDU, dwHeaderSizeN is the header size for the rest of
    // the PDUs. Note that the Nth (N>1) header does not include the
    // COMMAN_HEADER (28 bytes).
    DWORD  dwHeaderSize;
    DWORD  dwHeaderSize1 = sizeof(SCEP_HEADER)
                         + sizeof(SCEP_REQ_HEADER_LONG_FRAG)
                         + sizeof(USHORT)          // Num Attributes
                         + sizeof(BFTP_ATTRIBUTE)  // For CMD0
                         + sizeof(DWORD)
                         + sizeof(BFTP_ATTRIBUTE)  // For FIL0
                         + dwUpfFileNameLength
                         + sizeof(BFTP_ATTRIBUTE); // For BDY0

    DWORD  dwHeaderSizeN = sizeof(SCEP_HEADER)
                         + FIELD_OFFSET(SCEP_REQ_HEADER_LONG_FRAG,CommandHeader);

    DWORD  dwSpace1;       // Space left after the header in PDU #1.
    DWORD  dwSpaceN;       // Space left after the header in the Nth PDU.
    DWORD  dwFileSizeLeft; // File Size minus what will fit in the
                           // first PDU.
    DWORD  dwNumFullPdus;  // Number of "full" PDUs after PDU #1.
    DWORD  dwLastPdu;      // = 1 iff the last PDU is partially full.
    DWORD  dwNumPdus;      // Total number of fragments to hold the file.

    // Figure out which fragment we are on:
    if (*pdwFragNo == 0)
        {
        dwHeaderSize = dwHeaderSize1;
        m_Fragmented = TRUE;
        m_DFlag = DFLAG_FIRST_FRAGMENT;

        // The space in the PDU left after the first and Nth headers:
        dwSpace1 = MAX_PDU_SIZE - dwHeaderSize1;
        dwSpaceN = MAX_PDU_SIZE - dwHeaderSizeN;

        // The number of full PDUs following the first PDU:
        dwFileSizeLeft = dwUpfFileSize - dwSpace1;
        dwNumFullPdus = dwFileSizeLeft / dwSpaceN;

        // See if there is a trailer PDU with remaining data:
        dwLastPdu = ((dwFileSizeLeft % dwSpaceN) > 0)? 1 : 0;

        dwNumPdus = 1 + dwNumFullPdus + dwLastPdu;

        *pdwFragNo = 1;
        m_dwSequenceNo = 0;     // First Seq.No. is 0.
        m_dwRestNo = dwNumPdus; // Rest starts at Total Num. Fragments.
        }
    else
        {
        dwHeaderSize = dwHeaderSizeN;

        *pdwFragNo++;
        m_dwSequenceNo++;
        m_dwRestNo--;

        if (m_dwRestNo == 0)
            {
            return ERROR_BFTP_NO_MORE_FRAGMENTS; // Called to many times...
            }
        else if (m_dwRestNo == 1)
            {
            m_DFlag = DFLAG_LAST_FRAGMENT;
            }
        else
            {
            m_DFlag = DFLAG_FRAGMENT;
            }
        }

    // Length2 is the total size of the PDU minus the offset+size
    // of Length2:
    USHORT wLength2 = (USHORT)(MAX_PDU_SIZE - 6);
    DWORD  dwLength4 = dwUpfFileSize + 22 + 48;
    DWORD  dwBdy0Length = dwUpfFileSize + 2;

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pCommand = (SCEP_REQ_HEADER_LONG_FRAG*)(pHeader->Rest);
    pCommand->InfType = INF_TYPE_USER_DATA;
    pCommand->Length1 = USE_LENGTH2;           // 0xff
    pCommand->Length2 = wLength2;
    pCommand->InfVersion = INF_VERSION;
    pCommand->DFlag = m_DFlag;
    pCommand->Length3 = pCommand->Length2 - 12; //
    pCommand->SequenceNo = m_dwSequenceNo;
    pCommand->RestNo = m_dwRestNo;

    #ifdef LITTLE_ENDIAN
    pCommand->Length2 = ByteSwapShort(pCommand->Length2);
    pCommand->Length3 = ByteSwapShort(pCommand->Length3);
    pCommand->SequenceNo = ByteSwapLong(pCommand->SequenceNo);
    pCommand->RestNo = ByteSwapLong(pCommand->RestNo);
    #endif

    // Note that there is a COMMAND_HEADER in the SCEP header only
    // for the first fragment.
    if (m_DFlag == DFLAG_FIRST_FRAGMENT)
        {
        pCommandHeader = (COMMAND_HEADER*)(pCommand->CommandHeader);
        pCommandHeader->Marker58h = 0x58;
        pCommandHeader->PduType = PDU_TYPE_REQUEST;
        pCommandHeader->Length4 = dwLength4;
        pCommandHeader->DestPid = m_SrcPid;
        pCommandHeader->SrcPid = m_DestPid;
        pCommandHeader->CommandId = (USHORT)m_dwCommandId;

        memcpy( pCommandHeader->DestMachineId,
                m_pPrimaryMachineId,
                MACHINE_ID_SIZE );

        memcpy( pCommandHeader->SrcMachineId,
                m_pSecondaryMachineId,
                MACHINE_ID_SIZE );

        #ifdef LITTLE_ENDIAN
        ByteSwapCommandHeader(pCommandHeader);
        #endif

        // Setup the bFTP:
        pUserData = pCommand->UserData;
        pwNumAttributes = (USHORT*)pUserData;

        *pwNumAttributes = 3;     // Three bFTP attributes.
        #ifdef LITTLE_ENDIAN
        *pwNumAttributes = ByteSwapShort(*pwNumAttributes);
        #endif
        pUserData += sizeof(*pwNumAttributes);

        // First attribute is CMD0:
        DWORD  dwCmd0AttrValue = 0x00000000;
        pAttrib = (BFTP_ATTRIBUTE*)pUserData;
        memcpy( pAttrib->Name, Attributes[CMD0].pName, BFTP_NAME_SIZE );
        pAttrib->Length = sizeof(pAttrib->Type)
                        + sizeof(pAttrib->Flag)
                        + sizeof(ULONG);
        pAttrib->Type = ATTR_TYPE_BINARY;   // 0x00
        pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
        memcpy( pAttrib->Value, &dwCmd0AttrValue, sizeof(dwCmd0AttrValue) );

        #ifdef LITTLE_ENDIAN
        pAttrib->Length = ByteSwapLong(pAttrib->Length);
        #endif

        // Second attribute is FIL0 (with the 8.3 UPF file name):
        pAttrib = (BFTP_ATTRIBUTE*)(pUserData
                                    + sizeof(BFTP_ATTRIBUTE)
                                    + sizeof(dwCmd0AttrValue));
        memcpy( pAttrib->Name, Attributes[FIL0].pName, BFTP_NAME_SIZE );
        pAttrib->Length = sizeof(pAttrib->Type)
                        + sizeof(pAttrib->Flag)
                        + dwUpfFileNameLength;
        pAttrib->Type = ATTR_TYPE_CHAR;     // 0x01
        pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
        memcpy( pAttrib->Value, pszUpfFileName, dwUpfFileNameLength );

        #ifdef LITTLE_ENDIAN
        pAttrib->Length = ByteSwapLong(pAttrib->Length);
        #endif

        // Third attribute is BDY0 (with the value being the whole UPF file):
        pAttrib = (BFTP_ATTRIBUTE*)( (char*)pAttrib
                                   + sizeof(BFTP_ATTRIBUTE)
                                   + dwUpfFileNameLength );
        memcpy( pAttrib->Name, Attributes[BDY0].pName, BFTP_NAME_SIZE );
        pAttrib->Length = dwBdy0Length;
        pAttrib->Type = ATTR_TYPE_BINARY;   // 0x00
        pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
        // pAttrib->Value is not copied in (its the entire UPF file).

        #ifdef LITTLE_ENDIAN
        pAttrib->Length = ByteSwapLong(pAttrib->Length);
        #endif
        }

    // Done.
    *ppPdu = pHeader;
    *pdwHeaderSize = dwHeaderSize;
    *ppCommand = pCommand;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildBftpRespPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildBftpRespPdu(
                             IN  DWORD            dwPduSize,
                             OUT SCEP_HEADER    **ppPdu,
                             OUT SCEP_REQ_HEADER_SHORT **ppCommand,
                             OUT COMMAND_HEADER **ppCommandHeader )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pCommand;
    COMMAND_HEADER        *pCommandHeader;

    *ppPdu = 0;
    *ppCommand = 0;
    *ppCommandHeader = 0;

    pHeader = NewPdu();  // BUGBUG: Use dwPduSize?
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // BUGBUG: Use dwPduSize?

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pCommand = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pCommand->InfType = INF_TYPE_USER_DATA;
    pCommand->Length1 = (UCHAR)dwPduSize - 4;  // Four bytes from the start.
    pCommand->InfVersion = INF_VERSION;
    pCommand->DFlag = DFLAG_SINGLE_PDU;
    pCommand->Length3 = (USHORT)dwPduSize - 8; // Eight bytes from the start.

    #ifdef LITTLE_ENDIAN
    pCommand->Length3 = ByteSwapShort(pCommand->Length3);
    #endif

    pCommandHeader = (COMMAND_HEADER*)(pCommand->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_REPLY_ACK;
    pCommandHeader->Length4 = dwPduSize - 14;  // Twelve bytes from the start.
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    memcpy( pCommandHeader->DestMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pCommandHeader->SrcMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    #ifdef LITTLE_ENDIAN
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    *ppPdu = pHeader;
    *ppCommand = pCommand;
    *ppCommandHeader = pCommandHeader;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildWht0RespPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildWht0RespPdu( IN  DWORD         dwWht0Type,
                                          OUT SCEP_HEADER **ppPdu,
                                          OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    DWORD  dwRespSize;
    DWORD  dwAttrValueSize;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pCommand;
    COMMAND_HEADER        *pCommandHeader;
    UCHAR                 *pQueryResp;
    USHORT                *pUShort;
    BFTP_ATTRIBUTE        *pAttr;
    UCHAR                 *pAttrValue;

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwWht0Type == BFTP_QUERY_RIMG)
        {
        dwRespSize = BFTP_RIMG_RESP_SIZE;
        dwAttrValueSize = BFTP_RIMG_ATTR_VALUE_SIZE;
        pAttrValue = BftpRimgRespAttrValue;
        }
    else if (dwWht0Type == BFTP_QUERY_RINF)
        {
        dwRespSize = BFTP_RINF_RESP_SIZE;
        dwAttrValueSize = BFTP_RINF_ATTR_VALUE_SIZE;
        pAttrValue = BftpRinfRespAttrValue;
        }
    else if (dwWht0Type == BFTP_QUERY_RCMD)
        {
        dwRespSize = BFTP_RCMD_RESP_SIZE;
        dwAttrValueSize = BFTP_RCMD_ATTR_VALUE_SIZE;
        pAttrValue = BftpRcmdRespAttrValue;
        }
    else
        {
        return ERROR_BFTP_INVALID_PROTOCOL;
        }

    dwPduSize = SCEP_HEADER_SIZE
                + SCEP_REQ_HEADER_SHORT_SIZE
                + dwRespSize;

    dwStatus = BuildBftpRespPdu( dwPduSize,
                                 &pHeader,
                                 &pCommand,
                                 &pCommandHeader );

    if (dwStatus == NO_ERROR)
        {
        pQueryResp = pCommand->UserData;

        // Set the number of bFTP attributes:
        pUShort = (USHORT*)pQueryResp;
        *pUShort = 1;
        #ifdef LITTLE_ENDIAN
        *pUShort = ByteSwapShort(*pUShort);
        #endif

        // Set the BDY0 for the query response:
        pAttr = (BFTP_ATTRIBUTE*)(sizeof(USHORT)+pQueryResp);
        memcpy(pAttr->Name,Attributes[BDY0].pName,BFTP_NAME_SIZE);
        pAttr->Length = 2 + dwAttrValueSize;
        pAttr->Type = ATTR_TYPE_BINARY;
        pAttr->Flag = ATTR_FLAG_DEFAULT;
        memcpy(pAttr->Value,pAttrValue,dwAttrValueSize);

        #ifdef LITTLE_ENDIAN
        pAttr->Length = ByteSwapLong(pAttr->Length);
        #endif

        *ppPdu = pHeader;
        *pdwPduSize = dwPduSize;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildPutRespPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildPutRespPdu( IN  DWORD         dwPduAckOrNack,
                                         IN  USHORT        usErrorCode,
                                         OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    DWORD  dwRespSize;
    DWORD  dwFileNameLen;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pCommand;
    COMMAND_HEADER        *pCommandHeader;
    UCHAR                 *pQueryResp;
    USHORT                *pUShort;
    BFTP_ATTRIBUTE        *pAttr;
    UCHAR                 *pAttrValue;

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwPduAckOrNack == PDU_TYPE_REPLY_ACK)
        {
        if (!m_pszFileName)
            {
            return ERROR_BFTP_INVALID_PROTOCOL;
            }

        dwFileNameLen = strlen( (const char *)m_pszFileName );
        dwRespSize = sizeof(USHORT) + sizeof(BFTP_ATTRIBUTE) + dwFileNameLen;
        }
    else
        {
        dwRespSize = sizeof(USHORT) + sizeof(BFTP_ATTRIBUTE) + sizeof(USHORT);
        }

    dwPduSize = SCEP_HEADER_SIZE
                + SCEP_REQ_HEADER_SHORT_SIZE
                + dwRespSize;

    dwStatus = BuildBftpRespPdu( dwPduSize,
                                 &pHeader,
                                 &pCommand,
                                 &pCommandHeader );

    if (dwStatus == NO_ERROR)
        {
        pQueryResp = pCommand->UserData;

        // Set the number of bFTP attributes:
        pUShort = (USHORT*)pQueryResp;
        *pUShort = 1;
        #ifdef LITTLE_ENDIAN
        *pUShort = ByteSwapShort(*pUShort);
        #endif

        pAttr = (BFTP_ATTRIBUTE*)(sizeof(USHORT)+pQueryResp);

        if (dwPduAckOrNack == PDU_TYPE_REPLY_ACK)
            {
            // Set the RPL0 for the put response (ACK):
            memcpy(pAttr->Name,Attributes[RPL0].pName,BFTP_NAME_SIZE);
            pAttr->Length = 2 + dwFileNameLen;
            pAttr->Type = ATTR_TYPE_CHAR;
            pAttr->Flag = ATTR_FLAG_DEFAULT;
            memcpy(pAttr->Value,m_pszFileName,dwFileNameLen);
            }
        else
            {
            // Nack the PUT:
            pCommandHeader->PduType = PDU_TYPE_REPLY_NACK;

            // Set the ERR0 for the put response (NACK):
            memcpy(pAttr->Name,Attributes[RPL0].pName,BFTP_NAME_SIZE);
            pAttr->Length = 2 + sizeof(USHORT);
            pAttr->Type = ATTR_TYPE_BINARY;
            pAttr->Flag = ATTR_FLAG_DEFAULT;

            #ifdef LITTLE_ENDIAN
            usErrorCode = ByteSwapShort(usErrorCode);
            #endif
            memcpy(pAttr->Value,&usErrorCode,sizeof(USHORT));
            }

        #ifdef LITTLE_ENDIAN
        pAttr->Length = ByteSwapLong(pAttr->Length);
        #endif

        *ppPdu = pHeader;
        *pdwPduSize = dwPduSize;
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\io.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// io.cpp
//
// Author:
//
//   Edward Reus (edwardr)     02-27-98   Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

#ifdef DBG_MEM
static LONG g_lCIoPacketCount = 0;
#endif

extern HINSTANCE g_hInst;  // ircamera.dll instance.

//--------------------------------------------------------------------
// CIOPACKET::CIOPACKET()
//
//--------------------------------------------------------------------
CIOPACKET::CIOPACKET()
    {
    m_dwKind = PACKET_KIND_LISTEN;

    m_ListenSocket = INVALID_SOCKET;
    m_Socket = INVALID_SOCKET;
    m_hFile = INVALID_HANDLE_VALUE;
    m_pLocalAddr = 0;
    m_pFromAddr = 0;
    m_pAcceptBuffer = 0;
    m_pReadBuffer = 0;
    m_pvWritePdu = 0;
    m_dwReadBufferSize = 0;
    }

//--------------------------------------------------------------------
// CIOPACKET::~CIOPACKET()
//
//--------------------------------------------------------------------
CIOPACKET::~CIOPACKET()
    {
    // NOTE: Don't free m_pLocalAddr or m_pFromAddr, they just point
    // into m_pAcceptBuffer.

    if (m_pAcceptBuffer)
       {
       FreeMemory(m_pAcceptBuffer);
       }

    if (m_pReadBuffer)
       {
       FreeMemory(m_pReadBuffer);
       }

    // NOTE: Don't delete the write PDU (m_pvWritePdu), its free'd by 
    // somebody else (when the IO completes)...
    }

//------------------------------------------------------------------------
//  CIOPACKET::operator new()
//
//------------------------------------------------------------------------
void *CIOPACKET::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    #ifdef DBG_MEM
    if (pObj)
        {
        InterlockedIncrement(&g_lCIoPacketCount);
        }

    WIAS_TRACE((g_hInst,"new CIOPACKET: Count: %d\n",g_lCIoPacketCount));
    #endif

    return pObj;
    }

//------------------------------------------------------------------------
//  CIOPACKET::operator delete()
//
//------------------------------------------------------------------------
void CIOPACKET::operator delete( IN void *pObj,
                                 IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);

        #ifdef DBG_MEM
        if (dwStatus)
            {
            WIAS_TRACE((g_hInst,"IrXfer: IrTran-P: CIOPACKET::delete: FreeMemory Failed: %d\n",dwStatus));
            }

        InterlockedDecrement(&g_lCIoPacketCount);

        if (g_lCIoPacketCount < 0)
            {
            WIAS_TRACE((g_hInst,"IrXfer: IrTran-P: CIOPACKET::delete Count: %d\n",g_lCIoPacketCount));
            }
        #endif
        }
    }

//--------------------------------------------------------------------
// CIOPACKET::Initialize()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::Initialize( IN DWORD  dwKind,
                             IN SOCKET ListenSocket,
                             IN SOCKET Socket,
                             IN HANDLE hIoCP )
    {
    DWORD  dwStatus = NO_ERROR;

    m_dwKind = dwKind;

    if (dwKind == PACKET_KIND_LISTEN)
        {
        // The accept buffer needs to be large enough to hold
        // the "from" and "to" addresses:
        m_pAcceptBuffer = AllocateMemory(2*(16+sizeof(SOCKADDR_IRDA)));
        if (!m_pAcceptBuffer)
            {
            return ERROR_OUTOFMEMORY;
            }
        }

    m_ListenSocket = ListenSocket;
    m_Socket = Socket;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CIOPACKET::PostIoRead()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::PostIoRead()
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwBytes;

    if (!m_pReadBuffer)
        {
        m_pReadBuffer = AllocateMemory(DEFAULT_READ_BUFFER_SIZE);
        m_dwReadBufferSize = DEFAULT_READ_BUFFER_SIZE;

        if (!m_pReadBuffer)
            {
            return ERROR_OUTOFMEMORY;
            }
        }

    memset(&m_Overlapped,0,sizeof(m_Overlapped));

    BOOL b = ReadFile( (HANDLE)m_Socket,
                       m_pReadBuffer,
                       m_dwReadBufferSize,
                       0,  // Can be zero for overlapped IO.
                       &m_Overlapped );

    if (!b)
        {
        dwStatus = GetLastError();
        if ((dwStatus == ERROR_HANDLE_EOF)||(dwStatus == ERROR_IO_PENDING))
            {
            dwStatus = NO_ERROR;
            }
        }

    #ifdef DBG_IO
    WIAS_TRACE((g_hInst,"CIOPACKET::PostIoRead(): ReadFile(): Socket: %d",m_Socket));
    #endif

    return dwStatus;
    }

//--------------------------------------------------------------------
// CIOPACKET::PostIoWrite()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::PostIoWrite( IN void  *pvBuffer,
                              IN DWORD  dwBufferSize,
                              IN DWORD  dwOffset      )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwBytes;
    HANDLE hFile;

    memset(&m_Overlapped,0,sizeof(m_Overlapped));

    if (m_dwKind == PACKET_KIND_WRITE_SOCKET)
        {
        hFile = (HANDLE)m_Socket;
        int iBytes = send(m_Socket,(const char*)pvBuffer,dwBufferSize,0);
        if (iBytes == SOCKET_ERROR)
            {
            dwStatus = WSAGetLastError();

            WIAS_ERROR((g_hInst,"CIOPACKET::PostIoWrite(): send() Failed: Handle: %d Error: %d\n",m_Socket,dwStatus));

            return dwStatus;
            }
        }
    else if (m_dwKind == PACKET_KIND_WRITE_FILE)
        {
        hFile = m_hFile;
        m_Overlapped.Offset = dwOffset;

        DWORD  dwBytesWritten = 0;
        BOOL   b = WriteFile( hFile,
                              pvBuffer,
                              dwBufferSize,
                              &dwBytesWritten,
                              0 );

        if (!b)
            {
            dwStatus = GetLastError();

            WIAS_ERROR((g_hInst,"CIOPACKET::PostIoWrite(): WriteFile() Failed: Handle: %d Error: %d\n",hFile,dwStatus));

            return dwStatus;
            }
        }
    else
        {
        WIAS_TRACE((g_hInst,"CIOPACKET::PostIoWrite(): Invalid m_dwKind: %d.\n",m_dwKind));

        dwStatus = ERROR_INVALID_PARAMETER;
        }

    #ifdef DBG_IO
    WIAS_TRACE((g_hInst,"CIOPACKET::PostIoWrite(): WriteFile(): Handle: %d Bytes: %d\n", hFile, dwBufferSize ));
    #endif

    return dwStatus;
    }

//--------------------------------------------------------------------
// CIOPACKET::PostIo()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::PostIo()
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwBytes;

    if (m_dwKind == PACKET_KIND_LISTEN)
        {
        }
    else if (m_dwKind == PACKET_KIND_READ)
        {
        dwStatus = PostIoRead();
        }
    else
        {
        // Packet writes back to the camera (via socket) and writes to
        // the image (jpeg) file are posted only when data is ready to
        // send...
        WIAS_ASSERT( g_hInst,
                     (m_dwKind == PACKET_KIND_WRITE_SOCKET)
                     || (m_dwKind == PACKET_KIND_WRITE_FILE) );
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\conn.cpp ===
//---------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  conn.cpp
//
//  Connection mapping between sockets and CCONNECTION objects.
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//---------------------------------------------------------------

#include "precomp.h"
#include <userenv.h>
#include <time.h>
#include <malloc.h>
#include <shlwapi.h>

#ifdef DBG_MEM
static LONG g_lCConnectionCount = 0;
#endif

extern HINSTANCE  g_hInst;   // Instance of ircamera.dll

//------------------------------------------------------------------------
//  CCONNECTION::CCONNECTION()
//
//------------------------------------------------------------------------
CCONNECTION::CCONNECTION( IN DWORD             dwKind,
                          IN SOCKET            Socket,
                          IN HANDLE            hIoCP,
                          IN CSCEP_CONNECTION *pScepConnection,
                          IN BOOL              fSaveAsUPF )
    {
    this->SetKind(dwKind);
    m_pszServiceName = 0;
    m_ListenSocket = INVALID_SOCKET;
    m_Socket = Socket;
    m_hFile = INVALID_HANDLE_VALUE;
    m_pszPathPlusFileName = 0;
    m_dwFileBytesWritten = 0;
    m_lPendingReads = 0;
    // m_lMaxPendingReads is set in SetKind().
    m_lPendingWrites = 0;
    // m_lMaxPendingWrites is set in SetKind().
    m_dwJpegOffset = 0;
    m_fSaveAsUPF = fSaveAsUPF;
    m_dwUpfBytes = 0;
    m_dwBytesWritten = 0;
    m_fReceiveComplete = FALSE;
    m_fImpersonating = FALSE;
    m_pScepConnection = pScepConnection;

    // If the new connection is to a camera, then tell the system that
    // we don't want it to hibrenate while the connection is active.
    if (m_dwKind != PACKET_KIND_LISTEN)
        {
        #ifdef USE_WINNT_CALLS
        m_ExecutionState
             = SetThreadExecutionState( ES_SYSTEM_REQUIRED|ES_CONTINUOUS );
        #else
        #pragma message("Missing important call: SetThreadExecutionState  on Windows9x ")
        #endif
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::~CCONNECTION()
//
//------------------------------------------------------------------------
CCONNECTION::~CCONNECTION()
    {
    if (m_pszServiceName)
        {
        FreeMemory(m_pszServiceName);
        }

    if ( (m_dwKind == PACKET_KIND_LISTEN)
       && (m_ListenSocket != INVALID_SOCKET))
        {
        closesocket(m_ListenSocket);
        }

    if (m_Socket != INVALID_SOCKET)
        {
        closesocket(m_Socket);
        }

    if (m_pScepConnection)
        {
        delete m_pScepConnection;
        }

    if (m_hFile != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hFile);
        }

    if (m_pszPathPlusFileName)
        {
        FreeMemory(m_pszPathPlusFileName);
        }

    // Tell the system that it can go to sleep now if it wants
    // to...
    if (m_dwKind != PACKET_KIND_LISTEN)
        {
        #ifdef USE_WINNT_CALLS
        SetThreadExecutionState( m_ExecutionState );
        #else
        #pragma message("Missing important call SetThreadExecutionState on Windows9x ")
        #endif
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::operator new()
//
//------------------------------------------------------------------------
void *CCONNECTION::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CCONNECTION::operator delete()
//
//------------------------------------------------------------------------
void CCONNECTION::operator delete( IN void *pObj,
                                   IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::InitializeForListen()
//
//------------------------------------------------------------------------
DWORD  CCONNECTION::InitializeForListen( IN char  *pszServiceName,
                                         IN BOOL   fIsIrCOMM,
                                         IN HANDLE hIoCP )
    {
    DWORD          dwStatus = NO_ERROR;
    SOCKADDR_IRDA  AddrLocal;
    BYTE           bIASSetBuffer[sizeof(IAS_SET) - 3 + IAS_SET_ATTRIB_MAX_LEN];
    int            iIASSetSize = sizeof(bIASSetBuffer);
    IAS_SET       *pIASSet = (IAS_SET*)bIASSetBuffer;
    int            iEnable9WireMode = 1;


    // Connections are initialized in listen mode:
    SetKind(PACKET_KIND_LISTEN);

    // Save the service name for listen sockets:
    m_pszServiceName = (char*)AllocateMemory(1+strlen(pszServiceName));
    if (m_pszServiceName)
        {
        strcpy(m_pszServiceName,pszServiceName);
        }

    // Create a socket that we will listen on:
    m_ListenSocket = socket(AF_IRDA,SOCK_STREAM,IPPROTO_IP);

    if (m_ListenSocket == INVALID_SOCKET)
        {
        dwStatus = WSAGetLastError();
        #ifdef DBG_ERROR
        WIAS_ERROR((g_hInst,"InitializeForListen(%s): socket() Failed: %d\n",pszServiceName,dwStatus));
        #endif
        return dwStatus;
        }

    // If this is IrCOMM, the we need to do a little extra work.
    if (fIsIrCOMM)
        {
        // Fill in the 9-wire attributes:
        memset(pIASSet,0,iIASSetSize);

        memcpy(pIASSet->irdaClassName,IRCOMM_9WIRE,sizeof(IRCOMM_9WIRE));

        memcpy(pIASSet->irdaAttribName,IRDA_PARAMETERS,sizeof(IRDA_PARAMETERS));

        pIASSet->irdaAttribType = IAS_ATTRIB_OCTETSEQ;
        pIASSet->irdaAttribute.irdaAttribOctetSeq.Len = OCTET_SEQ_SIZE;

        memcpy(pIASSet->irdaAttribute.irdaAttribOctetSeq.OctetSeq,OCTET_SEQ,OCTET_SEQ_SIZE);

        // Add IrCOMM IAS attributes for 3-wire cooked and 9-wire
        // raw modes (see the IrCOMM spec)...
        if (SOCKET_ERROR == setsockopt(m_ListenSocket,
                                       SOL_IRLMP,
                                       IRLMP_IAS_SET,
                                       (const char*)pIASSet,
                                       iIASSetSize))
            {
            dwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            WIAS_TRACE((g_hInst,"InitializeForListen(%s): setsockopt(IRLMP_IAS_SET) Failed: %d",pszServiceName,dwStatus));
            #endif
            closesocket(m_ListenSocket);
            m_ListenSocket = INVALID_SOCKET;
            return dwStatus;
            }

        // Need to enable 9-wire mode before the bind():
        if (SOCKET_ERROR == setsockopt(m_ListenSocket,
                                       SOL_IRLMP,
                                       IRLMP_9WIRE_MODE,
                                       (const char*)&iEnable9WireMode,
                                       sizeof(iEnable9WireMode)))
            {
            dwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            WIAS_TRACE((g_hInst,"InitializeForListen(%s): setsockopt(IRLMP_9WIRE_MODE) Failed: %d",pszServiceName,dwStatus));
            #endif
            closesocket(m_ListenSocket);
            m_ListenSocket = INVALID_SOCKET;
            return dwStatus;
            }
        }

    // Setup the local address for the bind():
    memset(&AddrLocal,0,sizeof(AddrLocal));
    AddrLocal.irdaAddressFamily = AF_IRDA;
    strcpy(AddrLocal.irdaServiceName,pszServiceName);
    // Note: AddrLocal.irdaDeviceID ignored by server applications...

    if (SOCKET_ERROR == bind( m_ListenSocket,
                              (struct sockaddr *)&AddrLocal,
                              sizeof(AddrLocal)) )
        {
        dwStatus = WSAGetLastError();
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
        return dwStatus;
        }

    if (SOCKET_ERROR == listen(m_ListenSocket,2))
        {
        dwStatus = WSAGetLastError();
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
        return dwStatus;
        }

    #ifdef USE_IOCOMPLETION
    //
    // If this is NT, then associate the listen socket with
    // an IO completion port (not supported in Windows98).
    //
    hIoCP = CreateIoCompletionPort( (void*)m_ListenSocket,
                                    hIoCP,
                                    m_ListenSocket,
                                    0 );

    m_hIoCompletionPort = hIoCP;
    #endif

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::PostMoreIos()
//
//------------------------------------------------------------------------
#if FALSE
DWORD CCONNECTION::PostMoreIos( CIOPACKET *pIoPacket )
    {
    DWORD  dwStatus = S_OK;
    LONG   lNumPendingReads;


    while (m_lPendingReads < m_lMaxPendingReads)
        {
        if (!pIoPacket)
            {
            pIoPacket = new CIOPACKET;
            if (!pIoPacket)
                {
                WIAS_ERROR((g_hInst,"new CIOPACKET failed."));
                dwStatus = ERROR_OUTOFMEMORY;
                break;
                }

            dwStatus = pIoPacket->Initialize( GetKind(),
                                              GetListenSocket(),
                                              GetSocket(),
                                              GetIoCompletionPort() );
            }

        dwStatus = pIoPacket->PostIo();
        if (dwStatus != NO_ERROR)
            {
            WIAS_ERROR((g_hInst,"pNewIoPacket->PostIo() failed: %d\n", dwStatus ));
            delete pIoPacket;
            break;
            }

        // Increment the count of the number of pending reads on
        // this connection:
        lNumPendingReads = IncrementPendingReads();
        WIAS_ASSERT(g_hInst,lNumPendingReads > 0);

        pIoPacket = 0;  // don't delete this line... this is a loop...
        }

    return dwStatus;
    }
#endif

//------------------------------------------------------------------------
//  CCONNECTION::SendPdu()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::SendPdu( IN  SCEP_HEADER *pPdu,
                            IN  DWORD        dwPduSize,
                            OUT CIOPACKET  **ppIoPacket )
    {
    DWORD      dwStatus = NO_ERROR;
    CIOPACKET *pIoPacket = new CIOPACKET;

    *ppIoPacket = 0;

    if (!pIoPacket)
        {
        return ERROR_OUTOFMEMORY;
        }

    dwStatus = pIoPacket->Initialize( PACKET_KIND_WRITE_SOCKET,
                                      INVALID_SOCKET,  // ListenSocket
                                      GetSocket(),
                                      GetIoCompletionPort() );
    if (dwStatus != NO_ERROR)
        {
        delete pIoPacket;
        return dwStatus;
        }

    dwStatus = pIoPacket->PostIoWrite(pPdu,dwPduSize,0);

    delete pIoPacket;

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::ShutdownSocket()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::ShutdownSocket()
    {
    this->CloseSocket();

    return NO_ERROR;
    }

//------------------------------------------------------------------------
//  CCONNECTION::CloseSocket()
//
//------------------------------------------------------------------------
void CCONNECTION::CloseSocket()
    {
    if (m_Socket != INVALID_SOCKET)
        {
        closesocket(m_Socket);
        m_Socket = INVALID_SOCKET;
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::CloseListenSocket()
//
//------------------------------------------------------------------------
void CCONNECTION::CloseListenSocket()
    {
    if (m_ListenSocket != INVALID_SOCKET)
        {
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::CleanupDateString()
//
//  Make sure that the specified date string doesn't contain any slashes
//  which could be confused as subdirectories if the date is used as part
//  of a path.
//------------------------------------------------------------------------
void CCONNECTION::CleanupDateString( IN OUT CHAR *pszDateStr )
    {
    if (pszDateStr)
        {
        while (*pszDateStr)
            {
            if ((*pszDateStr == '/') || (*pszDateStr == '\\'))
                {
                *pszDateStr = '-';
                }
            else if (*pszDateStr < 30)
                {
                *pszDateStr = '_';
                }

            pszDateStr++;
            }
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::ConstructPicturesSubDirectory()
//
//  Generate the path for the directory where pictures will be stored
//  in.
//
//  The return path string should be free'd using FreeMemory().
//------------------------------------------------------------------------
char *CCONNECTION::ConstructPicturesSubDirectory( IN DWORD dwExtraChars )
    {
    char *pszTempDirectory = 0;

    char *psz = ::GetImageDirectory();

    if (psz)
        {
        pszTempDirectory = (char*)AllocateMemory( strlen(psz)
                                                + dwExtraChars
                                                + 2 );
        }

    if (pszTempDirectory)
        {
        strcpy(pszTempDirectory,psz);
        }

    // Don't try to free psz !!.

    return pszTempDirectory;
    }

//------------------------------------------------------------------------
//  CCONNECTION::ConstructFullFileName()
//
//  Generate the path + file name that the picture will be stored
//  in. If dwCopyCount is zero, then its just a straight file name.
//  If dwCopyCount is N, then "N_" is prefixed to the file name.
//------------------------------------------------------------------------
CHAR *CCONNECTION::ConstructFullFileName( IN DWORD dwCopyCount )
    {
#   define MAX_DATE   64
#   define MAX_PREFIX 64
    DWORD  dwLen;
    DWORD  dwFileNameLen;
    DWORD  dwPrefixStrLen;
    DWORD  dwExtraChars;
    CHAR  *pszFullFileName = 0;      // Path + file name.
    CHAR  *pszFileName = 0;          // File name only.
    CHAR   szPrefixStr[MAX_PREFIX];

    if (!m_pScepConnection)
        {
        return 0;
        }

    pszFileName = m_pScepConnection->GetFileName();
    if (!pszFileName)
        {
        return 0;
        }

    dwFileNameLen = strlen(pszFileName);

    if (dwCopyCount == 0)
        {
        dwExtraChars = 1 + dwFileNameLen;  // Extra 1 for the "\".
        }
    else
        {
        _itoa(dwCopyCount,szPrefixStr,10);
        strcat(szPrefixStr,SZ_UNDERSCORE);
        dwPrefixStrLen = strlen(szPrefixStr);
        dwExtraChars = 1 + dwFileNameLen + dwPrefixStrLen;
        }


    pszFullFileName = CCONNECTION::ConstructPicturesSubDirectory(dwExtraChars);
    if (!pszFullFileName)
        {
        return 0;
        }

    if (dwCopyCount == 0)
        {
        strcat(pszFullFileName,SZ_SLASH);
        strcat(pszFullFileName,pszFileName);
        }
    else
        {
        strcat(pszFullFileName,SZ_SLASH);
        strcat(pszFullFileName,szPrefixStr);
        strcat(pszFullFileName,pszFileName);
        }

    #ifdef DBG_IO
    WIAS_TRACE((g_hInst,"CCONNECTION::ConstructFullFileName(): return: %s",pszFullFileName));
    #endif

    return pszFullFileName;
    }

//------------------------------------------------------------------------
//  CCONNECTION::Impersonate()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::Impersonate()
    {
    DWORD   dwStatus = NO_ERROR;
    HANDLE  hToken = ::GetUserToken();

    if (hToken)
        {
        if (!ImpersonateLoggedOnUser(hToken))
            {
            dwStatus = GetLastError();
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"IrXfer: IrTran-P: CreatePictureFile(): Impersonate Failed: %d\n",dwStatus));
            #endif
            }
        else
            {
            m_fImpersonating = TRUE;
            #ifdef DBG_IMPERSONATE
            WIAS_ERROR((g_hInst,"CCONNECTION::Impersonate(): Impersonate\n"));
            #endif
            }
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::RevertToSelf()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::RevertToSelf()
    {
    DWORD   dwStatus = NO_ERROR;
    HANDLE  hToken = ::GetUserToken();

    if ((hToken) && (m_fImpersonating))
        {
        ::RevertToSelf();
        m_fImpersonating = FALSE;
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::CreatePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::CreatePictureFile()
    {
    DWORD  dwStatus = NO_ERROR;
    CHAR  *pszFile;
    CHAR  *pszPathPlusFileName = 0;
    DWORD  dwFlags = FILE_ATTRIBUTE_NORMAL;

    // Make sure that the counters start at zero:
    m_dwUpfBytes = 0;
    m_dwBytesWritten = 0;

    // See if we already have an image file open, if yes then
    // close it.
    if (m_hFile != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hFile);
        }

    // Get the full path + name for the file we will create.
    // Note, that ConstructFullFileName() may create a subdirectory,
    // so it needs to be done after the impersonation...
    // This is important if we have a remoted \My Documents\
    // directory.

    DWORD  dwCopyCount;
    for (dwCopyCount=0; dwCopyCount<=MAX_COPYOF_TRIES; dwCopyCount++)
        {
        pszPathPlusFileName = ConstructFullFileName(dwCopyCount);
        if (!pszPathPlusFileName)
            {
            return ERROR_SCEP_CANT_CREATE_FILE;
            }

        //
        // Try to create new image (JPEG) file:
        //
        m_hFile = CreateFile( pszPathPlusFileName,
                              GENERIC_WRITE,
                              FILE_SHARE_READ, // Share mode.
                              0,               // Security attr (BUGBUG).
                              CREATE_NEW,      // Open mode.
                              dwFlags,         // Attributes.
                              0 );             // Template file (none).

        if (m_hFile != INVALID_HANDLE_VALUE)
            {
            // This is the success exit point.
            m_pszPathPlusFileName = pszPathPlusFileName;
            break;
            }
        else
            {
            dwStatus = GetLastError();
            if (dwStatus != ERROR_FILE_EXISTS)
                {
                #ifdef DBG_TARGET_DIR
                WIAS_ERROR((g_hInst,"CCONNECTION::CreatePictureFile(): CreateFile(): %s Failed: %d",pszPathPlusFileName,dwStatus));
                #endif
                FreeMemory(pszPathPlusFileName);
                break;
                }

            // If we get here, then then a picture file by that name
            // alreay exists, so try again...
            FreeMemory(pszPathPlusFileName);
            }
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::SetPictureFileTime()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::SetPictureFileTime( IN FILETIME *pFileTime )
    {
    DWORD dwStatus = NO_ERROR;

    if (!pFileTime)
        {
        return dwStatus;  // Empty case, no time to set.
        }

    if (!SetFileTime(m_hFile,pFileTime,pFileTime,pFileTime))
        {
        dwStatus = GetLastError();

        WIAS_ERROR((g_hInst,"IrTranP: SetFileTime() Failed: %d",dwStatus));
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::WritePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::WritePictureFile( IN  UCHAR       *pBuffer,
                                     IN  DWORD        dwBufferSize,
                                     OUT CIOPACKET  **ppIoPacket )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwOffset = m_dwBytesWritten;
    DWORD  dwBytesToWrite;
    LONG   lPendingWrites;

    *ppIoPacket = 0;

    CIOPACKET *pIoPacket = new CIOPACKET;

    if (!pIoPacket)
        {
        return ERROR_OUTOFMEMORY;
        }

    dwStatus = pIoPacket->Initialize( PACKET_KIND_WRITE_FILE,
                                      INVALID_SOCKET,  // ListenSocket
                                      INVALID_SOCKET,  // Camera...
                                      GetIoCompletionPort() );
    if (dwStatus != NO_ERROR)
        {
        delete pIoPacket;
        return dwStatus;
        }

    pIoPacket->SetFileHandle(m_hFile);

    //
    // If we are writing just the JPEG image out of the UPF file,
    // then we don't want to write the first m_dwJpegOffset bytes
    // of the UPF file.
    //
    if ((m_dwUpfBytes >= m_dwJpegOffset) || (m_fSaveAsUPF))
        {
        dwBytesToWrite = dwBufferSize;
        }
    else if ((m_dwUpfBytes + dwBufferSize) > m_dwJpegOffset)
        {
        dwBytesToWrite = (m_dwUpfBytes + dwBufferSize) - m_dwJpegOffset;
        for (DWORD i=0; i<dwBytesToWrite; i++)
            {
            pBuffer[i] = pBuffer[i+m_dwJpegOffset-m_dwUpfBytes];
            }
        }
    else
        {
        dwBytesToWrite = 0;
        }

    //
    // When we start writing the JPEG file we want to cut off the
    // file save writes once we've written out the m_dwJpegSize
    // bytes that are the JPEG image inside of the UPF file.
    //
    if (!m_fSaveAsUPF)
        {
        if (m_dwBytesWritten < m_dwJpegSize)
            {
            if ((m_dwBytesWritten+dwBytesToWrite) > m_dwJpegSize)
                {
                dwBytesToWrite = m_dwJpegSize - m_dwBytesWritten;
                }
            }
        else
            {
            dwBytesToWrite = 0;
            }
        }

    //
    // If there are bytes to actually write, then let's do it.
    //
    if (dwBytesToWrite > 0)
        {
        dwStatus = pIoPacket->PostIoWrite(pBuffer,dwBytesToWrite,dwOffset);

        if (dwStatus == NO_ERROR)
            {
            lPendingWrites = IncrementPendingWrites();
            WIAS_ASSERT(g_hInst, lPendingWrites > 0 );

            m_dwBytesWritten += dwBytesToWrite;

            *ppIoPacket = pIoPacket;
            }
        }

    delete pIoPacket;

    m_dwUpfBytes += dwBufferSize;

    return dwStatus;
    }


//------------------------------------------------------------------------
//  CCONNECTION::DeletePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::DeletePictureFile()
    {
    DWORD  dwStatus = NO_ERROR;

    if (m_hFile == INVALID_HANDLE_VALUE)
        {
        return NO_ERROR;
        }

    CloseHandle(m_hFile);
    m_hFile = INVALID_HANDLE_VALUE;

    if (m_pszPathPlusFileName)
        {
        DeleteFile(m_pszPathPlusFileName);
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::ClosePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::ClosePictureFile()
    {
    DWORD  dwStatus = NO_ERROR;

#if FALSE
    if (m_pszPathPlusFileName)
        {
        FreeMemory(m_pszPathPlusFileName);
        m_pszPathPlusFileName = 0;
        }
#endif

    if (m_hFile != INVALID_HANDLE_VALUE)
        {
        if (!CloseHandle(m_hFile))
            {
            dwStatus = GetLastError();
            }

        m_hFile = INVALID_HANDLE_VALUE;
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::IncompleteFile()
//
//  Check to see if we have a complete picture file, if yes, then return
//  FALSE, else return TRUE.
//------------------------------------------------------------------------
BOOL CCONNECTION::IncompleteFile()
    {
    BOOL  fIncomplete = FALSE;

    if (m_fSaveAsUPF)
        {
        // Note: currently save the .UPF file, even if its incomplete.
        // This file mode is set in the registry and is for testing
        // only...
        fIncomplete = FALSE;
        }
    else if (!m_fReceiveComplete)
        {
        fIncomplete = (m_dwBytesWritten < m_dwJpegSize);
        }

    return fIncomplete;
    }

//------------------------------------------------------------------------
//  CCONNECTION::StartProgress()
//
//  Startup the progress bar for the incomming JPEG.
//------------------------------------------------------------------------
DWORD CCONNECTION::StartProgress()
    {
    DWORD  dwStatus = 0;

    if (!m_pIrProgress)
        {
        m_pIrProgress = new CIrProgress;

        if (m_pIrProgress)
            {
            dwStatus = m_pIrProgress->Initialize(g_hInst,IDR_TRANSFER_AVI);
            }
        else
            {
            return E_OUTOFMEMORY;
            }
        }

    if (m_pIrProgress)
        {
        dwStatus = m_pIrProgress->StartProgressDialog();
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::UpdateProgress()
//
//  Update the progress bar's completion display.
//------------------------------------------------------------------------
DWORD CCONNECTION::UpdateProgress()
    {
    DWORD  dwStatus = 0;

    if (m_pIrProgress)
        {
        dwStatus = m_pIrProgress->UpdateProgressDialog( m_dwBytesWritten,
                                                        m_dwJpegSize );
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::EndProgress()
//
//  File transfer complete, hide the progress bar.
//------------------------------------------------------------------------
DWORD CCONNECTION::EndProgress()
    {
    DWORD  dwStatus = 0;

    if (m_pIrProgress)
        {
        dwStatus = m_pIrProgress->EndProgressDialog();

        delete m_pIrProgress;

        m_pIrProgress = NULL;
        }

    return dwStatus;
    }


//************************************************************************


//------------------------------------------------------------------------
//  CCONNECTION_MAP::CCONNECTION_MAP()
//
//------------------------------------------------------------------------
CCONNECTION_MAP::CCONNECTION_MAP()
    {
    m_dwMapSize = 0;
    m_pMap = 0;

    ZeroMemory(&m_cs, sizeof(m_cs));
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::~CCONNECTION_MAP()
//
//------------------------------------------------------------------------
CCONNECTION_MAP::~CCONNECTION_MAP()
    {
    if (m_pMap)
        {
        DeleteCriticalSection(&m_cs);
        FreeMemory(m_pMap);
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::operator new()
//
//------------------------------------------------------------------------
void *CCONNECTION_MAP::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::operator delete()
//
//------------------------------------------------------------------------
void CCONNECTION_MAP::operator delete( IN void *pObj,
                                       IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Initialize()
//
//------------------------------------------------------------------------
BOOL CCONNECTION_MAP::Initialize( IN DWORD dwNewMapSize )
    {
    if (!dwNewMapSize)
        {
        return FALSE;
        }

    if (!m_dwMapSize)
        {
        m_pMap = (CONNECTION_MAP_ENTRY*)AllocateMemory( dwNewMapSize*sizeof(CONNECTION_MAP_ENTRY) );
        if (!m_pMap)
            {
            return FALSE;
            }

        __try
            {
            if(!InitializeCriticalSectionAndSpinCount(&m_cs, MINLONG))
                {
                FreeMemory(m_pMap);
                m_pMap = NULL;
                return FALSE;
                }
            }
        __except(EXCEPTION_EXECUTE_HANDLER)
            {
                FreeMemory(m_pMap);
                m_pMap = NULL;
                return FALSE;
            }

        m_dwMapSize = dwNewMapSize;

        memset(m_pMap,0,m_dwMapSize*sizeof(CONNECTION_MAP_ENTRY));

        for (DWORD i=0; i<m_dwMapSize; i++)
            {
            m_pMap[i].Socket = INVALID_SOCKET;
            }
        }

    return TRUE;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Lookup()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::Lookup( IN SOCKET Socket )
    {
    DWORD     i;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket == Socket)
            {
            LeaveCriticalSection(&m_cs);
            return m_pMap[i].pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::LookupByServiceName()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::LookupByServiceName( IN char *pszServiceName )
    {
    DWORD        i;
    CCONNECTION *pConnection;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        pConnection = m_pMap[i].pConnection;
        if (  (pConnection)
           && (pConnection->GetServiceName())
           && (!strcmp(pConnection->GetServiceName(),pszServiceName)))
            {
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Add()
//
//------------------------------------------------------------------------
BOOL CCONNECTION_MAP::Add( IN CCONNECTION *pConnection,
                           IN SOCKET       Socket )
    {
    DWORD   i;

    // Only add entries that look valid...
    if ((Socket == 0)||(Socket==INVALID_SOCKET)||(pConnection == 0))
        {
        return FALSE;
        }

    EnterCriticalSection(&m_cs);

    // Look for an empty place in the table:
    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket == INVALID_SOCKET)
            {
            m_pMap[i].Socket = Socket;
            m_pMap[i].pConnection = pConnection;
            LeaveCriticalSection(&m_cs);
            return TRUE;
            }
        }

    // The table is full, expand it...
    DWORD  dwNewMapSize = 3*m_dwMapSize/2;   // 50% bigger.
    CONNECTION_MAP_ENTRY *pMap = (CONNECTION_MAP_ENTRY*)AllocateMemory( dwNewMapSize*sizeof(CONNECTION_MAP_ENTRY) );

    if (!pMap)
        {
        LeaveCriticalSection(&m_cs);
        return FALSE;  // Out of memory...
        }

    memset(pMap,0,dwNewMapSize*sizeof(CONNECTION_MAP_ENTRY));
    for (i=0; i<dwNewMapSize; i++)
        {
        pMap[i].Socket = INVALID_SOCKET;
        }

    for (i=0; i<m_dwMapSize; i++)
        {
        pMap[i].Socket = m_pMap[i].Socket;
        pMap[i].pConnection = m_pMap[i].pConnection;
        }

    pMap[i].Socket = Socket;
    pMap[i].pConnection = pConnection;

    FreeMemory(m_pMap);
    m_pMap = pMap;
    m_dwMapSize = dwNewMapSize;

    LeaveCriticalSection(&m_cs);

    return TRUE;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Remove()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::Remove( IN SOCKET Socket )
    {
    DWORD        i;
    CCONNECTION *pConnection;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket == Socket)
            {
            pConnection = m_pMap[i].pConnection;
            m_pMap[i].Socket = INVALID_SOCKET;
            m_pMap[i].pConnection = 0;
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
}

//------------------------------------------------------------------------
//  CCONNECTION_MAP::RemoveConnection()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::RemoveConnection( IN CCONNECTION *pConnection )
    {
    DWORD     i;
    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].pConnection == pConnection)
            {
            m_pMap[i].Socket = INVALID_SOCKET;
            m_pMap[i].pConnection = 0;
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
}

//------------------------------------------------------------------------
//  CCONNECTION_MAP::RemoveNext()
//
//  Walk through the connection map and get the next entry, remove the
//  entry from the map as well.
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::RemoveNext()
    {
    DWORD        i;
    CCONNECTION *pConnection;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket)
            {
            pConnection = m_pMap[i].pConnection;
            m_pMap[i].Socket = INVALID_SOCKET;
            m_pMap[i].pConnection = 0;
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::ReturnNext()
//
//  Walk through the connection map returning the next entry. To start at
//  the "begining", pass in state equal zero. When you get to the end of
//  the list of connections, return NULL;
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::ReturnNext( IN OUT DWORD *pdwState )
    {
    CCONNECTION  *pConnection = NULL;
    EnterCriticalSection(&m_cs);

    if (*pdwState >= m_dwMapSize)
        {
        LeaveCriticalSection(&m_cs);
        return NULL;
        }

    while ((pConnection == NULL) && (*pdwState < m_dwMapSize))
        {
        pConnection = m_pMap[(*pdwState)++].pConnection;
        }

    LeaveCriticalSection(&m_cs);

    return pConnection;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::ReturnNextSocket()
//
//  Walk through the connection map returning the SOCKET associated with
//  the next entry. To start at the "begining", pass in state equal zero.
//  When you get to the end of the list of connections, return
//  INVALID_SOCKET.
//------------------------------------------------------------------------
SOCKET CCONNECTION_MAP::ReturnNextSocket( IN OUT DWORD *pdwState )
    {
    SOCKET  Socket = INVALID_SOCKET;
    EnterCriticalSection(&m_cs);

    if (*pdwState >= m_dwMapSize)
        {
        LeaveCriticalSection(&m_cs);
        return INVALID_SOCKET;
        }

    while ((Socket == INVALID_SOCKET) && (*pdwState < m_dwMapSize))
        {
        Socket = m_pMap[(*pdwState)++].Socket;
        }

    LeaveCriticalSection(&m_cs);

    return Socket;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\conn.h ===
//---------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  conn.h
//
//  Connection mapping between sockets and CCONNECTION objects.
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//---------------------------------------------------------------

#ifndef __CONN_HXX__
#define __CONN_HXX__

#define  MAX_MAP_ENTRIES        16

//---------------------------------------------------------------
//  Class CCONNECTION
//---------------------------------------------------------------

class CCONNECTION
{
public:
    // CCONNECTION();
    CCONNECTION( DWORD  dwKind = PACKET_KIND_LISTEN,
                 SOCKET Socket = 0,
                 HANDLE hIoCP  = INVALID_HANDLE_VALUE,
                 CSCEP_CONNECTION *pScepConnection = 0,
                 BOOL   fSaveAsUPF = FALSE );

    ~CCONNECTION();

    void   *operator new( IN size_t Size );

    void    operator delete( IN void   *pObj,
                             IN size_t  Size );

    DWORD   InitializeForListen( IN char  *pszServiceName,
                                 IN BOOL   fIsIrCOMM,
                                 IN HANDLE hIoCP );

    char   *GetServiceName();
    char   *GetPathPlusFileName();

    void    SetKind( DWORD dwKind );
    DWORD   GetKind();

    void    SetSocket( SOCKET Socket );
    SOCKET  GetSocket();
    DWORD   ShutdownSocket();
    void    CloseSocket();

    void    SetListenSocket( SOCKET ListenSocket );
    SOCKET  GetListenSocket();
    void    CloseListenSocket();

    void    SetIoCompletionPort( HANDLE hIoCP );
    HANDLE  GetIoCompletionPort();

    void    SetScepConnection( CSCEP_CONNECTION *pScepConnection );
    CSCEP_CONNECTION *GetScepConnection();

    void    SetJpegOffsetAndSize( DWORD dwOffset,
                                  DWORD dwSize );

    LONG    IncrementPendingReads();
    LONG    DecrementPendingReads();

    LONG    IncrementPendingWrites();
    LONG    DecrementPendingWrites();

    LONG    NumPendingIos();

    DWORD   PostMoreIos( CIOPACKET *pIoPacket = NULL );

    DWORD   SendPdu( IN  SCEP_HEADER *pPdu,
                     IN  DWORD        dwPduSize,
                     OUT CIOPACKET  **ppIoPacket );

    static  char  *ConstructPicturesSubDirectory( IN DWORD dwExtraChars = 0 );

    char   *ConstructFullFileName( IN DWORD dwCopyCount );

    BOOL    CheckSaveAsUPF();

    DWORD   Impersonate();

    DWORD   RevertToSelf();

    DWORD   CreatePictureFile();

    DWORD   SetPictureFileTime( IN FILETIME *pFileTime );

    DWORD   WritePictureFile( IN  UCHAR      *pBuffer,
                              IN  DWORD       dwBufferSize,
                              OUT CIOPACKET **ppIoPacket );

    DWORD   DeletePictureFile();
    DWORD   ClosePictureFile();
    BOOL    IncompleteFile();

    void    SetReceiveComplete( IN BOOL fReceiveComplete );

    DWORD   StartProgress();
    DWORD   UpdateProgress();
    DWORD   EndProgress();

private:
    static void CleanupDateString( IN OUT char *pszDateStr );

    DWORD  m_dwKind;
    char  *m_pszServiceName;   // Service name (for Listen Sockets).
    SOCKET m_ListenSocket;
    SOCKET m_Socket;
    HANDLE m_hFile;
    char  *m_pszPathPlusFileName;
    DWORD  m_dwFileBytesWritten;
    LONG   m_lMaxPendingReads;
    LONG   m_lPendingReads;
    LONG   m_lMaxPendingWrites;
    LONG   m_lPendingWrites;
    DWORD  m_dwJpegOffset;     // Offset in UPF file of JPEG image.
    DWORD  m_dwJpegSize;       // Size of JPEG image in UPF file.
    BOOL   m_fSaveAsUPF;       // If TRUE, write the entire UPF file.
    DWORD  m_dwUpfBytes;       // Total UPF bytes read in from Camera.
    DWORD  m_dwBytesWritten;   // Actual number of bytes written to disk.
    BOOL   m_fReceiveComplete; // Set to TRUE when a SCEP disconnect 
                               //   packet is received from the camera.
    BOOL   m_fImpersonating;   // TRUE iff we are currently impersonating.

    CIrProgress      *m_pIrProgress;     // Progress bar during receive.
    CSCEP_CONNECTION *m_pScepConnection; // SCEP protocol object.

    EXECUTION_STATE   m_ExecutionState;  // Use to tell the system not to
                                         // hibernate during file transfer.
};

//---------------------------------------------------------------
//  Class CCONNECTION_MAP
//---------------------------------------------------------------

typedef struct _CONNECTION_MAP_ENTRY
{
    SOCKET       Socket;
    CCONNECTION *pConnection;
} CONNECTION_MAP_ENTRY;

class CCONNECTION_MAP
{
public:

	CCONNECTION_MAP();
	~CCONNECTION_MAP();

    void *operator new( IN size_t Size );

    void  operator delete( IN void   *pObj,
                           IN size_t  Size );

	BOOL  Initialize( DWORD dwMapSize = MAX_MAP_ENTRIES );

	// Lookup
	CCONNECTION *Lookup( IN SOCKET Socket );

    // Lookup Connection by name:
    CCONNECTION *LookupByServiceName( IN char *pszServiceName );

	// Add a new (value,key) pair
    BOOL Add( IN CCONNECTION *pConnection,
              IN SOCKET       Socket );

    // Remove an entry from the mapping
    CCONNECTION *Remove( IN SOCKET Socket );
    CCONNECTION *RemoveConnection( IN CCONNECTION *pConnection );

    // Remove the "next" entry from the mapping
    CCONNECTION *RemoveNext();

    // Walk through all the connections (set State to 0 for "first").
    CCONNECTION *ReturnNext( IN OUT DWORD *pdwState );
    SOCKET       ReturnNextSocket( IN OUT DWORD *pdwState );

private:
    CRITICAL_SECTION      m_cs;
    DWORD                 m_dwMapSize;
    CONNECTION_MAP_ENTRY *m_pMap;
};

//---------------------------------------------------------------
//  CCONNECTION::GetServiceName()
//---------------------------------------------------------------
inline char *CCONNECTION::GetServiceName()
    {
    return m_pszServiceName;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetPathPlusFileName()
//---------------------------------------------------------------
inline char *CCONNECTION::GetPathPlusFileName()
    {
    return m_pszPathPlusFileName;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetKind()
//---------------------------------------------------------------
inline void CCONNECTION::SetKind( DWORD dwKind )
    {
    m_dwKind = dwKind;
    if (m_dwKind == PACKET_KIND_LISTEN)
       {
       m_lMaxPendingReads = MAX_PENDING_LISTEN;
       }
    else if (m_dwKind == PACKET_KIND_READ)
       {
       m_lMaxPendingReads = MAX_PENDING_READ;
       }
    }

//---------------------------------------------------------------
//  CCONNECTION::GetKind()
//---------------------------------------------------------------
inline DWORD CCONNECTION::GetKind()
    {
    return m_dwKind;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetSocket()
//---------------------------------------------------------------
inline void CCONNECTION::SetSocket( SOCKET Socket )
    {
    m_Socket = Socket;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetSocket()
//---------------------------------------------------------------
inline SOCKET CCONNECTION::GetSocket()
    {
    return m_Socket;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetListenSocket()
//---------------------------------------------------------------
inline void CCONNECTION::SetListenSocket( SOCKET ListenSocket )
    {
    m_ListenSocket = ListenSocket;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetListenSocket()
//---------------------------------------------------------------
inline SOCKET CCONNECTION::GetListenSocket()
    {
    return m_ListenSocket;
    }

//---------------------------------------------------------------
//  CCONNECTION::IncrementPendingReads()
//---------------------------------------------------------------
inline LONG CCONNECTION::IncrementPendingReads()
    {
    return InterlockedIncrement(&m_lPendingReads);
    }

//---------------------------------------------------------------
//  CCONNECTION::DecrementPendingReads()
//---------------------------------------------------------------
inline LONG CCONNECTION::DecrementPendingReads()
    {
    return InterlockedDecrement(&m_lPendingReads);
    }

//---------------------------------------------------------------
//  CCONNECTION::IncrementPendingWrites()
//---------------------------------------------------------------
inline LONG CCONNECTION::IncrementPendingWrites()
    {
    return InterlockedIncrement(&m_lPendingWrites);
    }

//---------------------------------------------------------------
//  CCONNECTION::DecrementPendingReads()
//---------------------------------------------------------------
inline LONG CCONNECTION::DecrementPendingWrites()
    {
    return InterlockedDecrement(&m_lPendingWrites);
    }

//---------------------------------------------------------------
//  CCONNECTION::NumPendingIos()
//---------------------------------------------------------------
inline LONG CCONNECTION::NumPendingIos()
    {
    return m_lPendingReads + m_lPendingWrites;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetIoCompletionPort()
//---------------------------------------------------------------
inline void CCONNECTION::SetIoCompletionPort( HANDLE hIoCP )
    {
    }

//---------------------------------------------------------------
//  CCONNECTION::GetIoCompletionPort()
//---------------------------------------------------------------
inline HANDLE CCONNECTION::GetIoCompletionPort()
    {
    return INVALID_HANDLE_VALUE;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetScepConnection()
//---------------------------------------------------------------
inline void CCONNECTION::SetScepConnection( CSCEP_CONNECTION *pScepConnection )
    {
    m_pScepConnection = pScepConnection;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetScepConnection()
//---------------------------------------------------------------
inline CSCEP_CONNECTION *CCONNECTION::GetScepConnection()
    {
    return m_pScepConnection;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetJpegOffset()
//---------------------------------------------------------------
inline void CCONNECTION::SetJpegOffsetAndSize( IN DWORD dwOffset,
                                               IN DWORD dwSize )
    {
    m_dwJpegOffset = dwOffset;
    m_dwJpegSize = dwSize;
    }

//---------------------------------------------------------------
//  CCONNECTION::CheckSaveAsUPF()
//---------------------------------------------------------------
inline BOOL CCONNECTION::CheckSaveAsUPF()
    {
    return m_fSaveAsUPF;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetReceiveComplete()
//---------------------------------------------------------------
inline void CCONNECTION::SetReceiveComplete( IN BOOL fReceiveComplete )
    {
    m_fReceiveComplete = fReceiveComplete;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\iostatus.cpp ===
//---------------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  iostatus.cpp
//
//  Author:
//
//    Edward Reus (edwardr)     02-28-98   Initial coding.
//
//---------------------------------------------------------------------

#include "precomp.h"

//---------------------------------------------------------------------
// CIOSTATUS::CIOSTATUS()
//
//---------------------------------------------------------------------
CIOSTATUS::CIOSTATUS()
    {
    m_dwMainThreadId = 0;

    m_lNumThreads = 0;
    m_lNumPendingThreads = 0;
    }

//---------------------------------------------------------------------
// CIOSTATUS::~CIOSTATUS()
//
//---------------------------------------------------------------------
CIOSTATUS::~CIOSTATUS()
    {
    }

//------------------------------------------------------------------------
//  CIOSTATUS::operator new()
//
//------------------------------------------------------------------------
void *CIOSTATUS::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CIOSTATUS::operator delete()
//
//------------------------------------------------------------------------
void CIOSTATUS::operator delete( IN void *pObj,
                                 IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);

        #ifdef DBG_MEM
        if (dwStatus)
            {
            DbgPrint("IrXfer: IrTran-P: CIOSTATUS::delete Failed: %d\n",
                     dwStatus );
            }
        #endif
        }
    }

//---------------------------------------------------------------------
// CIOSTATUS::Initialize();
//
//---------------------------------------------------------------------
DWORD CIOSTATUS::Initialize()
    {
    DWORD  dwStatus = NO_ERROR;

    m_dwMainThreadId = GetCurrentThreadId();

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\memory.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// memory.cpp
//
// Simple memory allocation routines. We use our own private heap
// so we won't (have less chances of) interfering with any other 
// service code.
//
// Author:
//
//   Edward Reus (EdwardR)   03-04-98  Initial coding.
//
//   Edward Reus (EdwardR)   06-08-98  Convert to use private heap.
//
//--------------------------------------------------------------------

#include "precomp.h"

#pragma warning (disable:4200)

typedef struct _PDU_MEMORY
    {
    LIST_ENTRY  Link;
    DWORD       dwPduSize;
    UCHAR       Pdu[];
    } PDU_MEMORY;

#pragma warning (default:4200)

static HANDLE      g_hHeap = 0;   // Can't use INVALID_HANDLE_VALUE.

static LIST_ENTRY  g_FreePduList;
static BOOL        g_fListInitialized = FALSE;

#ifdef DBG_MEM
static LONG        g_lPduCount = 0;
#endif


//--------------------------------------------------------------------
// InitializeMemory()
//
//--------------------------------------------------------------------
DWORD InitializeMemory()
    {
    DWORD   dwStatus = NO_ERROR;
    #define INITIAL_HEAP_PAGES    64

    if (!g_hHeap)
        {
        SYSTEM_INFO  SystemInfo;

        GetSystemInfo(&SystemInfo);

        DWORD  dwFlags = 0;
        DWORD  dwInitialSize = INITIAL_HEAP_PAGES * SystemInfo.dwPageSize;
        DWORD  dwMaxSize = 0;
        g_hHeap = HeapCreate( dwFlags, dwInitialSize, dwMaxSize );
        if (!g_hHeap)
            {
            dwStatus = GetLastError();
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// AllocateMemory()
//
//--------------------------------------------------------------------
void *AllocateMemory( DWORD dwBytes )
    {
    DWORD  dwStatus;
    void  *pvMemory;

    if (!g_hHeap)
        {
        dwStatus = InitializeMemory();
        }

    if ((g_hHeap) && (dwBytes > 0))
        {
        #ifdef DBG_MEM_VALIDATE
        HeapValidate(g_hHeap,0,0);
        #endif

        pvMemory = HeapAlloc(g_hHeap,0,dwBytes);
        }
    else
        {
        pvMemory = 0;
        }

    return pvMemory;
    }


//--------------------------------------------------------------------
// FreeMemory()
//
//--------------------------------------------------------------------
DWORD FreeMemory( void *pvMemory )
    {
    DWORD  dwStatus = NO_ERROR;

    if (g_hHeap)
        {
        #ifdef DBG_MEM_VALIDATE
        HeapValidate(g_hHeap,0,0);
        #endif

        if (pvMemory)
            {
            if (!HeapFree(g_hHeap,0,pvMemory))
                {
                dwStatus = GetLastError();
                }
            }
        }
    else
        {
        #ifdef DBG_MEM
        DbgPrint("IrXfer.dll: IrTran-P: Free memory with NULL g_hHeap.\n");
        #endif
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// UninitializeMemory()
//
//--------------------------------------------------------------------
DWORD UninitializeMemory()
    {
    DWORD  dwStatus = NO_ERROR;

    #ifdef DBG_MEM_VALIDATE
    HeapValidate(g_hHeap,0,0);
    #endif

    if (g_hHeap)
        {
        if (!HeapDestroy(g_hHeap))
            {
            dwStatus = GetLastError();
            }
        }

    g_hHeap = 0;

    return dwStatus;
    }

//--------------------------------------------------------------------
// NewPdu()
//
//--------------------------------------------------------------------
SCEP_HEADER *NewPdu( DWORD dwPduSize )
    {
    SCEP_HEADER  *pPdu;
    PDU_MEMORY   *pPduMemory;
    LIST_ENTRY   *pLink;

    if (!g_fListInitialized)
        {
        InitializeListHead(&g_FreePduList);
        g_fListInitialized = TRUE;
        }

    if (dwPduSize == 0)
        {
        dwPduSize = MAX_PDU_SIZE;
        }

    if (IsListEmpty(&g_FreePduList))
        {
        pPduMemory 
            = (PDU_MEMORY*)AllocateMemory( sizeof(PDU_MEMORY)+dwPduSize );

        if (pPduMemory)
            {
            pPduMemory->Link.Flink = 0;
            pPduMemory->Link.Blink = 0;
            pPduMemory->dwPduSize = dwPduSize;
            }
        }
    else
        {
        pLink = RemoveHeadList(&g_FreePduList);
        pPduMemory = CONTAINING_RECORD(pLink,PDU_MEMORY,Link);
        }

    if (pPduMemory)
        {
        pPdu = (SCEP_HEADER*)(pPduMemory->Pdu);
        }
    else
        {
        pPdu = 0;
        }

    #ifdef DBG_MEM
    if (pPdu)
        {
        InterlockedIncrement(&g_lPduCount);
        }
    DbgPrint("NewPdu(): Count: %d Bytes: %d Addr: 0x%x\n",
             g_lPduCount, dwPduSize, pPdu );
    #endif

    return pPdu;
    }

//--------------------------------------------------------------------
// DeletePdu()
//
//--------------------------------------------------------------------
void DeletePdu( SCEP_HEADER *pPdu )
    {
    PDU_MEMORY  *pPduMemory;

    if (pPdu)
        {
        pPduMemory = CONTAINING_RECORD(pPdu,PDU_MEMORY,Pdu);
        InsertTailList(&g_FreePduList,&pPduMemory->Link);

        #ifdef DBG_MEM
        InterlockedDecrement(&g_lPduCount);
        DbgPrint("DeletePdu(): Count: %d\n",g_lPduCount);
        #endif
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\irthread.h ===
//--------------------------------------------------------------------
// Copyright (c)1999 Microsoft Corporation, All Rights Reserved.
//
// irthread.h
//
// Author:
//
//   Edward Reus (edwardr)     08-30-99   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _IRTRANP_H_
#define _IRTRANP_H_


//
// IrTran-P thread procedure:
//
extern DWORD WINAPI  IrTranP( LPVOID pv );

//
// Call this guy to stop the IrTran-P protocol engine thread.
//
extern BOOL  UninitializeIrTranP( HANDLE hThread );

//
// Call this function to get the location that the IrTran-P places
// the images as they are sent by the camera.
//
extern CHAR *GetImageDirectory();


#endif //_IRTRANP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\io.h ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// io.h
//
// Author:
//
//   Edward Reus (edwardr)     02-24-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _IO_H_
#define _IO_H_

   // Different debug flags for various aspects of the code:
   #ifdef DBG
   // #define DBG_ERROR
   // #define DBG_IO
   // #define DBG_TARGET_DIR
   // #define DBG_MEM
   // #define DBG_MEM_VALIDATE
   // #define DBG_ASSEMBLE
   // #define DBG_DATE
   // #define DBG_REGISTRY
   // #define DBG_RETURN_STATUS
   // #define DBG_IMPERSONATE
   // #define DBG_PROPERTIES
   #endif

   // For NT we want to use IO Completion ports, for Windows98 we can't:
   // #define  USE_IOCOMPLETION
   #define  SYNCHRONOUS_FILES

   #ifndef NTENV

      #define  DbgPrint       printf

      #undef   ASSERT
      #define  ASSERT(x)

      #ifndef NTSTATUS
      #define  NTSTATUS       DWORD
      #endif

      #ifndef NT_SUCCESS
      #define  NT_SUCCESS(x)  ((x)==0)
      #endif

      #define  RTL_CRITICAL_SECTION   CRITICAL_SECTION

      NTSTATUS
      RtlInitializeCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );

      NTSTATUS
      RtlDeleteCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );

      NTSTATUS
      RtlEnterCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );

      NTSTATUS
      RtlLeaveCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );


   //  Doubly-linked list manipulation routines.  Implemented as macros
   //  but logically these are procedures.
   //

   //
   //  VOID
   //  InitializeListHead(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define InitializeListHead(ListHead) (\
       (ListHead)->Flink = (ListHead)->Blink = (ListHead))

   //
   //  BOOLEAN
   //  IsListEmpty(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define IsListEmpty(ListHead) \
       ((ListHead)->Flink == (ListHead))

   //
   //  PLIST_ENTRY
   //  RemoveHeadList(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define RemoveHeadList(ListHead) \
       (ListHead)->Flink;\
       {RemoveEntryList((ListHead)->Flink)}

   //
   //  PLIST_ENTRY
   //  RemoveTailList(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define RemoveTailList(ListHead) \
       (ListHead)->Blink;\
       {RemoveEntryList((ListHead)->Blink)}

   //
   //  VOID
   //  RemoveEntryList(
   //      PLIST_ENTRY Entry
   //      );
   //

   #define RemoveEntryList(Entry) {\
       PLIST_ENTRY _EX_Blink;\
       PLIST_ENTRY _EX_Flink;\
       _EX_Flink = (Entry)->Flink;\
       _EX_Blink = (Entry)->Blink;\
       _EX_Blink->Flink = _EX_Flink;\
       _EX_Flink->Blink = _EX_Blink;\
       }

   //
   //  VOID
   //  InsertTailList(
   //      PLIST_ENTRY ListHead,
   //      PLIST_ENTRY Entry
   //      );
   //

   #define InsertTailList(ListHead,Entry) {\
       PLIST_ENTRY _EX_Blink;\
       PLIST_ENTRY _EX_ListHead;\
       _EX_ListHead = (ListHead);\
       _EX_Blink = _EX_ListHead->Blink;\
       (Entry)->Flink = _EX_ListHead;\
       (Entry)->Blink = _EX_Blink;\
       _EX_Blink->Flink = (Entry);\
       _EX_ListHead->Blink = (Entry);\
       }

   //
   //  VOID
   //  InsertHeadList(
   //      PLIST_ENTRY ListHead,
   //      PLIST_ENTRY Entry
   //      );
   //

   #define InsertHeadList(ListHead,Entry) {\
       PLIST_ENTRY _EX_Flink;\
       PLIST_ENTRY _EX_ListHead;\
       _EX_ListHead = (ListHead);\
       _EX_Flink = _EX_ListHead->Flink;\
       (Entry)->Flink = _EX_Flink;\
       (Entry)->Blink = _EX_ListHead;\
       _EX_Flink->Blink = (Entry);\
       _EX_ListHead->Flink = (Entry);\
       }

   //
   //
   //  PSINGLE_LIST_ENTRY
   //  PopEntryList(
   //      PSINGLE_LIST_ENTRY ListHead
   //      );
   //

   #define PopEntryList(ListHead) \
       (ListHead)->Next;\
       {\
           PSINGLE_LIST_ENTRY FirstEntry;\
           FirstEntry = (ListHead)->Next;\
           if (FirstEntry != NULL) {     \
               (ListHead)->Next = FirstEntry->Next;\
           }                             \
       }


   //
   //  VOID
   //  PushEntryList(
   //      PSINGLE_LIST_ENTRY ListHead,
   //      PSINGLE_LIST_ENTRY Entry
   //      );
   //

   #define PushEntryList(ListHead,Entry) \
       (Entry)->Next = (ListHead)->Next; \
       (ListHead)->Next = (Entry)


#endif

// Maximum number of "Copy XX of" files to create:
#define  MAX_COPYOF_TRIES                 100

// CIOPACKET objects can have the following kinds:
#define  PACKET_KIND_LISTEN                 0
#define  PACKET_KIND_READ                   1
#define  PACKET_KIND_WRITE_SOCKET           2
#define  PACKET_KIND_WRITE_FILE             3

// The number of pending IOs depends on what you are doing:
#define  MAX_PENDING_LISTEN                 1
#define  MAX_PENDING_READ                   2
#define  MAX_PENDING_WRITE                  3

// This dwKey value for the key in IO completion is a special
// value used to shutdown the IrTran-P thread:
#define  IOKEY_SHUTDOWN            0xFFFFFFFF

// This is the default size for the read buffer in IO reads
// posted to the IO completion port:
#define  DEFAULT_READ_BUFFER_SIZE        4096

// Used in setting up the IrCOMM listen socket:
#define  IAS_SET_ATTRIB_MAX_LEN            32
#define  IAS_QUERY_ATTRIB_MAX_LEN          IAS_SET_ATTRIB_MAX_LEN

#define  IRDA_PARAMETERS                   "Parameters"
#define  OCTET_SEQ_SIZE                     6
#define  OCTET_SEQ                         "\000\001\006\001\001\001"

// The names of the services we will provide listen sockets for:
#define  IRTRANP_SERVICE                   "IrTranPv1"
#define  IRCOMM_9WIRE                      "IrDA:IrCOMM"

// The status of the listen socket for each service:
#define  STATUS_STOPPED                     0
#define  STATUS_RUNNING                     1

// Registry paths and value names:
#define  REG_PATH_HKCU                     "Control Panel\\Infrared\\IrTranP"
#define  REG_DWORD_SAVE_AS_UPF             "SaveAsUPF"
#define  REG_DWORD_DISABLE_IRTRANP         "DisableIrTranPv1"
#define  REG_DWORD_DISABLE_IRCOMM          "DisableIrCOMM"
#define  REG_DWORD_EXPLORE                 "ExploreOnCompletion"
#define  REG_SZ_DESTINATION                "RecvdFileLocation"

// Last chance location to put image files.
#define  SZ_UNDERSCORE                     "_"
#define  SZ_SLASH                          "\\"
#define  SZ_SUBDIRECTORY                   "IrTranP"
#define  SZ_BACKUP_MY_PICTURES             "\\TEMP"
#define  SZ_BACKUP_DRIVE                   "C:"

// File Suffix:
#define  SLASH                             '\\'
#define  PERIOD                            '.'
#define  SZ_JPEG                           ".JPG"
#define  SZ_UPF                            ".UPF"

// Forward reference:
class CIOSTATUS;

extern "C" DWORD    ProcessIoPackets( CIOSTATUS *pIoStatus );

//--------------------------------------------------------------------
// Global functions (in irtranp.cpp)
//--------------------------------------------------------------------

extern HANDLE   GetUserToken();
extern BOOL     CheckSaveAsUPF();
extern BOOL     CheckExploreOnCompletion();
extern BOOL     ReceivesAllowed();
extern char    *GetImageDirectory();

//--------------------------------------------------------------------
// class CIOPACKET
//--------------------------------------------------------------------
class CIOPACKET
{
public:
    CIOPACKET();
    ~CIOPACKET();

    void   *operator new( IN size_t Size );

    void    operator delete( IN void   *pObj,
                             IN size_t  Size );

    DWORD  Initialize( IN DWORD  dwKind = PACKET_KIND_LISTEN,
                       IN SOCKET ListenSocket = INVALID_SOCKET,
                       IN SOCKET Socket = INVALID_SOCKET,
                       IN HANDLE hIoCP = INVALID_HANDLE_VALUE );

    // void * operator new( size_t ObjectSize );

    // void   operator delete( void * pObject );

    DWORD  PostIo();

    DWORD  PostIoRead();    // Called by PostIo().

    DWORD  PostIoWrite( IN void  *pvBuffer,
                        IN DWORD  dwBufferSize,
                        IN DWORD  dwOffset   );

    #ifdef NTENV
    void   GetSockAddrs( OUT SOCKADDR_IRDA **ppAddrLocal,
                         OUT SOCKADDR_IRDA **ppAddrFrom );
    #endif

    DWORD  GetIoPacketKind();
    void   SetIoPacketKind( IN DWORD dwKind );

    HANDLE GetIoCompletionPort();

    char  *GetReadBuffer();

    SOCKET GetSocket();
    void   SetSocket( SOCKET Socket );
    SOCKET GetListenSocket();
    void   SetListenSocket( SOCKET Socket );
    HANDLE GetFileHandle();
    void   SetFileHandle( HANDLE hFile );

    void  *GetWritePdu();
    void   SetWritePdu( void *pvPdu );

    static CIOPACKET *CIoPacketFromOverlapped( OVERLAPPED *pOverlapped );

private:
    DWORD          m_dwKind;
    SOCKET         m_ListenSocket;
    SOCKET         m_Socket;
    HANDLE         m_hFile;
    SOCKADDR_IRDA *m_pLocalAddr;
    SOCKADDR_IRDA *m_pFromAddr;
    void          *m_pAcceptBuffer;
    void          *m_pReadBuffer;
    void          *m_pvWritePdu;           // SCEP_HEADER PDU holder.
    DWORD          m_dwReadBufferSize;
    OVERLAPPED     m_Overlapped;
};

//--------------------------------------------------------------------
// class CIOSTATUS
//
//--------------------------------------------------------------------
class CIOSTATUS
{
public:
    CIOSTATUS();
    ~CIOSTATUS();

    void   *operator new( IN size_t Size );

    void    operator delete( IN void   *pObj,
                             IN size_t  Size );

    DWORD  Initialize();

    BOOL   IsMainThreadId( DWORD dwTid );

    HANDLE GetIoCompletionPort();

    LONG   IncrementNumThreads();
    LONG   DecrementNumThreads();

    LONG   IncrementNumPendingThreads();
    LONG   DecrementNumPendingThreads();

private:
    DWORD     m_dwMainThreadId;

    LONG      m_lNumThreads;

    LONG      m_lNumPendingThreads;
};

//--------------------------------------------------------------------
// CIOPACKET::GetIoCompletionPort()
//--------------------------------------------------------------------
inline HANDLE CIOPACKET::GetIoCompletionPort()
    {
    return INVALID_HANDLE_VALUE;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetSocket()
//--------------------------------------------------------------------
inline SOCKET CIOPACKET::GetSocket()
    {
    return m_Socket;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetSocket()
//--------------------------------------------------------------------
inline void CIOPACKET::SetSocket( SOCKET Socket )
    {
    m_Socket = Socket;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetListenSocket()
//--------------------------------------------------------------------
inline SOCKET CIOPACKET::GetListenSocket()
    {
    return m_ListenSocket;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetListenSocket()
//--------------------------------------------------------------------
inline void CIOPACKET::SetListenSocket( SOCKET ListenSocket )
    {
    m_ListenSocket = ListenSocket;
    }

//--------------------------------------------------------------------
// CIOPACKET::CIoPacketFromOverlapped()
//--------------------------------------------------------------------
inline CIOPACKET *CIOPACKET::CIoPacketFromOverlapped( OVERLAPPED *pOverlapped )
    {
    return CONTAINING_RECORD(pOverlapped,CIOPACKET,m_Overlapped);
    }

//--------------------------------------------------------------------
// CIOPACKET::GetIoPacketKind()
//--------------------------------------------------------------------
inline DWORD CIOPACKET::GetIoPacketKind()
    {
    return m_dwKind;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetIoPacketKind()
//--------------------------------------------------------------------
inline void CIOPACKET::SetIoPacketKind( DWORD dwKind )
    {
    m_dwKind = dwKind;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetReadBuffer()
//--------------------------------------------------------------------
inline char *CIOPACKET::GetReadBuffer()
    {
    return (char*)m_pReadBuffer;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetFileHandle()
//--------------------------------------------------------------------
inline HANDLE CIOPACKET::GetFileHandle()
    {
    return m_hFile;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetFileHandle()
//--------------------------------------------------------------------
inline void CIOPACKET::SetFileHandle( HANDLE hFile )
    {
    m_hFile = hFile;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetWritePdu()
//--------------------------------------------------------------------
inline void *CIOPACKET::GetWritePdu()
    {
    return m_pvWritePdu;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetWritePdu()
//--------------------------------------------------------------------
inline void CIOPACKET::SetWritePdu( void *pvWritePdu )
    {
    m_pvWritePdu = pvWritePdu;
    }


//********************************************************************

//--------------------------------------------------------------------
// CIOSTATUS::IsMainTheadId()
//--------------------------------------------------------------------
inline BOOL CIOSTATUS::IsMainThreadId( DWORD dwTid )
    {
    return (dwTid == m_dwMainThreadId);
    }

//--------------------------------------------------------------------
// CIOSTATUS::GetIoCompletionPort()
//--------------------------------------------------------------------
inline HANDLE CIOSTATUS::GetIoCompletionPort()
    {
    return INVALID_HANDLE_VALUE;
    }

//--------------------------------------------------------------------
// CIOSTATUS::IncrementNumThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::IncrementNumThreads()
    {
    return InterlockedIncrement(&m_lNumThreads);
    }

//--------------------------------------------------------------------
// CIOSTATUS::DecrementNumThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::DecrementNumThreads()
    {
    return InterlockedDecrement(&m_lNumThreads);
    }

//--------------------------------------------------------------------
// CIOSTATUS::IncrementNumPendingThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::IncrementNumPendingThreads()
    {
    return InterlockedIncrement(&m_lNumPendingThreads);
    }

//--------------------------------------------------------------------
// CIOSTATUS::DecrementNumPendingThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::DecrementNumPendingThreads()
    {
    return InterlockedDecrement(&m_lNumPendingThreads);
    }

#endif //_IO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\irtranp.cpp ===
//---------------------------------------------------------------------
//  Copyright (c)1998-1999 Microsoft Corporation, All Rights Reserved.
//
//  irtranp.cpp
//
//  This file holds the main entry points for the IrTran-P service.
//  IrTranP() is the entry point that starts the listening, and
//  UninitializeIrTranP() shuts it down (and cleans everything up).
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//    Edward Reus (edwardr)     08-27-99   Finish modifications for
//                                         WIA Millennium port.
//
//  Note: Currently the Millennium version will only listen on IrCOMM.
//
//---------------------------------------------------------------------

#include "precomp.h"
#include <mbstring.h>

#define SZ_REG_KEY_IRTRANP     "Control Panel\\Infrared\\IrTranP"
#define SZ_REG_DISABLE_IRCOMM  "DisableIrCOMM"

//---------------------------------------------------------------------
// Listen ports array:
//---------------------------------------------------------------------

typedef struct _LISTEN_PORT
    {
    char  *pszService;      // Service to start.
    BOOL   fIsIrCOMM;       // TRUE iff IrCOMM 9-wire mode.
    DWORD  dwListenStatus;  // Status for port.
    } LISTEN_PORT;

static LISTEN_PORT aListenPorts[] =
    {
    // Service Name   IrCOMM  ListenStatus
    {IRCOMM_9WIRE,    TRUE,   STATUS_STOPPED },
//  {IRTRANP_SERVICE, FALSE,  STATUS_STOPPED },
//  {IR_TEST_SERVICE, FALSE,  STATUS_STOPPED }, 2nd test listen port.
    {0,               FALSE,  STATUS_STOPPED }
    };

#define  INDEX_IRCOMM           0
#define  INDEX_IRTRANPV1        1

CCONNECTION_MAP  *g_pConnectionMap = 0;
CIOSTATUS        *g_pIoStatus = 0;
HANDLE            g_hShutdownEvent;

BOOL              g_fShuttingDownTRANPThread = FALSE;
DWORD             g_dwTRANPThreadId = 0;

extern HINSTANCE  g_hInst;   // Handle to ircamera.dll USD

//---------------------------------------------------------------------
//  Globals:
//---------------------------------------------------------------------

HANDLE     g_UserToken = NULL;
HKEY       g_hUserKey = NULL;
BOOL       g_fDisableIrTranPv1 = FALSE;
BOOL       g_fDisableIrCOMM = FALSE;
BOOL       g_fExploreOnCompletion = TRUE;
BOOL       g_fSaveAsUPF = FALSE;
BOOL       g_fAllowReceives = TRUE;

char      *g_pszTempPicturesFolder = 0;

BOOL       g_fWSAStartupCalled = FALSE;

void      *g_pvIrUsdDevice = 0;  // WIA IrUsdDevice Object.


//---------------------------------------------------------------------
// GetUserToken()
//
// The "main" part of irxfer.dll (in ..\irxfer) maintains a token
// for user that is currently logged in (if any).
//---------------------------------------------------------------------
HANDLE GetUserToken()
    {
    return g_UserToken;
    }

//---------------------------------------------------------------------
// GetUserKey()
//
//---------------------------------------------------------------------
HKEY GetUserKey()
    {
    return g_hUserKey;
    }

//---------------------------------------------------------------------
// GetModule()
//
//---------------------------------------------------------------------
HINSTANCE GetModule()
    {
    return g_hInst;
    }

//---------------------------------------------------------------------
// CheckSaveAsUPF()
//
// Return TRUE iff pictures need to be saved in .UPF (as opposed to
// .JPEG) format.
//---------------------------------------------------------------------
BOOL CheckSaveAsUPF()
    {
    return g_fSaveAsUPF;
    }

//---------------------------------------------------------------------
// CheckExploreOnCompletion()
//
// Return TRUE iff we want to popup an explorer on the directory
// containing the newly transfered pictures.
//---------------------------------------------------------------------
BOOL CheckExploreOnCompletion()
    {
    return g_fExploreOnCompletion;
    }


/* FlushInputQueue is a private routine to collect and dispatch all
 * messages in the input queue.  It returns TRUE if a WM_QUIT message
 * was detected in the queue, FALSE otherwise.
 */
BOOL FlushInputQueue(VOID)
{
    MSG msgTemp;
    while (PeekMessage(&msgTemp, NULL, 0, 0, PM_REMOVE)) {
        DispatchMessage(&msgTemp);

        // If we see a WM_QUIT in the queue, we need to do the same
        // sort of thing that a modal dialog does:  break out of our
        // waiting, and repost the WM_QUIT to the queue so that the
        // next message loop up in the app will also see it.
        if (msgTemp.message == WM_QUIT) {
            PostQuitMessage((int)msgTemp.wParam);
            return TRUE;
        }
    }
    return FALSE;
}

/* WaitAndYield() waits for the specified object using
 * MsgWaitForMultipleObjects.  If messages are received,
 * they are dispatched and waiting continues.  The return
 * value is the same as from MsgWaitForMultipleObjects.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout)
{
    DWORD dwTickCount, dwWakeReason, dwTemp;

    do {
        /* Flush any messages before we wait.  This is because
         * MsgWaitForMultipleObjects will only return when NEW
         * messages are put in the queue.
         */
        if (FlushInputQueue()) {
            dwWakeReason = WAIT_TIMEOUT;
            break;
        }

        // in case we handle messages, we want close to a true timeout
        if ((dwTimeout != 0) &&
            (dwTimeout != (DWORD)-1)) {
            // if we can timeout, store the current tick count
            // every time through
            dwTickCount = GetTickCount();
        }
        dwWakeReason = MsgWaitForMultipleObjects(1,
                                                 &hObject,
                                                 FALSE,
                                                 dwTimeout,
                                                 QS_ALLINPUT);
        // if we got a message, dispatch it, then try again
        if (dwWakeReason == 1) {
            // if we can timeout, see if we did before processing the message
            // that way, if we haven't timed out yet, we'll get at least one
            // more shot at the event
            if ((dwTimeout != 0) &&
                (dwTimeout != (DWORD)-1)) {
                if ((dwTemp = (GetTickCount()-dwTickCount)) >= dwTimeout) {
                    // if we timed out, make us drop through
                    dwWakeReason = WAIT_TIMEOUT;
                } else {
                    // subtract elapsed time from timeout and continue
                    // (we don't count time spent dispatching message)
                    dwTimeout -= dwTemp;
                }
            }
            if (FlushInputQueue()) {
                dwWakeReason = WAIT_TIMEOUT;
                break;
            }
        }
    } while (dwWakeReason == 1);

    return dwWakeReason;
}


//---------------------------------------------------------------------
// GetImageDirectory();
//
// This is the temporary directory where the pictures sent by the
// camera will be held. WIA will then "down load" these to their
// final destination (usually this will be My Pictures).
//
//---------------------------------------------------------------------
CHAR *GetImageDirectory()
    {
    char  *pszPicturesFolder;
    char   szTempFolder[1+MAX_PATH];
    DWORD  dwPicturesFolderLen;
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwLen;


    if (!g_pszTempPicturesFolder)
        {
        dwLen = GetTempPath(MAX_PATH,szTempFolder);

        if ((!dwLen)||(dwLen > MAX_PATH))
            {
            dwStatus = GetLastError();
            WIAS_TRACE((g_hInst,"GetUserDirectroy(): GetTempPath() failed: %d",dwStatus));
            return NULL;
            }

        //
        // Make sure the directory exists:
        //
        if (!CreateDirectory(szTempFolder,0))
            {
            dwStatus = GetLastError();
            if ( (dwStatus == ERROR_ALREADY_EXISTS)
               || (dwStatus == ERROR_ACCESS_DENIED) )
                {
                dwStatus = NO_ERROR;
                }
            else if (dwStatus != NO_ERROR)
                {
                return 0;
                }
            }

        //
        // Construct the subdirectory path string that will actually hold the pictures:
        // This will be something like: C:\temp\irtranp
        //
        dwPicturesFolderLen = sizeof(CHAR)*( strlen(szTempFolder)
                                           + sizeof(SZ_SLASH)
                                           + sizeof(SZ_SUBDIRECTORY)
                                           + 1 );

        g_pszTempPicturesFolder = (CHAR*)AllocateMemory(dwPicturesFolderLen);

        if (!g_pszTempPicturesFolder)
            {
            return 0;    // Memory allocation failed!
            }

        strcpy(g_pszTempPicturesFolder,szTempFolder);
        if (szTempFolder[dwLen-1] != SLASH)
            {
            strcat(g_pszTempPicturesFolder,SZ_SLASH);
            }
        strcat(g_pszTempPicturesFolder,SZ_SUBDIRECTORY);

        //
        // Make sure the subdirectory exists:
        //
        if (!CreateDirectory(g_pszTempPicturesFolder,0))
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_ALREADY_EXISTS)
                {
                dwStatus = NO_ERROR;
                }
            else if (dwStatus != NO_ERROR)
                {
                return 0;
                }
            }
        }

    pszPicturesFolder = g_pszTempPicturesFolder;

    return pszPicturesFolder;
    }

//---------------------------------------------------------------------
// ReceivesAllowed()
//
// Using the IR configuration window (available from the wireless network
// icon in the control panel) you can disable communications with IR
// devices. This function returns the state of IR communications, FALSE
// is disabled, TRUE is enabled.
//---------------------------------------------------------------------
BOOL ReceivesAllowed()
    {
    return g_fAllowReceives;
    }

//---------------------------------------------------------------------
// SetupListenConnection()
//
//---------------------------------------------------------------------
DWORD SetupListenConnection( IN  CHAR  *pszService,
                             IN  BOOL   fIsIrCOMM,
                             IN  HANDLE hIoCompletionPort )
    {
    DWORD        dwStatus = NO_ERROR;
    CIOPACKET   *pIoPacket;
    CCONNECTION *pConnection;

    // See if the connection already exists:
    if (g_pConnectionMap->LookupByServiceName(pszService))
        {
        return NO_ERROR;
        }

    // Makeup and initialize a new connection object:
    pConnection = new CCONNECTION;
    if (!pConnection)
        {
        return E_OUTOFMEMORY;
        }

    dwStatus = pConnection->InitializeForListen( pszService,
                                                 fIsIrCOMM,
                                                 hIoCompletionPort );
    if (dwStatus)
        {
        WIAS_ERROR((g_hInst,"SetupForListen(): InitializeForListen(%s) failed: %d",pszService, dwStatus));
        return dwStatus;
        }

    pIoPacket = new CIOPACKET;
    if (!pIoPacket)
        {
        WIAS_ERROR((g_hInst,"SetupForListen(): new CIOPACKET failed"));
        delete pConnection;
        return E_OUTOFMEMORY;
        }

    // Setup the IO packet:
    dwStatus = pIoPacket->Initialize( PACKET_KIND_LISTEN,
                                      pConnection->GetListenSocket(),
                                      INVALID_SOCKET,
                                      hIoCompletionPort );
    if (dwStatus != NO_ERROR)
        {
        return dwStatus;
        }

    pConnection->SetSocket(pIoPacket->GetSocket());

    if (!g_pConnectionMap->Add(pConnection,pIoPacket->GetListenSocket()))
        {
        WIAS_ERROR((g_hInst,"SetupForListen(): Add(pConnection) ConnectionMap Failed."));
        return 1;
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// TeardownListenConnection()
//
//---------------------------------------------------------------------
DWORD TeardownListenConnection( IN char *pszService )
    {
    DWORD        dwStatus = NO_ERROR;
    CCONNECTION *pConnection;

    // Look for the connection associated with the service name:
    pConnection = g_pConnectionMap->LookupByServiceName(pszService);

    if (pConnection)
        {
        g_pConnectionMap->RemoveConnection(pConnection);
        pConnection->CloseSocket();
        pConnection->CloseListenSocket();
        }

    return dwStatus;
    }


//---------------------------------------------------------------------
// EnableDisableIrCOMM()
//
//---------------------------------------------------------------------
DWORD EnableDisableIrCOMM( IN BOOL fDisable )
   {
   DWORD     dwStatus;


   if (fDisable)
       {
       dwStatus = TeardownListenConnection(
                      aListenPorts[INDEX_IRCOMM].pszService);
       WIAS_ERROR((g_hInst,"IrTranP: TeardownListenConnection(%s): %d", aListenPorts[INDEX_IRCOMM].pszService,dwStatus));
       }
   else
       {
       dwStatus = SetupListenConnection(
                      aListenPorts[INDEX_IRCOMM].pszService,
                      aListenPorts[INDEX_IRCOMM].fIsIrCOMM,
                      g_pIoStatus->GetIoCompletionPort() );

       WIAS_TRACE((g_hInst,"IrTranP: SetupListenConnection(%s): %d", aListenPorts[INDEX_IRCOMM].pszService, dwStatus));
       }

   return dwStatus;
   }

//---------------------------------------------------------------------
// EnableDisableIrTranPv1()
//
//---------------------------------------------------------------------
DWORD EnableDisableIrTranPv1( IN BOOL fDisable )
   {
   DWORD  dwStatus;

   if (fDisable)
       {
       dwStatus = TeardownListenConnection(
                      aListenPorts[INDEX_IRTRANPV1].pszService);
       }
   else
       {
       dwStatus = SetupListenConnection(
                      aListenPorts[INDEX_IRTRANPV1].pszService,
                      aListenPorts[INDEX_IRTRANPV1].fIsIrCOMM,
                      g_pIoStatus->GetIoCompletionPort() );
       }

   return dwStatus;
   }

//---------------------------------------------------------------------
// IrTranp()
//
//---------------------------------------------------------------------
DWORD WINAPI IrTranP( IN void *pvIrUsdDevice )
    {
    int     i = 0;
    WSADATA wsaData;
    WORD    wVersion = MAKEWORD(1,1);
    DWORD   dwStatus;
    CCONNECTION *pConnection;

    g_dwTRANPThreadId = ::GetCurrentThreadId();

    //
    // Initialize Memory Management:
    //
    dwStatus = InitializeMemory();
    if (dwStatus)
        {
        WIAS_ERROR((g_hInst,"IrTranP(): InitializeMemory() failed: %d\n",dwStatus));
        return dwStatus;
        }

    //
    // This directory will be set as needed. It is only non-null in the case
    // where we are re-starting the IrTran-P thread:
    //
    if (g_pszTempPicturesFolder)
        {
        FreeMemory(g_pszTempPicturesFolder);
        g_pszTempPicturesFolder = 0;
        }

    //
    // Initialize Winsock2 if neccessary:
    //
    if (!g_fWSAStartupCalled)
        {
        if (WSAStartup(wVersion,&wsaData) == SOCKET_ERROR)
            {
            dwStatus = WSAGetLastError();
            WIAS_ERROR((g_hInst,"WSAStartup(0x%x) failed with error %d\n", wVersion, dwStatus ));
            return dwStatus;
            }

        g_fWSAStartupCalled = TRUE;
        }

    // Event used to signal back to "main" thread that the
    // IrTran-P thread is exiting.
    //
    // NoSecurity, Auto-Reset, Initially Not Signaled, No Name.
    //
    g_hShutdownEvent = CreateEventA( NULL, FALSE, FALSE, NULL );

    if (!g_hShutdownEvent)
        {
        dwStatus = GetLastError();
        WIAS_ERROR((g_hInst,"IrTranP(): CreateEvent() Failed: %d",dwStatus));
        return dwStatus;
        }

    // Create/initialize a object to keep track of the threading...
    g_pIoStatus = new CIOSTATUS;
        if (!g_pIoStatus)
        {
        WIAS_ERROR((g_hInst,"new CIOSTATUS failed."));
        return E_OUTOFMEMORY;
            }

    dwStatus = g_pIoStatus->Initialize();
    if (dwStatus != NO_ERROR)
        {
        WIAS_ERROR((g_hInst,"g_pIoStatus->Initialize(): Failed: %d",dwStatus));
        return dwStatus;
        }

    // Need to keep track of the open sockets and the number of
    // pending IOs on each...
    g_pConnectionMap = new CCONNECTION_MAP;
    if (!g_pConnectionMap)
        {
        WIAS_ERROR((g_hInst,"new CCONNECTION_MAP failed."));
        return E_OUTOFMEMORY;
        }

    if (!g_pConnectionMap->Initialize())
        {
        return 1;
        }

    // Create a CIOPACKET for each defined listen port. These are
    // what we will listen on.

    //
    // BUGBUG Should we really loop indefintely setting up connection or establish some limit on retries ? VS
    //
    while (!g_fShuttingDownTRANPThread )
        {
        dwStatus = SetupListenConnection(
                        aListenPorts[INDEX_IRCOMM].pszService,
                        aListenPorts[INDEX_IRCOMM].fIsIrCOMM,
                        g_pIoStatus->GetIoCompletionPort() );

        if (dwStatus)
            {
            WIAS_TRACE((g_hInst,"SetupListenConnection(%s) Status: %d",aListenPorts[i].pszService,dwStatus));
            //
            // BUGBUG Analyze error and stop processing if it doesn't make sense !!! VS
            //
            }
        else
            {
            WIAS_TRACE((g_hInst,"SetupListenConnection(%s) Ready",aListenPorts[i].pszService));
            aListenPorts[INDEX_IRCOMM].dwListenStatus = STATUS_RUNNING;
            break;
            }

        // Wait for timeout period, but wake up if we need to stop
        // Sleep(5000);
        WaitAndYield(g_hShutdownEvent,5000);
        }

    if (!g_fShuttingDownTRANPThread) {

        //
        // Wait on incomming connections and data, then process it.
        //
        g_pvIrUsdDevice = pvIrUsdDevice;

        dwStatus = ProcessIoPackets(g_pIoStatus);

    }

    //
    // Shutting down
    //
    g_pvIrUsdDevice = 0;

    WIAS_TRACE((g_hInst,"ProcessIoPackets(): dwStatus: %d",dwStatus));

    //
    // Cleanup and close any open handles:
    //
    while (pConnection=g_pConnectionMap->RemoveNext())
        {
        delete pConnection;
        }

    delete g_pConnectionMap;
    g_pConnectionMap = 0;
    delete g_pIoStatus;
    g_pIoStatus = 0;

    // Signal the shutdown event that the IrTran-P thread is exiting:
    if (g_hShutdownEvent)
        {
        SetEvent(g_hShutdownEvent);
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// IrTranPEnableIrCOMMFailed()
//
//---------------------------------------------------------------------
void IrTranPEnableIrCOMMFailed( DWORD dwErrorCode )
    {
    DWORD  dwStatus;

    // An error occured on enable, make sure the registry value
    // is set to disable (so UI will match the actual state).
    HKEY      hKey = 0;
    HKEY      hUserKey = GetUserKey();
    HANDLE    hUserToken = GetUserToken();
    HINSTANCE hInstance = GetModule();
    DWORD     dwDisposition;

    if (RegCreateKeyEx(hUserKey,
                       SZ_REG_KEY_IRTRANP,
                       0,              // reserved MBZ
                       0,              // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_SET_VALUE,
                       0,              // security attributes
                       &hKey,
                       &dwDisposition))
        {
        WIAS_TRACE((g_hInst,"IrTranP: RegCreateKeyEx(): '%' failed %d", SZ_REG_KEY_IRTRANP, GetLastError()));
        }

    if (  (hKey)
       && (hUserToken)
       && (::ImpersonateLoggedOnUser(hUserToken)))
        {
        DWORD  dwDisableIrCOMM = TRUE;
        dwStatus = RegSetValueEx(hKey,
                                 SZ_REG_DISABLE_IRCOMM,
                                 0,
                                 REG_DWORD,
                                 (UCHAR*)&dwDisableIrCOMM,
                                 sizeof(dwDisableIrCOMM) );
        if (dwStatus != ERROR_SUCCESS)
            {
            WIAS_TRACE((g_hInst,"IrTranP: Can't set DisableIrCOMM to TRUE in registry. Error: %d",dwStatus));
            }

        ::RevertToSelf();
        }

    if (hKey)
        {
        RegCloseKey(hKey);
        }

#if FALSE
    WCHAR *pwszMessage = NULL;
    WCHAR *pwszCaption = NULL;
    DWORD  dwFlags = ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                     | FORMAT_MESSAGE_IGNORE_INSERTS
                     | FORMAT_MESSAGE_FROM_HMODULE);

    dwStatus = FormatMessageW(dwFlags,
                              hInstance,
                              CAT_IRTRANP,
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPTSTR)(&pwszCaption),
                              0,     // Minimum size to allocate.
                              NULL); // va_list args...
    if (dwStatus == 0)
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: FormatMessage() failed: %d\n",GetLastError() );
        #endif
        return;
        }

    //
    // Hack: Make sure the caption doesn't end with newline-formfeed...
    //
    WCHAR  *pwsz = pwszCaption;

    while (*pwsz)
        {
        if (*pwsz < 0x20)   // 0x20 is always a space...
            {
            *pwsz = 0;
            break;
            }
        else
            {
            pwsz++;
            }
        }


    WCHAR   wszErrorCode[20];
    WCHAR  *pwszErrorCode = (WCHAR*)wszErrorCode;

    wsprintfW(wszErrorCode,L"%d",dwErrorCode);

    dwFlags = ( FORMAT_MESSAGE_ALLOCATE_BUFFER
              | FORMAT_MESSAGE_ARGUMENT_ARRAY
              | FORMAT_MESSAGE_FROM_HMODULE);

    dwStatus = FormatMessageW(dwFlags,
                              hInstance,
                              MC_IRTRANP_IRCOM_FAILED,
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPTSTR)(&pwszMessage),
                              0,    // Minimum size to allocate.
                              (va_list*)&pwszErrorCode);
    if (dwStatus == 0)
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: FormatMessage() failed: %d\n",GetLastError() );
        #endif

        if (pwszMessage)
            {
            LocalFree(pwszMessage);
            }

        return;
        }

    dwStatus = MessageBoxW( NULL,
                            pwszMessage,
                            pwszCaption,
                            (MB_OK|MB_ICONERROR|MB_SETFOREGROUND|MB_TOPMOST) );

    if (pwszMessage)
        {
        LocalFree(pwszMessage);
        }

    if (pwszCaption)
        {
        LocalFree(pwszCaption);
        }
#endif
    }

//---------------------------------------------------------------------
// UninitializeIrTranP()
//
//---------------------------------------------------------------------
BOOL UninitializeIrTranP( HANDLE hThread )
    {
    BOOL   fSuccess = TRUE;
    DWORD  dwStatus;
    HANDLE hIoCP = g_pIoStatus->GetIoCompletionPort();

    g_fShuttingDownTRANPThread = TRUE;

    // Inform TRANP thread it has to die
    ::PostThreadMessage(g_dwTRANPThreadId,WM_QUIT,0,0);

    if (hIoCP != INVALID_HANDLE_VALUE)
        {
        if (!PostQueuedCompletionStatus(hIoCP,0,IOKEY_SHUTDOWN,0))
            {
            // Unexpected error...
            dwStatus = GetLastError();
            }

        while (WAIT_TIMEOUT == WaitForSingleObject(g_hShutdownEvent,0))
            {
            Sleep(100);
            }

        CloseHandle(g_hShutdownEvent);
        }

    //
    // TRANP thread should be dead by now . In case it isn't wait on it's handle and terminate
    // Otherwise we have a small chance of unloading DLL before thread is dead, shutting down WIA service
    //
    dwStatus = ::WaitForSingleObject(hThread,100);
    if (dwStatus == WAIT_TIMEOUT) {
        // Have to be rude
        // BUGBUG Assert
        ::TerminateThread(hThread,NOERROR);
    }

    // Shutdown memory management:
    dwStatus = UninitializeMemory();

    return fSuccess;
    }


#ifdef RUN_AS_EXE

//---------------------------------------------------------------------
// main()
//
//---------------------------------------------------------------------
int __cdecl main( int argc, char **argv )
    {
    DWORD  dwStatus;

    printf("IrTran-P: Start\n");

    dwStatus = IrTranP( NULL );

    if (dwStatus)
        {
        printf("IrTran-P: Status: 0x%x (%d)\n",dwStatus,dwStatus);
        }

    return 0;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\precomp.h ===
//---------------------------------------------------------------------
//  Copyright (c)1998-1999 Microsoft Corporation, All Rights Reserved.
//
//  precomp.h
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//    Edward Reus (edwardr)     08-27-99   Modified for Millennium & WIA.
//
//---------------------------------------------------------------------


#include <windows.h>
#include <winsock2.h>

#ifndef  _WIN32_WINDOWS
   #define  _WIN32_WINDOWS
#endif

#include <af_irda.h>
#include <shlobj.h>
#include "irtranp.h"
#include "io.h"
#include "scep.h"
#include "../progress.h"
#include "conn.h"

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"
#include "wiamindr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\scep.cpp ===
//--------------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  scep.cpp
//
//  This file holds most of the implementation of CSCEP_CONNECTION
//  objects. Each active connection to a camera is represented by
//  a separate CSCEP_CONNECTION object. The CSCEP_CONNECTION is then
//  destroyed when the connection (socket) to the camera is closed.
//
//  Author:
//
//    Edward Reus (edwardr)     02-24-98   Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

typedef struct _ATTRIBUTE_TOKEN
    {
      DWORD  dwTokenType;
      UCHAR *pChars;
      DWORD  dwSize;
    } ATTRIBUTE_TOKEN;

#define ATTRIBUTE_NAME_SIZE        2

#define COLON                     ':'
#define ONE                       '1'
#define SPACE                     ' '
#define TAB                       '\t'
#define CR                        0x0d
#define LF                        0x0a

#define ATTRIBUTE_NAME             0
#define ATTRIBUTE_COLON            1
#define ATTRIBUTE_VALUE            2
#define ATTRIBUTE_CRLF             3

#define ATTR_PDU_SIZE              0
#define ATTR_PRODUCT_ID            1
#define ATTR_USER_NAME             2
#define ATTR_PASSWORD              3

//--------------------------------------------------------------------
// Globals:
//--------------------------------------------------------------------

extern  HINSTANCE  g_hInst;    // Instance for DLL ircamera.dll

static  DWORD      g_adwPduSizes[] 
                      = { PDU_SIZE_1, PDU_SIZE_2, PDU_SIZE_3, PDU_SIZE_4 };

#ifdef DBG_MEM
static  LONG g_lCScepConnectionCount = 0;
#endif

//--------------------------------------------------------------------
// SkipBlanks()
//
//--------------------------------------------------------------------
void SkipBlanks( IN OUT UCHAR **ppAttributes,
                 IN OUT DWORD  *pdwAttributeSize )
    {
    while ( (*pdwAttributeSize > 0)
          && ((**ppAttributes == SPACE)||(**ppAttributes == TAB)) )
        {
        (*ppAttributes)++;
        (*pdwAttributeSize)--;
        }
    }

//--------------------------------------------------------------------
// NextToken()
//
//--------------------------------------------------------------------
ATTRIBUTE_TOKEN *NextToken( IN     DWORD   dwTokenType,
                            IN OUT UCHAR **ppAttributes,
                            IN OUT DWORD  *pdwAttributeSize )
    {
    ATTRIBUTE_TOKEN *pToken = 0;

    SkipBlanks(ppAttributes,pdwAttributeSize);

    if ((!*ppAttributes) || (*pdwAttributeSize == 0))
        {
        return 0;
        }

    pToken = (ATTRIBUTE_TOKEN*)AllocateMemory(sizeof(ATTRIBUTE_TOKEN));
    if (!pToken)
        {
        return 0;
        }

    pToken->dwTokenType = dwTokenType;

    switch (dwTokenType)
        {
        case ATTRIBUTE_NAME:
            if (*pdwAttributeSize < ATTRIBUTE_NAME_SIZE)
                {
                FreeMemory(pToken);
                pToken = 0;
                break;
                }

            pToken->pChars = *ppAttributes;
            pToken->dwSize = ATTRIBUTE_NAME_SIZE;
            *ppAttributes += ATTRIBUTE_NAME_SIZE;
            *pdwAttributeSize -= ATTRIBUTE_NAME_SIZE;
            break;

        case ATTRIBUTE_COLON:
            if (**ppAttributes == COLON)
                {
                pToken->pChars = *ppAttributes;
                pToken->dwSize = 1;
                *ppAttributes += 1;
                *pdwAttributeSize -= 1;
                }
            break;

        case ATTRIBUTE_VALUE:
            pToken->pChars = *ppAttributes;
            pToken->dwSize = 0;
            while ((**ppAttributes != CR) && (*pdwAttributeSize > 0))
                {
                (*ppAttributes)++;
                (*pdwAttributeSize)--;
                (pToken->dwSize)++;
                }
            break;

        case ATTRIBUTE_CRLF:
            pToken->pChars = *ppAttributes;
            pToken->dwSize = 2;
            *ppAttributes += 2;
            *pdwAttributeSize -= 2;
            if ((pToken->pChars[0] != CR)||(pToken->pChars[1] != LF))
                {
                FreeMemory(pToken);
                pToken = 0;
                }
            break;

        default:
            FreeMemory(pToken);
            pToken = 0;
            break;
        }

    return pToken;
    }

//--------------------------------------------------------------------
// IsAttributeName()
//
//--------------------------------------------------------------------
BOOL IsAttributeName( ATTRIBUTE_TOKEN *pToken,
                      int        *piAttribute )
    {
    BOOL fIsName = FALSE;

    if ((pToken->pChars[0] == 'f')&&(pToken->pChars[1] == 'r'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PDU_SIZE;
        }
    else
    if ((pToken->pChars[0] == 'i')&&(pToken->pChars[1] == 'd'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PRODUCT_ID;
        }
    else
    if ((pToken->pChars[0] == 'n')&&(pToken->pChars[1] == 'm'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_USER_NAME;
        }
    else
    if ((pToken->pChars[0] == 'p')&&(pToken->pChars[1] == 'w'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PASSWORD;
        }

    return fIsName;
    }

//--------------------------------------------------------------------
// NewTokenString()
//
//--------------------------------------------------------------------
UCHAR *NewTokenString( IN  ATTRIBUTE_TOKEN *pToken,
                       OUT DWORD           *pdwStatus )
    {
    UCHAR *pszNewStr = (UCHAR*)AllocateMemory(1+pToken->dwSize);

    if (!pszNewStr)
        {
        *pdwStatus = ERROR_OUTOFMEMORY;
        return 0;
        }

    memcpy(pszNewStr,pToken->pChars,pToken->dwSize);
    pszNewStr[pToken->dwSize] = 0;

    return pszNewStr;
    }
                      
//--------------------------------------------------------------------
// CSCEP_CONNECTION::CSCEP_CONNECTION()
//
//--------------------------------------------------------------------
CSCEP_CONNECTION::CSCEP_CONNECTION()
    {
    m_dwConnectionState = STATE_CLOSED;
    m_dwPduSendSize = PDU_SIZE_1;    // default is 512 bytes.
    m_dwPduReceiveSize = PDU_SIZE_4;
    m_CFlag = 0;
    m_pPrimaryMachineId = 0;
    m_pSecondaryMachineId = 0;
    m_DestPid = DEFAULT_PID;
    m_SrcPid = DEFAULT_PID;
    m_pszUserName = 0;
    m_pszPassword = 0;

    m_pAssembleBuffer = 0;
    m_dwAssembleBufferSize = 0;
    m_dwMaxAssembleBufferSize = 0;
    m_fDidByteSwap = FALSE;

    m_Fragmented = FALSE;
    m_DFlag = 0;
    m_dwSequenceNo = 0;
    m_dwRestNo = 0;
    m_dwCommandId = 0;
    m_pCommandHeader = 0;

    m_pszFileName = 0;
    m_pszSaveFileName = 0;
    m_pszLongFileName = 0;

    m_CreateTime.dwLowDateTime = 0;   // Picture create date/time.
    m_CreateTime.dwHighDateTime = 0;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::~CSCEP_CONNECTION()
//
//--------------------------------------------------------------------
CSCEP_CONNECTION::~CSCEP_CONNECTION()
    {
    if (m_pPrimaryMachineId)
        {
        FreeMemory(m_pPrimaryMachineId);
        }

    if (m_pSecondaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        }

    if (m_pszUserName)
        {
        FreeMemory(m_pszUserName);
        }

    if (m_pszPassword)
        {
        FreeMemory(m_pszPassword);
        }

    if (m_pAssembleBuffer)
        {
        FreeMemory(m_pAssembleBuffer);
        }

    if (m_pCommandHeader)
        {
        FreeMemory(m_pCommandHeader);
        }

    if (m_pszFileName)
        {
        FreeMemory(m_pszFileName);
        }

    if (m_pszSaveFileName)
        {
        FreeMemory(m_pszSaveFileName);
        }

    if (m_pszLongFileName)
        {
        FreeMemory(m_pszLongFileName);
        }
    }

//------------------------------------------------------------------------
//  CSCEP_CONNECTION::operator new()
//
//------------------------------------------------------------------------
void *CSCEP_CONNECTION::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    #ifdef DBG_MEM
    if (pObj)
        {
        InterlockedIncrement(&g_lCScepConnectionCount);
        }
    #endif

    return pObj;
    }

//------------------------------------------------------------------------
//  CSCEP_CONNECTION::operator delete()
//
//------------------------------------------------------------------------
void CSCEP_CONNECTION::operator delete( IN void *pObj,
                                        IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);
        }
    }


//--------------------------------------------------------------------
// CSCEP_CONNECTION::AssemblePdu()
//
// Take in bits of data as its read in. When a complete SCEP PDU has
// been read and assembled return it.
//
//   pInputData      - This is the data that just came in.
//
//   dwInputDataSize - Size in bytes of pInputData.
//
//   ppPdu           - Returns a complete SCEP PDU when this function
//                     returns NO_ERROR, otherwise set to 0.
//
//   pdwPduSize      - Size of the returned PDU.
//
// Return values:
//
//   NO_ERROR         - A new SCEP PDU is complete and ready.
//   ERROR_CONTINUE   - Data read so far is Ok, still waiting for more.
//   ERROR_SCEP_INVALID_PROTOCOL
//   ERROR_OUTOFMEMORY
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::AssemblePdu( IN  void         *pInputData,
                                     IN  DWORD         dwInputDataSize,
                                     OUT SCEP_HEADER **ppPdu,
                                     OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = ERROR_CONTINUE;
    UCHAR *pEnd;

    ASSERT(dwInputDataSize <= MAX_PDU_SIZE);

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwInputDataSize > 0)
        {
        if (!m_pAssembleBuffer)
           {
           m_dwMaxAssembleBufferSize = 2*MAX_PDU_SIZE;
           m_pAssembleBuffer 
                   = (UCHAR*)AllocateMemory(m_dwMaxAssembleBufferSize);
           if (!m_pAssembleBuffer)
               {
               return ERROR_OUTOFMEMORY;
               }

            memcpy(m_pAssembleBuffer,pInputData,dwInputDataSize);
            m_dwAssembleBufferSize = dwInputDataSize;
            }
        else
            {
            if (m_dwAssembleBufferSize+dwInputDataSize >= m_dwMaxAssembleBufferSize)
                {
                WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::AssemblePdu(): Buffer Overrun!"));
                }
            pEnd = &(m_pAssembleBuffer[m_dwAssembleBufferSize]);
            memcpy(pEnd,pInputData,dwInputDataSize);
            m_dwAssembleBufferSize += dwInputDataSize;
            }
        }

    // Check to see if enough data has come in for a complete PDU.
    dwStatus = CheckPdu(ppPdu,pdwPduSize);

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckPdu()
//
// Run through the "current" PDU and see if its complete. If its
// not yet complete, return ERROR_CONTINUE. If it is complete then
// return NO_ERROR.
//
// Return values:
//
//   NO_ERROR         - The current SCEP PDU is complete and ready.
//   ERROR_CONTINUE   - Data read so far is Ok, still waiting for more.
//   ERROR_SCEP_INVALID_PROTOCOL
//   ERROR_OUTOFMEMORY
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckPdu( OUT SCEP_HEADER **ppPdu,
                                  OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_NEGOTIATION *pInfNegotiation;

    if (m_dwAssembleBufferSize < 2)
        {
        return ERROR_CONTINUE;
        }

    switch ( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType )
        {
        case MSG_TYPE_CONNECT_REQ:
            dwStatus = CheckConnectPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_CONNECT_RESP:
            dwStatus = CheckConnectRespPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_DATA:
            dwStatus = CheckDataPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_DISCONNECT:
            dwStatus = CheckDisconnectPdu(ppPdu,pdwPduSize);
            break;

        default:
            // BUGBUG: Need different error return so we can 
            // return a proper nack to the camera...
            WIAS_ERROR((g_hInst,"CheckPdu(): Invalid Msgtype: %d\n", ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType ));
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            break;
        }
    
    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckConnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckConnectPdu( OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_VERSION     *pInfVersion;
    SCEP_NEGOTIATION *pInfNegotiation;
    SCEP_EXTEND      *pInfExtend;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_CONNECT_REQ);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_CONNECT)
        {
        return ERROR_CONTINUE;
        }

    if (m_dwAssembleBufferSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pInfVersion = (SCEP_VERSION*)(((SCEP_HEADER*)m_pAssembleBuffer)->Rest);

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_VERSION)
                                           + (char*)pInfVersion );

    pInfExtend = (SCEP_EXTEND*)( FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
                                 + pInfNegotiation->Length
                                 + (char*)pInfNegotiation );

    // Check to see if we have a complete connect PDU size-wise:
    dwSize = 10 + pInfNegotiation->Length;
    if (m_dwAssembleBufferSize == dwSize)
        {
        // Have a complete PDU.
        dwStatus = NO_ERROR;
        }
    else if (m_dwAssembleBufferSize < dwSize)
        {
        // Need to wait for more data to arrive
        dwStatus = ERROR_CONTINUE;
        }
    else
        {
        // Too much data...
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        // Check to make sure the contents of the PDU "look" Ok:

        if ( (pInfVersion->InfType != INF_TYPE_VERSION)
           || (pInfVersion->Version != PROTOCOL_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }

        if ( (pInfNegotiation->InfType != INF_TYPE_NEGOTIATION)
           || (pInfNegotiation->InfVersion < INF_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }

        if ( (pInfExtend->InfType != INF_TYPE_EXTEND)
           || (pInfExtend->Length != (sizeof(pInfExtend->Parameter1)
                                      +sizeof(pInfExtend->Parameter2)))
           || (pInfExtend->Parameter1 != 0)
           || (pInfExtend->Parameter2 != 0) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckConnectPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = m_dwAssembleBufferSize;
            memcpy(*ppPdu,m_pAssembleBuffer,m_dwAssembleBufferSize);
            m_dwAssembleBufferSize = 0;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
//  CSCEP_CONNECTION::CheckConnectRespPdu()                     CLIENT
//
//  A connect response from the IrTran-P server is either a ACK or
//  NACK PDU. If we get here then it's an ACK. We'll make sure the
//  entire PDU is here and that it is formatted correctly. There is
//  a specific message type for ACK PDUs, the NACK is just a special
//  case of MSG_TYPE_DATA and is handled elsewere (CheckDataPdu()).
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_HEADER      *pHeader;
    SCEP_NEGOTIATION *pInfNegotiation;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_CONNECT_RESP);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_CONNECT_RESP)
        {
        return ERROR_CONTINUE;
        }

    if (m_dwAssembleBufferSize > MAX_PDU_SIZE_CONNECT_RESP)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pHeader = (SCEP_HEADER*)m_pAssembleBuffer;

    pInfNegotiation = (SCEP_NEGOTIATION*)(pHeader->Rest);

    // Check to see if we have a complete connect PDU size-wise:
    dwSize = sizeof(SCEP_HEADER)
             + FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
             + pInfNegotiation->Length;

    if (m_dwAssembleBufferSize == dwSize)
        {
        // Have a complete PDU.
        dwStatus = NO_ERROR;
        }
    else if (m_dwAssembleBufferSize < dwSize)
        {
        // Need to wait for more data to arrive
        dwStatus = ERROR_CONTINUE;
        }
    else
        {
        // Too much data...
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        // Check to make sure the contents of the PDU "look" Ok:

        if ( (pInfNegotiation->InfType != INF_TYPE_NEGOTIATION)
           || (pInfNegotiation->InfVersion < INF_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckConnectRespPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = m_dwAssembleBufferSize;
            memcpy(*ppPdu,m_pAssembleBuffer,m_dwAssembleBufferSize);
            m_dwAssembleBufferSize = 0;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckDisconnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckDisconnectPdu( OUT SCEP_HEADER **ppPdu,
                                            OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwSize;
    SCEP_DISCONNECT  *pDisconnect;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_DISCONNECT);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_DISCONNECT)
        {
        return ERROR_CONTINUE;
        }

    pDisconnect = (SCEP_DISCONNECT*)(((SCEP_HEADER*)m_pAssembleBuffer)->Rest);

    // Check to make sure the contents of the PDU "look" Ok:

    if (pDisconnect->InfType != INF_TYPE_REASON)
        {
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (pDisconnect->Length1 != sizeof(USHORT))
        {
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckDisonnectPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = sizeof(SCEP_HEADER) + 2 + pDisconnect->Length1;
            memcpy(*ppPdu,m_pAssembleBuffer,*pdwPduSize);
            m_dwAssembleBufferSize -= *pdwPduSize;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckDataPdu()
//
// The goal here is to check to see if we have a complete formatted
// PDU, if yes the return NO_ERROR, if the PDU looks ok so far, but
// isn't complete (we need to read more), then return ERROR_CONTINUE.
//
// Also if this is a little-endian machine, byteswap the header
// fields accordingly.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckDataPdu( OUT SCEP_HEADER **ppPdu,
                                      OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwExpectedPduSize;
    UCHAR *pEnd;
    SCEP_REQ_HEADER_SHORT *pReqHeaderShort;
    SCEP_REQ_HEADER_LONG  *pReqHeaderLong;

    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType == MSG_TYPE_DATA);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_DATA)
        {
        return ERROR_CONTINUE;
        }

    // Get the length out of the PDU and see if we have a
    // complete PDU:

    pReqHeaderShort = (SCEP_REQ_HEADER_SHORT*)
                             (((SCEP_HEADER*)m_pAssembleBuffer)->Rest);
    if (pReqHeaderShort->Length1 == USE_LENGTH2)
        {
        // We have a long PDU:

        pReqHeaderLong = (SCEP_REQ_HEADER_LONG*)(pReqHeaderShort);

        #ifdef LITTLE_ENDIAN
        if (!m_fDidByteSwap)
            {
            ByteSwapReqHeaderLong(pReqHeaderLong);
            m_fDidByteSwap = TRUE;
            }
        #endif

        dwExpectedPduSize = sizeof(SCEP_HEADER)
                            + FIELD_OFFSET(SCEP_REQ_HEADER_LONG,InfVersion)
                            + pReqHeaderLong->Length2;
        }
    else
        {
        // We have a short PDU:

        #ifdef LITTLE_ENDIAN
        if (!m_fDidByteSwap)
            {
            ByteSwapReqHeaderShort(pReqHeaderShort);
            m_fDidByteSwap = TRUE;
            }
        #endif

        dwExpectedPduSize = sizeof(SCEP_HEADER)
                            + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT,InfVersion)
                            + pReqHeaderShort->Length1;
        }

    // Ok, see if we have a complete PDU:
    if (m_dwAssembleBufferSize == dwExpectedPduSize)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckDataPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = dwExpectedPduSize;
            memcpy(*ppPdu,m_pAssembleBuffer,dwExpectedPduSize);
            m_dwAssembleBufferSize = 0;
            m_fDidByteSwap = FALSE;
            dwStatus = NO_ERROR;
            }
        }
    else if (m_dwAssembleBufferSize > dwExpectedPduSize)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckDataPdu(): Out of memory."));
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = dwExpectedPduSize;
            memcpy(*ppPdu,m_pAssembleBuffer,dwExpectedPduSize);
            pEnd = dwExpectedPduSize + (UCHAR*)m_pAssembleBuffer;
            m_dwAssembleBufferSize -= dwExpectedPduSize;
            m_fDidByteSwap = FALSE;
            memcpy(m_pAssembleBuffer,pEnd,m_dwAssembleBufferSize);
            dwStatus = NO_ERROR;
            }
        }
    else
        {
        dwStatus = ERROR_CONTINUE;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseConnectPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectPdu()), so at this point we'll assume everything
// is Ok.
//
// NOTE: The Connect PDU is limited to 256 bytes in total length,
// so it will never be fragmented.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseConnectPdu( IN SCEP_HEADER *pPdu,
                                         IN DWORD        dwInputDataSize )
    {
    DWORD  dwStatus;
    DWORD  dwLength;

    if (dwInputDataSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    SCEP_VERSION     *pInfVersion;
    SCEP_NEGOTIATION *pInfNegotiation;
    SCEP_EXTEND      *pInfExtend;

    pInfVersion = (SCEP_VERSION*)pPdu->Rest;

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_VERSION)
                                           + (char*)pInfVersion );

    pInfExtend = (SCEP_EXTEND*)( FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
                                 + pInfNegotiation->Length
                                 + (char*)pInfNegotiation );

    // 
    m_CFlag = pInfNegotiation->CFlag;
    
    m_pSecondaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pSecondaryMachineId)
        {
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pSecondaryMachineId,
            pInfNegotiation->SecondaryMachineId,
            MACHINE_ID_SIZE );
    
    m_pPrimaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pPrimaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pPrimaryMachineId,
            pInfNegotiation->PrimaryMachineId,
            MACHINE_ID_SIZE );

    // NOTE: The size of the negotiaion "text" is 18 bytes less than
    // the length in the SCEP_NEGOTIATION record:
    dwLength = pInfNegotiation->Length
             - ( sizeof(pInfNegotiation->InfVersion)
               + sizeof(pInfNegotiation->CFlag)
               + sizeof(pInfNegotiation->SecondaryMachineId)
               + sizeof(pInfNegotiation->PrimaryMachineId));

    dwStatus = ParseNegotiation( pInfNegotiation->Negotiation, dwLength );

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseConnectRespPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectRespPdu()), so at this point we'll assume 
// everything is Ok.
//
// NOTE: The Connect Response PDU is limited to 255 bytes in total
// length, so it will never be fragmented.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseConnectRespPdu( IN SCEP_HEADER *pPdu,
                                             IN DWORD        dwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwLength;
    SCEP_NEGOTIATION *pInfNegotiation;


    if (dwPduSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_HEADER)
                                           + (char*)pPdu );

    // This is the CFlag sent by the other machine.
    m_CFlag = pInfNegotiation->CFlag;

    m_pSecondaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pSecondaryMachineId)
        {
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pSecondaryMachineId,
            pInfNegotiation->SecondaryMachineId,
            MACHINE_ID_SIZE );
    
    m_pPrimaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pPrimaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pPrimaryMachineId,
            pInfNegotiation->PrimaryMachineId,
            MACHINE_ID_SIZE );

    // NOTE: The size of the negotiaion "text" is 18 bytes less than
    // the length in the SCEP_NEGOTIATION record:
    dwLength = pInfNegotiation->Length
             - ( sizeof(pInfNegotiation->InfVersion)
               + sizeof(pInfNegotiation->CFlag)
               + sizeof(pInfNegotiation->SecondaryMachineId)
               + sizeof(pInfNegotiation->PrimaryMachineId));

    dwStatus = ParseNegotiation( pInfNegotiation->Negotiation, dwLength );

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseNegotiation()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseNegotiation( IN UCHAR *pNegotiation,
                                          IN DWORD  dwNegotiationSize )
    {
    DWORD  dwStatus = NO_ERROR;
    UCHAR *pNext = pNegotiation;
    DWORD  dwSize = dwNegotiationSize;

    if (dwNegotiationSize <= 1)
        {
        return NO_ERROR;
        }

    if (*(pNext++) < NEGOTIATION_VERSION)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    dwSize--;

    while (pNext=ParseAttribute(pNext,
                                &dwSize,
                                &dwStatus))
       {
       if (dwStatus != NO_ERROR)
           {
           break;
           }
       }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseAttribute()
//
// Attributes are of the form:
//  
// Attr      <- AttrName Colon AttrValue CrLf
//
// AttrName  <- Two byte attribute name.
//
// Colon     <- ':'
//
// AttrValue <- Character string (bytes > 0x1f and < 0x8f).
//
// CrLf      <- 0x0d 0x0a
//
//--------------------------------------------------------------------
UCHAR *CSCEP_CONNECTION::ParseAttribute( IN  UCHAR *pAttributes,
                                         IN  DWORD *pdwAttributeSize,
                                         OUT DWORD *pdwStatus )
    {
    int  iAttribute;
    int  iPduSize;
    ATTRIBUTE_TOKEN  *pToken1 = 0;
    ATTRIBUTE_TOKEN  *pToken2 = 0;
    ATTRIBUTE_TOKEN  *pToken3 = 0;
    ATTRIBUTE_TOKEN  *pToken4 = 0;

    *pdwStatus = NO_ERROR;

    if (  (pToken1=NextToken(ATTRIBUTE_NAME,&pAttributes,pdwAttributeSize))
       && (IsAttributeName(pToken1,&iAttribute))
       && (pToken2=NextToken(ATTRIBUTE_COLON,&pAttributes,pdwAttributeSize))
       && (pToken3=NextToken(ATTRIBUTE_VALUE,&pAttributes,pdwAttributeSize))
       && (pToken4=NextToken(ATTRIBUTE_CRLF,&pAttributes,pdwAttributeSize)) )
        {
        if (iAttribute == ATTR_PDU_SIZE)
            {
            iPduSize = pToken3->pChars[0] - ONE;
            if ((pToken3->dwSize == 1)&&(iPduSize >= 1)&&(iPduSize <= 4))
                {
                m_dwPduSendSize = g_adwPduSizes[iPduSize];
                }
            }
        else
        if (iAttribute == ATTR_PRODUCT_ID)
            {
            m_pszProductId = NewTokenString(pToken3,pdwStatus);
            if (!m_pszProductId)
                {
                pAttributes = 0;
                }
            }
        else
        if (iAttribute == ATTR_USER_NAME)
            {
            m_pszUserName = NewTokenString(pToken3,pdwStatus);
            if (!m_pszUserName)
                {
                pAttributes = 0;
                }
            }
        else
        if (iAttribute == ATTR_PASSWORD)
            {
            m_pszPassword = NewTokenString(pToken3,pdwStatus);
            if (!m_pszPassword)
                {
                pAttributes = 0;
                }
            }
        }
    else
        {
        if (*pdwAttributeSize > 0)
            {
            *pdwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        pAttributes = 0;
        }

    if (pToken1) FreeMemory(pToken1);
    if (pToken2) FreeMemory(pToken2);
    if (pToken3) FreeMemory(pToken3);
    if (pToken4) FreeMemory(pToken4);

    return pAttributes;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseDataPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectPdu()), so at this point we'll assume everything
// is Ok.
//
// NOTE: The Data PDU is limited to m_dwPduReceiveSize bytes in total
// length, if data is longer then you will get the fragmented versions
// of the Data PDU.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseDataPdu( IN  SCEP_HEADER     *pPdu,
                                      IN  DWORD            dwPduSize,
                                      OUT COMMAND_HEADER **ppCommand,
                                      OUT UCHAR          **ppUserData,
                                      OUT DWORD           *pdwUserDataSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwLengthOffset1;
    DWORD  dwLengthOffset3;

    // There are four cases of Data PDUs, single (unfragmented)
    // "short" and "long" PDUs, and fragmented "short" and
    // "long" PDUs:
    SCEP_REQ_HEADER_SHORT *pReqHeaderShort;
    SCEP_REQ_HEADER_LONG  *pReqHeaderLong;
    SCEP_REQ_HEADER_SHORT_FRAG *pReqHeaderShortFrag;
    SCEP_REQ_HEADER_LONG_FRAG  *pReqHeaderLongFrag;

    *ppCommand = 0;

    // Make sure the packet length makes sense...
    if (dwPduSize > m_dwPduReceiveSize)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pReqHeaderShort = (SCEP_REQ_HEADER_SHORT*)(pPdu->Rest);

    if (pReqHeaderShort->InfType != INF_TYPE_USER_DATA)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    //
    // See if we have a short or long PDU:
    //
    if (pReqHeaderShort->Length1 != USE_LENGTH2)
        {
        // This is a short PDU (use Length1).

        m_DFlag = pReqHeaderShort->DFlag;

        if ( (pReqHeaderShort->DFlag == DFLAG_SINGLE_PDU)
           || (pReqHeaderShort->DFlag == DFLAG_CONNECT_REJECT))
            {
            //
            // This is a short unfragmented PDU.
            //

            // Make sure that a command header is present:
            if (pReqHeaderShort->Length1 > 4)
                {
                *ppCommand = (COMMAND_HEADER*)(pReqHeaderShort->CommandHeader);
                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderShort->CommandHeader;
            *pdwUserDataSize = pReqHeaderShort->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = FALSE;
            m_dwSequenceNo = 0;
            m_dwRestNo = 0;

            // In this case, there are two different lengths
            // in the PDU that must add up to dwPduSize...
            //
            // Note: Note: Not currently testing Length1 for 
            //       consistency...
            //
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT,CommandHeader);

            if (dwPduSize != dwLengthOffset3+pReqHeaderShort->Length3)
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (pReqHeaderShort->DFlag == DFLAG_FIRST_FRAGMENT)
            {
            //
            // This is a short fragmented PDU, and is the first 
            // fragment, so it will contain a COMMAND_HEADER.
            //
            // In practice, this should probably never show up...

            pReqHeaderShortFrag = (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort;

            // The command header is present only on the first fragment
            // of a multi-fragment PDU:
            if (pReqHeaderShortFrag->SequenceNo == 0)
                {
                *ppCommand 
                    = (COMMAND_HEADER*)(pReqHeaderShortFrag->CommandHeader);

                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData 
                = COMMAND_HEADER_SIZE + pReqHeaderShortFrag->CommandHeader;
            *pdwUserDataSize 
                = pReqHeaderShortFrag->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderShortFrag->SequenceNo;
            m_dwRestNo = pReqHeaderShortFrag->RestNo;

            // Check the two length fields for consistency:
            dwLengthOffset1 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,InfVersion);
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,SequenceNo);

            if ( (dwPduSize != dwLengthOffset1+pReqHeaderShortFrag->Length1)
               || (dwPduSize != dwLengthOffset3+pReqHeaderShortFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (  (pReqHeaderShort->DFlag == DFLAG_FRAGMENT)
                || (pReqHeaderShort->DFlag == DFLAG_LAST_FRAGMENT))
            {
            //
            // This is a short fragmented PDU.
            //
            // The 2nd through last fragmented PDUs don't contain a
            // COMMAND_HEADER, just data after Length3.
            pReqHeaderShortFrag = (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort;

            // The command header is present only on the first fragment
            // of a multi-fragment PDU:
            if (pReqHeaderShortFrag->SequenceNo == 0)
                {
                *ppCommand 
                    = (COMMAND_HEADER*)(pReqHeaderShortFrag->CommandHeader);

                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData = pReqHeaderShortFrag->CommandHeader;
            *pdwUserDataSize = pReqHeaderShortFrag->Length3;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderShortFrag->SequenceNo;
            m_dwRestNo = pReqHeaderShortFrag->RestNo;

            // Check the two length fields for consistency:
            dwLengthOffset1 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,InfVersion);
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,SequenceNo);

            if ( (dwPduSize != dwLengthOffset1+pReqHeaderShortFrag->Length1)
               || (dwPduSize != dwLengthOffset3+pReqHeaderShortFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else
            {
            // Undefined DFlag, we've got a problem...
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }
    else
        {
        // We have a long PDU.

        pReqHeaderLong = (SCEP_REQ_HEADER_LONG*)pReqHeaderShort;

        m_DFlag = pReqHeaderLong->DFlag;

        if ( (pReqHeaderLong->DFlag == DFLAG_SINGLE_PDU)
           || (pReqHeaderLong->DFlag == DFLAG_CONNECT_REJECT))
            {
            //
            // This is a long unfragmented PDU.
            //
            *ppCommand = (COMMAND_HEADER*)(pReqHeaderLong->CommandHeader);
            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderLong->CommandHeader;
            *pdwUserDataSize = pReqHeaderLong->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = FALSE;
            m_dwSequenceNo = 0;
            m_dwRestNo = 0;
            m_SrcPid = (*ppCommand)->SrcPid;
            m_DestPid = (*ppCommand)->DestPid;
            m_dwCommandId = (*ppCommand)->CommandId;

            // In this case, there are two different lengths
            // in the PDU that must add up to dwPduSize...
            if ( (dwPduSize != 6UL+pReqHeaderLong->Length2)
               || (dwPduSize != 10UL+pReqHeaderLong->Length3))
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (pReqHeaderLong->DFlag == DFLAG_FIRST_FRAGMENT)
            {
            //
            // This is the first fragment of a long fragmented PDU.
            //
            pReqHeaderLongFrag = (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong;

            m_pCommandHeader = (COMMAND_HEADER*)AllocateMemory(sizeof(COMMAND_HEADER));
            if (!m_pCommandHeader)
                {
                dwStatus = ERROR_OUTOFMEMORY;
                }
            else
                {
                memcpy(m_pCommandHeader,
                       pReqHeaderLongFrag->CommandHeader,
                       COMMAND_HEADER_SIZE );

                *ppCommand = m_pCommandHeader;
                }

            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderLongFrag->CommandHeader;
            *pdwUserDataSize = pReqHeaderLongFrag->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderLongFrag->SequenceNo;
            m_dwRestNo = pReqHeaderLongFrag->RestNo;
            m_dwCommandId = (*ppCommand)->CommandId;

            // Check the two length fields for consistency:
            if ( (dwPduSize != (DWORD)6+pReqHeaderLongFrag->Length2)
               || (dwPduSize != (DWORD)18+pReqHeaderLongFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if ( (pReqHeaderLong->DFlag == DFLAG_FRAGMENT)
                  || (pReqHeaderLong->DFlag == DFLAG_LAST_FRAGMENT) )
            {
            //
            // This is the second through last fragment of a long 
            // fragmented PDU.
            //
            // In this case the PDU doesn't contain a command
            // header, just more user data...
            //
            pReqHeaderLongFrag = (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong;

            *ppCommand = m_pCommandHeader;
            *ppUserData = (UCHAR*)(pReqHeaderLongFrag->CommandHeader);
            *pdwUserDataSize = pReqHeaderLongFrag->Length3;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderLongFrag->SequenceNo;
            m_dwRestNo = pReqHeaderLongFrag->RestNo;
            if (*ppCommand)
               {
               m_dwCommandId = (*ppCommand)->CommandId;
               }

            // Check the two length fields for consistency:
            if ( (dwPduSize != (DWORD)6+pReqHeaderLongFrag->Length2)
               || (dwPduSize != (DWORD)18+pReqHeaderLongFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else
            {
            // Undefined DFlag, we've got a problem...
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseDisconnectPdu()
//
// NOTE: In practice, reason codes should always be 2 bytes for
//       SCEP version 1.0.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseDisconnectPdu( IN  SCEP_HEADER *pPdu,
                                            IN  DWORD        dwPduSize )
    {
    DWORD  dwStatus;

    SCEP_DISCONNECT *pDisconnect = (SCEP_DISCONNECT*)(pPdu->Rest);

    if ( (pDisconnect->InfType != INF_TYPE_REASON)
       || (pDisconnect->Length1 != sizeof(USHORT))
       || (pDisconnect->ReasonCode == 0) )
        {
        dwStatus = ERROR_SCEP_UNSPECIFIED_DISCONNECT;
        }
    else if (pDisconnect->ReasonCode == 1)
        {
        dwStatus = ERROR_SCEP_USER_DISCONNECT;
        }
    else if (pDisconnect->ReasonCode == 2)
        {
        dwStatus = ERROR_SCEP_PROVIDER_DISCONNECT;
        }
    else
        {
        dwStatus = ERROR_SCEP_UNSPECIFIED_DISCONNECT;
        }
    
    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParsePdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParsePdu( IN  SCEP_HEADER *pPdu,
                                  IN  DWORD        dwPduSize,
                                  OUT COMMAND_HEADER **ppCommandHeader,
                                  OUT UCHAR          **ppUserData,
                                  OUT DWORD           *pdwUserDataSize )
    {
    DWORD  dwStatus = NO_ERROR;

    *ppCommandHeader = 0;
    *ppUserData = 0;
    *pdwUserDataSize = 0;

    switch (pPdu->MsgType)
        {
        case MSG_TYPE_CONNECT_REQ:
            dwStatus = ParseConnectPdu( pPdu, dwPduSize );
            break;

        case MSG_TYPE_CONNECT_RESP:
            dwStatus = ParseConnectRespPdu( pPdu, dwPduSize );
            break;

        case MSG_TYPE_DATA:
            dwStatus = ParseDataPdu( pPdu, 
                                     dwPduSize, 
                                     ppCommandHeader, 
                                     ppUserData,
                                     pdwUserDataSize );
            break;

        case MSG_TYPE_DISCONNECT:
            dwStatus = ParseDisconnectPdu( pPdu, dwPduSize );
            break;

        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectPdu( OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_VERSION      *pVersion;
    SCEP_NEGOTIATION  *pNegotiation;
    SCEP_EXTEND       *pExtend;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // Note that the PDU size doesn't include a trailing zero, as you 
    // would think by lookin at "sizeof(CONNECT_PDU_ATTRIBUTES)" below.
    // The extra byte is for the first byte of the Negotiation string
    // (which is the Negotiation version), so the eqn below is +1-1...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_VERSION)
                + sizeof(SCEP_NEGOTIATION)
                + sizeof(CONNECT_PDU_ATTRIBUTES)
                + sizeof(SCEP_EXTEND);

    pHeader = NewPdu();  // PDU size is defaulted to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_REQ;

    pVersion = (SCEP_VERSION*)(pHeader->Rest);
    pVersion->InfType = INF_TYPE_VERSION;
    pVersion->Version = PROTOCOL_VERSION;

    pNegotiation = (SCEP_NEGOTIATION*)((char*)pVersion + sizeof(SCEP_VERSION));
    pNegotiation->InfType = INF_TYPE_NEGOTIATION;
    pNegotiation->Length = 18 + sizeof(CONNECT_PDU_ATTRIBUTES);
    pNegotiation->InfVersion = INF_VERSION;
    pNegotiation->CFlag = CFLAG_ISSUE_OR_EXECUTE;
    // pNegotiation->SecondaryMachineId -- Leave set to zeros...
    // pNegotiation->PrimaryMachineId   -- Leave set to zeros...

    pNegotiation->Negotiation[0] = NEGOTIATION_VERSION;
    memcpy( &(pNegotiation->Negotiation[1]),
            CONNECT_PDU_ATTRIBUTES,
            sizeof(CONNECT_PDU_ATTRIBUTES)-1 );  // No Trailing zero...

    pExtend = (SCEP_EXTEND*)( (char*)pHeader + dwPduSize - sizeof(SCEP_EXTEND));
    pExtend->InfType = INF_TYPE_EXTEND;
    pExtend->Length = 2;
    pExtend->Parameter1 = 0;
    pExtend->Parameter2 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectRespPdu()
//
// This is the response PDU for a connection request from a camera.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_NEGOTIATION  *pNegotiation;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // Note that the PDU size doesn't include a trailing zero, as you 
    // would think by lookin at "sizeof(RESPONSE_PDU_ATTRIBUTES)" below,
    // the extra byte in for the first byte of the Negotiation string
    // which is the Negotiation version, so the eqn below is +1-1...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_NEGOTIATION)
                + sizeof(RESPONSE_PDU_ATTRIBUTES);

    pHeader = NewPdu();   // PDU size defaults to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_RESP;
    
    pNegotiation = (SCEP_NEGOTIATION*)(pHeader->Rest);
    pNegotiation->InfType = INF_TYPE_NEGOTIATION;
    pNegotiation->Length = 18 + sizeof(RESPONSE_PDU_ATTRIBUTES);
    pNegotiation->InfVersion = INF_VERSION;
    pNegotiation->CFlag = CFLAG_ISSUE_OR_EXECUTE;

    memcpy( pNegotiation->SecondaryMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pNegotiation->PrimaryMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    pNegotiation->Negotiation[0] = NEGOTIATION_VERSION;
    memcpy( &(pNegotiation->Negotiation[1]),
            RESPONSE_PDU_ATTRIBUTES,
            sizeof(RESPONSE_PDU_ATTRIBUTES)-1 );  // No Trailing zero...

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectNackPdu()
//
// This is the response PDU for a connection request from a camera
// when we want to reject the connection request.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectNackPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // A short PDU, there is now command header, so Length3 is zero...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_REQ_HEADER_SHORT)
                - sizeof(COMMAND_HEADER);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_REQ;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = sizeof(pReqHeader->InfVersion)
                        + sizeof(pReqHeader->DFlag)
                        + sizeof(pReqHeader->Length3);
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_CONNECT_REJECT;
    pReqHeader->Length3 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildAbortPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildAbortPdu( OUT SCEP_HEADER **ppPdu,
                                       OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    COMMAND_HEADER    *pCommandHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) + sizeof(SCEP_REQ_HEADER_SHORT);

    pHeader = NewPdu();   // PDU size default to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = 4 + sizeof(COMMAND_HEADER);
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_SINGLE_PDU;
    pReqHeader->Length3 = sizeof(COMMAND_HEADER);

    #ifdef LITTLE_ENDIAN
    pReqHeader->Length3 = ByteSwapShort(pReqHeader->Length3);
    #endif

    pCommandHeader = (COMMAND_HEADER*)(pReqHeader->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_ABORT;
    pCommandHeader->Length4 = 22;
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    #ifdef LITTLE_ENDIAN
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildStopPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildStopPdu( OUT SCEP_HEADER **ppPdu,
                                      OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) 
                + sizeof(SCEP_REQ_HEADER_SHORT)
                - sizeof(COMMAND_HEADER);

    pHeader = NewPdu();   // PDU size defaults to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = 4;
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_INTERRUPT;
    pReqHeader->Length3 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildDisconnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildDisconnectPdu( IN  USHORT        ReasonCode,
                                            OUT SCEP_HEADER **ppPdu,
                                            OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER     *pHeader;
    SCEP_DISCONNECT *pDisconnect;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) 
                + sizeof(SCEP_DISCONNECT);

    pHeader = NewPdu();   // PDU size defaults to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DISCONNECT;

    pDisconnect = (SCEP_DISCONNECT*)(pHeader->Rest);
    pDisconnect->InfType = INF_TYPE_REASON;
    pDisconnect->Length1 = sizeof(pDisconnect->ReasonCode);
    pDisconnect->ReasonCode = ReasonCode;

    #ifdef LITTLE_ENDIAN
    pDisconnect->ReasonCode = ByteSwapShort(pDisconnect->ReasonCode);
    #endif

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::SetScepLength()
//
// Update the length fields in a PDU to reflect the total length
// of a PDU.
//
// WARNING: Currently only supports long fragmented PDUs.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::SetScepLength( IN SCEP_HEADER *pPdu,
                                       IN DWORD        dwTotalPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_REQ_HEADER_LONG_FRAG *pScepHeader;

    if (dwTotalPduSize > MAX_PDU_SIZE)
        {
        dwStatus = ERROR_SCEP_PDU_TOO_LARGE;
        }
    else
        {
        pScepHeader = (SCEP_REQ_HEADER_LONG_FRAG *)(pPdu->Rest);
        pScepHeader->Length1 = USE_LENGTH2;
        pScepHeader->Length2 = (USHORT)dwTotalPduSize - 6;
        pScepHeader->Length3 = (USHORT)dwTotalPduSize - 18;

        #ifdef LITTLE_ENDIAN
        pScepHeader->Length2 = ByteSwapShort(pScepHeader->Length2);
        pScepHeader->Length3 = ByteSwapShort(pScepHeader->Length3);
        #endif
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\scep.h ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// scep.h
//
// Constants and Types for the Simple Command Execution Protocol
// (SCEP). This is the transport protocol for IrTran-P V1.0.
//
// NOTE: That IrTran-P is a big-endian protocol when on the net.
//
// NOTE: That the protocol data structures below assume that the
//       compiler generates structures with natural alignment by
//       field type.
//
// Author:
//
//   Edward Reus (edwardr)     02-05-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _SCEP_H_
#define _SCEP_H_

#ifndef _BFTP_H_
#include "bftp.h"
#endif

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#define  LITTLE_ENDIAN

#define  PROTOCOL_VERSION             0x01
#define  NEGOTIATION_VERSION          0x11   // SCEP_NEGOTIATION revision.
#define  INF_VERSION                  0x10   // Information Struct version.

#define  USE_LENGTH2                  0xff

// These PDU sizes are the default and negotiated sizes:
#define  PDU_SIZE_1                    512
#define  PDU_SIZE_2                   1024
#define  PDU_SIZE_3                   2048
#define  PDU_SIZE_4                   4096
#define  MAX_PDU_SIZE           PDU_SIZE_4

#define  DEFAULT_PDU_SIZE     MAX_PDU_SIZE

// These sizes are used to check if we have a complete PDU:
#define  MIN_PDU_SIZE_CONNECT           28
#define  MAX_PDU_SIZE_CONNECT          256
#define  MIN_PDU_SIZE_CONNECT_RESP      24
#define  MAX_PDU_SIZE_CONNECT_RESP     255

#define  MIN_PDU_SIZE_DATA               8

#define  MIN_PDU_SIZE_DISCONNECT         6

// These are the sizes of the SCEP headers:
#define  SCEP_HEADER_SIZE                2
#define  SCEP_REQ_HEADER_SHORT_SIZE     34
#define  COMMAND_HEADER_SIZE            28

#define  FILE_NAME_SIZE                 12  // 8.3

// These are the attribute strings that go in the negotiation part
// of connect request and response PDUs:
#define  CONNECT_PDU_ATTRIBUTES  "fr:3\r\nid:Microsoft IrTran-P v1.0\r\n"
#define  RESPONSE_PDU_ATTRIBUTES "fr:4\r\nid:Microsoft IrTran-P v1.0\r\n"

// Message Types (field: MsgType):
#define  MSG_TYPE_CONNECT_REQ         0x10  // Connection request.
#define  MSG_TYPE_CONNECT_RESP        0x11  // Connection confirmation.
#define  MSG_TYPE_DATA                0x20  // Data PDU.
#define  MSG_TYPE_DISCONNECT          0x30  // Disconnection.

// Information Types (field: InfType):
#define  INF_TYPE_VERSION             0x00  // Connection establishment.
#define  INF_TYPE_NEGOTIATION         0x01  // Connection establish or accept.
#define  INF_TYPE_USER_DATA           0x03  // Only if MsgType is MSG_TYPE_DATA.
#define  INF_TYPE_EXTEND              0x10  // Connection establishment.
#define  INF_TYPE_REASON              0x20  // Only for disconnect.

// Command Header: Pdu Types (top two bits in PduType):
#define  PDU_TYPE_REQUEST             0x00  // b:00000000
#define  PDU_TYPE_REPLY_ACK           0x40  // b:01000000
#define  PDU_TYPE_REPLY_NACK          0x80  // b:10000000
#define  PDU_TYPE_ABORT               0xc0  // b:11000000

#define  PDU_TYPE_MASK                0xc0  // b:11000000
#define  PDU_TYPE_RESERVED            0x3f  // b:00111111

// The machine ID is in the Connect PDU (SCEP_NEGOTIATION), it
// is in EUI-64 format:
#define  MACHINE_ID_SIZE                 8

// Machine PIDs: In the command header, the default source and destination
// program Ids are unsigned shorts with value 8. Some machines will have
// a PID other than this (see the first command header sent to us):
#define  DEFAULT_PID                     8

// CFlag meanings:
//
// There are two cases, one where a device/machine can only issue commands,
// the other when a device can both issue and execute commands.
//
#define  CFLAG_ISSUE_ONLY             0x00
#define  CFLAG_ISSUE_OR_EXECUTE       0x04

// DFlag Meanings:
//
// DFlag give information about the data and fragmentation (why did they
// put the reject in here?).
//
#define  DFLAG_SINGLE_PDU             0xc1
#define  DFLAG_FIRST_FRAGMENT         0x41
#define  DFLAG_FRAGMENT               0x01
#define  DFLAG_LAST_FRAGMENT          0x81
#define  DFLAG_INTERRUPT              0xc2
#define  DFLAG_CONNECT_REJECT         0xc3

// Reason Codes:
//
// Currently for V1.0 all reason codes are 2-byte numbers:
#define  REASON_CODE_UNSPECIFIED          0x0000
#define  REASON_CODE_USER_DISCONNECT      0x0001
#define  REASON_CODE_PROVIDER_DISCONNECT  0x0002

// Connection States:
#define  STATE_CLOSED                       0
#define  STATE_CONNECTING                   1
#define  STATE_CONNECTED                    2

// Put Response Protocol Error Codes (sent back to the camera):
#define  ERROR_PUT_UNDEFINED_ERROR     0x0000
#define  ERROR_PUT_ILLEGAL_DATA        0x0001
#define  ERROR_PUT_UNSUPPORTED_PID     0x0002
#define  ERROR_PUT_ILLEGAL_ATTRIBUTE   0x0010
#define  ERROR_PUT_UNSUPPORTED_CMD     0x0011
#define  ERROR_PUT_FILE_SYSTEM_FULL    0x0020
#define  ERROR_PUT_NO_FILE_OR_DIR      0x0021
#define  ERROR_PUT_LOW_BATTERY         0x0030
#define  ERROR_PUT_ABORT_EXECUTION     0x0031
#define  ERROR_PUT_NO_ERROR            0xffff

//--------------------------------------------------------------------
//  SCEP Protocol Headers:
//--------------------------------------------------------------------

// Turn off warning for zero-sized array...
#pragma warning(disable:4200)
#pragma pack(1)

typedef struct _SCEP_HEADER
   {
   UCHAR  Null;          // Always zero.
   UCHAR  MsgType;       // See MSG_TYPE_* above.
   UCHAR  Rest[];        // Dependent on the MsgType...
   } SCEP_HEADER;

typedef struct _SCEP_VERSION
   {
   UCHAR  InfType;       // Always INF_TYPE_VERSION (0x00).
   UCHAR  Version;       // Currently 0x01 (Version = 1).
   } SCEP_VERSION;

typedef struct _SCEP_NEGOTIATION
   {
   UCHAR  InfType;       // Always INF_TYPE_NEGOTATION (0x01).
   UCHAR  Length;        // Length (bytes) from InfVersion to
                         //   the end of the Negotiation information.
                         //   This will be from 0 to 228.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  CFlag;         //
   UCHAR  SecondaryMachineId[8]; //
   UCHAR  PrimaryMachineId[8];   //
   UCHAR  Negotiation[]; //
   } SCEP_NEGOTIATION;

typedef struct _SCEP_DISCONNECT
   {
   UCHAR  InfType;       // Always INF_TYPE_REASON (0x20).
   UCHAR  Length1;       // For V1.0 this should be 2.
   USHORT ReasonCode;    // See the REASON_CODE_xxx
   } SCEP_DISCONNECT;

typedef struct _SCEP_EXTEND
   {
   UCHAR  InfType;       // Always INF_TYPE_EXTEND (0x10).
   UCHAR  Length;        // Always 2 (bytes).
   UCHAR  Parameter1;
   UCHAR  Parameter2;
   } SCEP_EXTEND;

typedef struct _COMMAND_HEADER
   {
   UCHAR  Marker58h;      // Always 0x58 (See: 3.2.2.1.3 of Protocol).
   UCHAR  PduType;        // One of: PDU_TYPE_xxxx.
   ULONG  Length4;
   UCHAR  DestMachineId[MACHINE_ID_SIZE];
   UCHAR  SrcMachineId[MACHINE_ID_SIZE];
   USHORT DestPid;
   USHORT SrcPid;
   USHORT CommandId;
   } COMMAND_HEADER;

typedef struct _SCEP_REQ_HEADER_SHORT
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_SHORT;

typedef struct _SCEP_REQ_HEADER_LONG
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   USHORT Length2;       // Only present if Length1 == 0xff.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_LONG;

typedef struct _SCEP_REQ_HEADER_SHORT_FRAG
   {
   UCHAR  Inftype;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   DWORD  SequenceNo;    // Fragment number.
   DWORD  RestNo;        // Number of fragments left for this PDU.
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_SHORT_FRAG;

typedef struct _SCEP_REQ_HEADER_LONG_FRAG
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   USHORT Length2;       // Only present if Length1 == 0xff.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   DWORD  SequenceNo;    // Fragment number.
   DWORD  RestNo;        // Number of fragments left for this PDU.
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_LONG_FRAG;

#pragma pack()
#pragma warning(default:4200)

//--------------------------------------------------------------------
//  SCEP API Structures:
//--------------------------------------------------------------------

class CSCEP_CONNECTION
{
public:
    CSCEP_CONNECTION();
    ~CSCEP_CONNECTION();

    void  *operator new( IN size_t Size );

    void   operator delete( IN void  *pObj,
                            IN size_t Size );

    // Assemble the next PDU as data comes in:
    DWORD  AssemblePdu( IN  void         *pInputData,
                        IN  DWORD         dwInputDataSize,
                        OUT SCEP_HEADER **ppPdu,
                        OUT DWORD        *pdwPduSize );

    // Parse the PDU returned from AssemblePdu():
    DWORD  ParsePdu( IN  SCEP_HEADER *pPdu,
                     IN  DWORD        dwPduSize,
                     OUT COMMAND_HEADER **ppCommand,
                     OUT UCHAR          **ppUserData,
                     OUT DWORD           *pdwUserDataSize );

    DWORD  SetScepLength( IN SCEP_HEADER *pPdu,
                          IN DWORD        dwTotalPduSize );

    // Construct SCEP connection/control PDUs:
    DWORD  BuildConnectPdu( OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    DWORD  BuildConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  BuildConnectNackPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  BuildAbortPdu( OUT SCEP_HEADER **ppPdu,
                          OUT DWORD        *pdwPduSize );

    DWORD  BuildStopPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  BuildDisconnectPdu( IN  USHORT        ReasonCode,
                               OUT SCEP_HEADER **ppPdu,
                               OUT DWORD        *pdwPduSize );

    // Build bFTP request (client-side) PDUs:
    DWORD  BuildBftpWht0RinfPdu( OUT SCEP_HEADER          **ppPdu,
                                 OUT DWORD                 *pdwPduSize,
                                 OUT SCEP_REQ_HEADER_LONG **ppCommand,
                                 OUT COMMAND_HEADER       **ppCommandHeader );

    DWORD  BuildBftpPutPdu( IN  DWORD                       dwUpfFileSize,
                            IN  CHAR                       *pszUpfFile,
                            IN OUT DWORD                   *pdwFragNo,
                            OUT SCEP_HEADER               **ppPdu,
                            OUT DWORD                      *pdwPduSize,
                            OUT SCEP_REQ_HEADER_LONG_FRAG **ppCommand );

    // Build bFTP response PDUs:
    DWORD  BuildBftpRespPdu( IN  DWORD            dwPduSize,
                             OUT SCEP_HEADER    **ppPdu,
                             OUT SCEP_REQ_HEADER_SHORT **ppCommand,
                             OUT COMMAND_HEADER **ppCommandHeader );

    DWORD  BuildWht0RespPdu( IN  DWORD         dwWht0Type,
                             OUT SCEP_HEADER **ppPdu,
                             OUT DWORD        *pdwPduSize );

    DWORD  BuildPutRespPdu( IN  DWORD         dwPduAckOrNack,
                            IN  USHORT        usErrorCode,
                            OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    // Parse the bFTP in a SCEP command request PDU:
    DWORD  ParseBftp( IN  UCHAR  *pvBftpData,
                      IN  DWORD   dwDataSize,
                      IN  BOOL    fSaveAsUPF,
                      OUT DWORD  *pdwBftpOp,
                      OUT UCHAR **ppPutData,
                      OUT DWORD  *pdwPutDataSize );

    // Parse and save the create date/time that was specified as a 
    // bFTP option:
    DWORD  SaveBftpCreateDate( IN UCHAR *pDate,
                               IN DWORD  dwLength );

    // Parse the UPF file header to find the image JPEG file:
    DWORD  ParseUpfHeaders( IN UCHAR  *pPutData,
                            IN DWORD   dwPutDataSize,
                            OUT DWORD *pdwJpegOffset,
                            OUT DWORD *pdwJpegSize );

    // Used when a SCEP command PDU is received:
    BOOL   IsFragmented();
    DWORD  GetSequenceNo();
    DWORD  GetRestNo();
    DWORD  GetCommandId();
    CHAR  *GetFileName();
    UCHAR  GetDFlag();
    FILETIME *GetCreateTime();

protected:

    DWORD  CheckPdu( OUT SCEP_HEADER **ppPdu,
                     OUT DWORD        *pdwPduSize );

    DWORD  CheckConnectPdu( OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    DWORD  CheckAckPdu( OUT SCEP_HEADER **ppPdu,
                        OUT DWORD        *pdwPduSize );

    DWORD  CheckNackPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  CheckConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  CheckDataPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  CheckDisconnectPdu( OUT SCEP_HEADER **ppPdu,
                               OUT DWORD        *pdwPduSize );

    DWORD  ParseConnectPdu( IN SCEP_HEADER *pPdu,
                            IN DWORD        dwPduSize );

    DWORD  ParseConnectRespPdu( IN SCEP_HEADER *pPdu,
                                IN DWORD        dwPduSize );

    DWORD  ParseDataPdu( IN  SCEP_HEADER *pPdu,
                         IN  DWORD        dwPduSize,
                         OUT COMMAND_HEADER **ppCommand,
                         OUT UCHAR          **ppUserData,
                         OUT DWORD           *pdwUserDataSize );

    DWORD  ParseDisconnectPdu( IN SCEP_HEADER *pPdu,
                               IN DWORD        dwPduSize );

    DWORD  ParseNegotiation( IN UCHAR *pNegotiation,
                             IN DWORD  dwNegotiationSize );

    UCHAR *ParseAttribute( IN     UCHAR *pAttributes,
                           IN OUT DWORD *pdwAttributeSize,
                           OUT    DWORD *pdwStatus );

    DWORD  ParseSingleLongPdu( IN SCEP_HEADER *pPdu,
                               IN DWORD        dwPduSize );

    BFTP_ATTRIBUTE *ParseBftpAttributeName(
                               IN BFTP_ATTRIBUTE *pAttr,
                               IN OUT DWORD      *pdwSize,
                               OUT    DWORD      *pdwWhichAttr );

    DWORD   m_dwConnectionState;
    DWORD   m_dwPduSendSize;
    DWORD   m_dwPduReceiveSize;
    UCHAR   m_CFlag;
    UCHAR  *m_pPrimaryMachineId;
    UCHAR  *m_pSecondaryMachineId;
    USHORT  m_DestPid;        // My PID (Camera point of view).
    USHORT  m_SrcPid;         // Camera's PID (Camera point of view).
    UCHAR  *m_pszProductId;
    UCHAR  *m_pszUserName;
    UCHAR  *m_pszPassword;

    // Used during PDU assembley process.
    UCHAR  *m_pAssembleBuffer;
    DWORD   m_dwAssembleBufferSize;
    DWORD   m_dwMaxAssembleBufferSize;
    BOOL    m_fDidByteSwap;

    // Used to manage the current SCEP command PDU.
    UCHAR   m_Fragmented;
    UCHAR   m_DFlag;
    DWORD   m_dwSequenceNo;
    DWORD   m_dwRestNo;
    DWORD   m_dwCommandId;
    COMMAND_HEADER *m_pCommandHeader;

    //
    // NOTE: The m_pszFileName is the file name that the camera sent us,
    //       while pszSaveFileName is the file name will will actually
    //       save the file under (different extension). m_pszLongFileName
    //       is the optional BFTP file name (not currently used), it
    //       is not usually present in the BFTP.
    //
    CHAR    *m_pszFileName;
    CHAR    *m_pszSaveFileName;
    CHAR    *m_pszLongFileName;

    FILETIME m_CreateTime;
};

//--------------------------------------------------------------------
// Inline Functions:
//--------------------------------------------------------------------

inline BOOL CSCEP_CONNECTION::IsFragmented()
    {
    return m_Fragmented;
    }

inline DWORD CSCEP_CONNECTION::GetSequenceNo()
    {
    return m_dwSequenceNo;
    }

inline DWORD CSCEP_CONNECTION::GetRestNo()
    {
    return m_dwRestNo;
    }

inline DWORD CSCEP_CONNECTION::GetCommandId()
    {
    return m_dwCommandId;
    }

inline CHAR *CSCEP_CONNECTION::GetFileName()
    {
    return m_pszSaveFileName;
    }

inline UCHAR CSCEP_CONNECTION::GetDFlag()
    {
    return m_DFlag;
    }

inline FILETIME *CSCEP_CONNECTION::GetCreateTime()
    {
    if ( (m_CreateTime.dwLowDateTime)
       || (m_CreateTime.dwHighDateTime) )
        {
        return &m_CreateTime;
        }
    else
        {
        return 0;
        }
    }

//--------------------------------------------------------------------
// Utility Functions/Macros:
//--------------------------------------------------------------------

#define ByteSwapShort(Value)              \
            (  (((Value) & 0x00FF) << 8)  \
             | (((Value) & 0xFF00) >> 8))

#define ByteSwapLong(Value) \
            (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8)  \
             | (((Value) & 0x0000FF00) << 8)  \
             | (((Value) & 0x000000FF) << 24))

extern void ByteSwapReqHeaderShort( SCEP_REQ_HEADER_SHORT *pSingleShort );

extern void ByteSwapReqHeaderLong( SCEP_REQ_HEADER_LONG *pSingleLong );

extern void ByteSwapCommandHeader( COMMAND_HEADER *pCommandHeader );


//--------------------------------------------------------------------
// Memory management functions:
//--------------------------------------------------------------------

DWORD        InitializeMemory();

DWORD        UninitializeMemory();

void        *AllocateMemory( DWORD dwBytes );
 
DWORD        FreeMemory( void *pvMemory );

SCEP_HEADER *NewPdu( DWORD dwPduSize = MAX_PDU_SIZE );

void         DeletePdu( SCEP_HEADER *pPdu );

#if FALSE
//--------------------------------------------------------------------

    SCEP Connect PDU
    ----------------

    Connection request PDU. This is a SCEP_HEADER with Rest[] filled
    with three Inf Records, a SCEP_VERSION followed by a SCEP_NEGOTIATION
    followed by a SCEP_EXTEND. The Connect PDU must be less than or equal
    to 256 bytes in length.

      SCEP_HEADER                        2 bytes.
      Rest[]: SCEP_VERSION               2 bytes.
              SCEP_NEGOTIATION    20 - 228 bytes.
              SCEP_EXTEND                4 bytes.
                                  --------
                                  28 - 256 bytes.

    - If either the SecondaryMachineId[] or PrimariyMachineId is unused,
      then they are set to 00,00,00,00,00,00,00,00.
    - If a machine gets a Connect PDU but can't  execute commands
      (CFlag = CFLAG_ISSUE_ONLY), then it needs to respond with a
      NACK PDU.
    - The negotiation information is a simple text based command
      language.


    SCEP Connection ACK PDU
    -----------------------

    Connection acceptance PDU. This is a SCEP_HEADER with Rest[] filled
    with two Inf Records, a SCEP_VERSION followed by a SCEP_NEGOTIATION.

      SCEP_HEADER                        2 bytes.
      SCEP_VERSION                       2 bytes.
      Rest[]: SCEP_NEGOTIATION      20-251 bytes.
                                    ------
                                    24-255 bytes.

    - Note that the size of the ACK PDU is limited by the fact that
      the Length field is a single byte and that the ACK PDU can not
      be fragmented. Normally these PDUs will never be this long.


    SCEP Connection NACK PDU
    ------------------------

    Connection rejected PDU. This one can have either of two different
    formats.

      SCEP_HEADER
      Rest[]: SCEP_REQ_HEADER_SHORT

      or

      SCEP_HEADER
      Rest[]: SCEP_REQ_HEADER_LONG

    - In the first case, Length1 = 4, DFlag = DFLAG_CONNECT_REJECT,
      and Length 3 = 0.
    - In the second case, Length1 = 0xff, DFlag = DFLAG_CONNECT_REJECT,
      and Length 3 = 0.


    SCEP Disconnect PDU
    -------------------

    A disconnect can be generated by either side of the connection,
    or by one of the transports at any time.

      SCEP_HEADER
      Rest[]: SCEP_DISCONNECT

    - For V1.0, Length1 = 2, and ReasonCode is a USHORT.


    SCEP Command Request and Response PDUs (Non-fragmented)
    -------------------------------------------------------

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT    4 + 0-254 bytes
                                       ---------
                                         6 - 260 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG    4 + 0-4090 bytes (1)
                                      ----------
                                        6 - 4096 bytes

    - In either case, DFlag = DFLAG_SINGLE_PDU.
    - PduType = PDU_TYPE_REQUEST.
    - If Length1 = 0xff then the long version is used.
    - The Length1(2) field specifies the byte size from InfVersion to the
      end of the user data. If the total size will exceed the maximum PDU
      size then the request must be fragmented.
    - So the total PDU size is: 6 + Length1(2) bytes.

    (1) Assuming the maximum PDU size is 4096 (fr:4).


    SCEP Command Request and Response PDUs (Fragmented)
    ---------------------------------------------------

    For requests these PDUs are generated when the PDU size is greater
    than that of the responder that you are connected to. For responses,
    the PDUs are fragmented when the returned data is greater than the
    maximum that the requester specified during the connection establishment.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT_FRAG    6 + 0-254 bytes
                                       ---------
                                         8 - 260 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG_FRAG    8 + 0-4088 bytes (1)
                                       ---------
                                       10 - 4096 bytes

    - For the first PDU fragment, DFlag = DFLAG_FIRST_FRAGMENT, for
      intermediate fragments, DFlag = DFLAG_FRAGMENT, and for the
      last fragment, DFlag = DFLAG_LAST_FRAGMENT.
    - PduType = PDU_TYPE_REQUEST for the request.
    - PduType = PDU_TYPE_REPLY_ACK or PDU_TYPE_REPLY_NACK in the
      response.
    - If Length1 = 0xff then the long version is used.
    - Length1(2) can not exceed the maximum PDU size - 6 bytes.
    - SequenceNo is 0 for the first PDU (NOTE: 4 bytes).
    - RestNo is the remaining number of PDUs to get. It is 1 for
      the last PDU (really, it says so in the spec!). So, a client
      should start this as the total number of PDUs in the first
      fragment (not really the number remaining). NOTE: 4 bytes.

    (1) Assuming the maximum PDU size is 4096 (fr:4).


    SCEP Abort PDU
    --------------

    Use the abort to stop execution of a command (specified by the
    DestPid and CommandId) after ALL of the request PDUs have been
    sent. An abort PDU also has two possible formats.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT           34 bytes
                                              --
                                              36 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG            36 bytes
                                              --
                                              38 bytes

    - In either case, DFlag = DFLAG_SINGLE_PDU.
    - In either case, PduType = PDU_TYPE_ABORT.
    - For the short PDU, Length1 = 0x20 (32), and Length3 = 0x1c
      (28).
    - For the long PDU, Length1 = 0xff, Length2 = 0x20 (32),
      and Length3 = 0x1c (28).


    SCEP Stop (Interrupt) PDU
    -------------------------

    If an Abort PDU has been sent out to stop a command, and as the
    command is halted some response data has already been sent, the
    the responder will send this PDU. It appears that a Stop PDU should
    not be sent if no response has yet been sent back.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT            6 bytes
                                              --
                                               8 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG             8 bytes
                                              --
                                              10 bytes

    - In either case, DFlag = DFLAG_INTERRUPT.
    - For the short PDU, Length1 = 4, and Length3 = 0.
    - For the long PDU, Length1 = 0xff, Length2 = 4, and
      Length3 = 0.

    Negotiation Information
    -----------------------

    The negotiation information is used to convey the frame size,
    authentication data, and product information, etc.

    Its structure is a version code (currently 0x11) followed by
    text in the following syntax:

      NegInf    -> Attribute ':' Spaces Value CrLf

      Attribute -> AttribChar AttribChar

      AttribChar-> 'a-zA-Z'

      Value     -> ValueChar Value
                ->

      ValueChar -> 'ASCII string, bytes must be between 0x20 and 0x8e
                    inclusive'

      Spaces    -> ' ' Spaces
                ->

      CrLf      -> 0x0d 0x0a

      Attribute    Meaning
      ---------    -------
      fr           Frame (PDU) size. The sender requests the maximum
                   receivable PDU size, the receiver decides the
                   transmission PDU size in accordance with the senders
                   requested PDU size. The maximum PDU size of the sender
                   may be different than that of the receiver. The value
                   is one of:

                   1 -  512 bytes PDU size (default).
                   2 - 1024 bytes PDU size.
                   3 - 2048 bytes PDU size.
                   4 - 4096 bytes PDU size.

      id           Product Identification string.

      nm           User name. any byte string that doesn't include CR or
                   LF (note the conflict in by values with the syntax
                   specification above). The user name may be up to 32
                   characters long.

      pw           Password. This is a MD5 encoded password expressed
                   in a 16 byte "hex" string, no spaces are allowd.
                   It appears that this will always be 32 characters
                   long. For example: 0aff3728e4a62791337984282871a6bc

//--------------------------------------------------------------------
#endif

#endif //_SCEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\ircamera\irtranp\version.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       version.h
//
//  Contents:   Provides version info
//
//  Author:     edwardr   04-28-99
//
//----------------------------------------------------------------------------

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Configuration Tool"
#define VER_INTERNALNAME_STR            "netafx.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\camera.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camera.cpp

Abstract:

    This module implements the CPTPCamera class, which is a generic implementation
    of a PTP camera. Transport-specific processing is implemented in a sub-class.

Author:

    William Hsieh (williamh) created

Revision History:

--*/

#include "ptppch.h"

//
// This thread reads event data from the device and sends it back to the minidriver
//
// Input:
//   pParam -- pointer to the CPTPCamera subclassed object which can read the data
// Output:
//   Thread exit code
//
DWORD
WINAPI
EventThread(
    LPVOID pParam
    )
{
    DBG_FN("EventThread");
    
    HRESULT hr = S_OK;
    
    CPTPCamera *pDevice;

    wiauDbgTrace("EventThread", "starting");

    pDevice = (CPTPCamera *)pParam;
    if (!pDevice)
    {
        wiauDbgError("EventThread", "invalid arg");
        return ERROR_INVALID_PARAMETER;
    }

    DWORD Win32Err;

    //
    // Call the callback once with a NULL pointer so that it can initialize itself
    //
    hr = (pDevice->GetPTPEventCallback())(pDevice->GetEventCallbackParam(), NULL);
    if (FAILED(hr))
    {
        //
        // Log an error, but keep on catching events
        //
        wiauDbgError("EventThread", "event callback failed");
    }

    //
    // Read an event from the device. If an error occurs, log an error message and then
    // continue, unless the operation was aborted by the main thread.
    //
    PPTP_EVENT pEventBuffer = pDevice->GetEventBuffer();
    while (TRUE)
    {
        ZeroMemory(pEventBuffer, sizeof(*pEventBuffer));
        hr = pDevice->ReadEvent(pEventBuffer);
        if (FAILED(hr))
        {
            wiauDbgError("EventThread", "ReadEvent failed");
            break;;
        }

        if (hr == S_FALSE) {
            wiauDbgTrace("EventThread", "ReadEvent cancelled");
            break;
        }

        if (g_dwDebugFlags & WIAUDBG_DUMP) {
            DumpEvent(pEventBuffer);
        }
        
        //
        // Send the event back to the minidriver via its callback function
        //
        hr = (pDevice->GetPTPEventCallback())(pDevice->GetEventCallbackParam(), pEventBuffer);
        if (FAILED(hr))
        {
            wiauDbgError("EventThread", "event callback failed");
        }
    }

    //
    // The thread will now exit normally
    //
    wiauDbgTrace("EventThread", "exiting");
    
    return 0;
}


//
// Constructor for CPTPCamera
//
CPTPCamera::CPTPCamera()
:   m_hEventThread(NULL),
    m_SessionId(0),
    m_Phase(CAMERA_PHASE_NOTREADY),
    m_NextTransactionId(PTP_TRANSACTIONID_MIN),
    m_pTransferBuffer(NULL),
    m_pPTPEventCB(NULL),
    m_pPTPDataCB(NULL),
    m_pEventCallbackParam(NULL),
    m_pDataCallbackParam(NULL), 
    m_bCameraWasReset(FALSE),
    m_HackModel(HACK_MODEL_NONE),
    m_HackVersion(0.0)
{
    //PP_INIT_TRACING(L"Microsoft\\WIA\\PtpUsb");
}

//
// Destructor for CPTPCamera
//
CPTPCamera::~CPTPCamera()
{
    if (m_pTransferBuffer)
    {
        delete [] m_pTransferBuffer;
        m_pTransferBuffer = NULL;
    }

    //PP_CLEANUP();
}

//
// This function is the first one called by the driver to open access to the camera. The
// subclass Open should call this function first.
//
// Input:
//   DevicePortName -- name used by sub-class to access device
//   pPTPEventCB -- pointer to event callback function
//
HRESULT
CPTPCamera::Open(
    LPWSTR DevicePortName,
    PTPEventCallback pPTPEventCB,
    PTPDataCallback pPTPDataCB,
    LPVOID pEventParam,
    BOOL bEnableEvents
    )
{
    DBG_FN("CPTPCamera::Open");

    HRESULT hr = S_OK;
    
    if (!DevicePortName ||
        ((bEnableEvents == TRUE) && (!pPTPEventCB)))
    {
        wiauDbgError("Open", "invalid arg");
        return E_INVALIDARG;
    }

    m_bEventsEnabled = bEnableEvents;

    //
    // Allocate the re-usable transfer buffer
    //
    m_pTransferBuffer = new BYTE[TRANSFER_BUFFER_SIZE];
    if (!m_pTransferBuffer)
    {
        wiauDbgError("Open", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Save the callback pointers and object
    //
    m_pPTPEventCB = pPTPEventCB;
    m_pPTPDataCB = pPTPDataCB;
    m_pEventCallbackParam = pEventParam;
    m_pDataCallbackParam = NULL;
    
    //
    // The camera isn't actually ready yet, but this is the best place to set the phase to idle
    //
    m_Phase = CAMERA_PHASE_IDLE;

    if (m_bEventsEnabled)
    {
        //
        // Create a thread to listen for events
        //
        DWORD ThreadId;
        m_hEventThread = CreateThread(NULL,             // security descriptor
                                      0,                // stack size, use same size as this thread
                                      EventThread,      // thread procedure
                                      this,             // parameter to the thread
                                      CREATE_SUSPENDED, // creation flags
                                      &ThreadId         // to receive thread id
                                     );
        if (!m_hEventThread)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "Open", "CreateThread failed");
            return hr;
        }
    }

    //
    // The subclass should now open the device with CreateFile or equivalent
    //

    return hr;
}

//
// This function closes the connection to the camera.
//
HRESULT
CPTPCamera::Close()
{
    DBG_FN("CPTPCamera::Close");

    HRESULT hr = S_OK;

    if (IsCameraSessionOpen())
    {
        hr = CloseSession();
        if (FAILED(hr))
        {
            wiauDbgError("Close", "CloseSession failed");
            return hr;
        }
    }

    return hr;
}

//
// This function is responsible for executing a PTP command, reading or
// writing any necessary data, and reading the response
//
// Input/Output:
//   pData -- pointer to use for optional reading or writing of data
//
HRESULT
CPTPCamera::ExecuteCommand(
    BYTE *pReadData,
    UINT *pReadDataSize,
    BYTE *pWriteData,
    UINT WriteDataSize,
    UINT NumCommandParams,
    CAMERA_PHASE NextPhase
    )
{
    DBG_FN("CPTPCamera::ExecuteCommand");

    HRESULT hr = S_OK;

    BOOL bCommandCancelled = FALSE;

    //
    // If data is being tranferred, check the appropriate buffer pointer
    //
    if ((NextPhase == CAMERA_PHASE_DATAIN && (!pReadData || !pReadDataSize)) ||
        (NextPhase == CAMERA_PHASE_DATAOUT && !pWriteData))
    {
        wiauDbgError("ExecuteCommand", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Verify NumCommandParams is not too big
    //
    if (NumCommandParams > COMMAND_NUMPARAMS_MAX)
    {
        wiauDbgError("ExecuteCommand", "Too many command params");
        return E_INVALIDARG;
    }

    //
    // Verify that the camera is ready
    //
    if (m_Phase != CAMERA_PHASE_IDLE)
    {
        wiauDbgError("ExecuteCommand", "camera is not in idle phase, phase = %d", m_Phase);
        return E_FAIL;
    }

    //
    // Set the session and transaction IDs
    //
    
    if (IsCameraSessionOpen())
    {
        m_CommandBuffer.SessionId = m_SessionId;
        m_CommandBuffer.TransactionId = GetNextTransactionId();
    }
    else
    {
        if (m_CommandBuffer.OpCode == PTP_OPCODE_GETDEVICEINFO ||
            m_CommandBuffer.OpCode == PTP_OPCODE_OPENSESSION)
        {
            m_CommandBuffer.SessionId = PTP_SESSIONID_NOSESSION;
            m_CommandBuffer.TransactionId = PTP_TRANSACTIONID_NOSESSION;
        }
        else
        {
            wiauDbgError("ExecuteCommand", "session must first be opened");
            return E_FAIL;
        }
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        DumpCommand(&m_CommandBuffer, NumCommandParams);

    //
    // Send the command to the camera
    //
    m_Phase = CAMERA_PHASE_CMD;
    hr = SendCommand(&m_CommandBuffer, NumCommandParams);
    if (FAILED(hr))
    {
        wiauDbgError("ExecuteCommand", "SendCommand failed");
        m_Phase = CAMERA_PHASE_IDLE;

        RecoverFromError();
        
        return hr;
    }
    
    m_Phase = NextPhase;

    //
    // Get data, if necessary
    //
    if (m_Phase == CAMERA_PHASE_DATAIN)
    {
        hr = ReadData(pReadData, pReadDataSize);
        if (FAILED(hr))
        {
            m_Phase = CAMERA_PHASE_IDLE;
            wiauDbgError("ExecuteCommand", "ReadData failed");
            
            RecoverFromError();
            
            return hr;
        }

        if (hr == S_FALSE)
        {
            bCommandCancelled = TRUE;
        }
        else
        {
            //
            // If transfer was cancelled, ReadData has already set appropriate next phase
            // If not, set it to CAMERA_PHASE_RESPONSE now
            //
            m_Phase = CAMERA_PHASE_RESPONSE;
        }
    } 
    else 
    {
        // there is no data phase, tell caller there is no in data
        // (please, note that caller knows and will adjust for
        // obligatory response size) #337129
        if(pReadDataSize) *pReadDataSize = 0;
    }

    //
    // Send data, if necessary
    //
    if (m_Phase == CAMERA_PHASE_DATAOUT)
    {
        hr = SendData(pWriteData, WriteDataSize);
        if (FAILED(hr))
        {
            wiauDbgError("ExecuteCommand", "SendData failed");
            m_Phase = CAMERA_PHASE_IDLE;

            RecoverFromError();
            
            return hr;
        }

        if (hr == S_FALSE)
        {
            bCommandCancelled = TRUE;
        }
        else
        {
            //
            // If transfer was cancelled, SendData has already set appropriate next phase
            // If not, set it to CAMERA_PHASE_RESPONSE now
            //
            m_Phase = CAMERA_PHASE_RESPONSE;
        }
    }

    //
    // Read the response, if necessary
    //
    if (m_Phase == CAMERA_PHASE_RESPONSE)
    {
        memset(&m_ResponseBuffer, NULL, sizeof(m_ResponseBuffer));

        hr = ReadResponse(&m_ResponseBuffer);
        if (FAILED(hr))
        {
            wiauDbgError("ExecuteCommand", "ReadResponse failed");
            m_Phase = CAMERA_PHASE_IDLE;

            RecoverFromError();
            
            return hr;
        }


        if (g_dwDebugFlags & WIAUDBG_DUMP)
            DumpResponse(&m_ResponseBuffer);

        if (m_ResponseBuffer.ResponseCode != PTP_RESPONSECODE_OK && 
            m_ResponseBuffer.ResponseCode != PTP_RESPONSECODE_SESSIONALREADYOPENED)
        {
            wiauDbgError("ExecuteCommand", "bad response code = 0x%04x", m_ResponseBuffer.ResponseCode);
            //
            // Convert the PTP response code to an HRESULT;
            //
            hr = HRESULT_FROM_PTP(m_ResponseBuffer.ResponseCode);
        }

        m_Phase = CAMERA_PHASE_IDLE;
    }

    if (SUCCEEDED(hr) && bCommandCancelled)
    {
        hr = S_FALSE;
    }

    return hr;
}

//
// All of the "command" functions below have the same basic structure:
//   1. Check the arguments (if any) to make sure they are valid
//   2. Set up the opcode and parameters (if any) in the command buffer
//   3. Call ExecuteCommand
//   4. Check the return code
//   5. Parse the returned raw data (if any) into a PTP structure
//   6. If debugging is turned on, dump the data
//   7. Return
//

//
// This function gets the device info structure from the camera
//
// Output:
//   pDeviceInfo -- to receive the structure
//
HRESULT
CPTPCamera::GetDeviceInfo(
    CPtpDeviceInfo *pDeviceInfo
    )
{
    DBG_FN("CPTPCamera::GetDeviceInfo");

    HRESULT hr = S_OK;
    
    if (!pDeviceInfo)
    {
        wiauDbgError("GetDeviceInfo", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETDEVICEINFO;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 0, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetDeviceInfo", "ExecuteCommand failed");
        return hr;
    }

    hr = pDeviceInfo->Init(m_pTransferBuffer);
    if (FAILED(hr))
    {
        wiauDbgError("GetDeviceInfo", "couldn't parse DeviceInfo data");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pDeviceInfo->Dump();

    //
    // Set the model and version hack variables
    //
    SetupHackInfo(pDeviceInfo);

    return hr;
}

//
// This function opens a session on the camera for the caller. It is a little different
// than the other command functions. If it initially fails, it tries to recover and
// execute the OpenSession command again. It also starts the event thread.
//
// Input:
//   SessionId -- the session ID to open
//
HRESULT
CPTPCamera::OpenSession(
    DWORD SessionId
    )
{
    DBG_FN("CPTPCamera::OpenSession");

    HRESULT hr = S_OK;
    
    if (!SessionId)
    {
        wiauDbgError("OpenSession", "invalid arg");
        return E_INVALIDARG;
    }

    if (IsCameraSessionOpen())
    {
        wiauDbgError("OpenSession", "tried to open a session when one is already open");
        return E_FAIL;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_OPENSESSION;
    m_CommandBuffer.Params[0] = SessionId;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("OpenSession", "ExecuteCommand failed... attempting to recover and re-execute");
        
        hr = RecoverFromError();
        if (FAILED(hr))
        {
            wiauDbgError("OpenSession", "RecoverFromError failed");
            return hr;
        }

        //
        // Trying executing the command again
        //
        hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
        if (FAILED(hr))
        {
            wiauDbgError("OpenSession", "ExecuteCommand failed the second time");
            return hr;
        }
    }

    //
    // Set the session id
    //
    m_SessionId = SessionId;

    wiauDbgTrace("OpenSession", "session %d opened", m_SessionId);

    //
    // Resume the event thread that was created suspended
    //
    if (!m_hEventThread)
    {
        wiauDbgError("OpenSession", "event thread is null");
        return E_FAIL;
    }

    if (ResumeThread(m_hEventThread) > 1)
    {
        wiauDbgError("OpenSession", "ResumeThread failed");
        return E_FAIL;
    }

    return hr;
}

//
// This function closes the session
//
HRESULT
CPTPCamera::CloseSession()
{
    DBG_FN("CPTPCamera::CloseSession");

    HRESULT hr = S_OK;
    
    m_CommandBuffer.OpCode = PTP_OPCODE_CLOSESESSION;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 0, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("CloseSession", "ExecuteCommand failed");
        return hr;
    }

    wiauDbgTrace("CloseSession", "session closed");

    //
    // The session is closed, so reset the session and transaction ids
    //
    m_SessionId = PTP_SESSIONID_NOSESSION;
    m_NextTransactionId = PTP_TRANSACTIONID_MIN;
    m_Phase = CAMERA_PHASE_NOTREADY;

    return hr;
}

//
// This function retrieves the list of all available storages on the device
//
// Output:
//   pStorageIdArray -- An empty array to receive the storage IDs
//
HRESULT
CPTPCamera::GetStorageIDs(
    CArray32 *pStorageIdArray
    )
{
    DBG_FN("CPTPCamera::GetStorageIDs");

    HRESULT hr = S_OK;

    if (!pStorageIdArray)
    {
        wiauDbgError("GetStorageIDs", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETSTORAGEIDS;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 0, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetStorageIDs", "ExecuteCommand failed");
        return hr;
    }

    BYTE *pTemp = m_pTransferBuffer;
    if (!pStorageIdArray->Parse(&pTemp))
    {
        wiauDbgError("GetStorageIDs", "couldn't parse storage id array");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pStorageIdArray->Dump("  Storage ids       =", "                     ");

    return hr;
}

//
// This function gets the information about the given storage
//
// Input:
//   StorageId -- the storage ID to get info about
// Output:
//   pStorageInfo -- the structure to receive the information
//
HRESULT
CPTPCamera::GetStorageInfo(
    DWORD StorageId,
    CPtpStorageInfo *pStorageInfo
    )
{
    DBG_FN("CPTPCamera::GetStorageInfo");

    HRESULT hr = S_OK;

    if (!StorageId ||
        !pStorageInfo)
    {
        wiauDbgError("GetStorageInfo", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETSTORAGEINFO;
    m_CommandBuffer.Params[0] = StorageId;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetStorageInfo", "ExecuteCommand failed");
        return hr;
    }

    hr = pStorageInfo->Init(m_pTransferBuffer, StorageId);
    if (FAILED(hr))
    {
        wiauDbgError("GetStorageInfo", "couldn't parse storage info");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pStorageInfo->Dump();

    return hr;
}

//
// This function gets the number of objects on a storage, optionally in a specific
// format or under a specific association object
//
// Input:
//   StorageId -- the designated storage, e.g. PTP_STORAGEID_ALL
//   FormatCode -- optional format type, e.g. PTP_FORMATCODE_ALL, PTP_FORMATCODE_IMAGE
//   ParentObjectHandle -- the object handle under which to count objects
// Output:
//   pNumObjects -- to receive the number of the object.
//
HRESULT
CPTPCamera::GetNumObjects(
    DWORD StorageId,
    WORD FormatCode,
    DWORD ParentObjectHandle,
    UINT *pNumObjects
    )
{
    DBG_FN("CPTPCamera::GetNumObjects");

    HRESULT hr = S_OK;
    
    if (!StorageId ||
        !pNumObjects)
    {
        wiauDbgError("GetNumObjects", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETNUMOBJECTS;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 3, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("GetNumObjects", "ExecuteCommand failed");
        return hr;
    }

    *pNumObjects = m_ResponseBuffer.Params[0];

    wiauDbgTrace("GetNumObjects", "number of objects = %d", *pNumObjects);

    return hr;
}

//
// This function gets the object handles under the given parent object
//
// Input:
//   StorageId -- the designated storage, e.g. PTP_STORAGEID_ALL
//   FormatCode -- specifies what format type, e.g. PTP_FORMATCODE_ALL, PTP_FORMATCODE_IMAGE
//   ParentObjectHandle -- the object handle under which to enumerate the objects
// Output:
//   pObjectHandleArray -- the array to receive the object handles
//
HRESULT
CPTPCamera::GetObjectHandles(
    DWORD StorageId,
    WORD FormatCode,
    DWORD ParentObjectHandle,
    CArray32 *pObjectHandleArray
    )
{
    DBG_FN("CPTPCamera::GetObjectHandles");

    HRESULT hr = S_OK;

    if (!StorageId ||
        !pObjectHandleArray)
    {
        wiauDbgError("GetObjectHandles", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETOBJECTHANDLES;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 3, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectHandles", "ExecuteCommand failed");
        return hr;
    }

    BYTE *pTemp = m_pTransferBuffer;
    if (!pObjectHandleArray->Parse(&pTemp))
    {
        wiauDbgError("GetStorageIDs", "couldn't parse object handle array");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pObjectHandleArray->Dump("  Object handles    =", "                     ");

    return hr;
}

//
// This function gets the object info structure
//
// Input:
//   ObjectHandle -- the object handle
// Output:
//   pObjectInfo -- pointer to retreived object info
//
HRESULT
CPTPCamera::GetObjectInfo(
    DWORD ObjectHandle,
    CPtpObjectInfo *pObjectInfo
    )
{
    DBG_FN("CPTPCamera::GetObjectInfo");

    HRESULT hr = S_OK;

    if (!ObjectHandle ||
        !pObjectInfo)
    {
        wiauDbgError("GetObjectInfo", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETOBJECTINFO;
    m_CommandBuffer.Params[0] = ObjectHandle;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectInfo", "ExecuteCommand failed");
        return hr;
    }
    
    hr = pObjectInfo->Init(m_pTransferBuffer, ObjectHandle);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectInfo", "couldn't parse object info");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pObjectInfo->Dump();

    return hr;
}

//
// This function retrieves an object
//
// Input:
//   ObjectHandle -- the handle that represents the object
//   pBuffer -- the buffer to use for transfer
//   BufferLen -- the buffer size
//
HRESULT
CPTPCamera::GetObjectData(
    DWORD ObjectHandle,
    BYTE *pBuffer,
    UINT *pBufferLen,
    LPVOID pCallbackParam
    )
{
    DBG_FN("CPTPCamera::GetObjectData");
    
    HRESULT hr = S_OK;

    if (!pBuffer ||
        !pBufferLen ||
        *pBufferLen == 0)
    {
        wiauDbgError("GetObjectData", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;

    m_pDataCallbackParam = pCallbackParam;

    hr = ExecuteCommand(pBuffer, pBufferLen, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectData", "ExecuteCommand failed");
        //
        // go ahead to have m_pDataCallbackParam cleared
        //
    }

    m_pDataCallbackParam = NULL;
    
    return hr;
}

//
// This function gets the thumbnail for an object
//
// Input:
//   ObjectHandle -- the handle that represents the object
//   pBuffer -- the buffer to use for transfer
//   BufferLen -- the buffer size
//
HRESULT
CPTPCamera::GetThumb(
    DWORD ObjectHandle,
    BYTE *pBuffer,
    UINT *pBufferLen
    )
{
    DBG_FN("CPTPCamera::GetThumb");
    
    HRESULT hr = S_OK;

    if (!pBuffer ||
        !pBufferLen ||
        *pBufferLen == 0)
    {
        wiauDbgError("GetThumb", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETTHUMB;
    m_CommandBuffer.Params[0] = ObjectHandle;

    hr = ExecuteCommand(pBuffer, pBufferLen, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetThumb", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function deletes the given object and its children
//
// Input:
//   ObjectHandle -- object handle that represents the object to be deleted, e.g. PTP_OBJECTHANDLE_ALL
//   FormatCode -- Limits the scope of the deletion if objects of FormatCode type, e.g. PTP_FORMATCODE_NOTUSED, PTP_FORMATCODE_ALLIMAGES
//
HRESULT
CPTPCamera::DeleteObject(
    DWORD ObjectHandle,
    WORD FormatCode
    )
{
    DBG_FN("CPTPCamera::DeleteObject");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_DELETEOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = FormatCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("DeleteObject", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function sends an ObjectInfo structure to the device in preparation for sending an object
//
// Input:
//   StorageId -- storage id for the new object, e.g. PTP_STORAGEID_UNDEFINED
//   ParentObjectHandle -- parent to use for the new object, e.g. PTP_OBJECTHANDLE_UNDEFINED, PTP_OBJECTHANDLE_ROOT
//   pDeviceInfo -- pointer to DeviceInfo structure
// Output:
//   pResultStorageId -- location to store storage id where object will be stored
//   pResultParentObjectHandle -- parent object under which object will be stored
//   pResultObjectHandle -- location to store handle for the new object
//
HRESULT
CPTPCamera::SendObjectInfo(
    DWORD StorageId,
    DWORD ParentObjectHandle,
    CPtpObjectInfo *pObjectInfo,
    DWORD *pResultStorageId,
    DWORD *pResultParentObjectHandle,
    DWORD *pResultObjectHandle
    )
{
    DBG_FN("CPTPCamera::SendObjectInfo");
    
    HRESULT hr = S_OK;

    if (!pObjectInfo ||
        !pResultStorageId ||
        !pResultParentObjectHandle ||
        !pResultObjectHandle)
    {
        wiauDbgError("SendObjectInfo", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_SENDOBJECTINFO;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = ParentObjectHandle;

    BYTE *pRaw = m_pTransferBuffer;
    pObjectInfo->WriteToBuffer(&pRaw);
    UINT size = (UINT) (pRaw - m_pTransferBuffer);

    hr = ExecuteCommand(NULL, NULL, m_pTransferBuffer, size, 2, CAMERA_PHASE_DATAOUT);
    if (FAILED(hr))
    {
        wiauDbgError("SendObjectInfo", "ExecuteCommand failed");
        return hr;
    }

    *pResultStorageId = m_ResponseBuffer.Params[0];
    *pResultParentObjectHandle = m_ResponseBuffer.Params[1];
    *pResultObjectHandle = m_ResponseBuffer.Params[2];

    wiauDbgTrace("SendObjectInfo", "ObjectInfo added, storage = 0x%08x, parent = 0x%08x, handle = 0x%08x",
                   *pResultStorageId, *pResultParentObjectHandle, *pResultObjectHandle);
    
    return hr;
}

//
// This function sends data for a new object
//
// Input:
//   pBuffer -- pointer to raw data
//   BufferLen -- length of the buffer
//
HRESULT
CPTPCamera::SendObjectData(
    BYTE *pBuffer,
    UINT BufferLen
    )
{
    DBG_FN("CPTPCamera::SendObjectData");
    
    HRESULT hr = S_OK;

    if (!pBuffer)
    {
        wiauDbgError("SendObjectData", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_SENDOBJECT;

    hr = ExecuteCommand(NULL, NULL, pBuffer, BufferLen, 0, CAMERA_PHASE_DATAOUT);
    if (FAILED(hr))
    {
        wiauDbgError("SendObjectData", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function asks the device to initiate a capture. The newly added object
// will be reported via an ObjectAdded event, or StoreFull event if the store is full.
//
// Input:
//   StorageId -- where to save the capture object, e.g. PTP_STORAGEID_DEFAULT
//   FormatCode -- indicates what kind of object to capture, e.g. PTP_FORMATCODE_DEFAULT
//
HRESULT
CPTPCamera::InitiateCapture(
    DWORD StorageId,
    WORD FormatCode
    )
{
    DBG_FN("CPTPCamera::InitiateCapture");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_INITIATECAPTURE;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("InitiateCapture", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function formats a store on the device
//
// Input:
//   StorageId -- storage to format
//   FilesystemFormat -- optional format to use
//
HRESULT
CPTPCamera::FormatStore(
    DWORD StorageId,
    WORD FilesystemFormat
    )
{
    DBG_FN("CPTPCamera::FormatStore");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_FORMATSTORE;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FilesystemFormat;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("FormatStore", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function resets the camera. A DeviceReset event will be sent and all open
// sessions will be closed.
//
HRESULT
CPTPCamera::ResetDevice()
{
    DBG_FN("CPTPCamera::ResetDevice");
    
    HRESULT hr = S_OK;

    hr = SendResetDevice();
    if (FAILED(hr))
    {
        wiauDbgError("ResetDevice", "SendResetDevice failed");
        return hr;
    }

    wiauDbgTrace("ResetDevice", "device reset successfully");

    return hr;
}

//
// This function tests the camera
//
HRESULT
CPTPCamera::SelfTest(WORD SelfTestType)
{
    DBG_FN("CPTPCamera::SelfTest");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_SELFTEST;
    m_CommandBuffer.Params[0] = SelfTestType;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 0, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("SelfTest", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function sets the protection status of an object
//
// Input:
//   ObjectHandle -- handle of the object
//   ProtectionStatus -- protection status
//
HRESULT
CPTPCamera::SetObjectProtection(
    DWORD ObjectHandle,
    WORD ProtectionStatus
    )
{
    DBG_FN("CPTPCamera::SetObjectProtection");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_SETOBJECTPROTECTION;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = ProtectionStatus;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("SetObjectProtection", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function will cause the device to turn off
//
HRESULT
CPTPCamera::PowerDown()
{
    DBG_FN("CPTPCamera::PowerDown");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_POWERDOWN;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 0, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("PowerDown", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function retrieves a property description structure from the camera, allocating
// the appropriate CPtpPropDesc structure.
//
// Input:
//   PropCode -- property code to retrieve
//   pPropDesc -- pointer property description object
//
HRESULT
CPTPCamera::GetDevicePropDesc(
    WORD PropCode,
    CPtpPropDesc *pPropDesc
    )
{
    DBG_FN("CPtpCamera::GetDevicePropDesc");

    HRESULT hr = S_OK;
    
    if (!PropCode ||
        !pPropDesc)
    {
        wiauDbgError("GetDevicePropDesc", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETDEVICEPROPDESC;
    m_CommandBuffer.Params[0] = PropCode;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropDesc", "ExecuteCommand failed");
        return hr;
    }

    hr = pPropDesc->Init(m_pTransferBuffer);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropDesc", "couldn't parse property description");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pPropDesc->Dump();

    return hr;
}

//
// This function retrieves the current setting for a property.
//
// Input:
//   PropCode -- property code to get value for
//   pPropDesc -- pointer to property description object
//
HRESULT
CPTPCamera::GetDevicePropValue(
    WORD PropCode,
    CPtpPropDesc *pPropDesc
    )
{
    DBG_FN("CPtpCamera::GetDevicePropValue");

    HRESULT hr = S_OK;
    
    if (!PropCode ||
        !pPropDesc)
    {
        wiauDbgError("GetDevicePropValue", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETDEVICEPROPVALUE;
    m_CommandBuffer.Params[0] = PropCode;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropValue", "ExecuteCommand failed");
        return hr;
    }

    hr = pPropDesc->ParseValue(m_pTransferBuffer);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropValue", "couldn't parse property value");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pPropDesc->DumpValue();

    return hr;
}

//
// This function sends a new setting for a property to the device
//
// Input:
//   PropCode -- property code to set
//   pPropDesc -- pointer to property description object
//
HRESULT
CPTPCamera::SetDevicePropValue(
    WORD PropCode,
    CPtpPropDesc *pPropDesc
    )
{
    DBG_FN("CPtpCamera::SetDevicePropValue");

    HRESULT hr = S_OK;
    
    if (!PropCode ||
        !pPropDesc)
    {
        wiauDbgError("SetDevicePropValue", "invalid arg");
        return E_INVALIDARG;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pPropDesc->DumpValue();

    m_CommandBuffer.OpCode = PTP_OPCODE_SETDEVICEPROPVALUE;
    m_CommandBuffer.Params[0] = PropCode;

    BYTE *pRaw = m_pTransferBuffer;
    pPropDesc->WriteValue(&pRaw);
    UINT size = (UINT) (pRaw - m_pTransferBuffer);

    hr = ExecuteCommand(NULL, NULL, m_pTransferBuffer, size, 1, CAMERA_PHASE_DATAOUT);
    if (FAILED(hr))
    {
        wiauDbgError("SetDevicePropValue", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function resets the of a property
//
// Input:
//   PropCode -- property code to set
//
HRESULT
CPTPCamera::ResetDevicePropValue(
    WORD PropCode
    )
{
    DBG_FN("CPtpCamera::ResetDevicePropValue");

    HRESULT hr = S_OK;
    
    if (!PropCode)
    {
        wiauDbgError("ResetDevicePropValue", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_RESETDEVICEPROPVALUE;
    m_CommandBuffer.Params[0] = PropCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("ResetDevicePropValue", "ExecuteCommand failed");
        return hr;
    }

    //
    // WIAFIX-10/2/2000-davepar This function should reset the current value being held by the minidriver
    //

    return hr;
}

//
// This function terminates an open capture
//
// Input:
//   TransactionId -- transaction id of InitiateOpenCapture command
//
HRESULT
CPTPCamera::TerminateCapture(
    DWORD TransactionId
    )
{
    DBG_FN("CPtpCamera::TerminateCapture");

    HRESULT hr = S_OK;
    
    if (!TransactionId)
    {
        wiauDbgError("TerminateCapture", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_TERMINATECAPTURE;
    m_CommandBuffer.Params[0] = TransactionId;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("TerminateCapture", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function moves an object on the device
//
// Input:
//   ObjectHandle -- handle of object to move
//   StorageId -- storage id of new location for object
//   ParentObjectHandle -- handle of new parent for object
//
HRESULT
CPTPCamera::MoveObject(
    DWORD ObjectHandle,
    DWORD StorageId,
    DWORD ParentObjectHandle
    )
{
    DBG_FN("CPtpCamera::MoveObject");

    HRESULT hr = S_OK;
    
    if (!ObjectHandle)
    {
        wiauDbgError("MoveObject", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_MOVEOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = StorageId;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 3, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("MoveObject", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function copies an object to a new location on the device
//
// Input:
//   ObjectHandle -- handle of object to copy
//   StorageId -- storage id for new object
//   ParentObjectHandle -- handle of parent for new object
//   pResultObjectHandle -- pointer to location to receive new object's handle
//
HRESULT
CPTPCamera::CopyObject(
    DWORD ObjectHandle,
    DWORD StorageId,
    DWORD ParentObjectHandle,
    DWORD *pResultObjectHandle
    )
{
    DBG_FN("CPtpCamera::CopyObject");

    HRESULT hr = S_OK;
    
    if (!ObjectHandle ||
        !pResultObjectHandle)
    {
        wiauDbgError("CopyObject", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_COPYOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = StorageId;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 3, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("CopyObject", "ExecuteCommand failed");
        return hr;
    }

    *pResultObjectHandle = m_ResponseBuffer.Params[0];

    wiauDbgTrace("CopyObject", "Object 0x%08x copied to 0x%08x", ObjectHandle, *pResultObjectHandle);

    return hr;
}

//
// This function retrieves a portion of an object
//
// Input:
//   ObjectHandle -- the handle that represents the object
//   pBuffer -- the buffer to use for transfer
//   BufferLen -- the buffer size
//
HRESULT
CPTPCamera::GetPartialObject(
    DWORD ObjectHandle,
    UINT Offset,
    UINT *pLength,
    BYTE *pBuffer,
    UINT *pResultLength,
    LPVOID pCallbackParam
    )
{
    DBG_FN("CPTPCamera::GetPartialObject");
    
    HRESULT hr = S_OK;

    if (!pBuffer ||
        !pLength ||
        *pLength == 0 ||
        !pResultLength)
    {
        wiauDbgError("GetPartialObject", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETPARTIALOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = Offset;
    m_CommandBuffer.Params[2] = *pLength;

    m_pDataCallbackParam = pCallbackParam;

    hr = ExecuteCommand(pBuffer, pLength, NULL, 0, 3, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetPartialObject", "ExecuteCommand failed");
        m_pDataCallbackParam = NULL;
        return hr;
    }

    m_pDataCallbackParam = NULL;

    *pResultLength = m_ResponseBuffer.Params[0];
    
    return hr;
}

//
// This function initiates an open capture
//
// Input:
//   StorageId -- storage to use for new object(s)
//   FormatCode -- format for new object(s)
//
HRESULT
CPTPCamera::InitiateOpenCapture(
    DWORD StorageId,
    WORD FormatCode
    )
{
    DBG_FN("CPtpCamera::InitiateOpenCapture");

    HRESULT hr = S_OK;
    
    m_CommandBuffer.OpCode = PTP_OPCODE_INITIATEOPENCAPTURE;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("InitiateOpenCapture", "ExecuteCommand failed");
        
        hr = RecoverFromError();
        if(FAILED(hr))
        {
            wiauDbgError("InitiateOpenCapture", "RecoverFromError failed");
            return hr;
        }

        hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
        if (FAILED(hr))
        {
            wiauDbgError("InitiateOpenCapture", "ExecuteCommand failed 2nd time");
            return hr;
        }
    }

    return hr;
}

//
// This function executes a vendor command
//
HRESULT
CPTPCamera::VendorCommand(
    PTP_COMMAND *pCommand,
    PTP_RESPONSE *pResponse,
    UINT *pReadDataSize,
    BYTE *pReadData,
    UINT WriteDataSize,
    BYTE *pWriteData,
    UINT NumCommandParams,
    int NextPhase
    )
{
    DBG_FN("CPTPCamera::VendorCommand");

    HRESULT hr = S_OK;

    memcpy(&m_CommandBuffer, pCommand, sizeof(m_CommandBuffer));

    hr = ExecuteCommand(pReadData, pReadDataSize, pWriteData, WriteDataSize,
                        NumCommandParams, (CAMERA_PHASE) NextPhase);
    
    if (FAILED(hr))
    {
        wiauDbgError("VendorCommand", "ExecuteCommand failed");
        return hr;
    }

    memcpy(pResponse, &m_ResponseBuffer, sizeof(m_ResponseBuffer));

    return hr;
}

//
// This function increments the transaction ID, rolling over if necessary
//
// Output:
//   next transaction ID
//
DWORD
CPTPCamera::GetNextTransactionId()
{
    // Valid transaction IDs range from PTP_TRANSACTIONID_MIN to
    // PTP_TRANSACTIONID_MAX, inclusive.
    //
    if (PTP_TRANSACTIONID_MAX == m_NextTransactionId)
    {
        m_NextTransactionId = PTP_TRANSACTIONID_MIN;
        return PTP_TRANSACTIONID_MAX;
    }
    else
    {
        return m_NextTransactionId++;
    }
}

//
// Set m_HackModel and m_HackVersion according to device info
//
HRESULT CPTPCamera::SetupHackInfo(CPtpDeviceInfo *pDeviceInfo)
{
    DBG_FN("CWiaMiniDriver::SetupHackInfo");

    if (pDeviceInfo == NULL)
    {
        wiauDbgError("SetupHackInfo", "Invalid device info");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    m_HackModel = HACK_MODEL_NONE;
    m_HackVersion = 0.0;

    //
    // Kodak DC4800
    //
    if (wcscmp(pDeviceInfo->m_cbstrModel.String(), L"DC4800 Zoom Digital Camera") == 0)
    {
        m_HackModel = HACK_MODEL_DC4800;
        wiauDbgTrace("SetupHackInfo", "Detected Kodak DC4800 camera");
    }

    //
    // Any Sony camera
    //
    else if (wcsstr(pDeviceInfo->m_cbstrModel.String(), L"Sony") != NULL)
    {
        //
        // Sony cameras report version as "01.0004"
        //
        WCHAR *pszStopChar = NULL;
        double dbVersion = wcstod(pDeviceInfo->m_cbstrDeviceVersion.String(), &pszStopChar);
        if (dbVersion != 0.0)
        {
            m_HackModel = HACK_MODEL_SONY;
            m_HackVersion = dbVersion;
            wiauDbgTrace("SetupHackInfo", "Detected Sony camera, version = %f", m_HackVersion);
        }
    }

    //
    // Nikon E2500 
    //
    else if (wcsstr(pDeviceInfo->m_cbstrManufacturer.String(), L"Nikon") != NULL &&
             wcscmp(pDeviceInfo->m_cbstrModel.String(), L"E2500") == 0)
    {
        //
        // Nikon E2500 reports version as "E2500v1.0"
        //
        WCHAR *pch = wcsrchr(pDeviceInfo->m_cbstrDeviceVersion.String(), L'v');
        if (pch != NULL)
        {
            WCHAR *pszStopChar = NULL;
            double dbVersion = wcstod(pch + 1, &pszStopChar);
            if (dbVersion != 0)
            {
                m_HackModel = HACK_MODEL_NIKON_E2500;
                m_HackVersion = dbVersion;
                wiauDbgTrace("SetupHackInfo", "Detected Nikon E2500 camera, version = %f", m_HackVersion);
            }
        }
    }
    else
    {
        wiauDbgTrace("SetupHackInfo", "Not detected any hack model");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\camera.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camera.h

Abstract:

    This module declares CPTPCamera class

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#ifndef CAMERA__H_
#define CAMERA__H_


//
// Reserve 8KB of memory as a re-usable transaction buffer
//
const UINT TRANSFER_BUFFER_SIZE = 0x2000;

//
// Hack models
//
typedef enum tagHackModel
{
    HACK_MODEL_NONE = 0,
    HACK_MODEL_DC4800,
    HACK_MODEL_NIKON_E2500,
    //
    // Right now, Sony cameras do not provide model in DeviceInfo. m_HackVersion is used to 
    // differentiate newer and older firmware of Sony cameras
    //
    HACK_MODEL_SONY
} HACK_MODEL;

//
// Camera is always in one of these phases. Constants are fixed and documented in DDK, see ptpusd.h
//
typedef enum tagCameraPhase
{
    CAMERA_PHASE_NOTREADY,
    CAMERA_PHASE_IDLE,
    CAMERA_PHASE_CMD,
    CAMERA_PHASE_DATAIN,
    CAMERA_PHASE_DATAOUT,
    CAMERA_PHASE_RESPONSE
}CAMERA_PHASE, *PCAMERA_PHASE;

//
// Definition for function to call when event occurs
//
typedef HRESULT (*PTPEventCallback)(LPVOID pCallbackParam, PPTP_EVENT pEvent);

//
// Definition for function to call while data is transferred
//
typedef HRESULT (*PTPDataCallback)(LPVOID pCallbackParam, LONG lPercentComplete,
                                   LONG lOffset, LONG lLength, BYTE **ppBuffer, LONG *plBufferSize);

//
// CPTPCamera - generic PTP camera
//
class CPTPCamera
{
public:
    CPTPCamera();
    virtual ~CPTPCamera();

    virtual HRESULT Open(LPWSTR DevicePortName, PTPEventCallback pPTPEventCB,
                         PTPDataCallback pPTPDataCB, LPVOID pEventParam, BOOL bEnableEvents = TRUE);
    virtual HRESULT Close();
    HRESULT GetDeviceInfo(CPtpDeviceInfo *pDeviceInfo);
    HRESULT OpenSession(DWORD SessionId);
    HRESULT CloseSession();
    HRESULT GetStorageIDs(CArray32 *pStorageIds);
    HRESULT GetStorageInfo(DWORD StorageId, CPtpStorageInfo *pStorageInfo);
    HRESULT GetNumObjects(DWORD StorageId, WORD FormatCode,
                          DWORD ParentObjectHandle, UINT *pNumObjects);
    HRESULT GetObjectHandles(DWORD StorageId, WORD FormatCode,
                             DWORD ParentObjectHandle, CArray32 *pObjectHandles);
    HRESULT GetObjectInfo(DWORD ObjectHandle, CPtpObjectInfo *pObjectInfo);
    HRESULT GetObjectData(DWORD ObjectHandle, BYTE *pBuffer, UINT *pBufferLen, LPVOID pCallbackParam);
    HRESULT GetThumb(DWORD ObjectHandle, BYTE *pBuffer, UINT *pBufferLen);
    HRESULT DeleteObject(DWORD ObjectHandle, WORD FormatCode);
    HRESULT SendObjectInfo(DWORD StorageId, DWORD ParentObjectHandle, CPtpObjectInfo *pObjectInfo,
                           DWORD *pResultStorageId, DWORD *pResultParentObjectHandle, DWORD *pResultObjectHandle);
    HRESULT SendObjectData(BYTE *pBuffer, UINT BufferLen);
    HRESULT InitiateCapture(DWORD StorageId, WORD FormatCode);
    HRESULT FormatStore(DWORD StorageId, WORD FilesystemFormat);
    HRESULT ResetDevice();
    HRESULT SelfTest(WORD SelfTestType);
    HRESULT SetObjectProtection(DWORD ObjectHandle, WORD ProtectionStatus);
    HRESULT PowerDown();
    HRESULT GetDevicePropDesc(WORD PropCode, CPtpPropDesc *pPropDesc);
    HRESULT GetDevicePropValue(WORD PropCode, CPtpPropDesc *pPropDesc);
    HRESULT SetDevicePropValue(WORD PropCode, CPtpPropDesc *pPropDesc);
    HRESULT ResetDevicePropValue(WORD PropCode);
    HRESULT TerminateCapture(DWORD TransactionId);
    HRESULT MoveObject(DWORD ObjectHandle, DWORD StorageId, DWORD ParentObjectHandle);
    HRESULT CopyObject(DWORD ObjectHandle, DWORD StorageId, DWORD ParentObjectHandle, DWORD *pResultObjectHandle);
    HRESULT GetPartialObject(DWORD ObjectHandle, UINT Offset, UINT *pLength, BYTE *pBuffer,
                             UINT *pResultLength, LPVOID pCallbackParam);
    HRESULT InitiateOpenCapture(DWORD StorageId, WORD FormatCode);

    HRESULT VendorCommand(PTP_COMMAND *pCommand, PTP_RESPONSE *pResponse,
                          UINT *pReadDataSize, BYTE *pReadData,
                          UINT WriteDataSize, BYTE *pWriteData,
                          UINT NumCommandParams, int NextPhase);

    //
    // Camera state functions
    //
    BOOL  IsCameraOpen()         { return m_Phase != CAMERA_PHASE_NOTREADY; }
    BOOL  IsCameraSessionOpen()  { return m_SessionId != PTP_SESSIONID_NOSESSION; }
    PBOOL CameraWasReset()       { return &m_bCameraWasReset; }

    //
    // Model identification for model-specific handling
    //
    HRESULT             SetupHackInfo(CPtpDeviceInfo *pDeviceInfo);
    HACK_MODEL          GetHackModel() { return m_HackModel; }
    double              GetHackVersion() { return m_HackVersion; }

    //
    // Member access functions (for the event thread)
    //
    PPTP_EVENT          GetEventBuffer()        { return &m_EventBuffer; }
    PTPEventCallback    GetPTPEventCallback()   { return m_pPTPEventCB; }
    LPVOID              GetEventCallbackParam() { return m_pEventCallbackParam; }

    //
    // This function must be overriden by a transport-specific subclass
    //
    virtual HRESULT ReadEvent(PTP_EVENT *pEvent) = 0;
    virtual HRESULT RecoverFromError() = 0;

protected:
    //
    // These functions must be overriden by a transport-specific subclass
    //
    virtual HRESULT SendCommand(PTP_COMMAND *pCommand, UINT NumParams) = 0;
    virtual HRESULT ReadData(BYTE *pData, UINT *pBufferSize) = 0;
    virtual HRESULT SendData(BYTE *pData, UINT BufferSize) = 0;
    virtual HRESULT ReadResponse(PTP_RESPONSE *pResponse) = 0;
    virtual HRESULT AbortTransfer() = 0;
    virtual HRESULT SendResetDevice() = 0;

    //
    // Member variables
    //
    HANDLE                  m_hEventThread;         // Event thread handle
    DWORD                   m_SessionId;            // Current session ID
    CAMERA_PHASE            m_Phase;                // Current camera phase
    DWORD                   m_NextTransactionId;    // Next transaction ID
    PTPEventCallback        m_pPTPEventCB;          // Event callback function pointer
    PTPDataCallback         m_pPTPDataCB;           // Data callback function pointer
    LPVOID                  m_pEventCallbackParam;  // Pointer to pass to event callback functions
    LPVOID                  m_pDataCallbackParam;   // Pointer to pass to data callback functions
    BOOL                    m_bEventsEnabled;       // GetDeviceInfo is used to query camera for its name.  We don't want to start up entire eventing just for this.
    BOOL                    m_bCameraWasReset;      // Device was successfully reset, WIA server was not notified about that yet
    HACK_MODEL              m_HackModel;            // Indicator for model-specific hacks
    double                  m_HackVersion;          // Indicator for model and version specific hacks

private:
    HRESULT ExecuteCommand(BYTE *pReadData, UINT *pReadDataSize, BYTE *pWriteData, UINT WriteDataSize,
                           UINT NumCommandParams, CAMERA_PHASE NextPhase);
    DWORD   GetNextTransactionId();
    
    BYTE                   *m_pTransferBuffer;     // Re-usable buffer for small transfers
    PTP_COMMAND             m_CommandBuffer;       // Re-usable buffer for commands
    PTP_RESPONSE            m_ResponseBuffer;      // Re-usable buffer for responses
    PTP_EVENT               m_EventBuffer;         // Re-usable buffer for events

};

#endif // CAMERA__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\camusb.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camusb.cpp

Abstract:

    This module implements CUsbCamera object

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "ptppch.h"

#include <atlbase.h>
#include <atlconv.h>
#include <devioctl.h>

//
// Private IOCTL to workaround #446466 (Whistler)
//
#define IOCTL_SEND_USB_REQUEST_PTP  CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+20,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Constructor for CUsbCamera
//
CUsbCamera::CUsbCamera() :
    m_hUSB(NULL),
    m_hEventUSB(NULL),
    m_hEventCancel(NULL),
    m_hEventRead(NULL),
    m_pUsbData(NULL),
    m_UsbDataSize(0),
    m_prevOpCode(0),
    m_prevTranId(0)
{
    DBG_FN("CUsbCamera::CUsbCamera");

    memset(&m_EndpointInfo, NULL, sizeof(m_EndpointInfo));
}

CUsbCamera::~CUsbCamera()
{
}

//
// This function takes care of USB-specific processing for opening
// a connection with a device.
//
// Input:
//   DevicePortName -- name used to access device via CreateFile
//   pIPTPEventCB   -- IWiaPTPEventCallback interface pointer
//
HRESULT
CUsbCamera::Open(
    LPWSTR DevicePortName,
    PTPEventCallback pPTPEventCB,
    PTPDataCallback pPTPDataCB,
    LPVOID pEventParam,
    BOOL bEnableEvents
    )
{
    USES_CONVERSION;

    DBG_FN("CUsbCamera::Open");

    HRESULT hr = S_OK;

    //
    // Call the base class Open function first
    //
    hr = CPTPCamera::Open(DevicePortName, pPTPEventCB, pPTPDataCB, pEventParam, bEnableEvents);
    if (FAILED(hr))
    {
        wiauDbgError("Open", "base class Open failed");
        return hr;
    }
    
    //
    // Open another handle to talk with the device, to work around possible
    // bug in Usbscan.sys
    //
    m_hEventUSB = ::CreateFile(W2T(DevicePortName),        // file name
                               GENERIC_READ | GENERIC_WRITE,   // desired access
                               0,                              // sharing mode
                               NULL,                           // security descriptor
                               OPEN_EXISTING,                  // creation disposition
                               FILE_FLAG_OVERLAPPED,           // file attributes
                               NULL                            // template file
                              );

    if (m_hEventUSB == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateFile failed");
        m_hUSB = NULL;
        return hr;
    }

    //
    // Open a handle to talk with the device
    //
    m_hUSB = ::CreateFile(W2T(DevicePortName),        // file name
                        GENERIC_READ | GENERIC_WRITE,   // desired access
                        0,                              // sharing mode
                        NULL,                           // security descriptor
                        OPEN_EXISTING,                  // creation disposition
                        0,                              // file attributes
                        NULL                            // template file
                       );

    if (m_hUSB == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "Second CreateFile failed");
        m_hUSB = NULL;
        return hr;
    }

    //
    // Create event handle that will cancel interrupt pipe read
    //
    m_hEventCancel = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventCancel)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateEvent failed");
        return hr;
    }

    //
    // Create event handle for reading interrupt pipe
    //
    m_hEventRead = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventRead)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateEvent failed");
        return hr;
    }

    //
    // Set up array used by WaitForMultipleObjects
    //
    m_EventHandles[0] = m_hEventCancel;
    m_EventHandles[1] = m_hEventRead;

    //
    // Get the pipe configuration information of each pipe
    //
    USBSCAN_PIPE_CONFIGURATION PipeCfg;
    DWORD BytesReturned;
    
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_GET_PIPE_CONFIGURATION,
                         NULL,
                         0,
                         &PipeCfg,
                         sizeof(PipeCfg),
                         &BytesReturned,
                         NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "get pipe config DeviceIoControl failed");
        return hr;
    }

    //
    // Loop through the pipe configurations and store the information we'll need
    // later (maximum packet size and address). Also make sure there is at least
    // one endpoint of each: bulk-in, bulk-out, and interrupt.
    //
    USBSCAN_PIPE_INFORMATION *pPipeInfo;  // Temporary pointer

    for (ULONG count = 0; count < PipeCfg.NumberOfPipes; count++)
    {
        pPipeInfo = &PipeCfg.PipeInfo[count];
        switch (pPipeInfo->PipeType)
        {
        case USBSCAN_PIPE_BULK:

            if (pPipeInfo->EndpointAddress & BULKIN_FLAG)
            {
                m_EndpointInfo.BulkInMaxSize = pPipeInfo->MaximumPacketSize;
                m_EndpointInfo.BulkInAddress = pPipeInfo->EndpointAddress;
                wiauDbgTrace("Open", "found a bulk-in endpoint, address = 0x%04x, packet size = %d, index = %d",
                             pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);
            }
            else
            {
                m_EndpointInfo.BulkOutMaxSize = pPipeInfo->MaximumPacketSize;
                m_EndpointInfo.BulkOutAddress = pPipeInfo->EndpointAddress;
                wiauDbgTrace("Open", "found a bulk-out endpoint, address = 0x%04x, packet size = %d, index = %d",
                             pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);
            }

            break;

        case USBSCAN_PIPE_INTERRUPT:

            m_EndpointInfo.InterruptMaxSize = pPipeInfo->MaximumPacketSize;
            m_EndpointInfo.InterruptAddress = pPipeInfo->EndpointAddress;
            wiauDbgTrace("Open", "found an interrupt endpoint, address = 0x%02x, packet size = %d, index = %d",
                         pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);

            break;
            
        default:
            wiauDbgTrace("Open", "found an endpoint of unknown type, type = 0x%04x, address = 0x%02x, packet size = %d, index = %d",
                           pPipeInfo->PipeType, pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);
        }
    }

    //
    // Each of these endpoints must be present and have non-zero packet size
    //
    if (!m_EndpointInfo.BulkInMaxSize ||
        !m_EndpointInfo.BulkOutMaxSize ||
        !m_EndpointInfo.InterruptMaxSize)
    {
        wiauDbgError("Open", "At least one endpoint is invalid");
        return E_FAIL;
    }

    //
    // Allocate a re-usable buffer for handling the USB header during reads
    // and writes. It needs to be large enough to hold one packet and large
    // enough to hold a USB header.
    //
    m_UsbDataSize = max(m_EndpointInfo.BulkInMaxSize, m_EndpointInfo.BulkOutMaxSize);
    while (m_UsbDataSize < sizeof(m_pUsbData->Header))
    {
        m_UsbDataSize += m_UsbDataSize;
    }
    m_pUsbData = (PUSB_PTP_DATA) new BYTE[m_UsbDataSize];
    if (!m_pUsbData)
    {
        wiauDbgError("Open", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    return hr;
}

//
// This function closes the connection to the camera
//
HRESULT
CUsbCamera::Close()
{
    DBG_FN("CUsbCamera::Close");

    HRESULT hr = S_OK;

    //
    // Call the base class Close function first
    //
    hr = CPTPCamera::Close();
    if (FAILED(hr))
    {
        wiauDbgError("Close", "base class Close failed");
    }

    //
    // Signal event to cancel interrupt pipe I/O
    //
    if (!SetEvent(m_hEventCancel))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Close", "SetEvent failed");
    } else {

        if (m_bEventsEnabled)
        {
            //
            // We need to wait until event thread finishes, otherwise driver DLL may get unloaded
            // with a running thread in it
            //
            DWORD ret = WaitForSingleObject(m_hEventThread, INFINITE);

            if (ret != WAIT_OBJECT_0) {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                wiauDbgErrorHr(hr, "Close", "WaitForSingleObject failed");
            }
        }
    }

    //
    // Close handle to the event thread
    //
    if (m_hEventThread)
    {
        CloseHandle(m_hEventThread);
        m_hEventThread = NULL;
    }

    //
    // Close the file handles and event handles
    //
    if (m_hUSB)
    {
        CloseHandle(m_hUSB);
        m_hUSB = NULL;
    }

    if (m_hEventUSB)
    {
        CloseHandle(m_hEventUSB);
        m_hEventUSB = NULL;
    }

    if (m_hEventCancel)
    {
        CloseHandle(m_hEventCancel);
        m_hEventCancel = NULL;
    }

    if (m_hEventRead)
    {
        CloseHandle(m_hEventRead);
        m_hEventRead = NULL;
    }

    //
    // Free memory used for reading/writing data
    //
    if (m_pUsbData)
    {
        delete[] (BYTE*)m_pUsbData;
        m_pUsbData = NULL;
    }

    return hr;
}

//
// This function writes a command buffer to the device
//
// Input:
//   pCommand -- pointer to the command to send
//   NumParams -- number of parameters in the command
//
HRESULT
CUsbCamera::SendCommand(
    PTP_COMMAND *pCommand,
    UINT NumParams
    )
{
    DBG_FN("CUsbCamera::SendCommand");

    HRESULT hr = S_OK;
    
    if (!pCommand || NumParams > COMMAND_NUMPARAMS_MAX)
    {
        wiauDbgError("SendCommand", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Check for the reset command, and send it via the control pipe instead
    //
    if (pCommand->OpCode == PTP_OPCODE_RESETDEVICE)
    {
        wiauDbgTrace("SendCommand", "sending reset request");

        hr = ResetDevice();
        if (FAILED(hr))
        {
            wiauDbgError("SendCommand", "ResetDevice failed");
            return hr;
        }
    }

    else
    {
        //
        // Put the PTP command into a USB container
        //
        m_UsbCommand.Header.Len = sizeof(m_UsbCommand.Header) + sizeof(DWORD) * NumParams;
        m_UsbCommand.Header.Type = PTPCONTAINER_TYPE_COMMAND;
        m_UsbCommand.Header.Code = pCommand->OpCode;
        m_UsbCommand.Header.TransactionId = pCommand->TransactionId;

        if (NumParams > 0)
        {
            memcpy(m_UsbCommand.Params, pCommand->Params, sizeof(DWORD) * NumParams);
        }

        //
        // Send the command to the device
        //
        DWORD BytesWritten = 0;
        wiauDbgTrace("SendCommand", "writing command");

        if (!WriteFile(m_hUSB, &m_UsbCommand, m_UsbCommand.Header.Len, &BytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "SendCommand", "WriteFile failed");
            return hr;
        }

        if (BytesWritten != m_UsbCommand.Header.Len)
        {
            wiauDbgError("SendCommand", "wrong amount of data written = %d", BytesWritten);
            return E_FAIL;
        }

        //
        // If the amount written is a multiple of the packet size, send a null packet
        //
        if (m_UsbCommand.Header.Len % m_EndpointInfo.BulkOutMaxSize == 0)
        {
            wiauDbgTrace("SendCommand", "sending null packet");

            if (!WriteFile(m_hUSB, NULL, 0, &BytesWritten, NULL))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                wiauDbgErrorHr(hr, "SendCommand", "second WriteFile failed");
                return hr;
            }

            if (BytesWritten != 0)
            {
                wiauDbgError("SendCommand", "wrong amount of data written = %d -", BytesWritten);
                return E_FAIL;
            }
        }
    }

    //
    // Save the opcode, because we need it for the data container header
    //
    m_prevOpCode = pCommand->OpCode;
    m_prevTranId = pCommand->TransactionId;

    wiauDbgTrace("SendCommand", "command successfully sent");

    return hr;
}

//
// This function reads bulk data from the device
//
// Input:
//   pData -- pointer to a buffer to receive read data
//   BufferSize -- size of buffer
//
HRESULT
CUsbCamera::ReadData(
    BYTE *pData,
    UINT *pBufferSize
    )
{
    DBG_FN("CUsbCamera::ReadData");

    HRESULT hr = S_OK;

    BOOL bAbortTransfer = FALSE;
    
    if (!pData ||
        !pBufferSize ||
        *pBufferSize == 0)
    {
        wiauDbgError("ReadData", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // First read the header from the device
    //
    memset(m_pUsbData, NULL, m_UsbDataSize);

    DWORD BytesRead = 0;
    wiauDbgTrace("ReadData", "reading data header");

    if (!ReadFile(m_hUSB, m_pUsbData, sizeof(m_pUsbData->Header), &BytesRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "ReadData", "ReadFile failed");
        return hr;
    }

    if (BytesRead != sizeof(m_pUsbData->Header))
    {
        wiauDbgError("ReadData", "wrong amount of data read = %d", BytesRead);
        return E_FAIL;
    }

    //
    // Check the type code in the header to make sure it's correct
    //
    if (m_pUsbData->Header.Type != PTPCONTAINER_TYPE_DATA)
    {
        wiauDbgError("ReadData", "expected a data header but received type = %d", m_pUsbData->Header.Type);
        return E_FAIL;
    }

    //
    // Check the opcode and transaction id in the header just to make sure they are correct
    //
    if ((m_pUsbData->Header.Code != m_prevOpCode) ||
        (m_pUsbData->Header.TransactionId != m_prevTranId))
    {
        wiauDbgError("ReadData", "fields in the data header were incorrect, opcode=0x%04x tranid=0x%08x",
                       m_pUsbData->Header.Code, m_pUsbData->Header.TransactionId);
        return E_FAIL;
    }

    //
    // Loop, reading the data. The callback function will be called at least 10 times during
    // the transfer. More if the buffer size is small.
    //
    LONG lOffset = 0;
    UINT BytesToRead = 0;
    UINT TotalRead = 0;
    UINT TotalToRead = m_pUsbData->Header.Len - sizeof(m_pUsbData->Header);
    UINT TotalRemaining = TotalToRead;

    //
    // Make sure the buffer is large enough, unless a callback function is being used
    //
    if (m_pDataCallbackParam == NULL &&
        *pBufferSize < TotalToRead)
    {
        wiauDbgError("ReadData", "buffer is too small");
        return E_FAIL;
    }

    //
    // When doing callbacks, read the data in chunk sizes slightly
    // larger the 1/10 the total and divisible by 4.
    //
    if (m_pDataCallbackParam)
        BytesToRead = (TotalToRead / 40 + 1) * 4;
    else
        BytesToRead = *pBufferSize;

    //
    // Set time out values for Usbscan
    //
    USBSCAN_TIMEOUT TimeOut;
    DWORD BytesReturned = 0;

    TimeOut.TimeoutRead = PTP_READ_TIMEOUT + max(BytesToRead / 100000, 114);
    TimeOut.TimeoutWrite = PTP_WRITE_TIMEOUT;
    TimeOut.TimeoutEvent = PTP_EVENT_TIMEOUT;
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_SET_TIMEOUT,
                         &TimeOut,
                         sizeof(TimeOut),
                         NULL,
                         0,
                         &BytesReturned,
                         NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "set timeout DeviceIoControl failed");
        return hr;
    }

    while (TotalRemaining > 0)
    {
        //
        // Make sure the amount to read is never larger than the buffer size. The buffer size may
        // be updated by the callback function.
        //
        if (BytesToRead > *pBufferSize)
            BytesToRead = *pBufferSize;

        //
        // On the last read, the bytes to read may need to be reduced
        //
        if (BytesToRead > TotalRemaining)
            BytesToRead = TotalRemaining;

        wiauDbgTrace("ReadData", "reading a chunk of data = %d", BytesToRead);

        BytesRead = 0;
        if (!ReadFile(m_hUSB, pData, BytesToRead, &BytesRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadData", "ReadFile failed");
            return hr;
        }

        if ((BytesRead > *pBufferSize) ||
            (BytesRead != BytesToRead))
        {
            wiauDbgError("ReadData", "wrong amount of data read = %d -", BytesRead);
            return E_FAIL;
        }

        TotalRemaining -= BytesRead;
        TotalRead += BytesRead;

        if (m_pDataCallbackParam &&
            !bAbortTransfer)
        {
            //
            // Call the callback function reporting percent complete, offset, and amount read.
            // The callback may update pData and BufferSize.
            //
            hr = m_pPTPDataCB(m_pDataCallbackParam, (TotalRead * 100 / TotalToRead),
                              lOffset, BytesRead, &pData, (LONG *) pBufferSize);

            if (FAILED(hr))
            {
                //
                // Report the error
                //
                wiauDbgErrorHr(hr, "ReadData", "data callback failed");
            }

            //
            // Check if caller wants to cancel the transfer or returns error
            //
            if (hr == S_FALSE || FAILED(hr))
            {
                //
                // Do not send CancelRequest to cameras that do not support it, just read the 
                // remainder of the object without reporting progress and return S_FALSE.
                //
                // Cameras not supporting CancelRequest are:
                //   all Sony cameras with DeviceVersion < 1.0004
                //   Nikon E2500 with DeviceVersion = 1.0
                //
                const double NIKON_E2500_VERSION_NOT_SUPPORTING_CANCEL = 1.0;
                const double MIN_SONY_VERSION_SUPPORTING_CANCEL = 1.0004;

                if ((GetHackModel() == HACK_MODEL_NIKON_E2500 && 
                     GetHackVersion() == NIKON_E2500_VERSION_NOT_SUPPORTING_CANCEL) || 

                    (GetHackModel() == HACK_MODEL_SONY && 
                     GetHackVersion() < MIN_SONY_VERSION_SUPPORTING_CANCEL))
                {
                    wiauDbgWarning("ReadData", 
                        "Transfer cancelled, reading but ignoring remainder of the object (%d bytes)", TotalRemaining);

                    bAbortTransfer = TRUE;
                    m_Phase = CAMERA_PHASE_RESPONSE; // camera will send response
                    hr = S_OK;
                }
                else
                {
                    wiauDbgWarning("ReadData", "Transfer cancelled, aborting current transfer");
                    
                    hr = SendCancelRequest(m_prevTranId);
                    if (FAILED(hr))
                    {
                        wiauDbgErrorHr(hr, "ReadData", "SendCancelRequest failed");
                        return hr;
                    }

                    m_Phase = CAMERA_PHASE_IDLE; // camera will not send response
                    return S_FALSE;
                }
            }
        }

        //
        // Increment the offset
        //
        lOffset += BytesRead;
    }

    if ((TotalRead + sizeof(m_pUsbData->Header)) % m_EndpointInfo.BulkInMaxSize == 0)
    {
        //
        // Read the extra null packet
        //
        wiauDbgTrace("ReadData", "reading a null packet");

        BytesRead = 0;
        if (!ReadFile(m_hUSB, m_pUsbData, m_UsbDataSize, &BytesRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadData", "ReadFile failed");
            return hr;
        }
        
        if (BytesRead != 0)
        {
            wiauDbgError("ReadData", "tried to read null packet but read %d bytes instead", BytesRead);
            return E_FAIL;
        }
    }

    *pBufferSize = TotalRead;

    wiauDbgTrace("ReadData", "%d bytes of data successfully read", TotalRead);

    if (bAbortTransfer)
        hr = S_FALSE;

    return hr;
}

//
// This function writes bulk data to the device
//
// Input:
//   pData -- pointer to a buffer of data to write
//   BufferSize -- amount of data to write
//
HRESULT
CUsbCamera::SendData(
    BYTE *pData,
    UINT BufferSize
    )
{
    DBG_FN("CUsbCamera::SendData");

    HRESULT hr = S_OK;

    if (!pData ||
        BufferSize == 0)
    {
        wiauDbgError("SendData", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Figure out how many packets it will take to contain the header
    //
    UINT BytesToWrite = m_EndpointInfo.BulkOutMaxSize;
    while (BytesToWrite < sizeof(m_pUsbData->Header))
    {
        BytesToWrite += m_EndpointInfo.BulkOutMaxSize;
    }

    //
    // The first write will contain the USB header plus as much of the data as it
    // takes to fill out the packet. We need to write full packets, otherwise the device
    // will think the transfer is done.
    //
    UINT FirstWriteDataAmount = min(BufferSize, BytesToWrite - sizeof(m_pUsbData->Header));
    BytesToWrite = sizeof(m_pUsbData->Header) + FirstWriteDataAmount;

    //
    // Fill out header fields
    //
    m_pUsbData->Header.Len = BufferSize + sizeof(m_pUsbData->Header);
    m_pUsbData->Header.Type = PTPCONTAINER_TYPE_DATA;
    m_pUsbData->Header.Code = m_prevOpCode;
    m_pUsbData->Header.TransactionId = m_prevTranId;

    //
    // Copy the part of the data needed to fill out the packets
    //
    memcpy(m_pUsbData->Data, pData, FirstWriteDataAmount);

    //
    // Write the header plus partial data
    //
    wiauDbgTrace("SendData", "Writing first packet, length = %d", BytesToWrite);
    DWORD BytesWritten = 0;
    if (!WriteFile(m_hUSB, m_pUsbData, BytesToWrite, &BytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "SendData", "WriteFile failed");
        return hr;
    }

    if (BytesWritten != BytesToWrite)
    {
        wiauDbgError("SendData", "wrong amount of data written = %d", BytesWritten);
        return E_FAIL;
    }

    UINT TotalBytesWritten = BytesWritten;

    //
    // The next write (if necessary) will include the remainder of the data
    //
    if (BufferSize > FirstWriteDataAmount)
    {
        BytesToWrite = BufferSize - FirstWriteDataAmount;
        BytesWritten = 0;
        wiauDbgTrace("SendData", "writing remainder of data, length = %d", BytesToWrite);

        if (!WriteFile(m_hUSB, &pData[FirstWriteDataAmount], BytesToWrite, &BytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "SendData", "second WriteFile failed");
            return hr;
        }

        if (BytesWritten != BytesToWrite)
        {
            wiauDbgError("SendData", "wrong amount of data written = %d -", BytesWritten);
            return E_FAIL;
        }

        TotalBytesWritten += BytesWritten;
    }

    //
    // If the amount written is exactly a multiple of the packet size, send an empty packet
    // so the device knows we are done sending data
    //
    if (TotalBytesWritten % m_EndpointInfo.BulkOutMaxSize == 0)
    {
        BytesWritten = 0;
        wiauDbgTrace("SendData", "writing null packet");

        if (!WriteFile(m_hUSB, NULL, 0, &BytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "SendData", "third WriteFile failed");
            return hr;
        }

        if (BytesWritten != 0)
        {
            wiauDbgError("SendData", "wrong amount of data written = %d --", BytesWritten);
            return E_FAIL;
        }
    }

    wiauDbgTrace("SendData", "%d bytes of data successfully written", TotalBytesWritten);

    return hr;
}

//
// This function reads the response data from the device
//
// Input:
//   pResponse -- pointer to a response structure to receive the response data
//
HRESULT
CUsbCamera::ReadResponse(
    PTP_RESPONSE *pResponse
    )
{
    DBG_FN("CUsbCamera::ReadResponse");

    HRESULT hr = S_OK;

    if (!pResponse)
    {
        wiauDbgError("ReadResponse", "invalid arg");
        return E_INVALIDARG;
    }
    
    //
    // Handle response from reset command
    //
    if (m_prevOpCode == PTP_OPCODE_RESETDEVICE)
    {
        wiauDbgTrace("ReadResponse", "creating reset response");

        pResponse->ResponseCode = PTP_RESPONSECODE_OK;
        pResponse->SessionId = m_SessionId;
        pResponse->TransactionId = m_prevTranId;
    }

    else
    {
        //
        // Clear the USB response buffer
        //
        memset(&m_UsbResponse, NULL, sizeof(m_UsbResponse));

        //
        // Read the response from the device
        //
        DWORD BytesRead = 0;
        wiauDbgTrace("ReadResponse", "reading response");

        if (!ReadFile(m_hUSB, &m_UsbResponse, sizeof(m_UsbResponse), &BytesRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadResponse", "ReadFile failed");
            return hr;
        }

        if ((BytesRead < sizeof(m_UsbResponse.Header)) ||
            (BytesRead > sizeof(m_UsbResponse)))
        {
            wiauDbgError("ReadResponse", "wrong amount of data read = %d", BytesRead);
            return E_FAIL;
        }

        //
        // Check the type code in the response to make sure it's correct
        //
        if (m_UsbResponse.Header.Type != PTPCONTAINER_TYPE_RESPONSE)
        {
            wiauDbgError("ReadResponse", "expected a response but received type = %d", m_UsbResponse.Header.Type);
            return E_FAIL;
        }

        //
        // Unwrap the PTP response from the USB container
        //
        pResponse->ResponseCode = m_UsbResponse.Header.Code;
        pResponse->SessionId = m_SessionId;  // USB doesn't care about session id, so just use the one we have stored
        pResponse->TransactionId = m_UsbResponse.Header.TransactionId;

        DWORD ParamLen = BytesRead - sizeof(m_UsbResponse.Header);
        if (ParamLen > 0)
        {
            memcpy(pResponse->Params, m_UsbResponse.Params, ParamLen);
        }
    }

    wiauDbgTrace("ReadResponse", "response successfully read");

    return hr;
}

//
// This function reads event data from the device
//
// Input:
//   pEvent -- pointer to a PTP event structure to receive the event data
//
HRESULT
CUsbCamera::ReadEvent(
    PTP_EVENT *pEvent
    )
{
    DBG_FN("CUsbCamera::ReadEvent");

    HRESULT hr = S_OK;
    
    if (!pEvent)
    {
        wiauDbgError("ReadEvent", "invalid arg");
        return E_INVALIDARG;
    }
    
    //
    // Allocate buffer for reading event from camera. It should be big enough to accomodate
    // packet of maximum allowed size, otherwise we'll get INVALID_ARG
    //
    DWORD cbEventBufSize = max(sizeof(USB_PTP_EVENT), m_EndpointInfo.InterruptMaxSize);
    USB_PTP_EVENT *pEventBuf = (USB_PTP_EVENT*) new BYTE[cbEventBufSize];
    if (pEventBuf == NULL)
    {
        wiauDbgError("ReadEvent", "Memory allocation failed");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }    
    memset(pEventBuf, 0, cbEventBufSize);

    //
    // Read the event from the device. DeviceIoControl is called in overlapped mode. If
    // no information is ready on the interrupt pipe, GetOverlappedResult will wait for
    // data to arrive. Unfortunately, DeviceIoControl returns after each packet, so keep
    // reading until a short packet is received.
    //
    DWORD BytesRead = 0;
    DWORD TotalBytesRead = 0;
    BOOL bReceivedShortPacket = FALSE;
    BYTE *pData = (BYTE*) pEventBuf;

    wiauDbgTrace("ReadEvent", "reading event");

    while (!bReceivedShortPacket)
    {
        if (!ResetEvent(m_hEventRead))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadEvent", "ResetEvent failed");
            return hr;
        }

        memset(&m_Overlapped, 0, sizeof(OVERLAPPED));
        m_Overlapped.hEvent = m_hEventRead;
        
        if (!DeviceIoControl(m_hEventUSB,
                             IOCTL_WAIT_ON_DEVICE_EVENT,
                             NULL,
                             0,
                             pData,
                             cbEventBufSize - TotalBytesRead,
                             &BytesRead,
                             &m_Overlapped))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING))
            {
                hr = S_OK;
                DWORD ret;
                wiauDbgTrace("ReadEvent", "waiting for interrupt pipe data");

                ret = WaitForMultipleObjects(2, m_EventHandles, FALSE, INFINITE);
                if (ret == WAIT_FAILED)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    wiauDbgErrorHr(hr, "ReadEvent", "WaitForMultipleObjects failed");
                    goto Cleanup;
                }
                else if (ret == WAIT_OBJECT_0)
                {
                    //
                    // Indicate to caller that I/O was cancelled
                    //
                    wiauDbgTrace("ReadEvent", "Cancelling I/O on the interrupt pipe");
                    hr = S_FALSE;

                    HRESULT temphr = S_OK;

                    //
                    // Cancel the pending I/O on the interrupt pipe
                    //
                    if (!CancelIo(m_hEventUSB))
                    {
                        temphr = HRESULT_FROM_WIN32(::GetLastError());
                        wiauDbgErrorHr(hr, "ReadEvent", "CancelIo failed");
                    }
                    
                    //
                    // Exit point when I/O is cancelled!!!
                    //
                    goto Cleanup;

                }
                else
                {
                    //
                    // Get result of read
                    //
                    if (!GetOverlappedResult(m_hEventUSB, &m_Overlapped, &BytesRead, TRUE))
                    {
                        hr = HRESULT_FROM_WIN32(::GetLastError());
                        wiauDbgErrorHr(hr, "ReadEvent", "GetOverlappedResult failed");
                        goto Cleanup;
                    }
                }
            }
            else
            {
                wiauDbgErrorHr(hr, "ReadEvent", "DeviceIoControl failed");
                goto Cleanup;
            }
        }

        if (BytesRead == 0) {
            bReceivedShortPacket = TRUE;
        }
        else {
            TotalBytesRead += BytesRead;
            pData += BytesRead;
            bReceivedShortPacket = (BytesRead % m_EndpointInfo.InterruptMaxSize != 0);
        }
    }

    //
    // Verify that camera sent correct amount of data
    //
    if ((TotalBytesRead < sizeof(USB_PTP_HEADER)) ||
        (TotalBytesRead > sizeof(USB_PTP_EVENT)))
    {
        wiauDbgError("ReadEvent", "wrong amount of data read by DeviceIoControl = %d", TotalBytesRead);
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Check the type code in the response to make sure it's correct
    //
    if (pEventBuf->Header.Type != PTPCONTAINER_TYPE_EVENT)
    {
        wiauDbgError("ReadEvent", "expected an event but received type = %d", pEventBuf->Header.Type);
        hr = E_FAIL;
        goto Cleanup;
    }
    
    //
    // Unwrap the PTP event from the USB container
    //
    pEvent->EventCode = pEventBuf->Header.Code;
    pEvent->SessionId = m_SessionId;  // USB doesn't care about session id, so just use the one we have stored
    pEvent->TransactionId = pEventBuf->Header.TransactionId;

    DWORD ParamLen = TotalBytesRead - sizeof(pEventBuf->Header);
    if (ParamLen > 0)
    {
        memcpy(pEvent->Params, pEventBuf->Params, ParamLen);
    }

    wiauDbgTrace("ReadEvent", "event successfully read, byte count = %d", TotalBytesRead);

Cleanup:
    if (pEventBuf)
    {
        delete[] (BYTE*)pEventBuf;
        pEventBuf = NULL;
    }
    
    return hr;
}

//
// This function cancels the remainder of a data transfer.
//
HRESULT
CUsbCamera::AbortTransfer()
{
    DBG_FN("CUsbCamera::AbortTransfer");

    HRESULT hr = S_OK;

    //
    // WIAFIX-8/28/2000-davepar Fill in the details:
    // 1. If usbscan.sys already transferred the data, clear it's buffer
    // 2. If not, send cancel control code to camera
    //

    return hr;
}

//
// This function attempts to recover from an error. When this function returns, the
// device will be in one of three states:
// 1. Ready for more commands, indicated by S_OK
// 2. Reset, indicated by S_FALSE
// 3. Unreachable, indicated by FAILED(hr)
//
HRESULT
CUsbCamera::RecoverFromError()
{
    DBG_FN("CUsbCamera::RecoverFromError");

    HRESULT hr = S_OK;

    //
    // WIAFIX-7/29/2000-davepar Maybe first should cancel all pending I/O with IOCTL_CANCEL_IO??
    //

    //
    // Attempt to get status on the device
    //
    USB_PTPDEVICESTATUS DeviceStatus;
    hr = GetDeviceStatus(&DeviceStatus);

    //
    // If that worked, clear any stalls returned
    //
    if (SUCCEEDED(hr))
    {
        hr = ClearStalls(&DeviceStatus);

        //
        // If clearing all the stalls worked, exit
        //
        if (SUCCEEDED(hr))
        {
            wiauDbgTrace("RecoverFromError", "device is ready for more commands");
            return S_OK;
        }
    }

    //
    // Either the GetDeviceStatus or ClearStall failed, reset the device
    //
    hr = ResetDevice();

    //
    // If that worked, return S_FALSE
    //
    if (SUCCEEDED(hr))
    {
        wiauDbgWarning("RecoverFromError", "the device was reset");
        return S_FALSE;
    }
    
    //
    // If that fails, the device is unreachable
    //
    wiauDbgError("RecoverFromError", "ResetDevice failed");

    return hr;
}

//
// This function gets the device status, used mainly after an error occurs. It
// may return an endpoint number that the device has intentionally stalled to
// cancel a transaction. The caller should be prepared to clear the stall.
//
// Input:
//       pDeviceStatus -- the receive the status.
//
HRESULT
CUsbCamera::GetDeviceStatus(
                           USB_PTPDEVICESTATUS *pDeviceStatus
                           )
{
    DBG_FN("CUsbCamera::GetDeviceStatus");

    HRESULT hr = S_OK;
    
    //
    // Set up the request
    //
    IO_BLOCK_EX IoBlock;

    IoBlock.bRequest = USB_PTPREQUEST_GETSTATUS;
    IoBlock.bmRequestType = USB_PTPREQUEST_TYPE_IN;
    IoBlock.fTransferDirectionIn = TRUE;
    IoBlock.uOffset = 0;
    IoBlock.uLength = sizeof(*pDeviceStatus);
    IoBlock.pbyData = (UCHAR *) pDeviceStatus;
    IoBlock.uIndex = 0;

    pDeviceStatus->Header.Code = 0;

    //
    // Send the request
    //
    wiauDbgTrace("GetDeviceStatus", "sending GetDeviceStatus request");
    DWORD BytesRead = 0;
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_SEND_USB_REQUEST_PTP,
                         &IoBlock,
                         sizeof(IoBlock),
                         pDeviceStatus,
                         sizeof(*pDeviceStatus),
                         &BytesRead,
                         NULL
                         ))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "GetDeviceStatus", "DeviceIoControl failed");
        return hr;
    }

    if (BytesRead < sizeof(USB_PTPDEVICESTATUS_HEADER) ||
        BytesRead > sizeof(*pDeviceStatus))
    {
        wiauDbgError("GetDeviceStatus", "wrong amount of data returned = %d", BytesRead);
        return E_FAIL;
    }

    if((HIBYTE(pDeviceStatus->Header.Code) & 0xF0) != 0x20 &&
       (HIBYTE(pDeviceStatus->Header.Code) & 0xF0) != 0xA0)
    {
        wiauDbgError("GetDeviceStatus", "PTP status code (0x%x)is invalid ", pDeviceStatus->Header.Code);
        return E_FAIL;
    }


    wiauDbgTrace("GetDeviceStatus", "read %d bytes", BytesRead);

    if (g_dwDebugFlags & WIAUDBG_DUMP)
    {
        wiauDbgTrace("GetDeviceStatus", "Dumping device status:");
        wiauDbgTrace("GetDeviceStatus", "  Length            = 0x%04x", pDeviceStatus->Header.Len);
        wiauDbgTrace("GetDeviceStatus", "  Response code     = 0x%04x", pDeviceStatus->Header.Code);

        ULONG NumParams = (ULONG)min(MAX_NUM_PIPES, (BytesRead - sizeof(pDeviceStatus->Header) / sizeof(pDeviceStatus->Params[0])));
        for (ULONG count = 0; count < NumParams; count++)
        {
            wiauDbgTrace("GetDeviceStatus", "  Param %d           = 0x%08x", count, pDeviceStatus->Params[count]);
        }
    }

    return hr;
}

//
// This function clears all the stalls listed in the given device status
//
// Input:
//       pDeviceStatus -- lists zero or more stalled endpoints
//
HRESULT
CUsbCamera::ClearStalls(
    USB_PTPDEVICESTATUS *pDeviceStatus
    )
{
    DBG_FN("CUsbCamera::ClearStalls");

    HRESULT hr = S_OK;
    
    if (!pDeviceStatus)
    {
        wiauDbgError("ClearStalls", "invalid arg");
        return E_INVALIDARG;
    }


    PIPE_TYPE PipeType;
    ULONG NumStalls = (pDeviceStatus->Header.Len - sizeof(pDeviceStatus->Header)) / sizeof(pDeviceStatus->Params[0]);

    for (ULONG count = 0; count < NumStalls; count++)
    {
        //
        // Translate the endpoint address to the pipe type
        //
        if ((UCHAR)pDeviceStatus->Params[count] == m_EndpointInfo.BulkInAddress)
        {
            PipeType = READ_DATA_PIPE;
        }
        else if ((UCHAR)pDeviceStatus->Params[count] == m_EndpointInfo.BulkOutAddress)
        {
            PipeType = WRITE_DATA_PIPE;
        }
        else if ((BYTE)pDeviceStatus->Params[count] == m_EndpointInfo.InterruptAddress)
        {
            PipeType = EVENT_PIPE;
        }
        else
        {
            //
            // Unrecognized, ignore it
            //
            wiauDbgError("ClearStalls", "unrecognized pipe address 0x%08x", pDeviceStatus->Params[count]);
            continue;
        }
        
        //
        // Reset the endpoint
        //
        DWORD BytesRead;
        if (!DeviceIoControl(m_hUSB,
                             IOCTL_RESET_PIPE,
                             &PipeType,
                             sizeof(PipeType),
                             NULL,
                             0,
                             &BytesRead,
                             NULL
                             ))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ClearStalls", "DeviceIoControl failed");
            return hr;
        }
    }
    
    if(NumStalls) {
        for(count = 0; count < 3; count++) {
            if(FAILED(GetDeviceStatus(pDeviceStatus))) {
                wiauDbgErrorHr(hr, "ClearStalls", "GetDeviceStatus failed");
                return hr;
            }
            if(pDeviceStatus->Header.Code == PTP_RESPONSECODE_OK) {
                break;
            }
        }

        //
        // check if still there are stalled endpoints
        //
        if(pDeviceStatus->Header.Code != PTP_RESPONSECODE_OK)
        {
            hr = E_FAIL;
        }
    }

    //
    // Device should be ready to receive commands again
    //
    m_Phase = CAMERA_PHASE_IDLE;

    return hr;
}

//
// Reset the device
//
HRESULT
CUsbCamera::SendResetDevice()
{
    DBG_FN("CUsbCamera::SendResetDevice");

    HRESULT hr = S_OK;
    
    //
    // Set up the request
    //
    IO_BLOCK_EX IoBlock;
    IoBlock.bRequest = USB_PTPREQUEST_RESET;
    IoBlock.bmRequestType = USB_PTPREQUEST_TYPE_OUT;
    IoBlock.fTransferDirectionIn = FALSE;
    IoBlock.uOffset = 0;
    IoBlock.uLength = 0;
    IoBlock.pbyData = NULL;
    IoBlock.uIndex = 0;

    //
    // Send the request
    //
    DWORD BytesRead;
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_SEND_USB_REQUEST_PTP,
                         &IoBlock,
                         sizeof(IoBlock),
                         NULL,
                         0,
                         &BytesRead,
                         NULL
                        ))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "ResetDevice", "DeviceIoControl failed");
        goto Cleanup;
    }
    //
    // Let the device settle
    //
    Sleep(1000);

    //
    // See if reset helped
    //
    USB_PTPDEVICESTATUS DeviceStatus;
    hr = GetDeviceStatus(&DeviceStatus);
    if (FAILED(hr) || DeviceStatus.Header.Code != PTP_RESPONSECODE_OK)
    {
        hr = E_FAIL;   // device is still unconscious
        goto Cleanup;
    }

    //
    // Side effect of reseting the device is that the phase, session id, and transaction id get reset
    //
    m_Phase = CAMERA_PHASE_IDLE;
  