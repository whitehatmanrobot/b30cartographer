
   ASSERT(refcount == 0);

   // Need to delete these after all.
   // NTRAID#NTBUG9-380753-2001/04/28-sburns

   Win::DeleteObject(smallImage);
   Win::DeleteObject(smallImageOpen);
   Win::DeleteObject(largeImage);
}



ULONG __stdcall
SnapinAbout::AddRef()
{
   LOG_ADDREF(SnapinAbout);   

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
SnapinAbout::Release()
{
   LOG_RELEASE(SnapinAbout);   

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);

   return newref;
}





HRESULT __stdcall
SnapinAbout::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
   LOG_FUNCTION(SnapinAbout::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired =
         static_cast<IUnknown*>(static_cast<ISnapinAbout*>(this));
   }
   else if (interfaceID == IID_ISnapinAbout)
   {
      *interfaceDesired = static_cast<ISnapinAbout*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall
SnapinAbout::GetSnapinDescription(LPOLESTR* description)
{
   LOG_FUNCTION(SnapinAbout::GetSnapinDescription);
   ASSERT(description);

   if (!description)
   {
      return E_POINTER;
   }

   String desc = String::load(IDS_SNAPIN_ABOUT_DESCRIPTION);
   return desc.as_OLESTR(*description);
}



HRESULT __stdcall
SnapinAbout::GetProvider(LPOLESTR* name)
{
   LOG_FUNCTION(SnapinAbout::GetProvider);
   ASSERT(name);

   if (!name)
   {
      return E_POINTER;
   }

   static const String desc(VER_COMPANYNAME_STR);
   return desc.as_OLESTR(*name);
}



HRESULT __stdcall
SnapinAbout::GetSnapinVersion(LPOLESTR* version)
{
   LOG_FUNCTION(SnapinAbout::GetSnapinVersion);
   ASSERT(version);

   if (!version)
   {
      return E_POINTER;
   }

   static const String ver(VER_PRODUCTVERSION_STR);
   return ver.as_OLESTR(*version);
}



HRESULT __stdcall
SnapinAbout::GetSnapinImage(HICON* icon)
{
   LOG_FUNCTION(SnapinAbout::GetSnapinImage);

   if (!icon)
   {
      return E_POINTER;
   }
      
   HRESULT hr = Win::LoadIcon(IDI_SNAPIN_ICON, *icon);
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT __stdcall
SnapinAbout::GetStaticFolderImage(
   HBITMAP*    smallImage_,	
   HBITMAP*    smallImageOpen_,	
   HBITMAP*    largeImage_,	
   COLORREF*   mask)
{
   LOG_FUNCTION(SnapinAbout::GetStaticFolderImage);

   if (smallImage_)
   {
      *smallImage_ = smallImage;
   }
   if (smallImageOpen_)
   {
      *smallImageOpen_ = smallImageOpen;
   }
   if (largeImage_)
   {
      *largeImage_ = largeImage;
   }
   if (mask)
   {
      *mask = BITMAP_MASK_COLOR;
   }

   if (*smallImage_ && *smallImageOpen_ && *largeImage_)
   {
      return S_OK;
   }

   LOG(L"One or more bitmaps were not loaded");

   return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\adsinode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// AdsiNode class
// 
// 9-22-97 sburns



#include "headers.hxx"
#include "adsinode.hpp"



AdsiNode::AdsiNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType,
   const String&                          displayName,
   const ADSI::Path&                      path_)
   :
   ResultNode(owner, nodeType, displayName),
   path(path_)
{
   LOG_CTOR(AdsiNode);
}



AdsiNode::~AdsiNode()
{
   LOG_DTOR(AdsiNode);
}



const ADSI::Path&
AdsiNode::GetPath() const
{
   return path;
}



bool
AdsiNode::IsSameAs(const Node* other) const
{
   LOG_FUNCTION(AdsiNode::IsSameAs);
   ASSERT(other);

   if (other)
   {
      const AdsiNode* adsi_other = dynamic_cast<const AdsiNode*>(other);
      if (adsi_other)
      {
         // same type.  Compare ADSI paths to see if they refer to the same
         // object.  This has the nice property that separate instances of the
         // snapin focused on the same machine will "recognize" each other's
         // prop sheets.

         if (path == adsi_other->path)
         {
            return true;
         }

         // not the same path.
         return false;
      }

      // not the same type.  Defer to the base class.
      return ResultNode::IsSameAs(other);
   }

   return false;
}



HRESULT
AdsiNode::rename(const String& newName)
{
   LOG_FUNCTION(AdsiNode::rename);

   String p = path.GetPath();
   HRESULT hr =
      ADSI::RenameObject(
         ADSI::ComposeMachineContainerPath(
            GetOwner()->GetInternalComputerName()),
         p,
         newName);
   if (SUCCEEDED(hr))
   {
      SetDisplayName(newName);
      ADSI::PathCracker cracker(p);
      path = ADSI::Path(cracker.containerPath() + ADSI::PATH_SEP + newName, path.GetSidPath());
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\adsipage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ASDIPage base class class
// 
// 10-30-97 sburns



#include "headers.hxx"
#include "adsipage.hpp"



ADSIPage::ADSIPage(
   int                  dialogResID,
   const DWORD          helpMap[],
   NotificationState*   state,
   const ADSI::Path&    path_)
   :
   MMCPropertyPage(dialogResID, helpMap, state),
   path(path_)
{
   LOG_CTOR(ADSIPage);
}



const ADSI::Path&
ADSIPage::GetPath() const
{
   LOG_FUNCTION(ADSIPage::GetPath);

   return path;
}



String
ADSIPage::GetObjectName() const
{
   LOG_FUNCTION2(ADSIPage::GetObjectName, path.GetObjectName());

   return path.GetObjectName();
}



String
ADSIPage::GetMachineName() const
{
   LOG_FUNCTION(ADSIPage::GetMachineName);

   return path.GetServerName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\adsi.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ADSI wrapper
// 
// 9-22-97 sburns



#include "headers.hxx"
#include "adsi.hpp"


const String ADSI::PROVIDER(L"WinNT");
const String ADSI::PROVIDER_ROOT(L"WinNT://");
const String ADSI::CLASS_User(USER_CLASS_NAME);
const String ADSI::CLASS_Group(GROUP_CLASS_NAME);
const String ADSI::CLASS_Computer(COMPUTER_CLASS_NAME);
const String ADSI::PATH_SEP(L"/");
const String ADSI::PROPERTY_PasswordExpired(L"PasswordExpired");
const String ADSI::PROPERTY_UserFlags(L"UserFlags");
const String ADSI::PROPERTY_LocalDrive(L"HomeDirDrive");
const String ADSI::PROPERTY_UserParams(L"Parameters");
const String ADSI::PROPERTY_ObjectSID(L"ObjectSID");
const String ADSI::PROPERTY_GroupType(L"groupType");

// InetOrgPerson needs to be supported as if it was a user.
// The WINNT provider always returns inetOrgPerson objects
// as users but the LDAP provider returns them as inetOrgPerson.
// This string is used for the comparison
// NTRAID#NTBUG9-436314-2001/07/16-jeffjon

const String ADSI::CLASS_InetOrgPerson(L"inetOrgPerson");

static const String COMPUTER_SUFFIX(L"," COMPUTER_CLASS_NAME);



static
HRESULT
buildEnumerator(
   SmartInterface<IADsContainer>&   container,
   IEnumVARIANT*&                   enumVariant);

static
HRESULT
buildEnumerator(IADsMembers& members, IEnumVARIANT*& enumVariant);

static
HRESULT
enumerateNext(
   IEnumVARIANT&  enumVariant,
   int            numberElementsToRead,
   _variant_t     destinationBuf[],
   int&           elementsRead);

static
HRESULT
freeEnumerator(IEnumVARIANT& enumerator);



static
HRESULT
buildEnumerator(
   SmartInterface<IADsContainer>&   container,
   IEnumVARIANT*&                   enumVariant)
{
   LOG_FUNCTION(buildEnumerator);

   return ::ADsBuildEnumerator(container, &enumVariant);
}



HRESULT
buildEnumerator(IADsMembers& members, IEnumVARIANT*& enumVariant)
{
   LOG_FUNCTION(buildEnumerator);

   // this fast-and-loose cast is from ADSI sample code...
   return ::ADsBuildEnumerator((IADsContainer*) &members, &enumVariant);
}



HRESULT
freeEnumerator(IEnumVARIANT& enumerator)
{
   LOG_FUNCTION(freeEnumerator);

   return ::ADsFreeEnumerator(&enumerator);
}



HRESULT
enumerateNext(
   IEnumVARIANT&  enumVariant,
   int            numberElementsToRead,
   _variant_t     destinationBuf[],
   int&           elementsRead)
{
   LOG_FUNCTION(enumerateNext);
   ASSERT(numberElementsToRead);

   ULONG n = 0;
   HRESULT hr =
      ::ADsEnumerateNext(
         &enumVariant,
         numberElementsToRead,
         destinationBuf,
         &n);

   // this cast is safe, as we never ask for more elements than can be
   // counted with an int.            
   elementsRead = static_cast<int>(n);
   return hr;
}



HRESULT
walkArray(
   _variant_t           varray[],
   int                  arraySize,
   ADSI::ObjectVisitor& visitor)
{
   LOG_FUNCTION(walkArray);

   HRESULT hr = S_OK;
   for (int i = 0; i < arraySize; i++ )
   {
      IDispatch* dispatch = varray[i].pdispVal;
      ASSERT(dispatch);

      if (dispatch)
      {
         IADs* object = 0;
         hr = dispatch->QueryInterface(QI_PARAMS(IADs, &object));
         BREAK_ON_FAILED_HRESULT(hr);
         ASSERT(object);

         if (object)
         {
            SmartInterface<IADs> so(0);
            so.Acquire(object);
            visitor.Visit(so);
         }
      }

      // we do not release dispatch, as this is done when the array is
      // destroyed: _variant_t::~_variant_t calls VariantClear.   As each
      // element has type VT_DISPATCH, VariantClear releases the interface for
      // us.
   }

   return hr;
}



HRESULT
walkEnumeration(IEnumVARIANT& enumerator, ADSI::ObjectVisitor& visitor)
{
   LOG_FUNCTION(walkEnumeration);

   // read 100 values at a time.
   static const int MAX_ADS_ENUM = 100;

   HRESULT hr = S_OK;
   bool done = false;
   do
   {
      _variant_t varray[MAX_ADS_ENUM];
      int objects_fetched = 0;

      hr =
         enumerateNext(
            enumerator,

            // REVIEWED-2002/03/04-sburns element count matches declaration
            
            MAX_ADS_ENUM,
            varray,
            objects_fetched);
      BREAK_ON_FAILED_HRESULT(hr);
      done = (hr == S_FALSE) ? true : false;

      hr = walkArray(varray, objects_fetched, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (!done);

   return hr;
}



buildVarArrayStr(
   const StringVector&  strings,
   _variant_t&          v)
{
   LOG_FUNCTION(buildVarArrayStr);
   ASSERT(strings.size());

   PWSTR* a = new PWSTR[strings.size()];
   for (size_t i = 0; i < strings.size(); ++i)
   {
      a[i] = const_cast<wchar_t*>(strings[i].c_str());
   }

   HRESULT hr =
      ::ADsBuildVarArrayStr(
         a,

         // REVIEWED-2002/03/04-sburns array size matches declaration
         
         static_cast<DWORD>(strings.size()),
         &v);
   delete[] a;

   return hr;
}



HRESULT
ADSI::VisitChildren(
   const String&        containerPath,
   const String&        objectADSIClass,
   ADSI::ObjectVisitor& visitor)
{
   LOG_FUNCTION2(
      ADSI::VisitChildren,
      String::format(
         L"container: %1 class: %2",
         containerPath.c_str(),
         objectADSIClass.c_str()));
   ASSERT(!containerPath.empty());
   ASSERT(!objectADSIClass.empty());

   HRESULT hr = S_OK;

   // This interface must be released
   IEnumVARIANT* enumerator = 0;

   do
   {
      AutoCoInitialize coinit;
      hr = coinit.Result();
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(containerPath, container);
      // failure => not a valid container
      BREAK_ON_FAILED_HRESULT(hr);

      _variant_t filter;
      PWSTR a = const_cast<wchar_t*>(objectADSIClass.c_str());
      hr = ::ADsBuildVarArrayStr(&a, 1, &filter);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = container->put_Filter(filter);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = buildEnumerator(container, enumerator);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = walkEnumeration(*enumerator, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (enumerator)
   {
      freeEnumerator(*enumerator);
   }

   return hr;
}



HRESULT
ADSI::VisitMembers(
   const SmartInterface<IADsGroup>& group,
   ADSI::ObjectVisitor&             visitor)
{
   LOG_FUNCTION(ADSI::VisitMembers);

   HRESULT hr = S_OK;

   // these must be released when we're done
   IADsMembers* members = 0;      
   IEnumVARIANT* enumerator = 0;

   do
   {
      hr = group->Members(&members);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = buildEnumerator(*members, enumerator);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = walkEnumeration(*enumerator, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (enumerator)
   {
      freeEnumerator(*enumerator);
   }

   if (members)
   {
      members->Release();
   }

   return hr;
}


  
String
ADSI::ExtractObjectName(const String& ADSIPath)
{
   LOG_FUNCTION2(ADSI::ExtractObjectName, ADSIPath);
   ASSERT(!ADSIPath.empty());

   PathCracker cracker(ADSIPath);
   return cracker.leaf();
}



String
ADSI::ComposeMachineContainerPath(const String& computerName)
{
   return
         PROVIDER_ROOT
      +  computerName
      +  COMPUTER_SUFFIX;
}



HRESULT
ADSI::RenameObject(
   const String& containerADSIPath,
   const String& objectADSIPath,
   const String& newName)
{
   LOG_FUNCTION2(
      ADSI::RenameObject,
      String::format(
         L"container: %1 object: %2, new name: %3",
         containerADSIPath.c_str(),
         objectADSIPath.c_str(),
         newName.c_str()));
   ASSERT(!containerADSIPath.empty());
   ASSERT(!objectADSIPath.empty());
   ASSERT(!newName.empty());

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(containerADSIPath, container);
      BREAK_ON_FAILED_HRESULT(hr);

      IDispatch* object = 0;
      hr =
         container->MoveHere(
            AutoBstr(objectADSIPath),
            AutoBstr(newName),
            &object);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(object);
   }
   while (0);

   return hr;
}



HRESULT
ADSI::DeleteObject(
   const String& containerADSIPath,
   const String& objectRelativeName,
   const String& objectClass)
{
   LOG_FUNCTION2(
      ADSI::DeleteObject,
      String::format(
         L"container: %1 object: %2 class: %3",
         containerADSIPath.c_str(),
         objectRelativeName.c_str(),
         objectClass.c_str()));
   ASSERT(!containerADSIPath.empty());
   ASSERT(!objectRelativeName.empty());
   ASSERT(!objectClass.empty());

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(containerADSIPath, container);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         container->Delete(
            AutoBstr(objectClass),
            AutoBstr(objectRelativeName));
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
ADSI::IsComputerAccessible(const String& machine)
{
   LOG_FUNCTION2(ADSI::IsComputerAccessible, machine);
   ASSERT(!machine.empty());

   String path = ADSI::ComposeMachineContainerPath(machine);
   SmartInterface<IADsContainer> container(0);
   return ADSI::GetContainer(path, container);
}



HRESULT
ADSI::VisitGroups(
   const SmartInterface<IADsUser>&  user,
   ADSI::ObjectVisitor&             visitor)
{   
   LOG_FUNCTION(ADSI::VisitGroups);

   HRESULT hr = S_OK;

   // these must be released when we're done
   IADsMembers* members = 0;      
   IEnumVARIANT* enumerator = 0;

   do
   {
      hr = user->Groups(&members);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = buildEnumerator(*members, enumerator);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = walkEnumeration(*enumerator, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (enumerator)
   {
      freeEnumerator(*enumerator);
   }

   if (members)
   {
      members->Release();
   }

   return hr;
}



// e.g. DOMAIN\account

String
ADSI::ExtractDomainObjectName(const String& ADSIPath)
{
   LOG_FUNCTION2(ADSI::ExtractDomainObjectName, ADSIPath);
   ASSERT(!ADSIPath.empty());

   String result(ADSIPath);

   size_t pos = ADSIPath.find_last_of(ADSI::PATH_SEP);
   if (pos != String::npos)
   {
      // the last '/' marks the user name, just prior to that is the machine
      // name (or the domain name), so find the 2nd to last '/'

      pos = ADSIPath.find_last_of(ADSI::PATH_SEP, pos - 1);
      if (pos != String::npos)
      {
         String s = ADSIPath.substr(pos + 1);
         result = s.replace(ADSI::PATH_SEP, L"\\");
      }
   }
   else
   {
      // there's something weird about the path

      ASSERT(false);
   }

   LOG(result);

   return result;
}



HRESULT
ADSI::DuplicateSid(SID* sid, SID*& result)
{
   LOG_FUNCTION(ADSI::DuplicateSid);
   ASSERT(::IsValidSid(sid));
   
   result = 0;
   HRESULT hr = S_OK;

   BYTE* buffer = 0;
   
   do
   {
      DWORD bufSize = ::GetLengthSid(sid);
      buffer = new BYTE[bufSize];

      // REVIEWED-2002/03/01-sburns correct byte count passed.

      ::ZeroMemory(buffer, bufSize);

      result = reinterpret_cast<SID*>(buffer);

      // REVIEWED-2002/03/01-sburns correct buffer size.

      hr = Win::CopySid(bufSize, result, sid);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(::IsValidSid(result));
   }
   while (0);

   if (FAILED(hr))
   {
      delete[] buffer;
      result = 0;
   }

   return hr;
}



void
ADSI::FreeSid(SID* sid)
{
   // don't assert: it's legal to free a null pointer
   // ASSERT(sid);

#ifdef DBG   
   if (sid)
   {
      // But if you're gonna provide one, make it a good one.
      
      ASSERT(::IsValidSid(sid));
   }
#endif    

   delete[] reinterpret_cast<BYTE*>(sid);
}



// allocates memory (with ::operator new) to hold a copy of the SID inside the
// variant.  returns a pointer to that memory as a SID*, which the caller
// should free with ADSI::FreeSid.

HRESULT
VariantToSid(VARIANT* var, SID*& result)
{
   LOG_FUNCTION(VariantToSid);
   ASSERT(var);
   ASSERT(V_VT(var) == (VT_ARRAY | VT_UI1));

   result = 0;

   HRESULT hr = S_OK;
   SAFEARRAY* psa = V_ARRAY(var);
   bool safeArrayAccessed = false;

   do
   {
      ASSERT(psa);
      ASSERT(psa != (SAFEARRAY*)-1);

      if (!psa || psa == (SAFEARRAY*)-1)
      {
         LOG(L"variant not safe array");
         hr = E_INVALIDARG;
         break;
      }

      if (::SafeArrayGetDim(psa) != 1)
      {
         LOG(L"safe array: wrong number of dimensions");
         hr = E_INVALIDARG;
         break;
      }

      if (::SafeArrayGetElemsize(psa) != 1)
      {
         LOG(L"safe array: wrong element type");
         hr = E_INVALIDARG;
         break;
      }

      SID* sid = 0;
      hr = ::SafeArrayAccessData(psa, reinterpret_cast<void**>(&sid));
      BREAK_ON_FAILED_HRESULT(hr);

      safeArrayAccessed = true;

      if (!::IsValidSid(sid))
      {
         LOG(L"sid not valid");
         hr = E_INVALIDARG;
         break;
      }

      hr = ADSI::DuplicateSid(sid, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   
   if (safeArrayAccessed)
   {
      HRESULT unused = ::SafeArrayUnaccessData(psa);

      ASSERT(SUCCEEDED(unused));
   }

   if (FAILED(hr))
   {
      ADSI::FreeSid(result);
      result = 0;
   }

   LOG_HRESULT(hr);
   
   return hr;
}
   


// Converts a VARIANT containing a safe array of bytes to a WinNT SID-style
// path (WinNT://S-x-x...)

HRESULT
ADSI::VariantToSidPath(VARIANT* var, String& result)
{
   LOG_FUNCTION(ADSI::VariantToSidPath);
   ASSERT(var);
   ASSERT(V_VT(var) == (VT_ARRAY | VT_UI1));

   result.erase();

   HRESULT hr = S_OK;
   SID* sid = 0;

   do
   {
      hr = VariantToSid(var, sid);
      BREAK_ON_FAILED_HRESULT(hr);

      String sidString;      
      hr = Win::ConvertSidToStringSid(sid, sidString);
      BREAK_ON_FAILED_HRESULT(hr);

      result = ADSI::PROVIDER_ROOT + sidString;
   }
   while (0);
   
   ADSI::FreeSid(sid);

   LOG_HRESULT(hr);
   LOG(result);
   
   return hr;
}



HRESULT
ADSI::GetSid(const String& adsiPath, SID*& result)
{
   LOG_FUNCTION2(ADSI::GetSid, adsiPath);
   
   ASSERT(!adsiPath.empty());
   ASSERT(IsWinNTPath(adsiPath));

   HRESULT hr = S_OK;
   result = 0;

   do
   {
      SmartInterface<IADs> iads(0);
      IADs* p = 0;
      hr = 
         ::ADsGetObject(
            adsiPath.c_str(),
            QI_PARAMS(IADs, &p));
      BREAK_ON_FAILED_HRESULT(hr);

      iads.Acquire(p);

      hr = ADSI::GetSid(iads, result);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(::IsValidSid(result));      
   }
   while (0);

   return hr;
}



HRESULT
ADSI::GetSid(const SmartInterface<IADs>& iads, SID*& result)
{
   LOG_FUNCTION(ADSI::GetSid);
   ASSERT(iads);

   result = 0;

   HRESULT hr = S_OK;

   do
   {
      // get the account SID

      _variant_t variant;
      hr = iads->Get(AutoBstr(ADSI::PROPERTY_ObjectSID), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = VariantToSid(&variant, result);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(::IsValidSid(result));
   }
   while (0);

   return hr;
}


   
HRESULT
ADSI::GetSidPath(const SmartInterface<IADs>& iads, String& result)
{
   LOG_FUNCTION(ADSI::GetSidPath);
   ASSERT(iads);

   result.erase();

   HRESULT hr = S_OK;

   do
   {
      // get the account SID

      _variant_t variant;
      hr = iads->Get(AutoBstr(ADSI::PROPERTY_ObjectSID), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ADSI::VariantToSidPath(&variant, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}

   

HRESULT
ADSI::GetSidPath(const String& adsiPath, String& result)
{
   LOG_FUNCTION2(ADSI::GetSidPath, adsiPath);
   ASSERT(!adsiPath.empty());
   ASSERT(IsWinNTPath(adsiPath));

   result.erase();

   HRESULT hr = S_OK;

   do
   {
      SmartInterface<IADs> iads(0);
      IADs* p = 0;
      hr = 
         ::ADsGetObject(
            adsiPath.c_str(),
            QI_PARAMS(IADs, &p));
      BREAK_ON_FAILED_HRESULT(hr);

      iads.Acquire(p);

      hr = ADSI::GetSidPath(iads, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
ADSI::IsWinNTPath(const String& path)
{
   LOG_FUNCTION2(ADSI::IsWinNTPath, path);

   bool result = false;

   if (path.find(ADSI::PROVIDER_ROOT) == 0)
   {
      result = true;
   }

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\adsinode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// AdsiNode class
// 
// 9-22-97 sburns



#ifndef ADSINODE_HPP_INCLUDED
#define ADSINODE_HPP_INCLUDED



#include "resnode.hpp"
#include "adsi.hpp"



// AdsiNode is an intermediate adstract base class for all Nodes which are
// built from ADSI APIs.  All ADSI entities use their ADSI path name as their
// unique identifier.  By forcing that path to be supplied upon contruction,
// this class enforces that notion of identity.

class AdsiNode : public ResultNode
{
   public:



   // Return the path with which this node was constructed.
      
   const ADSI::Path&
   GetPath() const;


   
   // See base class.  Compares the pathnames.

   virtual
   bool
   IsSameAs(const Node* other) const;



   protected:



   // Constructs a new instance. Declared protected as this class may only
   // be used as a base class.
   // 
   // owner - See base class ctor.
   //
   // nodeType - See base class ctor.
   // 
   // displayName - See base class ctor.
   //
   // path - the ADSI::Path object that refers to the object this node
   // is to represent.

   AdsiNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType,
      const String&                          displayName,
      const ADSI::Path&                      path);

   virtual ~AdsiNode();



   // ResultNode::Rename helper function
      
   HRESULT
   rename(const String& newName);

   private:

   ADSI::Path path;



   // not implemented: no copying allowed

   AdsiNode(const AdsiNode&);
   const AdsiNode& operator=(const AdsiNode&);
};



#endif   // ADSINODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\adsi.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ADSI wrapper
// 
// 9-22-97 sburns



#ifndef ADSI_HPP_INCLUDED
#define ADSI_HPP_INCLUDED



// Macro to define an inline static method of class ADSI that calls
// ADsGetObject for the supplied path, and binds the resulting interface to a
// smart interface pointer.
// 
// name - ADSI classname.  As this is used in token-pasted composition of the
// corresponding IADs interface and interface IID, this must appear exactly as
// in the ADSI IDL.  e.g. User, Group, Container, etc.
// 
// The resulting function has the signature:
// static HRESULT GetXXX(const String& path, SmartInterface<IADsXXX>& ptr)
// where 'XXX' is replaced with the name parameter of the macro.  Returns the
// result of ADsGetObject.
// 
// path - The ADSI path of the object to be bound.
// 
// ptr - A null smart pointer to be bound to the interface of the object.

#define DEFINE_GET(name)                                                \
static                                                                  \
HRESULT                                                                 \
Get##name(                                                              \
   const String&               path,                                    \
   SmartInterface<IADs##name>& ptr)                                     \
{                                                                       \
   LOG_FUNCTION2(ADSI::Get##name, path);                              \
   return TemplateGetObject<IADs##name>(path, ptr);                     \
}                                                                       \



// Template function that actually calls ADsGetObject for the DEFINE_GET
// macro.  While it should be possible to define this template as a member of
// the ADSI class, the VC++ 5 parser doesn't allow it.
// 
// Interface - The IADsXXX interface of the object to be bound.
// 
// path - The ADSI path of the object to be bound.
// 
// ptr - A null smart pointer to be bound to the interface of the object.

template <class Interface> 
static
HRESULT
TemplateGetObject(
   const String&               path,
   SmartInterface<Interface>&  ptr)
{
   ASSERT(!path.empty());
   ASSERT(ADSI::IsWinNTPath(path));

   Interface* p = 0;
   HRESULT hr = 
      ::ADsGetObject(
         path.c_str(),
         __uuidof(Interface), 
         reinterpret_cast<void**>(&p));
   if (!FAILED(hr))
   {
      ptr.Acquire(p);
   }

   return hr;
}



// Macro to define an inline static method of class ADSI that calls
// IADsContainer::Create for the supplied relative object naem, and binds the
// interface of the resulting new object to a smart interface pointer.
//
// className - ADSI classname.
// 
// interfaceName - ADSI IADsXxxx interface name. As this is used in
// token-pasted composition of the corresponding IADs interface and interface
// IID, this must appear exactly as in the ADSI IDL.  e.g. User, Group,
// Container, etc.
// 
// The resulting function has the signature:
// static HRESULT
// CreateXXX(
//    SmartInterface<IADsContainer>   container,
//    const String&                 relativeName,
//    SmartInterface<IADsXXX>&        ptr)
// where 'XXX' is replaced with the name parameter of the macro.  Returns the
// result of ADsGetObject.
// 
// container - smart pointer bound to the ADSI container object that is to
// contain the created object.
// 
// relativeName - The "leaf" name of the new object, relative to the name of
// the container.  I.e. *not* the full ADSI path of the new object.
// 
// ptr - A null smart pointer to be bound to the interface of the new object.

#define DEFINE_CREATE(className, interfaceName)                         \
static                                                                  \
HRESULT                                                                 \
Create##interfaceName(                                                  \
   const SmartInterface<IADsContainer>   container,                     \
   const String&                         relativeName,                  \
   SmartInterface<IADs##interfaceName>&  ptr)                           \
{                                                                       \
   LOG_FUNCTION2(ADSI::Create##className, relativeName);              \
   return                                                               \
      TemplateCreateObject<                                             \
         IADs##interfaceName,                                           \
         &ADSI::CLASS_##className,                                      \
         &IID_IADs##interfaceName>(container, relativeName, ptr);       \
}                                                                       \
         
   

// Template function that actually implements the DEFINE_CREATE
// macro.  While it should be possible to define this template as a member of
// the ADSI class, the VC++ 5 parser doesn't allow it.
// 
// Interface - The IADsXXX interface of the object to be bound.
// 
// classname - The ADSI class name of the object to be created.
// 
// interfaceID - The IID of the Interface parameter.
// 
// container - smart pointer bound to the ADSI container object that is to
// contain the created object.
// 
// relativeName - in, The "leaf" name of the new object, relative to the name
// of the container.  I.e. *not* the full ADSI path of the new object.
// 
// object - out, A null smart pointer to be bound to the interface of the new
// object.

template <class Interface, const String* classname, const IID* interfaceID>
HRESULT
TemplateCreateObject(
   const SmartInterface<IADsContainer> container,
   const String&                       relativeName,
   SmartInterface<Interface>&          object)
{
   ASSERT(classname);
   ASSERT(interfaceID);
   ASSERT(!relativeName.empty());

   IDispatch* p = 0;
   HRESULT hr =
      container->Create(AutoBstr(*classname), AutoBstr(relativeName), &p);
   if (!FAILED(hr))
   {
      ASSERT(p);
      hr = object.AcquireViaQueryInterface(*p, *interfaceID);
      ASSERT(SUCCEEDED(hr));
      p->Release();
   }

   return hr;
}



// Class ADSI bundles a bunch of useful functions and static data for dealing
// with ADSI.

class /* namespace, really */ ADSI
{
   public:

   static const String PROVIDER;
   static const String PROVIDER_ROOT;
   static const String CLASS_User;
   static const String CLASS_Group;
   static const String CLASS_Computer;
   static const String PATH_SEP;
   static const String PROPERTY_PasswordExpired;
   static const String PROPERTY_UserFlags;
   static const String PROPERTY_LocalDrive;
   static const String PROPERTY_UserParams;
   static const String PROPERTY_ObjectSID;
   static const String PROPERTY_GroupType;

   // InetOrgPerson needs to be supported as if it was a user.
   // The WINNT provider always returns inetOrgPerson objects
   // as users but the LDAP provider returns them as inetOrgPerson.
   // This string is used for the comparison
   // NTRAID#NTBUG9-436314-2001/07/16-jeffjon

   static const String CLASS_InetOrgPerson;


   // Given a computer name, compose the WinNT provider ADSI path for that
   // machine, return the result.  The computer object is not verified to
   // exist.  Path is of the form "WinNT://machine,Computer"
   //
   // computerName - name of the computer, without leading \\'s

   static
   String
   ComposeMachineContainerPath(const String& computerName);



   // Deletes an object.
   // 
   // containerADSIPath - fully-qualified ADSI path of the container of the
   // object to be deleted.  E.g. to delete "WinNT://foo/bar", this parameter
   // would have the value "WinNT://foo".
   // 
   // objectRelativeName - name of the object to be deleted, relative to the
   // name of the parent container.  E.g. to delete object "WinNT://foo/bar",
   // this paramter would have the value "bar".
   // 
   // objectClass - ADSI classname of the object to be deleted, in order to
   // disambiguate objects of different classes with the same name in the same
   // container.  E.g. "User", "Group".  See the ADSI::CLASS_XXX constants.

   static
   HRESULT
   DeleteObject(
      const String& containerADSIPath,
      const String& objectRelativeName,
      const String& objectClass);



   static
   String
   ExtractDomainObjectName(const String& ADSIPath);



   // Extracts the leaf name from a fully-qualified ADSI path name.  E.g. for
   // "WinNT://machine/Fred", returns "Fred"
   // 
   // path - fully-qualified ADSI path of the object.  The object need not
   // exist.

   static
   String
   ExtractObjectName(const String& ADSIPath);


   
   // Allocates and copyies a sid. Caller must free the result with
   // ADSI::FreeSid.
   
   static 
   HRESULT
   DuplicateSid(SID* sid, SID*& result);

   
   
   static   
   void
   FreeSid(SID* sid);


   
   // Determines the SID path of the supplied object.
   //   
   // iads - interface pointer to bound WinNT object, assumed to be one that
   // has a ObjectSid property.
   //
   // result - receives the result, a pointer to a chuck of memory that
   // contains the object's sid.  This result should be freed with
   // ADSI::FreeSid (not Win32 FreeSid)

   static   
   HRESULT
   GetSid(const SmartInterface<IADs>& iads, SID*& result);

   
   
   // Determines the SID path of the supplied object.
   //   
   // adsiPath - WinNT pathname of the object for which the sid-style path
   // is to be retrieved.  assumed to be the path of an object that has a
   // ObjectSid property.
   //
   // result - receives the result, a pointer to a chuck of memory that
   // contains the object's sid.  This result should be freed with
   // ADSI::FreeSid (not Win32 FreeSid)

   static
   HRESULT
   GetSid(const String& path, SID*& result);


   
   // Determines the SID-style path of the supplied object.  A SID-style path
   // is of the form WinNT://S-1-5...
   //
   // iads - interface pointer to bound WinNT object, assumed to be one that
   // has a ObjectSid property.
   //
   // result - receives the result

   static
   HRESULT
   GetSidPath(const SmartInterface<IADs>& iads, String& result);



   // Determines the SID-style path of the supplied object.  A SID-style path
   // is of the form WinNT://S-1-5...
   //
   // adsiPath - WinNT pathname of the object for which the sid-style path
   // is to be retrieved.  assumed to be the path of an object that has a
   // ObjectSid property.
   //
   // result - receives the result

   static
   HRESULT
   GetSidPath(const String& adsiPath, String& result);



   // Versions of the templates:

   DEFINE_GET(User);
   DEFINE_GET(Group);
   DEFINE_GET(Container);
   DEFINE_CREATE(User, User);
   DEFINE_CREATE(Group, Group);



   // static               
   // HRESULT              
   // GetObject(           
   //    const String&        path,
   //    SmartInterface<IADs>&  ptr) 
   // {                            
   //    return TemplateGetObject<IADs, &IID_IADs>(path, ptr); 
   // }                                                        



   // Returns S_OK if the computer object could be bound, an error code
   // otherwise.
   //
   // machine - the leaf name of the computer object, without leading \\'s   

   static
   HRESULT
   IsComputerAccessible(const String& machine);



   static
   bool
   IsWinNTPath(const String& path);



   // Rename or move an object.
   // 
   // destinationContainerADSIPath - fully-qualified ADSI path of the
   // container to receive the object named by objectADSIPath.
   //
   // objectADSIPath - the fully-qualified ADSI path of the object to be
   // renamed or moved.  If this parent of this path differs from that given
   // by containerADSIPath, the object is moved to containerADSIPath.  (I.e. a
   // rename is an in-place move).
   //    
   // newName - new leaf name of the object.

   static
   HRESULT
   RenameObject(
      const String& desitnationContainerADSIPath,
      const String& objectADSIPath,
      const String& newName);



   // Converts a VARIANT containing a safe array of bytes to a string-ized SID
   // of the form S-1-5-....
   //
   // var - variant initialized with the safe array.
   //
   // result - receives the result.

   static
   HRESULT
   VariantToSidPath(VARIANT* var, String& result);



   // Used with VisitXxxx functions, ObjectVistor is an abstract base class.
   // The Visit method is called for each object in an container or member
   // enumeration.

   class ObjectVisitor
   {
      public:

      virtual 
      void
      Visit(const SmartInterface<IADs>& object) = 0;
   };



   // Applies the given visitor to each child object of a particular class in
   // a given container.
   // 
   // containerPath - fully-qualified ADSI path of the container to enumerate.
   // 
   // objectADSIClass - ADSI classname of the class of child objects to visit.
   // See ADSI::CLASS_Xxxx constants.
   // 
   // visitor - ObjectVistor instance.  The Visit method of this object will
   // be invoked for every child object enumerated of the specified ADSI
   // class.

   static
   HRESULT
   VisitChildren(
      const String&        containerPath,
      const String&        objectADSIClass,
      ADSI::ObjectVisitor& visitor);



   // Applies a given vistor to each of the members of a Group.
   // 
   // group - smart pointer bound to an IADsGroup interface.
   // 
   // visitor - The Visit method of this object will be invoked for every
   // member of the group.

   static
   HRESULT
   VisitMembers(
      const SmartInterface<IADsGroup>& group,
      ADSI::ObjectVisitor&             visitor);



   // Applies a given visitor to each of the groups to which a user object
   // belongs.
   // 
   // user - smart pointer bound to an IADsUser interface.
   // 
   // visitor - The Visit method of this object will be invoked for every
   // member of the group.

   static
   HRESULT
   VisitGroups(
      const SmartInterface<IADsUser>&  user,
      ADSI::ObjectVisitor&             visitor);



   class Path
   {
      public:

      Path(const String& path_, const String& sidPath_)
         :
         path(path_),
         sidPath(sidPath_)
      {
         ASSERT(!path.empty());
         ASSERT(!sidPath.empty());
      }


      
      // default copy ctor, op= used.

      // no ctor from IADs* because I don't want to have to deal with error
      // handling for a failed ctor (which, if I did want to deal with it,
      // would be done with exceptions, I suppose).


      
      bool
      operator==(const Path& rhs) const
      {
         // we use the sidpath as the basis of comparison, as a sid is the
         // identity of an object.

         bool result = sidPath.icompare(rhs.sidPath) == 0 ? true : false;

         // Check that the non-sid path is the same, too.
         
         ASSERT(!result || (result && path.icompare(rhs.path) == 0));

         return result;
      }


      
      String
      GetSidPath() const
      {
         return path;

         // CODEWORK: someday, the WinNT provider may allow directly binding
         // to objects with the sid-style path.  When that happens, just
         // uncomment this line, and we will have rename-safe prop pages
         // return sidPath;
         // NTRAID#NTBUG9-490601-2001/11/06-sburns
      }



      String
      GetPath() const
      {
         return path;
      }



      String
      GetObjectName() const
      {
         return ADSI::ExtractObjectName(path);
      }


      
      String
      GetServerName() const
      {
         return ADSI::PathCracker(path).serverName();
      }



      private:

      String path;
      String sidPath;
   };
      
      

   // Wrapper for that very problematic IADsPathname

   class PathCracker
   {
      public:

      PathCracker(const String& adsiPath);

      ~PathCracker();

      String
      containerPath() const;

      int
      elementCount() const;

      String
      element(int index) const;

      String
      leaf() const;

      String
      serverName() const;

      private:

      void
      reset() const;

      SmartInterface<IADsPathname> ipath;
      String                       path;
      AutoCoInitialize             coinit;

      // not defined: no copying allowed

      PathCracker(const PathCracker&);
      const PathCracker& operator=(const PathCracker&);
   };

   private:



   // not implemented.  This class can't be instantiated.

   ADSI();
   ADSI(const ADSI&);
};



#endif   // ADSI_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\adsipage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ASDIPage base class class
// 
// 10-30-97 sburns



#ifndef ADSIPAGE_HPP_INCLUDED
#define ADSIPAGE_HPP_INCLUDED



#include "mmcprop.hpp"
#include "adsi.hpp"



// ADSIPage is a base class for property pages for that are editing the
// properties of an ADSI object.

class ADSIPage : public MMCPropertyPage
{
   protected:



   // Constructs a new instance. Declared protected as this class may only
   // serve as a base class.
   //
   // dialogResID - See base class ctor.
   //
   // helpMap - See base class ctor.
   //
   // state - See base class ctor.
   //
   // path - the ADSI::Path object that refers to the object this page will
   // refer to.

   ADSIPage(
      int                  dialogResID,
      const DWORD          helpMap[],
      NotificationState*   state,
      const ADSI::Path&    path);


      
   // Returns the object name of the ADSI object.

   String
   GetObjectName() const;

   // Returns the machine where the ADSI object resides.

   String
   GetMachineName() const;


   
   // Returns the path with which the object was constructed.
   
   const ADSI::Path&
   GetPath() const;


   
   private:

   ADSI::Path path;
   
   // not implemented: no copying allowed
   ADSIPage(const ADSIPage&);
   const ADSIPage& operator=(const ADSIPage&);
};



#endif   // ADSIPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\comp.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// IComponent implementation
//
// 9-2-97 sburns



#include "headers.hxx"
#include "comp.hpp"
#include "compdata.hpp"
#include "images.hpp"
#include "resource.h"
#include "resnode.hpp"
#include "mseldo.hpp"



Component::Component(ComponentData* parent_)
   :
   console(0),
   consoleVerb(0),
   headerCtrl(0),
   parent(parent_),
   refcount(1),       // implicit AddRef
   resultData(0),
   selectedScopeNode(0),
   displayHelp(0),
   displayInfoCache()
{
   LOG_CTOR(Component);
   ASSERT(parent);
}



Component::~Component()
{
   LOG_DTOR(Component);

   // ensure that everything has been released (in the Destroy method)

   ASSERT(!console);
   ASSERT(!consoleVerb);
   ASSERT(!headerCtrl);
   ASSERT(!parent);
   ASSERT(!refcount);
   ASSERT(!resultData);
   ASSERT(!selectedScopeNode);
   ASSERT(!displayHelp);
}



ULONG __stdcall
Component::AddRef()
{
   LOG_ADDREF(Component);   

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
Component::Release()
{
   LOG_RELEASE(Component);   

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);

   return newref;
}



HRESULT __stdcall
Component::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
//   LOG_FUNCTION(Component::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
//      LOG(L"Supplying IUnknown interface");
      *interfaceDesired = static_cast<IUnknown*>(
         static_cast<IComponent*>(this));
   }
   else if (interfaceID == IID_IComponent)
   {
//      LOG(L"Supplying IComponent interface");
      *interfaceDesired = static_cast<IComponent*>(this);
   }
   else if (interfaceID == IID_IExtendContextMenu)
   {
//      LOG(L"Supplying IExtendContextMenu interface");
      *interfaceDesired = static_cast<IExtendContextMenu*>(this);
   }
   else if (interfaceID == IID_IExtendPropertySheet)
   {
//      LOG(L"Supplying IExtendPropertSheet interface");
      *interfaceDesired = static_cast<IExtendPropertySheet*>(this);
   }
//    else if (interfaceID == IID_IResultDataCompare)
//    {
// //      LOG(L"Supplying IResultDataCompare interface");
//       *interfaceDesired = static_cast<IResultDataCompare*>(this);
//    }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall   
Component::Initialize(IConsole* c)
{
   LOG_FUNCTION(Component::Initialize);   
   ASSERT(c);

   HRESULT hr = S_OK;
   do
   {
      hr = console.AcquireViaQueryInterface(*c);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = resultData.AcquireViaQueryInterface(*console); 
      BREAK_ON_FAILED_HRESULT(hr);

      hr = headerCtrl.AcquireViaQueryInterface(*console); 
      BREAK_ON_FAILED_HRESULT(hr);

      hr = displayHelp.AcquireViaQueryInterface(*console); 
      BREAK_ON_FAILED_HRESULT(hr);

      IConsoleVerb* verb = 0;
      hr = console->QueryConsoleVerb(&verb);
      ASSERT(verb);
      consoleVerb.Acquire(verb);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT __stdcall
Component::Notify(
   IDataObject*      dataObject,
   MMC_NOTIFY_TYPE   event,
   LPARAM            arg,
   LPARAM            param)
{
   LOG_FUNCTION(Component::Notify);   

   if (dataObject && IS_SPECIAL_DATAOBJECT(dataObject))
   {
      return E_NOTIMPL;
   }
                     
   HRESULT hr = S_FALSE;
   switch (event)
   {
      case MMCN_ADD_IMAGES:
      {
//         LOG(L"MMCN_ADD_IMAGES");
         ASSERT(arg);

         hr = DoAddImages(*reinterpret_cast<IImageList*>(arg));
         break;
      }
      case MMCN_ACTIVATE:
      {
//         LOG(L"MMCN_ACTIVATE");
         break;
      }
      case MMCN_BTN_CLICK:
      {
//         LOG(L"MMCN_BTN_CLICK");
         break;
      }
      case MMCN_COLUMN_CLICK:
      {
//         LOG(L"MMCN_COLUMN_CLICK");
         break;
      }
      case MMCN_CLICK:
      {
//         LOG(L"MMCN_CLICK");
         break;
      }
      case MMCN_DBLCLICK:
      {
//         LOG(L"MMCN_DBLCLICK");

         // allow the default context menu action

         hr = S_FALSE;  
         break;
      }
      case MMCN_DELETE:
      {
//         LOG(L"MMCN_DELETE");

         ASSERT(dataObject);

         if (dataObject)
         {
            hr = DoDelete(*dataObject);
         }
         break;
      }
      case MMCN_MINIMIZED:
      {
//         LOG(L"MMCN_MINIMIZED");
         break;
      }
      case MMCN_PROPERTY_CHANGE:
      {
         LOG(L"MMCN_PROPERTY_CHANGE");

         if (!arg)
         {
            // change was for a result pane item, refresh the pane this node
            // was the selected node when the prop sheet was created.

            ScopeNode* node = reinterpret_cast<ScopeNode*>(param);
            ASSERT(node);
            if (node)
            {
               hr = DoResultPaneRefresh(*node);

               // Since the call to MMCPropertyChangeNotify in
               // MMCPropertyPage::NotificationState::~NotificationState
               // has AddRef'd node, then we must Release that reference.
               //
               // NTRAID#NTBUG9-431831-2001/07/06-sburns               

               node->Release();
            }
            else
            {
               hr = E_INVALIDARG;
            }
         }
         break;
      }
      case MMCN_REFRESH:
      {
//         LOG(L"MMCN_REFRESH");

         ASSERT(dataObject);

         if (dataObject)
         {
            hr = DoRefresh(*dataObject);
         }
         break;
      }
      case MMCN_RENAME:
      {
//         LOG(L"MMCN_RENAME");

         ASSERT(dataObject);

         if (dataObject)
         {
            hr =
               DoRename(
                  *dataObject,
                  String(reinterpret_cast<PWSTR>(param)));
         }
         break;
      }
      case MMCN_SELECT:
      {
//         LOG(L"MMCN_SELECT");

         ASSERT(dataObject);

         if (dataObject)
         {
            hr =
               DoSelect(
                  *dataObject,  
                  /* LOWORD(arg) ? true : false, */ // scope or result? who cares?
                  HIWORD(arg) ? true : false);
         }
         break;
      }
      case MMCN_SHOW:
      {
//         LOG(L"MMCN_SHOW");

         ASSERT(dataObject);
      
         if (dataObject)
         {
            hr = DoShow(
               *dataObject,
               arg ? true : false
               /* reinterpret_cast<HSCOPEITEM>(param) who cares? */ );
         }
         break;
      }
      case MMCN_VIEW_CHANGE:
      {
//         LOG(L"MMCN_VIEW_CHANGE");

         ASSERT(dataObject);

         if (dataObject)
         {
            hr = DoViewChange(*dataObject, arg ? true : false);
         }
         break;
      }
      case MMCN_CONTEXTHELP:
      {
         LOG(L"MMCN_CONTEXTHELP");

         // fall thru
      }
      case MMCN_SNAPINHELP:
      {
         LOG(L"MMCN_SNAPINHELP");

         static const String HELPFILE(String::load(IDS_HTMLHELP_NAME));
         static const String TOPIC(String::load(IDS_HTMLHELP_OVERVIEW_TOPIC));

         String helpparam = HELPFILE + L"::" + TOPIC;
         hr =
            displayHelp->ShowTopic(
               const_cast<wchar_t*>(helpparam.c_str()));
         break;
      }
      default:
      {
         LOG(String::format(L"unhandled event 0x%1!08X!", event));

         break;
      }
   }

   return hr;
}



HRESULT __stdcall
Component::Destroy(MMC_COOKIE /* cookie */ )
{
   LOG_FUNCTION(Component::Destroy);     

   // We have to release these now, rather than upon calling of our dtor,
   // in order to break a circular dependency with MMC.

   resultData.Relinquish();
   headerCtrl.Relinquish();
   consoleVerb.Relinquish();
   console.Relinquish();
   parent.Relinquish();
   selectedScopeNode.Relinquish();
   displayHelp.Relinquish();

   return S_OK;
}



HRESULT __stdcall
Component::QueryDataObject(
  MMC_COOKIE         cookie,
  DATA_OBJECT_TYPES  type,
  IDataObject**      ppDataObject)
{
   LOG_FUNCTION(Component::QueryDataObject);     

   switch (cookie)
   {
      case MMC_MULTI_SELECT_COOKIE:
      {
         return E_NOTIMPL;

//          // create a multi-select data object, AddRef'd once.
//          MultiSelectDataObject* data_object = new MultiSelectDataObject();
// 
//          // walk the result pane and note the nodes that are selected.
//          RESULTDATAITEM item;
//          memset(&item, 0, sizeof(item));
//          item.mask = RDI_STATE;
//          item.nIndex = -1;
//          item.nState = TVIS_SELECTED;
// 
//          HRESULT hr = S_OK;
//          do
//          {
//             item.lParam = 0;
//             hr = resultData->GetNextItem(&item);
//             if (hr != S_OK)
//             {
//                break;
//             }
// 
//             ResultNode* node =
//                dynamic_cast<ResultNode*>(
//                   parent->GetInstanceFromCookie(item.lParam));
//             if (node)
//             {
//                data_object->AddDependent(node);
//             }
//             else
//             {
//                hr = E_INVALIDARG;
//                break;
//             }
//          }
//          while (1);
// 
//          if (SUCCEEDED(hr))
//          {
//             *ppDataObject = data_object;
//             return S_OK;
//          }
// 
//          // failure: cause the data object to delete itself
//          data_object->Release();
//          return hr;
      }
      case MMC_WINDOW_COOKIE:
      {
         // only used if the result pane is an error message window.

         return E_NOTIMPL;
      }
      default:
      {
         return parent->QueryDataObject(cookie, type, ppDataObject);
      }
   }
}



HRESULT __stdcall
Component::GetResultViewType(
   MMC_COOKIE  cookie,
   LPOLESTR*   viewType,
   long*       options)
{
   LOG_FUNCTION(Component::GetResultViewType);   
   ASSERT(viewType);
   ASSERT(options);

   if (parent->IsBroken())
   {
      // stringize the special CLSID, and pass that back.

      String mvs = Win::GUIDToString(CLSID_MessageView);
      return mvs.as_OLESTR(*viewType);
   }
      
   *viewType = 0;

   Node* node = parent->GetInstanceFromCookie(cookie);
   if (node)
   {
      ScopeNode* sn = dynamic_cast<ScopeNode*>(node);
      if (sn)
      {
         *options = sn->GetViewOptions();
         return S_FALSE;
      }
   }

   // no special view options

   *options = MMC_VIEW_OPTIONS_LEXICAL_SORT; 

   // use the default list view
   return S_FALSE;
}



HRESULT __stdcall
Component::GetDisplayInfo(RESULTDATAITEM* item)
{
//    LOG_FUNCTION(Component::GetDisplayInfo);    
   ASSERT(item);

   if (item)
   {
      // Extract the node in question from the item.  (the cookie is the
      // lParam member.)  This cookie should always be ours.

      MMC_COOKIE cookie = item->lParam;
      Node* node = parent->GetInstanceFromCookie(cookie);

      if (node)
      {
         // LOG(
         //    String::format(
         //       L"supplying display info for %1, column %2!u!",
         //       node->GetDisplayName().c_str(),
         //       item->nCol) ); 
            
         // Walk thru the item mask and fill in the info requested

         if (item->mask & RDI_STR)
         {
            // According to the MMC docs, it is safe to de/reallocate the
            // item->str member when GetDisplayInfo is called again for the
            // same cookie.  By replacing the value in the cache, we are
            // freeing the old memory.

            displayInfoCache[cookie] = node->GetColumnText(item->nCol);

            // the str member is a pointer to the raw string data in our
            // cache, which we will not alter until the cache is updated
            // for the same cookie.

            item->str =
               const_cast<wchar_t*>(
                  displayInfoCache[cookie].c_str() );
         }

         if (item->mask & RDI_IMAGE)
         {
            item->nImage = node->GetNormalImageIndex();
         }

         return S_OK;
      }
   }

   // bad cookie.  Yeech.
   return E_FAIL;
}



// used by MMC to ensure that properties on a node (data object) are not
// launched twice for the same object.

HRESULT __stdcall
Component::CompareObjects(
   IDataObject* objectA,
   IDataObject* objectB)
{
   LOG_FUNCTION(Component::CompareObjects);

   if (IS_SPECIAL_DATAOBJECT(objectA) || IS_SPECIAL_DATAOBJECT(objectB))
   {
      return E_UNEXPECTED;
   }

   return parent->CompareObjects(objectA, objectB);
}



// Handles the MMCN_SHOW event.
// 
// dataObject - the IDataObject of the ScopeNode that is being shown/hidden.
// 
// show - true if the node is being shown (i.e. should populate it's result
// pane), false if the node is being hidden.

HRESULT
Component::DoShow(
   IDataObject&   dataObject,
   bool           show)
{
   LOG_FUNCTION(Component::DoShow);

   HRESULT hr = S_FALSE;   
   if (!show)
   {
      selectedScopeNode.Relinquish();
      return hr;
   }

   // The data object is really a ScopeNode.

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
   ASSERT(node);

   if (node)
   {
      selectedScopeNode = node;
      do                                                        
      {
         if (parent->IsBroken())
         {
            // the snapin bombed initialization for some reason.  Set the
            // entire result pane to a nasty message indicating this
            // fact.  337324

            ASSERT(console);

            SmartInterface<IUnknown> resultPane;
            IUnknown* unk = 0;
            hr = console->QueryResultView(&unk);
            BREAK_ON_FAILED_HRESULT(hr);
            resultPane.Acquire(unk);

            SmartInterface<IMessageView> messageView;
            hr = messageView.AcquireViaQueryInterface(resultPane);
            BREAK_ON_FAILED_HRESULT(hr);

            LPOLESTR olestr = 0;
            String s = String::load(IDS_APP_ERROR_TITLE);

            // console is responsible for calling CoTaskMemFree on olestr

            hr = s.as_OLESTR(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = messageView->SetTitleText(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            // console is responsible for calling CoTaskMemFree on olestr

            hr = parent->GetBrokenErrorMessage().as_OLESTR(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = messageView->SetBodyText(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = messageView->SetIcon(Icon_Error);
            BREAK_ON_FAILED_HRESULT(hr);

            break;
         }

         // load the columns of the listview 
         hr = node->InsertResultColumns(*headerCtrl);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = node->InsertResultItems(*resultData);
         BREAK_ON_FAILED_HRESULT(hr);

         hr =
            resultData->SetDescBarText(
               const_cast<wchar_t*>(
                  node->GetDescriptionBarText().c_str()));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      while (0);
   }

   return hr;
}



HRESULT
Component::DoViewChange(IDataObject& dataObject, bool clear)
{
   LOG_FUNCTION(Component::DoViewChange);

   HRESULT hr = S_FALSE;
   do
   {
      if (!selectedScopeNode)
      {
         break;
      }

      // only reload the result pane if the selected node is the one
      // that caused the refresh.

      hr = CompareObjects(&dataObject, selectedScopeNode);
      BREAK_ON_FAILED_HRESULT(hr);

      if (hr == S_OK)
      {
         if (clear)
         {
            hr = resultData->DeleteAllRsltItems();
            BREAK_ON_FAILED_HRESULT(hr);
         }
         else
         {
            hr = selectedScopeNode->InsertResultItems(*resultData);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }
   }
   while (0);

   return hr;
}



HRESULT
Component::DoAddImages(IImageList& imageList)
{
   LOG_FUNCTION(Component::DoAddImages);

   static const IconIDToIndexMap map[] =
   {
      { IDI_USER,          USER_INDEX          },
      { IDI_GROUP,         GROUP_INDEX         },
      { IDI_DISABLED_USER, DISABLED_USER_INDEX },
      { 0, 0 }
   };

   // register the IComponentData image list plus our own.  This means that
   // there is one big image list used by IComponent and IComponentData,
   // and that the indices are unique for that big list.
   HRESULT hr = parent->LoadImages(imageList);
   if (SUCCEEDED(hr))
   {
      return IconIDToIndexMap::Load(map, imageList);
   }

   return hr;
}
   


HRESULT __stdcall
Component::AddMenuItems(
   IDataObject*            dataObject,
   IContextMenuCallback*   callback,
   long*                   insertionAllowed)
{
   LOG_FUNCTION(Component::AddMenuItems);

   // CODEWORK: this may be a multi-select data object?  (see DoDelete)

   if (dataObject && !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      Node* node = nodePointerExtractor.GetNode<Node*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         return node->AddMenuItems(*callback, *insertionAllowed);
      }
   }

   return S_FALSE;
}


 
HRESULT __stdcall
Component::Command(long commandID, IDataObject* dataObject)
{
   LOG_FUNCTION(Component::Command);

   // CODEWORK: this may be a multi-select data object? (see DoDelete)

   if (dataObject && !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      Node* node = nodePointerExtractor.GetNode<Node*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         return node->MenuCommand(*this, commandID);
      }
   }

   return E_NOTIMPL;
}



HRESULT __stdcall
Component::CreatePropertyPages(
   IPropertySheetCallback* callback,
   LONG_PTR                handle,
   IDataObject*            dataObject)
{
   LOG_FUNCTION(Component::CreatePropertyPages);
   ASSERT(callback);
   ASSERT(dataObject);

   if (dataObject && !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         // build the notification state object
         MMCPropertyPage::NotificationState* state =
            new MMCPropertyPage::NotificationState(handle, selectedScopeNode);

         return node->CreatePropertyPages(*callback, state);
      }
   }

   return E_NOTIMPL;
}



HRESULT __stdcall
Component::QueryPagesFor(IDataObject* dataObject)
{
   LOG_FUNCTION(Component::QueryPagesFor);
   ASSERT(dataObject);

   if (dataObject && !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         return node->HasPropertyPages() ? S_OK : S_FALSE;
      }
   }

   return S_FALSE;
}



HRESULT
Component::DoSelect(IDataObject& dataObject, bool selected)
{
   LOG_FUNCTION(Component::DoSelect);

   HRESULT hr = S_FALSE;

   if (!selected)
   {
      return hr;
   }

   // CODEWORK: this may be a multi-select data object? (see DoDelete)

   Node* node = nodePointerExtractor.GetNode<Node*>(dataObject);
   ASSERT(node);

   if (node)
   {
      return node->UpdateVerbs(*consoleVerb);
   }

   return hr;
}



HRESULT
Component::DoRefresh(IDataObject& dataObject)
{
   LOG_FUNCTION(Component::DoRefresh);

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
   ASSERT(node);

   HRESULT hr = S_FALSE;      
   if (node)
   {
      do
      {
         // first call, with the '1' parameter, means "call
         // IResultData::DeleteAllRsltItems if you care that dataObject is
         // about to rebuild itself" 
         hr = console->UpdateAllViews(&dataObject, 1, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            // don't break...we need to update the views
         }

         hr = node->RebuildResultItems();
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            // don't break...we need to update the views
         }

         // second call, with the '0' parameter, means, "now that your
         // result pane is empty, repopulate it."
         hr = console->UpdateAllViews(&dataObject, 0, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
         }
      }
      while (0);

      return hr;
   }

   return hr;
}



HRESULT
Component::DoResultPaneRefresh(ScopeNode& changedScopeNode)
{
   LOG_FUNCTION(Component::DoResultPaneRefresh);

   HRESULT hr = S_FALSE;      
   do
   {
      // JonN 7/16/01 437337
      // AV when change User's or Group Properties and use "New Window from Here"
      // If this window has already been closed, skip the refresh
      if (!parent)
         break;

      // Get the data object for the scopeNode.
      IDataObject* dataObject = 0;
      hr =
         parent->QueryDataObject(
            reinterpret_cast<MMC_COOKIE>(&changedScopeNode),
            CCT_RESULT,
            &dataObject);
      BREAK_ON_FAILED_HRESULT(hr);

      // causes changedScopeNode to be rebuilt and any result panes displaying
      // the contents of the node to be repopulated.
      hr = DoRefresh(*dataObject);
      dataObject->Release();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
Component::DoRename(
   IDataObject&   dataObject,
   const String&  newName)
{
   LOG_FUNCTION(Component::DoRename);

   // only result nodes should be renameable.

   ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(dataObject);

   if (node)
   {
      return node->Rename(newName);
   }

   return S_FALSE;
}



// static
// MultiSelectDataObject*
// extractMultiSelectDataObject(IDataObject& dataObject)
// {
//    class MultiSelectDataObjectPointerExtractor : public Extractor
//    {
//       public:
// 
//       MultiSelectDataObjectPointerExtractor()
//          :
//          Extractor(
//             Win::RegisterClipboardFormat(MultiSelectDataObject::CF_PTR),
//             sizeof(MultiSelectDataObject*))
//       {
//       }
// 
//       MultiSelectDataObject*
//       Extract(IDataObject& dataObject)
//       {
//          MultiSelectDataObject* result = 0;
//          HGLOBAL mem = GetData(dataObject);
//          if (mem)
//          {
//             result = *(reinterpret_cast<MultiSelectDataObject**>(mem));
//             ASSERT(result);
//          }
// 
// #ifdef DBG
// 
//          // here we are counting on the fact that MultiSelectDataObject
//          // implements IDataObject, and that the data object we were given is
//          // really a MultiSelectDataObject.
//          MultiSelectDataObject* msdo =
//             dynamic_cast<MultiSelectDataObject*>(&dataObject);
//          ASSERT(msdo == result);
// #endif
// 
//          return result;
//       }
//    };
// 
//    static MultiSelectDataObjectPointerExtractor extractor;
// 
//    return extractor.Extract(dataObject);
// }



HRESULT
Component::DoDelete(IDataObject& dataObject)
{
   LOG_FUNCTION(Component::DoDelete);

   HRESULT hr = S_FALSE;

// @@ this does not work.  The data object here is a composite of all data
// objects returned by snapins responding to the multi-select QueryDataObject.
// Need to open the composite, find my data object that I returned from my querydataobject
// then iterate thru that.

//    MultiSelectDataObject* ms = extractMultiSelectDataObject(dataObject);
//    if (ms)
//    {
//       HRESULT hr = S_OK;
//       for (
//          MultiSelectDataObject::iterator i = ms->begin();
//          i != ms->end();
//          i++)
//       {
//          hr = (*i)->Delete();
//          if (FAILED(hr))
//          {
//             LOG_HRESULT(hr);
//             // don't break...we need to visit every node
//          }
//       }
// 
//       // refresh once all deletes have been done.
//       hr = DoResultPaneRefresh(*selectedScopeNode);
//       if (FAILED(hr))
//       {
//          LOG_HRESULT(hr);
//       }
// 
//       return hr;
//    }
//    else
   {
      // only result nodes should be deleteable.

      ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(dataObject);

      if (node)
      {
         do
         {
            hr = node->Delete();
            BREAK_ON_FAILED_HRESULT(hr);

            hr = DoResultPaneRefresh(*selectedScopeNode);
            BREAK_ON_FAILED_HRESULT(hr);
         }
         while(0);
      }
   }

   return hr;
}



// HRESULT __stdcall
// Component::Compare(
//    LPARAM     userParam,
//    MMC_COOKIE cookieA,  
//    MMC_COOKIE cookieB,  
//    int*       result)
// {
//    LOG_FUINCTION(Component::Compare);
//    ASSERT(result);
// 
//    HRESULT hr = S_OK;
// 
//    do
//    {
//       if (!result)
//       {
//          hr = E_INVALIDARG;
//          break;
//       }
// 
//       // on input, result is the column being compared.
// 
//       int column = *result;
//       *result = 0;
// 
//       Node* nodeA = parent->GetInstanceFromCookie(cookieA);
//       Node* nodeB = parent->GetInstanceFromCookie(cookieB);
//       ASSERT(nodeA && nodeB);
// 
//       if (nodeA && nodeB)
//       {
//          String text1 = nodeA->GetColumnText(column);
//          String text2 = nodeB->GetColumnText(column);
// 
//          *result = text1.icompare(text2);
//       }
//    }
//    while (0);
// 
//    LOG(
//          result
//       ?  String::format(L"result = %1!d!", *result)
//       :  L"result not set");
//    LOG_HRESULT(hr);
//       
//    return hr;
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\comp.hpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// IComponent implementation
//
// 9-2-97 sburns



#ifndef COMP_HPP_INCLUDED
#define COMP_HPP_INCLUDED



#include "scopnode.hpp"
#include "mmcprop.hpp"
#include "NodePointerExtractor.hpp"



// Implements IComponent.  An instance of this class is created for each MDI
// child of a particular "load" of a Snapin.

class Component 
   :
   public IComponent,
   public IExtendContextMenu,
   public IExtendPropertySheet /* ,
   public IResultDataCompare */
{
   // Only instances of ComponentData can create instances of this
   // class.
   friend class ComponentData;

   public:

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IComponent overrides

   virtual
   HRESULT __stdcall   
   Initialize(IConsole* console);

   virtual
   HRESULT __stdcall
   Notify(
      IDataObject*      dataObject,
      MMC_NOTIFY_TYPE   event,
      LPARAM            arg,
      LPARAM            param);

   virtual
   HRESULT __stdcall
   Destroy(MMC_COOKIE cookie);

   virtual
   HRESULT __stdcall
   QueryDataObject(
     MMC_COOKIE         cookie,
     DATA_OBJECT_TYPES  type,
     IDataObject**      ppDataObject); 

   virtual
   HRESULT __stdcall
   GetResultViewType(MMC_COOKIE cookie, LPOLESTR* viewType, long* options);

   virtual
   HRESULT __stdcall
   GetDisplayInfo(RESULTDATAITEM* item);

   virtual
   HRESULT __stdcall
   CompareObjects(IDataObject* objectA, IDataObject* objectB);

   // IExtendContextMenu overrides

   virtual
   HRESULT __stdcall
   AddMenuItems(
      IDataObject*            dataObject,
      IContextMenuCallback*   callback,
      long*                   insertionAllowed);
    
   virtual
   HRESULT __stdcall
   Command(long commandID, IDataObject* dataObject);

   // IExtendPropertySheet overrides

   virtual
   HRESULT __stdcall
   CreatePropertyPages(
      IPropertySheetCallback* callback,
      LONG_PTR                handle,
      IDataObject*            dataObject);

   virtual
   HRESULT __stdcall
   QueryPagesFor(IDataObject* dataObject);

   // IResultDataCompare overrides

   // virtual
   // HRESULT __stdcall
   // Compare(
   //    LPARAM     userParam,
   //    MMC_COOKIE cookieA,  
   //    MMC_COOKIE cookieB,  
   //    int*       result);

   private:

   // only our friend class ComponentData can instantiate us.
   //
   // parent - the instantiating parent ComponentData object.

   Component(ComponentData* parent);

   // only Release can cause us to be deleted

   virtual
   ~Component();

   // MMCN_SHOW handler

   HRESULT
   DoShow(
      IDataObject&   dataObject,
      bool           selected // ,
      /* HSCOPEITEM     scopeID */ );

   // MMCN_ADD_IMAGES handler

   HRESULT
   DoAddImages(IImageList& imageList);

   // MMCN_REFRESH handler
      
   HRESULT
   DoRefresh(IDataObject& dataObject);

   // MMCN_SELECT handler
         
   HRESULT
   DoSelect(
      IDataObject&   dataObject,
      bool           selected);

   // MMCN_VIEW_CHANGE handler

   HRESULT
   DoViewChange(IDataObject& dataObject, bool clear);

   // MMCN_PROPERY_CHANGE handler

   HRESULT
   DoResultPaneRefresh(ScopeNode& node);

   // MMCN_RENAME handler

   HRESULT
   DoRename(
      IDataObject&   dataObject,
      const String&  newName);

   // MMCN_DELETE handler

   HRESULT
   DoDelete(IDataObject& dataObject);

   // not implemented; no instance copying allowed.

   Component(const Component&);
   void operator=(const Component&);

   SmartInterface<IConsole2>       console;
   SmartInterface<IConsoleVerb>    consoleVerb;
   SmartInterface<IHeaderCtrl>     headerCtrl;
   SmartInterface<ComponentData>   parent;
   SmartInterface<IResultData>     resultData;
   SmartInterface<ScopeNode>       selectedScopeNode;
   SmartInterface<IDisplayHelp>    displayHelp;

   // We need a buffer that will persist beyond the life time of this call.
   // This is needed because the item->str needs to be valid when this call
   // returns.  (the need for this buffer is a design flaw in MMC, which
   // should have the snapin allocate an LPOLESTR and free it when it is not
   // needed.).
   // 
   // The MMC docs claim it is not safe to deallocate the buffer until the
   // cookie is destroyed, the Component is destroyed (with
   // IComponent::Destroy), or GetDisplayInfo is called again for the same
   // cookie.  We will cache the last result for each cookie in a map with the
   // cookie as the key and the result String as the value.
   //    
   // This map has the same lifetime as the Component instance.  Access is
   // threadsafe as the COM object in which it lives is apartment threaded.

   typedef
      std::map<
         MMC_COOKIE,
         String,
         std::less<MMC_COOKIE>,
         Burnslib::Heap::Allocator<String> >
      CookieToStringMap;

   CookieToStringMap    displayInfoCache;    
   ComServerReference   dllref;              
   long                 refcount;            
   NodePointerExtractor nodePointerExtractor;
};



#endif   // COMP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\creategroupdialog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateGroupDialog class
// 
// 10-15-97 sburns



#ifndef CREATEGROUPDIALOG_HPP_INCLUDED
#define CREATEGROUPDIALOG_HPP_INCLUDED



#include "dialog.hpp"



class MembershipListView;



class CreateGroupDialog : public Dialog
{
   public:

   // Constructs a new instance.
   // 
   // machine - computer name of the machine on which groups will be
   // created.

   CreateGroupDialog(const String& machine);

   virtual ~CreateGroupDialog();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnDestroy();

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   private:

   bool
   CreateGroup();

   void
   Enable();

   void
   Reset();

   String               machine;
   bool                 refresh_on_exit;
   MembershipListView*  listview;

   CreateGroupDialog(const CreateGroupDialog&);
   const CreateGroupDialog& operator=(const CreateGroupDialog&);
};



#endif CREATEGROUPDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\cracker.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ADSI::PathCracker class: a wrapper around a pretty poor interface...
// 
// 4-14-98 sburns



#include "headers.hxx"
#include "adsi.hpp"



#define LOG_PATH()                                                   \
         BSTR __path = 0;                                              \
         ipath->Retrieve(ADS_FORMAT_WINDOWS, &__path);                 \
         if (__path)                                                   \
         {                                                             \
            LOG(String::format(L"ADS_FORMAT_WINDOWS=%1", __path));   \
            ::SysFreeString(__path);                                   \
         }                                                             \
         BSTR __path2 = 0;                                             \
         ipath->Retrieve(ADS_FORMAT_SERVER, &__path2);                 \
         if (__path2)                                                  \
         {                                                             \
            LOG(String::format(L"ADS_FORMAT_SERVER=%1", __path2));   \
            ::SysFreeString(__path2);                                  \
         }                                                             \


ADSI::PathCracker::PathCracker(const String& adsiPath)
   :
   ipath(0),
   path(adsiPath)
{
   LOG_CTOR(ADSI::PathCracker);
   ASSERT(!path.empty());

   // we only support WinNT provider paths...   

   ASSERT(path.find(ADSI::PROVIDER) == 0);

   if (!path.empty())
   {
      HRESULT hr = S_OK;
      do
      {
         hr =
            ipath.AcquireViaCreateInstance(
               CLSID_Pathname,
               0,
               CLSCTX_INPROC_SERVER);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = ipath->Set(AutoBstr(path), ADS_SETTYPE_FULL);
         ASSERT(SUCCEEDED(hr));
      }
      while (0);
   }
}



ADSI::PathCracker::~PathCracker()
{
   LOG_DTOR(ADSI::PathCracker);
}



void
ADSI::PathCracker::reset() const
{
   ASSERT(ipath);

   if (ipath)
   {
      HRESULT hr = ipath->Set(AutoBstr(path), ADS_SETTYPE_FULL);
      ASSERT(SUCCEEDED(hr));
   }
}
   


int
ADSI::PathCracker::elementCount() const
{
   ASSERT(ipath);

   if (ipath)
   {
      LOG_PATH();

      long elements = 0;
      HRESULT hr = ipath->GetNumElements(&elements);
      ASSERT(SUCCEEDED(hr));
      ASSERT(elements);

      return elements;
   }

   return 0;
}



String
ADSI::PathCracker::element(int index) const
{
   ASSERT(ipath);

   String result;
   if (ipath)
   {
      LOG_PATH();

      BSTR element = 0;
      HRESULT hr = ipath->GetElement(index, &element);
      ASSERT(SUCCEEDED(hr));
      ASSERT(element);
      if (element)
      {
         result = element;
         ::SysFreeString(element);
      }
   }

   LOG(String::format(L"element %1!d! = %2", index, result.c_str()));
   return result;
}



String
ADSI::PathCracker::containerPath() const
{
   ASSERT(ipath);

   String result;
   if (ipath)
   {
      do
      {
         LOG_PATH();         
         HRESULT hr = ipath->RemoveLeafElement();
         BREAK_ON_FAILED_HRESULT(hr);

         BSTR container = 0;
         hr = ipath->Retrieve(ADS_FORMAT_WINDOWS, &container);
         BREAK_ON_FAILED_HRESULT(hr);

         ASSERT(container);
         if (container)
         {
            result = container;

            // REVIEW: result[result.length() - 1] is the same as *(result.rbegin())
            // which is cheaper?
            
            // if (result[result.length() - 1] == ADSI::PATH_SEP[0])
            // {
            //    // IADsPath: sometimes leaves trailing '/'
            //    result.resize(result.length() - 1);
            // }
            ::SysFreeString(container);
         }
      }
      while (0);

      reset();
      LOG_PATH();
   }

   LOG(String::format(L"container path=%1", result.c_str()));
   return result;
}



String
ADSI::PathCracker::leaf() const
{
   return element(0);
}



String
ADSI::PathCracker::serverName() const
{
   ASSERT(ipath);

   String result;
   if (ipath)
   {
      LOG_PATH();

      // If the ms network client is not installed, then paths have the
      // form (1) WinNT://servername/objectname.  If it is installed, then
      // they are of the form (2) WinNT://domainname/servername/objectname.
      //
      // Not astonishingly, given the all-around badness of
      // IADsPathname, the server format returns the domain name for form
      // (2) paths, and the server name for form (1) paths.  And the 1st
      // element of the path after the provider name is unreachable
      // except with Retrieve!

      if (elementCount() >= 2)
      {
         // form (2) name, so get the next-to-last element
         return element(1);
      }

      BSTR server = 0;
      HRESULT hr = ipath->Retrieve(ADS_FORMAT_SERVER, &server);
      ASSERT(SUCCEEDED(hr));
      ASSERT(server);
      if (server)
      {
         result = server;
         ::SysFreeString(server);
      }
   }

   LOG(String::format(L"server=%1", result.c_str()));

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\compdata.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Local Security MMC Snapin
//
// 8-19-97 sburns



#include "headers.hxx"
#include "compdata.hpp"
#include "rootnode.hpp"
#include "comp.hpp"
#include "resource.h"
#include "images.hpp"
#include "machine.hpp"
#include "uuids.hpp"
#include <compuuid.h>   // for Computer Management nodetypes
#include "adsi.hpp"
#include "dlgcomm.hpp"



// version number: bump this if you change the file layout
const unsigned VERSION_TAG = 1;
const unsigned CAN_OVERRIDE_MACHINE_FLAG = 0x01;
static NodeType SYS_TOOLS_NODE_TYPE = structuuidNodetypeSystemTools;



ComponentData::ComponentData()
   :
   canOverrideComputer(false),
   isExtension(false),
   isBroken(false),
   isBrokenEvaluated(false),
   isHomeEditionSku(false),
   console(0),
   nameSpace(0),
   refcount(1),    // implicit AddRef
   rootNode(0),
   isDirty(false),
   isDomainController(false)
{
   LOG_CTOR(ComponentData);

   // create the node object for the root node, implictly AddRef'd

   SmartInterface<ComponentData> spThis(this);
   rootNode.Acquire(new RootNode(spThis));
}



ComponentData::~ComponentData()
{
   LOG_DTOR(ComponentData);
   ASSERT(refcount == 0);
}



ULONG __stdcall
ComponentData::AddRef()
{
   LOG_ADDREF(ComponentData);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
ComponentData::Release()
{
   LOG_RELEASE(ComponentData);

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);

   return newref;
}



HRESULT __stdcall
ComponentData::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
//   LOG_FUNCTION(ComponentData::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
//      LOG(L"Supplying IUnknown interface");

      *interfaceDesired = static_cast<IUnknown*>(
         static_cast<IComponentData*>(this));
   }
   else if (interfaceID == IID_IComponentData)
   {
//      LOG(L"Supplying IComponentData interface");

      *interfaceDesired = static_cast<IComponentData*>(this);
   }
   else if (interfaceID == IID_IExtendContextMenu)
   {
//      LOG(L"Supplying IExtendContextMenu interface");

      *interfaceDesired = static_cast<IExtendContextMenu*>(this);
   }
   else if (interfaceID == IID_IExtendPropertySheet && !isExtension)
   {
      LOG(L"Supplying IExtendPropertySheet interface");

      *interfaceDesired = static_cast<IExtendPropertySheet*>(this);
   }
   else if (interfaceID == IID_IPersist)
   {
//      LOG(L"Supplying IPersist interface");

      *interfaceDesired = static_cast<IPersist*>(this);
   }
   else if (interfaceID == IID_IPersistStream)
   {
//      LOG(L"Supplying IPersistStream interface");

      *interfaceDesired = static_cast<IPersistStream*>(this);
   }
   else if (interfaceID == IID_ISnapinHelp)
   {
//      LOG(L"Supplying ISnapinHelp interface");

      *interfaceDesired = static_cast<ISnapinHelp*>(this);
   }
   else if (interfaceID == IID_IRequiredExtensions)
   {
//      LOG(L"Supplying IRequiredExtensions interface");

      *interfaceDesired = static_cast<IRequiredExtensions*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;

      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);

      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall
ComponentData::CreateComponent(IComponent** ppComponent)
{
   LOG_FUNCTION(ComponentData::CreateComponent);
   ASSERT(ppComponent);

   // this instance is implicitly AddRef'd by its ctor

   *ppComponent = new Component(this);
   return S_OK;
}



HRESULT __stdcall
ComponentData::CompareObjects(
   IDataObject* objectA,
   IDataObject* objectB)
{
   LOG_FUNCTION(ComponentData::CompareObjects);
   ASSERT(objectA);
   ASSERT(objectB);

   Node* nodeA = nodePointerExtractor.GetNode<Node*>(*objectA);
   Node* nodeB = nodePointerExtractor.GetNode<Node*>(*objectB);

   if (nodeA && nodeB)
   {
      // This needs to be a deep compare, because stale cookies (those that
      // are still held by MMC, but released by ScopeNode containers upon
      // refresh, for instance, may be compared.  Therefore, the addresses
      // of the nodes might be different, but still refer to the same
      // logical object.

      if (nodeA == nodeB)
      {
         // identity => equality

         return S_OK;
      }

      if (typeid(*nodeA) == typeid(*nodeB))
      {
         // the nodes are the same type

         if (nodeA->IsSameAs(nodeB))
         {
            return S_OK;
         }
      }
      return S_FALSE;
   }

   return E_UNEXPECTED;
}



HRESULT __stdcall
ComponentData::Destroy()
{
   LOG_FUNCTION(ComponentData::Destroy);

   // We have to release these now, rather than upon calling of our dtor,
   // in order to break a circular dependency with MMC.

   console.Relinquish();
   nameSpace.Relinquish();

   // rootNode is pointing back to us, so break the circular dependency.

   rootNode.Relinquish();

   return S_OK;
}



HRESULT __stdcall
ComponentData::GetDisplayInfo(SCOPEDATAITEM* item)
{
//   LOG_FUNCTION(ComponentData::GetDisplayInfo);
   ASSERT(item);

   // extract the node in question from the item

   ScopeNode* node =
      dynamic_cast<ScopeNode*>(GetInstanceFromCookie(item->lParam));
   ASSERT(node);

   if (node)
   {
      // LOG(
      //    String::format(
      //       L"supplying display info for %1",
      //       node->GetDisplayName().c_str()) );

      // Walk thru the item mask and fill in the info requested

      if (item->mask & SDI_STR)
      {
         item->displayname =
            const_cast<wchar_t*>(node->GetDisplayName().c_str());
      }
      if (item->mask & SDI_IMAGE)
      {
         item->nImage = node->GetNormalImageIndex();
      }
      if (item->mask & SDI_OPENIMAGE)
      {
         item->nOpenImage = node->GetOpenImageIndex();
      }

      return S_OK;
   }

   return E_FAIL;
}



HRESULT __stdcall
ComponentData::Initialize(IUnknown* consoleIUnknown)
{
   LOG_FUNCTION(ComponentData::Initialize);
   ASSERT(consoleIUnknown);

   HRESULT hr = S_OK;
   do
   {
      // Save important interface pointers

      hr = console.AcquireViaQueryInterface(*consoleIUnknown); 
      BREAK_ON_FAILED_HRESULT(hr);

      hr = nameSpace.AcquireViaQueryInterface(*consoleIUnknown);
      BREAK_ON_FAILED_HRESULT(hr);

      // Load the image list

      IImageList* scopeImageList = 0;
      hr = console->QueryScopeImageList(&scopeImageList);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = LoadImages(*scopeImageList);
      scopeImageList->Release();
   }
   while (0);

   return hr;
}



HRESULT
ComponentData::LoadImages(IImageList& imageList)
{
   LOG_FUNCTION(ComponentData::LoadImages);

   static IconIDToIndexMap map[] =
   {
      { IDI_FOLDER_OPEN,   FOLDER_OPEN_INDEX   },
      { IDI_FOLDER_CLOSED, FOLDER_CLOSED_INDEX },
      { IDI_ROOT_OPEN,     ROOT_OPEN_INDEX     },
      { IDI_ROOT_CLOSED,   ROOT_CLOSED_INDEX   },
      { IDI_ROOT_ERROR,    ROOT_ERROR_INDEX    },
      { 0, 0 }
   };

   return IconIDToIndexMap::Load(map, imageList);
}



HRESULT __stdcall
ComponentData::Notify(
   IDataObject*      dataObject,
   MMC_NOTIFY_TYPE   event,
   LPARAM            arg,
   LPARAM            param)
{
   LOG_FUNCTION(ComponentData::Notify);
   ASSERT(dataObject);

   HRESULT hr = S_FALSE;
   switch (event)
   {
      case MMCN_EXPAND:
      {
//         LOG(L"MMCN_EXPAND");

         hr =
            DoExpand(
               *dataObject,
               arg ? true : false,
               static_cast<HSCOPEITEM>(param));
         break;
      }
      case MMCN_REMOVE_CHILDREN:
      {
         LOG(L"MMCN_REMOVE_CHILDREN");

         hr =
            DoRemoveChildren(
               *dataObject,
               static_cast<HSCOPEITEM>(arg));
         break;
      }
      case MMCN_PRELOAD:
      {
         LOG(L"MMCN_PRELOAD");

         hr = DoPreload(*dataObject, static_cast<HSCOPEITEM>(arg));
         break;
      }
      default:
      {
         break;
      }
   }

   return hr;
}



// This is not really a preload: it's a pre-expand.  This message is sent
// after the console has called the Load method.

HRESULT
ComponentData::DoPreload(
   IDataObject&   /* dataObject */ ,
   HSCOPEITEM     rootNodeScopeID)
{
   LOG_FUNCTION(ComponentData::DoPreload);
   ASSERT(nameSpace);
   ASSERT(!GetInternalComputerName().empty());
   ASSERT(rootNode);

   // Rename the root node for the command-line override

   String displayName = rootNode->GetDisplayName();
   SCOPEDATAITEM item;

   // REVIEWED-2002/03/01-sburns correct byte count passed
   
   ::ZeroMemory(&item, sizeof item);

   item.mask        = SDI_STR;                                  
   item.displayname = const_cast<wchar_t*>(displayName.c_str());
   item.ID          = rootNodeScopeID;                          

   return nameSpace->SetItem(&item);
}




HRESULT __stdcall
ComponentData::QueryDataObject(
   MMC_COOKIE        cookie,
   DATA_OBJECT_TYPES /* type */ ,
   IDataObject**     ppDataObject)
{
   // LOG_FUNCTION2(
   //    ComponentData::QueryDataObject,
   //    String::format(L"cookie: %1!08X!, type: 0x%2!08X!", cookie, type));
   ASSERT(ppDataObject);

   Node* node = GetInstanceFromCookie(cookie);
   ASSERT(node);

   if (node)
   {
      return
         node->QueryInterface(QI_PARAMS(IDataObject, ppDataObject));
   }

   return E_FAIL;
}



HRESULT
ComponentData::DoExpand(
   IDataObject& dataObject,
   bool         expanding, 
   HSCOPEITEM   scopeID)   
{
   LOG_FUNCTION(ComponentData::DoExpand);

   HRESULT hr = S_FALSE;

   do
   {
      if (!expanding)
      {
         break;
      }

      NodeType nodeType = nodeTypeExtractor.Extract(dataObject);

      if (nodeType == SYS_TOOLS_NODE_TYPE)
      {
         LOG(L"expanding computer management");

         // we're extending the System Tools node of Computer Management

         isExtension = true;

         // determine the machine Computer Management is targeted at.

         String machine = machineNameExtractor.Extract(dataObject);

         // This may be the first time we've expanded our root node under
         // the computer management tree, in which case our computer names
         // have not been set.  If that is the case, then we need to set them
         // and test for brokenness.  So we compare the name returned by
         // comp mgmt against our internal variable, not the result of
         // GetDisplayComputerName.

         if (displayComputerName.icompare(machine) != 0)
         {
            // different machine.

            SetComputerNames(machine);
            EvaluateBrokenness();
            isDirty = true;
         }

         // don't insert our node in the tree on home edition

         // don't insert our node in the tree on a domain controller
         // NTRAID#NTBUG9-328287-2001/02/26-sburns

         if (!isHomeEditionSku && !isDomainController)
         {
            hr = rootNode->InsertIntoScopePane(*nameSpace, scopeID);
         }

         
         break;
      }

      // not expanding computer management...
      
      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
      ASSERT(node);

      if (!isBrokenEvaluated)
      {
         ASSERT(node == rootNode);
         EvaluateBrokenness();

         // change the root node icon (unless we're an extension, in which
         // case the normal image index mechanism will do the job -- in fact,
         // attempting to update the icon if we're an extension will be
         // rejected by the console)

         if (isBroken && !isExtension)
         {
            HRESULT unused = SetRootErrorIcon(scopeID);
            ASSERT(SUCCEEDED(unused));
         }
      }

      if (node)
      {
         hr = node->InsertScopeChildren(*nameSpace, scopeID);
      }
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
ComponentData::DoRemoveChildren(
   IDataObject&   dataObject,
   HSCOPEITEM     parentScopeID)
{
   LOG_FUNCTION(ComponentData::DoRemoveChildren);

   HRESULT hr = S_FALSE;

   NodeType nodeType = nodeTypeExtractor.Extract(dataObject);
   if (nodeType == SYS_TOOLS_NODE_TYPE)
   {
      // we're extending the System Tools node of Computer Management

      ASSERT(isExtension);

      hr = rootNode->RemoveScopeChildren(*nameSpace, parentScopeID);
   }
   else
   {
      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
      ASSERT(node);

      if (node)
      {
         hr = node->RemoveScopeChildren(*nameSpace, parentScopeID);
      }
   }

   return hr;
}



HRESULT __stdcall
ComponentData::AddMenuItems(
   IDataObject*            dataObject,
   IContextMenuCallback*   callback,
   long*                   insertionAllowed)
{
   LOG_FUNCTION(ComponentData::AddMenuItems);
   ASSERT(dataObject);
   ASSERT(callback);
   ASSERT(insertionAllowed);

   HRESULT hr = S_OK;

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);
   ASSERT(node);

   if (node)
   {
      hr = node->AddMenuItems(*callback, *insertionAllowed);
   }

   return hr;
}



HRESULT __stdcall
ComponentData::Command(long commandID, IDataObject* dataObject)
{
   LOG_FUNCTION(ComponentData::Command);

   HRESULT hr = S_OK;

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);
   ASSERT(node);

   if (node)
   {
      hr = node->MenuCommand(*this, commandID);
   }

   return hr;
}



HRESULT __stdcall
ComponentData::CreatePropertyPages(
   IPropertySheetCallback* callback,
   LONG_PTR                handle,
   IDataObject*            dataObject)
{
   LOG_FUNCTION(ComponentData::CreatePropertyPages);
   ASSERT(callback);
   ASSERT(dataObject);

   HRESULT hr = S_FALSE;
   do
   {
      if (isExtension)
      {
         // we should not have provided IExtendPropertySheet in QI

         ASSERT(false);

         break;
      }

      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);

      if (!node)
      {
         ASSERT(false);

         hr = E_UNEXPECTED;
         break;
      }

      // the data object is ours, and should be the root node.  The page
      // we will provide is the computer chooser.

      ASSERT(dynamic_cast<RootNode*>(node));

      SmartInterface<ScopeNode> spn(node);
      MMCPropertyPage::NotificationState* state =
         new MMCPropertyPage::NotificationState(handle, spn);

      ComputerChooserPage* chooserPage =
         new ComputerChooserPage(
            state,
            displayComputerName,
            internalComputerName,
            canOverrideComputer);
      chooserPage->SetStateOwner();

      do
      {
         HPROPSHEETPAGE hpage = chooserPage->Create();
         if (!hpage)
         {
            hr = Win::GetLastErrorAsHresult();
            break;
         }

         hr = callback->AddPage(hpage);
         if (FAILED(hr))
         {
            ASSERT(false);

            // note that this is another hr, not the one from the enclosing
            // scope.
             
            HRESULT unused = Win::DestroyPropertySheetPage(hpage);

            ASSERT(SUCCEEDED(unused));

            break;
         }

         isDirty = true;
      }
      while (0);

      if (FAILED(hr))
      {
         delete chooserPage;
      }
   }
   while (0);

   return hr;
}



// this should be only called from the snapin manager.

HRESULT __stdcall
ComponentData::QueryPagesFor(IDataObject* dataObject)
{
   LOG_FUNCTION(ComponentData::QueryPagesFor);
   ASSERT(dataObject);

   HRESULT hr = S_OK;

   do
   {
      if (isExtension)
      {
         // we should not have provided IExtendPropertySheet in QI

         ASSERT(false);

         hr = E_UNEXPECTED;
         break;
      }

      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);

      if (!node)
      {
         ASSERT(false);

         hr = E_UNEXPECTED;
         break;
      }

      // the data object is ours, and should be the root node.  The page
      // we will provide is the computer chooser.

      ASSERT(dynamic_cast<RootNode*>(node));
   }
   while (0);

   return hr;
}



HRESULT __stdcall
ComponentData::GetClassID(CLSID* pClassID)
{
   LOG_FUNCTION(ComponentData::GetClassID);
   ASSERT(pClassID);

   *pClassID = CLSID_ComponentData;
   return S_OK;
}



HRESULT __stdcall
ComponentData::IsDirty()
{
   LOG_FUNCTION(ComponentData::IsDirty);

   return isDirty ? S_OK : S_FALSE;
}



String
GetComputerOverride(const String& defaultValue)
{
   LOG_FUNCTION(GetComputerOverride);

   static const String COMMAND(L"/Computer");
   static const size_t COMMAND_LEN = COMMAND.length();
   static const String LOCAL(L"LocalMachine");

   String result = defaultValue;
   StringList args;
   Win::GetCommandLineArgs(std::back_inserter(args));

   // locate the override command arg

   String override;
   for (
      StringList::iterator i = args.begin();
      i != args.end();
      i++)
   {
      String prefix = i->substr(0, COMMAND_LEN);
      if (prefix.icompare(COMMAND) == 0)
      {
         override = *i;
         break;
      }
   }

   if (!override.empty())
   {
      // the command is in the form "/Computer=<machine>", where "<machine>"
      // may be "LocalMachine" for the local machine, or the name of a
      // particular computer.

      // +1 to skip any delimiter between /computer and the machine name

      String machine = override.substr(COMMAND_LEN + 1);
      if (!machine.empty() && (machine.icompare(LOCAL) != 0))
      {
         result = Computer::RemoveLeadingBackslashes(machine);
      }
   }

   LOG(result);
   
   return result;
}



HRESULT
VerifyRead(IStream* stream, void* buf, ULONG bytesToRead)
{
   ASSERT(stream);
   ASSERT(buf);
   ASSERT(bytesToRead);
   
   ULONG bytesRead = 0;
   HRESULT hr = stream->Read(buf, bytesToRead, &bytesRead);
   if (SUCCEEDED(hr))
   {
      ASSERT(bytesRead == bytesToRead);
   }

   return hr;
}



HRESULT __stdcall
ComponentData::Load(IStream* stream)
{
   LOG_FUNCTION(ComponentData::Load);
   ASSERT(stream);

   HRESULT hr = S_OK;
   String computerName;
   unsigned flags = 0;

   do
   {
      if (!stream)
      {
         hr = E_POINTER;
         break;
      }
      
      // version tag

      unsigned version = 0;
      ASSERT(sizeof VERSION_TAG == sizeof version);

      hr = VerifyRead(stream, &version, sizeof version);
      BREAK_ON_FAILED_HRESULT(hr);

      if (version != VERSION_TAG)
      {
         // make a big fuss about mismatched versions

         hr =
            console->MessageBox(
               String::format(
                  IDS_VERSION_MISMATCH,
                  version,
                  VERSION_TAG).c_str(),
               String::load(IDS_VERSION_MISMATCH_TITLE).c_str(),
               MB_OK | MB_ICONERROR | MB_TASKMODAL,
               0);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // flags

      ASSERT(sizeof(flags) == 4);
            
      hr = VerifyRead(stream, &flags, sizeof flags);
      BREAK_ON_FAILED_HRESULT(hr);

      // computer name; we read this regardless of the override flag to
      // ensure that we consume all of our stream data. (I don't know that
      // this is required, but it seems courteous.)

      // make sure we use an int type that's 4 bytes on all platforms.
      // (i.e. not size_t)
      // NTRAID#NTBUG9-499631-2001/11/27-sburns
      
      unsigned len = 0;
      ASSERT(sizeof(len) == 4);
      
      hr = VerifyRead(stream, &len, sizeof len);
      BREAK_ON_FAILED_HRESULT(hr);

      if (len > DNS_MAX_NAME_LENGTH)
      {
         LOG(L"corrupt length of computer name field");
         hr = E_UNEXPECTED;
         break;
      }
      
      if (len)
      {
         ASSERT(len <= DNS_MAX_NAME_LENGTH);
         
         computerName.resize(len);
         hr =
            VerifyRead(
               stream,
               const_cast<wchar_t*>(computerName.c_str()),
               static_cast<ULONG>(len * sizeof(wchar_t)) );
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // null terminator

      wchar_t t = 0;
      ASSERT(sizeof(t) == 2);
      
      hr = VerifyRead(stream, &t, sizeof t);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(t == 0);
   }
   while (0);

   if (SUCCEEDED(hr))
   {
      canOverrideComputer = flags & CAN_OVERRIDE_MACHINE_FLAG;

      if (canOverrideComputer)
      {
         computerName = GetComputerOverride(computerName);
         isDirty = true;
      }
   }

   // not specified, LocalMachine, or fouled up in some fashion, results in
   // focus on the local machine.

   if (computerName.empty() || FAILED(hr))
   {
      computerName = Win::GetComputerNameEx(ComputerNameNetBIOS);
   }

   SetComputerNames(computerName);

   // evaluate this in case the machine is now a DC.
   
   EvaluateBrokenness();

   return hr;
}



HRESULT
VerifyWrite(IStream* stream, void* buf, ULONG bytesToWrite)
{
   ASSERT(stream);
   ASSERT(buf);
   ASSERT(bytesToWrite);
   
   ULONG bytesWritten = 0;
   HRESULT hr = stream->Write(buf, bytesToWrite, &bytesWritten);
   if (SUCCEEDED(hr))
   {
      ASSERT(bytesWritten == bytesToWrite);
   }

   return hr;
}



HRESULT __stdcall
ComponentData::Save(IStream* stream, BOOL clearDirty)
{
   LOG_FUNCTION(ComponentData::Save);
   ASSERT(stream);

   HRESULT hr = S_OK;
   do
   {
      // version tag

      unsigned version = VERSION_TAG;
      ASSERT(sizeof VERSION_TAG == sizeof version);

      hr = VerifyWrite(stream, &version, sizeof version);
      BREAK_ON_FAILED_HRESULT(hr);

      // flags

      unsigned flags = 0;
      ASSERT(sizeof(flags) == 4);
      
      if (canOverrideComputer)
      {
         flags |= CAN_OVERRIDE_MACHINE_FLAG;
      }

      hr = VerifyWrite(stream, &flags, sizeof flags);
      BREAK_ON_FAILED_HRESULT(hr);

      // computer name

      // make sure we use an int type that's 4 bytes on all platforms.
      // (i.e. not size_t)
      // NTRAID#NTBUG9-499631-2001/11/27-sburns

      unsigned len = (unsigned) GetDisplayComputerName().length();
      ASSERT(sizeof(len) == 4);
      ASSERT(len <= DNS_MAX_NAME_LENGTH);

      if (len > DNS_MAX_NAME_LENGTH)
      {
         len = DNS_MAX_NAME_LENGTH;
      }

      hr = VerifyWrite(stream, &len, sizeof len);
      BREAK_ON_FAILED_HRESULT(hr);

      if (len)
      {
         hr =
            VerifyWrite(
               stream,
               (void*) GetDisplayComputerName().c_str(),
               static_cast<ULONG>(len * sizeof wchar_t) );
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // null terminator

      wchar_t t = 0;
      ASSERT(sizeof(t) == 2);
      
      hr = VerifyWrite(stream, &t, sizeof t);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (clearDirty)
   {
      isDirty = false;
   }
   
   return hr;
}



HRESULT __stdcall
ComponentData::GetSizeMax(ULARGE_INTEGER* size)
{
   LOG_FUNCTION(ComponentData::GetSizeMax);

   size->HighPart = 0;
   size->LowPart =
         sizeof(unsigned)  // version number
      +  sizeof(unsigned)  // flags
      +  sizeof(unsigned)  // computer name length, incl null terminator

         // +1 just to add a bit of slop for null termination ambiguity
         // (whether we write a null within the max length, or 1 outside the
         // max length, we're covered)
                  
      +  sizeof(wchar_t) * (DNS_MAX_NAME_LENGTH + 1);

   return S_OK;
}



String
ComponentData::GetInternalComputerName() const
{
   if (internalComputerName.empty())
   {
      return Win::GetComputerNameEx(ComputerNameNetBIOS);
   }

   return internalComputerName;
}



String
ComponentData::GetDisplayComputerName() const
{
   if (displayComputerName.empty())
   {
      // CODEWORK: should use fully-qualified DNS if tcp/ip present

      return Win::GetComputerNameEx(ComputerNameNetBIOS);
   }

   return displayComputerName;
}



bool
ComponentData::CanOverrideComputer() const
{
   return canOverrideComputer;
}



HWND
ComponentData::GetMainWindow() const
{
   LOG_FUNCTION(ComponentData::GetMainWindow);

   if (console)
   {
      HWND w = 0;
      HRESULT hr = console->GetMainWindow(&w);
      ASSERT(SUCCEEDED(hr));
      return w;
   }

   ASSERT(false);
   return 0;
}



SmartInterface<IConsole2>
ComponentData::GetConsole() const
{
   LOG_FUNCTION(ComponentData::GetConsole);

   return console;
}



Node*
ComponentData::GetInstanceFromCookie(MMC_COOKIE cookie)
{
//   LOG_FUNCTION(ComponentData::GetInstanceFromCookie);

   if (cookie == 0)
   {
      // null cookie => the root node of the owner, which had better be set
      // by now
      ASSERT(rootNode);
      return rootNode;
   }
   else if (IS_SPECIAL_COOKIE(cookie))
   {
      ASSERT(false);
      return 0;
   }

   return reinterpret_cast<Node*>(cookie);
}



bool
ComponentData::IsExtension() const
{
   // set in DoExpand
   return isExtension;
}



HRESULT __stdcall
ComponentData::GetHelpTopic(LPOLESTR* compiledHelpFilename)
{
   LOG_FUNCTION(ComponentData::GetHelpTopic);
   ASSERT(compiledHelpFilename);

   if (!compiledHelpFilename)
   {
      return E_POINTER;
   }

   String help =
      Win::GetSystemWindowsDirectory() + String::load(IDS_HTMLHELP_NAME);
   return help.as_OLESTR(*compiledHelpFilename);
}



HRESULT __stdcall
ComponentData::EnableAllExtensions()
{
   LOG_FUNCTION(ComponentData::EnableAllExtensions);

   // we don't want all extensions; just the RAS one.
   return S_FALSE;
}



HRESULT __stdcall
ComponentData::GetFirstExtension(LPCLSID extensionCLSID)
{
   LOG_FUNCTION(ComponentData::GetFirstExtension);

   // Now why do you suppose the MMC folks couldn't express this iteration
   // with just the GetNext function?

   static const CLSID RAS_EXTENSION_CLSID =
   { /* B52C1E50-1DD2-11D1-BC43-00C04FC31FD3 */
      0xB52C1E50,
      0x1DD2,
      0x11D1,
      {0xBC, 0x43, 0x00, 0xc0, 0x4F, 0xC3, 0x1F, 0xD3}
   };

   // REVIEWED-2002/03/01-sburns correct byte count passed.
   
   ::CopyMemory(extensionCLSID, &RAS_EXTENSION_CLSID, sizeof CLSID);
   return S_OK;
}




HRESULT __stdcall
ComponentData::GetNextExtension(LPCLSID extensionCLSID)
{
   LOG_FUNCTION(ComponentData::GetNextExtension);

   // no additional required extensions beyond the first.

   // REVIEWED-2002/03/01-sburns correct byte count passed
   
   ::ZeroMemory(extensionCLSID, sizeof CLSID);
   return S_FALSE;
}



bool
ComponentData::IsBroken() const
{
   LOG_FUNCTION(ComponentData::IsBroken);

   return isBroken;
}



String
ComponentData::GetBrokenErrorMessage() const
{
   LOG_FUNCTION2(ComponentData::GetBrokenErrorMessage, brokenErrorMessage);
   ASSERT(IsBroken());

   return brokenErrorMessage;
}



void
ComponentData::EvaluateBrokenness()
{
   LOG_FUNCTION(ComponentData::EvaluateBrokenness);

   isBroken           = false;
   isHomeEditionSku   = false;
   isDomainController = false;

   // bind to the computer to verify its accessibility
   
   HRESULT hr = S_OK;

   String internalName = GetInternalComputerName();
   Computer c(internalName);
   do
   {
      // Check that the machine is Windows NT-based 24644
      // and not Windows Home Edition NTRAID#NTBUG9-145309 NTRAID#NTBUG9-145288

      unsigned errorResId = 0;
      hr = CheckComputerOsIsSupported(internalName, errorResId);
      BREAK_ON_FAILED_HRESULT(hr);

      if (hr == S_FALSE)
      {
         isBroken = true;
         brokenErrorMessage =
            String::format(
               errorResId,
               GetDisplayComputerName().c_str());
         isBrokenEvaluated = true;

         if (errorResId == IDS_MACHINE_IS_HOME_EDITION_LOCAL)
         {
            isHomeEditionSku = true;
         }
         
         return;
      }

      // CODEWORK?? should we hold on to the bound computer object
      // to make sure we can access the machine for the life of this
      // session?

      hr = ADSI::IsComputerAccessible(internalName);
      BREAK_ON_FAILED_HRESULT(hr);

      // 340379

      hr = c.Refresh();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      isBroken = true;
      brokenErrorMessage =
         String::format(
            IDS_CANT_ACCESS_MACHINE,
            GetDisplayComputerName().c_str(),
            GetErrorMessage(hr).c_str());
   }
   else if (c.IsDomainController())
   {
      isBroken = true;
      isDomainController = true;
      brokenErrorMessage =
         String::format(
               IsExtension()
            ?  IDS_ERROR_DC_NOT_SUPPORTED_EXT
            :  IDS_ERROR_DC_NOT_SUPPORTED,
            GetDisplayComputerName().c_str());
   }

   isBrokenEvaluated = true;
}



HRESULT
ComponentData::SetRootErrorIcon(HSCOPEITEM scopeID)
{
   LOG_FUNCTION(ComponentData::SetRootErrorIcon);
   ASSERT(nameSpace);

   HRESULT hr = E_FAIL;
   
   if (nameSpace)
   {
      SCOPEDATAITEM item;

      // REVIEWED-2002/03/01-sburns correct byte count passed
      
      ::ZeroMemory(&item, sizeof item);

      item.mask =
            SDI_IMAGE
         |  SDI_OPENIMAGE;

      item.nImage     = ROOT_ERROR_INDEX;
      item.nOpenImage = ROOT_ERROR_INDEX;
      item.ID         = scopeID;         

      hr = nameSpace->SetItem(&item);
   }

   return hr;
}



void
ComponentData::SetComputerNames(const String& newName)
{
   LOG_FUNCTION2(ComponentData::SetComputerNames, newName);

   ::SetComputerNames(newName, displayComputerName, internalComputerName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\compdata.hpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// Local Security MMC Snapin
//
// 8-12-97 sburns



#ifndef COMPDATA_HPP_INCLUDED
#define COMPDATA_HPP_INCLUDED



class Node;
class RootNode;



#include "NodePointerExtractor.hpp"



// class ComponentData implements IComponentData: there is one instance of
// this class for each time the snapin is loaded in a console.

class ComponentData
   :
   public IComponentData,
   public IExtendContextMenu,
   public IExtendPropertySheet,
   public IPersistStream,
   public ISnapinHelp,
   public IRequiredExtensions
{
   // this is the only entity with access to the ctor of this class
   friend class ClassFactory<ComponentData>; 

   public:

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IComponentData overrides

   virtual
   HRESULT __stdcall
   CreateComponent(IComponent** ppComponent);

   virtual
   HRESULT __stdcall 
   CompareObjects(IDataObject* dataObjectA, IDataObject* dataObjectB);

   virtual
   HRESULT __stdcall 
   Destroy();

   virtual
   HRESULT __stdcall 
   GetDisplayInfo(SCOPEDATAITEM* item);

   virtual
   HRESULT __stdcall
   Initialize(IUnknown* consoleIUnknown);

   virtual
   HRESULT __stdcall 
   Notify(
      IDataObject*      dataObject,  
      MMC_NOTIFY_TYPE   event, 
      LPARAM            arg,  
      LPARAM            param);

   virtual
   HRESULT __stdcall 
   QueryDataObject( 
      MMC_COOKIE        cookie,  
      DATA_OBJECT_TYPES type,
      IDataObject**     ppDataObject);

   // IExtendContextMenu overrides

   virtual
   HRESULT __stdcall
   AddMenuItems(
      IDataObject*            dataObject,
      IContextMenuCallback*   callback,
      long*                   insertionAllowed);
    
   virtual
   HRESULT __stdcall
   Command(long commandID, IDataObject* dataObject);

   // IExtendPropertySheet overrides

   virtual
   HRESULT __stdcall
   CreatePropertyPages(
      IPropertySheetCallback* callback,
      LONG_PTR                handle,
      IDataObject*            dataObject);

   virtual
   HRESULT __stdcall
   QueryPagesFor(IDataObject* dataObject);

   // IPersist overrides

   virtual
   HRESULT __stdcall
   GetClassID(CLSID* pClassID);

   // IPersistStream overrides

   virtual
   HRESULT __stdcall
   IsDirty();

   virtual
   HRESULT __stdcall
   Load(IStream* stream);

   virtual
   HRESULT __stdcall
   Save(IStream* stream, BOOL /* clearDirty */);

   virtual
   HRESULT __stdcall
   GetSizeMax(ULARGE_INTEGER* size);

   // ISnapinHelp overrides

   virtual
   HRESULT __stdcall
   GetHelpTopic(LPOLESTR* compiledHelpFilename);

   // IRequiredExtensions overrides

   virtual
   HRESULT __stdcall
   EnableAllExtensions();

   virtual
   HRESULT __stdcall
   GetFirstExtension(LPCLSID extensionCLSID);

   virtual
   HRESULT __stdcall
   GetNextExtension(LPCLSID extensionCLSID);

   // ComponentData methods
   
   bool
   CanOverrideComputer() const;

   HRESULT
   LoadImages(IImageList& imageList);

   String
   GetInternalComputerName() const;

   String
   GetDisplayComputerName() const;

   SmartInterface<IConsole2>
   GetConsole() const;

   // Maps a MMC cookie to a Node instance.  Handles the special 0 cookie by
   // returning an instance set to be the root Node.  As Nodes are cookies,
   // this is simply a cast.
   //
   // cookie - MMC cookie to be mapped.

   Node*
   GetInstanceFromCookie(MMC_COOKIE cookie);

   HWND
   GetMainWindow() const;

   // true if the snapin is operating as an extension to another snapin
   // (namely, Computer Management)
   bool
   IsExtension() const;

   // true if the snapin is not working because the target machine is a
   // DC, or is not reachable, etc.
   
   bool
   IsBroken() const;

   String
   GetBrokenErrorMessage() const;

   private:

   // only our friend class factory can instantiate us.
   ComponentData();

   // only Release can cause us to be deleted
   ~ComponentData();

   HRESULT
   DoExpand(IDataObject& dataObject, bool expanding, HSCOPEITEM scopeID);

   HRESULT
   DoPreload(IDataObject& dataObject, HSCOPEITEM rootNodeScopeID);

   HRESULT
   DoRemoveChildren(IDataObject& dataObject, HSCOPEITEM parentScopeID);
      
   void
   EvaluateBrokenness();

   void
   SetComputerNames(const String& newName);

   HRESULT
   SetRootErrorIcon(HSCOPEITEM scopeID);

   // not implemented; no instance copying allowed.
   ComponentData(const ComponentData&);
   const ComponentData& operator=(const ComponentData&);

   String                             brokenErrorMessage;
   bool                               canOverrideComputer;
   bool                               isExtension;         
   bool                               isBroken;
   bool                               isBrokenEvaluated;
   bool                               isDirty;
   bool                               isDomainController;
   bool                               isHomeEditionSku;
   mutable String                     displayComputerName;
   mutable String                     internalComputerName;
   SmartInterface<IConsole2>          console;              
   SmartInterface<IConsoleNameSpace2> nameSpace;           
   SmartInterface<RootNode>           rootNode;
   ComServerReference                 dllref;               
   long                               refcount;



   // class NodeTypeExtractor implements methods used to extract a node type
   // from the CCF_NODETYPE clipboard format.

   class NodeTypeExtractor : public Extractor
   {
      public:

      NodeTypeExtractor()
         :
         Extractor(
            Win::RegisterClipboardFormat(CCF_NODETYPE),
            sizeof(NodeType))
      {
      }

      virtual
      ~NodeTypeExtractor()            
      {
      }
      
      NodeType
      Extract(IDataObject& dataObject)
      {
         HGLOBAL buf = ExtractData(dataObject);
         if (buf)
         {
            NodeType* ntp = reinterpret_cast<NodeType*>(buf);
            return *ntp;
         }

         return NodeType();
      }

      private:

      // not defined: no copying allowed

      NodeTypeExtractor(const NodeTypeExtractor&);
      const NodeTypeExtractor& operator=(const NodeTypeExtractor&);
   }

   // our instance:

   nodeTypeExtractor;



   // class MachineNameExtractor implements methods used to extract a node type
   // from the CCF_NODETYPE clipboard format.

   class MachineNameExtractor : public Extractor
   {
      public:

      MachineNameExtractor()
         :
         Extractor(
            Win::RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME"),

            // lots of space here to support machine names in any number
            // of formats
            (MAX_PATH + 1) * sizeof(wchar_t))
      {
      }

      virtual
      ~MachineNameExtractor()
      {
      }
      
      String
      Extract(IDataObject& dataObject)
      {
         HGLOBAL buf = ExtractData(dataObject);
         if (buf)
         {
            TCHAR* p = reinterpret_cast<TCHAR*>(buf);

            // skip leading whacks
            while (*p == L'\\')
            {
               ++p;
            }

            String result(p);
            if (result.empty())
            {
               // use the local machine

               result = Win::GetComputerNameEx(ComputerNameNetBIOS);
            }

            return result;
         }

         return String();
      }

      private:

      // not defined: no copying allowed

      MachineNameExtractor(const MachineNameExtractor&);
      const MachineNameExtractor& operator=(const MachineNameExtractor&);
   }

   // our instance:

   machineNameExtractor;



   NodePointerExtractor nodePointerExtractor;
};



#endif   // COMPDATA_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\creategroupdialog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateGroupDialog class
// 
// 10-15-97 sburns



#include "headers.hxx"
#include "CreateGroupDialog.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"
#include "MembershipListView.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_NAME,                     idh_creategroup_name,
   IDC_DESCRIPTION,              idh_creategroup_description,
   IDC_MEMBERS,                  idh_creategroup_members,
   IDC_ADD,                      idh_creategroup_addbutton,
   IDC_REMOVE,                   idh_creategroup_removebutton,
   IDC_CREATE,                   idh_creategroup_createbutton,
   IDCANCEL,                     idh_creategroup_closebutton,
   0, 0
};



CreateGroupDialog::CreateGroupDialog(const String& machine_)
   :
   Dialog(IDD_CREATE_GROUP, HELP_MAP),
   listview(0),
   machine(machine_),
   refresh_on_exit(false)
{
   LOG_CTOR(CreateGroupDialog);
   ASSERT(!machine.empty());      
}
      


CreateGroupDialog::~CreateGroupDialog()
{
   LOG_DTOR(CreateGroupDialog);
}



void
CreateGroupDialog::OnDestroy()
{
   LOG_FUNCTION(CreateGroupDialog::OnDestroy);
   
   delete listview;
   listview = 0;
}



void
CreateGroupDialog::Enable()
{
//    LOG_FUNCTION(CreateGroupDialog::Enable);

   bool enable_create_button =
      !Win::GetTrimmedDlgItemText(hwnd, IDC_NAME).empty();
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_CREATE),
      enable_create_button);

   bool selected =
      Win::ListView_GetSelectedCount(
         Win::GetDlgItem(hwnd, IDC_MEMBERS)) > 0;

   HWND removeButton = Win::GetDlgItem(hwnd, IDC_REMOVE);
   
   if (!selected)
   {
      // If we're about to disable the remove button, check to see if it
      // has focus first.  If it does, we need to move focus to another
      // control.  Similarly for default pushbutton style.
      // NTRAID#NTBUG9-435045-2001/07/13-sburns

      if (removeButton == ::GetFocus())
      {
         HWND addButton = Win::GetDlgItem(hwnd, IDC_ADD);
         Win::SetFocus(addButton);
         Win::Button_SetStyle(addButton, BS_DEFPUSHBUTTON, true);
         Win::Button_SetStyle(removeButton, BS_PUSHBUTTON, true);
      }
   }

   Win::EnableWindow(removeButton, selected);

}



void
CreateGroupDialog::Reset()
{
   LOG_FUNCTION(CreateGroupDialog::Reset);

   static const String blank;
   Win::SetDlgItemText(hwnd, IDC_NAME, blank);
   Win::SetDlgItemText(hwnd, IDC_DESCRIPTION, blank);
   Win::SetFocus(Win::GetDlgItem(hwnd, IDC_NAME));

   listview->ClearContents();

   Enable();
}
 


void
CreateGroupDialog::OnInit()
{
   LOG_FUNCTION(CreateGroupDialog::OnInit());

   listview =
      new MembershipListView(
         Win::GetDlgItem(hwnd, IDC_MEMBERS),
         machine,
         MembershipListView::GROUP_MEMBERSHIP);
   
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_NAME), GNLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);

   Reset();
}



bool
CreateGroupDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(CreateGroupDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_NAME:
      {
         if (code == EN_CHANGE)
         {
            Enable();

            // In case the close button took the default style when the create
            // button was disabled. (e.g. tab to close button while create is
            // disabled, then type in the name field, which enables the
            // button, but does not restore the default style unless we do
            // it ourselves)

            Win::Button_SetStyle(
               Win::GetDlgItem(hwnd, IDC_CREATE),
               BS_DEFPUSHBUTTON,
               true);
         }
         break;
      }
      case IDC_CREATE:
      {
         if (code == BN_CLICKED)
         {
            if (CreateGroup())
            {
               refresh_on_exit = true;               
               Reset();
            }
            else
            {
               Win::SetFocus(Win::GetDlgItem(hwnd, IDC_NAME));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         HRESULT unused = Win::EndDialog(hwnd, refresh_on_exit);

         ASSERT(SUCCEEDED(unused));

         break;
      }
      case IDC_ADD:
      {
         if (code == BN_CLICKED)
         {
            listview->OnAddButton();
         }
         break;
      }
      case IDC_REMOVE:
      {
         if (code == BN_CLICKED)
         {
            listview->OnRemoveButton();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}



static
HRESULT
SaveGroupProperties(
   const SmartInterface<IADsGroup>& group,
   const String*                    description,
   const MemberList*                membership)
{
   HRESULT hr = S_OK;
   do
   {
      if (description)
      {
         hr = group->put_Description(AutoBstr(*description));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (membership)
      {
         for (
            MemberList::iterator i = membership->begin();
            i != membership->end();
            i++)
         {
            MemberInfo& info = *i;

            // not found.  Add the node as a member of the group

            hr = group->Add(AutoBstr(info.path));
            BREAK_ON_FAILED_HRESULT(hr);
         }
         if (FAILED(hr))
         {
            break;
         }
      }

      // commit the property changes

      hr = group->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
CreateGroupDialog::CreateGroup()
{
   LOG_FUNCTION(CreateGroupDialog::CreateGroup);

   Win::CursorSetting cursor(IDC_WAIT);

   HRESULT hr = S_OK;

   String name = Win::GetTrimmedDlgItemText(hwnd, IDC_NAME);
   String desc = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);

   // shouldn't be able to poke the Create button if this is empty

   ASSERT(!name.empty());

   if (!ValidateSAMName(hwnd, name, IDC_NAME))
   {
      return false;
   }

   SmartInterface<IADsGroup> group(0);
   do
   {
      // get a pointer to the machine container

      String path = ADSI::ComposeMachineContainerPath(machine);
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(path, container);
      BREAK_ON_FAILED_HRESULT(hr);

      // create a group object in that container

      hr = ADSI::CreateGroup(container, name, group);
      BREAK_ON_FAILED_HRESULT(hr);

      // commit the create

      hr = group->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_CREATING_GROUP,
            name.c_str(),
            machine.c_str()));
      return false;      
   }

   do
   {
      // these must be written after the commit

      MemberList new_members;
      listview->GetContents(new_members);

      hr =
         SaveGroupProperties(
            group, 
            desc.empty() ? 0 : &desc,
            new_members.empty() ? 0 : &new_members);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_GROUP_PROPERTIES,
            name.c_str(),
            machine.c_str()));
      return false;
   }

   return true;
}



bool
CreateGroupDialog::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lparam)
{
   LOG_FUNCTION(CreateGroupDialog::OnNotify);

   switch (controlIDFrom)
   {
      case IDC_MEMBERS:
      {
         switch (code)
         {
            case LVN_ITEMCHANGED:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lparam);
                  if (lv->uChanged & LVIF_STATE)
                  {
                     // a list item changed state

                     Enable();
                  }
               }
               break;
            }
            case LVN_KEYDOWN:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLVKEYDOWN* kd = reinterpret_cast<NMLVKEYDOWN*>(lparam);
                  if (kd->wVKey == VK_INSERT)
                  {
                     listview->OnAddButton();
                  }
                  else if (kd->wVKey == VK_DELETE)
                  {
                     listview->OnRemoveButton();
                  }
               }
               break;
            }
            case LVN_INSERTITEM:
            case LVN_DELETEITEM:
            {
               break;
            }
            default:
            {
               break;
            }
         }
         break;
      }
      default:
      {
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\dlgcomm.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Shared Dialog code
// 
// 10-24-97 sburns



#include "headers.hxx"
#include "dlgcomm.hpp"
#include "adsi.hpp"
#include "resource.h"



bool
IsValidPassword(
   HWND  dialog,
   int   passwordResID,
   int   confirmResID)
{
   LOG_FUNCTION(IsValidPassword);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(passwordResID);
   ASSERT(confirmResID);

   EncryptedString password =
      Win::GetEncryptedDlgItemText(dialog, passwordResID);
   EncryptedString confirm  =
      Win::GetEncryptedDlgItemText(dialog, confirmResID); 

   if (password != confirm)
   {
      Win::SetDlgItemText(dialog, passwordResID, String());
      Win::SetDlgItemText(dialog, confirmResID, String());
      popup.Gripe(dialog, passwordResID, IDS_PASSWORD_MISMATCH);
      return false;
   }

   return true;
}
   


void
DoUserButtonEnabling(
   HWND  dialog,
   int   mustChangeResID,
   int   cantChangeResID,
   int   neverExpiresResID)
{
   LOG_FUNCTION(DoUserButtonEnabling);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(mustChangeResID);
   ASSERT(cantChangeResID);
   ASSERT(neverExpiresResID);

   static const int MUST_ENABLED  = 0x4;
   static const int CANT_ENABLED  = 0x2;
   static const int NEVER_ENABLED = 0x1;
   
   static const int truthTable[] =
   {
      MUST_ENABLED | CANT_ENABLED | NEVER_ENABLED, // none checked
      0            | CANT_ENABLED | NEVER_ENABLED, // never checked
      0            | CANT_ENABLED | NEVER_ENABLED, // cant checked
      0            | CANT_ENABLED | NEVER_ENABLED, // cant and never 
      MUST_ENABLED | 0            | 0,             // must checked   
      MUST_ENABLED | 0            | 0,             // must and never
      MUST_ENABLED | CANT_ENABLED | 0,             // must and cant
      MUST_ENABLED | CANT_ENABLED | 0              // all checked
   };
      
   int truthTableIndex = 0;
   truthTableIndex |= (NEVER_ENABLED * Win::IsDlgButtonChecked(dialog, neverExpiresResID));
   truthTableIndex |= (CANT_ENABLED  * Win::IsDlgButtonChecked(dialog, cantChangeResID));      
   truthTableIndex |= (MUST_ENABLED  * Win::IsDlgButtonChecked(dialog, mustChangeResID));
   
   Win::EnableWindow(
      Win::GetDlgItem(dialog, mustChangeResID),
      (truthTable[truthTableIndex] & MUST_ENABLED) ? true : false);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, cantChangeResID),
      (truthTable[truthTableIndex] & CANT_ENABLED) ? true : false);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, neverExpiresResID),
      (truthTable[truthTableIndex] & NEVER_ENABLED) ? true : false);
}



  
// Sets or clears a bit, or set of bits.
// 
// bits - bit set where bits will be set.
// 
// mask - mask of bits to be effected.
// 
// state - true to set the mask bits, false to clear them.

void
tweakBits(long& bits, long mask, bool state)
{
   ASSERT(mask);

   if (state)
   {
      bits |= mask;
   }
   else
   {
      bits &= ~mask;
   }
}




HRESULT
SaveUserProperties(
   const SmartInterface<IADsUser>&  user,
   const String*                    fullName,
   const String*                    description,
   const bool*                      disable,
   const bool*                      mustChangePassword,
   const bool*                      cannotChangePassword,
   const bool*                      passwordNeverExpires,
   const bool*                      isLocked)
{
   HRESULT hr = S_OK;
   do
   {
      if (fullName)
      {
         hr = user->put_FullName(AutoBstr(*fullName));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (description)
      {
         hr = user->put_Description(AutoBstr(*description));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (mustChangePassword)
      {
         long value = *mustChangePassword ? 1 : 0;
         _variant_t variant(value);
         hr = user->Put(AutoBstr(ADSI::PROPERTY_PasswordExpired), variant);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (disable)
      {
         VARIANT_BOOL value = *disable ? VARIANT_TRUE : VARIANT_FALSE;
         hr = user->put_AccountDisabled(value);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (cannotChangePassword || passwordNeverExpires)
      {
         // read the existing flags
         _variant_t get_variant;
         hr = user->Get(AutoBstr(ADSI::PROPERTY_UserFlags), &get_variant);
         BREAK_ON_FAILED_HRESULT(hr);
         long flags = get_variant;
         
         if (cannotChangePassword)
         {
            tweakBits(flags, UF_PASSWD_CANT_CHANGE, *cannotChangePassword);
         }
         if (passwordNeverExpires)
         {
            tweakBits(flags, UF_DONT_EXPIRE_PASSWD, *passwordNeverExpires);
         }

         _variant_t put_variant(flags);
         hr = user->Put(AutoBstr(ADSI::PROPERTY_UserFlags), put_variant);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (isLocked)
      {
         VARIANT_BOOL value = *isLocked ? VARIANT_TRUE : VARIANT_FALSE;
         hr = user->put_IsAccountLocked(value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // commit the property changes
      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
IsValidSAMName(const String& name)
{
   LOG_FUNCTION2(IsValidSAMName, name);

   static const String ILLEGAL_SAM_CHARS(ILLEGAL_FAT_CHARS L"@");
   
   if (name.find_first_of(ILLEGAL_SAM_CHARS) == String::npos)
   {
      // does not contain bad chars

      // remove all spaces and periods
      String n = name;
      n.replace(L" ", String());
      n.replace(L".", String());
      if (!n.empty())
      {
         // not just spaces & periods
         return true;
      }
   }

   return false;
}



bool
ValidateSAMName(HWND dialog, const String& name, int editResID)
{
   LOG_FUNCTION(ValidateSAMName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(IDS_BAD_SAM_NAME, name.c_str()));
      return false;
   }

   return true;
}



void
SetComputerNames(
   const String&  newName,
   String&        displayComputerName,
   String&        internalComputerName)
{
   LOG_FUNCTION2(SetComputerNames, newName);

   // The idea here is to take the new name, and pass it thru
   // NetWkstaGetInfo, then compare the computer name returned (which is
   // the netbios name) to the newName.  If they are the same, then newName
   // is a netbios name.  If not, then it is a DNS name or IP address.

   // we want to make the internal computer name the netbios name, as that
   // is the name that the ADSI WinNT provider works best with.

   // display name is always the one supplied externally (from the user,
   // from a saved console file, from comp mgmt snapin)

   displayComputerName = newName;

   // initially, the internal name is also the display name.  If the new name
   // is not a netbios name, then we will replace it below.

   internalComputerName = newName;

   WKSTA_INFO_100* info = 0;
   HRESULT hr = MyNetWkstaGetInfo(newName, info);

   if (SUCCEEDED(hr) && info)
   {
      internalComputerName = info->wki100_computername;
      ::NetApiBufferFree(info);
   }

   LOG(
      String::format(
         L"%1 %2 a netbios name.",
         newName.c_str(),
         (newName.icompare(internalComputerName) == 0) ? L"is" : L"is not"));
}



HRESULT
CheckComputerOsIsSupported(const String& name, unsigned& errorResId)
{
   LOG_FUNCTION2(CheckComputerOsIsSupported, name);
   ASSERT(!name.empty());

   HRESULT hr = S_OK;
   errorResId = 0;

   do
   {
      if (Win::IsLocalComputer(name))
      {
         // if this code is running, then by definition it's NT

         // check if machine is Windows Home Edition.  If it is, refer the
         // user to the account management control panel applet.
         
         OSVERSIONINFOEX verInfo;
         hr = Win::GetVersionEx(verInfo);
         BREAK_ON_FAILED_HRESULT(hr);

         if (verInfo.wSuiteMask & VER_SUITE_PERSONAL)
         {
            hr = S_FALSE;
            errorResId = IDS_MACHINE_IS_HOME_EDITION_LOCAL;
         }

         break;
      }

      // Use NetServerGetInfo to find the machine's os & version info.

      String s(name);
      if (s.length() >= 1)
      {
         if (s[0] != L'\\')
         {
            s = L"\\\\" + s;
         }
      }

      LOG(L"Calling NetServerGetInfo");
      LOG(String::format(L"servername : %1", s.c_str()));
      LOG(               L"level      : 101");

      SERVER_INFO_101* info = 0;
      hr =
         Win32ToHresult(
            ::NetServerGetInfo(
               const_cast<wchar_t*>(s.c_str()),
               101,
               reinterpret_cast<BYTE**>(&info)));

      LOG_HRESULT(hr);

      if (SUCCEEDED(hr) && info)
      {
         LOG(String::format(L"sv101_platform_id   : %1!d!",    info->sv101_platform_id));
         LOG(String::format(L"sv101_name          : %1",       info->sv101_name));
         LOG(String::format(L"sv101_version_major : %1!d!",    info->sv101_version_major));
         LOG(String::format(L"sv101_version_minor : %1!d!",    info->sv101_version_minor));
         LOG(String::format(L"sv101_type          : 0x%1!X!",  info->sv101_type));
         LOG(String::format(L"sv101_comment       : %1",       info->sv101_comment));

         if (info->sv101_platform_id != PLATFORM_ID_NT)
         {
            hr = S_FALSE;
            errorResId = IDS_MACHINE_NOT_NT;
         }

         ::NetApiBufferFree(info);

         // at this point, the machine has been verified to be running NT

         // We don't need to check for Windows Home Edition on the remote machine.
         // The call to NetServerGetInfo will always fail against Home
         // Edition machines with access denied.  From johnhaw (2000/08/08):
         // "This is as designed, remote Admin of personal machines is not
         // allowed.  Any attempt to access a personal machine (regardless of
         // the username supplied) is transparently forced to Guest."
      }
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\fpnw.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Random fpnw code
// 
// 10-28-98 sburns



#ifndef FPNW_HPP_INCLUDED
#define FPNW_HPP_INCLUDED



class WasteExtractor;



namespace FPNW
{
   // locate the the File & Print for NetWare LSA secret, return S_OK.
   //
   // machine - machine on which the FPNW service is installed
   //
   // result - the secret, if S_OK is returned.

   HRESULT
   GetLSASecret(const String& machine, String& result);

   HRESULT
   GetObjectIDs(
      const SmartInterface<IADsUser>&  user,
      const SafeDLL&                   clientDLL,
      DWORD&                           objectID,
      DWORD&                           swappedObjectID);

   HRESULT
   SetPassword(
      WasteExtractor&        dump,
      const SafeDLL&         clientDLL,   
      const EncryptedString& newPassword, 
      const String&          lsaSecretKey,
      DWORD                  objectID);
};



#endif   // FPNW_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\dlgcomm.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Shared Dialog code
// 
// 10-24-97 sburns



#ifndef DLGCOMM_HPP_INCLUDED
#define DLGCOMM_HPP_INCLUDED



// Return S_OK if the machine is NT or an NT derivate that is not Windows
// Home Edition (e.g. is Professional, or one of the Server variants).  Returns
// S_FALSE if the machine was contacted and it is not running an NT-based OS
// (like Windows 9X), or it is running Home Edition.  Returns an error
// code code if the machine could not be contacted, or the evaluation failed.
// 
// name - IN name of the computer to check
// 
// errorResId - OUT error message resource identifier indicating what kind of
// machine the computer is (non-NT, home edition)

HRESULT
CheckComputerOsIsSupported(const String& name, unsigned& errorResId);



// Enable/disable the check boxes for the correct allowable combinations,
// based on the current state of theose boxes. Called from UserGeneralPage and
// CreateUserDialog.
// 
// dialog - HWND of the parent window of the controls.
// 
// mustChangeResID - resource ID of the "Must change password at next login"
// checkbox.
// 
// cantChangeResID - resource ID of the "Can't change password" checkbox.
// 
// neverExpiresResID - resource ID of the "password Never Expires" checkbox.

void
DoUserButtonEnabling(
   HWND  dialog,
   int   mustChangeResID,
   int   cantChangeResID,
   int   neverExpiresResID);



// Verifies that the contents of the two password edit boxes match, clearing
// them, griping, and setting input focuse to the first edit box if they
// don't.  Returns true if the passwords match, false if not.
// 
// dialog - parent window of the edit box controls.
// 
// passwordResID - resource ID of the "Password" edit box.
// 
// confirmResID - resource ID of the "Confirm Password" edit box.

bool
IsValidPassword(
   HWND  dialog,
   int   passwordResID,
   int   confirmResID);


// Puts new values for various user properties, then commits the result.  If
// any of the parameters is 0, then the corresponding property is unchanged.
// If any change fails, the commit is not performed and the function
// immediately returns.
// 
// user - smart pointer bound to the ADSI user to be changed.
// 
// fullName - ptr to the new value of the FullName property.
// 
// description - ptr to the new value of the Description property.
// 
// disable - ptr to flag whether the account is disabled or not.
// 
// mustChangePassword - ptr to flag indicating whether or not the user must
// change the password at next login.
// 
// cannotChangePassword - ptr to flag indicating the user cannot change the
// password.
// 
// passwordNeverExpires - ptr to flag indicating that the password never
// expires.
// 
// isLocked - ptr to flag indicating to clear the account lock, if it is
// locked.

HRESULT
SaveUserProperties(
   const SmartInterface<IADsUser>&  user,
   const String*                    fullName,
   const String*                    description,
   const bool*                      disable,
   const bool*                      mustChangePassword,
   const bool*                      cannotChangePassword,
   const bool*                      passwordNeverExpires,
   const bool*                      isLocked);



// Sets the display name and the internal name based on the supplied
// parameter, which may be a DNS or NetBIOS name.  (see ComponentData)

void
SetComputerNames(
   const String&  newName,
   String&        displayComputerName,
   String&        internalComputerName);



bool
IsValidSAMName(const String& name);



bool
ValidateSAMName(HWND dialog, const String& name, int editResID);




#endif   // DLGCOMM_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\foldnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Folder Node class
// 
// 9-29-97 sburns



#ifndef FOLDNODE_HPP_INCLUDED
#define FOLDNODE_HPP_INCLUDED



#include "scopnode.hpp"
#include "resnode.hpp"



class ComponentData;



// Class FolderNode is a ScopeNode that has folder icons, and enables the
// refresh verb.  It is an abstract base class.

class FolderNode : public ScopeNode
{
   public:

   // Node overrides

   String
   GetDisplayName() const;

   String
   GetColumnText(int column);

   // Default implementation returns FOLDER_CLOSED_INDEX.

   virtual 
   int
   GetNormalImageIndex();

   // default implementation enables refresh

   virtual 
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ScopeNode overrides

   // Calls ScopeNode::BuildContextMenu with the MenuItemList supplied to the
   // ctor.

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   // Default implementation returns FOLDER_OPEN_INDEX.

   virtual 
   int
   GetOpenImageIndex();

   // Calls ScopeNode;:BuildResultColumns with the ColumnList supplied to
   // the ctor.
   
   virtual
   HRESULT
   InsertResultColumns(IHeaderCtrl& headerCtrl);

   // Calls the (virtual) BuildResultItems, then inserts each of the items
   // (which are ResultNodes) into the result pane by calling each item's
   // InsertIntoResultPane method.

   virtual
   HRESULT
   InsertResultItems(IResultData& resultData);

   // Default implementation calls ReleaseAllResultItems,
   // then BuildResultItemList

   virtual
   HRESULT
   RebuildResultItems();

   // FolderNode methods

   typedef
      std::vector<ResultColumn, Burnslib::Heap::Allocator<ResultColumn> >
      ColumnList;

   typedef
      std::vector<ContextMenuItem, Burnslib::Heap::Allocator<ContextMenuItem> >
      MenuItemList;

   typedef
      std::list<
         SmartInterface<ResultNode> > // ,
//         Burnslib::Heap::Allocator<SmartInterface<ResultNode> > >
      ResultNodeList;

   int
   GetResultItemCount() const;

   // Derived Classes must implement this method, with populates the items
   // list with those ResultNodes which should appear in the the result pane
   // for this node.  As the list is a list of SmartInterface<ResultNode>, the
   // items will be AddRef'd and Released properly.
   //
   // items - the list to be populated.

   virtual
   void
   BuildResultItems(ResultNodeList& items) = 0;

   protected:

   // Constructs a new instance.  Declared protected to allow this class to
   // only be a base class.
   //
   // owner - supplied to base class constructor
   // 
   // nodeType - NodeType GUID supplied to the base class constructor.
   //
   // displayNameResID - resource ID of a string resource that contains the
   // name of this node to be shown in the scope pane.
   // 
   // typeTitleResID - resource ID of a string resource that contains the type
   // or title of this node to appear in the "Type" column of the details view
   // when this node appears in the result pane (of the parent node).
   // 
   // columns - the result column list for the columns that appear in the
   // details view of the result pane of this node.
   // 
   // menu - the context menu list for this node.

   FolderNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodetype,
      int                                    displayNameResID,
      int                                    typeTitleResID,
      const ColumnList&                      columns,
      const MenuItemList&                    menu);

   virtual ~FolderNode();

   // Causes the console to update all views of this node's result items,
   // calls RebuildResultItems.  Call this method to rebuild the result pane
   // from scratch.

   void
   RefreshView();

   private:

   ResultNodeList items;
   ColumnList     columns;
   MenuItemList   menu;
   String         name;
   String         type_title;

   // not implemented: no copying allowed

   FolderNode(const FolderNode&);
   const FolderNode& operator=(const FolderNode&);
};



#endif   // FOLDNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\dllmain.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Local Security Snapin DLL entry points
// 
// 8-14-97 sburns



#include "headers.hxx"
#include "resource.h"
#include "uuids.hpp"
#include "compdata.hpp"
#include "about.hpp"
#include <compuuid.h>



HINSTANCE hResourceModuleHandle = 0;
HINSTANCE hDLLModuleHandle = 0;
const wchar_t* HELPFILE_NAME = L"\\help\\localsec.hlp";
const wchar_t* RUNTIME_NAME = L"localsec";

// default debug options: none

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



Popup popup(IDS_APP_ERROR_TITLE);



BOOL
APIENTRY
DllMain(
   HINSTANCE   hInstance,
   DWORD       dwReason,
   PVOID       /* lpReserved */ )
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = hInstance;
         hDLLModuleHandle = hInstance;

         LOG(L"DLL_PROCESS_ATTACH");

         break;
      }
      case DLL_PROCESS_DETACH:
      {
         LOG(L"DLL_PROCESS_DETACH");

#ifdef DBG         
         if (!ComServerLockState::CanUnloadNow())
         {
            LOG(
               L"server locks and/or outstanding object instances exit");
         }
         else
         {
            LOG(L"server can unload now.");
         }
#endif

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



static
HKEY
CreateKey(HKEY rootHKEY, const String& key)
{
   LOG_FUNCTION2(CreateKey, key);
   ASSERT(!key.empty());

   HKEY hKey = 0;
   LONG result = 
      Win::RegCreateKeyEx(
         rootHKEY,
         key, 
         REG_OPTION_NON_VOLATILE,
         KEY_WRITE,
         0, 
         hKey,
         0);
   if (result != ERROR_SUCCESS)
   {
      return 0;
   }

   return hKey;
}



static
bool
CreateKeyAndSetValue(
   HKEY           rootHKEY,
   const String&  key,
   const String&  valueName,
   const String&  value)
{
   LOG_FUNCTION2(
      CreateKeyAndSetValue,
      String::format(
         L"key=%1, value name=%2, value=%3",
         key.c_str(),
         valueName.c_str(),
         value.c_str()));
   ASSERT(!key.empty());
   ASSERT(!value.empty());

   bool result = false;
   HKEY hKey = CreateKey(rootHKEY, key);

   do
   {
      if (hKey == 0)
      {
         break;
      }
   
      // ISSUE-2002/03/01-sburns consider using RegistryKey instead, which will
      // free you from worrying about null termination problems.
   
      HRESULT hr =
         Win::RegSetValueEx(
            hKey,
            valueName,
            REG_SZ, 
            (BYTE*) value.c_str(),
            (value.length() + 1) * sizeof(wchar_t));
      if (SUCCEEDED(hr))
      {
         result = true;
      }
   }
   while (0);

   Win::RegCloseKey(hKey);
   
   return result;
}



static
HRESULT
DoSnapinRegistration(const String& classIDString)
{
   LOG_FUNCTION2(DoSnapinRegistration, classIDString);
   static const String SNAPIN_REG_ROOT(L"Software\\Microsoft\\MMC");
  
   String key = SNAPIN_REG_ROOT + L"\\Snapins\\" + classIDString;
   String name = String::load(IDS_SNAPIN_REG_NAMESTRING);

   bool result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
         key,
         L"NameString",
         name);
   if (!result)
   {
      LOG(L"Failure setting snapin NameString");
      return E_FAIL;
   }

   String filename = Win::GetModuleFileName(hDLLModuleHandle);

   String indirectName =
      String::format(
         L"@%1,-%2!d!",
         filename.c_str(),
         IDS_SNAPIN_REG_NAMESTRING);

   result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
         key,
         L"NameStringIndirect",
         indirectName);
   if (!result)
   {
      LOG(L"Failure setting snapin NameStringIndirect");
      return E_FAIL;
   }

   // make the snapin standalone
   HKEY hkey =
      CreateKey(
         HKEY_LOCAL_MACHINE,
         key + L"\\Standalone");
   if (hkey == 0)
   {
      LOG(L"Failure creating snapin standalone key");
      return E_FAIL;
   }

   // indicate the CLSID SnapinAbout
   result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
         key,
         L"About",
         Win::StringFromCLSID(CLSID_SnapinAbout));
   if (!result)
   {
      LOG(L"Failure creating snapin about key");
      return E_FAIL;
   }

   // register all the myriad nodetypes
   String nodekey_base = key + L"\\NodeTypes";
   hkey = CreateKey(HKEY_LOCAL_MACHINE, nodekey_base);
   if (hkey == 0)
   {
      LOG(L"Failure creating snapin nodetypes key");
      return E_FAIL;
   }
   for (int i = 0; nodetypes[i]; ++i)
   {
      hkey =
         CreateKey(
            HKEY_LOCAL_MACHINE,
               nodekey_base
            +  L"\\"
            +  Win::StringFromGUID2(*nodetypes[i]));
      if (hkey == 0)
      {
         LOG(L"Failure creating nodetype key");
         return E_FAIL;
      }
   }

   // register the snapin as an extension of Computer Management snapin
   result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
            SNAPIN_REG_ROOT
         +  L"\\NodeTypes\\"
         +  lstruuidNodetypeSystemTools
         +  L"\\Extensions\\NameSpace",
         classIDString,
         name);
   if (!result)
   {
      LOG(L"Failure creating snapin extension key");
      return E_FAIL;
   }

   return S_OK;
}



static
bool
registerClass(const CLSID& classID, int friendlyNameResID)
{
   LOG_FUNCTION(registerClass);
   ASSERT(friendlyNameResID);

   // Get server location.
   
   String module_location = Win::GetModuleFileName(hDLLModuleHandle);
   String classID_string = Win::StringFromCLSID(classID);
   String key1 = L"CLSID\\" + classID_string;
   String key2 = key1 + L"\\InprocServer32";

   // Add the CLSID to the registry.
   
   if (
         CreateKeyAndSetValue(
            HKEY_CLASSES_ROOT,
            key1,
            "",
            String::load(friendlyNameResID))
      && CreateKeyAndSetValue(
            HKEY_CLASSES_ROOT,
            key2,
            L"",
            module_location)
      && CreateKeyAndSetValue(
            HKEY_CLASSES_ROOT,
            key2,
            L"ThreadingModel",
            L"Apartment") )
   {
      return true;
   }

   LOG(L"Unable to register class " + classID_string);
   return false;
}



STDAPI
DllRegisterServer()
{
   LOG_FUNCTION(DllRegisterServer);

   if (
         registerClass(
            CLSID_ComponentData,
            IDS_SNAPIN_CLSID_FRIENDLY_NAME)
      && registerClass(
            CLSID_SnapinAbout,
            IDS_SNAPIN_ABOUT_CLSID_FRIENDLY_NAME) )
   {
      return
         DoSnapinRegistration(
            Win::StringFromCLSID(CLSID_ComponentData));
   }

   return E_FAIL;
}



// STDAPI
// DllUnregisterServer()
// {
//    return S_OK;
// }



STDAPI
DllCanUnloadNow()
{
   LOG_FUNCTION(DllCanUnloadNow);
   if (ComServerLockState::CanUnloadNow())
   {
      return S_OK;
   }

   return S_FALSE;
}



// Creates the snapin class factory object
//
// A class object is an instance of an object that implements IClassFactory
// for a given CLSID.  It is a meta-object, not to be confused with instances
// of the type the class factory creates.
// 
// In our case, this COM server supports two classes: The Local Users and
// Groups Snapin (ComponentData) and The Local Users and Groups About
// "Provider" (SnapinAbout).
// 
// The meta objects -- class objects in COM lingo -- are
// ClassFactory<ComponentData> and ClassFactory<SnapinAbout>.  COM calls this
// function to get instances of those meta objects.

STDAPI
DllGetClassObject(
   const CLSID&   classID,
   const IID&     interfaceID,
   void**         interfaceDesired)
{
   LOG_FUNCTION(DllGetClassObject);

   IClassFactory* factory = 0;

   // The class objects are instances of ClassFactory<>, which are ref-counted
   // in the usual fashion (i.e. they track their ref counts, and
   // self-destruct on final Release).  I could have used static instances of
   // a C++ class that ignored the refcounting (ala Don Box's examples in
   // Essential COM)

   if (classID == CLSID_ComponentData)
   {
      factory = new ClassFactory<ComponentData>; 
   }
   else if (classID == CLSID_SnapinAbout)
   {
      factory = new ClassFactory<SnapinAbout>; 
   }
   else
   {
      *interfaceDesired = 0;
      return CLASS_E_CLASSNOTAVAILABLE;
   }

   // the class factory instance starts with a ref count of 1.  If the QI
   // fails, then it self-destructs upon Release.
   HRESULT hr = factory->QueryInterface(interfaceID, interfaceDesired);
   factory->Release();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\foldnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Folder Node class
// 
// 9-29-97 sburns



#include "headers.hxx"
#include "foldnode.hpp"
#include "uuids.hpp"
#include "images.hpp"
#include "compdata.hpp"



FolderNode::FolderNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType,
   int                                    displayNameResID,
   int                                    typeTitleResID,
   const ColumnList&                      columns_,
   const MenuItemList&                    menu_)
   :
   ScopeNode(owner, nodeType),
   name(String::load(displayNameResID)),
   type_title(String::load(typeTitleResID)),
   columns(columns_),
   menu(menu_)
{
   LOG_CTOR(FolderNode);
}



FolderNode::~FolderNode()
{
   LOG_DTOR(FolderNode);

   // items is destroyed, destroying all of it's nodes, which cause them
   // all to be released
}


int
FolderNode::GetNormalImageIndex()
{
   LOG_FUNCTION(FolderNode::GetNormalImageIndex);

   return FOLDER_CLOSED_INDEX;
}



int
FolderNode::GetOpenImageIndex()
{
   LOG_FUNCTION(FolderNode::GetOpenImageIndex);

   return FOLDER_OPEN_INDEX;
}



HRESULT
FolderNode::InsertResultColumns(IHeaderCtrl& headerCtrl)
{
   LOG_FUNCTION(FolderNode::InsertResultColumns);

   return BuildResultColumns(columns.begin(), columns.end(), headerCtrl);
}



HRESULT
FolderNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(FolderNode::UpdateVerbs);

   consoleVerb.SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

   // this must be the default in order for the folder to open upon
   // double click while in the result pane.
   consoleVerb.SetDefaultVerb(MMC_VERB_OPEN);

   return S_OK;
}



HRESULT
FolderNode::AddMenuItems(
   IContextMenuCallback&   callback,
   long&                   insertionAllowed)
{
   LOG_FUNCTION(FolderNode::AddMenuItems);

   return
      BuildContextMenu(
         menu.begin(),
         menu.end(),
         callback,
         insertionAllowed);
}



String
FolderNode::GetDisplayName() const
{
//   LOG_FUNCTION(FolderNode::GetDisplayName);

   return name;
}



String
FolderNode::GetColumnText(int column)
{
   LOG_FUNCTION(FolderNode::GetColumnText);

   switch (column)
   {
      case 0:
      {
         return GetDisplayName();
      }
      case 1:
      {
         return type_title;
      }
      default:
      {
         // This should never be called
         ASSERT(false);
      }
   }

   return String();
}



HRESULT
FolderNode::InsertResultItems(IResultData& resultData)
{
   LOG_FUNCTION(FolderNode::InsertResultItems);

   if (items.empty())
   {
      BuildResultItems(items);
   }

   HRESULT hr = S_OK;
   for (
      ResultNodeList::iterator i = items.begin();
      i != items.end();
      i++)
   {
      hr = (*i)->InsertIntoResultPane(resultData);
      BREAK_ON_FAILED_HRESULT(hr);
   }

   return hr;
}



HRESULT
FolderNode::RebuildResultItems()
{
   LOG_FUNCTION(FolderNode::RebuildResultItems);

   // Destroying the contents of the list causes the SmartInterfaces to be
   // destroyed, which releases their pointers.   

   items.clear();
   BuildResultItems(items);

   return S_OK;
}



void
FolderNode::RefreshView()
{
   do
   {
      SmartInterface<IConsole2> console(GetOwner()->GetConsole());

      // Create a data object for this node.

      HRESULT hr = S_OK;      
      IDataObject* data_object = 0;
      hr =
         GetOwner()->QueryDataObject(
            reinterpret_cast<MMC_COOKIE>(this),
            CCT_SCOPE,
            &data_object);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(data_object);

      if (data_object)
      {
         // first call, with the '1' parameter, means "call
         // IResultData::DeleteAllRsltItems if you care that dataObject is
         // about to rebuild itself"

         hr = console->UpdateAllViews(data_object, 1, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);

            // don't break...we need to update the views
         }

         hr = RebuildResultItems();
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            // don't break...we need to update the views
         }

         // second call, with the '0' parameter, means, "now that your
         // result pane is empty, repopulate it."
         hr = console->UpdateAllViews(data_object, 0, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
         }

         data_object->Release();
      }
   }
   while (0);
}



int
FolderNode::GetResultItemCount() const
{
   LOG_FUNCTION(FolderNode::GetResultItemCount);

   return static_cast<int>(items.size());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\fpnw.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Random fpnw code
// 
// 10-28-98 sburns



#include "headers.hxx"
#include "adsi.hpp"
#include "waste.hpp"
#include "fpnw.hpp"



static const String RETURNNETWAREFORM(L"ReturnNetwareForm");
typedef NTSTATUS (*ReturnNetwareForm)(PCSTR, DWORD, PCWSTR, UCHAR*);

static const String MAPRIDTOOBJECTID(L"MapRidToObjectId");
typedef ULONG (*MapRidToObjectId)(DWORD, PWSTR, BOOL, BOOL);

static const String SWAPOBJECTID(L"SwapObjectId");
typedef ULONG (*SwapObjectId)(ULONG);



HRESULT
getObjectIDs(
   const SafeDLL& client_DLL,
   const String&  userSAMName,
   SAFEARRAY*     SIDArray,
   DWORD&         objectID,
   DWORD&         swappedObjectID)
{
   LOG_FUNCTION2(getObjectIDs, userSAMName);
   ASSERT(!userSAMName.empty());
   ASSERT(SIDArray);

   // the array is a one dimensional array of bytes
   ASSERT(::SafeArrayGetDim(SIDArray) == 1);
   ASSERT(::SafeArrayGetElemsize(SIDArray) == 1);

   objectID = 0;
   swappedObjectID = 0;

   HRESULT hr = S_OK;
   bool accessed = false;

   do
   {
      PSID sid = 0;
      hr = ::SafeArrayAccessData(SIDArray, &sid);
      BREAK_ON_FAILED_HRESULT(hr);
      accessed = true;

      UCHAR* sa_count = GetSidSubAuthorityCount(sid);
      if (!sa_count)
      {
         hr = Win::GetLastErrorAsHresult();

         LOG_HRESULT(hr);
         
         // make sure we break if sa_count is null, because we'll attempt
         // to deref it otherwise.
         // NTRAID#NTBUG9-540630-2002/04/03-sburns
         
         break;
      }

      DWORD* rid = GetSidSubAuthority(sid, *sa_count - 1);
      if (!rid)
      {
         hr = Win::GetLastErrorAsHresult();
      }
      BREAK_ON_FAILED_HRESULT(hr);

      FARPROC f = 0; 
      hr = client_DLL.GetProcAddress(MAPRIDTOOBJECTID, f);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(f);
      objectID =
         ((MapRidToObjectId) f)(
            *rid,
            const_cast<wchar_t*>(userSAMName.c_str()),
            FALSE,
            FALSE);

      if (objectID == SUPERVISOR_USERID)
      {
         swappedObjectID = SUPERVISOR_USERID;
      }
      else
      {
         hr = client_DLL.GetProcAddress(SWAPOBJECTID, f);
         BREAK_ON_FAILED_HRESULT(hr);
         swappedObjectID = ((SwapObjectId) f)(objectID);
      }
   }
   while (0);

   if (accessed)
   {
      ::SafeArrayUnaccessData(SIDArray);
   }

   return hr;
}  



HRESULT
FPNW::GetObjectIDs(
   const SmartInterface<IADsUser>&  user,
   const SafeDLL&                   clientDLL,
   DWORD&                           objectID,
   DWORD&                           swappedObjectID)
{
   LOG_FUNCTION(FPNW::GetObjectIDs);

   objectID = 0;
   swappedObjectID = 0;

   HRESULT hr = S_OK;
   do
   {
      // first, get the SAM account name
      BSTR bstrname;
      hr = user->get_Name(&bstrname);
      BREAK_ON_FAILED_HRESULT(hr);
      String name(bstrname);
      ::SysFreeString(bstrname);

      // next, get the account SID
      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_ObjectSID), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      // Object SID is returned as a safe array of bytes
      ASSERT(V_VT(&variant) & VT_ARRAY);
      ASSERT(V_VT(&variant) & VT_UI1);

      // object ID is determined by a mapping from the user's SAM account
      // name and SID.

      hr =
         getObjectIDs(
            clientDLL,
            name,
            V_ARRAY(&variant),
            objectID,
            swappedObjectID);
      variant.Clear();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



   
HRESULT
FPNW::GetLSASecret(const String& machine, String& result)
{
   LOG_FUNCTION2(GetLSASecret, machine);
   ASSERT(!machine.empty());

   result.erase();

   UNICODE_STRING machine_name;
   UNICODE_STRING secret_name;

   // ISSUE-2002/03/01-sburns should change these to RtlInitUnicodeStringEx
   
   ::RtlInitUnicodeString(&machine_name, machine.c_str());
   ::RtlInitUnicodeString(&secret_name, NCP_LSA_SECRET_KEY);

   SECURITY_QUALITY_OF_SERVICE sqos;

   // REVIEWED-2002/03/01-sburns correct byte count passed.
   
   ::ZeroMemory(&sqos, sizeof sqos);
   
   sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
   sqos.ImpersonationLevel = SecurityImpersonation;
   sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
   sqos.EffectiveOnly = FALSE;

   OBJECT_ATTRIBUTES oa;
   InitializeObjectAttributes(&oa, 0, 0, 0, 0);
   oa.SecurityQualityOfService = &sqos;

   LSA_HANDLE hlsaPolicy = 0;
   LSA_HANDLE hlsaSecret = 0;
   HRESULT hr = S_OK;

   do
   {
      hr = 
         Win32ToHresult(
            RtlNtStatusToDosError(
               LsaOpenPolicy(
                  &machine_name,
                  &oa,
                  GENERIC_READ | GENERIC_EXECUTE,
                  &hlsaPolicy)));
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         Win32ToHresult(
            RtlNtStatusToDosError(
               LsaOpenSecret(
                  hlsaPolicy,
                  &secret_name,
                  SECRET_QUERY_VALUE,
                  &hlsaSecret)));
      BREAK_ON_FAILED_HRESULT(hr);

      UNICODE_STRING* puSecretValue = 0;

      // CODEWORK: what if I passed 0 for these parameters?

      LARGE_INTEGER lintCurrentSetTime;
      LARGE_INTEGER lintOldSetTime;

      hr =
         Win32ToHresult(
            RtlNtStatusToDosError(
               LsaQuerySecret(
                  hlsaSecret,
                  &puSecretValue,
                  &lintCurrentSetTime,
                  NULL,
                  &lintOldSetTime)));
      BREAK_ON_FAILED_HRESULT(hr);

      // paranoid null check: NTRAID#NTBUG9-333197-2001/03/02-sburns
      
      if (puSecretValue)
      {
         result =
            String(
               puSecretValue->Buffer,

               // the secret length is in bytes, so convert to wchar_t's

               NCP_LSA_SECRET_LENGTH / sizeof(wchar_t));

         ::LsaFreeMemory(puSecretValue);
      }
      else
      {
         // if the LsaQuerySecret call succeeds, it should return a valid
         // pointer. If it does not, LsaQuerySecret is broken.
         
         ASSERT(false);
         hr = E_FAIL;
      }
   }
   while (0);

   if (hlsaPolicy)
   {
      ::LsaClose(hlsaPolicy);
   }

   if (hlsaSecret)
   {
      ::LsaClose(hlsaSecret);
   }

   return hr;
}



HRESULT
FPNW::SetPassword(
   WasteExtractor&        dump,
   const SafeDLL&         clientDLL,   
   const EncryptedString& newPassword, 
   const String&          lsaSecretKey,
   DWORD                  objectID)
{
   LOG_FUNCTION(FPNW::SetPassword);
   ASSERT(!lsaSecretKey.empty());
   ASSERT(objectID);

   HRESULT hr = S_OK;
   do
   {
      FARPROC f = 0;

      hr = clientDLL.GetProcAddress(RETURNNETWAREFORM, f);
      BREAK_ON_FAILED_HRESULT(hr);

      String encrypted(NWENCRYPTEDPASSWORDLENGTH, L' ');
      char secret_key[NCP_LSA_SECRET_LENGTH + 1];

      // REVIEWED-2002/03/01-sburns correct byte count passed.
      
      ::ZeroMemory(secret_key, NCP_LSA_SECRET_LENGTH + 1);

      // REVIEWED-2002/03/01-sburns correct byte count passed, and it's
      // correct to copy the unicode string into a char (byte) array
      
      ::CopyMemory(secret_key, lsaSecretKey.c_str(), NCP_LSA_SECRET_LENGTH);

      PWSTR cleartext = newPassword.GetClearTextCopy();
      if (!cleartext)
      {
         // don't set a null password if the decryption failed.

         hr = E_OUTOFMEMORY;
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      NTSTATUS status =
         ((ReturnNetwareForm) f)(
            secret_key,
            objectID,
            cleartext,
            reinterpret_cast<UCHAR*>(
               const_cast<wchar_t*>(encrypted.c_str())));

      newPassword.DestroyClearTextCopy(cleartext);
                     
      if (!NT_SUCCESS(status))
      {
         hr = Win32ToHresult(::NetpNtStatusToApiStatus(status));
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = dump.Put(NWPASSWORD, encrypted);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\fpnwlog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW login script editor dialog
// 
// 10-16-98 sburns



#include "headers.hxx"
#include "fpnwlog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   IDC_SCRIPT,       NO_HELP,
   IDCANCEL,         NO_HELP,
   IDOK,             NO_HELP,
   0, 0
};



FPNWLoginScriptDialog::FPNWLoginScriptDialog(
   const String& userName,
   const String& loginScript)
   :
   Dialog(IDD_FPNW_LOGIN_SCRIPT, HELP_MAP),
   name(userName),
   script(loginScript),
   start_sel(0),
   end_sel(0)
{
   LOG_CTOR(FPNWLoginScriptDialog);
}



FPNWLoginScriptDialog::~FPNWLoginScriptDialog()
{
   LOG_DTOR(FPNWLoginScriptDialog);   
}



String
FPNWLoginScriptDialog::GetLoginScript() const
{
   LOG_FUNCTION(FPNWLoginScriptDialog::GetLoginScript);

   return script;
}



bool
FPNWLoginScriptDialog::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (WasChanged(IDC_SCRIPT))
            {
               // save the changed script
               script = Win::GetDlgItemText(hwnd, IDC_SCRIPT);
            }

            HRESULT unused = Win::EndDialog(hwnd, IDOK);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, IDCANCEL);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDC_SCRIPT:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               break;
            }
            case EN_KILLFOCUS:
            {
               // save the selection state
               Win::Edit_GetSel(windowFrom, start_sel, end_sel);
               break;
            }
            case EN_SETFOCUS:
            {
               // restore the selection state
               Win::Edit_SetSel(windowFrom, start_sel, end_sel);
               break;
            }
            default:
            {
               // do nothing
            }
         }
         break;
      }
      default:
      {
         // do nothing
      }
   }

   return true;
}



void
FPNWLoginScriptDialog::OnInit()
{
   LOG_FUNCTION(FPNWLoginScriptDialog::OnInit);

   Win::SetWindowText(
      hwnd,
      String::format(IDS_LOGIN_SCRIPT_TITLE, name.c_str()));
   Win::SetDlgItemText(hwnd, IDC_SCRIPT, script);

   ClearChanges();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\fpnwpass.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW password dialog
// 
// 10-20-98 sburns



#ifndef FPNWPASS_HPP_INCLUDED
#define FPNWPASS_HPP_INCLUDED



class FPNWPasswordDialog : public Dialog
{
   public:

   FPNWPasswordDialog(const String& userName);

   virtual
   ~FPNWPasswordDialog();

   EncryptedString
   GetPassword() const;

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // not implemented: no copying allowed
   FPNWPasswordDialog(const FPNWPasswordDialog&);
   const FPNWPasswordDialog& operator=(const FPNWPasswordDialog&);

   EncryptedString password;
   String          name;    
};



#endif   // FPNWPASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\fpnwlog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW login script editor dialog
// 
// 10-16-98 sburns



#ifndef FPNWLOG_HPP_INCLUDED
#define FPNWLOG_HPP_INCLUDED



class FPNWLoginScriptDialog : public Dialog
{
   public:

   FPNWLoginScriptDialog(const String& userName, const String& loginScript);

   virtual
   ~FPNWLoginScriptDialog();

   String
   GetLoginScript() const;

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // not implemented: no copying allowed
   FPNWLoginScriptDialog(const FPNWLoginScriptDialog&);
   const FPNWLoginScriptDialog& operator=(const FPNWLoginScriptDialog&);

   String   script;
   String   name;
   int      start_sel;
   int      end_sel;
};



#endif   // FPNWLOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\groupgeneralpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupGeneralPage class
// 
// 9-17-97 sburns



#ifndef GROUPGENERALPAGE_HPP_INCLUDED
#define GROUPGENERALPAGE_HPP_INCLUDED



#include "adsipage.hpp"
#include "MembershipListView.hpp"



class GroupGeneralPage : public ADSIPage
{
   public:


   
   // Creates a new instance.
   // 
   // state - See base class ctor.
   //
   // path - See base class ctor.

   GroupGeneralPage(
      MMCPropertyPage::NotificationState* state,
      const ADSI::Path&                   path);

   virtual ~GroupGeneralPage();

   virtual
   bool
   OnApply(bool isClosing);

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnDestroy();

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   private:

   void
   Enable();

   MembershipListView* listview;        
   MemberList          originalMembers;
   HICON               groupIcon;       
                                      
   // not implemented: no copying allowed

   GroupGeneralPage(const GroupGeneralPage&);
   const GroupGeneralPage& operator=(const GroupGeneralPage&);
};



#endif   // GROUPGENERALPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\fpnwpass.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW password dialog
// 
// 10-20-98 sburns



#include "headers.hxx"
#include "fpnwpass.hpp"
#include "resource.h"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_PASSWORD,     NO_HELP,
   IDC_CONFIRM,      NO_HELP,
   IDCANCEL,         NO_HELP,
   IDOK,             NO_HELP,
   0, 0
};



FPNWPasswordDialog::FPNWPasswordDialog(const String& userName)
   :
   Dialog(IDD_FPNW_PASSWORD, HELP_MAP),
   name(userName)
{
   LOG_CTOR(FPNWPasswordDialog);
}



FPNWPasswordDialog::~FPNWPasswordDialog()
{
   LOG_DTOR(FPNWPasswordDialog);   
}



EncryptedString
FPNWPasswordDialog::GetPassword() const
{
   LOG_FUNCTION(FPNWPasswordDialog::GetPassword);

   return password;
}



bool
FPNWPasswordDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM))
            {
               password = Win::GetEncryptedDlgItemText(hwnd, IDC_PASSWORD);

               HRESULT unused = Win::EndDialog(hwnd, IDOK);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            if (
               popup.MessageBox(
                  hwnd,
                  IDS_FPNW_PASSWORD_CANCEL_WARNING,
                  MB_YESNO | MB_ICONWARNING) == IDYES)
            {
               HRESULT unused = Win::EndDialog(hwnd, IDCANCEL);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      default:
      {
         // do nothing
      }
   }

   return true;
}



void
FPNWPasswordDialog::OnInit()
{
   LOG_FUNCTION(FPNWPasswordDialog::OnInit);

   Win::SetWindowText(
      hwnd,
      String::format(IDS_PASSWORD_TITLE, name.c_str()));

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PASSWORD), PWLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_CONFIRM), PWLEN);

   ClearChanges();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\gfnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Groups Folder Node class
// 
// 9-17-97 sburns



#ifndef GFNODE_HPP_INCLUDED
#define GFNODE_HPP_INCLUDED



#include "foldnode.hpp"



class GroupsFolderNode : public FolderNode
{
   friend class RootNode;

   public:

   // Node overrides

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);

   // ScopeNode overrides

   virtual
   String
   GetDescriptionBarText();

   private:

   // can only be instanciated by Root Node (when expanding)
   GroupsFolderNode(const SmartInterface<ComponentData>& owner);

   // only we can delete ourselves
   virtual ~GroupsFolderNode();

   void
   BuildResultItems(ResultNodeList& items);

   // not defined: no copying allowed

   GroupsFolderNode(const GroupsFolderNode&);
   const GroupsFolderNode& operator=(const GroupsFolderNode&);
};

   


#endif   // GFNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\groupgeneralpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupGeneralPage class
// 
// 9-17-97 sburns



#include "headers.hxx"
#include "GroupGeneralPage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "MemberVisitor.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_NAME,         idh_general121_name,
   IDC_DESCRIPTION,  idh_general121_description,
   IDC_MEMBERS,      idh_general121_members, 
   IDC_ADD,          idh_general121_add,
   IDC_REMOVE,       idh_general121_remove,
   IDC_GROUP_ICON,   NO_HELP,
   0, 0
};



GroupGeneralPage::GroupGeneralPage(
   MMCPropertyPage::NotificationState* state,
   const ADSI::Path&                  path)
   :
   ADSIPage(IDD_GROUP_GENERAL, HELP_MAP, state, path),
   listview(0),
   groupIcon(0)
{
   LOG_CTOR2(GroupGeneralPage, path.GetPath());
}



GroupGeneralPage::~GroupGeneralPage()
{
   LOG_DTOR(GroupGeneralPage);

   if (groupIcon)
   {
      Win::DestroyIcon(groupIcon);
   }
}



void
GroupGeneralPage::OnInit()
{
   LOG_FUNCTION(GroupGeneralPage::OnInit());

   // Setup the controls

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);

   HRESULT hr = Win::LoadImage(IDI_GROUP, groupIcon);

   // if the icon load fails, we're not going to tank the whole dialog, so
   // just assert here.

   ASSERT(SUCCEEDED(hr));

   Win::Static_SetIcon(Win::GetDlgItem(hwnd, IDC_GROUP_ICON), groupIcon);

   listview =
      new MembershipListView(
         Win::GetDlgItem(hwnd, IDC_MEMBERS),
         GetMachineName(),
         MembershipListView::GROUP_MEMBERSHIP);

   // load the group properties into the dialog.

   hr = S_OK;
   do
   {
      SmartInterface<IADsGroup> group(0);
      
      // CODEWORK: would qualifying this path with the class type improve bind
      // performance? If so, change ADSI::GetXxxx to append class type
      // automatically.
      
      hr = ADSI::GetGroup(GetPath().GetSidPath(), group);
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR name;
      hr = group->get_Name(&name);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_NAME, name);

      BSTR description;
      hr = group->get_Description(&description);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_DESCRIPTION, description);

      // populate the list with group membership

      MemberVisitor visitor(originalMembers, hwnd, name, GetMachineName());
      hr = ADSI::VisitMembers(group, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
      listview->SetContents(originalMembers);

      ::SysFreeString(name);
      ::SysFreeString(description);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_READING_GROUP,
            GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   Enable();
}



void
GroupGeneralPage::Enable()
{
   bool selected =
      Win::ListView_GetSelectedCount(
         Win::GetDlgItem(hwnd, IDC_MEMBERS)) > 0;

   HWND removeButton = Win::GetDlgItem(hwnd, IDC_REMOVE);
   
   if (!selected)
   {
      // If we're about to disable the remove button, check to see if it
      // has focus first.  If it does, we need to move focus to another
      // control.  Similarly for default pushbutton style.
      // NTRAID#NTBUG9-435045-2001/07/13-sburns

      if (removeButton == ::GetFocus())
      {
         HWND addButton = Win::GetDlgItem(hwnd, IDC_ADD);
         Win::SetFocus(addButton);
         Win::Button_SetStyle(addButton, BS_DEFPUSHBUTTON, true);
         Win::Button_SetStyle(removeButton, BS_PUSHBUTTON, true);
      }
   }

   Win::EnableWindow(removeButton, selected);
}



bool
GroupGeneralPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lparam)
{
//    LOG_FUNCTION(GroupGeneralPage::OnNotify);

   switch (controlIDFrom)
   {
      case IDC_MEMBERS:
      {
         switch (code)
         {
            case LVN_ITEMCHANGED:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lparam);
                  if (lv->uChanged & LVIF_STATE)
                  {
                     // a list item changed state

                     Enable();
                  }
               }
               break;
            }
            case LVN_KEYDOWN:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLVKEYDOWN* kd = reinterpret_cast<NMLVKEYDOWN*>(lparam);
                  if (kd->wVKey == VK_INSERT)
                  {
                     listview->OnAddButton();
                  }
                  else if (kd->wVKey == VK_DELETE)
                  {
                     listview->OnRemoveButton();
                  }
               }
               break;
            }
            case LVN_INSERTITEM:
            case LVN_DELETEITEM:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
               break;
            }
            default:
            {
               break;
            }
         }
         break;
      }
      default:
      {
      }
   }

   return true;
}



void
GroupGeneralPage::OnDestroy()
{
   LOG_FUNCTION(GroupGeneralPage::OnDestroy);
   
   delete listview;
   listview = 0;
}



bool
GroupGeneralPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(GroupGeneralPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DESCRIPTION:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_ADD:
      {
         if (code == BN_CLICKED)
         {
            listview->OnAddButton();
         }
         break;
      }
      case IDC_REMOVE:
      {
         if (code == BN_CLICKED)
         {
            listview->OnRemoveButton();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}



String
GetPathToUseInGroupAdd(const MemberInfo& info)
{
   LOG_FUNCTION2(GetPathToUseInGroupAdd, info.path);

   if (!info.sidPath.empty())
   {
      // use the sidPath to add the member to the group, as a workaround
      // to bug 333491.

      return info.sidPath;
   }

   // since all objects to be added were retreived from the object picker,
   // we would expect them all to have the sid.

   ASSERT(false);

   // form a "type-qualified" path, ostensibly for better performance, 
   // although my experience is that this does not appear to improve
   // performance perceptibly.

   String path = info.path;
   switch (info.type)
   {
      case MemberInfo::USER:
      case MemberInfo::DOMAIN_USER:
      {
         path += L",";
         path += ADSI::CLASS_User;
         break;
      }
      case MemberInfo::GROUP:
      case MemberInfo::DOMAIN_GROUP:
      {
         path += L",";
         path += ADSI::CLASS_Group;
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return path;
}



String
GetPathToUseInGroupRemove(const MemberInfo& info)
{
   LOG_FUNCTION2(GetPathToUseInGroupRemove, info.path);

   if (!info.sidPath.empty())
   {
      // prefer the SID path.  This is because in some cases (like
      // group members that have been since cloned), the SID is the only
      // correct way to refer to the membership.

      return info.sidPath;
   }

   String path = info.path;

   // if info refers to a local user, then bind to it and retrieve its
   // sid, and use the sid path to remove the membership.  workaround to
   // 333491.

   if (info.type == MemberInfo::USER)
   {
      // only need to find sid for user objects, as local groups can't
      // have other local groups as members, and 333491 does not apply
      // to global objects.

      HRESULT hr = ADSI::GetSidPath(info.path, path);

      // in case of failure fall back to the normal path

      if (FAILED(hr))
      {
         path = info.path;
      }
   }

   return path;
}



HRESULT
ReconcileMembershipChanges(
   const SmartInterface<IADsGroup>& group,
   MemberList                       originalMembers,     // a local copy...
   const MemberList&                newMembers,
   HWND                             hwnd)
{
   HRESULT hr = S_OK;
   for (
      MemberList::iterator i = newMembers.begin();
      i != newMembers.end();
      i++)
   {
      MemberInfo& info = *i;

      MemberList::iterator f =
         std::find(originalMembers.begin(), originalMembers.end(), info);
      if (f != originalMembers.end())
      {
         // found.  remove the matching node in the original list

         originalMembers.erase(f);
      }
      else
      {
         // not found.  Add the node as a member of the group

         String path = GetPathToUseInGroupAdd(info);

         LOG(L"Adding to group " + path);

         hr = group->Add(AutoBstr(path));
         if (hr == Win32ToHresult(ERROR_MEMBER_IN_ALIAS))
         {
            // already a member: pop up a warning but don't consider this
            // a real error. 6791

            hr = S_OK;

            BSTR groupName;
            HRESULT anotherHr = group->get_Name(&groupName);
            if (SUCCEEDED(anotherHr))
            {
               popup.Info(
                  hwnd,
                  String::format(
                     IDS_ALREADY_MEMBER,
                     info.name.c_str(),
                     groupName));
               ::SysFreeString(groupName);
            }
         }

         BREAK_ON_FAILED_HRESULT(hr);
      }
   }

   if (SUCCEEDED(hr))
   {
      // at this point, the original list contains only those nodes which are
      // not in the new list.  Remove these from the group membership

      for (
         i = originalMembers.begin();
         i != originalMembers.end();
         i++)
      {
         String path = GetPathToUseInGroupRemove(*i);

         LOG(L"Removing from group " + path);

         hr = group->Remove(AutoBstr(path));
         BREAK_ON_FAILED_HRESULT(hr);

         // CODEWORK: what if the member is not part of the group?
      }
   }

   return hr;
}



bool
GroupGeneralPage::OnApply(bool isClosing)
{
   LOG_FUNCTION(GroupGeneralPage::OnApply);

   bool description_changed = WasChanged(IDC_DESCRIPTION);
   bool members_changed = WasChanged(IDC_MEMBERS);

   if (!description_changed && !members_changed)
   {
      // no changes to save
      return true;
   }

   // save the changes thru ADSI
   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsGroup> group(0);
      hr = ADSI::GetGroup(GetPath().GetSidPath(), group);
      BREAK_ON_FAILED_HRESULT(hr);

      if (description_changed)
      {
         String description = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);
         hr = group->put_Description(AutoBstr(description));
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (members_changed)
      {
         MemberList newMembers;
         listview->GetContents(newMembers);
         hr =
            ReconcileMembershipChanges(
               group,
               originalMembers,
               newMembers,
               hwnd);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // commit the property changes
      hr = group->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

      // refresh the membership list
      if (!isClosing && members_changed)
      {
         BSTR name;
         hr = group->get_Name(&name);
         BREAK_ON_FAILED_HRESULT(hr);
         
         // refresh the listview
         originalMembers.clear();
         MemberVisitor
            visitor(originalMembers, hwnd, name, GetMachineName());
         hr = ADSI::VisitMembers(group, visitor);
         BREAK_ON_FAILED_HRESULT(hr);
         listview->SetContents(originalMembers);

         ::SysFreeString(name);
      }

      SetChangesApplied();
      ClearChanges();
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_GROUP_PROPERTIES,
            GetObjectName().c_str(),
            GetMachineName().c_str()));

      if (hr != E_ADS_UNKNOWN_OBJECT)
      {
         // cause the sheet to remain open, and focus to go to this page.
         // NTRAID#NTBUG9-462516-2001/08/28-sburns
      
         Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\gfnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupsFolder Node class
// 
// 9-17-97 sburns



#include "headers.hxx"
#include "gfnode.hpp"
#include "uuids.hpp"
#include "resource.h"
#include "grupnode.hpp"
#include "images.hpp"
#include "adsi.hpp"
#include "compdata.hpp"
#include "CreateGroupDialog.hpp"
#include "dlgcomm.hpp"



static
FolderNode::ColumnList
buildColumnList()
{
   FolderNode::ColumnList list;

   static const ResultColumn col1 =
   {   
      IDS_GROUP_NAME_COLUMN_TITLE,
      IDS_GROUP_NAME_COLUMN_WIDTH
   };
   static const ResultColumn col2 =
   {
      IDS_GROUP_DESCRIPTION_COLUMN_TITLE,
      IDS_GROUP_DESCRIPTION_COLUMN_WIDTH
   };

   list.push_back(col1);
   list.push_back(col2);

   return list;
};



static
FolderNode::MenuItemList
buildMenuItemList()
{
   FolderNode::MenuItemList list;

   static const ContextMenuItem item1 =
   {
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      IDS_GF_MENU_CREATE_GROUP,
      IDS_GF_MENU_NEW_GROUP_STATUS
   };
   // static const ContextMenuItem item2 =
   // {
   //    CCM_INSERTIONPOINTID_PRIMARY_NEW,
   //    IDS_GF_MENU_NEW_GROUP,
   //    IDS_GF_MENU_NEW_GROUP_STATUS         
   // };

   list.push_back(item1);
   // list.push_back(item2);

   return list;
}



GroupsFolderNode::GroupsFolderNode(
   const SmartInterface<ComponentData>& owner)
   :
   FolderNode(
      owner,
      NODETYPE_GroupsFolder,
      IDS_GROUPS_FOLDER_DISPLAY_NAME,
      IDS_GROUPS_FOLDER_TYPE_TITLE,
      buildColumnList(),
      buildMenuItemList())
{
   LOG_CTOR(GroupsFolderNode);
}



GroupsFolderNode::~GroupsFolderNode()
{
   LOG_DTOR(GroupsFolderNode);
}



HRESULT
GroupsFolderNode::MenuCommand(
   IExtendContextMenu&  /* extendContextMenu */,
   long                 commandID)
{
   LOG_FUNCTION(GroupsFolderNode::MenuCommand);

   switch (commandID)
   {
      case IDS_GF_MENU_NEW_GROUP:
      case IDS_GF_MENU_CREATE_GROUP:
      {
         CreateGroupDialog dlg(GetOwner()->GetInternalComputerName());
         if (dlg.ModalExecute(GetOwner()->GetMainWindow()))
         {
            RefreshView();
         }
         break;
      }
      case MMCC_STANDARD_VIEW_SELECT:
      {
         // we ignore this

         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



class GroupVisitor : public ADSI::ObjectVisitor
{
   public:

   GroupVisitor(
      FolderNode::ResultNodeList&            nodes_,
      const SmartInterface<ComponentData>&   owner_)
      :
      nodes(nodes_),
      owner(owner_)
   {
   }

   virtual
   ~GroupVisitor()
   {
   }
   
   virtual
   void
   Visit(const SmartInterface<IADs>& object)
   {
      LOG_FUNCTION(GroupVistor::visit);

      HRESULT hr = S_OK;
      do
      {
         
#ifdef DBG         
         BSTR cls = 0;
         hr = object->get_Class(&cls);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(String(cls));

         ASSERT(cls == ADSI::CLASS_Group);
         ::SysFreeString(cls);
#endif

         BSTR name = 0;
         hr = object->get_Name(&name);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(String(name));

         String sidPath;
         hr = ADSI::GetSidPath(object, sidPath);
         BREAK_ON_FAILED_HRESULT2(hr, L"GetSidPath");

         BSTR path = 0;
         hr = object->get_ADsPath(&path);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(L"Visiting " + String(path));

         SmartInterface<IADsGroup> group(0);
         hr = group.AcquireViaQueryInterface(*((IADs*)object)); 
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(L"IADsGroup QI SUCCEEDED");

         BSTR desc = 0;
         hr = group->get_Description(&desc);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(String(desc));

         // created with a ref count == 1, so we own it here

         ADSI::Path p(path, sidPath);
         
         GroupNode* node = new GroupNode(owner, name, p, desc);
         ::SysFreeString(name);
         ::SysFreeString(path);
         ::SysFreeString(desc);

         // transfer ownership of the node pointer to a SmartInterface in
         // the list....

         nodes.push_back(SmartInterface<ResultNode>(node));

         // ... and relinquish our hold on it.

         node->Release();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            owner->GetMainWindow(),
            hr,
            String::load(IDS_ERROR_VISITING_GROUP));
      }
   }

   private:

   FolderNode::ResultNodeList& nodes;
   SmartInterface<ComponentData> owner;

   // not defined: no copying allowed

   GroupVisitor(const GroupVisitor&);
   const GroupVisitor& operator=(const GroupVisitor&);
};



void
GroupsFolderNode::BuildResultItems(ResultNodeList& items)
{
   LOG_FUNCTION(GroupsFolderNode::BuildResultItems);
   ASSERT(items.empty());

   GroupVisitor visitor(items, GetOwner());
   ADSI::VisitChildren(
      ADSI::ComposeMachineContainerPath(GetOwner()->GetInternalComputerName()),
      ADSI::CLASS_Group,
      visitor);
}



String
GroupsFolderNode::GetDescriptionBarText()
{
   LOG_FUNCTION(GroupsFolderNode::GetDescriptionBarText);

   return String::format(IDS_GROUPS_FOLDER_DESC, GetResultItemCount());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\images.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Image handling stuff
//
// 9-24-97 sburns



#ifndef IMAGES_HPP_INCLUDED
#define IMAGES_HPP_INCLUDED



// Image indicies for scope and result panes.  These must be contiguous and
// unique

#define FOLDER_OPEN_INDEX   0
#define FOLDER_CLOSED_INDEX 1
#define USER_INDEX          2
#define GROUP_INDEX         3
#define POLICY_INDEX        4
#define DISABLED_USER_INDEX 5
#define ROOT_OPEN_INDEX     6
#define ROOT_CLOSED_INDEX   7
#define ROOT_ERROR_INDEX    8



struct IconIDToIndexMap
{
   int   resID;
   int   index;

   static
   HRESULT
   Load(const IconIDToIndexMap map[], IImageList& imageList);
};



#endif   // IMAGES_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\grupnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupNode class
// 
// 9-17-97 sburns



#include "headers.hxx"
#include "grupnode.hpp"
#include "resource.h"
#include "uuids.hpp"
#include "images.hpp"
#include "GroupGeneralPage.hpp"
#include "adsi.hpp"
#include "dlgcomm.hpp"



GroupNode::GroupNode(
   const SmartInterface<ComponentData>&   owner,
   const String&                          displayName,
   const ADSI::Path&                      path,
   const String&                          description_)
   :
   AdsiNode(owner, NODETYPE_Group, displayName, path),
   description(description_)
{
   LOG_CTOR2(GroupNode, GetDisplayName());
}



GroupNode::~GroupNode()
{
   LOG_DTOR2(GroupNode, GetDisplayName());
}
   

                 
String
GroupNode::GetColumnText(int column)
{
//    LOG_FUNCTION(GroupNode::GetColumnText);

   switch (column)
   {
      case 0:  // Name
      {
         return GetDisplayName();
      }
      case 1:  // Description
      {
         return description;
      }
      default:
      {
         // This should never be called
         ASSERT(false);
      }
   }

   return String();
}



int
GroupNode::GetNormalImageIndex()
{
   LOG_FUNCTION2(GroupNode::GetNormalImageIndex, GetDisplayName());

   return GROUP_INDEX;
}



bool
GroupNode::HasPropertyPages()
{
   LOG_FUNCTION2(GroupNode::HasPropertyPages, GetDisplayName());
      
   return true;
}



HRESULT
GroupNode::CreatePropertyPages(
   IPropertySheetCallback&             callback,
   MMCPropertyPage::NotificationState* state)
{
   LOG_FUNCTION2(GroupNode::CreatePropertySheet, GetDisplayName());

   // these pages delete themselves when the prop sheet is destroyed

   GroupGeneralPage* general_page =
      new GroupGeneralPage(state, GetPath());

   // designate the general page as that which frees the notify state
   // (only one page in the prop sheet should do this)
   general_page->SetStateOwner();

   HRESULT hr = S_OK;
   do
   {
      hr = DoAddPage(*general_page, callback);
      if (FAILED(hr))
      {
         delete general_page;
         general_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   return hr;
}



HRESULT
GroupNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(GroupNode::UpdateVerbs);

   consoleVerb.SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
   consoleVerb.SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

// CODEWORK: we should enable the refresh verb for result nodes too.
// NTRAID#NTBUG9-153012-2000/08/31-sburns
//   consoleVerb.SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

   consoleVerb.SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
   consoleVerb.SetDefaultVerb(MMC_VERB_PROPERTIES);

   return S_OK;
}



HRESULT
GroupNode::Rename(const String& newName)
{
   LOG_FUNCTION(GroupNode::Rename);

   String name(newName);

   // trim off whitespace.
   // NTRAID#NTBUG9-328306-2001/02/26-sburns
   
   name.strip(String::BOTH);
   
   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_BAD_SAM_NAME,
            name.c_str()));
      return S_FALSE;
   }

   HRESULT hr = AdsiNode::rename(name);
   if (FAILED(hr))
   {
      String obj = GetPath().GetObjectName();      
      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(IDS_ERROR_RENAMING_GROUP, obj.c_str()));
      return S_FALSE;
   }

   return S_OK;
}



HRESULT
GroupNode::Delete()
{
   LOG_FUNCTION(GroupNode::Delete);

   String name = GetPath().GetObjectName();

   if (
      popup.MessageBox(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_CONFIRM_GROUP_DELETE,
            name.c_str()),
         MB_ICONWARNING | MB_YESNO) == IDYES)
   {
      HRESULT hr =
         ADSI::DeleteObject(
            ADSI::ComposeMachineContainerPath(GetOwner()->GetInternalComputerName()),
            name,
            ADSI::CLASS_Group);

      if (SUCCEEDED(hr))
      {
         return S_OK;
      }

      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(IDS_ERROR_DELETING_GROUP, name.c_str()));
   }

   // always return S_OK, since we've handled the delete verb    
   // NTRAID#NTBUG9-475985-2001/10/03-sburns
   
   return S_OK;
}



HRESULT
GroupNode::AddMenuItems(
   IContextMenuCallback&   callback,
   long&                   insertionAllowed)
{
   LOG_FUNCTION(GroupNode::AddMenuItems);

   static const ContextMenuItem items[] =
   {
      {
         CCM_INSERTIONPOINTID_PRIMARY_TOP,
         IDS_ADD_TO_GROUP_MEMBERSHIP,
         IDS_ADD_TO_GROUP_MEMBERSHIP_STATUS
      },
      {
         CCM_INSERTIONPOINTID_PRIMARY_TASK,
         IDS_ADD_TO_GROUP_MEMBERSHIP,
         IDS_ADD_TO_GROUP_MEMBERSHIP_STATUS
      }
   };

   return
      BuildContextMenu(
         items,
         items + sizeof(items) / sizeof(ContextMenuItem),
         callback,
         insertionAllowed);
}



HRESULT
GroupNode::MenuCommand(
   IExtendContextMenu&  extendContextMenu,
   long                 commandID)
{
   LOG_FUNCTION(GroupNode::MenuCommand);

   switch (commandID)
   {
      case IDS_ADD_TO_GROUP_MEMBERSHIP:
      {
         return showProperties(extendContextMenu);
      }
      case MMCC_STANDARD_VIEW_SELECT:
      {
         // we ignore this

         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



HRESULT
GroupNode::showProperties(IExtendContextMenu& extendContextMenu)
{
   LOG_FUNCTION2(GroupNode::ShowProperties, GetDisplayName());

   SmartInterface<IPropertySheetProvider> prop_sheet_provider(0);
   HRESULT hr =
      prop_sheet_provider.AcquireViaQueryInterface(
         *(GetOwner()->GetConsole()) );
   if (SUCCEEDED(hr))
   {
      bool cleanup = false;
      do
      {
         hr =
            prop_sheet_provider->FindPropertySheet(
               reinterpret_cast<MMC_COOKIE>(this),
               0,
               this);
         if (hr == S_OK)
         {
            // sheet found, and brought to the foreground
            break;
         }

         hr =
            prop_sheet_provider->CreatePropertySheet(
               GetDisplayName().c_str(),
               TRUE,    // create a prop sheet, not a wizard
               reinterpret_cast<MMC_COOKIE>(this),
               this,
               0);
         BREAK_ON_FAILED_HRESULT(hr);

         // passing extendContextMenu here is ok, as ComponentData implements
         // IExtendContextMenu and IComponentData, and Component implements
         // IExtendContextMenu and IComponent.
         hr =
            prop_sheet_provider->AddPrimaryPages(
               &extendContextMenu,
               TRUE,
               GetOwner()->GetMainWindow(),
               FALSE);
         cleanup = FAILED(hr);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = prop_sheet_provider->AddExtensionPages();
         cleanup = FAILED(hr);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = prop_sheet_provider->Show(0, 0);
         cleanup = FAILED(hr);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      while (0);

      if (cleanup)
      {
         prop_sheet_provider->Show(-1, 0);
      }
   }

   if (FAILED(hr))
   {
      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(IDS_ERROR_SPAWNING_GROUP_PROPERTIES, GetDisplayName()));
   }
      
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\images.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Image handling stuff
// 
// 9-24-97 sburns



#include "headers.hxx"
#include "images.hpp"


   
HRESULT
IconIDToIndexMap::Load(const IconIDToIndexMap map[], IImageList& imageList)
{
   LOG_FUNCTION(IconIDToIndexMap::Load);
   ASSERT(map);

   HRESULT hr = S_OK;
   for (int i = 0; map[i].resID != 0; i++)
   {
      HICON icon = 0;
      hr = Win::LoadIcon(map[i].resID, icon);

      ASSERT(SUCCEEDED(hr));
         
      // if the load fails, then skip this image index (@@I wonder what will
      // happen, then)

      if (SUCCEEDED(hr))
      {
         hr =
            imageList.ImageListSetIcon(
               reinterpret_cast<LONG_PTR*>(icon),
               map[i].index);

         // once the icon is added (copied) to the image list, we can
         // destroy the original.

         Win::DestroyIcon(icon);

         BREAK_ON_FAILED_HRESULT(hr);
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\lsm.h ===
// "User Rights" Dialog Box

#define idh_user_right_list		1000	// User Rights: "" (ListBox)
#define idh_user_right_granted_list	1010	// User Rights: "" (ListBox)
#define idh_user_right_add_button	1020	// User Rights: "A&dd..." (Button)
#define idh_user_right_remove_button	1030	// User Rights: "&Remove" (Button)

// "General" Dialog Box

#define idh_general_must_change		110	// General: "User &must change password at next 
#define idh_general_never_expires	130	// General: "Pass&word never expires" (Button)
#define idh_general_password		90	// General: "" (Edit)
#define idh_general_description		80	// General: "" (Edit)
#define idh_general_fullname		70	// General: "" (Edit)
#define idh_general_confirm		100	// General: "" (Edit)
#define idh_general_account_disabled	140	// General: "Account disa&bled" (Button)
#define idh_general_username		60	// General: "" (Edit)
#define	idh_general_account_lockedout	145
#define idh_general_cannot_change	120	// General: "U&ser cannot change password" 

// "Profile" Dialog Box

#define idh_profile_local_path_radio	170	// Profile: "Local path:" (Button)
#define idh_profile_connect_to_list	200	// Profile: "" (ComboBox)
#define idh_profile_path		150	// Profile: "" (Edit)
#define idh_profile_local_path_text	180	// Profile: "" (Edit)
#define idh_profile_logon_script	160	// Profile: "" (Edit)
#define idh_profile_to_text		210	// Profile: "" (Edit)
#define idh_profile_connect_to_radio	190	// Profile: "&Connect to:" (Button)
#define idh_general_account_disabled	140	// General: "Account disa&bled" (Button)

// "Dial-In" Dialog Box

#define idh_dialin_grant	220	// Dial-In: "&Grant dial-in permission to user" (Button)
#define idh_dialin_nocall	230	// Dial-In: "&No call back" (Button)
#define idh_dialin_setby	260	// Dial-In: "&Set by caller" (Button)
#define idh_dialin_preset	240	// Dial-In: "&Preset to:" (Button)
#define idh_dialin_preset_text	250	// Dial-In: "" (Edit)

// "Member Of" Dialog Box

#define idh_memberof_add	280	// Member Of: "A&dd..." (Button)
#define idh_memberof_list	270	// Member Of: "" (ListBox)
#define idh_memberof_remove	290	// Member Of: "&Remove" (Button)

// "Choose Target Machine" Dialog Box

#define idh_local_computer		340	// Choose Target Machine: "&Local computer:  
#define idh_another_computer		350	// Choose Target Machine: "&Another computer: 
#define idh_another_computer_text	360	// Choose Target Machine: "" (Edit)
#define idh_browse			370	// Choose Target Machine: "B&rowse..." (Button)
#define idh_allow_selected		380	// Choose Target Machine: "Allo&w the selected 

// "General" Dialog Box for Groups

#define idh_general121_name		305	// Name
#define idh_general121_members		310	// General: "" (ListBox)
#define idh_general121_add		320	// General: "A&dd..." (Button)
#define idh_general121_remove		330	// General: "&Remove" (Button)
#define idh_general121_description	300	// General: "" (Edit)

// "Password" Dialog Box

#define idh_password_never_expires		500	// Password: "&Password never expires" 
#define idh_expires_in				510	// Password: "&Expires in" (Button)
#define idh_expires_in_days			520	// Password: "0" (Edit)
#define idh_password_allow_changes_immediately	530	// Password: "Allo&w changes immediately" #define idh_password_allow_changes_in		540	// Password: "Allow &changes in" (Button)
#define idh_password_allow_changes_in_days	550	// Password: "0" (Edit)
#define idh_password_permit_blank		560	// Password: "Permit &blank passwords" 
#define idh_password_at_least			570	// Password: "A&t least" (Button)
#define idh_password_at_least_characters	580	// Password: "0" (Edit)
#define idh_password_do_not_keep_history	590	// Password: "&Do not keep password
#define idh_password_remember			600	// Password: "&Remember" (Button)
#define idh_password_remember_numberof		610	// Password: "0" (Edit)
#define idh_password_user_must_logon		620	// Password: "&Users must logon in order 
#define idh_passwords_must_be_strong		630	// Password: "Passwords must be &strong"
#define idh_passwords_store_cleartext		640	// Password: "Store passwords in #define
#define idh_password_allow_changes_in	540	// Password: "Allow &changes in" (Button)

// "Lockout" Dialog Box

#define idh_reset_lockout_after		730	// Lockout: "0" (Edit)
#define idh_lockout_until_admin_unlocks	770	// Lockout: "Lockout &until Administrator unlocks  #define idh_duration_minutes		760	// Lockout: "0" (Edit)
#define idh_duration			750	// Lockout: "&Duration:" (Button)
#define idh_no_lockout			700	// Lockout: "&No account lockout policy" (Button)
#define idh_enable_lockout		710	// Lockout: "&Enable account lockout policy" 
#define idh_lockout_after		720	// Lockout: "0" (Edit)
#define idh_duration_minutes	760	// Lockout: "0" (Edit)

// "Auditing" Dialog Box

#define idh_disable_auditing		800	// Lockout: "Disable auditing" (Button)
#define idh_enable_auditing		810	// Lockout: "Enable auditing" (Button)
#define idh_audit_ds_access_success	834	// Auditing: "" (Button)
#define idh_audit_ds_access_failure	835	// Auditing: "" (Button)
#define idh_audit_kerberos_success	836	// Auditing: "" (Button)
#define idh_audit_kerberos_failure	837	// Auditing: "" (Button)
#define idh_audit_login_success		820	// Auditing: "" (Button)
#define idh_audit_login_failure		821	// Auditing: "" (Button)
#define idh_audit_file_access_success	822	// Auditing: "" (Button)
#define idh_audit_file_access_failure	823	// Auditing: "" (Button)
#define idh_audit_user_right_success	824	// Auditing: "" (Button)
#define idh_audit_user_right_failure	825	// Auditing: "" (Button)
#define idh_audit_mgmt_events_success	826	// Auditing: "" (Button)
#define idh_audit_mgmt_events_failure	827	// Auditing: "" (Button)
#define idh_audit_security_policy_success	828	// Auditing: "" (Button)
#define idh_audit_security_policy_failure	829	// Auditing: "" (Button)
#define idh_audit_system_shutdown_success	830	// Auditing: "" (Button)
#define idh_audit_system_shutdown_failure	831	// Auditing: "" (Button)
#define idh_audit_process_creation_success	832	// Auditing: "" (Button)
#define idh_audit_process_creation_failure	833	// Auditing: "" (Button)
#define idh_audit_audit_categories	850
#define idh_audit_success		855
#define idh_audit_failure		860


// "Trusted C.A. List" Dialog Box

#define idh_ca_list	900	// Trusted C.A. List: "" (ListBox)
#define idh_ca_add	910	// Trusted C.A. List: "A&dd..." (Button)
#define idh_ca_remove	920	// Trusted C.A. List: "&Remove" (Button)
#define idh_ca_details	930	// Trusted C.A. List: "&Details" (Button)
#define idh_ca_edit	940	//Edit button

// "Encrypted Data Recovery" Dialog Box

#define idh_encrypted_deactivate	1110	// Encrypted Data Recovery: "&Deactivate" 
#define idh_encrypted_recovery_keys	1100	// Encrypted Data Recovery: "" (ListBox)
#define idh_encrypted_manage_keys	1120	// Encrypted Data Recovery: "&Manage Keys" 

// "Create User" Dialog Box

#define idh_createuser_confirm_password	1240	// Create User: "" (Edit)
#define idh_createuser_change_password	1250	// Create User: "User &must change password at 
#define idh_createuser_user_cannot_change	1260	// Create User: "U&ser cannot change 
#define idh_createuser_account_disabled	1280	// Create User: "Account disa&bled" (Button)
#define idh_createuser_full_name	1210	// Create User: "" (Edit)
#define idh_createuser_user_name	1200	// Create User: "" (Edit)
#define idh_createuser_create_button	1290	// Create User: "C&reate" (Button)
#define idh_createuser_password_never_expires	1270	// Create User: "Pass&word never expires" 
#define idh_createuser_description	1220	// Create User: "" (Edit)
#define idh_createuser_password		1230	// Create User: "" (Edit)
#define idh_createuser_close_button	1295

// "Create Group" Dialog Box

#define idh_creategroup_members		1320	// Create Group: "List2" (SysListView32)
#define idh_creategroup_addbutton	1330	// Create Group: "A&dd..." (Button)
#define idh_creategroup_removebutton	1340	// Create Group: "&Remove" (Button)
#define idh_creategroup_name		1300	// Create Group: "" (Edit)
#define idh_creategroup_createbutton	1350	// Create Group: "C&reate" (Button)
#define idh_creategroup_description	1310	// Create Group: "" (Edit)
#define idh_creategroup_closebutton	1360



#define idh_setpass_new_password	1400	// Set Password: "" (Edit)
#define idh_setpass_confirm_password	1405	// Set Password: "" (Edit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\grupnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupNode class
// 
// 9-17-97 sburns



#ifndef GRUPNODE_HPP_INCLUDED
#define GRUPNODE_HPP_INCLUDED



#include "adsinode.hpp"



class GroupNode : public AdsiNode
{
   friend class GroupsFolderNode;

   public:

   // Creates a new instance.
   //
   // owner - See base class ctor.
   // 
   // displayName - See base class ctor.
   //
   // path - See base class ctor.
   // 
   // description - text to appear as the node's description in the result
   // pane details view.

   GroupNode(
      const SmartInterface<ComponentData>&   owner,
      const String&                          displayName,
      const ADSI::Path&                      path,
      const String&                          description);



   // Node overrides

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   virtual
   String
   GetColumnText(int column);

   virtual 
   int
   GetNormalImageIndex();

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);
                                      
   virtual
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ResultNode overrides

   virtual
   HRESULT
   CreatePropertyPages(
      IPropertySheetCallback&             callback,
      MMCPropertyPage::NotificationState* state);

   virtual
   HRESULT
   Delete();

   virtual
   bool
   HasPropertyPages();

   virtual
   HRESULT
   Rename(const String& newName);

   private:

   // only we can delete ourselves.
   virtual ~GroupNode();

   HRESULT
   showProperties(IExtendContextMenu& extendContextMenu);

   String description;

   // not defined: no copying allowed

   GroupNode(const GroupNode&);
   const GroupNode& operator=(const GroupNode&);
};



#endif   // GRUPNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\machine.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ComputerChooserPage class
// 
// 9-11-97 sburns



#ifndef MACHINE_HPP_INCLUDED
#define MACHINE_HPP_INCLUDED



#include "mmcprop.hpp"



class ComputerChooserPage : public MMCPropertyPage
{
   public:

   // Creates a new instance.
   // 
   // state - see base class.
   // 
   // machineName - String to receive the machine name chosen.
   // 
   // canOverrideComputerName - bool to receive the override flag.

   ComputerChooserPage(
      MMCPropertyPage::NotificationState* state,
      String&                             displayComputerName,
      String&                             internalComputerName,
      bool&                               canOverrideComputerName);


      
   virtual
   ~ComputerChooserPage();


   
   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    ID,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnWizFinish();

   private:

   // not implemented: no copying allowed
   ComputerChooserPage(const ComputerChooserPage&);
   const ComputerChooserPage& operator=(const ComputerChooserPage&);

   void
   doEnabling();

   void
   doBrowse();

   String&  displayComputerName;
   String&  internalComputerName;
   bool&    can_override;
};



#endif   // MACHINE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\machine.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ComputerChooserPage class
// 
// 9-11-97 sburns



#include "headers.hxx"
#include "machine.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"
#include "objpick.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_LOCAL_MACHINE,      idh_local_computer,
   IDC_SPECIFIC_MACHINE,   idh_another_computer,
   IDC_MACHINE_NAME,       idh_another_computer_text, 
   IDC_BROWSE,             idh_browse, 
   IDC_OVERRIDE,           idh_allow_selected,
   0, 0
};



ComputerChooserPage::ComputerChooserPage(
   MMCPropertyPage::NotificationState* state,
   String&                             displayComputerName_,
   String&                             internalComputerName_,
   bool&                               canOverrideComputerName)
   :
   MMCPropertyPage(IDD_MACHINE_CHOOSER, HELP_MAP, state),
   displayComputerName(displayComputerName_),
   internalComputerName(internalComputerName_),
   can_override(canOverrideComputerName)
{
   LOG_CTOR(ComputerChooserPage);

   displayComputerName.erase();
   internalComputerName.erase();
   can_override = false;
}



ComputerChooserPage::~ComputerChooserPage()
{
   LOG_DTOR(ComputerChooserPage);
}



void
ComputerChooserPage::doEnabling()
{
   // enable the edit box and browse button only if the specific machine
   // radio button is pressed.
   bool enable = Win::IsDlgButtonChecked(hwnd, IDC_SPECIFIC_MACHINE);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_MACHINE_NAME), enable);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE), enable);
}



class ComputerChooserObjectPickerResultCallback
   :
   public ObjectPicker::ResultsCallback
{
   public:

   ComputerChooserObjectPickerResultCallback(HWND machineNameEditBox)
      :
      hwnd(machineNameEditBox)
   {
      ASSERT(Win::IsWindow(hwnd));
   }

   int
   Execute(DS_SELECTION_LIST& selections)
   {
      // only single select
      ASSERT(selections.cItems == 1);

      DS_SELECTION& current = selections.aDsSelection[0];
      ASSERT(ADSI::CLASS_Computer.icompare(current.pwzClass) == 0);

      Win::SetWindowText(hwnd, current.pwzName);

      return 0;
   }

   private:

   HWND hwnd;
};



void
ComputerChooserPage::doBrowse()
{
   LOG_FUNCTION(ComputerChooserPage::doBrowse);

   static const int INFO_COUNT = 2;
   DSOP_SCOPE_INIT_INFO* infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(infos, INFO_COUNT * sizeof DSOP_SCOPE_INIT_INFO);

   int scope = 0;   
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

   infos[scope].flType =
         DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |  DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
   infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = 0;
   infos[scope].flType = 
         DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
      |  DSOP_SCOPE_TYPE_GLOBAL_CATALOG
      |  DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_WORKGROUP
      |  DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
      |  DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
   infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

   ASSERT(scope == INFO_COUNT - 1);

   DSOP_INIT_INFO init_info;

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(&init_info, sizeof init_info);

   init_info.cbSize = sizeof(init_info);
   init_info.flOptions = 0;
   init_info.pwzTargetComputer = 0;
   init_info.aDsScopeInfos = infos;
   init_info.cDsScopeInfos = INFO_COUNT;

   HRESULT hr =
      ObjectPicker::Invoke(
         hwnd,
         ComputerChooserObjectPickerResultCallback(
            Win::GetDlgItem(hwnd, IDC_MACHINE_NAME)),
         init_info);
   delete[] infos;

   if (FAILED(hr))
   {
      popup.Error(hwnd, hr, IDS_ERROR_LAUNCHING_PICKER);
   }
}



bool
ComputerChooserPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    ID,
   unsigned    code)
{
   if (code == BN_CLICKED)
   {
      switch (ID)
      {
         case IDC_LOCAL_MACHINE:
         case IDC_SPECIFIC_MACHINE:
         {
            doEnabling();
            return true;
         }
         case IDC_BROWSE:
         {
            doBrowse();
            return true;
         }
         default:
         {
            // do nothing
            break;
         }
      }
   }

   return false;
}



void
ComputerChooserPage::OnInit()
{
   LOG_FUNCTION(ComputerChooserPage::OnInit);

   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_FINISH);

   // default to the local machine
   Win::CheckDlgButton(hwnd, IDC_LOCAL_MACHINE, BST_CHECKED);

   // NTRAID#NTBUG9-485809-2001/10/24-sburns
   
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_MACHINE_NAME), DNS_MAX_NAME_LENGTH);
   
   doEnabling();
}



bool
ComputerChooserPage::OnWizFinish()
{
   LOG_FUNCTION(ComputerChooserPage::OnWizFinish);

   Win::CursorSetting cursor(IDC_WAIT);

   String s;
   if (Win::IsDlgButtonChecked(hwnd, IDC_SPECIFIC_MACHINE))
   {
      s = Win::GetTrimmedDlgItemText(hwnd, IDC_MACHINE_NAME);
      if (s.empty())
      {
         popup.Gripe(hwnd, IDC_MACHINE_NAME, IDS_MUST_ENTER_MACHINE_NAME);
         Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
         return true;
      }
   }

   HRESULT hr = S_OK;
   String message;
   do
   {
      if (!s.empty())
      {
         // we only need to check this if the snapin is not targeted at
         // the local machine.  (If the snapin is targeted at the local
         // machine, the very fact that this code is running on it is
         // proof that the machine is NT-based, and not Home Edition.
         // 145309 145288

         unsigned errorResId = 0;
         hr = CheckComputerOsIsSupported(s, errorResId);
         BREAK_ON_FAILED_HRESULT(hr);

         if (hr == S_FALSE)
         {
            hr = E_FAIL;
            message =
               String::format(
                  errorResId,
                  s.c_str());
            break;
         }
      }
      else
      {
         // we're focusing on the local computer.  Check for Home Edition.
         // NTRAID#NTBUG9-145309 NTRAID#NTBUG9-145288

         OSVERSIONINFOEX verInfo;
         hr = Win::GetVersionEx(verInfo);
         BREAK_ON_FAILED_HRESULT(hr);

         if (verInfo.wSuiteMask & VER_SUITE_PERSONAL)
         {
            hr = E_FAIL;
            message = String::load(IDS_MACHINE_IS_HOME_EDITION_LOCAL);

            break;
         }
      }

      Computer comp(s);

      hr = comp.Refresh();
      BREAK_ON_FAILED_HRESULT(hr);

      // bind to the computer to verify its accessibility (should work
      // if above worked, but just in case...

      String c = comp.GetNetbiosName();
      hr = ADSI::IsComputerAccessible(c);
      BREAK_ON_FAILED_HRESULT(hr);

      // determine if the machine is a DC
      if (comp.IsDomainController())
      {
         // can't use this on DCs
         hr = E_FAIL;
         message = String::format(IDS_ERROR_DC_NOT_SUPPORTED, c.c_str());
         break;
      }

      // use the name the user entered as the display name, not the
      // computer's netbios name (even thought it is the netbios name that
      // really matters).  454513
         
      SetComputerNames(s, displayComputerName, internalComputerName);
   }
   while (0);

   if (FAILED(hr))
   {
      if (message.empty())
      {
         String error = GetErrorMessage(hr);
         message =
            String::format(
               IDS_CANT_ACCESS_MACHINE,
               s.c_str(),
               error.c_str());
      }

      // at this point, an error occurred.  refuse to close
      popup.Gripe(hwnd, IDC_MACHINE_NAME, message);
      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
   }

   if (Win::IsDlgButtonChecked(hwnd, IDC_OVERRIDE))
   {
      can_override = true;
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\membershiplistview.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Group Membership/Object Picker handler class
// 
// 11-3-97 sburns



#ifndef MEMBERSHIPLISTVIEW_HPP_INCLUDED
#define MEMBERSHIPLISTVIEW_HPP_INCLUDED



#include "MemberInfo.hpp"



typedef
   std::list<MemberInfo, Burnslib::Heap::Allocator<MemberInfo> >
   MemberList;



// MembershipListView wraps a listview control, adding support for tracking
// the contents of the list, launching the object picker, etc.  Can be "wired"
// into a dialog or property page.

class MembershipListView
{
   public:

   enum Options
   {
      // show objects to which a local user may belong = local groups
      USER_MEMBERSHIP,

      // show objects which may belong to a local group = global groups,
      // global users, local users    
      GROUP_MEMBERSHIP
   };

   // Creates a new instance, "wiring" it to an existing listview control
   // child window.
   // 
   // listview - a list view child window.
   //       
   // machine - the name of the machine to focus the object picker on.
   //
   // opts - Options enum value.

   MembershipListView(
      HWND           listview,
      const String&  machine,
      Options        opts);

   ~MembershipListView();

   // Remove all items in the listview.

   void
   ClearContents();

   // Retrieve the current contents of the list view.
   //
   // results - MemberList instance where the contents of the listview are to
   // be placed.

   void
   GetContents(MemberList& results) const;

   // Launches the object picker, adding all picked object to the list
   // view.

   void
   OnAddButton();

   // Removes the currently selected item in the list view.

   void
   OnRemoveButton();

   // Sets the contents of the list view to that of the supplied list.
   //
   // newMembers - list of MemberInfo objects used to populate the list
   // view.

   void
   SetContents(const MemberList& newMembers);

   private:

   friend class ResultsCallback;
        
   void
   addItem(const MemberInfo& info);

   void
   AddPickerItems(DS_SELECTION_LIST& selections);

   void
   deleteItem(int target);

   bool
   itemPresent(const String& path);

   HWND     view;

   // CODEWORK: it would be more efficient to have a single Computer instance
   // built when the snapin changes focus, to which references are passed
   // around -- like to here

   Computer computer;
   Options  options;

   // not defined: no copying allowed

   MembershipListView(const MembershipListView&);
   const MembershipListView& operator=(const MembershipListView&);
};

   

#endif   // MEMBERSHIPLISTVIEW_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\membervisitor.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MemberVisitor class
// 
// 11-14-97 sburns



#include "headers.hxx"
#include "MembershipListView.hpp"
#include "MemberVisitor.hpp"
#include "resource.h"
#include "dlgcomm.hpp"



MemberVisitor::MemberVisitor(
   MemberList&    members_,
   HWND           parent_,
   const String&  containerName,
   const String&  machineName)
   :
   members(members_),
   parent(parent_),
   container_name(containerName),
   machine(machineName)
{
   LOG_CTOR(MemberVisitor);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!container_name.empty());
}



MemberVisitor::~MemberVisitor()
{
   LOG_DTOR(MemberVisitor);
}



void
MemberVisitor::Visit(const SmartInterface<IADs>& object)
{
   LOG_FUNCTION(MemberVistor::Visit);

   HRESULT hr = S_OK;
   BSTR name = 0;
   do
   {
      MemberInfo info;

      hr = object->get_Name(&name);
      BREAK_ON_FAILED_HRESULT(hr);
      info.name = name;

      hr = info.Initialize(name, machine, object);
      BREAK_ON_FAILED_HRESULT(hr);

      members.push_back(info);
   }
   while (0);

   if (FAILED(hr))
   {
      int res_id =
            name
         ?  IDS_ERROR_READING_MEMBER_PROPERTIES1
         :  IDS_ERROR_READING_MEMBER_PROPERTIES2;

      popup.Error(
         parent,
         hr,
         String::format(res_id, container_name.c_str(), name));
   }

   ::SysFreeString(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\memberinfo.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
// 
// MemberInfo class
// 
// 24 Jan 2000 sburns



#ifndef MEMBERINFO_HPP_INCLUDED
#define MEMBERINFO_HPP_INCLUDED

                   

// An instance of MemberInfo is associated with each item in the listview via
// the item's lparam.  As items are added and removed, MemberInfo objects are
// created and destroyed.
// 
// MemberInfo objects are also used in the public interface of
// MembershipListView to communicate the contents of the listview control.

class MemberInfo
{
   public:

   enum Type
   {
      // order is significant: it's also the image index

      USER         = 0,
      GROUP        = 1,
      DOMAIN_USER  = 2,
      DOMAIN_GROUP = 3,    // local, global, universal
      UNKNOWN_SID  = 4,
      COMPUTER     = 5 
   };

   Type   type;
   String path;
   String name;
   String sidPath;
   String upn;
   String origName;

   // default ctor, copy ctor, dtor, op= all used



   // Set the members based on information gleaned from the parameters
   //
   // objectName - Display name of the object.  Copied into the name member.
   // 
   // machine - netbios machine from whence the object was read.
   // 
   // object - IADs pointer to the object.
   
   HRESULT
   Initialize(
      const String&                 objectName,
      const String&                 machine,
      const SmartInterface<IADs>&   object);



   // Set the members based on information gleaned from the parameters
   //
   // objectName - Display name of the object.  Copied into the name member.
   //
   // adsPath - ADSI WinNT provider path to the object.
   //
   // upn - Universal Principal Name property of the object.  May be empty.
   //
   // sidPath - ADSI SID-style WinNT provider path to the object.
   //
   // adsClass - ADSI WinNT object class string for the object.
   //
   // groupTypeAttrVal - ADSI group type flag.
   // 
   // machine - netbios machine from whence the object was read.

   HRESULT
   InitializeFromPickerResults(
      const String&           objectName,
      const String&           adsPath,
      const String&           upn,
      const String&           sidPath,
      const String&           adsClass,
      long                    groupTypeAttrVal,
      const String&           machine);



   // returns true if the instances are logically equal (have the same name
   // path, etc.) false otherwise

   bool
   operator==(const MemberInfo&) const;



   private:

   void
   DetermineType(
      const String& className,
      const String& machine,
      long          groupTypeAttrVal,
      bool          canTrustClassName,
      bool          isLocal);


      
   void
   DetermineOriginalName(
      const String& targetComputer,
      const String& container);
};



#endif   // MEMBERINFO_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\membershiplistview.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Group Membership/Object Picker handler class
// 
// 11-3-97 sburns



#include "headers.hxx"
#include "MembershipListView.hpp"
#include "resource.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"
#include "objpick.hpp"



void
AddIconImage(HIMAGELIST imageList, int iconResID)
{
   LOG_FUNCTION(AddIconImage);
   ASSERT(imageList);
   ASSERT(iconResID);
   
   if (iconResID && imageList)
   {
      HICON icon = 0;
      HRESULT hr = Win::LoadImage(iconResID, icon);

      ASSERT(SUCCEEDED(hr));

      if (SUCCEEDED(hr))
      {
         Win::ImageList_AddIcon(imageList, icon);

         // once the icon is added (copied) to the image list, we can
         // destroy the original.

         Win::DestroyIcon(icon);
      }
   }
}
         


MembershipListView::MembershipListView(
   HWND           listview,
   const String&  machine,
   Options        opts)
   :
   view(listview),
   computer(machine),
   options(opts)
{
   LOG_CTOR(MembershipListView);
   ASSERT(Win::IsWindow(view));

   LVCOLUMN column;

   // REVIEWED-2002/03/04-sburns correct byte count passed
   
   ::ZeroMemory(&column, sizeof column);
   
   column.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
   column.fmt = LVCFMT_LEFT;

   String label = String::load(IDS_MEMBER_LIST_NAME_COLUMN);
   column.pszText = const_cast<wchar_t*>(label.c_str());

   Win::ListView_InsertColumn(view, 0, column);

//    // add a column to the list view for description.
//    String::load(IDS_MEMBER_LIST_DESC_COLUMN_WIDTH).convert(width);
//    column.cx = width;
//    label = String::load(IDS_MEMBER_LIST_DESC_COLUMN);
//    column.pszText = const_cast<wchar_t*>(label.c_str());
// 
//    Win::ListView_InsertColumn(view, 1, column);

   // this will resize the column to fill the entire width of the control.
   
   Win::ListView_SetColumnWidth(view, 0, LVSCW_AUTOSIZE_USEHEADER);
   
   // create the image list for the group members consisting of images
   // for groups and users.

   HIMAGELIST images =
      Win::ImageList_Create(
         Win::GetSystemMetrics(SM_CXSMICON),
         Win::GetSystemMetrics(SM_CYSMICON),
         ILC_MASK,
         5,
         0);

   // the order in which these are added must be the same that the
   // MemberInfo::Type enum values are listed!

   AddIconImage(images, IDI_USER);
   AddIconImage(images, IDI_GROUP);
   AddIconImage(images, IDI_DOMAIN_USER);
   AddIconImage(images, IDI_DOMAIN_GROUP);
   AddIconImage(images, IDI_UNKNOWN_SID);
   AddIconImage(images, IDI_COMPUTER);   

   Win::ListView_SetImageList(view, images, LVSIL_SMALL);

   // CODEWORK: instead of refreshing a new computer instance, can we
   // arrange to copy an existing one?  Or use a reference to an existing
   // one?

   computer.Refresh();
}



MembershipListView::~MembershipListView()
{
   LOG_DTOR(MembershipListView);

   ClearContents();
}



void
MembershipListView::ClearContents()
{
   // traverse the list and delete each item in reverse order (to minimize
   // redraw).

   for (int i = Win::ListView_GetItemCount(view) - 1; i >= 0; --i)
   {
      deleteItem(i);
   }
}



void
MembershipListView::GetContents(MemberList& results) const
{
   LOG_FUNCTION(MembershipListView::GetContents);

   LVITEM item;

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(&item, sizeof item);
   
   item.mask = LVIF_PARAM;

   for (int i = Win::ListView_GetItemCount(view) - 1; i >= 0; --i)
   {
      item.iItem = i;

      if (Win::ListView_GetItem(view, item))
      {
         ASSERT(item.lParam);

         results.push_back(*(reinterpret_cast<MemberInfo*>(item.lParam)));
      }
   }
}



void
MembershipListView::SetContents(const MemberList& newMembers)
{
   LOG_FUNCTION(MembershipListView::SetContents);

   ClearContents();

   for (
      MemberList::iterator i = newMembers.begin();
      i != newMembers.end();
      i++)
   {
      // We used to filter out duplicate names, but it turns out that you
      // can get duplicate names for accounts that have been cloned via
      // sidhistory, when a migrated SID and its clone are both added as
      // members of a local group.
      // NTRAID#NTBUG9-729319-2002/10/28-sburns

      // copy the node info
      // deleted in deleteItem, called by ClearContents.
      
      MemberInfo* info = new MemberInfo(*i);
      addItem(*info);
   }
}



void
MembershipListView::addItem(const MemberInfo& info)
{
   LVITEM item;

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(&item, sizeof item);

   // add the "main" item to the list control

   String text;
   switch (info.type)
   {
      case MemberInfo::DOMAIN_USER:
      case MemberInfo::DOMAIN_GROUP:
      {
         // if the account has an original name (is a migrated account),
         // then prefer showing that to the upn.
         
         if (!info.origName.empty())
         {
            text =
               String::format(
                  IDS_GLOBAL_ACCOUNT_DISPLAY_FORMAT,
                  ADSI::ExtractDomainObjectName(info.path).c_str(),
                  info.origName.c_str());
         }
         else if (!info.upn.empty())
         {
            text =
               String::format(
                  IDS_GLOBAL_ACCOUNT_DISPLAY_FORMAT,
                  ADSI::ExtractDomainObjectName(info.path).c_str(),
                  info.upn.c_str());
         }
         else
         {
            text = ADSI::ExtractDomainObjectName(info.path);
         }
         break;
      }
      case MemberInfo::COMPUTER:
      {
         text = ADSI::ExtractDomainObjectName(info.path);

         // Remove the trailing $ so the user is not confused with the
         // way object picker displays computer objects.
         
         if (*text.rbegin() == L'$')
         {
            text.resize(text.size() - 1);
         }
         break;
      }
      default:
      {
         text = ADSI::ExtractObjectName(info.path);
         break;
      }
   }        

   item.mask     = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
   item.iItem    = 0;                                 
   item.iSubItem = 0;                                 
   item.pszText  = const_cast<wchar_t*>(text.c_str());
   item.lParam   = reinterpret_cast<LPARAM>(&info);   
   item.iImage   = static_cast<int>(info.type);       

   item.iItem = Win::ListView_InsertItem(view, item);

   // // add the description sub-item to the list control
   // item.mask = LVIF_TEXT; 
   // item.iSubItem = 1;
   // item.pszText = const_cast<wchar_t*>(info->desc.c_str());
   // Win::ListView_SetItem(view, item);
}



void
MembershipListView::OnRemoveButton()
{
   LOG_FUNCTION(MembershipListView::OnRemoveButton);

   int count = Win::ListView_GetSelectedCount(view);
   if (count)
   {
      // determine the indices of the selected items and delete them in
      // reverse order (so that the remaining indices are valid)

      int i = Win::ListView_GetItemCount(view) - 1;
      ASSERT(i >= 0);

      int j = 0;
      std::vector<int, Burnslib::Heap::Allocator<int> > indices(count);

      while (i >= 0)
      {
         if (Win::ListView_GetItemState(view, i, LVIS_SELECTED))
         {
            indices[j++] = i;
         }
         --i;
      }

      ASSERT(j == count);

      for (i = 0; i < count; ++i)
      {
         deleteItem(indices[i]);
      }
   }
}



void
MembershipListView::deleteItem(int target)
{
   LOG_FUNCTION(MembershipListView::deleteItem);
   ASSERT(target != -1);

   LVITEM item;

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(&item, sizeof item);
   
   item.mask = LVIF_PARAM;
   item.iItem = target;

   if (Win::ListView_GetItem(view, item))
   {
      ASSERT(item.lParam);

      delete reinterpret_cast<MemberInfo*>(item.lParam);
      Win::ListView_DeleteItem(view, target);
      return;
   }
}



void
getGroupMembershipPickerSettings(
   DSOP_SCOPE_INIT_INFO*&  infos,
   ULONG&                  infoCount)
{
   LOG_FUNCTION(getGroupMembershipPickerSettings);

   static const int INFO_COUNT = 5;
   infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   infoCount = INFO_COUNT;

   // REVIEWED-2002/03/04-sburns correct byte count passed
   
   ::ZeroMemory(infos, INFO_COUNT * sizeof DSOP_SCOPE_INIT_INFO);

   int scope = 0;

   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   infos[scope].flScope =
            DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH

         // check the users and groups checkbox in the look for dialog
         // by default. NTRAID#NTBUG9-300910-2001/01/31-sburns
         
         |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
         |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;
         
      // this is implied for machine only scope
      /* |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT */

   // allow only local users from the machine scope

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_USERS
      |  DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

   // 
   // for the domain this machine is joined to (native and mixed mode).
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope =

         // make the joined domain the starting scope so that the default
         // filter options are actually evaluated.  In the case that the
         // machine is not joined, then this scope is not included in the
         // look in, and the default filter option we set don't matter
         // anyway (since the only scope will be local machine).
         // NTRAID#NTBUG9-300910-2001/02/06-sburns
         
         DSOP_SCOPE_FLAG_STARTING_SCOPE
      |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;

   infos[scope].flType =
         DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |  DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

   // here, we allow only domain global groups and domain users.  While
   // it is possible to add a domain local group to a machine local group,
   // I'm told such an operation is not really useful from an administraion
   // perspective.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

   // same comment above re: domain local groups applies here too.

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS
      |  DSOP_DOWNLEVEL_FILTER_COMPUTERS;

   //       
   // for domains in the same tree (native and mixed mode)
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   infos[scope].flScope =
         DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

   // above domain local group comment applies here, too.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

   // 
   // for external trusted domains
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope =
         DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;
   infos[scope].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS
      |  DSOP_DOWNLEVEL_FILTER_COMPUTERS;

   // 
   // for the global catalog
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope =
         DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;
   infos[scope].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

   // only native mode applies to gc scope.

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS
      |  DSOP_FILTER_COMPUTERS;

// SPB:252126 the workgroup scope doesn't apply in this case
//    // for when the machine is not joined to a domain
//    scope++;
//    infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
//    infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
//    infos[scope].flType = DSOP_SCOPE_TYPE_WORKGROUP;
// 
//    infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
//    infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

   ASSERT(scope == INFO_COUNT - 1);
}



void
getUserMembershipPickerSettings(
   DSOP_SCOPE_INIT_INFO*&  infos,
   ULONG&                  infoCount)
{
   LOG_FUNCTION(getUserMembershipPickerSettings);
   static const int INFO_COUNT = 1;
   infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   infoCount = INFO_COUNT;
   
   // REVIEWED-2002/03/04-sburns correct byte count passed

   ::ZeroMemory(infos, INFO_COUNT * sizeof DSOP_SCOPE_INIT_INFO);

   int scope = 0;   
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;

   infos[scope].flScope =
         DSOP_SCOPE_FLAG_STARTING_SCOPE; 
      // this is implied for machine only scope
      /* |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT */

   infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

   ASSERT(scope == INFO_COUNT - 1);
}



class ResultsCallback : public ObjectPicker::ResultsCallback
{
   public:

   ResultsCallback(MembershipListView& mlview)
      :
      view(mlview)
   {
      LOG_CTOR(ResultsCallback);
   }

   virtual
   ~ResultsCallback()
   {
      LOG_DTOR(ResultsCallback);
   }
   
   virtual
   int
   Execute(DS_SELECTION_LIST& selections)
   {
      view.AddPickerItems(selections);
      return 0;
   }

   private:

   MembershipListView& view;

   // not defined: no copying allowed

   ResultsCallback(const ResultsCallback&);
   const ResultsCallback& operator=(const ResultsCallback&);
};



// caller needs to call delete[] on element to free the copied string.

void
CopyStringToNewWcharElement(PWSTR& element, const String& str)
{
   LOG_FUNCTION2(CopyStringToNewWcharElement, str);
   ASSERT(!element);
   ASSERT(!str.empty());

   size_t len = str.length();
   element = new WCHAR[len + 1];
   
   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(element, (len + 1) * sizeof WCHAR);

   // REVIEWED-2002/03/04-sburns correct character count passed.
   
   str.copy(element, len);
}



void
MembershipListView::OnAddButton()
{
   LOG_FUNCTION(MembershipListView::OnAddButton);

   String computerName = computer.GetNetbiosName();

   DSOP_INIT_INFO initInfo;

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(&initInfo, sizeof initInfo);

   initInfo.cbSize = sizeof(initInfo);
   initInfo.flOptions = DSOP_FLAG_MULTISELECT;

   // aliasing the computerName internal pointer here -- ok, as lifetime
   // of computerName > initInfo

   initInfo.pwzTargetComputer =
      computer.IsLocal() ? 0 : computerName.c_str();

   // have the object picker fetch the group type attribute for us.  If user
   // objects are picked (which don't have this attribute), this is not a
   // problem: the result will simply indicate that the attribute value is
   // empty -- the returned variant will be VT_EMPTY.

   // @@for the machine scope, we also need the sid of the user, as a workaround
   // to bug 333491.  Q: I must ask for the SID for all objects (not just for
   // those from a single scope), so, do I incur a perf hit to get that
   // attribute?

   initInfo.cAttributesToFetch = 2;
   PWSTR attrs[3] = {0, 0, 0};

   CopyStringToNewWcharElement(attrs[0], ADSI::PROPERTY_GroupType);
   CopyStringToNewWcharElement(attrs[1], ADSI::PROPERTY_ObjectSID);

   // obtuse notation required to cast *in* const and away the static len

   initInfo.apwzAttributeNames = const_cast<PCWSTR*>(&attrs[0]); 

   switch (options)
   {
      case GROUP_MEMBERSHIP:
      {
         getGroupMembershipPickerSettings(
            initInfo.aDsScopeInfos,
            initInfo.cDsScopeInfos);
         break;
      }
      case USER_MEMBERSHIP:
      {
         getUserMembershipPickerSettings(
            initInfo.aDsScopeInfos,
            initInfo.cDsScopeInfos);
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   HRESULT hr =
      ObjectPicker::Invoke(
         view,
         ResultsCallback(*this),
         initInfo);
   delete[] initInfo.aDsScopeInfos;
   delete[] attrs[0];
   delete[] attrs[1];

   if (FAILED(hr))
   {
      popup.Error(view, hr, IDS_ERROR_LAUNCHING_PICKER);
   }
}



void
MembershipListView::AddPickerItems(DS_SELECTION_LIST& selections)
{
   LOG_FUNCTION(MembershipListView::AddPickerItems);

   DS_SELECTION* current = &(selections.aDsSelection[0]);

   for (ULONG i = 0; i < selections.cItems; i++, current++)
   {
      String name;
      String path;
      String cls;
      String upn;
      switch (options)
      {
         case USER_MEMBERSHIP:
         {
            ASSERT(current->pwzClass == ADSI::CLASS_Group);

            if (current->pwzClass == ADSI::CLASS_Group)
            {
               path = current->pwzADsPath;
               name = current->pwzName;   
               cls  = current->pwzClass;  
               upn.erase();
            }
            break;
         }
         case GROUP_MEMBERSHIP:
         {
            path = current->pwzADsPath;
            name = current->pwzName;   
            cls  = current->pwzClass;  
            upn  = current->pwzUPN;    
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
      
      if (!path.empty() && !cls.empty() && !name.empty())
      {
            LOG(L"Adding object " + path);

   // #ifdef DBG
   //          do
   //          {
   //             HRESULT hr = S_OK;
   //             IADs* obj = 0;
   //             hr = ::ADsGetObject(
   //                const_cast<wchar_t*>(path.c_str()),
   //                IID_IADs,
   //                (void**) &obj);
   //             BREAK_ON_FAILED_HRESULT(hr);
   // 
   //             BSTR p;
   //             hr = obj->get_ADsPath(&p);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             ::SysFreeString(p);
   // 
   //             BSTR n;
   //             hr = obj->get_Name(&n);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             ::SysFreeString(n);
   // 
   //             BSTR pr;
   //             hr = obj->get_Parent(&pr);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             ::SysFreeString(pr);
   // 
   //             _variant_t variant;
   //             hr = obj->Get(AutoBstr(ADSI::PROPERTY_GroupType), &variant);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             long type = variant;
   // 
   //             obj->Release();
   //          }
   //          while (0);
   // #endif


            // the only reason for this to be null is out-of-memory, which if
            // it occurs causes the object picker to fail (so we should not
            // reach this path)   

            ASSERT(current->pvarFetchedAttributes);

            // extract the GroupType of the object, if applicable

            long groupType = 0;
            if (V_VT(&current->pvarFetchedAttributes[0]) != VT_EMPTY)
            {
               ASSERT(cls.icompare(ADSI::CLASS_Group) == 0);
               _variant_t variant(current->pvarFetchedAttributes[0]);
               groupType = variant;
            }

            // extract the ObjectSID of the object (this should always be
            // present, but sometimes the object picker can't get it, so
            // check for empty)

            if (V_VT(&current->pvarFetchedAttributes[1]) == VT_EMPTY)
            {
               popup.Error(
                  view,
                  String::format(IDS_ITEM_INCOMPLETE, name.c_str()));
               continue;
            }
                  
            String sidPath;
            HRESULT hr =
               ADSI::VariantToSidPath(
                  &current->pvarFetchedAttributes[1],
                  sidPath);
                 
            if (itemPresent(sidPath))
            {
               popup.Info(
                  view,
                  String::format(
                     IDS_ITEM_ALREADY_PRESENT,
                     name.c_str()));
               continue;      
            }
                  
            // what do we do about a failure here?  ignore it, then in the
            // membership reconciliation code fall back to using the normal path.
            // That's making the best effort.

            MemberInfo* info = new MemberInfo;
            hr =
               info->InitializeFromPickerResults(
                  name,
                  path,
                  upn,
                  sidPath,
                  cls,
                  groupType,
                  computer.GetNetbiosName());

            // we don't expect this version of Initialize to ever fail, as it
            // is pretty much member-wise copy.  Anyway, if it did, there's
            // nothing we can do: we'll show the item anyway, even though
            // the type may be inaccurate.

            ASSERT(SUCCEEDED(hr));
            
            addItem(*info);
      }
   }
}



// Searches for a duplicate item by comparing sids.  Returns true if such
// an item is already present.
//
// sidPath - ADSI sid-style path of the item for which a duplicate should
// be searched.

bool
MembershipListView::itemPresent(const String& sidPath)
{
   LOG_FUNCTION(MembershipListView::itemPresent);

   LVITEM item;

   // REVIEWED-2002/03/04-sburns correct byte count passed
   
   ::ZeroMemory(&item, sizeof item);
   
   item.mask = LVIF_PARAM;

   for (int i = Win::ListView_GetItemCount(view) - 1; i >= 0; i--)
   {
      item.iItem = i;

      if (Win::ListView_GetItem(view, item))
      {
         ASSERT(item.lParam);

         MemberInfo* info = reinterpret_cast<MemberInfo*>(item.lParam);

         // we expect that the sid path is always present

         ASSERT(!info->sidPath.empty());
         
         if (sidPath.icompare(info->sidPath) == 0)
         {
            return true;
         }
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\memberinfo.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
// 
// MemberInfo class
// 
// 24 Jan 2000 sburns



#include "headers.hxx"
#include "MemberInfo.hpp"
#include "adsi.hpp"



// Return true if the paths refer to an object whose SID cannot be resolved,
// false otherwise.
// 
// adsPath - WinNT provider path to the object
// 
// sidPath - WinNT provider SID-style path to the object.

bool
IsUnresolvableSid(const String& adsPath, const String sidPath)
{
   LOG_FUNCTION2(IsUnresolvableSid, adsPath);

   bool result = false;

   if (sidPath == adsPath)
   {
      result = true;
   }

// // @@ here is a "temporary" workaround: no / found after the provider
// // prefix implies that the path is a SID-style path, paths of that
// // form are returned only by ADSI when the SID can't be resolved to a name.
// 
//    size_t prefixLen = ADSI::PROVIDER_ROOT.length();
//    if (
//          (adsPath.find(L'/', prefixLen) == String::npos)
//       && (adsPath.substr(prefixLen, 4) == L"S-1-") )
//    {
//       result = true;
//    }

   LOG(
      String::format(
         L"%1 %2 an unresolved SID",
         adsPath.c_str(),
         result ? L"is" : L"is NOT"));

   return result;
}
     


// return true if the specified path refers to an account that is local to
// the given machine, false if not.

bool
IsLocalPrincipal(
   const String&  adsiPath,
   const String&  machine,
   String&        container)
{
   LOG_FUNCTION2(IsLocalPrincipal, adsiPath);

   bool result = false;

   do
   {
      ADSI::PathCracker c1(adsiPath);

      String cp = c1.containerPath();
      if (cp.length() <= ADSI::PROVIDER_ROOT.length())
      {
         // There is no container.  This is the case with built-ins, like
         // Everyone.

         ASSERT(!result);
         break;
      }
   
      ADSI::PathCracker c2(cp);

      container = c2.leaf();
      result = (container.icompare(machine) == 0);
   }
   while (0);

   LOG(
      String::format(
         L"%1 local to %2",
         result ? L"is" : L"is NOT",
         machine.c_str()));
   LOG(container);
         
   return result;
}


   
HRESULT
MemberInfo::InitializeFromPickerResults(
   const String&           objectName,
   const String&           adsPath,
   const String&           upn_,
   const String&           sidPath_,
   const String&           adsClass,
   long                    groupTypeAttrVal,
   const String&           machine)
{
   LOG_FUNCTION(MemberInfo::InitializeFromPickerResults);
   ASSERT(!objectName.empty());
   ASSERT(!adsPath.empty());
   ASSERT(!adsClass.empty());
   ASSERT(!machine.empty());

   // sidPath and upn may be empty

   name    = objectName;             
   path    = adsPath;                
   upn     = upn_;                   
   sidPath = sidPath_;                
   type    = MemberInfo::UNKNOWN_SID;

   HRESULT hr = S_OK;
   do
   {
      if (IsUnresolvableSid(path, sidPath))
      {
         ASSERT(type == MemberInfo::UNKNOWN_SID);

         break;
      }

      // picker results have a reliable classname, unlike normal WinNT
      // membership enumeration.
      
      String container;
      bool isLocal = IsLocalPrincipal(path, machine, container);
      DetermineType(adsClass, machine, groupTypeAttrVal, true, isLocal);

      if (!isLocal)
      {
         DetermineOriginalName(machine, container);
      }
   }
   while (0);

   // we count on knowing the sid of the object to adjust group memberships.
   
   ASSERT(!sidPath.empty());

   return hr;
}


   
HRESULT
MemberInfo::Initialize(
   const String&                 objectName,
   const String&                 machine,
   const SmartInterface<IADs>&   object)
{
   LOG_FUNCTION(MemberInfo::Initialize);
   ASSERT(object);
   ASSERT(!machine.empty());
   ASSERT(!objectName.empty());

   name.erase();
   path.erase();
   sidPath.erase();
   type = MemberInfo::UNKNOWN_SID;
   upn.erase();

   HRESULT hr = S_OK;
   do
   {
      name = objectName;

      BSTR p = 0;
      hr = object->get_ADsPath(&p);
      BREAK_ON_FAILED_HRESULT(hr);
      path = p;
      ::SysFreeString(p);

      hr = ADSI::GetSidPath(object, sidPath);

      // check if the object refers to an unresolvable SID

      if (IsUnresolvableSid(path, sidPath))
      {
         ASSERT(type == MemberInfo::UNKNOWN_SID);

         break;
      }

      BSTR cls = 0;
      hr = object->get_Class(&cls);
      BREAK_ON_FAILED_HRESULT(hr);

      String c(cls);
      ::SysFreeString(cls);

      // determine the object type

      long type = 0;
      if (c.icompare(ADSI::CLASS_Group) == 0)
      {
         _variant_t variant;
         hr = object->Get(AutoBstr(ADSI::PROPERTY_GroupType), &variant);
         BREAK_ON_FAILED_HRESULT(hr);
         type = variant;
      }

      String container;
      bool isLocal = IsLocalPrincipal(path, machine, container);
      DetermineType(c, machine, type, false, isLocal);

      if (!isLocal)
      {
         DetermineOriginalName(machine, container);
      }
   }
   while (0);

   // we count on knowing the sid of the object to adjust group memberships.
   
   ASSERT(!sidPath.empty());
   
   return hr;
}   



void
MemberInfo::DetermineType(
   const String& className,
   const String& machine,
   long          groupTypeAttrVal,
   bool          canTrustClassName,
   bool          isLocal)
{
   LOG_FUNCTION2(
      MemberInfo::DetermineType,
      String::format(
         L"className=%1, machine=%2, groupTypeAttrVal=%3!X!",
         className.c_str(),
         machine.c_str(),
         groupTypeAttrVal));
   ASSERT(!className.empty());

   if (className.icompare(ADSI::CLASS_User) == 0 ||

       // InetOrgPerson needs to be supported as if it was a user.
       // The WINNT provider always returns inetOrgPerson objects
       // as users but the LDAP provider returns them as inetOrgPerson.
       // NTRAID#NTBUG9-436314-2001/07/16-jeffjon

       className.icompare(ADSI::CLASS_InetOrgPerson) == 0)
   {
      // determine the name of the container.  If the name of the container
      // is the same as the machine name, then the user is a local account.
      // We can make this assertion because it is illegal to have a machine
      // with the same name as a domain on the net at the same time.
      // 349104

      if (isLocal)
      {
         type = MemberInfo::USER;
      }
      else
      {
         // when enumerating the group membership, the class name is always
         // User. The only way to distinguish a user from a computer
         // is by the trailing $ convention, which is not perfect, as it is
         // legal to create a user account with a trailing $.

         // CODEWORK: we could disambiguate this situation by attempting to
         // bind to the object in question and asking it for its object class.
         // I'm not inclined to do that, really, since 1) I'm lazy, and 2) it
         // introduces new failure modes (what if the logged on user has
         // insufficient creds to bind to the object?)
         
         // REVIEW: [path[path.length() - 1] is the same as *(path.rbegin())
         // which is cheaper?
         
         if (!canTrustClassName && (path[path.length() - 1] == L'$'))
         {
            type = MemberInfo::COMPUTER;
         }
         else
         {
            type = MemberInfo::DOMAIN_USER;
         }
      }
   }
   else if (className.icompare(ADSI::CLASS_Group) == 0)
   {
      // examine the group type attribute's value

      // mask off all but the last byte of the value, in case this group
      // was read from the DS, which sets other bits not of interest to
      // us.

      groupTypeAttrVal = groupTypeAttrVal & 0x0000000F;

      if (groupTypeAttrVal == ADS_GROUP_TYPE_LOCAL_GROUP)
      {
         // it's possible that the group is a domain local group, not a
         // machine local group.

         LOG(L"Member is a local group, but local to what?");
      
         type = isLocal ? MemberInfo::GROUP : MemberInfo::DOMAIN_GROUP;
      }
      else
      {
         // of the n flavors of groups, I'm not expecting anything else but
         // the global variety.

         LOG(L"Member is a global group");
         ASSERT(
               (groupTypeAttrVal == ADS_GROUP_TYPE_GLOBAL_GROUP)
            || (groupTypeAttrVal == ADS_GROUP_TYPE_UNIVERSAL_GROUP) );

         type = MemberInfo::DOMAIN_GROUP;
      }
   }
   else if (className.icompare(ADSI::CLASS_Computer) == 0)
   {
      // The only computer objects will be those from domains.

      ASSERT(!isLocal);

      type = MemberInfo::COMPUTER;
   }
   else
   {
      type = MemberInfo::UNKNOWN_SID;

      ASSERT(false);
   }
}




// Finds a domain controller for the given domain, first consulting a cache,
// since this search is expensive (especially if it fails).  Returns S_OK on
// success, or an error code on failure.
// 
// domainName - name of the domain for which a controller is to be found.
// 
// dcName - out, receives the domain controller name if the search was
// successful, or the empty string if the search failed.
   
// this has to be defined outside of the GetDcNameFromCache function so
// that it is a type with linkage, which is required to be a template arg.

struct CacheEntry
{
   String  dcName;
   HRESULT getDcNameResult;
};

HRESULT
GetDcNameFromCache(const String& domainName, String& dcName)
{
   LOG_FUNCTION2(GetDcNameFromCache, domainName);
   ASSERT(!domainName.empty());

   typedef
      std::map<
         String,
         CacheEntry,
         String::LessIgnoreCase,
         Burnslib::Heap::Allocator<String> >
      DcNameMap;

   // Note that this is a global DLL static, which means that all instances of
   // the snapin in the same process share this cache, and that the cache
   // persists across snapin retargeting.

   // Note too that we cache negative results -- that a dc is not found -- and
   // so once we determine that a dc is not reachable for a domain, if one
   // does come online after that point, we will not find it.  So it will only
   // be looked for if our dll is unloaded (which dumps this cache).
      
   static DcNameMap nameMap;

   dcName.erase();
   HRESULT hr = S_OK;
   DOMAIN_CONTROLLER_INFO* info = 0;
   
   do
   {
      DcNameMap::iterator i = nameMap.find(domainName);
      if (i != nameMap.end())
      {
         // present.

         LOG(L"cache hit");

         CacheEntry& e = i->second;
         hr = e.getDcNameResult;
         if (SUCCEEDED(hr))
         {
            dcName = e.dcName;
         }
         break;
      }
         
      // not present, so go look for it.

      hr =
         MyDsGetDcName(
            0,
            domainName,
            0,
            info);
      CacheEntry e;
      e.getDcNameResult = hr;

      if (info && info->DomainControllerName)
      {
         e.dcName = info->DomainControllerName;
         dcName = e.dcName;
      }
      
      LOG(L"caching " + dcName);

      nameMap.insert(std::make_pair(domainName, e));
   }
   while (0);

   if (info)
   {
      ::NetApiBufferFree(info);
   }

   LOG(dcName);
   LOG_HRESULT(hr);

   return hr;
}
         


// Determine the name of the domain from whence a given account originates.
// Returns S_OK on success, S_FALSE if the account is a well-known account, or
// an error code on failure.  The most likely failure is that the domain could
// not be determined.
// 
// targetComputer - the name of the machine that the snapin is targeted at.
// Lookups are remoted to that machine so that the results are the same as if
// the snapin was running local to that machine.
// 
// accountSid - SID of the account for which the domain should be determined.
// 
// domainName - out, receives the name of the domain when the return value is
// S_OK, empty string otherwise.
         
HRESULT
GetDomainNameFromAccountSid(
   const String&  targetComputer,
   PSID           accountSid,
   String&        domainName)
{
   LOG_FUNCTION(GetDomainNameFromAccountSid);
   domainName.erase();

   HRESULT hr = S_OK;

   do
   {
      BYTE sidBuf[SECURITY_MAX_SID_SIZE];
      
      PSID domainSid = (PSID) sidBuf;
      DWORD sidSize = sizeof sidBuf;
      BOOL succeeded =
         ::GetWindowsAccountDomainSid(
            accountSid,
            domainSid,
            &sidSize);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }
            
      ASSERT(sidSize <= SECURITY_MAX_SID_SIZE);

      // If this lookup fails, then the domain can't be resolved. We know
      // that we don't have an unresolvable acct sid due to the type (see
      // the Initialize... methods), thus, the account was found in some
      // domain -- just not the one that the sid refers to.  So we can
      // infer that this is a migrated account and the source domain is
      // defunct.

      String unused;
      hr =
         Win::LookupAccountSid(

            // need to make sure we do the lookup on the computer that
            // we're targeted to, in case we're running remotely.
         
            targetComputer,
            domainSid,
            unused,
            domainName);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   // ADSI::FreeSid(domainSid);

   LOG(domainName);
   LOG_HRESULT(hr);

   return hr;
}



// Looks up the "original name" of an account that was migrated from one
// domain to another using the sid history mechanism (via clone principal or
// ADMT, or equivalent).  The "original name" is the name corresponding to the
// account SID in the domain that issued the SID.
// 
// Returns S_OK on success, S_FALSE if the account is a well-known account, or
// an error code on failure.  The most likely failure is that the domain could
// not be determined.
//
// targetComputer - the name of the machine that the snapin is targeted at.
// Lookups are remoted to that machine so that the results are the same as if
// the snapin was running local to that machine.
//
// sidPath - the sid-style WinNT provider path of the account
// 
// container - the container portion of the WinNT path of the account.  This
// is the domain name of the account, which, if the account was migrated, will
// be the domain the account was migrated to.
// 
// origName - out, receives the name of the domain when the return value is
// S_OK, empty string otherwise.

HRESULT
GetOriginalName(
   const String& targetComputer,
   const String& sidPath,
   const String& container,
   String&       origName)
{
   LOG_FUNCTION2(GetOriginalName, sidPath);
   ASSERT(!sidPath.empty());
   ASSERT(!container.empty());

   origName.erase();
   HRESULT hr         = S_OK;
   PSID    accountSid = 0;   
   
   do
   {
      // remove the provider prefix from the string

      String sidStr = sidPath.substr(ADSI::PROVIDER_ROOT.length());

      // To look up the original name, we will need to determine the domain
      // name from whence that account sid came. We will get that domain name
      // by looking up the domain sid (which is the prefix of the account
      // sid).

      hr = Win::ConvertStringSidToSid(sidStr, accountSid);
      BREAK_ON_FAILED_HRESULT(hr);

      String domainName;
      hr =
         GetDomainNameFromAccountSid(
            targetComputer,
            accountSid,
            domainName);
      if (hr == S_FALSE || FAILED(hr))
      {
         // can't determine the name, or it refers to a well-known sid.
         
         ASSERT(origName.empty());
         break;
      }

      ASSERT(!domainName.empty());

      // The container of the account is a domain name, we know this because
      // the type of the account is one of the domain types (checked in the
      // calling function)

      if (domainName.icompare(container) == 0)
      {
         // The account really is from the domain indicated by its path; it
         // is not a migrated account, and therefore has no original name.

         LOG(L"account was not migrated");
         
         ASSERT(origName.empty());
         hr = S_FALSE;
         break;
      }

      // The domain names did not match, so look up the account sid on a
      // domain controller from the domain indicated by its sid, rather than
      // on the domain controller that the target machine is joined to.
      // This will yield the original account name and domain.

      String dcName;         
      hr = GetDcNameFromCache(domainName, dcName);
      if (FAILED(hr))
      {
         ASSERT(origName.empty());
         break;
      }

      String origAccount;
      String origDomain;
      hr =
         Win::LookupAccountSid(
            dcName,
            accountSid,
            origAccount,
            origDomain);
      BREAK_ON_FAILED_HRESULT(hr);

      // the domain names should match, since that's what we started with.
            
      ASSERT(origDomain.icompare(domainName) == 0);

      // but the name should not be the same as the name given by the win2k
      // domain controller.
      
      ASSERT(origDomain.icompare(container) != 0);
       
      origName = origDomain + L"\\" + origAccount;
   }
   while (0);

   Win::LocalFree(accountSid);

   LOG(origName);
   LOG_HRESULT(hr);

   return hr;
}



// Part of instance initialization, determines the original name of an
// account, if the account sid was one migrated from one domain to another.   
//
// targetComputer - the name of the machine that the snapin is targeted at.
// Lookups are remoted to that machine so that the results are the same as if
// the snapin was running local to that machine.
//
// container - the container portion of the WinNT path of the account.  This
// is the domain name of the account, which, if the account was migrated, will
// be the domain the account was migrated to.

void
MemberInfo::DetermineOriginalName(
   const String& targetComputer,
   const String& container)
{
   LOG_FUNCTION2(MemberInfo::DetermineOriginalName, container);

   do
   {
      if (sidPath.empty())
      {
         // we can't do any lookups without a sid
         
         ASSERT(origName.empty());
         break;
      }

      if (container.empty())
      {
         // we can't determine if an account is migrated if we have no
         // idea where it was migrated to.  If the container is empty, it's
         // probably a well-known SID like Everyone.
         
         ASSERT(origName.empty());
         break;
      }

      if (
            type != MemberInfo::DOMAIN_USER
         && type != MemberInfo::DOMAIN_GROUP)
      {
         // only domain accounts can be cloned, and therefore have an
         // original name.

         ASSERT(origName.empty());         
         break;
      }

      // If the name of the domain that we find from the domain part of the
      // account sid does not match the name of the domain in the non-sid
      // path, then the sid was migrated and the account has an original name.
      // 
      // (We could also look up the sid of the domain from the non-sid path,
      // and compare it to the domain sid from the sid path, and if they don't
      // match then the account was migrated, but we'll need the domain
      // name in case they don't match.)
      // 
      // If these lookups fail, then we'll call the original name the sid of
      // the account, so at least the user has something to indicate that the
      // account is not really from the domain that its name indicates.
      // 
      // We expect that it's reasonably likely that the lookups will fail, as
      // the original domain may be defunct.

      HRESULT hr =
         GetOriginalName(targetComputer, sidPath, container, origName);
      if (FAILED(hr))
      {
         origName = sidPath.substr(ADSI::PROVIDER_ROOT.length());
      }
   }
   while (0);

   LOG(origName);
}
            


// Compare strings using the same flags used by the SAM on workstations.
// 365500

LONG
SamCompatibleStringCompare(const String& first, const String& second)
{
   LOG_FUNCTION(SamCompatibleStringCompare);

   // SAM creates local accounts by creating a key in the registry, and the
   // the name comparision semantics are exactly those of registry keys, and
   // RtlCompareUnicodeString is the API that implements those semantics.

   UNICODE_STRING s1;
   UNICODE_STRING s2;

   // ISSUE-2002/03/04-sburns consider replacing with RtlInitUnicodeStringEx
   
   ::RtlInitUnicodeString(&s1, first.c_str());
   ::RtlInitUnicodeString(&s2, second.c_str());   

   return ::RtlCompareUnicodeString(&s1, &s2, TRUE);
}
   


bool
MemberInfo::operator==(const MemberInfo& rhs) const
{
   if (this != &rhs)
   {
      // since multiple SIDs may resolve to the same account name due to 
      // sid history, this comparison must be on the sids.

      if (!sidPath.empty() && !rhs.sidPath.empty())
      {
         return (sidPath.icompare(rhs.sidPath) == 0);
      }
      else
      {
         // we expect that the sidPath always be present
         
         ASSERT(false);
         return (SamCompatibleStringCompare(path, rhs.path) == 0);
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\membervisitor.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MemberVisitor class
// 
// 11-14-97 sburns



#ifndef MEMBERVISITOR_HPP_INCLUDED
#define MEMBERVISITOR_HPP_INCLUDED



#include "adsi.hpp"



// Binds to a MemberList, and populates it with it's visit method.

class MemberVisitor : public ADSI::ObjectVisitor
{
   public:

   // Creates a new instance.
   //
   // members - the list to receive the elements in the enumeration.
   //
   // parent - the parent window to be used for error reporting.
   //
   // containerName - the name of the container whose members are being
   // visited (a user or group).  Used for error reporting.
   //
   // machineName - the name of the machine that owns the container.

   MemberVisitor(
      MemberList&    members,
      HWND           parent,
      const String&  containerName,
      const String&  machineName);

   virtual
   ~MemberVisitor();

   virtual
   void
   Visit(const SmartInterface<IADs>& object);

   private:

   // not implemented: no copying allowed
   MemberVisitor(const MemberVisitor&);
   const MemberVisitor& operator=(const MemberVisitor&);

   MemberList& members;
   HWND        parent;
   String      container_name;
   String      machine;
};



#endif   // MEMBERVISITOR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\mmcprop.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MMCProperty Page base class 
// 
// 12-4-97 sburns



#include "headers.hxx"
#include "mmcprop.hpp"
#include "scopnode.hpp"



MMCPropertyPage::NotificationState::NotificationState(
   LONG_PTR                         MMCNotifyHandle,
   const SmartInterface<ScopeNode>& scopeNode_)
   :
   mmcNotifyHandle(MMCNotifyHandle),
   scopeNode(scopeNode_),
   sendNotify(false)
{
   LOG_CTOR(MMCPropertyPage::NotificationState);
   ASSERT(scopeNode);

   // MMCNotifyHandle may be 0
}

   

MMCPropertyPage::NotificationState::~NotificationState()
{
   LOG_DTOR(MMCPropertyPage::NotificationState);

   if (mmcNotifyHandle)
   {
      if (sendNotify)
      {
         // this causes MMCN_PROPERTY_CHANGE to be sent to the IComponent that
         // created the prop sheet.  Since that component may have changed
         // it's selected scope node while the sheet was up, we pass along a
         // pointer to the node that was selected when the sheet was created.

         // AddRef the scopeNode in case we hold the last reference to the
         // scopeNode. If that happens, then there is a race condition between
         // us Releasing the last reference (a side effect of the dtor for
         // scopeNode), and the use of the node in the MMCN_PROPERTY_CHANGE
         // handler in Component, which is in a different thread.  We will
         // have the last reference if the user opens a prop sheet, collapses
         // the scope tree (by retargeting Computer Management, say), then
         // changes the prop sheet.
         //
         // The MMCN_PROPERTY_CHANGE handler will Release this reference.
         // 
         // NTRAID#NTBUG9-431831-2001/07/06-sburns
         
         scopeNode->AddRef();
         
         MMCPropertyChangeNotify(
            mmcNotifyHandle,
            reinterpret_cast<MMC_COOKIE>((ScopeNode*) scopeNode));
      }
      MMCFreeNotifyHandle(mmcNotifyHandle);
   }
}



bool
MMCPropertyPage::NotificationState::ResultsRebuilt() const 
{
   LOG_FUNCTION(MMCPropertyPage::NotificationState::ResultsRebuilt);

   return resultsRebuilt;
}



void
MMCPropertyPage::NotificationState::SetResultsRebuilt()
{
   LOG_FUNCTION(MMCPropertyPage::NotificationState::SetResultsRebuilt);

   // should only be called once
   ASSERT(!resultsRebuilt);
   resultsRebuilt = true;
}



void
MMCPropertyPage::NotificationState::SetSendNotify()
{
   LOG_FUNCTION(MMCPropertyPage::NotificationState::SetSendNotify);

   sendNotify = true;
}



MMCPropertyPage::MMCPropertyPage(
   int                  dialogResID,
   const DWORD          helpMap[],
   NotificationState*   state_)
   :
   PropertyPage(dialogResID, helpMap),
   state(state_),
   owns_state(false)
{
   LOG_CTOR(MMCPropertyPage);
   ASSERT(state);
}



MMCPropertyPage::~MMCPropertyPage()
{
   LOG_DTOR(MMCPropertyPage);

   if (owns_state)
   {
      delete state;
   }
}



void
MMCPropertyPage::SetStateOwner()
{
   LOG_FUNCTION(MMCPropertyPage::SetStateOwner);

   // shouldn't set more than once
   ASSERT(!owns_state);
   owns_state = true;
}



void
MMCPropertyPage::SetChangesApplied()
{
   LOG_FUNCTION(MMCPropertyPage::SetChangesApplied);

   state->SetSendNotify();

   // Don't call this, it causes more problems than it's worth.
   // NTRAID#NTBUG9-489276-2001/11/05-sburns
   // Win::PropSheet_CancelToClose(Win::GetParent(hwnd));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\mseldo.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MultiSelectDataObject class
// 
// 11-14-97 sburns



#ifndef MSELDO_HPP_INCLUDED
#define MSELDO_HPP_INCLUDED



#include "resnode.hpp"



class MultiSelectDataObject : public IDataObject
{
   public:

   static const String CF_PTR;

   typedef
      std::list<ResultNode*, Burnslib::Heap::Allocator<ResultNode*> >
      DependentList;

   typedef DependentList::iterator iterator;

   MultiSelectDataObject();

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IDataObject overrides

   virtual
   HRESULT __stdcall
   GetData(FORMATETC* formatetcIn, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   QueryGetData(FORMATETC* pformatetc);

   virtual
   HRESULT __stdcall
   GetCanonicalFormatEtc(FORMATETC* formatectIn, FORMATETC* formatetcOut);

   virtual
   HRESULT __stdcall  
   SetData(FORMATETC* formatetc, STGMEDIUM* medium, BOOL release);

   virtual
   HRESULT __stdcall
   EnumFormatEtc(DWORD direction, IEnumFORMATETC** ppenumFormatEtc);

   virtual
   HRESULT __stdcall
   DAdvise(
      FORMATETC*     formatetc,
      DWORD          advf,
      IAdviseSink*   advSink,
      DWORD*         connection);

   virtual
   HRESULT __stdcall
   DUnadvise(DWORD connection);

   virtual
   HRESULT __stdcall
   EnumDAdvise(IEnumSTATDATA** ppenumAdvise);

   // MultiSelectDataObject methods

   void
   AddDependent(ResultNode* node);

   iterator
   begin() const;

   iterator
   end() const;

   private:

   // only we can delete ourselves
   
   virtual
   ~MultiSelectDataObject();

   // not implemented: no copying allowed.
   MultiSelectDataObject(const MultiSelectDataObject&);
   const MultiSelectDataObject& operator=(const MultiSelectDataObject&);

   DependentList        dependents;
   ComServerReference   dllref;
   long                 refcount;
};



#endif   // MSELDO_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\newuser.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateUserDialog class
// 
// 10-15-97 sburns



#ifndef NEWUSER_HPP_INCLUDED
#define NEWUSER_HPP_INCLUDED



#include "dialog.hpp"



class CreateUserDialog : public Dialog
{
   public:

   // Constructs a new instance.
   //
   // machine - in, internal (netbios) computer name of the machine on which
   // users will be created.

   CreateUserDialog(const String& machine);

   virtual ~CreateUserDialog();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   bool
   CreateUser();

   String machine;
   bool   refreshOnExit;

   // not defined: no copying allowed

   CreateUserDialog(const CreateUserDialog&);
   const CreateUserDialog& operator=(const CreateUserDialog&);
};



#endif   // NEWUSER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\mmcprop.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MMC-Aware Property Page base class
// 
// 12-4-97 sburns



#ifndef MMCPROP_HPP_INCLUDED
#define MMCPROP_HPP_INCLUDED



class ScopeNode;



// MMCPropertyPage extends PropertyPage, providing facilities for dealing with
// MMCNotifyHandles via a nested class NotificationState.

class MMCPropertyPage : public PropertyPage
{
   public:

   // Wraps up an MMCNotifyHandle, and manages triggering change notifications
   // to the console.  Each MMCPropertyPage in a sheet has a reference to the
   // same NotificationState object, but only one (usually the first) page is
   // designated as the owner of that state object.  When the owner page is
   // destroyed, it destroys the state object, upon which any change
   // notification is sent to the console.

   class NotificationState
   {
      friend class Component;
      friend class MMCPropertyPage;

      public:

      // MMCNotifyHandle - the MMC notification handle supplied to
      // IComponent::CreatePropertyPages.
      //
      // scopeNode - the selected ScopeNode when the prop sheet was built.
      // When change notification is sent to the IComponent that created the
      // sheet, this pointer is send as a parameter.

      NotificationState(
         LONG_PTR                         MMCNotifyHandle,
         const SmartInterface<ScopeNode>& scopeNode);

      private:

      // only MMCPropertyPage should delete us.
      ~NotificationState();

      // called by Component

      bool
      ResultsRebuilt() const;

      // called by Component

      void
      SetResultsRebuilt();

      // only ProperyPages should call this.

      void
      SetSendNotify();

      // not implemented: no copying allowed
      NotificationState(const NotificationState&);
      const NotificationState& operator=(const NotificationState&);

      LONG_PTR                  mmcNotifyHandle;
      bool                      sendNotify;      
      bool                      resultsRebuilt;  
      SmartInterface<ScopeNode> scopeNode;       
   };
            
   // Indicates that this page owns the notification state, and will destroy
   // that state when the page is destroyed.  Only one page in a prop sheet
   // should do this, or MMC will croak.  (Wonderful, huh?)

   void
   SetStateOwner();

   protected :

   // Derived classes should call this function when changes to the object
   // they edit have been made, and the console should be informed of the
   // change.  A good place to do this is in the OnApply function.

   void
   SetChangesApplied();

   // Constructs a new instance.  Declared protected so that this class
   // only functions as base class
   // 
   // dialogResID - see base class ctor.
   // 
   // helpMap - see base class ctor.
   //
   // state - notification state object that is shared among pages in a
   // sheet.  Only one page should be designated as the owner of the
   // notification state, which ownership is signalled by calling
   // SetStateOwner.

   MMCPropertyPage(
      int                  dialogResID,
      const DWORD          helpMap[],
      NotificationState*   state);

   virtual ~MMCPropertyPage();

   private:

   // not implemented: no copying allowed
   MMCPropertyPage(const MMCPropertyPage&);
   const MMCPropertyPage& operator=(const MMCPropertyPage&);

   NotificationState*   state;
   bool                 owns_state;
};



#endif   // MMCPROP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\newuser.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateUserDialog class
// 
// 10-15-97 sburns



#include "headers.hxx"
#include "newuser.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_USER_NAME,                idh_createuser_user_name,
   IDC_FULL_NAME,                idh_createuser_full_name,
   IDC_DESCRIPTION,              idh_createuser_description,
   IDC_PASSWORD,                 idh_createuser_password,
   IDC_CONFIRM,                  idh_createuser_confirm_password,
   IDC_MUST_CHANGE_PASSWORD,     idh_createuser_change_password,
   IDC_CANNOT_CHANGE_PASSWORD,   idh_createuser_user_cannot_change,
   IDC_NEVER_EXPIRES,            idh_createuser_password_never_expires,
   IDC_DISABLED,                 idh_createuser_account_disabled,
   IDC_CREATE,                   idh_createuser_create_button,
   IDCANCEL,                     idh_createuser_close_button,
   0, 0
};



CreateUserDialog::CreateUserDialog(const String& machine_)
   :
   Dialog(IDD_CREATE_USER, HELP_MAP),
   machine(machine_),
   refreshOnExit(false)
{
   LOG_CTOR(CreateUserDialog);
      
   ASSERT(!machine.empty());      
}
      


CreateUserDialog::~CreateUserDialog()
{
   LOG_DTOR(CreateUserDialog);
}



static
void
enable(HWND dialog)
{
   LOG_FUNCTION(enable);
   ASSERT(Win::IsWindow(dialog));

   bool enable_create_button =
      !Win::GetTrimmedDlgItemText(dialog, IDC_USER_NAME).empty();
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CREATE),
      enable_create_button);

   DoUserButtonEnabling(
      dialog,
      IDC_MUST_CHANGE_PASSWORD,
      IDC_CANNOT_CHANGE_PASSWORD,
      IDC_NEVER_EXPIRES);
}


     
static
void
reset(HWND dialog)
{
   LOG_FUNCTION(reset);
   ASSERT(Win::IsWindow(dialog));
   
   String blank;

   Win::SetDlgItemText(dialog, IDC_USER_NAME, blank);
   Win::SetDlgItemText(dialog, IDC_FULL_NAME, blank);
   Win::SetDlgItemText(dialog, IDC_DESCRIPTION, blank);
   Win::SetDlgItemText(dialog, IDC_PASSWORD, blank);
   Win::SetDlgItemText(dialog, IDC_CONFIRM, blank);
   Win::CheckDlgButton(dialog, IDC_MUST_CHANGE_PASSWORD, BST_CHECKED);
   Win::CheckDlgButton(dialog, IDC_CANNOT_CHANGE_PASSWORD, BST_UNCHECKED);
   Win::CheckDlgButton(dialog, IDC_NEVER_EXPIRES, BST_UNCHECKED);
   Win::CheckDlgButton(dialog, IDC_DISABLED, BST_UNCHECKED);

   Win::SetFocus(Win::GetDlgItem(dialog, IDC_USER_NAME));

   enable(dialog);
}



void
CreateUserDialog::OnInit()
{
   LOG_FUNCTION(CreateUserDialog::OnInit());

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_USER_NAME), LM20_UNLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_FULL_NAME), MAXCOMMENTSZ);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);    // 420889
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PASSWORD), PWLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_CONFIRM), PWLEN);

   reset(hwnd);
}



bool
CreateUserDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(CreateUserDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_MUST_CHANGE_PASSWORD:
      case IDC_CANNOT_CHANGE_PASSWORD:
      case IDC_NEVER_EXPIRES:
      {
         if (code == BN_CLICKED)
         {
            enable(hwnd);
         }
         break;
      }
      case IDC_USER_NAME:
      {
         if (code == EN_CHANGE)
         {
            enable(hwnd);

            // In case the close button took the default style when the create
            // button was disabled. (e.g. tab to close button while create is
            // disabled, then type in the name field, which enables the
            // button, but does not restore the default style unless we do
            // it ourselves)
            Win::Button_SetStyle(
               Win::GetDlgItem(hwnd, IDC_CREATE),
               BS_DEFPUSHBUTTON,
               true);
         }
         break;
      }
      case IDC_CREATE:
      {
         if (code == BN_CLICKED)
         {
            if (CreateUser())
            {
               refreshOnExit = true;               
               reset(hwnd);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, refreshOnExit);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
   }

   return true;
}



HRESULT
GetLocalUsersGroupName(const String& machine, String& result)
{
   LOG_FUNCTION2(GetLocalUsersGroupName, machine);
   ASSERT(!machine.empty());

   result.erase();

   HRESULT hr = S_OK;

   do
   {
      // build the SID for the well-known Users local group.

      PSID sid = 0;
      SID_IDENTIFIER_AUTHORITY authority = SECURITY_NT_AUTHORITY;

      // REVIEWED-2002/03/04-sburns no issues evident
      
      hr =
         Win::AllocateAndInitializeSid(
            authority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_USERS,
            0,
            0,
            0,
            0,
            0,
            0,
            sid);
      BREAK_ON_FAILED_HRESULT(hr);

      String domain;

      // REVIEWED-2002/03/04-sburns wrapper deals with buffer issues.
      
      hr = Win::LookupAccountSid(machine, sid, result, domain);

      Win::FreeSid(sid);
   }
   while (0);

   return hr;
}




// Verifies that the candidate new user account name is syntactically valid.
// If not, displays an error message to the user, and returns false.
// Otherwise, returns true.
// 
// dialog - in, parent window for the error message dialog, also the window
// containing the edit box for the user name, which is identified by
// editResId.
// 
// name - in, candidate new user account name.
// 
// machineName - in, internal computer name of the machine on which the
// account will be created.
// 
// editResId - in, the resource identifier of the edit box of the parent
// window (given by the dialog parameter) that contains the new user name.
// This control is given focus on error.

bool
ValidateNewUserName(
   HWND           dialog,
   const String&  name,
   const String&  machineName,
   int            editResId)
{
   LOG_FUNCTION(ValidateNewUserName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(!machineName.empty());
   ASSERT(editResId > 0);

   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         dialog,
         editResId,
         String::format(IDS_BAD_SAM_NAME, name.c_str()));
      return false;
   }

   // Disallow user account names with the same name as the netbios computer
   // name. This causes some apps to get confused the the <03> and <20>
   // registrations.
   // NTRAID#NTBUG9-324794-2001/02/26-sburns

   if (name.icompare(machineName) == 0)
   {
      popup.Gripe(
         dialog,
         editResId,
         String::format(
            IDS_USERNAME_CANT_BE_COMPUTER_NAME,
            machineName.c_str()));
      return false;
   }

   return true;
}



// returns true on successful creation of the user, false otherwise

bool
CreateUserDialog::CreateUser()
{
   LOG_FUNCTION(CreateUserDialog::CreateUser);

   Win::CursorSetting cursor(IDC_WAIT);

   HRESULT hr = S_OK;

   String name = Win::GetTrimmedDlgItemText(hwnd, IDC_USER_NAME);

   // shouldn't be able to poke the Create button if this is empty
   ASSERT(!name.empty());

   if (
         !ValidateNewUserName(hwnd, name, machine, IDC_USER_NAME)
      || !IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM))
   {
      return false;
   }

   SmartInterface<IADsUser> user(0);
   do
   {
      // get a pointer to the machine container
      
      String container_path = ADSI::ComposeMachineContainerPath(machine);
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(container_path, container);
      BREAK_ON_FAILED_HRESULT(hr);

      // create a user object in that container
      
      hr = ADSI::CreateUser(container, name, user);
      BREAK_ON_FAILED_HRESULT(hr);

      // must set full name before setting password in order for all
      // "bad password" checks to be made (some of which prevent passwords
      // that contain part of the the full name)
      // NTRAID#NTBUG9-221152-2000/11/14-sburns
      
      String fullName = Win::GetTrimmedDlgItemText(hwnd, IDC_FULL_NAME);
      if (!fullName.empty())
      {
         hr = user->put_FullName(AutoBstr(fullName));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      // Don't trim the password field.
      // NTRAID#NTBUG9-434037-2001/07/11-sburns

      EncryptedString pass =
         Win::GetEncryptedDlgItemText(hwnd, IDC_PASSWORD);
      if (!pass.IsEmpty())
      {
         PWSTR cleartext = pass.GetClearTextCopy();
         if (!cleartext)
         {
            // fail the create rather than set a null password.
            
            hr = E_OUTOFMEMORY;
            BREAK_ON_FAILED_HRESULT(hr);
         }          
         
         hr = user->SetPassword(AutoBstr(cleartext));

         pass.DestroyClearTextCopy(cleartext);
         
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // commit the create.  The account will be created as disabled until
      // it meets all policy restrictions
      
      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, String());
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, String());

      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_CREATING_USER,
            name.c_str(),
            machine.c_str()));
            
      if (hr == Win32ToHresult((DWORD) NERR_UserExists))
      {
         Win::SetFocus(Win::GetDlgItem(hwnd, IDC_USER_NAME));
      }
      else if (hr == Win32ToHresult((DWORD) NERR_PasswordTooShort))
      {
         Win::SetFocus(Win::GetDlgItem(hwnd, IDC_PASSWORD));
      }
      
      return false;      
   }

   // save the user's properties.
   
   do
   {
      String desc = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);
      bool must_change   = Win::IsDlgButtonChecked(hwnd, IDC_MUST_CHANGE_PASSWORD);  
      bool disable       = Win::IsDlgButtonChecked(hwnd, IDC_DISABLED);              
      bool cant_change   = Win::IsDlgButtonChecked(hwnd, IDC_CANNOT_CHANGE_PASSWORD);
      bool never_expires = Win::IsDlgButtonChecked(hwnd, IDC_NEVER_EXPIRES);         

      hr = 
         SaveUserProperties(
            user,
            0,    // already saved full name
            desc.empty() ? 0 : &desc,
            &disable,
            &must_change,
            &cant_change,
            &never_expires,
            0); // locked is never set here
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_USER_PROPERTIES,
            name.c_str(),
            machine.c_str()));
      return false;
   }

   // add the new user to the Users built-in group
   String usersGroupName;
   do
   {
      BSTR path = 0;
      hr = user->get_ADsPath(&path);
      BREAK_ON_FAILED_HRESULT(hr);

      String userPath = path;
      ::SysFreeString(path);
      
      // The name of the local built-in users group may have been changed
      // or be translated to a different locale that of the machine running
      // the snapin.  We need to determine the name of that group, then
      // use it to form the WinNT path for it.
         
      hr = GetLocalUsersGroupName(machine, usersGroupName);
      BREAK_ON_FAILED_HRESULT(hr);

      // use the user's path as the basis of the users group path, as this
      // will contain the domain and machine name as appropriate, thus helping
      // poor ADSI out in locating the object (resulting in a faster bind to
      // the group.

      ADSI::PathCracker cracker(userPath);

      String usersGroupPath =
            cracker.containerPath()
         +  ADSI::PATH_SEP
         +  usersGroupName
         +  L","
         +  ADSI::CLASS_Group;

      // Get the sid-style path of the user.  We'll use that form of the
      // path to work around 333491.

      SmartInterface<IADs> iads(0);
      hr = iads.AcquireViaQueryInterface(user);
      BREAK_ON_FAILED_HRESULT(hr);

      String sidPath;
      hr = ADSI::GetSidPath(iads, sidPath);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IADsGroup> group(0);

      hr = ADSI::GetGroup(usersGroupPath, group);
      if (SUCCEEDED(hr))
      {
         hr = group->Add(AutoBstr(sidPath));
      }
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_ASSIGNING_NEW_USER_TO_USERS_GROUP,
            name.c_str(),
            usersGroupName.c_str()));

      // return true to cause the create to be considered successful.
      return true;      
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\node.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Node class
// 
// 9-2-97 sburns



#include "headers.hxx"
#include "node.hpp"
#include "uuids.hpp"
#include <localsec.h>



#define LOG_NODE_TYPE                                                  \
   if (IsEqualGUID(type, NODETYPE_RootFolder))                           \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"RootFolder");                         \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_UsersFolder))                     \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"UsersFolder");                        \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_GroupsFolder))                    \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"GroupsFolder");                       \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_User))                            \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"User");                               \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_Group))                           \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"Group");                              \
   }                                                                     \
   else                                                                  \
   {                                                                     \
      ASSERT(false);                                                     \
      LOGT(Log::OUTPUT_LOGS, L"unknown GUID!");                      \
   }                                                                     \



const String Node::CF_NODEPTR(L"Local User Manager Node Pointer");



Node::Node(
   const SmartInterface<ComponentData>&   owner_,
   const NodeType&                        nodeType)
   :
   owner(owner_),
   type(nodeType),
   refcount(1)          // implicit AddRef
{
   LOG_CTOR(Node);
}



Node::~Node()
{
   LOG_DTOR2(Node, String::format(L"0x%1!08X!", (MMC_COOKIE)this));
   ASSERT(refcount == 0);
}

      

ULONG __stdcall
Node::AddRef()
{
   LOG_ADDREF(Node);

#ifdef LOGGING_BUILD
   if (IsEqualGUID(type, NODETYPE_User))
   {
      LOG_NODE_TYPE;
   }
#endif

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
Node::Release()
{
   LOG_RELEASE(Node);

#ifdef LOGGING_BUILD
   if (IsEqualGUID(type, NODETYPE_User))
   {
      LOG_NODE_TYPE;
   }
#endif

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);
   
   return newref;
}



HRESULT __stdcall
Node::QueryInterface(const IID& interfaceID, void** interfaceDesired)
{
//   LOG_FUNCTION(Node::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired = static_cast<IUnknown*>(this);
   }
   else if (interfaceID == IID_IDataObject)
   {
//      LOG(L"Node: supplying IDataObject");
      *interfaceDesired = static_cast<IDataObject*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      // LOG(
      //       L"interface not supported: "
      //    +  Win::StringFromGUID2(interfaceID));
      // LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall
Node::GetData(FORMATETC* /* formatetcIn */ , STGMEDIUM* /* medium */ )
{
//   LOG_FUNCTION(Node::GetData);

   return E_NOTIMPL;
}



// determine the magic numbers associated with the clipboard formats we
// support

// these need to be at file scope so that it is executed only once (since they
// involve a function call, at function scope they would be called over and over
// again).

static const UINT CFID_NODETYPE =
   Win::RegisterClipboardFormat(CCF_NODETYPE);
static const UINT CFID_SZNODETYPE =
   Win::RegisterClipboardFormat(CCF_SZNODETYPE);
static const UINT CFID_DISPLAY_NAME =
   Win::RegisterClipboardFormat(CCF_DISPLAY_NAME);
static const UINT CFID_SNAPIN_CLASSID =
   Win::RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
static const UINT CFID_SNAPIN_PRELOADS =
   Win::RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);

// private clipboard format for identifying our data objects
static const UINT CFID_LOCALSEC_NODEPTR =
   Win::RegisterClipboardFormat(Node::CF_NODEPTR);
static const UINT CFID_LOCALSEC_MACHINE_NAME =
   Win::RegisterClipboardFormat(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);

// this appears to be the only IDataObject interface we need implement for MMC

HRESULT __stdcall
Node::GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium)
{
//   LOG_FUNCTION(Node::GetDataHere);
   ASSERT(formatetc);
   ASSERT(medium);

   // ISSUE-2002/03/04-sburns if formatetc or medium are null, then we should
   // return an error.
   
   if (medium->tymed != TYMED_HGLOBAL)
   {
      return DV_E_TYMED;
   }

   // this is required as per win32 docs:
   medium->pUnkForRelease = 0;

   const CLIPFORMAT cf = formatetc->cfFormat;
   IStream *stream = 0;
   HRESULT hr = DV_E_CLIPFORMAT;

   do
   {
      // before we do anything, verify that we support the requested
      // clipboard format

      if (
            cf != CFID_NODETYPE
         && cf != CFID_SZNODETYPE
         && cf != CFID_DISPLAY_NAME
         && cf != CFID_SNAPIN_CLASSID
         && cf != CFID_SNAPIN_PRELOADS
         && cf != CFID_LOCALSEC_NODEPTR
         && cf != CFID_LOCALSEC_MACHINE_NAME)
      {
         LOG(
            String::format(
               L"Unsupported clip format %1",
               Win::GetClipboardFormatName(cf).c_str()) );
         hr = DV_E_CLIPFORMAT;
         break;
      }
      
      hr = Win::CreateStreamOnHGlobal(medium->hGlobal, false, stream);
      BREAK_ON_FAILED_HRESULT(hr);

      if (cf == CFID_NODETYPE)
      {
//         LOG(CCF_NODETYPE);

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write

         // REVIEWED-2002/03/04-sburns correct byte count passed.
         
         hr = stream->Write(&type, sizeof type, 0);
      }
      else if (cf == CFID_SZNODETYPE)
      {
//         LOG(CCF_SZNODETYPE);

         String s =  Win::StringFromGUID2(type);

         // +1 for null terminator
         
         size_t bytes = (s.length() + 1) * sizeof wchar_t;

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write

         // REVIEWED-2002/03/04-sburns correct byte count passed.
         
         hr = stream->Write(s.c_str(), static_cast<ULONG>(bytes), 0);
      }
      else if (cf == CFID_DISPLAY_NAME)
      {
//         LOG(CCF_DISPLAY_NAME);

         String name = GetDisplayName();

         // +1 for null terminator
         
         size_t bytes = (name.length() + 1) * sizeof wchar_t;

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write

         // REVIEWED-2002/03/04-sburns correct byte count passed.
         
         hr = stream->Write(name.c_str(), static_cast<ULONG>(bytes), 0);
      }
      else if (cf == CFID_SNAPIN_CLASSID)
      {
//         LOG(CCF_SNAPIN_CLASSID);

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write

         hr = stream->Write(
            &CLSID_ComponentData,

            // REVIEWED-2002/03/04-sburns correct byte count passed.

            sizeof CLSID_ComponentData,
            0);
      }
      else if (cf == CFID_SNAPIN_PRELOADS)
      {
         LOG(CCF_SNAPIN_CLASSID);

         // by implementing this clipboard format, we inform the console
         // that it should write a flag into the save console file so that
         // when loaded, the console will know to send MMCN_PRELOAD to
         // our IComponentData::Notify.

         // we use the preload function to update the name of the root
         // node when overrriden on the command-line load of a saved console.

         // always return TRUE in case the saved console will be loaded from
         // another machine, in which case we'll need to update the root
         // node.
         // NTRAID#NTBUG9-466119-2001/10/02-sburns
         
         BOOL preload = TRUE; 

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write

         // REVIEWED-2002/03/04-sburns correct byte count passed.
         
         hr = stream->Write(&preload, sizeof preload, 0);
      }
      else if (cf == CFID_LOCALSEC_NODEPTR)
      {
//         LOG(CF_NODEPTR);
         Node* ptr = this;   

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write

         // REVIEWED-2002/03/04-sburns correct byte count passed.
         
         hr = stream->Write(&ptr, sizeof ptr, 0);
      }
      else if (cf == CFID_LOCALSEC_MACHINE_NAME)
      {
//         LOG(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);

         String name = GetOwner()->GetDisplayComputerName();

         // +1 for null terminator
         
         size_t bytes = (name.length() + 1) * sizeof wchar_t;

         // ISSUE-2002/03/04-sburns should get the bytes written and assert
         // that it's the same as the bytes requested to write
         
         // REVIEWED-2002/03/04-sburns correct byte count passed.
         
         hr = stream->Write(name.c_str(), static_cast<ULONG>(bytes), 0);
      }
      else
      {
         // we repeat the unsupported clip format check again just in case
         // whoever maintains this code forgets to update the list at the
         // top of the do .. while loop
         
         LOG(
            String::format(
               L"Unsupported clip format %1",
               Win::GetClipboardFormatName(cf).c_str()) );
         hr = DV_E_FORMATETC;
      }

      if (stream)
      {
         stream->Release();
      }
   }
   while (0);

   return hr;
}



HRESULT __stdcall
Node::QueryGetData(FORMATETC* /* pformatetc */ )
{
   LOG_FUNCTION(Node::QueryGetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::GetCanonicalFormatEtc(
   FORMATETC* /* formatectIn  */ ,
   FORMATETC* /* formatetcOut */ )
{
   LOG_FUNCTION(Node::GetCannonicalFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall  
Node::SetData(
   FORMATETC* /* formatetc */ ,
   STGMEDIUM* /* medium    */ ,
   BOOL       /* release   */ )
{
   LOG_FUNCTION(Node::SetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::EnumFormatEtc(
   DWORD            /* direction       */ ,
   IEnumFORMATETC** /* ppenumFormatEtc */ )
{
   LOG_FUNCTION(Node::EnumFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::DAdvise(
   FORMATETC*   /* formatetc  */ ,
   DWORD        /* advf       */ ,
   IAdviseSink* /* advSink    */ ,
   DWORD*       /* connection */ )
{
   LOG_FUNCTION(Node::DAdvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::DUnadvise(DWORD /* connection */ )
{
   LOG_FUNCTION(Node::DUnadvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::EnumDAdvise(IEnumSTATDATA** /* ppenumAdvise */ )
{
   LOG_FUNCTION(Node::EnumDAdvise);
   return E_NOTIMPL;
}



HRESULT
Node::AddMenuItems(
   IContextMenuCallback& /* callback         */ ,
   long&                 /* insertionAllowed */ )
{
   // the defualt is to do nothing
   LOG_FUNCTION(Node::AddMenuItems);

   return S_OK;
}


   
HRESULT
Node::MenuCommand(
   IExtendContextMenu& /* extendContextMenu */ ,
   long                /* commandID         */ )
{
   LOG_FUNCTION(Node::MenuCommand);

   // this may get called for console menu items, like view selection.

   return S_OK;
}



bool
Node::shouldInsertMenuItem(
   long  insertionAllowed,
   long  insertionPointID)
{
   LOG_FUNCTION(Node::shouldInsertMenuItem);

   long mask = 0;

   switch (insertionPointID)
   {
      case CCM_INSERTIONPOINTID_PRIMARY_TOP:
      {
         mask = CCM_INSERTIONALLOWED_TOP;
         break; 
      }
      case CCM_INSERTIONPOINTID_PRIMARY_NEW:
      {
         mask = CCM_INSERTIONALLOWED_NEW;
         break;
      }
      case CCM_INSERTIONPOINTID_PRIMARY_TASK:
      {
         mask = CCM_INSERTIONALLOWED_TASK;
         break;
      }
      case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
      {
         mask = CCM_INSERTIONALLOWED_VIEW;
         break;
      }
      default:
      {
         ASSERT(false);
         mask = 0;
         break;
      }
   }

   return (insertionAllowed & mask) ? true : false;
}



HRESULT
Node::UpdateVerbs(IConsoleVerb& /* consoleVerb */ )
{
   LOG_FUNCTION(Node::UpdateVerbs);

   // default is to do nothing.

   return S_OK;
}



SmartInterface<ComponentData>
Node::GetOwner() const
{
//   LOG_FUNCTION(Node::GetOwner);

   return owner;
}



NodeType
Node::GetNodeType() const
{
   LOG_FUNCTION(Node::GetNodeType);

   return type;
}



bool
Node::IsSameAs(const Node* other) const 
{
   LOG_FUNCTION(Node::IsSameAs);
   ASSERT(other);

   if (other)
   {
      if (GetDisplayName() == other->GetDisplayName())
      {
         // nodes have the same name, names are unique within a given type
         // (i.e. Users are unique, groups are unique)
         return true;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\mseldo.cpp ===
// ISSUE-2002/03/04-sburns this is unfinished code that is not compiled
// into the snapin.  consider commenting it out entirely.

// Copyright (C) 1997 Microsoft Corporation
// 
// MultiSelectDataObject class
// 
// 11-14-97 sburns



#include "headers.hxx"
#include "mseldo.hpp"



const String MultiSelectDataObject::CF_PTR(L"MultiSelectDataObject Pointer");



MultiSelectDataObject::MultiSelectDataObject()
   :
   refcount(1)    // implicit AddRef
{
   LOG_CTOR(MultiSelectDataObject);
}



MultiSelectDataObject::~MultiSelectDataObject()
{
   LOG_DTOR(MultiSelectDataObject);

   for (iterator i = begin(); i != end(); i++)
   {
      (*i)->Release();
   }
}



ULONG __stdcall
MultiSelectDataObject::AddRef()
{
   LOG_ADDREF(MultiSelectDataObject);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
MultiSelectDataObject::Release()
{
   LOG_RELEASE(MultiSelectDataObject);

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);

   return newref;
}



HRESULT __stdcall
MultiSelectDataObject::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
   LOG_FUNCTION(MultiSelectDataObject::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired = static_cast<IUnknown*>(this);
   }
   else if (interfaceID == IID_IDataObject)
   {
      *interfaceDesired = static_cast<IDataObject*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



static const UINT CFID_OBJECT_TYPES_IN_MULTI_SELECT =
   Win::RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);

// private clipboard format for identifying our data objects
static const UINT CFID_PTR =
   Win::RegisterClipboardFormat(MultiSelectDataObject::CF_PTR);



HRESULT __stdcall
MultiSelectDataObject::GetData(FORMATETC* formatetc, STGMEDIUM* medium)
{
   LOG_FUNCTION(MultiSelectDataObject::GetData);

   const CLIPFORMAT cf = formatetc->cfFormat;

   if (cf == CFID_OBJECT_TYPES_IN_MULTI_SELECT)
   {
//      LOG(CCF_OBJECT_TYPES_IN_MULTI_SELECT);

      // collect all the node types of the dependents
      list<GUID> types;
      for (iterator i = begin(); i != end(); i++)
      {
         NodeType type = (*i)->GetNodeType();
         list<GUID>::iterator f = find(types.begin(), types.end(), type);
         if (f == types.end())
         {
            // not found.  So add it.
            types.push_back(type);
         }
      }

      // at this point, types is a set of all the node types of the
      // dependent nodes.

      medium->tymed = TYMED_HGLOBAL;
      DWORD size = sizeof(SMMCObjectTypes) + (types.size() - 1) * sizeof(GUID);
      medium->hGlobal = Win::GlobalAlloc(GPTR, size);     
      if (!medium->hGlobal)
      {
         return E_OUTOFMEMORY;
      }

      SMMCObjectTypes* data =
         reinterpret_cast<SMMCObjectTypes*>(medium->hGlobal);
      data->count = types.size();
      int k = 0;
      for (list<GUID>::iterator j = types.begin(); j != types.end(); j++, k++)
      {
         data->guid[k] = *j;
      }

      return S_OK;
   }

   return DV_E_CLIPFORMAT;
}



HRESULT __stdcall
MultiSelectDataObject::GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium)
{
   LOG_FUNCTION(MultiSelectDataObject::GetDataHere);
   ASSERT(formatetc);
   ASSERT(medium);

   if (medium->tymed != TYMED_HGLOBAL)
   {
      return DV_E_TYMED;
   }

   // this is required as per win32 docs:
   medium->pUnkForRelease = 0;

   const CLIPFORMAT cf = formatetc->cfFormat;
   IStream *stream = 0;
   HRESULT hr = DV_E_CLIPFORMAT;

   do
   {
      hr = Win::CreateStreamOnHGlobal(medium->hGlobal, false, stream);
      BREAK_ON_FAILED_HRESULT(hr);

      if (cf == CFID_PTR)
      {
//         LOG(CF_PTR);
         MultiSelectDataObject* ptr = this;   
         hr = stream->Write(&ptr, sizeof(ptr), 0);
      }
      else
      {
         LOG(
            String::format(
               L"Unsupported clip format %1",
               Win::GetClipboardFormatName(cf).c_str()) );
      }

      if (stream)
      {
         stream->Release();
      }
   }
   while (0);

   return hr;
}



HRESULT __stdcall
MultiSelectDataObject::QueryGetData(FORMATETC* pformatetc)
{
   LOG_FUNCTION(MultiSelectDataObject::QueryGetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::GetCanonicalFormatEtc(
   FORMATETC* formatectIn,
   FORMATETC* formatetcOut)
{
   LOG_FUNCTION(MultiSelectDataObject::GetCannonicalFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall  
MultiSelectDataObject::SetData(
   FORMATETC*  formatetc,
   STGMEDIUM*  medium,
   BOOL        release)
{
   LOG_FUNCTION(MultiSelectDataObject::SetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::EnumFormatEtc(
   DWORD             direction,
   IEnumFORMATETC**  ppenumFormatEtc)
{
   LOG_FUNCTION(MultiSelectDataObject::EnumFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::DAdvise(
   FORMATETC*     formatetc,
   DWORD          advf,
   IAdviseSink*   advSink,
   DWORD*         connection)
{
   LOG_FUNCTION(MultiSelectDataObject::DAdvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::DUnadvise(DWORD connection)
{
   LOG_FUNCTION(MultiSelectDataObject::DUnadvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::EnumDAdvise(IEnumSTATDATA** ppenumAdvise)
{
   LOG_FUNCTION(MultiSelectDataObject::EnumDAdvise);
   return E_NOTIMPL;
}



void
MultiSelectDataObject::AddDependent(ResultNode* node)
{
   LOG_FUNCTION(MultiSelectDataObject::AddDependent);
   ASSERT(node);

   if (node)
   {
      // add the node if not already present
      iterator f = find(begin(), end(), node);
      if (f == end())
      {
         node->AddRef();
         dependents.push_back(node);
      }
   }
}



MultiSelectDataObject::iterator
MultiSelectDataObject::begin() const
{
   return dependents.begin();
}



MultiSelectDataObject::iterator
MultiSelectDataObject::end() const
{
   return dependents.end();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\nodepointerextractor.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// clipboard Extractor for Node pointers
//
// 8-12-97 sburns



#include "headers.hxx"
#include "node.hpp"
#include "NodePointerExtractor.hpp"



NodePointerExtractor::NodePointerExtractor()
   :
   Extractor(
      Win::RegisterClipboardFormat(Node::CF_NODEPTR),
      sizeof(Node*))
{
}



Node*
NodePointerExtractor::Extract(IDataObject& dataObject)
{
   Node* result = 0;
   HGLOBAL mem = ExtractData(dataObject);
   if (mem)
   {
      result = *(reinterpret_cast<Node**>(mem));

      // This assertion may fail if we or any other snapin puts a null pointer
      // in the HGLOBAL, or more likely, returns S_OK from
      // IDataObject::GetDataHere without actually writing anything into the
      // HGLOBAL.  See NTRAID#NTBUG9-303984-2001/02/05-sburns for an example.
      // Either way, it's a bug, so we leave the assertion in.
      
      ASSERT(result);
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\node.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Node class
// 
// 9-2-97 sburns



#ifndef NODE_HPP_INCLUDED
#define NODE_HPP_INCLUDED



#include "compdata.hpp"



// Struct used by BuildContextMenu.  Should be nested in Node, but vc++ templates
// seem to have trouble with nested classes as parameters.

struct ContextMenuItem
{
   long insertionPointID;  // MMC insertion point identifier
   int  menuResID;         // menu text string resource ID
   int  statusResID;       // status bar string resource ID
};



// Node is the abstract base class of all objects which appear as a single
// item in the scope or result panes of MMC.  It implements IDataObject so
// that MMC cookies = node instance pointers, i.e. cookies, IDataObject ptrs,
// and Node ptrs are all freely and cheaply convertible.
// 
// Since requesting data objects is something MMC does an awful lot, this
// scheme may provide better speed and space performance that having a
// separate class implementing IDataObject which wraps node instances.
//
// With this scheme, there is no overhead for creating/deleting IDataObject
// instances, mapping from IDataObject instance to node instance is simply a
// pointer cast, and no reference relationship between IDataObject instances
// and node instances need be maintained (which makes the system conceptually
// simpler, too.)
// 
// Nodes are reference-counted.

class Node : public IDataObject
{
   public:

   // Clipboard format for obtaining a pointer to a Node instance from
   // a IDataObject.  (If the call to GetDataHere responds without failure
   // to this format, one need not read the pointer from the stream -- a
   // simple cast of the IDataObject will work.)
   static const String CF_NODEPTR;

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IDataObject overrides

   virtual
   HRESULT __stdcall
   GetData(FORMATETC* formatetcIn, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   QueryGetData(FORMATETC* pformatetc);

   virtual
   HRESULT __stdcall
   GetCanonicalFormatEtc(FORMATETC* formatectIn, FORMATETC* formatetcOut);

   virtual
   HRESULT __stdcall  
   SetData(FORMATETC* formatetc, STGMEDIUM* medium, BOOL release);

   virtual
   HRESULT __stdcall
   EnumFormatEtc(DWORD direction, IEnumFORMATETC** ppenumFormatEtc);

   virtual
   HRESULT __stdcall
   DAdvise(
      FORMATETC*     formatetc,
      DWORD          advf,
      IAdviseSink*   advSink,
      DWORD*         connection);

   virtual
   HRESULT __stdcall
   DUnadvise(DWORD connection);

   virtual
   HRESULT __stdcall
   EnumDAdvise(IEnumSTATDATA** ppenumAdvise);

   // Node methods

   // Called from IComponent::AddMenuItems, and has the same semantics.  If a
   // derived node class supports a custom context menus for that node, that
   // class should override this function to insert menu items.
   // 
   // The default implementation does nothing and returns S_OK.
   // 
   // callback - The MMC interface with which menu items are added.  This is
   // the same instance passed to IComponent::AddMenuItems.
   // 
   // insertionAllowed - The flag parameter passed to
   // IComponent::AddMenuItems.

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   // Returns the friendly name of the node that is displayed with the node's
   // icon.  This is pure virtual as some nodes may wish to manufacture a name
   // on-the-fly.

   virtual
   String
   GetDisplayName() const = 0;

   // Returns the text to be displayed in a particular column of the result
   // pane list view when the node is displayed in the result pane.  Called
   // by IComponent::GetDisplayInfo
   // 
   // column - The number of the column for which text should be supplied.

   virtual
   String
   GetColumnText(int column) = 0;

   // Returns the NodeType with which the instance was created.

   NodeType
   GetNodeType() const;

   // Returns the image index of the icon image for this node.  This is the
   // index of the image that was registered with MMC by IComponent in
   // response to the MMCN_ADD_IMAGES notification.  This should always return
   // the same index for all invocations.

   virtual 
   int
   GetNormalImageIndex() = 0;

   // Compares this node to other, returns true if they can be considered the
   // same (not necessarily the same Node instance, mind you).  The default
   // implementation compares the result of GetDisplayName().
   // 
   // other - Node to compare this to.  0 is illegal, and always returns false.

   virtual
   bool
   IsSameAs(const Node* other) const;

   // Called by IExtendContextMenu::Command when a context menu command has been
   // selected.  Since the default AddMenuItems implementation adds no menu
   // items, the default implementation of this function simply returns S_OK;
   //
   // extendContextMenu - the IExtendContextMenu instance that invokes this
   // method.
   // 
   // commandID - The ID of the command that was registered with the menu item
   // by AddMenuItems.  The range of possible IDs is the union of all IDs
   // registered by AddMenuItems.

   virtual
   HRESULT
   MenuCommand(IExtendContextMenu& extendContextMenu, long commandID);

   // Called from IComponent::Notify in response to the MMCN_SELECT
   // notification. Derived classes should use the provided IConsoleVerb
   // instance to enable the verbs applicable to their node type.
   // 
   // consoleVerb - Instance of IConsoleVerb used to do verb enabling.

   virtual
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   protected:
   
   // Creates an instance with a given NodeType (a GUID).  Declared protected
   // to that this class may only be used as a base class.
   //
   // owner - the ComponentData object which "owns" this node
   //
   // nodeType - the NodeType GUID corresponding to this instance.  This must
   // be one of the node types registered in the MMC keys registry when the
   // snapin is registered, as it is used to produce the CCF_NODETYPE and
   // CCF_SZNODETYPE formats for IDataObject::GetDataHere.

   Node(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType);

   // don't call directly: allow Release() to delete instances.  (declared
   // protected so as to be accessible to derived class' dtors)

   virtual ~Node();

   // Helper for derived classes for use in building a context menu as part of
   // the implementation of AddMenuItems.
   // 
   // begin - Iterator positioned at the beginning of the collection of
   // ContextMenuItem instances.
   // 
   // end - Iterator positioned just beyond the end of the collection of
   // ContextMenuItem instances.
   // 
   // callback - The IContextMenuCallback passed to AddMenuItems.
   // 
   // insertionAllowed - The insertion flag passed to AddMenuItems.

   template <class InputIterator>
   HRESULT
   BuildContextMenu(
      InputIterator           begin,
      InputIterator           end,
      IContextMenuCallback&   callback,
      long                    insertionAllowed)
   {
      HRESULT hr = S_OK;
      for (
         ;
         begin != end;
         ++begin)
      {
         CONTEXTMENUITEM item;
         
         // REVIEWED-2002/03/01-sburns correct byte count passed

         ::ZeroMemory(&item, sizeof item);
         
         String text = String::load((*begin).statusResID);

         item.strStatusBarText =
            const_cast<wchar_t*>(text.c_str());

         if (shouldInsertMenuItem(insertionAllowed, (*begin).insertionPointID))
         {
            String name = String::load((*begin).menuResID);
                     
            // Use the string res ID as the command ID.  Ensure that our command ID
            // is valid.
            ASSERT(!(CCM_COMMANDID_MASK_RESERVED & (*begin).menuResID));
            item.lCommandID = (*begin).menuResID;

            item.strName = const_cast<wchar_t*>(name.c_str());
            item.lInsertionPointID = (*begin).insertionPointID;
            hr = callback.AddItem(&item);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      return hr;
   }

   // Returns the ComponentData ptr with which the instance was constructed.

   SmartInterface<ComponentData>
   GetOwner() const;

   private:

   // not implemented: no copying allowed
   Node(const Node&);
   const Node& operator=(const Node&);

   static
   bool
   shouldInsertMenuItem(
      long  insertionAllowed,
      long  insertionPointID);

   SmartInterface<ComponentData> owner;
   NodeType                      type;
   ComServerReference            dllref;
   long                          refcount;
};



#endif   // NODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\nodepointerextractor.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// clipboard Extractor for Node pointers
//
// 8-12-97 sburns



#ifndef NODEPOINTEREXTRACTOR_HPP_INCLUDED
#define NODEPOINTEREXTRACTOR_HPP_INCLUDED



class NodePointerExtractor : public Extractor
{
   public:



   NodePointerExtractor();



   Node*
   Extract(IDataObject& dataObject);



   // Note: this can fail (return 0) if the dataObject is not one of our own (if
   // it is that of the snapin we're extending, for instance.)

   template <class C>
   C
   GetNode(IDataObject& dataObject)
   {
      Node* node = Extract(dataObject);
      C n = dynamic_cast<C>(node);

      // don't assert: if the data object is not ours, it is correct to
      // return 0.
      // NTRAID#NTBUG9-464647-2001/09/07-sburns
      // ASSERT(n);

      return n;
   }



   // We do not specialize the above template method for C = class Node*.
   // While doing do we could avoid a dynamic_cast, but it turns out that the 
   // dynamic_cast is a nice way to double check that the clipboard data we
   // extract isn't some bogus data returned by another snapin's buggy
   // implementation of IDataObject::GetDataHere.  (If you think I'm being
   // paranoid, check out NTRAID#NTBUG9-303984-2001/02/02-sburns).
   // 
   // If we do get bogus data, then the dynamic_cast will almost certainly
   // fail, returning 0, and we will live happily ever after.
   

//    // This is a specialization of the above template that avoids the otherwise
//    // redundant dynamic_cast.
// 
//    Node*
//    GetNode /* <Node*> */ (IDataObject& dataObject)
//    {
//       Node* node = Extract(dataObject);
// 
//       ASSERT(node);
// 
//       return node;
//    }



   private:



   // not defined: no copying allowed

   NodePointerExtractor(const NodePointerExtractor&);
   const NodePointerExtractor& operator=(const NodePointerExtractor&);
};


#endif 	// NODEPOINTEREXTRACTOR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\objpick.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ObjectPicker wrapper class
// 
// 10-13-98 sburns



#ifndef OBJPICK_HPP_INCLUDED
#define OBJPICK_HPP_INCLUDED



// ObjectPicker is a variation on the Template Method pattern.  It allows the
// object picker to be invoked, and parameterizes the retreival of the
// results.

class ObjectPicker
{
   public:

   // the Execute method is invoked to return the results.  Subclass your
   // own ResultsCallback to change the behavior.

   class ResultsCallback : public Callback
   {
      public:

      // Callback override

      virtual
      int
      Execute(void* param)
      {
         ASSERT(param);

         return
            Execute(*reinterpret_cast<DS_SELECTION_LIST*>(param));
      }

      virtual
      int
      Execute(DS_SELECTION_LIST& selections) = 0;
   };

   static
   HRESULT
   Invoke(
      HWND              parentWindow,
      ResultsCallback&  callback,
      DSOP_INIT_INFO&   initInfo);

   private:

   // not implemented: can't construct instances
   ObjectPicker();
   ObjectPicker(const ObjectPicker&);
   const ObjectPicker& operator=(const ObjectPicker&);
};



#endif   // OBJPICK_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\objpick.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// ObjectPicker wrapper class
//
// 10-13-98 sburns




#include "headers.hxx"
#include "objpick.hpp"



HRESULT
ObjectPicker::Invoke(
   HWND                             parentWindow,
   ObjectPicker::ResultsCallback&   callback,
   DSOP_INIT_INFO&                  initInfo)
{
   ASSERT(Win::IsWindow(parentWindow));

   HRESULT hr = S_OK;

   do
   {
      SmartInterface<IDsObjectPicker> object_picker;
      hr =
         object_picker.AcquireViaCreateInstance(
            CLSID_DsObjectPicker,
            0,
            CLSCTX_INPROC_SERVER,

            // CODEWORK: this interface needs to be declared w/ declspec uuid
            IID_IDsObjectPicker);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = object_picker->Initialize(&initInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      IDataObject* pdo = 0;
      hr = object_picker->InvokeDialog(parentWindow, &pdo);
      BREAK_ON_FAILED_HRESULT(hr);

      // S_OK == selections made, S_FALSE == cancel hit

      if (hr == S_OK)
      {
         SmartInterface<IDataObject> ido(0);
         ido.Acquire(pdo);

         STGMEDIUM stgmedium =
         {
            TYMED_HGLOBAL,
            0
         };

         static const UINT cf =
            Win::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

         FORMATETC formatetc =
         {
            (CLIPFORMAT)cf,
            0,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
         };

         hr = ido->GetData(&formatetc, &stgmedium);
         BREAK_ON_FAILED_HRESULT(hr);

         PVOID lockedHGlobal = 0;
         hr = Win::GlobalLock(stgmedium.hGlobal, lockedHGlobal);
         BREAK_ON_FAILED_HRESULT(hr);
         
         DS_SELECTION_LIST* selections =
            reinterpret_cast<DS_SELECTION_LIST*>(lockedHGlobal);

         if (selections)
         {
            callback.Execute(*selections);
         }

         Win::GlobalUnlock(stgmedium.hGlobal);
         Win::ReleaseStgMedium(stgmedium);
      }
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_WARN                        102
#define IDI_COMPUTER                    103
#define IDI_WARNINGBIG                  107
#define IDD_USER_GENERAL                115
#define IDD_USER_PROFILE                116
#define IDD_USER_MEMBER                 120
#define IDD_GROUP_GENERAL               121
#define IDC_MUST_CHANGE_PASSWORD        257
#define IDC_CANNOT_CHANGE_PASSWORD      258
#define IDC_DISABLED                    260
#define IDD_MACHINE_CHOOSER             970
#define IDC_GROUP                       971
#define IDC_LOCAL_MACHINE               972
#define IDC_SPECIFIC_MACHINE            973
#define IDC_MACHINE_NAME                974
#define IDC_BROWSE                      975
#define IDC_OVERRIDE                    976
#define IDS_MACHINE_IS_HOME_EDITION_LOCAL 978
#define IDS_USERNAME_CANT_BE_COMPUTER_NAME 979
#define IDC_DRIVE                       1001
#define IDC_USER_NAME                   1002
#define IDC_CONNECT                     1012
#define IDC_LOCAL                       1013
#define IDC_MEMBERS                     1022
#define IDC_FULL_NAME                   1030
#define IDC_PROFILE                     1031
#define IDC_PATH                        1032
#define IDC_SCRIPT                      1033
#define IDC_SHARE                       1034
#define IDC_NEVER_EXPIRES               1078
#define IDC_DISABLE                     1111
#define IDD_CREATE_USER                 1113
#define IDD_CREATE_GROUP                1114
#define IDC_LOCKED                      1165
#define IDC_ADD                         1168
#define IDC_REMOVE                      1169
#define IDC_CREATE                      1170
#define IDC_DESCRIPTION                 1171
#define IDC_PASSWORD                    1172
#define IDC_CONFIRM                     1173
#define IDC_NAME                        1174
#define IDC_USER_ICON                   1177
#define IDC_GROUP_ICON                  1178
#define IDC_GROUPS                      1189
#define IDI_DISABLED_USER               1190
#define IDC_HELP_BUTTON                 1197
#define IDC_WARNING_TEXT1               1198
#define IDC_MESSAGE                     1200
#define IDC_TO_STATIC                   1202
#define IDS_ERROR_LAUNCHING_PICKER      5017
#define IDS_BAD_SHARE_NAME              5018
#define IDS_BAD_HOME_DIR                5019
#define IDI_GROUP                       5020
#define IDI_SNAPIN_ICON                 5021
#define IDI_USER                        5022
#define IDI_FOLDER_OPEN                 5023
#define IDI_FOLDER_CLOSED               5024
#define IDS_SNAPIN_CLSID_FRIENDLY_NAME  5025
#define IDS_SNAPIN_REG_NAMESTRING       5026
#define IDS_SNAPIN_ABOUT_CLSID_FRIENDLY_NAME 5027
#define IDS_SNAPIN_ABOUT_DESCRIPTION    5028
#define IDS_STATIC_FOLDER_DISPLAY_NAME  5031
#define IDS_USERS_FOLDER_DISPLAY_NAME   5032
#define IDS_GROUPS_FOLDER_DISPLAY_NAME  5033
#define IDS_USER_NAME_COLUMN_TITLE      5034
#define IDS_USER_FULL_NAME_COLUMN_TITLE 5035
#define IDS_USER_DESCRIPTION_COLUMN_TITLE 5036
#define IDS_USERS_FOLDER_TYPE_TITLE     5037
#define IDS_UF_MENU_NEW_USER            5038
#define IDS_UF_MENU_NEW_USER_STATUS     5039
#define IDS_UF_MENU_CREATE_USER         5040
#define IDS_ERROR_DC_NOT_SUPPORTED      5041
#define IDS_ERROR_DC_NOT_SUPPORTED_EXT  5042
#define IDS_STATIC_FOLDER_SHORT_DISPLAY_NAME 5049
#define IDS_VERSION_MISMATCH            5050
#define IDS_VERSION_MISMATCH_TITLE      5051
#define IDS_GROUPS_FOLDER_TYPE_TITLE    5052
#define IDS_GF_MENU_CREATE_GROUP        5053
#define IDS_GF_MENU_NEW_GROUP_STATUS    5054
#define IDS_GF_MENU_NEW_GROUP           5055
#define IDS_ERROR_READING_MEMBER_PROPERTIES1 5056
#define IDS_ERROR_READING_MEMBER_PROPERTIES2 5057
#define IDS_USER_NAME_COLUMN_WIDTH      5064
#define IDS_USER_FULL_NAME_COLUMN_WIDTH 5065
#define IDS_USER_DESCRIPTION_COLUMN_WIDTH 5066
#define IDS_GROUP_NAME_COLUMN_TITLE     5067
#define IDS_GROUP_NAME_COLUMN_WIDTH     5068
#define IDS_GROUP_DESCRIPTION_COLUMN_TITLE 5069
#define IDS_GROUP_DESCRIPTION_COLUMN_WIDTH 5070
#define IDS_ERROR_READING_USER          5089
#define IDS_ERROR_READING_GROUP         5090
#define IDS_MEMBER_LIST_NAME_COLUMN_WIDTH 5091
#define IDS_MEMBER_LIST_NAME_COLUMN     5092
#define IDS_MEMBER_LIST_DESC_COLUMN_WIDTH 5093
#define IDS_MEMBER_LIST_DESC_COLUMN     5094
#define IDS_ERROR_CREATING_USER         5095
#define IDS_PASSWORD_MISMATCH           5096
#define IDS_ERROR_SETTING_USER_PROPERTIES 5098
#define IDB_STATIC_FOLDER_LARGE         5099
#define IDS_ERROR_CREATING_GROUP        5100
#define IDS_ERROR_SETTING_GROUP_PROPERTIES 5101
#define IDS_USER_MENU_CHANGE_PASSWORD   5102
#define IDB_STATIC_FOLDER_SMALL         5102
#define IDB_STATIC_FOLDER_SMALL_OPEN    5103
#define IDS_USER_MENU_CHANGE_PASSWORD_STATUS 5103
#define IDS_ERROR_RENAMING_USER         5104
#define IDS_ERROR_RENAMING_GROUP        5105
#define IDS_ERROR_DELETING_USER         5106
#define IDS_ERROR_DELETING_GROUP        5107
#define IDD_SET_PASSWORD                5109
#define IDI_DOMAIN_USER                 5110
#define IDI_DOMAIN_GROUP                5111
#define IDS_NEED_SHARE_NAME             5113
#define IDI_ROOT_CLOSED                 5114
#define IDD_SET_PASSWORD_WARNING_SELF   5115
#define IDI_ROOT_OPEN                   5115
#define IDD_SET_PASSWORD_WARNING_SELF_FRIENDLY 5115
#define IDI_ROOT_ERROR                  5116
#define IDI_UNKNOWN_SID                 5117
#define IDS_ROOT_NODE_DESCRIPTION       5118
#define IDI_BULLET                      5118
#define IDS_ROOT_NODE_TYPE              5119
#define IDS_ITEM_INCOMPLETE             5120
#define IDS_ERROR_CHANGING_MEMBERSHIP   5121
#define IDS_APP_ERROR_TITLE             5122
#define IDS_USER_MENU_ADD_TO_GROUP      5123
#define IDS_USER_MENU_ADD_TO_GROUP_STATUS 5124
#define IDS_STATIC_FOLDER_LOCAL_DISPLAY_NAME 5127
#define IDS_CONFIRM_USER_DELETE         5129
#define IDS_CONFIRM_GROUP_DELETE        5131
#define IDS_HTMLHELP_NAME               5132
#define IDS_ERROR_VISITING_GROUP        5133
#define IDS_ERROR_VISITING_USER         5134
#define IDS_PASSWORD_CHANGE_SUCCESSFUL  5135
#define IDS_GLOBAL_ACCOUNT_DISPLAY_FORMAT 5137
#define IDS_USERNAME                    5138
#define IDS_ADD_TO_GROUP_MEMBERSHIP     5139
#define IDS_ADD_TO_GROUP_MEMBERSHIP_STATUS 5140
#define IDS_ERROR_SPAWNING_GROUP_PROPERTIES 5142
#define IDS_ERROR_ASSIGNING_NEW_USER_TO_USERS_GROUP 5145
#define IDS_HTMLHELP_OVERVIEW_TOPIC     5146
#define IDD_USER_FPNW                   5147
#define IDC_NETWARE_ENABLE              5148
#define IDC_NWPWEXPIRED                 5149
#define IDC_OBJECTID_TEXT               5150
#define IDC_OBJECT_ID                   5151
#define IDC_GRACE_LOGINS                5152
#define IDC_UNLIMITED_GRACELOGINS       5153
#define IDC_LIMIT_GRACELOGINS           5154
#define IDC_GRACE_LIMIT                 5155
#define IDC_GRACE_SPIN                  5156
#define IDC_GRACE_REMAINING_TEXT        5157
#define IDC_GRACE_REMAINING             5158
#define IDC_GRACE_REMAINING_SPIN        5159
#define IDC_CONCURRENT_CONNECTIONS      5160
#define IDC_UNLIMITED_CONNECTIONS       5161
#define IDC_LIMIT_CONNECTIONS           5162
#define IDC_CONNECTION_LIMIT            5163
#define IDC_CONNECTION_SPIN             5164
#define IDC_SCRIPT_BUTTON               5166
#define IDC_NWHMDIR_RELPATH_TEXT        5167
#define IDC_NWHMDIR_RELPATH             5168
#define IDD_FPNW_LOGIN_SCRIPT           5170
#define IDD_FPNW_PASSWORD               5171
#define IDD_SET_PASSWORD_WARNING_OTHER  5172
#define IDD_SET_PASSWORD_WARNING_OTHER_HOSTILE 5172
#define IDD_SET_PASSWORD_WARNING_SELF_HOSTILE 5173
#define IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY 5174
#define IDS_BAD_SAM_NAME                5178
#define IDS_ERROR_FPNW_SERVICE_NOT_RUNNING 5179
#define IDS_ERROR_FPNW_SERVICE_NOT_ACCESSIBLE 5180
#define IDS_ERROR_SETTING_PASSWORD      5200
#define IDS_BAD_SCRIPT_PATH             5201
#define IDS_FPNW_CLIENT_DLL             5202
#define IDS_LOGIN_SCRIPT_TITLE          5203
#define IDS_PASSWORD_TITLE              5204
#define IDS_FPNW_PASSWORD_CANCEL_WARNING 5205
#define IDS_BAD_FPNW_HOMEDIR            5206
#define IDS_FPNW_ERROR_WRITING_SCRIPT   5207
#define IDS_FPNW_ERROR_READING_SCRIPT   5208
#define IDS_HOME_DIR_CREATE_FAILED      5209
#define IDS_USER_NAME_TOO_LONG          5210
#define IDS_USERS_FOLDER_DESC           5211
#define IDS_GROUPS_FOLDER_DESC          5212
#define IDS_MUST_ENTER_MACHINE_NAME     5213
#define IDS_CANT_ACCESS_MACHINE         5214
#define IDS_ALREADY_MEMBER              5215
#define IDS_ITEM_ALREADY_PRESENT        5216
#define IDS_CANT_ACCESS_SHARE           5217
#define IDS_CANT_CREATE_FOLDER          5218
#define IDS_MACHINE_NOT_NT              5219
#define IDS_SET_PASSWORD_TITLE          5220
#define IDS_SET_PASSWORD_WARNING_BULLET_OTHER1 5221
#define IDS_SET_PASSWORD_WARNING_BULLET_SELF1 5223
#define IDS_SET_PASSWORD_WARNING_MESSAGE_SELF1 5225
#define IDS_CONFIRM_LOGGED_ON_USER_DELETE 5226
#define IDS_SET_HOME_DIR_ACL_FAILED 5227
#define IDS_CANT_SET_FOLDER_ACL 5228


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        5119
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1202
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\resnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Result Node class
// 
// 9-4-97 sburns



#ifndef RESNODE_HPP_INCLUDED
#define RESNODE_HPP_INCLUDED



#include "node.hpp"
#include "mmcprop.hpp"



// ResultNode is an abstract base class defining the interfaces for all Node
// classes that are normally hosted in the result pane.  (ScopeNodes may also
// appear in the result pane, but MMC takes care of this automatically.  That
// is one reason why ScopeNode does not derive from ResultNode.)
// 
// ResultNode instances are "owned" by ScopeNodes.  That is, a ScopeNode has a
// bunch of ResultNodes that it instantiates and uses to populate its result
// pane.

class ResultNode : public Node
{
   public:

   // Called by IComponent::CreatePropertyPages.  Derived classes should use
   // the given parameters to supply MMC with the property pages for their
   // node type.  The default implementation returns S_OK;
   // 
   // callback - the IPropertySheetCallback supplied to
   // IComponent::CreatePropertyPages.
   // 
   // state - the NotificationState instance created to contain property
   // change notification information for the console.

   virtual
   HRESULT
   CreatePropertyPages(
      IPropertySheetCallback&             callback,
      MMCPropertyPage::NotificationState* state);

   // Node overrides

   // Overrides the base class function to supply the name the node was
   // created with.  This implies that ResultNodes tend to have names fixed
   // throughout their lifetimes.

   virtual
   String
   GetDisplayName() const;

   // ResultNode methods

   // Called by IComponent::Notify upon receipt of a MMCN_DELETE message.  The
   // default implementation always returns E_NOTIMPL.  Derived classes should
   // return S_OK to indicate that the delete succeeded.  This function will
   // only be called if the node has enabled the MMC_VERB_DELETE verb in its
   // implementation of UpdateVerbs.

   virtual
   HRESULT
   Delete();

   // Called by IComponent::QueryPagesFor.  Derived classes should return true
   // if the Node has any pages to supply to the property sheet.  The class
   // should also implement CreatePropertyPages.  The default implementation
   // returns false.

   virtual
   bool
   HasPropertyPages();

   // Inserts self into the result pane, using the supplied IResultData
   // interface.  This is typically called from the owning ScopeNode's
   // implementation of InsertResultItems.
   //
   // resultData - the IResultData interface used to insert this node.

   HRESULT
   InsertIntoResultPane(IResultData& resultData);

   // Called by IComponent::Notify upon receipt of a MMCN_RENAME message.  The
   // default implementation always returns S_FALSE.  Derived classes should
   // return S_OK to indicate that the rename succeeded, or S_FALSE to
   // indicate otherwise.  This function will only be called if the node has
   // enabled the MMC_VERB_RENAME verb in its implementation of UpdateVerbs.
   // 
   // newName - The new name for the node entered by the user.

   virtual 
   HRESULT
   Rename(const String& newName);

   protected:

   // Contructs a new instance.  Declared protected so that this class may
   // only be a base class.
   //
   // owner - the ComponentData object which "owns" this node
   //
   // nodeType - the NodeType GUID corresponding to this instance.  This must
   // be one of the node types registered in the MMC keys registry when the
   // snapin is registered, as it is used to produce the CCF_NODETYPE and
   // CCF_SZNODETYPE formats for IDataObject::GetDataHere.
   // 
   // displayName - The text used to label the node in the result pane.

   ResultNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType,      
      const String&                          displayName);

   virtual ~ResultNode();

   void
   SetDisplayName(const String& newName);

   // A helper function for classes that implement CreatePropertyPages.  The
   // function calls Create on the supplied page, then calls AddPage on the
   // callback with the result of the Create call.  If any errors occurr, the
   // page is properly destroyed.
   // 
   // page - page to be created and added.
   // 
   // callback - used to add the page.
      
   HRESULT
   DoAddPage(
      MMCPropertyPage&           page,
      IPropertySheetCallback&    callback);
      
   String name;

   private:

   // not implemented: no copying allowed

   ResultNode(const ResultNode&);
   const ResultNode& operator=(const ResultNode&);
};



#endif   // RESNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\rootnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Root Node class
//
// 9-2-97 sburns



#include "headers.hxx"
#include "rootnode.hpp"
#include "uuids.hpp"
#include "images.hpp"
#include "resource.h"
#include "UsersFolderNode.hpp"
#include "gfnode.hpp"
#include "compdata.hpp"
#include "dlgcomm.hpp"



RootNode::RootNode(const SmartInterface<ComponentData>& owner)
   :
   ScopeNode(owner, NODETYPE_RootFolder),
   users_folder_node(0),
   groups_folder_node(0)
{
   LOG_CTOR(RootNode);
}



RootNode::~RootNode()
{
   LOG_DTOR(RootNode);

   // users_folder_node is destroyed, releasing it's object
   // groups_folder_node is destroyed, releasing it's object
}



String
RootNode::GetDisplayName() const
{
//   LOG_FUNCTION(RootNode::GetDisplayName);

   SmartInterface<ComponentData> owner(GetOwner());
   String machine = owner->GetDisplayComputerName();
   if (owner->IsExtension())
   {
      // "Local User Manager"
      name = String::load(IDS_STATIC_FOLDER_SHORT_DISPLAY_NAME);
   }
   else if (Win::IsLocalComputer(machine))
   {
      // "Local User Manager (Local)"
      name = String::load(IDS_STATIC_FOLDER_LOCAL_DISPLAY_NAME);
   }
   else
   {
      // "Local User Manager (machine)"
      name =
         String::format(
            IDS_STATIC_FOLDER_DISPLAY_NAME,
            machine.c_str());
   }

   return name;
}



String
RootNode::GetColumnText(int column)
{
   LOG_FUNCTION(Node::GetColumnText);

   switch (column)
   {
      case 0:
      {
         return GetDisplayName();
      }
      case 1:  // type
      {
         // CODEWORK: this is inefficient -- should load once

         return String::load(IDS_ROOT_NODE_TYPE);
      }
      case 2:  // description
      {
         // CODEWORK: this is inefficient -- should load once

         return String::load(IDS_ROOT_NODE_DESCRIPTION);
      }
      default:
      {
         ASSERT(false);
      }
   }

   return L"";
}



int
RootNode::GetNormalImageIndex()
{
   SmartInterface<ComponentData> owner(GetOwner());
   if (owner->IsBroken())
   {
      return ROOT_ERROR_INDEX;
   }

   return ROOT_CLOSED_INDEX;
}



int
RootNode::GetOpenImageIndex()
{
   SmartInterface<ComponentData> owner(GetOwner());
   if (owner->IsBroken())
   {
      return ROOT_ERROR_INDEX;
   }

   return ROOT_OPEN_INDEX;
}



HRESULT
RootNode::InsertScopeChildren(
   IConsoleNameSpace2&  nameSpace,
   HSCOPEITEM           parentScopeID)
{
   LOG_FUNCTION(RootNode::InsertScopeChildren);

   HRESULT hr = S_OK;
   SmartInterface<ComponentData> owner(GetOwner());
   if (!owner->IsBroken())
   {
      // these will be implicitly AddRef'd
      users_folder_node.Acquire(new UsersFolderNode(owner));
      groups_folder_node.Acquire(new GroupsFolderNode(owner));

      do
      {
         hr = users_folder_node->InsertIntoScopePane(nameSpace, parentScopeID);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = groups_folder_node->InsertIntoScopePane(nameSpace, parentScopeID);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      while (0);
   }

   return hr;
}



HRESULT
RootNode::RemoveScopeChildren(
   IConsoleNameSpace2&  nameSpace,
   HSCOPEITEM           /* parentScopeID */ )
{
   LOG_FUNCTION(RootNode::RemoveScopeChildren);

   HRESULT hr = S_OK;
   SmartInterface<ComponentData> owner(GetOwner());
   if (!owner->IsBroken())
   {
      do
      {
         // we test each pointer to our child nodes, as they may not
         // have been created yet when we are told to remove them.

         if (users_folder_node)
         {
            hr = users_folder_node->RemoveFromScopePane(nameSpace);
            BREAK_ON_FAILED_HRESULT(hr);
            users_folder_node.Relinquish();
         }

         if (groups_folder_node)
         {
            hr = groups_folder_node->RemoveFromScopePane(nameSpace);
            BREAK_ON_FAILED_HRESULT(hr);
            groups_folder_node.Relinquish();
         }
      }
      while (0);
   }

   return hr;
}



HRESULT
RootNode::InsertResultColumns(IHeaderCtrl& /* headerCtrl */ )
{
   LOG_FUNCTION(RootNode::InsertResultColumns);

   return S_OK;
}



HRESULT
RootNode::InsertResultItems(IResultData& /* resultData */ )
{
   LOG_FUNCTION(RootNode::InsertResultItems);

   // insert root-level leaves, but not subordinates (as mmc will place them
   // in the result pane for me)

   // no root-level result nodes.

   return S_OK;
}



int
RootNode::GetNumberOfScopeChildren()
{
   LOG_FUNCTION(RootNode::GetNumberOfScopeChildren);

   SmartInterface<ComponentData> owner(GetOwner());
   if (owner->IsBroken())
   {
      return 0;
   }

   // groups folder and users folder
   return 2;
}



// added to fix 213003

HRESULT
RootNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(RootNode::UpdateVerbs);

   SmartInterface<ComponentData> owner(GetOwner());
   if (!owner->IsBroken())
   {
      consoleVerb.SetDefaultVerb(MMC_VERB_OPEN);
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\resnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Result Node class
// 
// 9-4-97 sburns



#include "headers.hxx"
#include "resnode.hpp"



ResultNode::ResultNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType,      
   const String&                          displayName)
   :
   Node(owner, nodeType),
   name(displayName)
{
   LOG_CTOR2(ResultNode, GetDisplayName());
}



ResultNode::~ResultNode()
{
   LOG_DTOR2(ResultNode, GetDisplayName());   
}



bool
ResultNode::HasPropertyPages()
{
   LOG_FUNCTION(ResultNode::HasPropertyPages);

   return false;
}



HRESULT
ResultNode::CreatePropertyPages(
   IPropertySheetCallback&             /* callback */ ,
   MMCPropertyPage::NotificationState* /* state    */ )
{
   LOG_FUNCTION(ResultNode::CreatePropertyPages);

   return S_OK;
}

   

HRESULT
ResultNode::InsertIntoResultPane(IResultData& resultData)
{
   LOG_FUNCTION2(ResultNode::InsertIntoResultPane, GetDisplayName());  

   HRESULT hr = S_OK;
   RESULTDATAITEM item;

   // REVIEWED-2002/03/04-sburns correct byte count passed
   
   ::ZeroMemory(&item, sizeof item);

   item.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
   item.str = MMC_CALLBACK;  
   item.nImage = GetNormalImageIndex();  
   item.lParam = reinterpret_cast<LPARAM>(this);

   do
   {
      hr = resultData.InsertItem(&item);
      BREAK_ON_FAILED_HRESULT(hr);
      // could save the item.ID in the node, but so far this is not
      // necessary information to retain.

      LOG(
         String::format(
            "result item inserted, cookie = 0x%1!08X!, name =",
            item.lParam,
            GetDisplayName().c_str()));
   }
   while (0);

   return hr;
}



HRESULT
ResultNode::DoAddPage(
   MMCPropertyPage&           page,
   IPropertySheetCallback&    callback)
{
   LOG_FUNCTION2(ResultNode::DoAddPage, GetDisplayName());
      
   HRESULT hr = S_OK;
   do
   {
      HPROPSHEETPAGE hpage = page.Create();
      if (!hpage)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      hr = callback.AddPage(hpage);
      if (FAILED(hr))
      {
         ASSERT(false);

         // note that this is another hr, not the one from the enclosing
         // scope.

         HRESULT unused = Win::DestroyPropertySheetPage(hpage);

         ASSERT(SUCCEEDED(unused));

         break;
      }
   }
   while (0);

   return hr;
}



String
ResultNode::GetDisplayName() const
{
//   LOG_FUNCTION(ResultNode::GetDisplayName);  

   return name;
}



HRESULT
ResultNode::Rename(const String& /* newName */ )
{
   LOG_FUNCTION(ResultNode::Rename);

   return S_FALSE;
}



void
ResultNode::SetDisplayName(const String& newName)
{
   LOG_FUNCTION2(ResultNode::SetDisplayName, newName);

   name = newName;
}



HRESULT
ResultNode::Delete()
{
   LOG_FUNCTION(ResultNode::Delete);

   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\rootnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Root Node class
// 
// 9-2-97 sburns



#ifndef ROOTNODE_HPP_INCLUDED
#define ROOTNODE_HPP_INCLUDED



#include "scopnode.hpp"



class UsersFolderNode;
class GroupsFolderNode;
class AdminRolesFolderNode;
class PoliciesFolderNode;
class ComponentData;



// For the snapin in stand-alone mode, a "phantom" node (i.e. it is not
// actually inserted into the scope pane) representing the snapin root node.
// This maintains the consistency of the object hierarchy.
// 
// When the snapin is in extension mode, this node is inserted as a child of
// the extended snapin.

class RootNode : public ScopeNode
{
   friend class ComponentData;

   public:

   // Node overrides

   virtual
   String
   GetColumnText(int column);

   virtual
   String
   GetDisplayName() const;

   virtual 
   int
   GetNormalImageIndex();

   virtual
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ScopeNode overrides

   virtual
   int
   GetNumberOfScopeChildren();

   virtual
   int
   GetOpenImageIndex();

   virtual
   HRESULT
   InsertResultColumns(IHeaderCtrl& headerCtrl);

   virtual
   HRESULT
   InsertResultItems(IResultData& resultData);

   virtual
   HRESULT
   InsertScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   virtual 
   HRESULT
   RemoveScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   private:

   // Creates a new instance.  Declared private so only the friend
   // ComponentData can create new instances.
   //
   // owner - the ComponentData that creates the object.  This is passed to
   // all subsequent nodes that are created by this node, both ScopeNodes and
   // ResultNodes.

   RootNode(const SmartInterface<ComponentData>& owner);

   // only we can delete ourselves via Release
   virtual ~RootNode();

   SmartInterface<UsersFolderNode>  users_folder_node; 
   SmartInterface<GroupsFolderNode> groups_folder_node;
   mutable String                   name;

   // not implemented: no copying allowed

   RootNode(const RootNode&);
   const RootNode& operator=(const RootNode&);
};



#endif   // ROOTNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\setpass.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// SetPasswordDialog class
// 
// 10-29-97 sburns



#ifndef SETPASS_HPP_INCLUDED
#define SETPASS_HPP_INCLUDED



#include "dialog.hpp"



// Dialog to accept a new password and confirmation, then change a user
// account password.

class SetPasswordDialog : public Dialog
{
   public:

   // Creates a new instance.
   // 
   // userADSIPath - in, fully-qualified ADSI path of the user account for
   // which the password is to be set.
   //
   // displayName - in, display name of the account corresponding to
   // userADSIPath.
   //
   // isLoggedOnUser - in, true if the account is the currently logged on
   // user, false if not.

   SetPasswordDialog(
      const String&  ADSIPath,
      const String&  displayName,
      bool           isLoggedOnUser);

   virtual ~SetPasswordDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String path;
   String displayName;
   bool   isLoggedOnUser;

   // not defined: no copying allowed

   SetPasswordDialog(const SetPasswordDialog&);
   const SetPasswordDialog& operator=(const SetPasswordDialog&);
};



#endif   // SETPASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\scopnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Scope Node class
// 
// 9-4-97 sburns



#ifndef SCOPNODE_HPP_INCLUDED
#define SCOPNODE_HPP_INCLUDED



#include "node.hpp"



// Struct used by BuildResultColumns.  Should be nested in ScopeNode, but vc++
// templates seem to have trouble with nested classes as parameters.

struct ResultColumn
{
   int colTextResID;    // header text string resource ID
   int colWidthResID;   // string with decimal integer pixel width
};



// ScopeNode instances represent items appearing in the scope pane.  An
// instance of ScopeNode "owns" the items (which are ResultNode instances) to
// be displayed in the result pane when that instance is expanded in the scope
// pane.

class ScopeNode : public Node
{
   public:

   // Returns the text to be displayed in the description bar of the result
   // pane when the node is shown.  The default implementation returns the
   // empty string.

   virtual
   String
   GetDescriptionBarText();

   // Returns the number of scope children that will be inserted by
   // InsertScopeChildren.  The default implementation returns 0.  If you
   // don't know how many children you will have, return 1.

   virtual
   int
   GetNumberOfScopeChildren();

   // Returns the image index of the icon image for this node to be used then
   // the node is shown in the "open" or expanded state.  This is the index of
   // the image that was registered with MMC by IComponent in response to the
   // MMCN_ADD_IMAGES notification.  This should always return the same index
   // for all invocations.
   
   virtual
   int
   GetOpenImageIndex() = 0;

   // The default implementation returns MMC_VIEW_OPTIONS_NONE;

   virtual
   long
   GetViewOptions();

   // Called from IComponentData::Notify upon receipt of a MMCN_EXPAND
   // notification.  Derived classes should override this function to insert
   // any subordinate ScopeNodes (*not* ResultNodes).  The default
   // implementation does nothing, and returns S_OK.
   // 
   // nameSpace - The console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.
   // 
   // scopeID - The HSCOPEITEM passed as the param argument to the MMCN_EXPAND
   // notification.

   virtual 
   HRESULT
   InsertScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           scopeID);

   // Called by IComponent::Notify upon receipt of a MMCN_SHOW notification.
   // Derived classes should provide an implementation which inserts columns
   // for each of the columns supported by the node's owned items; that is,
   // for each column for which the owned node's GetColumnText method will
   // support.
   // 
   // headerCtrl - The console's IHeaderCtrl interface, obtained upon
   // IComponentData::Initialize

   virtual
   HRESULT
   InsertResultColumns(IHeaderCtrl& headerCtrl) = 0;

   // Called by IComponent::Notify upon receipt of a MMCN_SHOW notification,
   // or MMCN_VIEW_CHANGE notification (where the arg indicates that the
   // result pane is to be re-populated).  Derived classes should iterate
   // through their dependent ResultNodes, calling InsertIntoResultPane for
   // each.
   //
   // resultData - The console's IResultData interface, obtained upon
   // IComponentData::Initialize.

   virtual
   HRESULT
   InsertResultItems(IResultData& resultData) = 0;

   // Inserts self into the scope pane.  Typically called from a parent
   // ScopeNode's implementation of InsertScopeChildren.
   //
   // nameSpace - The console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.
   // 
   // parentScopeID - The HSCOPEITEM passed as the param argument to the
   // MMCN_EXPAND notification received by the parent ScopeNode, then passed
   // to the parent ScopeNode's InsertScopeChildren

   HRESULT
   InsertIntoScopePane(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   // Called by IComponent::Notify upon receipt of a MMCN_REFRESH
   // notification, if the node's implementation of UpdateVerbs has enabled
   // the MMC_VERB_REFERESH verb.
   // 
   // Derived classes should release any dependent data, then rebuild it.
   //
   // The refresh cycle works like this:
   // MMCN_REFRESH received for the ScopeNode
   //   - UpdateAllViews is called to clear the result pane of any view for
   //     which the current selected node is the same ScopeNode.  This is
   //     done by comparing nodes and using IResultData::DeleteAllRsltItems.
   //   - ScopeNode::RebuildResultItems is called for the ScopeNode.
   //   - UpdateAllViews is called to repopulate the result pane of any view
   //     for which the current selected node is the same ScopeNode.  This
   //     is done by comparing nodes and calling InsertResultItems for the
   //     ScopeNode.

   virtual
   HRESULT
   RebuildResultItems();

   // Removes self from the scope pane.  Typically called from a parent
   // ScopeNode's implementation of RemoveScopeChildren on it's children.
   // 
   // If this node has scope pane children, then this call will cause
   // MMCN_REMOVE_CHILDREN to be fired for this node, which will call
   // RemoveScopeChildren for this node.  
   //
   // nameSpace - the console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.

   HRESULT
   RemoveFromScopePane(IConsoleNameSpace2& nameSpace);

   // Called from IComponentData::Notify upon receipt of a
   // MMCN_REMOVE_CHILDREN notification.  Derived classes should override this
   // function to remove any subordinate ScopeNodes (*not* ResultNodes).  The
   // default implementation does nothing, and returns S_OK.
   // 
   // nameSpace - The console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.
   // 
   // parentScopeID - The HSCOPEITEM passed as the param argument to the
   // MMCN_REMOVE_CHILDREN notification.

   virtual 
   HRESULT
   RemoveScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   protected:

   // Constructs a new instance.  Declared protected to allow this class to
   // only be a base class.
   //
   // owner - supplied to base class contructor
   // 
   // nodeType - NodeType GUID supplied to the base class constructor.

   ScopeNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType);

   virtual ~ScopeNode();

   // Helper function used to implement InsertResultColumns.
   // 
   // begin - Iterator positioned to the beginning ResultColumn instance.
   // 
   // end - Iterator positioned just beyond the last ResultColumn instance.
   //
   // headerCtrl - the IHeaderCtrl instance passed to InsertResultColumns.

   template <class InputIterator>
   HRESULT
   BuildResultColumns(
      InputIterator  begin,
      InputIterator  end,
      IHeaderCtrl&   headerCtrl)
   {
      int col = 0;
      HRESULT hr = S_OK;
      for (
         ;
         begin != end;
         ++begin)
      {
         int width = 0;
         String::load((*begin).colWidthResID).convert(width);

         // minimum width is 100 units.
         width = max(100, width);

         hr =
            headerCtrl.InsertColumn(
               col++,
               String::load((*begin).colTextResID).c_str(),
               LVCFMT_LEFT,
               width);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      return hr;
   }

   private:

   HSCOPEITEM item_id;

   // not implemented: no copying allowed

   ScopeNode(const ScopeNode&);
   const ScopeNode& operator=(const ScopeNode&);
};



#endif   // SCOPNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\setpass.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// SetPasswordDialog class
// 
// 10-29-97 sburns



#include "headers.hxx"
#include "setpass.hpp"
#include "resource.h"
#include "dlgcomm.hpp"
#include "adsi.hpp"
#include "lsm.h"
#include "waste.hpp"
#include "fpnw.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_PASSWORD,      idh_setpass_new_password,    
   IDC_CONFIRM,       idh_setpass_confirm_password,
   IDCANCEL,          NO_HELP,                     
   IDOK,              NO_HELP,                     
   IDC_WARNING_TEXT1, NO_HELP,                     
   0, 0
};



SetPasswordDialog::SetPasswordDialog(
   const String&  ADSIPath,
   const String&  displayName_,
   bool           isLoggedOnUser_)
   :
   Dialog(IDD_SET_PASSWORD, HELP_MAP),
   path(ADSIPath),
   displayName(displayName_),
   isLoggedOnUser(isLoggedOnUser_)   
{
   LOG_CTOR(SetPasswordDialog);
   ASSERT(!path.empty());
   ASSERT(!displayName.empty());
}
      


SetPasswordDialog::~SetPasswordDialog()
{
   LOG_DTOR(SetPasswordDialog);
}



void
SetPasswordDialog::OnInit()
{
   LOG_FUNCTION(SetPasswordDialog::OnInit());

   Win::SetWindowText(
      hwnd,
      String::format(IDS_SET_PASSWORD_TITLE, displayName.c_str()));
   
   // Load appropriate warning text based on whether the logged on user is
   // setting the password for his own account or another user.

   if (isLoggedOnUser)
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_WARNING_TEXT1,
         IDS_SET_PASSWORD_WARNING_BULLET_SELF1);
   }
   else
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_WARNING_TEXT1,
         IDS_SET_PASSWORD_WARNING_BULLET_OTHER1);
   }

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PASSWORD), PWLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_CONFIRM), PWLEN);
}



// // HRESULT
// // setFPNWPassword(
// //    SmartInterface<IADsUser>& user,
// //    const String&           userADSIPath,
// //    const String&           password)
// // {
// //    LOG_FUNCTION2(setFPNWPassword, userADSIPath);
// //    ASSERT(user);
// //    ASSERT(!userADSIPath.empty());
// // 
// //    HRESULT hr = S_OK;
// //    do
// //    {
// //       // determine the secret key
// //       String secret;
// // 
// //       hr =
// //          FPNW::GetLSASecret(
// //             ADSI::PathCracker(userADSIPath).serverName(),
// //             secret);
// //       if (FAILED(hr))
// //       {
// //          // fpnw is not installed, so we're done
// //          LOG(L"fpnw not installed");
// //          hr = S_OK;
// //          break;
// //       }
// // 
// //       // get the user's toxic waste dump
// //       _variant_t variant;
// //       hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       WasteExtractor dump(V_BSTR(&variant));
// //       variant.Clear();
// // 
// //       // check to see if there is a fpnw password on in the waste dump.
// //       // if present, this implies that the account is fpnw-enabled
// //       hr = dump.IsPropertyPresent(NWPASSWORD);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       if (hr == S_FALSE)
// //       {
// //          LOG(L"account not fpnw enabled");
// //          hr = S_OK;
// //          break;
// //       }
// // 
// //       // load up the fpnw client dll.
// //       SafeDLL client_DLL(String::load(IDS_FPNW_CLIENT_DLL));
// // 
// //       // get the object id
// //       DWORD object_id = 0;
// //       DWORD unused = 0;
// //       hr =
// //          FPNW::GetObjectIDs(
// //             user,
// //             client_DLL,
// //             object_id,
// //             unused);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       // now we have all the ingredients required.
// // 
// //       hr =
// //          FPNW::SetPassword(
// //             dump,
// //             client_DLL,
// //             password,
// //             secret,
// //             object_id);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       // reset the last password set time (which clears the expired flag)
// // 
// //       LARGE_INTEGER li = {0, 0};
// //       ::NtQuerySystemTime(&li);
// // 
// //       hr = dump.Put(NWTIMEPASSWORDSET, li);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //    }
// //    while (0);
// // 
// //    return hr;
// // }



HRESULT
setPassword(const String& path, const EncryptedString& password)
{
   LOG_FUNCTION(setPassword);
   ASSERT(!path.empty());

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(path, user);
      BREAK_ON_FAILED_HRESULT(hr);

      PWSTR cleartext = password.GetClearTextCopy();
      if (!cleartext)
      {
         // fail the operation rather than set a null password.
         
         hr = E_OUTOFMEMORY;
         BREAK_ON_FAILED_HRESULT(hr);
      }          
      
      hr = user->SetPassword(AutoBstr(cleartext));

      password.DestroyClearTextCopy(cleartext);
      
      BREAK_ON_FAILED_HRESULT(hr);

// It appears that IADsUser will set the password for us.

// //       hr = setFPNWPassword(user, path, password);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       hr = user->SetInfo();
// //       BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   return hr;
}



bool
SetPasswordDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(SetPasswordDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM))
            {
               EncryptedString password =
                  Win::GetEncryptedDlgItemText(hwnd, IDC_PASSWORD);
               HRESULT hr = setPassword(path, password);
               if (SUCCEEDED(hr))
               {
                  popup.Info(
                     hwnd,
                     String::load(IDS_PASSWORD_CHANGE_SUCCESSFUL));

                  HRESULT unused = Win::EndDialog(hwnd, IDOK);

                  ASSERT(SUCCEEDED(unused));
               }
               else
               {
                  Win::SetDlgItemText(hwnd, IDC_PASSWORD, String());
                  Win::SetDlgItemText(hwnd, IDC_CONFIRM, String());
                 
                  popup.Error(
                     hwnd,
                     hr,
                     String::format(
                        IDS_ERROR_SETTING_PASSWORD,            
                        ADSI::ExtractObjectName(path).c_str()));

                  if (hr == Win32ToHresult((DWORD) NERR_PasswordTooShort))
                  {
                     Win::SetFocus(Win::GetDlgItem(hwnd, IDC_PASSWORD));
                  }
               }
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, IDCANCEL);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\setpasswordwarningdialog.hpp ===
// Copyright (C) 2001 Microsoft Corporation
// 
// SetPasswordWarningDialog class
// 
// 21 Feb 2001 sburns



#ifndef SETPASSWORDWARNINGDIALOG_HPP_INCLUDED
#define SETPASSWORDWARNINGDIALOG_HPP_INCLUDED



#include "dialog.hpp"



// Dialog to accept a new password and confirmation, then change a user
// account password.

class SetPasswordWarningDialog : public Dialog
{
   public:

   // Creates a new instance.
   // 
   // userADSIPath - in, fully-qualified ADSI path of the user account for
   // which the password is to be set.
   //
   // displayName - in, display name of the account corresponding to
   // userADSIPath.
   //
   // isLoggedOnUser - in, true if the account is the currently logged on
   // user, false if not.

   SetPasswordWarningDialog(
      const String&  userAdsiPath,
      const String&  userDisplayName,
      bool           isLoggedOnUser);

   virtual ~SetPasswordWarningDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String path;
   String displayName;
   bool   isLoggedOnUser;
   bool   isFriendlyLogonMode;

   // not defined: no copying allowed

   SetPasswordWarningDialog(const SetPasswordWarningDialog&);
   const SetPasswordWarningDialog& operator=(const SetPasswordWarningDialog&);
};



#endif   // SETPASSWORDWARNINGDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\scopnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Scope Node class
// 
// 9-4-97 sburns



#include "headers.hxx"
#include "scopnode.hpp"



ScopeNode::ScopeNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType)
   :
   Node(owner, nodeType)
{
   LOG_CTOR(ScopeNode);
}



ScopeNode::~ScopeNode()
{
   LOG_DTOR(ScopeNode);
}



HRESULT
ScopeNode::InsertIntoScopePane(
   IConsoleNameSpace2&  nameSpace,
   HSCOPEITEM           parentScopeID)
{
   LOG_FUNCTION2(ScopeNode::InsertIntoScopePane, GetDisplayName());

   HRESULT hr = S_OK;
   SCOPEDATAITEM item;

   // REVIEWED-2002/03/04-sburns correct byte count passed.
   
   ::ZeroMemory(&item, sizeof item);

   item.mask =
         SDI_STR
      |  SDI_IMAGE
      |  SDI_OPENIMAGE
      |  SDI_PARAM
      |  SDI_PARENT
      |  SDI_CHILDREN;
   item.displayname = MMC_CALLBACK;  
   item.relativeID = parentScopeID;

   do
   {
      item.lParam       = reinterpret_cast<LPARAM>(this);
      item.nImage       = GetNormalImageIndex();
      item.nOpenImage   = GetOpenImageIndex();
      item.cChildren    = GetNumberOfScopeChildren();

      hr = nameSpace.InsertItem(&item);
      BREAK_ON_FAILED_HRESULT(hr);

      // retained for RemoveFromScopePane
      item_id = item.ID;
   }
   while (0);

   return hr;
}



HRESULT
ScopeNode::RemoveFromScopePane(IConsoleNameSpace2& nameSpace)
{
   LOG_FUNCTION2(ScopeNode::RemoveFromScopePane, GetDisplayName());

   ASSERT(item_id);

   return nameSpace.DeleteItem(item_id, TRUE);
}
   


HRESULT
ScopeNode::InsertScopeChildren(
   IConsoleNameSpace2& /* nameSpace     */ ,
   HSCOPEITEM          /* parentScopeID */ )
{
   LOG_FUNCTION(ScopeNode::InsertScopeChildren);

   return S_OK;
}




HRESULT
ScopeNode::RemoveScopeChildren(
   IConsoleNameSpace2& /* nameSpace     */ ,
   HSCOPEITEM          /* parentScopeID */ )
{
   LOG_FUNCTION(ScopeNode::RemoveScopeChildren);

   return S_OK;
}



HRESULT
ScopeNode::RebuildResultItems()
{
   LOG_FUNCTION(ScopeNode::RebuildResultItems);

   // default is to do nothing.
   return S_OK;
}



long
ScopeNode::GetViewOptions()
{
   LOG_FUNCTION(ScopeNode::GetViewOptions);

   return MMC_VIEW_OPTIONS_LEXICAL_SORT; 
}



int
ScopeNode::GetNumberOfScopeChildren()
{
   LOG_FUNCTION(ScopeNode::GetNumberOfScopeChildren);

   return 0;
}



String
ScopeNode::GetDescriptionBarText()
{
   LOG_FUNCTION(ScopeNode::GetDescriptionBarText);

   return String();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\userfpnwpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UserFpnwPage class
//
// 9-11-98 sburns



#include "headers.hxx"
#include "UserFpnwPage.hpp"
#include "resource.h"
#include "dlgcomm.hpp"
#include "adsi.hpp"
#include "waste.hpp"
#include "fpnwlog.hpp"
#include "fpnwpass.hpp"
#include "fpnw.hpp"



static const String FPNWVOLUMEGETINFO(L"FpnwVolumeGetInfo");
typedef DWORD (*FPNWVolumeGetInfo)(PWSTR, PWSTR, DWORD, PBYTE*);

static const String FPNWAPIBUFFERFREE(L"FpnwApiBufferFree");
typedef DWORD (*FPNWApiBufferFree)(PVOID);

static const int MAX_GRACE_LOGINS = 200;
static const int MAX_CONNECTIONS = 1000;



static const int NO_GRACE_LOGIN_LIMIT=0xFF; // net\ui\admin\user\user\ncp.cxx
static const DWORD MAX_PASSWORD_AGE = static_cast<DWORD>(-1);


static const DWORD HELP_MAP[] =
{
   IDC_CONCURRENT_CONNECTIONS,   NO_HELP,
   IDC_CONNECTION_LIMIT,         NO_HELP,
   IDC_CONNECTION_SPIN,          NO_HELP,
   IDC_GRACE_LIMIT,              NO_HELP,
   IDC_GRACE_LIMIT,              NO_HELP,
   IDC_GRACE_LOGINS,             NO_HELP,
   IDC_GRACE_REMAINING,          NO_HELP,
   IDC_GRACE_REMAINING_SPIN,     NO_HELP,
   IDC_GRACE_REMAINING_TEXT,     NO_HELP,
   IDC_GRACE_SPIN,               NO_HELP,
   IDC_LIMIT_CONNECTIONS,        NO_HELP,
   IDC_LIMIT_CONNECTIONS,        NO_HELP,
   IDC_LIMIT_GRACELOGINS,        NO_HELP,
   IDC_LIMIT_GRACELOGINS,        NO_HELP,
   IDC_NETWARE_ENABLE,           NO_HELP,
   IDC_NWHMDIR_RELPATH,          NO_HELP,
   IDC_NWHMDIR_RELPATH_TEXT,     NO_HELP,
   IDC_NWPWEXPIRED,              NO_HELP,
   IDC_OBJECTID_TEXT,            NO_HELP,
   IDC_OBJECT_ID,                NO_HELP,
   IDC_SCRIPT_BUTTON,            NO_HELP,
   IDC_UNLIMITED_CONNECTIONS,    NO_HELP,
   IDC_UNLIMITED_GRACELOGINS,    NO_HELP,
   0, 0
};



UserFpnwPage::UserFpnwPage(
   MMCPropertyPage::NotificationState* state,
   const ADSI::Path&                   path)
   :
   ADSIPage(
      IDD_USER_FPNW,
      HELP_MAP,
      state,
      path),
   maxPasswordAge(MAX_PASSWORD_AGE),
   minPasswordLen(0),
   clientDll(String::load(IDS_FPNW_CLIENT_DLL)),
   scriptRead(false),
   fpnwEnabled(false),
   objectId(0)
{
   LOG_CTOR2(UserFpnwPage::ctor, path.GetPath());
}



UserFpnwPage::~UserFpnwPage()
{
   LOG_DTOR2(UserFpnwPage, GetPath().GetPath());
}



static
void
Enable(HWND dialog)
{
   LOG_FUNCTION(Enable);
   ASSERT(Win::IsWindow(dialog));

   // this checkbox determines if the rest of the controls on the page
   // are enabled or not.

   bool maintain_login =
      Win::IsDlgButtonChecked(dialog, IDC_NETWARE_ENABLE);

   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_NWPWEXPIRED),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_LOGINS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_UNLIMITED_GRACELOGINS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_LIMIT_GRACELOGINS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CONCURRENT_CONNECTIONS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_UNLIMITED_CONNECTIONS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_LIMIT_CONNECTIONS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_OBJECTID_TEXT),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_OBJECT_ID),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_NWHMDIR_RELPATH_TEXT),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_NWHMDIR_RELPATH),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_SCRIPT_BUTTON),
      maintain_login);

   bool limit_grace_logins =
      Win::IsDlgButtonChecked(dialog, IDC_LIMIT_GRACELOGINS);

   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_LIMIT),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_SPIN),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_REMAINING),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_REMAINING_TEXT),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_LIMIT),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_REMAINING_SPIN),
      maintain_login && limit_grace_logins);

   bool limitConnections =
      Win::IsDlgButtonChecked(dialog, IDC_LIMIT_CONNECTIONS);

   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CONNECTION_LIMIT),
      maintain_login && limitConnections);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CONNECTION_SPIN),
      maintain_login && limitConnections);
}



HRESULT
GetPasswordRestrictions(
   const String&  machine,
   DWORD&         minimumPasswordLength,
   DWORD&         maximumPasswordAge)
{
   LOG_FUNCTION(GetPasswordRestrictions);
   ASSERT(!machine.empty());

   HRESULT hr = S_OK;
   USER_MODALS_INFO_0 *info = 0;

   minimumPasswordLength = 0;
   maximumPasswordAge = MAX_PASSWORD_AGE;

   // the Net API's don't work when the
   // specified machine name is that of the local machine...

   PCWSTR m = Win::IsLocalComputer(machine) ? 0 : machine.c_str();

   LOG(L"Calling NetUserModalsGet");
   LOG(String::format(L"servername : %1", m ? m : L"(null)"));
   LOG(               L"level      : 0");

   NET_API_STATUS status =
      ::NetUserModalsGet(
         m,
         0,
         reinterpret_cast<BYTE**>(&info));

   if (status == NERR_Success)
   {
      minimumPasswordLength = info->usrmod0_min_passwd_len;
      maximumPasswordAge = info->usrmod0_max_passwd_age;
   }
   else
   {
      hr = Win32ToHresult(status);
   }

   if (info)
   {
      NetApiBufferFree(info);
   }

   LOG(String::format(L"Result 0x%1!X!", hr));

   return hr;
}



// compare the given time to the current system clock reading.  return true
// if the time is beyond the maximum, false otherwise

bool
IsPasswordExpired(const LARGE_INTEGER& lastTimeSet, DWORD maxPasswordAge)
{
   LOG_FUNCTION(IsPasswordExpired);
   ASSERT(lastTimeSet.LowPart);
   ASSERT(lastTimeSet.HighPart);
   ASSERT(maxPasswordAge);

   DWORD age = 0;

   if (
         (lastTimeSet.LowPart == 0xffffffff)
      && (lastTimeSet.HighPart == 0xffffffff) )
   {
      age = 0xffffffff;
   }
   else
   {
      LARGE_INTEGER now = {0, 0};
      LARGE_INTEGER delta = {0, 0};

      ::NtQuerySystemTime(&now);

      delta.QuadPart = now.QuadPart - lastTimeSet.QuadPart;
      delta.QuadPart /= 10000000;   // time resolution in seconds

      // @@ this truncation makes me queasy.

      age = delta.LowPart;
   }

   return (age >= maxPasswordAge);
}



HRESULT
determineLoginScriptFilename(
   const SafeDLL& clientDLL,
   const String&  machine,
   DWORD          swappedObjectID,
   String&        result)
{
   LOG_FUNCTION(DetermineLoginScriptFilename);
   ASSERT(swappedObjectID);
   ASSERT(!machine.empty());

   result.erase();

   HRESULT hr = S_OK;
   do
   {
      FARPROC f = 0;

      hr = clientDLL.GetProcAddress(FPNWVOLUMEGETINFO, f);
      BREAK_ON_FAILED_HRESULT(hr);

      FPNWVOLUMEINFO* info = 0;
      DWORD err =
         ((FPNWVolumeGetInfo) f)(
            const_cast<wchar_t*>(machine.c_str()),
            SYSVOL_NAME_STRING,
            1,
            reinterpret_cast<PBYTE*>(&info));
      if (err != NERR_Success)
      {
         hr = Win32ToHresult(err);
      }
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info);
      String volume = info->lpPath;

      // one could argue that this isn't really fatal, but I'm in bad mood.
      hr = clientDLL.GetProcAddress(FPNWAPIBUFFERFREE, f);
      BREAK_ON_FAILED_HRESULT(hr);

      ((FPNWApiBufferFree) f)(info);

      result =
         String::format(
            L"%1\\MAIL\\%2!x!\\LOGIN",
            volume.c_str(),
            swappedObjectID);
   }
   while (0);

   return hr;
}



void
UserFpnwPage::OnInit()
{
   LOG_FUNCTION(UserFpnwPage::OnInit());

   // load the user properties into the dialog, setup the controls

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetPath().GetSidPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      // retrieve the toxic waste dump

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      WasteExtractor dump(V_BSTR(&variant));
      variant.Clear();

      //
      // object ID
      //

      DWORD swappedObjectId = 0;
      hr =
         FPNW::GetObjectIDs(
            user,
            clientDll,
            objectId,
            swappedObjectId);
      BREAK_ON_FAILED_HRESULT(hr);

      // the object ID we display is the "swapped" version, whatever that
      // means.

      Win::SetDlgItemText(
         hwnd,
         IDC_OBJECT_ID,
         String::format(L"%1!08X!", swappedObjectId));

      //
      // login script filename
      //

      hr =
         determineLoginScriptFilename(
            clientDll,
            GetMachineName(),
            swappedObjectId,
            loginScriptFilename);
      BREAK_ON_FAILED_HRESULT(hr);

      // the presence/absence of a NetWare password is the flag indicating
      // whether the acccount is FPNW-enabled

      hr = dump.IsPropertyPresent(NWPASSWORD);
      BREAK_ON_FAILED_HRESULT(hr);

      fpnwEnabled = (hr == S_OK);

      Win::CheckDlgButton(
         hwnd,
         IDC_NETWARE_ENABLE,
         fpnwEnabled ? BST_CHECKED : BST_UNCHECKED);

      USHORT graceLoginsAllowed   = DEFAULT_GRACELOGINALLOWED;  
      USHORT graceLoginsRemaining = DEFAULT_GRACELOGINREMAINING;
      USHORT maxConnections       = 1;                          
      bool   limitGraceLogins     = true;                       
      bool   limitConnections     = false;                      

      if (fpnwEnabled)
      {
         // the other fields are only valid if we're enabling the account
         // for fpnw access.

         //
         // password expired
         //

         hr =
            GetPasswordRestrictions(
               GetMachineName(),
               minPasswordLen,
               maxPasswordAge);
         BREAK_ON_FAILED_HRESULT(hr);

         LARGE_INTEGER lastTimeSet = {0, 0};
         hr = dump.Get(NWTIMEPASSWORDSET, lastTimeSet);
         BREAK_ON_FAILED_HRESULT(hr);

         // an S_FALSE result would indicate that no password last time set was
         // present, which would be an inconsistency

         ASSERT(hr == S_OK);

         bool passwordExpired = true;
         if (hr == S_OK)
         {
            passwordExpired = IsPasswordExpired(lastTimeSet, maxPasswordAge);
         }

         Win::CheckDlgButton(
            hwnd,
            IDC_NWPWEXPIRED,
            passwordExpired ? BST_CHECKED : BST_UNCHECKED);

         //
         // grace logins
         //

         hr = dump.Get(GRACELOGINALLOWED, graceLoginsAllowed);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Get(GRACELOGINREMAINING, graceLoginsRemaining);
         BREAK_ON_FAILED_HRESULT(hr);

         limitGraceLogins =
            (graceLoginsRemaining != NO_GRACE_LOGIN_LIMIT);

         //
         // concurrent connections
         //

         hr = dump.Get(MAXCONNECTIONS, maxConnections);
         BREAK_ON_FAILED_HRESULT(hr);

         // if the property is not present, then we consider the connections
         // unlimited.

         if (hr == S_FALSE)
         {
            maxConnections = NO_LIMIT;
         }

         limitConnections = (maxConnections != NO_LIMIT);

         //
         // home directory
         //

         String homeDir;
         hr = dump.Get(NWHOMEDIR, homeDir);
         BREAK_ON_FAILED_HRESULT(hr);

         Win::SetDlgItemText(hwnd, IDC_NWHMDIR_RELPATH, homeDir);
      }

      // update the UI to reflect the values set (or, in the case that
      // the account is not FPNW-enabled, the defaults)

      Win::CheckRadioButton(
         hwnd,
         IDC_UNLIMITED_GRACELOGINS,
         IDC_LIMIT_GRACELOGINS,
            limitGraceLogins
         ?  IDC_LIMIT_GRACELOGINS
         :  IDC_UNLIMITED_GRACELOGINS);

      HWND spin = Win::GetDlgItem(hwnd, IDC_GRACE_SPIN);
      Win::Spin_SetRange(spin, 1, MAX_GRACE_LOGINS);
      Win::Spin_SetPosition(spin, graceLoginsAllowed);

      spin = Win::GetDlgItem(hwnd, IDC_GRACE_REMAINING_SPIN);
      Win::Spin_SetRange(spin, 0, graceLoginsAllowed);
      Win::Spin_SetPosition(
         spin,
         min(graceLoginsRemaining, graceLoginsAllowed));

      Win::CheckRadioButton(
         hwnd,
         IDC_UNLIMITED_CONNECTIONS,
         IDC_LIMIT_CONNECTIONS,
            limitConnections
         ?  IDC_LIMIT_CONNECTIONS
         :  IDC_UNLIMITED_CONNECTIONS);

      spin = Win::GetDlgItem(hwnd, IDC_CONNECTION_SPIN);
      Win::Spin_SetRange(spin, 1, MAX_CONNECTIONS);
      Win::Spin_SetPosition(
         spin,
         limitConnections ? maxConnections : 1);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_READING_USER,
            GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   Enable(hwnd);
}



bool
UserFpnwPage::Validate()
{
   LOG_FUNCTION(UserFpnwPage::Validate);

   bool result = true;
   do
   {
      if (WasChanged(IDC_NWHMDIR_RELPATH))
      {
         // validate the home dir as a relative path

         String homedir = Win::GetTrimmedDlgItemText(hwnd, IDC_NWHMDIR_RELPATH);

         if (homedir.empty())
         {
            // no path is ok

            break;
         }

         if (FS::GetPathSyntax(homedir) != FS::SYNTAX_RELATIVE_NO_DRIVE)
         {
            popup.Gripe(
               hwnd,
               IDC_NWHMDIR_RELPATH,
               String::format(
                  IDS_BAD_FPNW_HOMEDIR,
                  homedir.c_str(),
                  GetObjectName().c_str()));
            result = false;
            break;
         }
      }
   }
   while (0);

   return result;
}



bool
UserFpnwPage::OnKillActive()
{
   LOG_FUNCTION(UserFpnwPage::OnKillActive);

   if (!Validate())
   {
      // refuse to relinquish focus
      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
   }

   return true;
}



HRESULT
SetUserFlag(
   const SmartInterface<IADsUser>&  user,
   DWORD                            flag,
   bool                             state)
{
   LOG_FUNCTION(SetUserFlag);

   HRESULT hr = S_OK;

   do
   {
      // read the existing flags

      _variant_t getVariant;

      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserFlags), &getVariant);
      BREAK_ON_FAILED_HRESULT(hr);

      long flags = getVariant;

      // set the flag

      if (state)
      {
         flags |= flag;
      }
      else
      {
         flags &= ~flag;
      }

      _variant_t putVariant(flags);

      hr = user->Put(AutoBstr(ADSI::PROPERTY_UserFlags), putVariant);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
UserFpnwPage::SavePassword(
   const SmartInterface<IADsUser>&  user,
   WasteExtractor&                  dump,
   const EncryptedString&           newPassword)
{
   LOG_FUNCTION(UserFpnwPage::SavePassword);

   HRESULT hr = S_OK;
   do
   {
      // change the user's NT password also

      PWSTR cleartext = newPassword.GetClearTextCopy();
      if (!cleartext)
      {
         // fail the operation rather than set a null password.
         
         hr = E_OUTOFMEMORY;
         BREAK_ON_FAILED_HRESULT(hr);
      }          
      
      hr = user->SetPassword(AutoBstr(cleartext));

      newPassword.DestroyClearTextCopy(cleartext);
      
      BREAK_ON_FAILED_HRESULT(hr);

      String secret;
      hr = FPNW::GetLSASecret(GetPath().GetServerName(), secret);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         FPNW::SetPassword(
            dump,
            clientDll,
            newPassword,
            secret,
            objectId);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
UserFpnwPage::OnApply(bool /* isClosing */)
{
   LOG_FUNCTION(UserFpnwPage::OnApply);

   if (!WasChanged())
   {
      return true;
   }

   // don't need to call validate; kill active is sent before apply

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetPath().GetSidPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      // re-read the waste dump

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      WasteExtractor dump(V_BSTR(&variant));
      variant.Clear();

      // save the changes, creating a new waste dump

      bool maintainLogin =
         Win::IsDlgButtonChecked(hwnd, IDC_NETWARE_ENABLE);

      EncryptedString password;

      if (!maintainLogin)
      {
         // clear the waste dump
         hr = dump.Clear(NWPASSWORD);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(NWTIMEPASSWORDSET);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(GRACELOGINALLOWED);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(GRACELOGINREMAINING);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(MAXCONNECTIONS);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(NWHOMEDIR);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = SetUserFlag(user, UF_MNS_LOGON_ACCOUNT, false);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      else
      {
         if (maintainLogin != fpnwEnabled)
         {
            // we're enabling the account for FPNW, so get a password from
            // the user.  Writing the Netware password into the waste dump
            // is the flag that this account is fpnw-enabled.

            FPNWPasswordDialog dlg(GetObjectName());
            if (dlg.ModalExecute(hwnd) == IDCANCEL)
            {
               // bail out if the user hits cancel on the password dialog
               // 89677

               hr = S_FALSE;
               break;
            }

            hr = SetUserFlag(user, UF_MNS_LOGON_ACCOUNT, true);
            BREAK_ON_FAILED_HRESULT(hr);

            password = dlg.GetPassword();

            hr = SavePassword(user, dump, password);
            BREAK_ON_FAILED_HRESULT(hr);

            // Create login script folder, if necessary

            String parentFolder = FS::GetParentFolder(loginScriptFilename);
            if (!FS::PathExists(parentFolder))
            {
               HRESULT anotherHr = FS::CreateFolder(parentFolder);

               // don't break on failure: continue on

               LOG_HRESULT(anotherHr);
            }

            // ensure that the new time and default settings are recorded

            SetChanged(IDC_NWPWEXPIRED);
            SetChanged(IDC_LIMIT_GRACELOGINS);
            SetChanged(IDC_LIMIT_CONNECTIONS);
         }

         if (WasChanged(IDC_NWPWEXPIRED))
         {
            LARGE_INTEGER li = {0, 0};
            if (Win::IsDlgButtonChecked(hwnd, IDC_NWPWEXPIRED))
            {
               li.HighPart = -1;
               li.LowPart = static_cast<DWORD>(-1);
            }
            else
            {
               ::NtQuerySystemTime(&li);
            }

            hr = dump.Put(NWTIMEPASSWORDSET, li);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (
               WasChanged(IDC_LIMIT_GRACELOGINS)
            || WasChanged(IDC_UNLIMITED_GRACELOGINS)
            || WasChanged(IDC_GRACE_LIMIT)
            || WasChanged(IDC_GRACE_REMAINING) )
         {
            bool limitGraceLogins =
               Win::IsDlgButtonChecked(hwnd, IDC_LIMIT_GRACELOGINS);

            USHORT graceLoginsAllowed = DEFAULT_GRACELOGINALLOWED;
            USHORT graceLoginsRemaining = NO_GRACE_LOGIN_LIMIT;
            if (limitGraceLogins)
            {
               String s = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_LIMIT);
               s.convert(graceLoginsAllowed);

               s = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_REMAINING);
               s.convert(graceLoginsRemaining);
            }

            hr = dump.Put(GRACELOGINALLOWED, graceLoginsAllowed);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = dump.Put(GRACELOGINREMAINING, graceLoginsRemaining);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (
               WasChanged(IDC_UNLIMITED_CONNECTIONS)
            || WasChanged(IDC_LIMIT_CONNECTIONS)
            || WasChanged(IDC_CONNECTION_LIMIT) )
         {
            bool limitConnections =
               Win::IsDlgButtonChecked(hwnd, IDC_LIMIT_CONNECTIONS);

            USHORT maxConnections = 0;
            if (!limitConnections)
            {
               maxConnections = NO_LIMIT;
            }
            else
            {
               String s =
                  Win::GetTrimmedDlgItemText(hwnd, IDC_CONNECTION_LIMIT);
               s.convert(maxConnections);
            }

            hr = dump.Put(MAXCONNECTIONS, maxConnections);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (WasChanged(IDC_NWHMDIR_RELPATH))
         {
            hr =
               dump.Put(
                  NWHOMEDIR,
                  Win::GetTrimmedDlgItemText(hwnd, IDC_NWHMDIR_RELPATH));
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (WasChanged(IDC_SCRIPT_BUTTON))
         {
            WriteLoginScript();
         }
      }

      // update the user params with the new waste dump

      _variant_t v;
      v = dump.GetWasteDump().c_str();
      hr = user->Put(AutoBstr(ADSI::PROPERTY_UserParams), v);
      BREAK_ON_FAILED_HRESULT(hr);

      // commit the property changes

      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

// {
//       _variant_t variant;
//       hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
//       BREAK_ON_FAILED_HRESULT(hr);
// 
//       WasteExtractor dump(V_BSTR(&variant));
//       variant.Clear();
// }


      if (maintainLogin && maintainLogin != fpnwEnabled)
      {
         SmartInterface<IADsUser> user1(0);
         hr = ADSI::GetUser(GetPath().GetSidPath(), user1);
         BREAK_ON_FAILED_HRESULT(hr);

         // we're enabling the account for fpnw, and it wasn't enabled
         // before.

         // It would appear that one has to update the account flags and
         // scribble a password into the waste dump, then set the password
         // again once those changes are committed, in order for the
         // password setting to really stick.

         PWSTR cleartext = password.GetClearTextCopy();
         if (!cleartext)
         {
            // fail the operation rather than set a null password.
            
            hr = E_OUTOFMEMORY;
            BREAK_ON_FAILED_HRESULT(hr);
         }          
         
         hr = user1->SetPassword(AutoBstr(cleartext));

         password.DestroyClearTextCopy(cleartext);
         
         BREAK_ON_FAILED_HRESULT(hr);

         // Setting the password resets the grace logins remaining, so
         // if that was changed, then we need to re-write that value
         // here.
         //
         // For reasons that are unfathomable to me (which I suspect are
         // due to ADSI bug(s)), if I don't reset this value on a separate
         // binding to the user account, then it causes the account to
         // change such that the user cannot login in with fpnw.
         // That's why we rebind to the account in this scope.

         _variant_t variant1;
         hr = user1->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant1);
         BREAK_ON_FAILED_HRESULT(hr);

         WasteExtractor dump1(V_BSTR(&variant1));
         variant1.Clear();

         USHORT graceLoginsRemaining = NO_GRACE_LOGIN_LIMIT;

         String s = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_REMAINING);
         s.convert(graceLoginsRemaining);

         hr = dump1.Put(GRACELOGINREMAINING, graceLoginsRemaining);
         BREAK_ON_FAILED_HRESULT(hr);

         // We write this again, as setting the password appears to
         // clear it.

         LARGE_INTEGER li = {0, 0};
         if (Win::IsDlgButtonChecked(hwnd, IDC_NWPWEXPIRED))
         {
            li.HighPart = -1;
            li.LowPart = static_cast<DWORD>(-1);
         }
         else
         {
            ::NtQuerySystemTime(&li);
         }

         hr = dump1.Put(NWTIMEPASSWORDSET, li);
         BREAK_ON_FAILED_HRESULT(hr);

         _variant_t variant2;
         variant2 = dump1.GetWasteDump().c_str();
         hr = user1->Put(AutoBstr(ADSI::PROPERTY_UserParams), variant2);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = user1->SetInfo();
         BREAK_ON_FAILED_HRESULT(hr);
      }

// {
//       SmartInterface<IADsUser> user(0);
//       hr = ADSI::GetUser(GetADSIPath(), user);
//       BREAK_ON_FAILED_HRESULT(hr);
// 
//       _variant_t variant;
//       hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
//       BREAK_ON_FAILED_HRESULT(hr);
// 
//       WasteExtractor dump(V_BSTR(&variant));
//       variant.Clear();
// }

      // set this so we don't ask for another password if the user keeps
      // the propsheet open and makes more changes

      fpnwEnabled = maintainLogin;

      SetChangesApplied();
      ClearChanges();
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_USER_PROPERTIES,
            GetObjectName().c_str()));

      if (hr != E_ADS_UNKNOWN_OBJECT)
      {
         // cause the sheet to remain open, and focus to go to this page.
         // NTRAID#NTBUG9-462516-2001/08/28-sburns
      
         Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
      }
   }

   return true;
}



HRESULT
UserFpnwPage::ReadLoginScript()
{
   LOG_FUNCTION(UserFpnwPage::ReadLoginScript);
   ASSERT(!scriptRead);
   ASSERT(!loginScriptFilename.empty());

   HRESULT hr = S_OK;
   HANDLE file = INVALID_HANDLE_VALUE;

   do
   {
      Win::CursorSetting cursor(IDC_WAIT);

      if (FS::PathExists(loginScriptFilename))
      {
         // REVIEWED-2002/03/04-sburns minimum read permissions used.
         
         hr =
            FS::CreateFile(
               loginScriptFilename,
               file,
               GENERIC_READ,
               FILE_SHARE_READ);
         BREAK_ON_FAILED_HRESULT(hr);

         AnsiString text;
         hr = FS::Read(file, -1, text);
         BREAK_ON_FAILED_HRESULT(hr);

         // this assign converts the ansi text to unicode

         loginScript = String(text);
         scriptRead = true;
      }
   }
   while (0);

   if (file != INVALID_HANDLE_VALUE)
   {
      Win::CloseHandle(file);
   }

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         IDS_FPNW_ERROR_READING_SCRIPT);
   }

   return hr;
}



HRESULT
UserFpnwPage::WriteLoginScript()
{
   LOG_FUNCTION(UserFpnwPage::WriteLoginScript);

   HRESULT hr = S_OK;
   HANDLE file = INVALID_HANDLE_VALUE;

   do
   {
      Win::CursorSetting cursor(IDC_WAIT);

      // uses the SD of the parent folder.
      
      hr =
         FS::CreateFile(
            loginScriptFilename,
            file,
            GENERIC_WRITE,
            0,

            // erase the existing file, if any

            CREATE_ALWAYS);
      BREAK_ON_FAILED_HRESULT(hr);

      // convert the unicode text to ansi

      AnsiString ansi;
      loginScript.convert(ansi);

      if (ansi.length())
      {
         hr = FS::Write(file, ansi);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   Win::CloseHandle(file);      

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         IDS_FPNW_ERROR_WRITING_SCRIPT);
   }

   return hr;
}



bool
UserFpnwPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserFpnwPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_GRACE_LIMIT:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);

               break;
            }
            case EN_KILLFOCUS:
            {
               // check the limits against the contents of the control,
               // change the contents to be within the limits.

               String allowed = Win::GetTrimmedWindowText(windowFrom);
               int a = 0;
               allowed.convert(a);
               if (a < 1 || a > MAX_GRACE_LOGINS)
               {
                  a = max(1, min(a, MAX_GRACE_LOGINS));
                  Win::SetWindowText(
                     windowFrom,
                     String::format(L"%1!d!", a));
               }

               // also change the upper limit on the remaining logins to
               // match the new allowed logins value.
               HWND spin = Win::GetDlgItem(hwnd, IDC_GRACE_REMAINING_SPIN);
               Win::Spin_SetRange(spin, 1, a);

               // (this removes the selection from the buddy edit box,
               // which I consider a bug in the up-down control)
               Win::Spin_SetPosition(spin, a);

               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }

         break;
      }
      case IDC_GRACE_REMAINING:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);

               break;
            }
            case EN_KILLFOCUS:
            {
               // check the contents of the control against the allowed field,
               // change the contents to be within the limits.

               String allowed = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_LIMIT);
               String remaining = Win::GetTrimmedWindowText(windowFrom);

               int a = 0;
               int r = 0;
               allowed.convert(a);
               remaining.convert(r);

               if (a == 0)
               {
                  // the conversion failed somehow, so use the max value

                  a = MAX_GRACE_LOGINS;
               }
               if (r < 0 || r > a)
               {
                  r = max(0, min(r, a));
                  Win::SetWindowText(
                     windowFrom,
                     String::format(L"%1!d!", r));
               }
               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }

         break;
      }
      case IDC_CONNECTION_LIMIT:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               // the max connections field has been altered.
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);

               break;
            }
            case EN_KILLFOCUS:
            {
               // check the limits against the contents of the control,
               // change the contents to be within the limits.

               String maxcon = Win::GetTrimmedWindowText(windowFrom);
               int a = 0;
               maxcon.convert(a);
               if (a < 1 || a > MAX_CONNECTIONS)
               {
                  Win::SetWindowText(
                     windowFrom,
                     String::format(
                        L"%1!d!",
                        max(1, min(a, MAX_CONNECTIONS))));
               }

               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }

         break;
      }
      case IDC_SCRIPT_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            NTService s(GetMachineName(), NW_SERVER_SERVICE);
            DWORD state = 0;
            HRESULT hr = s.GetCurrentState(state);

            if (SUCCEEDED(hr))
            {
               if (state == SERVICE_RUNNING)
               {
                  // edit the login script

                  if (!scriptRead)
                  {
                     ReadLoginScript();
                  }
                  FPNWLoginScriptDialog dlg(GetObjectName(), loginScript);
                  if (dlg.ModalExecute(hwnd) == IDOK)
                  {
                     // save the results
                     loginScript = dlg.GetLoginScript();
                     SetChanged(controlIDFrom);
                     Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
                  }

                  break;
               }

               // the service is not running, login scripts are not
               // editable

               popup.Error(
                  hwnd,
                  IDS_ERROR_FPNW_SERVICE_NOT_RUNNING);
               break;
            }

            // the service state could not be acertained.
            popup.Error(
               hwnd,
               hr,
               IDS_ERROR_FPNW_SERVICE_NOT_ACCESSIBLE);
         }
         break;
      }
      case IDC_UNLIMITED_CONNECTIONS:
      case IDC_LIMIT_CONNECTIONS:
      case IDC_UNLIMITED_GRACELOGINS:
      case IDC_LIMIT_GRACELOGINS:
      case IDC_NETWARE_ENABLE:
      case IDC_NWPWEXPIRED:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            Enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_NWHMDIR_RELPATH:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            Enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\setpasswordwarningdialog.cpp ===
// Copyright (C) 2001 Microsoft Corporation
// 
// SetPasswordWarningDialog class
// 
// 21 Feb 2001 sburns



#include "headers.hxx"
#include "SetPasswordWarningDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   IDCANCEL,         NO_HELP,
   IDOK,             NO_HELP,
   IDC_HELP_BUTTON,  NO_HELP,
   IDC_MESSAGE,      NO_HELP,   
   0, 0
};



// allow assignment in conditional in this rare case
      
#pragma warning(push)
#pragma warning(disable: 4706)

SetPasswordWarningDialog::SetPasswordWarningDialog(
   const String& userAdsiPath,
   const String& userDisplayName,
   bool          isLoggedOnUser_)
   :
   Dialog(
         (isFriendlyLogonMode = IsOS(OS_FRIENDLYLOGONUI) ? true : false)
      ?  (isLoggedOnUser_
         ?  IDD_SET_PASSWORD_WARNING_SELF_FRIENDLY
         :  IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY)
      :  (isLoggedOnUser_
         ?  IDD_SET_PASSWORD_WARNING_SELF_HOSTILE
         :  IDD_SET_PASSWORD_WARNING_OTHER_HOSTILE),   
      HELP_MAP),
   path(userAdsiPath),
   displayName(userDisplayName),
   isLoggedOnUser(isLoggedOnUser_)
{
   LOG_CTOR(SetPasswordWarningDialog);
   ASSERT(!path.empty());
   ASSERT(!displayName.empty());   
}

#pragma warning(pop)
      


SetPasswordWarningDialog::~SetPasswordWarningDialog()
{
   LOG_DTOR(SetPasswordWarningDialog);
}



void
SetPasswordWarningDialog::OnInit()
{
   LOG_FUNCTION(SetPasswordWarningDialog::OnInit());

   Win::SetWindowText(
      hwnd,
      String::format(IDS_SET_PASSWORD_TITLE, displayName.c_str()));
   
   // Load appropriate warning text based on whether the logged on user is
   // setting the password for his own account or another user.

   if (isLoggedOnUser)
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_MESSAGE,
         String::format(
            IDS_SET_PASSWORD_WARNING_MESSAGE_SELF1,
            displayName.c_str()));
   }
}



bool
SetPasswordWarningDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(SetPasswordWarningDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_HELP_BUTTON:
      {
         Win::HtmlHelp(
            hwnd,
               isFriendlyLogonMode
            ?  L"password.chm::/datalos.htm"
            :  L"password.chm::/datalosW.htm",
            HH_DISPLAY_TOPIC,
            0);
         break;
      }
      case IDOK:
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      default:
      {
         // do nothing.
         
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usergeneralpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserGeneralPage class
// 
// 9-9-97 sburns



#ifndef USERGENERALPAGE_HPP_INCLUDED
#define USERGENERALPAGE_HPP_INCLUDED



#include "adsipage.hpp"



class UserGeneralPage : public ADSIPage
{
   public:



   // Constructs a new instance.
   //
   // state - See base class
   //
   // path - See base class ctor.

   UserGeneralPage(
      MMCPropertyPage::NotificationState* state,
      const ADSI::Path&                   path);

   virtual ~UserGeneralPage();



   // Dialog overrides

   virtual 
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   private:

   HICON userIcon;

   // not implemented: no copying allowed

   UserGeneralPage(const UserGeneralPage&);
   const UserGeneralPage& operator=(const UserGeneralPage&);
};



#endif   // USERGENERALPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\userfpnwpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UserFpnwPage class
// 
// 9-11-98 sburns
//
// This should have been implemented as an extension snapin, like the RAS
// page, but the FPNW managers didn't get around to finding dev resources
// until way, way too late.



#ifndef USERFPNWPAGE_HPP_INCLUDED
#define USERFPNWPAGE_HPP_INCLUDED



#include "adsipage.hpp"
#include "waste.hpp"



class UserFpnwPage : public ADSIPage
{
   public:



   // Constructs a new instance.
   //
   // state - See base class
   //
   // path - See base class ctor.

   UserFpnwPage(
      MMCPropertyPage::NotificationState* state,
      const ADSI::Path&                   path);


      
   virtual
   ~UserFpnwPage();
   

   
   // Dialog overrides

   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual 
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   virtual
   bool
   OnKillActive();

   private:

   String
   MassagePath(const String& path);

   HRESULT
   ReadLoginScript();

   HRESULT
   WriteLoginScript();

   HRESULT
   SavePassword(
      const SmartInterface<IADsUser>&  user,
      WasteExtractor&                  dump,
      const EncryptedString&           newPassword);

   bool
   Validate();

   DWORD    maxPasswordAge;
   DWORD    minPasswordLen;
   DWORD    objectId;
   SafeDLL  clientDll;
   String   loginScriptFilename;
   bool     scriptRead;
   String   loginScript;
   bool     fpnwEnabled;

   // not defined: no copying allowed

   UserFpnwPage(const UserFpnwPage&);
   const UserFpnwPage& operator=(const UserFpnwPage&);
};



#endif   // USERFPNWPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usermemberpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserMemberPage class
// 
// 9-11-97 sburns



#include "headers.hxx"
#include "UserMemberPage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "MemberVisitor.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_GROUPS,    idh_memberof_list,
   IDC_ADD,       idh_memberof_add,
   IDC_REMOVE,    idh_memberof_remove,
   0, 0
};



UserMemberPage::UserMemberPage(
   MMCPropertyPage::NotificationState* state,
   const ADSI::Path&                   path)
   :
   ADSIPage(
      IDD_USER_MEMBER,
      HELP_MAP,
      state,
      path)
{
   LOG_CTOR2(UserMemberPage, path.GetPath());
}



UserMemberPage::~UserMemberPage()
{
   LOG_DTOR2(UserMemberPage, GetPath().GetPath());
}



void
UserMemberPage::OnInit()
{
   LOG_FUNCTION(UserMemberPage::OnInit);

   // Setup the controls

   listview =
      new MembershipListView(
         Win::GetDlgItem(hwnd, IDC_GROUPS),
         GetMachineName(),
         MembershipListView::USER_MEMBERSHIP);

   // load the group properties into the dialog.

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetPath().GetSidPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      // populate the list with group membership

      MemberVisitor
         visitor(original_groups, hwnd, GetObjectName(), GetMachineName());
      hr = ADSI::VisitGroups(user, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
      listview->SetContents(original_groups);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(IDS_ERROR_READING_USER, GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   enable();
}



void
UserMemberPage::enable()
{
   // LOG_FUNCTION(UserMemberPage::enable);

   bool selected =
      Win::ListView_GetSelectedCount(
         Win::GetDlgItem(hwnd, IDC_GROUPS)) > 0;

   HWND removeButton = Win::GetDlgItem(hwnd, IDC_REMOVE);
   
   if (!selected)
   {
      // If we're about to disable the remove button, check to see if it
      // has focus first.  If it does, we need to move focus to another
      // control.  Similarly for default pushbutton style.
      // NTRAID#NTBUG9-435045-2001/07/13-sburns

      if (removeButton == ::GetFocus())
      {
         HWND addButton = Win::GetDlgItem(hwnd, IDC_ADD);
         Win::SetFocus(addButton);
         Win::Button_SetStyle(addButton, BS_DEFPUSHBUTTON, true);
         Win::Button_SetStyle(removeButton, BS_PUSHBUTTON, true);
      }
   }

   Win::EnableWindow(removeButton, selected);
}


bool
UserMemberPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lparam)
{
   LOG_FUNCTION(UserMemberPage::OnNotify);

   switch (controlIDFrom)
   {
      case IDC_GROUPS:
      {
         switch (code)
         {
            case LVN_ITEMCHANGED:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lparam);
                  if (lv->uChanged & LVIF_STATE)
                  {
                     // a list item changed state

                     enable();
                  }
               }
               break;
            }
            case LVN_KEYDOWN:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLVKEYDOWN* kd = reinterpret_cast<NMLVKEYDOWN*>(lparam);
                  if (kd->wVKey == VK_INSERT)
                  {
                     listview->OnAddButton();
                  }
                  else if (kd->wVKey == VK_DELETE)
                  {
                     listview->OnRemoveButton();
                  }
               }
               break;
            }
            case LVN_INSERTITEM:
            case LVN_DELETEITEM:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
               break;
            }
            default:
            {
               break;
            }
         }
         break;
      }
      default:
      {
      }
   }

   return true;
}



void
UserMemberPage::OnDestroy()
{
   LOG_FUNCTION(UserMemberPage::OnDestroy);
   
   delete listview;
   listview = 0;
}



bool
UserMemberPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserMemberPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_ADD:
      {
         if (code == BN_CLICKED)
         {
            listview->OnAddButton();
         }
         break;
      }
      case IDC_REMOVE:
      {
         if (code == BN_CLICKED)
         {
            listview->OnRemoveButton();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}



bool
UserMemberPage::OnApply(bool isClosing)
{
   LOG_FUNCTION(UserMemberPage::OnApply);

   if (WasChanged(IDC_GROUPS))
   {
      // save the changes thru ADSI

      HRESULT hr = S_OK;
      do
      {
         SmartInterface<IADsUser> user(0);
         hr = ADSI::GetUser(GetPath().GetSidPath(), user);
         BREAK_ON_FAILED_HRESULT(hr);

         SmartInterface<IADs> iads(0);
         hr = iads.AcquireViaQueryInterface(user);
         BREAK_ON_FAILED_HRESULT(hr);

         // CODEWORK: when ADSI supports binding directly against a sid-style
         // path, then replace this with GetPath().GetSidPath() (used above)
         // NTRAID#NTBUG9-490601-2001/11/05-sburns
         
         String sidPath;
         hr = ADSI::GetSidPath(iads, sidPath);
         BREAK_ON_FAILED_HRESULT(hr);

         MemberList new_groups;
         listview->GetContents(new_groups);
         hr =
            ReconcileMembershipChanges(
               sidPath,
               original_groups,
               new_groups);
         BREAK_ON_FAILED_HRESULT(hr);

         if (!isClosing)
         {
            // refresh the listview

            original_groups.clear();
            MemberVisitor
               visitor(
                  original_groups,
                  hwnd,
                  GetObjectName(),
                  GetMachineName());
            hr = ADSI::VisitGroups(user, visitor);
            BREAK_ON_FAILED_HRESULT(hr);
            listview->SetContents(original_groups);
         }

         SetChangesApplied();
         ClearChanges();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            hwnd,
            hr,
            String::format(
               IDS_ERROR_SETTING_USER_PROPERTIES,            
               GetObjectName().c_str(),
               GetMachineName().c_str()));

        if (hr != E_ADS_UNKNOWN_OBJECT)
        {
           // cause the sheet to remain open, and focus to go to this page.
           // NTRAID#NTBUG9-462516-2001/08/28-sburns
           
           Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
     }
   }

   return true;
}



HRESULT
UserMemberPage::ReconcileMembershipChanges(
   const String&     userADSIPath,
   MemberList        originalGroups,   // a copy
   const MemberList& newGroups)
{
   LOG_FUNCTION2(UserMemberPage::ReconcileMembershipChanges, userADSIPath);
   ASSERT(!userADSIPath.empty());

   bool successful = true; // be optimistic!
   HRESULT hr = S_OK;
   for (
      MemberList::iterator i = newGroups.begin();
      i != newGroups.end();
      i++)
   {
      MemberInfo& info = *i;

      MemberList::iterator f =
         std::find(originalGroups.begin(), originalGroups.end(), info);
      if (f != originalGroups.end())
      {
         // found.  remove the matching node in the original list

         originalGroups.erase(f);
      }
      else
      {
         // not found.  Add the user as a member of the group

         SmartInterface<IADsGroup> group(0);
         hr = ADSI::GetGroup(info.path, group);
         if (SUCCEEDED(hr))
         {
            hr = group->Add(AutoBstr(userADSIPath));

            if (hr == Win32ToHresult(ERROR_MEMBER_IN_ALIAS))
            {
               // already a member: pop up a warning but don't consider this
               // a real error. 6791

               hr = S_OK;

               String name = GetObjectName();
               BSTR groupName;
               HRESULT anotherHr = group->get_Name(&groupName);
               if (SUCCEEDED(anotherHr))
               {
                  popup.Info(
                     hwnd,
                     String::format(
                        IDS_ALREADY_MEMBER,
                        name.c_str(),
                        groupName));
                  ::SysFreeString(groupName);
               }
            }
         }
            
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            successful = false;
         }
      }
   }

   // at this point, the original list contains only those nodes which are
   // not in the new list.  Remove these from the group membership

   for (
      i = originalGroups.begin();
      i != originalGroups.end();
      i++)
   {
      SmartInterface<IADsGroup> group(0);
      hr = ADSI::GetGroup(i->path, group);
      if (SUCCEEDED(hr))
      {
         hr = group->Remove(AutoBstr(userADSIPath));

         // CODEWORK: what if the member is not part of the group?
      }

      if (FAILED(hr))
      {
         LOG_HRESULT(hr);
         successful = false;
      }
   }

   if (!successful)
   {
      popup.Error(
         hwnd,
         0,
         String::format(
            IDS_ERROR_CHANGING_MEMBERSHIP,
            GetObjectName().c_str()));
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usergeneralpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserGeneralPage class
// 
// 9-9-97 sburns



#include "headers.hxx"
#include "UserGeneralPage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_FULL_NAME,                idh_general_fullname,
   IDC_DESCRIPTION,              idh_general_description,
   IDC_MUST_CHANGE_PASSWORD,     idh_general_must_change,
   IDC_CANNOT_CHANGE_PASSWORD,   idh_general_cannot_change,
   IDC_NEVER_EXPIRES,            idh_general_never_expires,
   IDC_DISABLED,                 idh_general_account_disabled,
   IDC_LOCKED,                   idh_general_account_lockedout,
   IDC_NAME,                     idh_general_username,
   IDC_USER_ICON,                NO_HELP,
   0, 0
};



UserGeneralPage::UserGeneralPage(
   MMCPropertyPage::NotificationState* state,
   const ADSI::Path&                   path)
   :
   ADSIPage(IDD_USER_GENERAL, HELP_MAP, state, path),
   userIcon(0)
{
   LOG_CTOR2(UserGeneralPage, path.GetPath());
}



UserGeneralPage::~UserGeneralPage()
{
   LOG_DTOR(UserGeneralPage);

   if (userIcon)
   {
      Win::DestroyIcon(userIcon);
   }
}



static
void
enable(HWND dialog)
{
   LOG_FUNCTION(enable);
   ASSERT(Win::IsWindow(dialog));

   DoUserButtonEnabling(
      dialog,
      IDC_MUST_CHANGE_PASSWORD,
      IDC_CANNOT_CHANGE_PASSWORD,
      IDC_NEVER_EXPIRES);
}



void
UserGeneralPage::OnInit()
{
   LOG_FUNCTION(UserGeneralPage::OnInit());

   // Setup the controls

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_FULL_NAME), MAXCOMMENTSZ);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);

   HRESULT hr = Win::LoadImage(IDI_GROUP, userIcon);

   // if the icon load fails, we're not going to tank the whole dialog, so
   // just assert here.

   ASSERT(SUCCEEDED(hr));

   Win::Static_SetIcon(Win::GetDlgItem(hwnd, IDC_USER_ICON), userIcon);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LOCKED), false);

   // load the user properties into the dialog.

   hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetPath().GetSidPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR name;
      hr = user->get_Name(&name);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_NAME, name);
      ::SysFreeString(name);

      BSTR full_name;
      hr = user->get_FullName(&full_name);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_FULL_NAME, full_name);
      ::SysFreeString(full_name);

      BSTR description;
      hr = user->get_Description(&description);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_DESCRIPTION, description);
      ::SysFreeString(description);

      VARIANT_BOOL disabled = VARIANT_FALSE;
      hr = user->get_AccountDisabled(&disabled);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::CheckDlgButton(
         hwnd,
         IDC_DISABLED,
         disabled ? BST_CHECKED : BST_UNCHECKED);

      VARIANT_BOOL locked = VARIANT_FALSE;
      hr = user->get_IsAccountLocked(&locked);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::CheckDlgButton(
         hwnd,
         IDC_LOCKED,
         locked ? BST_CHECKED : BST_UNCHECKED);
      if (locked)
      {
         Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LOCKED), true);
      }

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_PasswordExpired), &variant);
      BREAK_ON_FAILED_HRESULT(hr);
      long expired = variant;
      Win::CheckDlgButton(
         hwnd,
         IDC_MUST_CHANGE_PASSWORD,
         expired == 1 ? BST_CHECKED : BST_UNCHECKED);

      variant.Clear();
      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserFlags), &variant);
      BREAK_ON_FAILED_HRESULT(hr);
      long flags = variant;
      Win::CheckDlgButton(
         hwnd,
         IDC_CANNOT_CHANGE_PASSWORD,
         flags & UF_PASSWD_CANT_CHANGE ? BST_CHECKED : BST_UNCHECKED);
      Win::CheckDlgButton(
         hwnd,
         IDC_NEVER_EXPIRES,
         flags & UF_DONT_EXPIRE_PASSWD ? BST_CHECKED : BST_UNCHECKED);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(IDS_ERROR_READING_USER, GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   enable(hwnd);
}



bool
UserGeneralPage::OnApply(bool /* isClosing */)
{
   LOG_FUNCTION(UserGeneralPage::OnApply);

   if (WasChanged())
   {
      String full_name = Win::GetTrimmedDlgItemText(hwnd, IDC_FULL_NAME);
      String description = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);
      bool disabled = Win::IsDlgButtonChecked(hwnd, IDC_DISABLED);
      bool must_change = Win::IsDlgButtonChecked(hwnd, IDC_MUST_CHANGE_PASSWORD);
      bool cant_change = Win::IsDlgButtonChecked(hwnd, IDC_CANNOT_CHANGE_PASSWORD);
      bool never_expires = Win::IsDlgButtonChecked(hwnd, IDC_NEVER_EXPIRES);
      bool locked = Win::IsDlgButtonChecked(hwnd, IDC_LOCKED);

      // save the changes thru ADSI
      HRESULT hr = S_OK;
      do
      {
         SmartInterface<IADsUser> user(0);
         hr = ADSI::GetUser(GetPath().GetSidPath(), user);
         BREAK_ON_FAILED_HRESULT(hr);

         hr =
            SaveUserProperties(
               user,
               WasChanged(IDC_FULL_NAME) ? &full_name : 0,
               WasChanged(IDC_DESCRIPTION) ? &description : 0,
               WasChanged(IDC_DISABLED) ? &disabled : 0,
               WasChanged(IDC_MUST_CHANGE_PASSWORD) ? &must_change : 0,
               WasChanged(IDC_CANNOT_CHANGE_PASSWORD) ? &cant_change : 0,
               WasChanged(IDC_NEVER_EXPIRES) ? &never_expires : 0,
               WasChanged(IDC_LOCKED) ? &locked : 0);
         BREAK_ON_FAILED_HRESULT(hr);      

         SetChangesApplied();
         ClearChanges();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            hwnd,
            hr,
            String::format(
               IDS_ERROR_SETTING_USER_PROPERTIES,            
               GetObjectName().c_str()));

         if (hr != E_ADS_UNKNOWN_OBJECT)
         {
            // cause the sheet to remain open, and focus to go to this page.
            // NTRAID#NTBUG9-462516-2001/08/28-sburns
            
            Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
         }
      }
   }

   return true;
}
      


bool
UserGeneralPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserGeneralPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_MUST_CHANGE_PASSWORD:
      case IDC_CANNOT_CHANGE_PASSWORD:
      case IDC_NEVER_EXPIRES:
      case IDC_DISABLED:
      case IDC_LOCKED:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_FULL_NAME:
      case IDC_DESCRIPTION:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usernode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserNode class
// 
// 9-4-97 sburns



#ifndef USERNODE_HPP_INCLUDED
#define USERNODE_HPP_INCLUDED



#include "adsinode.hpp"



class UserNode : public AdsiNode
{
   friend class UsersFolderNode;

   public:



   // Creates a new instance.
   //
   // owner - See base class ctor.
   // 
   // displayName - See base class ctor.
   //
   // path - See base class ctor.
   //
   // fullName - text to appear as the node's Full Name in the result
   // pane details view.
   //
   // description - text to appear as the node's description in the result
   // pane details view.
   //
   // disabled - true if the account is disabled, false if not.

   UserNode(
      const SmartInterface<ComponentData>&   owner,
      const String&                          displayName,
      const ADSI::Path&                      path,
      const String&                          fullName,
      const String&                          description,
      bool                                   disabled);



   // Node overrides

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   String
   GetColumnText(int column);

   virtual 
   int
   GetNormalImageIndex();

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);

   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ResultNode overrides

   virtual
   HRESULT
   CreatePropertyPages(
      IPropertySheetCallback&             callback,
      MMCPropertyPage::NotificationState* state);

   virtual
   HRESULT
   Delete();

   virtual
   bool
   HasPropertyPages();

   virtual
   HRESULT
   Rename(const String& newName);

   private:

   // only we can delete ourselves via Release
   virtual ~UserNode();

   String   full_name;
   String   description;
   bool     disabled;

   // not defined: no copying allowed

   UserNode(const UserNode&);
   const UserNode& operator=(const UserNode&);
};



#endif   // USERNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usernode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserNode class
// 
// 9-4-97 sburns



#include "headers.hxx"
#include "usernode.hpp"
#include "uuids.hpp"
#include "resource.h"
#include "images.hpp"
#include "UserGeneralPage.hpp"
#include "UserFpnwPage.hpp"
#include "UserMemberPage.hpp"
#include "UserProfilePage.hpp"
#include "adsi.hpp"
#include "setpass.hpp"
#include "dlgcomm.hpp"
#include "fpnw.hpp"
#include "SetPasswordWarningDialog.hpp"
#include "WinStation.hpp"



UserNode::UserNode(
   const SmartInterface<ComponentData>&   owner,
   const String&                          displayName,
   const ADSI::Path&                      path,
   const String&                          fullName,
   const String&                          description_,
   bool                                   isDisabled)
   :
   AdsiNode(owner, NODETYPE_User, displayName, path),
   full_name(fullName),
   description(description_),
   disabled(isDisabled)
{
   LOG_CTOR2(UserNode, GetDisplayName());
}



UserNode::~UserNode()
{
   LOG_DTOR2(UserNode, GetDisplayName());
}
   

                 
String
UserNode::GetColumnText(int column)
{
//    LOG_FUNCTION(UserNode::GetColumnText);

   switch (column)
   {
      case 0:  // Name
      {
         return GetDisplayName();
      }
      case 1:  // Full Name
      {
         return full_name;
      }
      case 2:  // Description
      {
         return description;
      }
      default:
      {
         // This should never be called
         ASSERT(false);
      }
   }

   return String();
}



int
UserNode::GetNormalImageIndex()
{
   LOG_FUNCTION2(UserNode::GetNormalImageIndex, GetDisplayName());

   if (disabled)
   {
      return DISABLED_USER_INDEX;
   }

   return USER_INDEX;
}



bool
UserNode::HasPropertyPages()
{
   LOG_FUNCTION2(UserNode::HasPropertyPages, GetDisplayName());
      
   return true;
}



bool
ShouldShowFpnwPage(const String& serverName)
{
   LOG_FUNCTION(ShouldShowFpnwPage);
   ASSERT(!serverName.empty());

   bool result = false;

   do
   {
      // Check that FPNW Service is running

      NTService fpnw(NW_SERVER_SERVICE);

      DWORD state = 0;
      HRESULT hr = fpnw.GetCurrentState(state);
      BREAK_ON_FAILED_HRESULT(hr);

      if (state != SERVICE_RUNNING)
      {
         break;
      }

      String secret;
      hr = FPNW::GetLSASecret(serverName, secret);
      BREAK_ON_FAILED_HRESULT(hr);

      result = true;      
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}



HRESULT
UserNode::CreatePropertyPages(
   IPropertySheetCallback&             callback,
   MMCPropertyPage::NotificationState* state)
{
   LOG_FUNCTION2(UserNode::CreatePropertyPages, GetDisplayName());

   // these pages delete themselves when the prop sheet is destroyed

   const ADSI::Path& path = GetPath();

   HRESULT hr = S_OK;
   do
   {
      // designate the general page as that which frees the notify state
      // (only one page in the prop sheet should do this)
      
      UserGeneralPage* general_page = new UserGeneralPage(state, path);
      general_page->SetStateOwner();
      hr = DoAddPage(*general_page, callback);
      if (FAILED(hr))
      {
         delete general_page;
         general_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      UserMemberPage* member_page = new UserMemberPage(state, path);
      hr = DoAddPage(*member_page, callback);
      if (FAILED(hr))
      {
         delete member_page;
         member_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      UserProfilePage* profile_page = new UserProfilePage(state, path);
      hr = DoAddPage(*profile_page, callback);
      if (FAILED(hr))
      {
         delete profile_page;
         profile_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      if (ShouldShowFpnwPage(GetOwner()->GetInternalComputerName()))
      {
         UserFpnwPage* fpnw_page = new UserFpnwPage(state, path);
         hr = DoAddPage(*fpnw_page, callback);
         if (FAILED(hr))
         {
            delete fpnw_page;
            fpnw_page = 0;
         }
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // if the secret is not present, or can't be read, then FPNW is not
      // installed, and the page does not apply.  However, that doesn't mean
      // that the creation of the prop pages failed, so we clear the error
      // here.

      hr = S_OK;
   }
   while(0);

   return hr;
}



HRESULT
UserNode::AddMenuItems(
   IContextMenuCallback&   callback,
   long&                   insertionAllowed)
{
   LOG_FUNCTION(UserNode::AddMenuItems);

   static const ContextMenuItem items[] =
   {
      // {
      //    CCM_INSERTIONPOINTID_PRIMARY_TOP,
      //    IDS_USER_MENU_ADD_TO_GROUP,
      //    IDS_USER_MENU_ADD_TO_GROUP_STATUS         
      // },
      {
         CCM_INSERTIONPOINTID_PRIMARY_TOP,
         IDS_USER_MENU_CHANGE_PASSWORD,
         IDS_USER_MENU_CHANGE_PASSWORD_STATUS      // 347894
      },
      // {
      //    CCM_INSERTIONPOINTID_PRIMARY_TASK,
      //    IDS_USER_MENU_ADD_TO_GROUP,
      //    IDS_USER_MENU_ADD_TO_GROUP_STATUS
      // },
      {
         CCM_INSERTIONPOINTID_PRIMARY_TASK,
         IDS_USER_MENU_CHANGE_PASSWORD,
         IDS_USER_MENU_CHANGE_PASSWORD_STATUS
      }
   };

   return
      BuildContextMenu(
         items,
         items + sizeof(items) / sizeof(ContextMenuItem),
         callback,
         insertionAllowed);
}



bool
UserIsCurrentLoggedOnUser(const String& path)
{
   LOG_FUNCTION2(UserIsCurrentLoggedOnUser, path);

   bool result = false;
   HRESULT hr = S_OK;

   SID* acctSid = 0;
   HANDLE hToken = INVALID_HANDLE_VALUE;
   TOKEN_USER* userTokenInfo = 0;
         
   do
   {
      // get the account SID

      hr = ADSI::GetSid(path, acctSid);
      BREAK_ON_FAILED_HRESULT(hr);

      // get the current logged on user's sid

      hr =
         Win::OpenProcessToken(
            Win::GetCurrentProcess(),
            TOKEN_QUERY,
            hToken);
      BREAK_ON_FAILED_HRESULT(hr);

      // REVIEWED-2002/03/04-sburns Win:: wrapper handles buffer issues
      
      hr = Win::GetTokenInformation(hToken, userTokenInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      // REVIEWED-2002/03/04-sburns both SIDS are from trusted sources
      
      result = Win::EqualSid(acctSid, userTokenInfo->User.Sid);
   }
   while (0);

   if (acctSid)
   {
      ADSI::FreeSid(acctSid);
   }

   Win::CloseHandle(hToken);
   Win::FreeTokenInformation(userTokenInfo);
   
   LOG_HRESULT(hr);

   // if we've failed, then the result is false, and the caller will show
   // the password reset warning dialog, which is good. (i.e. failure of
   // this routine will not cause the user to unwittingly reset a password.)

   if (FAILED(hr))
   {
      ASSERT(!result);
   }

   return result;
}



HRESULT
UserNode::MenuCommand(
   IExtendContextMenu&  /* extendContextMenu */ ,
   long                 commandID)
{
   LOG_FUNCTION(UserNode::MenuCommand);

   switch (commandID)
   {
      case IDS_USER_MENU_CHANGE_PASSWORD:
      {
         // NTRAID#NTBUG9-314217-2001/02/21-sburns
         // NTRAID#NTBUG9-314230-2001/02/21-sburns

         // CODEWORK: when ADSI supports direct bind to sid-style paths,
         // then this path can be the sid path.
         // NTRAID#NTBUG9-490601-2001/11/06-sburns
         
         String path = GetPath().GetPath();
         String displayName = GetDisplayName();
         
         bool isLoggedOn = UserIsCurrentLoggedOnUser(path);
         
         if (
            SetPasswordWarningDialog(
               path,
               displayName,
               isLoggedOn).ModalExecute(
                  GetOwner()->GetMainWindow()) == IDOK)
         {
            SetPasswordDialog dlg(path, displayName, isLoggedOn);
               dlg.ModalExecute(GetOwner()->GetMainWindow());
         }
         break;
      }
      // case IDS_USER_MENU_ADD_TO_GROUP:
      // {
      //    break;
      // }
      case MMCC_STANDARD_VIEW_SELECT:
      {
         // we ignore this

         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



HRESULT
UserNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(UserNode::UpdateVerbs);

   consoleVerb.SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
   consoleVerb.SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
   consoleVerb.SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

// CODEWORK: we should enable the refresh verb for result nodes too.
// NTRAID#NTBUG9-153012-2000/08/31-sburns
//   consoleVerb.SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

   consoleVerb.SetDefaultVerb(MMC_VERB_PROPERTIES);

   return S_OK;
}



HRESULT
UserNode::Rename(const String& newName)
{
   LOG_FUNCTION(UserNode::Rename);

   String name(newName);

   // trim off whitespace.
   // NTRAID#NTBUG9-328306-2001/02/26-sburns
   
   name.strip(String::BOTH);
   
   // truncate the name
   
   if (name.length() > LM20_UNLEN)
   {
      name.resize(LM20_UNLEN);

      // trim off the whitespace again, as the truncation may "expose"
      // more whitespace at the end of the string
      // NTRAID#NTBUG9-462415-2001/08/28-sburns
      
      name.strip();
      
      popup.Info(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_USER_NAME_TOO_LONG,
            newName.c_str(),
            name.c_str()));
   }

   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_BAD_SAM_NAME,
            name.c_str()));
      return S_FALSE;
   }
      
   // Disallow user account names with the same name as the netbios computer
   // name. This causes some apps to get confused the the <03> and <20>
   // registrations.
   // NTRAID#NTBUG9-324794-2001/02/26-sburns

   String netbiosName = GetOwner()->GetInternalComputerName();
   if (name.icompare(netbiosName) == 0)
   {
      popup.Gripe(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_USERNAME_CANT_BE_COMPUTER_NAME,
            netbiosName.c_str()));
      return S_FALSE;
   }
      
   HRESULT hr = AdsiNode::rename(name);
   if (FAILED(hr))
   {
      String obj = GetPath().GetObjectName();      
      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(IDS_ERROR_RENAMING_USER, obj.c_str()));
      return S_FALSE;
   }

   return S_OK;
}



// Determine if the user is logged on to a machine.  Returns:
// S_OK - the user is not logged on to the server
// S_FALSE - the user is logged on to the server
// other - could not determine if the user is logged on.
// 
// serverName - in, NetBIOS name of the remote machine.
// 
// userName - in, name of the user account to test for.

HRESULT
CheckUserLoggedOn(const String& serverName, const String& userName)
{
   LOG_FUNCTION2(
      CheckUserLoggedOn,
      L"server=" + serverName + L" user=" + userName);
   ASSERT(!serverName.empty());
   ASSERT(!userName.empty());   

   HRESULT hr = S_OK;
   HANDLE serverHandle = INVALID_HANDLE_VALUE;

   do
   {
      hr = WinStation::OpenServer(serverName, serverHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGONID* sessionList = 0;
      DWORD    sessionCount = 0;

      // Iterate the sessions looking for active and disconnected sessions
      // only. Then match the user name and domain (case INsensitive) for a
      // result.

      hr = WinStation::Enumerate(serverHandle, sessionList, sessionCount);
      BREAK_ON_FAILED_HRESULT(hr);

      PLOGONID session = sessionList;
      DWORD    i = 0;

      for (; session && i < sessionCount; ++i, ++session)
      {
         if (
               (session->State != State_Active)
            && (session->State != State_Disconnected))
         {
            continue;
         }

         WINSTATIONINFORMATION info;
         hr =
            WinStation::QueryInformation(
               serverHandle,
               session->SessionId,
               info);
         BREAK_ON_FAILED_HRESULT(hr);

         if (serverName.icompare(info.Domain) == 0)
         {
            // The account logged on to the session is a local account for
            // that machine.

            if (userName.icompare(info.UserName) == 0)
            {
               // the account name is the same, so the user is logged on.

               hr = S_FALSE;
               break;
            }
         }
      }

      WinStation::FreeMemory(sessionList);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
IsUserLoggedOn(const String& serverName, const String& userName)
{
   HRESULT hr = CheckUserLoggedOn(serverName, userName);

   bool result = (hr == S_FALSE) ? true : false;

   LOG_BOOL(result);

   return result;
}



HRESULT
UserNode::Delete()
{
   LOG_FUNCTION(UserNode::Delete);

   HRESULT hr = E_FAIL;
   String name = GetPath().GetObjectName();
   
   do
   {
      if (
         popup.MessageBox(
            GetOwner()->GetMainWindow(),
            String::format(
               IDS_CONFIRM_USER_DELETE,
               name.c_str()),
            MB_ICONWARNING | MB_YESNO) != IDYES)
      {
         // user declined to roach the account.

         break;
      }

      // at this point, user wants to delete the account.  Make sure the
      // account is not logged on interactively (like with Fast User
      // Switching)
      // NTRAID#NTBUG9-370130-2001/04/25-sburns
      
      // IsOS(OS_FASTUSERSWITCHING) will tell us if the local machine is
      // running with FUS.  Unfortunately, that API is not remoteable.

      String serverName = GetOwner()->GetInternalComputerName();
      
      if (IsUserLoggedOn(serverName, name))
      {
         if (
            popup.MessageBox(
               GetOwner()->GetMainWindow(),
               String::format(
                  IDS_CONFIRM_LOGGED_ON_USER_DELETE,
                  name.c_str()),
               MB_ICONWARNING | MB_YESNO) != IDYES)
         {
            // user declined to roach logged on user.

            break;
         }
      }
               
      hr =
         ADSI::DeleteObject(
            ADSI::ComposeMachineContainerPath(serverName),         
            name,
            ADSI::CLASS_User);
      if (SUCCEEDED(hr))
      {
         break;
      }

      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(
            IDS_ERROR_DELETING_USER,            
            name.c_str()));
   }
   while (0);
   
   LOG_HRESULT(hr);

   // always return S_OK, since we've handled the delete verb    
   // NTRAID#NTBUG9-475985-2001/10/03-sburns
   
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usermemberpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserMemberPage class
// 
// 9-11-97 sburns



#ifndef USERMEMBERPAGE_HPP_INCLUDED
#define USERMEMBERPAGE_HPP_INCLUDED



#include "adsipage.hpp"
#include "MembershipListView.hpp"



class UserMemberPage : public ADSIPage
{
   public:



   // Creates a new instance
   // 
   // state - See base class.
   //
   // path - See base class ctor.

   UserMemberPage(
      MMCPropertyPage::NotificationState* state,
      const ADSI::Path&                   path);

   virtual ~UserMemberPage();



   // Dialog overrides

   virtual 
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual 
   void
   OnDestroy();

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   private:

   HRESULT
   ReconcileMembershipChanges(
      const String&     userADSIPath,
      MemberList        originalGroups,
      const MemberList& newGroups);

   void
   enable();

   MembershipListView*  listview;
   MemberList           original_groups;

   // not implemented: no copying allowed

   UserMemberPage(const UserMemberPage&);
   const UserMemberPage& operator=(const UserMemberPage&);
};



#endif   // USERMEMBERPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\userprofilepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserProfilePage class
// 
// 9-11-97 sburns



#include "headers.hxx"
#include "UserProfilePage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_PROFILE,   idh_profile_path,
   IDC_SCRIPT,    idh_profile_logon_script,
   IDC_LOCAL,     idh_profile_local_path_radio,
   IDC_CONNECT,   idh_profile_connect_to_radio,
   IDC_PATH,      idh_profile_local_path_text,
   IDC_DRIVE,     idh_profile_connect_to_list,
   IDC_SHARE,     idh_profile_to_text,
   0, 0
};


static const wchar_t FIRST_DRIVE_LETTER(L'C');
static const wchar_t LAST_DRIVE_LETTER(L'Z');


UserProfilePage::UserProfilePage(
   MMCPropertyPage::NotificationState* state,
   const ADSI::Path&                   path)
   :
   ADSIPage(
      IDD_USER_PROFILE,
      HELP_MAP,
      state,
      path)
{
   LOG_CTOR2(UserProfilePage::ctor, path.GetPath());
}



UserProfilePage::~UserProfilePage()
{
   LOG_DTOR2(UserProfilePage, GetPath().GetPath());
}



static
void
enable(HWND dialog)
{
   LOG_FUNCTION(enable);
   ASSERT(Win::IsWindow(dialog));

   bool enable_path = Win::IsDlgButtonChecked(dialog, IDC_LOCAL);

   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_PATH), enable_path);
   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_DRIVE), !enable_path);
   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_SHARE), !enable_path);

   // NTRAID#NTBUG9-425891-2001/06/28-sburns
   
   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_TO_STATIC), !enable_path);   
}


      
void
UserProfilePage::OnInit()
{
   LOG_FUNCTION(UserProfilePage::OnInit());

   // Setup the controls
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PROFILE), MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SCRIPT), MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PATH), MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SHARE), MAX_PATH);

   // populate the drive list
   HWND combo = Win::GetDlgItem(hwnd, IDC_DRIVE);
   for (wchar_t d = FIRST_DRIVE_LETTER; d <= LAST_DRIVE_LETTER; d++)
   {
      Win::ComboBox_AddString(combo, String(1, d) + L":");
   }
   Win::ComboBox_SetCurSel(combo, LAST_DRIVE_LETTER - FIRST_DRIVE_LETTER);

   // load the user properties into the dialog.
   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetPath().GetSidPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR profile;
      hr = user->get_Profile(&profile);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_PROFILE, profile);
      ::SysFreeString(profile);

      BSTR script;
      hr = user->get_LoginScript(&script);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_SCRIPT, script);
      ::SysFreeString(script);

      BSTR home;
      hr = user->get_HomeDirectory(&home);
      BREAK_ON_FAILED_HRESULT(hr);

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_LocalDrive), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      String local = V_BSTR(&variant);
      if (!local.empty())
      {
         Win::CheckDlgButton(hwnd, IDC_CONNECT, BST_CHECKED);
         Win::SetDlgItemText(hwnd, IDC_SHARE, home);
         int index = max(0, local[0] - FIRST_DRIVE_LETTER);
         Win::ComboBox_SetCurSel(combo, index);
      }
      else
      {
         Win::CheckDlgButton(hwnd, IDC_LOCAL, BST_CHECKED);         
         Win::SetDlgItemText(hwnd, IDC_PATH, home);
      }

      ::SysFreeString(home);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_READING_USER,
            GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   enable(hwnd);
}



bool
UserProfilePage::Validate(HWND dialog)
{
   LOG_FUNCTION(UserProfilePage::Validate);
   ASSERT(Win::IsWindow(dialog));

   // profile path is a free-for-all, as it may contain expansion expressions

   String script = Win::GetTrimmedDlgItemText(dialog, IDC_SCRIPT);
   if (!script.empty())
   {
      if (FS::GetPathSyntax(script) != FS::SYNTAX_RELATIVE_NO_DRIVE)
      {
         popup.Gripe(
            dialog,
            IDC_SCRIPT,
            String::format(IDS_BAD_SCRIPT_PATH, script.c_str()) );
         return false;
      }
   }

   if (Win::IsDlgButtonChecked(dialog, IDC_LOCAL))
   {
      // we massage the path one final time here, as the edit box may receive
      // kill focus after the page receives kill focus.  This happens when
      // entering the path then pressing enter.

      String dir =
         MassagePath(Win::GetTrimmedDlgItemText(dialog, IDC_PATH));
      if (!dir.empty())
      {
         if (FS::GetPathSyntax(dir) != FS::SYNTAX_ABSOLUTE_DRIVE)
         {
            popup.Gripe(
               dialog,
               IDC_PATH,
               String::format(IDS_BAD_HOME_DIR, dir.c_str()));
            return false;
         }
      }
   }
   else
   {
      // see massage note above...

      String share =
         MassagePath(Win::GetTrimmedDlgItemText(dialog, IDC_SHARE));
      if (share.empty())
      {
         popup.Gripe(dialog, IDC_SHARE, IDS_NEED_SHARE_NAME);
         return false;
      }
      else
      {
         if (FS::GetPathSyntax(share) != FS::SYNTAX_UNC)
         {
            popup.Gripe(
               dialog,
               IDC_SHARE,
               String::format(IDS_BAD_SHARE_NAME, share.c_str()));
            return false;
         }

         String s = FS::GetRootFolder(share);

         // remove the trailing backslash

         // REVIEW: s[s.length() - 1] is the same as *(s.rbegin())
         // which is cheaper?

         if (s[s.length() - 1] == L'\\')
         {
            s.resize(s.length() - 1);
         }

         Win::WaitCursor waitCur;

         DWORD attrs = 0;
         HRESULT hr = Win::GetFileAttributes(s, attrs);

         if (FAILED(hr))
         {
            popup.Gripe(
               dialog,
               IDC_SHARE,
               hr,
               String::format(IDS_CANT_ACCESS_SHARE, s.c_str()));
            return false;
         }
      }
   }

   return true;
}
      
   

bool
UserProfilePage::OnKillActive()
{
   LOG_FUNCTION(UserProfilePage::OnKillActive);

   if (!Validate(hwnd))
   {
      // refuse to relinquish focus

      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
   }

   return true;
}



// if %username% is at the end of the string, replace it with the current
// username.

String
UserProfilePage::MassagePath(const String& path)
{
   LOG_FUNCTION2(UserProfilePage::MassagePath, path);

   static const String USERNAME = String::load(IDS_USERNAME).to_upper();

   if (path.length() >= USERNAME.length())
   {
      String path_copy = path;
      path_copy.to_upper();
      size_t pos = path_copy.rfind(USERNAME);
      if (pos == path.length() - USERNAME.length())
      {
         return path.substr(0, pos) + GetObjectName();
      }
   }

   return path;
}



// Free result with Win::FreeSid

HRESULT
CreateBuiltinAdminsSid(SID*& result)
{
   HRESULT hr = S_OK;
   result = 0;

   PSID r = result;   
   do
   {
      SID_IDENTIFIER_AUTHORITY authority = {SECURITY_NT_AUTHORITY};
      hr =
         Win::AllocateAndInitializeSid(
            authority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            r);
      BREAK_ON_FAILED_HRESULT(hr);

      result = (SID*) r;
      
      ASSERT(::IsValidSid(result));
   }
   while (0);

   return hr;
}



// Set an ACL with ACEs for Administrators and the user

HRESULT
SetNewHomeFolderAcl(
   const String&                    path,
   const SmartInterface<IADsUser>&  user)
{
   LOG_FUNCTION2(SetNewHomeFolderAcl, path);
   ASSERT(!path.empty());
   ASSERT(user);

   HRESULT hr               = S_OK;
   SID*    userSid          = 0;   
   SID*    builtinAdminsSid = 0;   

   do
   {
      if (!FS::PathExists(path))
      {
         hr = S_FALSE;
         break;
      }

      // build SIDs for the user and build admins group

      SmartInterface<IADs> iads;
      hr = iads.AcquireViaQueryInterface(user);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ADSI::GetSid(iads, userSid);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = CreateBuiltinAdminsSid(builtinAdminsSid);
      BREAK_ON_FAILED_HRESULT(hr);
      
      // build two ACEs granting access to those SIDs
   
      static const unsigned ACE_COUNT = 2;
   
      EXPLICIT_ACCESS ea[ACE_COUNT];
      ::ZeroMemory(ea, sizeof ea);
   
      for (unsigned i = 0; i < ACE_COUNT; ++i)
      {
         ea[i].grfAccessPermissions = GENERIC_ALL;                       
         ea[i].grfAccessMode        = GRANT_ACCESS;                      
         ea[i].grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
      }
      
      ::BuildTrusteeWithSid(&(ea[0].Trustee), userSid);   
      ::BuildTrusteeWithSid(&(ea[1].Trustee), builtinAdminsSid);   
   
      // Build an ACL, and add the ACEs to it
   
      PACL acl = 0;
      hr = Win::SetEntriesInAcl(ACE_COUNT, ea, acl);
      BREAK_ON_FAILED_HRESULT(hr);
   
      // Build a security descriptor, add the ACL to it
   
      SECURITY_DESCRIPTOR sd;
      ::ZeroMemory(&sd, sizeof sd);
   
      hr = Win::InitializeSecurityDescriptor(sd);
      BREAK_ON_FAILED_HRESULT(hr);
   
      hr = Win::SetSecurityDescriptorDacl(sd, *acl);
      BREAK_ON_FAILED_HRESULT(hr);
         
      // Set the owner to be the user
   
      hr = Win::SetSecurityDescriptorOwner(sd, userSid);
      BREAK_ON_FAILED_HRESULT(hr);
   
      ASSERT(::IsValidSecurityDescriptor(&sd));

      // enable the SE_RESTORE_NAME priv, required to set owners in an sd.
      
      AutoTokenPrivileges autoPrivs(SE_RESTORE_NAME);
      
      hr = autoPrivs.Enable();
      if (hr == Win32ToHresult(ERROR_NOT_ALL_ASSIGNED))
      {
         // Since we're only asking for one priv, this is essentially the same
         // as access denied: the currently logged on user doesn't have rights
         // to assign ownership. We prefer to say access denied because that's
         // much less cryptic than the message that corresponds to
         // ERROR_NOT_ALL_ASSIGNED.

         LOG_HRESULT(hr);
         hr = Win32ToHresult(ERROR_ACCESS_DENIED);
      }
       
      BREAK_ON_FAILED_HRESULT(hr);

      // Set the ACL on the file

      // CODEWORK: if the priv enabling fails, then we could try to just set
      // the dacl.

      SECURITY_INFORMATION si =
         OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
      
      hr = Win::SetFileSecurity(path, si, sd);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   ADSI::FreeSid(userSid);
   Win::FreeSid(builtinAdminsSid);
   
   LOG_HRESULT(hr);

   return hr;   
}

   
   
HRESULT
UserProfilePage::CreateLocalProfilePath(
   const String&                    path,
   const SmartInterface<IADsUser>&  user)
{
   LOG_FUNCTION2(UserProfilePage::CreateLocalProfilePath, path);

   // allow the path to be empty -- we deal with this below.
   // ASSERT(!path.empty());
   // ASSERT(FS::GetPathSyntax(path) == FS::SYNTAX_ABSOLUTE_DRIVE);

   // NTRAID#NTBUG9-484380-2001/10/24-sburns
   // NTRAID#NTBUG9-488546-2001/10/31-sburns
   
   String dir = path;
      
   dir.strip(String::BOTH);
   if (dir.empty())
   {
      return E_INVALIDARG;
   }

   HRESULT hr = S_OK;
   String machineName = GetMachineName();

   if (!Win::IsLocalComputer(machineName))
   {
      // convert the local path to a UNC path to the corresponding admin
      // share

      dir =
         L"\\\\"
         + machineName
         + L"\\"
         + dir[0] + L"$"
         + dir.substr(2);
   }

   hr = FS::CreateFolder(dir);
      
   if (FAILED(hr))
   {
      // we don't consider this a "blocking" failure, as the
      // admin can go create the path after the fact.
   
      popup.Error(
         hwnd,
         hr,
         String::format(IDS_HOME_DIR_CREATE_FAILED, dir.c_str()));
   }
   else
   {
      hr = SetNewHomeFolderAcl(dir, user);

      if (FAILED(hr))
      {
         // we don't consider this a "blocking" failure, as the
         // admin can go clean up the ACL after the fact.
   
         popup.Error(
            hwnd,
            hr,
            String::format(IDS_SET_HOME_DIR_ACL_FAILED, dir.c_str()));
      }
   }
   
   return hr;
}



bool
UserProfilePage::OnApply(bool /* isClosing */)
{
   LOG_FUNCTION(UserProfilePage::OnApply);

   if (!WasChanged())
   {
      return true;
   }

   // don't need to call validate; kill active is sent before apply

   HRESULT hr = S_OK;

   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetPath().GetSidPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      if (WasChanged(IDC_PROFILE))
      {
         String profile =
            MassagePath(Win::GetTrimmedDlgItemText(hwnd, IDC_PROFILE));
         hr = user->put_Profile(AutoBstr(profile));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (WasChanged(IDC_SCRIPT))
      {
         String script = Win::GetTrimmedDlgItemText(hwnd, IDC_SCRIPT);                  
         hr = user->put_LoginScript(AutoBstr(script));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (Win::IsDlgButtonChecked(hwnd, IDC_LOCAL))
      {
         if (WasChanged(IDC_LOCAL) || WasChanged(IDC_PATH))
         {
            // The local path button was checked, and the user clicked it.

            String dir =
               MassagePath(Win::GetTrimmedDlgItemText(hwnd, IDC_PATH));
            hr = user->put_HomeDirectory(AutoBstr(dir));;
            BREAK_ON_FAILED_HRESULT(hr);

            // Move this from OnKillFocus so that the folder is not
            // created until commit time
            // NTRAID#NTBUG9-460901-2001/08/28-sburns
      
            CreateLocalProfilePath(dir, user);

            // write an empty string to the home drive

            String blank;
            _variant_t variant;
            variant = blank.c_str();
            hr = user->Put(AutoBstr(ADSI::PROPERTY_LocalDrive), variant);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }
      else
      {
         if (
               WasChanged(IDC_CONNECT)
            || WasChanged(IDC_SHARE)
            || WasChanged(IDC_DRIVE))
         {  
            // The connect to: button was checked, and the user clicked it.

            String share =
               MassagePath(Win::GetTrimmedDlgItemText(hwnd, IDC_SHARE));
            hr = user->put_HomeDirectory(AutoBstr(share));
            BREAK_ON_FAILED_HRESULT(hr);

            // Attempt to create the folder

            hr = FS::CreateFolder(share);
            if (FAILED(hr))
            {
               popup.Error(
                  hwnd,
                  hr,
                  String::format(IDS_CANT_CREATE_FOLDER, share.c_str()));
            }
            else
            {
               hr = SetNewHomeFolderAcl(share, user);
               if (FAILED(hr))
               {
                  popup.Error(
                     hwnd,
                     hr,
                     String::format(IDS_CANT_SET_FOLDER_ACL, share.c_str()));
               }
            }
               
            int index =
               Win::ComboBox_GetCurSel(Win::GetDlgItem(hwnd, IDC_DRIVE));
            String drive =
                  String(1, (wchar_t)min(FIRST_DRIVE_LETTER + index, LAST_DRIVE_LETTER))
               +  L":";

            _variant_t variant;
            variant = drive.c_str();
            hr = user->Put(AutoBstr(ADSI::PROPERTY_LocalDrive), variant);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      // commit the property changes

      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

      SetChangesApplied();
      ClearChanges();
   }
   while (0);
   
   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_USER_PROPERTIES,            
            GetObjectName().c_str()));

      if (hr != E_ADS_UNKNOWN_OBJECT)
      {
         // cause the sheet to remain open, and focus to go to this page.
         // NTRAID#NTBUG9-462516-2001/08/28-sburns
      
         Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
      }
   }
      
   return true;
}



bool
UserProfilePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserProfilePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_LOCAL:
      case IDC_CONNECT:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_PROFILE:
      case IDC_SCRIPT:
      case IDC_PATH:
      case IDC_SHARE:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               enable(hwnd);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
               break;
            }
            case EN_KILLFOCUS:
            {
               Win::SetDlgItemText(
                  hwnd,
                  controlIDFrom,
                  MassagePath(
                     Win::GetTrimmedDlgItemText(hwnd, controlIDFrom)));
               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }
         break;
      }
      case IDC_DRIVE:
      {
         if (code == CBN_SELCHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usersfoldernode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Users Folder Node class
// 
// 9-3-97 sburns



#ifndef USERSFOLDERNODE_HPP_INCLUDED
#define USERSFOLDERNODE_HPP_INCLUDED



#include "foldnode.hpp"



class UsersFolderNode : public FolderNode
{
   friend class RootNode;

   public:

   // Node overrides

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);

   // ScopeNode overrides

   virtual
   String
   GetDescriptionBarText();

   // FolderNode overrides

   void
   BuildResultItems(ResultNodeList& items);

   private:

   // Constructs a new instance.  Declared private as to be accessible only by
   // RootNode (which calls it when expanding)
   //
   // owner - See base class.

   UsersFolderNode(const SmartInterface<ComponentData>& owner);

   // only we can delete ourselves

   virtual ~UsersFolderNode();

   // not defined: no copying allowed

   UsersFolderNode(const UsersFolderNode&);
   const UsersFolderNode& operator=(const UsersFolderNode&);   
};

   


#endif   // USERSFOLDERNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\userprofilepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserProfilePage class
// 
// 9-11-97 sburns



#ifndef USERPROFILEPAGE_HPP_INCLUDED
#define USERPROFILEPAGE_HPP_INCLUDED



#include "adsipage.hpp"



class UserProfilePage : public ADSIPage
{
   public:



   // Constructs a new instance.
   //
   // state - See base class
   //
   // path - See base class ctor.

   UserProfilePage(
      MMCPropertyPage::NotificationState* state,
      const ADSI::Path&                   path);



   virtual
   ~UserProfilePage();


         
   // Dialog overrides

   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual 
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   virtual
   bool
   OnKillActive();

   private:

   HRESULT
   CreateLocalProfilePath(
      const String&                    path,
      const SmartInterface<IADsUser>&  user);

   String
   MassagePath(const String& path);

   bool
   Validate(HWND dialog);

   // not implemented: no copying allowed

   UserProfilePage(const UserProfilePage&);
   const UserProfilePage& operator=(const UserProfilePage&);
};



#endif   // USERPROFILEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\usersfoldernode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UsersFolder Node class
// 
// 9-2-97 sburns



#include "headers.hxx"
#include "UsersFolderNode.hpp"
#include "resource.h"
#include "uuids.hpp"
#include "usernode.hpp"
#include "compdata.hpp"
#include "adsi.hpp"
#include "newuser.hpp"
#include "dlgcomm.hpp"


static
FolderNode::ColumnList
buildColumnList()
{
   FolderNode::ColumnList list;

   static const ResultColumn col1 =
   {   
      IDS_USER_NAME_COLUMN_TITLE,
      IDS_USER_NAME_COLUMN_WIDTH
   };
   static const ResultColumn col2 =
   {
      IDS_USER_FULL_NAME_COLUMN_TITLE,
      IDS_USER_FULL_NAME_COLUMN_WIDTH
   };
   static const ResultColumn col3 =
   {
      IDS_USER_DESCRIPTION_COLUMN_TITLE,
      IDS_USER_DESCRIPTION_COLUMN_WIDTH
   };

   list.push_back(col1);
   list.push_back(col2);
   list.push_back(col3);

   return list;
};



static
FolderNode::MenuItemList
buildMenuItemList()
{
   FolderNode::MenuItemList list;

   static const ContextMenuItem item1 =
   {
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      IDS_UF_MENU_CREATE_USER,
      IDS_UF_MENU_NEW_USER_STATUS
   };
   // static const ContextMenuItem item2 =
   // {
   //    CCM_INSERTIONPOINTID_PRIMARY_NEW,
   //    IDS_UF_MENU_NEW_USER,
   //    IDS_UF_MENU_NEW_USER_STATUS         
   // };

   list.push_back(item1);
   // list.push_back(item2);

   return list;
}



UsersFolderNode::UsersFolderNode(const SmartInterface<ComponentData>& owner)
   :
   FolderNode(
      owner,
      NODETYPE_UsersFolder,
      IDS_USERS_FOLDER_DISPLAY_NAME,
      IDS_USERS_FOLDER_TYPE_TITLE,
      buildColumnList(),
      buildMenuItemList())
{
   LOG_CTOR(UsersFolderNode);
}



UsersFolderNode::~UsersFolderNode()
{
   LOG_DTOR(UsersFolderNode);
}



HRESULT
UsersFolderNode::MenuCommand(
   IExtendContextMenu&  /* extendContextMenu */ ,
   long                 commandID)
{
   LOG_FUNCTION(UsersFolderNode::MenuCommand);

   switch (commandID)
   {
      case IDS_UF_MENU_NEW_USER:
      case IDS_UF_MENU_CREATE_USER:
      {
         CreateUserDialog dlg(GetOwner()->GetInternalComputerName());
         if (dlg.ModalExecute(GetOwner()->GetMainWindow()))
         {
            RefreshView();
         }
         break;
      }
      case MMCC_STANDARD_VIEW_SELECT:
      {
         // we ignore this

         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



class UserVisitor : public ADSI::ObjectVisitor
{
   public:

   UserVisitor(
      FolderNode::ResultNodeList&            nodes_,
      const SmartInterface<ComponentData>&   owner_)
      :
      nodes(nodes_),
      owner(owner_)
   {
   }


   
   virtual
   ~UserVisitor()
   {
   }


   
   virtual
   void
   Visit(const SmartInterface<IADs>& object)
   {
      LOG_FUNCTION(UserVistor::visit);

      HRESULT hr = S_OK;
      do
      {

#ifdef DBG
         BSTR cls = 0;
         hr = object->get_Class(&cls);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_Class");

         ASSERT(cls == ADSI::CLASS_User);
         if (cls != ADSI::CLASS_User)
         {
            break;
         }
         ::SysFreeString(cls);

#endif          
            
         BSTR name = 0;            
         hr = object->get_Name(&name);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_Name");

         String sidPath;
         hr = ADSI::GetSidPath(object, sidPath);
         BREAK_ON_FAILED_HRESULT2(hr, L"GetSidPath");

         BSTR path = 0;
         hr = object->get_ADsPath(&path);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_ADsPath");
         LOG(TEXT("Visiting ") + String(path));

         SmartInterface<IADsUser> user(0);
         hr = user.AcquireViaQueryInterface(*((IADs*)object));
         BREAK_ON_FAILED_HRESULT2(hr, L"QI->IADsUser");

         BSTR desc = 0;
         hr = user->get_Description(&desc);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_Description");

         BSTR full = 0;
         hr = user->get_FullName(&full);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_FullName");

         VARIANT_BOOL disabled = VARIANT_FALSE;
         hr = user->get_AccountDisabled(&disabled);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_AccountDisabled");

         ADSI::Path p(path, sidPath);

         UserNode* node =
            new UserNode(
               owner,
               name,
               p,
               full,
               desc,
               disabled == VARIANT_TRUE ? true : false);
         ::SysFreeString(name);
         ::SysFreeString(path);
         ::SysFreeString(desc);
         ::SysFreeString(full);

         // transfer ownership of the node pointer to a SmartInterface in
         // the list....

         nodes.push_back(SmartInterface<ResultNode>(node));

         // ... and relinquish our hold on it.

         node->Release();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            owner->GetMainWindow(),
            hr,
            String::load(IDS_ERROR_VISITING_USER));
      }
   }

   private:

   FolderNode::ResultNodeList&   nodes;
   SmartInterface<ComponentData> owner;

   // not defined: no copying allowed

   UserVisitor(const UserVisitor&);
   const UserVisitor& operator=(const UserVisitor&);
};



void
UsersFolderNode::BuildResultItems(ResultNodeList& items)
{
   LOG_FUNCTION(UsersFolderNode::BuildResultItems);
   ASSERT(items.empty());

   UserVisitor visitor(items, GetOwner());
   ADSI::VisitChildren(
      ADSI::ComposeMachineContainerPath(GetOwner()->GetInternalComputerName()),
      ADSI::CLASS_User,
      visitor);
}



String
UsersFolderNode::GetDescriptionBarText()
{
   LOG_FUNCTION(UsersFolderNode::GetDescriptionBarText);

   return String::format(IDS_USERS_FOLDER_DESC, GetResultItemCount());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\waste.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// WasteExtractor class.  Now that sounds pleasant, doesn't it?
// 
// 10-8-98 sburns



#ifndef WASTE_HPP_INCLUDED
#define WASTE_HPP_INCLUDED



// Extracts stuff from the toxic waste dump (the SAM user account user
// parameters field) as a variety of data types.

// EPA license required to operate this class...

class WasteExtractor
{
   public:



   // copies the waste dump

   WasteExtractor(const String& wasteDump);



   // default dtor used

   HRESULT
   Clear(const String& propertyName);



   // Returns S_FALSE if the property is not present, S_OK if it was
   // present and was extracted, or an error code.

   template<class T>
   HRESULT
   Get(const String& propertyName, T& result)
   {
      BYTE* buf = 0;
      int len = 0;
      HRESULT hr = getProperty(waste_dump, propertyName, &buf, &len);

      if (hr == S_OK && buf)    // 447771 prefix warning
      {
         // property was found
         ASSERT(len == sizeof(T));

         result = *(reinterpret_cast<T*>(buf));
         delete[] buf;
      }

      return hr;
   }



   // specialization for Strings
   // Returns S_FALSE if the property is not present, S_OK if it was
   // present and was extracted, or an error code.

   HRESULT
   Get(const String& propertyName, String& result)
   {
      BYTE* buf = 0;
      int len = 0;
      HRESULT hr = getProperty(waste_dump, propertyName, &buf, &len);

      if (hr == S_OK && buf)
      {
         // property was found

         // convert to wide char.
         result = reinterpret_cast<PCSTR>(buf);
         delete[] buf;
      }

      return hr;
   }

   String
   GetWasteDump() const;

   // S_OK => value exists, S_FALSE => value does not exist

   HRESULT
   IsPropertyPresent(const String& propertyName);

   template<class T>
   HRESULT
   Put(const String& propertyName, const T& newValue)
   {
      return
         setProperty(
            waste_dump,
            propertyName,
            reinterpret_cast<BYTE*>(const_cast<T*>(&newValue)),
            sizeof(T));
   }

   // specialization for Strings

   HRESULT
   Put(const String& propertyName, const String& newValue)
   {
      // convert the wide string to ansi

      AnsiString s;
      if (newValue.convert(s) == String::CONVERT_FAILED)
      {
         return E_FAIL;
      }

      char* buf = const_cast<char*>(s.c_str());

      // determine the length, in bytes, of the buffer. add 1 for the null
      // terminator

      size_t bytes = strlen(buf) + 1;

      return
         setProperty(
            waste_dump,
            propertyName, 
            reinterpret_cast<BYTE*>(buf),
            static_cast<int>(bytes));
   }
            
   private:

   // Returns S_FALSE if the property is not present, S_OK if it was
   // present and was extracted, or an error code.

   static 
   HRESULT
   getProperty(
      const String&  wasteDump,
      const String&  propertyName,
      BYTE**         valueBuffer,
      int*           bufferLength);

   static
   HRESULT
   setProperty(
      String&        wasteDump,
      const String&  propertyName,
      BYTE*          valueBuffer,
      int            bufferLength);

   // not implemented: no copying allowed.
   WasteExtractor(const WasteExtractor&);
   const WasteExtractor& operator=(const WasteExtractor&);

   String waste_dump;
};
  


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\uuids.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UUIDS used in the Local Security Snapin
// 
// 8-18-97 sburns



#include "headers.hxx"
#include "uuids.hpp"
#include <localsec.h>



// DON'T EVER CHANGE THESE, OR YOU WILL BREAK ANY AND ALL EXTENSIONS
// TO THIS SNAPIN!

/* extern */ const CLSID CLSID_ComponentData =
{  /* 5d6179c8-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c8,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const CLSID CLSID_SnapinAbout =
{ /* 5d6179d2-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179d2,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_RootFolder =
{  /* 5d6179d3-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179d3,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_UsersFolder =
{  /* 5d6179c9-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c9,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_GroupsFolder =
{ /* 5d6179ca-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179ca,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_User = LUM_USER_NODETYPE_GUID;

/* extern */ const NodeType NODETYPE_Group =
{ /* 5d6179cd-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179cd,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};


const NodeType* nodetypes[] =
{
   &NODETYPE_RootFolder,
   &NODETYPE_UsersFolder,
   &NODETYPE_GroupsFolder,
   &NODETYPE_User,
   &NODETYPE_Group,
   0
};






// /* extern */ const NodeType NODETYPE_AdminRolesFolder =
// { /* 5d6179cb-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179cb,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };

// /* extern */ const NodeType NODETYPE_PasswordPolicy =
// { /* 5d6179ce-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179ce,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };

// /* extern */ const NodeType NODETYPE_AuditingPolicy =
// { /* 5d6179cf-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179cf,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_UserRightsPolicy =
// { /* 5d6179d0-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d0,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_DataRecoveryPolicy =
// { /* 5d6179d1-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d1,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_AdminRole =
// { /* 5d6179d4-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d4,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_PoliciesFolder =
// { /* 5d6179d5-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d5,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_TrustedCAList =
// { /* 5d6179d6-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d6,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };

// INTERFACENAME = { /* 5d6179d7-17ec-11d1-9aa9-00c04fd8fe93 */
//     0x5d6179d7,
//     0x17ec,
//     0x11d1,
//     {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
//   };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\uuids.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UUIDS used in the Local Security Snapin
// 
// 8-18-97 sburns



#ifndef UUIDS_HPP_INCLUDED
#define UUIDS_HPP_INCLUDED



#include "node.hpp"



extern const CLSID CLSID_ComponentData;
extern const CLSID CLSID_SnapinAbout;

extern const NodeType NODETYPE_RootFolder;
extern const NodeType NODETYPE_UsersFolder;
extern const NodeType NODETYPE_GroupsFolder;
extern const NodeType NODETYPE_User;
extern const NodeType NODETYPE_Group;
extern const NodeType* nodetypes[];



#endif   // UUIDS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\winstation.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// winsta.h wrapper functions
//
// 25 April 2001 sburns



#include "headers.hxx"
#include "WinStation.hpp"



HRESULT
WinStation::OpenServer(const String& serverName, HANDLE& result)
{
   LOG_FUNCTION2(WinStation::OpenServer, serverName);
   ASSERT(result == INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   if (serverName.empty())
   {
      result = SERVERNAME_CURRENT;
   }
   else
   {
      ::SetLastError(0);

      result =
         WinStationOpenServer(const_cast<PWSTR>(serverName.c_str()));

      if (result == 0 || result == INVALID_HANDLE_VALUE)
      {
         hr = Win::GetLastErrorAsHresult();
      }
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
WinStation::Enumerate(
   HANDLE    serverHandle,
   LOGONID*& sessionList, 
   DWORD&    sessionCount)
{
   LOG_FUNCTION(WinStation::Enumerate);
   ASSERT(serverHandle != INVALID_HANDLE_VALUE);

   sessionList = 0;
   sessionCount = 0;
   HRESULT hr = S_OK;

   BOOLEAN succeeded =
      WinStationEnumerate(serverHandle, &sessionList, &sessionCount);

   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
WinStation::QueryInformation(
   HANDLE                 serverHandle,
   ULONG                  logonId,     
   WINSTATIONINFORMATION& result)      
{
   LOG_FUNCTION(WinStation::QueryInformation);
   ASSERT(serverHandle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;
   
   // REVIEWED-2002/03/04-sburns correct byte count passed
   
   ::ZeroMemory(&result, sizeof result);

   DWORD unused = 0;
   
   BOOLEAN succeeded =
      WinStationQueryInformation(
         serverHandle,
         logonId,
         WinStationInformation,
         &result,
         sizeof result,
         &unused);
   
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   LOG_HRESULT(hr);
   
   return hr;
}



void
WinStation::FreeMemory(void* mem)
{
   LOG_FUNCTION(WinStation::FreeMemory);

   BOOLEAN succeeded = WinStationFreeMemory(mem);

   ASSERT(succeeded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\waste.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// WasteExtractor class.  Now that sounds pleasant, doesn't it?
//
// 10-8-98 sburns



#include "headers.hxx"
#include "waste.hpp"




WasteExtractor::WasteExtractor(const String& wasteDump)
   :
   waste_dump(wasteDump)
{
   LOG_CTOR(WasteExtractor);
}



HRESULT
WasteExtractor::Clear(const String& propertyName)
{
   if (waste_dump.empty())
   {
      ASSERT(false);
      return E_INVALIDARG;
   }

   return setProperty(waste_dump, propertyName, 0, 0);
}



String
WasteExtractor::GetWasteDump() const
{
   LOG_FUNCTION(WasteExtractor::GetWasteDump);

   return waste_dump;
}



// S_OK => value exists, S_FALSE => value does not exist

HRESULT
WasteExtractor::IsPropertyPresent(const String& propertyName)
{
   HRESULT hr = getProperty(waste_dump, propertyName, 0, 0);

   return hr;
}



// S_OK on success, otherwise an error occurred.
//
// wasteDump - string containing the toxic waste dump bytes.  This is changed
// when the property is written.
//
// propertyName - name of the property to extract.
//
// valueBuffer - address of data to be written into the property.  If 0, then
// the property's value is removed.
//
// bufferLength - length, in bytes, of the value buffer.  If valueBuffer is 0,
// then this parameter is ignored.

HRESULT
WasteExtractor::setProperty(
   String&        wasteDump,
   const String&  propertyName,
   BYTE*          valueBuffer,
   int            bufferLength)
{
   LOG_FUNCTION2(WasteExtractor::setProperty, propertyName);

#ifdef DBG
   ASSERT(!propertyName.empty());
   if (valueBuffer)
   {
      ASSERT(bufferLength > 0);
   }
#endif

   UNICODE_STRING value;
   value.Buffer = reinterpret_cast<USHORT*>(valueBuffer);
   value.Length = (USHORT)bufferLength;
   value.MaximumLength = (USHORT)bufferLength;
   PWSTR new_waste = 0;
   BOOL  waste_updated = FALSE;
   HRESULT hr = S_OK;

   NTSTATUS status =
      ::NetpParmsSetUserProperty(
         const_cast<wchar_t*>(wasteDump.c_str()),
         const_cast<wchar_t*>(propertyName.c_str()),
         value,
         USER_PROPERTY_TYPE_ITEM,
         &new_waste,
         &waste_updated);

   if (!NT_SUCCESS(status))
   {
      hr = Win32ToHresult(::NetpNtStatusToApiStatus(status));
   }
   else if (waste_updated && new_waste)
   {
      wasteDump = new_waste;
   }

   if (new_waste)
   {
      ::NetpParmsUserPropertyFree(new_waste);
   }

   LOG_HRESULT(hr);

   return hr;
}




// S_OK on success, S_FALSE if property not found, otherwise an error
// occurred.
//
// wasteDump - string containing the toxic waste dump bytes.
//
// propertyName - name of the property to extract.
//
// valueBuffer - address of pointer to receive the address of a
// newly-allocated buffer containing property value, or 0, if the value is
// not to be returned.  Invoker must free this buffer with delete[].
//
// bufferLength - address of int to receive the length, in bytes, of the
// value returned in valueBuffer, or 0, if the length is not to be
// returned.

HRESULT
WasteExtractor::getProperty(
   const String&  wasteDump,
   const String&  propertyName,
   BYTE**         valueBuffer,
   int*           bufferLength)
{
   LOG_FUNCTION2(WasteExtractor::getProperty, propertyName);
   ASSERT(!propertyName.empty());

   HRESULT hr = S_FALSE;
   if (valueBuffer)
   {
      *valueBuffer = 0;
   }
   if (bufferLength)
   {
      *bufferLength = 0;
   }

   WCHAR unused = 0;
   UNICODE_STRING value;

   value.Buffer = 0;
   value.Length = 0;
   value.MaximumLength = 0;

   NTSTATUS status =
      ::NetpParmsQueryUserProperty(
         const_cast<wchar_t*>(wasteDump.c_str()),
         const_cast<wchar_t*>(propertyName.c_str()),
         &unused,
         &value);

   if (!NT_SUCCESS(status))
   {
      hr = Win32ToHresult(::NetpNtStatusToApiStatus(status));
   }
   else if (value.Length)
   {
      hr = S_OK;
      if (valueBuffer)
      {
         *valueBuffer = new BYTE[value.Length];

         // REVIEWED-2002/03/04-sburns correct byte count passed. The
         // Length member of UNICODE_STRING is in bytes.
         
         ::CopyMemory(*valueBuffer, value.Buffer, value.Length);
      }
      if (bufferLength)
      {
         *bufferLength = value.Length;
      }
   }

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\aclpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       aclpage.h
//
//--------------------------------------------------------------------------


#ifndef _ACLPAGE_H
#define _ACLPAGE_H

// aclpage.h : header file
//

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CISecurityInformationWrapper;
class CPropertyPageHolderBase;

//////////////////////////////////////////////////////////////////////////
// CAclEditorPage

class CAclEditorPage
{
public:
	static CAclEditorPage* CreateInstance(LPCTSTR lpszLDAPPath,
									CPropertyPageHolderBase* pPageHolder);
	static CAclEditorPage* CreateInstanceEx(LPCTSTR lpszLDAPPath,
															LPCTSTR lpszServer,
															LPCTSTR lpszUsername,
															LPCTSTR lpszPassword,
															DWORD	dwFlags,
															CPropertyPageHolderBase* pPageHolder);
	~CAclEditorPage();
	HPROPSHEETPAGE CreatePage();

private:
	// methods
	CAclEditorPage();
	void SetHolder(CPropertyPageHolderBase* pPageHolder)
	{ 
		ASSERT((pPageHolder != NULL) && (m_pPageHolder == NULL)); 
		m_pPageHolder = pPageHolder;
	}

	HRESULT Initialize(LPCTSTR lpszLDAPPath);
	HRESULT InitializeEx(LPCTSTR lpszLDAPPath,
								LPCTSTR lpszServer,
								LPCTSTR lpszUsername,
								LPCTSTR lpszPassword,
								DWORD dwFlags);
	
	// data
	CISecurityInformationWrapper* m_pISecInfoWrap;
	CPropertyPageHolderBase*	 m_pPageHolder;		// back pointer

	friend class CISecurityInformationWrapper;
};





#endif //_ACLPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\winstation.hpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// winsta.h wrapper functions
//
// 25 April 2001 sburns



#ifndef WINSTATION_HPP_INCLUDED
#define WINSTATION_HPP_INCLUDED



// Wrappers of functions in the internal winsta.h header. These wrapped
// functions are remoteable over RPC to machines with terminal server
// installed. If it is not installed, they fail w/ RPC server unavailable.

namespace WinStation
{
   HRESULT
   OpenServer(const String& serverName, HANDLE& result);



   // If the machine is in safe mode, this will fail with
   // RPC_S_INVALID_BINDING.
   //
   // serverHandle - in, valid handle opened with WinStation::OpenServer
   //
   // sessionList - out, receives an array of logon session IDs. Caller must
   // deallocate this memory with WinStation::FreeMemory.
   //
   // sessionCount - out, receives the number of logon session IDs in the
   // sessionList result.

   HRESULT
   Enumerate(
      HANDLE    serverHandle,
      LOGONID*& sessionList, 
      DWORD&    sessionCount);



   HRESULT
   QueryInformation(
      HANDLE                 serverHandle,
      ULONG                  logonId,     
      WINSTATIONINFORMATION& result);



   void
   FreeMemory(void* mem);
     
}



#endif   // WINSTATION_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

///////////////////////////////////////////////////////////////////////////////
// MACROS

// We are assuming the string passed in is NULL terminated.
#define BYTE_MEM_LEN_W(s) ((wcslen(s)+1) * sizeof(wchar_t))

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CTreeNode;
class CRootData;
class CComponentDataObject;
class CNodeList;


///////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES

// New Clipboard format that has the Type and Cookie
extern const wchar_t* CCF_DNS_SNAPIN_INTERNAL;

struct INTERNAL 
{
  INTERNAL() 
  { 
    m_type = CCT_UNINITIALIZED; 
    m_p_cookies = NULL; 
    m_pString = NULL;
    m_cookie_count = 0;
  };

  ~INTERNAL() 
  { 
    free(m_p_cookies);
    delete m_pString;
  }

  DATA_OBJECT_TYPES   m_type;     // What context is the data object.
  CTreeNode**         m_p_cookies;   // What object the cookie represents
  LPTSTR              m_pString;  // internal pointer
  DWORD               m_cookie_count;

  INTERNAL & operator=(const INTERNAL& rhs) 
  { 
    m_type = rhs.m_type; 
    m_p_cookies = rhs.m_p_cookies; 
    m_cookie_count = rhs.m_cookie_count;
    return *this;
  } 
};

//////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

class CInternalFormatCracker
{
public:
  CInternalFormatCracker() : m_pInternal(NULL) {}
  CInternalFormatCracker(INTERNAL* pInternal) : m_pInternal(pInternal) {}
  ~CInternalFormatCracker() 
  {
    _Free();
  }

  DWORD GetCookieCount() 
  { 
    if (m_pInternal == NULL)
    {
      return 0;
    }
    return m_pInternal->m_cookie_count; 
  }

  DATA_OBJECT_TYPES GetCookieType() 
  { 
    ASSERT(m_pInternal != NULL);
    return m_pInternal->m_type; 
  }

  CTreeNode* GetCookieAt(DWORD idx)
  {
    if(m_pInternal == NULL)
    {
      return NULL;
    }

    if (idx < m_pInternal->m_cookie_count)
    {
      return m_pInternal->m_p_cookies[idx];
    }
    return NULL;
  }

  HRESULT Extract(LPDATAOBJECT lpDataObject);

  void GetCookieList(CNodeList& list);

private:
  INTERNAL* m_pInternal;

  void _Free()
  {
    if (m_pInternal != NULL)
    {
      ::GlobalFree(m_pInternal);
      m_pInternal = NULL;
    }
  }
};


///////////////////////////////////////////////////////////////////////////////
// CDataObject

class CDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
	CDataObject() 
	{ 
#ifdef _DEBUG_REFCOUNT
		dbg_cRef = 0;
		++m_nOustandingObjects;
		TRACE(_T("CDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT
		m_pUnkComponentData = NULL; 
	}

  ~CDataObject() 
	{
#ifdef _DEBUG_REFCOUNT
		--m_nOustandingObjects;
		TRACE(_T("~CDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT
		if (m_pUnkComponentData != NULL)
		{
			m_pUnkComponentData->Release();
			m_pUnkComponentData = NULL;
#ifdef _DEBUG_REFCOUNT
			TRACE(_T("~CDataObject() released m_pUnkComponentData\n"));
#endif // _DEBUG_REFCOUNT
		}
	}
#ifdef _DEBUG_REFCOUNT
	static unsigned int m_nOustandingObjects; // # of objects created
	int dbg_cRef;

  ULONG InternalAddRef()
  {
		++dbg_cRef;
    return CComObjectRoot::InternalAddRef();
  }
  ULONG InternalRelease()
  {
  	--dbg_cRef;
    return CComObjectRoot::InternalRelease();
  }
#endif // _DEBUG_REFCOUNT

// Clipboard formats that are required by the console
public:
  static CLIPFORMAT    m_cfNodeType;		    // Required by the console
  static CLIPFORMAT    m_cfNodeTypeString;  // Required by the console
  static CLIPFORMAT    m_cfDisplayName;		  // Required by the console
  static CLIPFORMAT    m_cfCoClass;         // Required by the console
	static CLIPFORMAT		 m_cfColumnID;			  // Option for column identification

  static CLIPFORMAT    m_cfInternal; 
  static CLIPFORMAT    m_cfMultiSel;
  static CLIPFORMAT    m_cfMultiObjTypes;

// Standard IDataObject methods
public:
// Implemented
  STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
  STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
  STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

// Not Implemented
private:
  STDMETHOD(QueryGetData)(LPFORMATETC) 
  { return E_NOTIMPL; };

  STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC)
  { return E_NOTIMPL; };

  STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL)
  { return E_NOTIMPL; };

  STDMETHOD(DAdvise)(LPFORMATETC, DWORD,
              LPADVISESINK, LPDWORD)
  { return E_NOTIMPL; };
  
  STDMETHOD(DUnadvise)(DWORD)
  { return E_NOTIMPL; };

  STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*)
  { return E_NOTIMPL; };

// Implementation
public:
  void SetType(DATA_OBJECT_TYPES type) // Step 3
  { 
		ASSERT(m_internal.m_type == CCT_UNINITIALIZED); 
		m_internal.m_type = type; 
	}
	DATA_OBJECT_TYPES GetType()
	{
		ASSERT(m_internal.m_type != CCT_UNINITIALIZED); 
		return m_internal.m_type;
	}


  void AddCookie(CTreeNode* cookie);
  void SetString(LPTSTR lpString) { m_internal.m_pString = lpString; }

	HRESULT Create(const void* pBuffer, size_t len, LPSTGMEDIUM lpMedium);
private:
	HRESULT CreateColumnID(LPSTGMEDIUM lpMedium);			      // Optional for column identification
  HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);		    // Required by the console
  HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);	// Required by the console
  HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);		    // Required by the console
	HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);			    // Required by the console
  HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);  
  HRESULT CreateInternal(LPSTGMEDIUM lpMedium);

  INTERNAL m_internal;

	// pointer to the ComponentDataObject
private:
	IUnknown* m_pUnkComponentData;
	
	HRESULT SetComponentData(IUnknown* pUnkComponentData)
	{ 
		if (m_pUnkComponentData != NULL)
    {
			m_pUnkComponentData->Release();
    }
		m_pUnkComponentData = pUnkComponentData;
		if (m_pUnkComponentData != NULL)
    {
			m_pUnkComponentData->AddRef();
    }
		return S_OK;
	}

	HRESULT GetComponentData(IUnknown** ppUnkComponentData)
	{ 
		ASSERT(FALSE); // never called??? find out!
		if (ppUnkComponentData == NULL)
    {
			return E_POINTER;
    }
		*ppUnkComponentData = m_pUnkComponentData; 
		if (m_pUnkComponentData != NULL)
    {
			m_pUnkComponentData->AddRef();
    }
		return S_OK; 
	}
	CRootData* GetDataFromComponentDataObject();
	CTreeNode* GetTreeNodeFromCookie();

	friend class CComponentDataObject;
};

///////////////////////////////////////////////////////////////////////////////
// CDummyDataObject

class CDummyDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummyDataObject)
BEGIN_COM_MAP(CDummyDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Standard IDataObject methods
public:
    STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM)
	{ return E_NOTIMPL; };
    STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM)
	{ return E_NOTIMPL; };
    STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*)
	{ return E_NOTIMPL; };
    STDMETHOD(QueryGetData)(LPFORMATETC) 
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*)
    { return E_NOTIMPL; };
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\compbase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       compbase.h
//
//--------------------------------------------------------------------------

#ifndef _COMPBASE_H
#define _COMPBASE_H

// We do not want to force snapins using the framework to go and replace all
// of their unsafe functions.
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
// Base classes implementing the IComponent and IComponentData interfaces
///////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// IConsole::UpdateAllViews() : values for the Hint argument

#define ADD_RESULT_ITEM             ( 0x00000001 )
#define DELETE_RESULT_ITEM          ( 0x00000002 )
#define CHANGE_RESULT_ITEM_DATA     ( 0x00000004 )
#define CHANGE_RESULT_ITEM_ICON     ( 0x00000008 )
#define CHANGE_RESULT_ITEM          ( CHANGE_RESULT_ITEM_DATA | CHANGE_RESULT_ITEM_ICON )
#define REPAINT_RESULT_PANE         ( 0x00000010 )
#define DELETE_ALL_RESULT_ITEMS     ( 0x00000011 )
#define UPDATE_VERB_STATE           ( 0x00000012 )
#define SORT_RESULT_PANE            ( 0x00000013 )
#define UPDATE_DESCRIPTION_BAR ( 0x00000100 )
#define UPDATE_RESULT_PANE_VIEW ( 0x00000200 )
#define DELETE_MULTIPLE_RESULT_ITEMS ( 0x00000400)

///////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES

extern DWORD _MainThreadId;
extern CString LOGFILE_NAME;

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CComponentDataObject;     
class CComponentObject;         
class CRootData;                
class CTreeNode;                
class CContainerNode;           
class CMTContainerNode;         
class CLeafNode;                
class CPropertyPageHolderTable;

///////////////////////////////////////////////////////////////////////////////
// global functions


struct _NODE_TYPE_INFO_ENTRY
{
    const GUID* m_pNodeGUID;
    LPCTSTR     m_lpszNodeDescription;
};


HRESULT RegisterSnapin(const GUID* pSnapinCLSID,
                       const GUID* pStaticNodeGUID,
                       const GUID* pAboutGUID,
                       LPCTSTR lpszNameString, LPCTSTR lpszVersion, LPCTSTR lpszProvider,
             BOOL bExtension, _NODE_TYPE_INFO_ENTRY* pNodeTypeInfoEntryArray,
             UINT nSnapinNameID = 0);

HRESULT UnregisterSnapin(const GUID* pSnapinCLSID);

HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription);
HRESULT UnregisterNodeType(const GUID* pGuid);

HRESULT RegisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
                              const GUID* pExtensionSnapinCLSID, LPCTSTR lpszDescription, BOOL bDynamic);
HRESULT UnregisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
                              const GUID* pExtensionSnapinCLSID, BOOL bDynamic);

/////////////////////////////////////////////////////////////////////////////
// CTimerThread

class CTimerThread : public CWinThread
{
public:
    CTimerThread() { m_bAutoDelete = FALSE; m_hWnd = 0;}

    BOOL Start(HWND hWnd);
    virtual BOOL InitInstance() { return TRUE; }    // MFC override
    virtual int Run() { return -1;}                 // MFC override

protected:
    BOOL PostMessageToWnd(WPARAM wParam, LPARAM lParam);
private:
    HWND                    m_hWnd;

};


/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

class CWorkerThread : public CWinThread
{
public:
    CWorkerThread();
    virtual ~CWorkerThread();

    BOOL Start(HWND hWnd);
    virtual BOOL InitInstance() { return TRUE; }    // MFC override
    virtual int Run() { return -1;}                 // MFC override

   // REVIEWED-2002/03/08-JeffJon-There appears to be no danger
   // of getting stuck in the critical section

    void Lock() { ::EnterCriticalSection(&m_cs); }
    void Unlock() { ::LeaveCriticalSection(&m_cs); }

    void Abandon();
    BOOL IsAbandoned();

    void AcknowledgeExiting() { VERIFY(0 != ::SetEvent(m_hEventHandle));}

protected:
    virtual void OnAbandon() {}

protected:
    BOOL PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam);
    void WaitForExitAcknowledge();

private:
    CRITICAL_SECTION        m_cs;   
    HANDLE                  m_hEventHandle;

    HWND                    m_hWnd;
    BOOL                    m_bAbandoned;
};



////////////////////////////////////////////////////////////////////
// CHiddenWnd : Hidden window to syncronize threads and CComponentData object

class CHiddenWnd : public CHiddenWndBase
{
public:
    CHiddenWnd(CComponentDataObject* pComponentDataObject);

    static const UINT s_NodeThreadHaveDataNotificationMessage;
    static const UINT s_NodeThreadErrorNotificationMessage;
    static const UINT s_NodeThreadExitingNotificationMessage;

    static const UINT s_NodePropertySheetCreateMessage;
    static const UINT s_NodePropertySheetDeleteMessage; 

    static const UINT s_ExecCommandMessage;     
    static const UINT s_ForceEnumerationMessage;            
    static const UINT s_TimerThreadMessage;         

    UINT_PTR m_nTimerID;
private:
    CComponentDataObject* m_pComponentDataObject; // back pointer
public:

    BEGIN_MSG_MAP(CHiddenWnd)
      MESSAGE_HANDLER( CHiddenWnd::s_NodeThreadHaveDataNotificationMessage, OnNodeThreadHaveDataNotification )
      MESSAGE_HANDLER( CHiddenWnd::s_NodeThreadErrorNotificationMessage, OnNodeThreadErrorNotification )
      MESSAGE_HANDLER( CHiddenWnd::s_NodeThreadExitingNotificationMessage, OnNodeThreadExitingNotification )

      MESSAGE_HANDLER( CHiddenWnd::s_NodePropertySheetCreateMessage, OnNodePropertySheetCreate )
      MESSAGE_HANDLER( CHiddenWnd::s_NodePropertySheetDeleteMessage, OnNodePropertySheetDelete )
      
      MESSAGE_HANDLER( CHiddenWnd::s_ExecCommandMessage, OnExecCommand )
      MESSAGE_HANDLER( CHiddenWnd::s_ForceEnumerationMessage, OnForceEnumeration )
      MESSAGE_HANDLER( CHiddenWnd::s_TimerThreadMessage, OnTimerThread )

    MESSAGE_HANDLER( WM_TIMER, OnTimer )
        
    CHAIN_MSG_MAP(CHiddenWndBase)
  END_MSG_MAP()

    LRESULT OnNodeThreadHaveDataNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNodeThreadErrorNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNodeThreadExitingNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNodePropertySheetCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNodePropertySheetDelete(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnExecCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnForceEnumeration(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimerThread(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

////////////////////////////////////////////////////////////////////////////////////
// CRunningThreadTable
// all CMTContainerNode with running refresh/enumerate background threads will
// register/unregister in this table to allow proper thread abandoning at shutdown

class CRunningThreadTable
{
public:
    CRunningThreadTable(CComponentDataObject* pComponentData);
    ~CRunningThreadTable();

    void Add(CMTContainerNode* pNode);
    void Remove(CMTContainerNode* pNode);
    void RemoveAll();
  BOOL IsPresent(CMTContainerNode* pNode);

private:
    CComponentDataObject* m_pComponentData; // back pointer

    CMTContainerNode** m_pEntries;
    int m_nSize;
};
    


////////////////////////////////////////////////////////////////////////////////////
// CExecContext

class CExecContext
{
public:
    CExecContext();
    ~CExecContext();
    virtual void Execute(LPARAM arg) = 0; // code to be executed from main thread
    virtual void Wait();    // secondary thread waits on this call
    virtual void Done();    // called when main thread done executing
protected:
    HANDLE  m_hEventHandle;
};


////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkBase

class CNotificationSinkBase
{
public:
    virtual void OnNotify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2) = 0;
};

////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkEvent

class CNotificationSinkEvent : public CNotificationSinkBase
{
public:
    CNotificationSinkEvent();
    ~CNotificationSinkEvent();

public:
    void OnNotify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2);
    virtual void Wait();
private:
    HANDLE  m_hEventHandle;
};


////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkTable

class CNotificationSinkTable
{
public:
    CNotificationSinkTable();
    ~CNotificationSinkTable();
    
    void Advise(CNotificationSinkBase* p);
    void Unadvise(CNotificationSinkBase* p);
    void Notify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2);

private:
    void Lock()
    {
        TRACE(_T("CNotificationSinkTable::Lock()\n"));

      // REVIEWED-2002/03/08-JeffJon-There appears to be no danger
      // of getting stuck in the critical section

        ::EnterCriticalSection(&m_cs);
    }
    void Unlock()
    {
        TRACE(_T("CNotificationSinkTable::Unlock()\n"));
        ::LeaveCriticalSection(&m_cs);
    }

    CRITICAL_SECTION m_cs;
    CNotificationSinkBase** m_pEntries;
    int m_nSize;
};



////////////////////////////////////////////////////////////////////////////////////
// CPersistStreamImpl

class CPersistStreamImpl : public IPersistStream
{
public:
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID* pClassID) = 0;
  HRESULT STDMETHODCALLTYPE IsDirty() = 0;
  HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStm) = 0;
  HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStm, BOOL fClearDirty) = 0;
  HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER *pcbSize)
    {
        ASSERT(FALSE);

    //
        // arbitrary value, do we ever get called?
    //
        pcbSize->LowPart = 0xffff;
    pcbSize->HighPart= 0x0;
        return S_OK;
    }
};

///////////////////////////////////////////////////////////////////////////////
// CWatermarkInfo

class CWatermarkInfo
{
public:
    CWatermarkInfo()
    {
        m_nIDBanner = 0;
        m_nIDWatermark = 0;
        m_hPalette = NULL;
        m_bStretch = TRUE;
    }
    UINT        m_nIDBanner;
    UINT        m_nIDWatermark;
    HPALETTE    m_hPalette;
    BOOL        m_bStretch;
};



////////////////////////////////////////////////////////////////////////////////
// CColumn

class CColumn
{
public:
  CColumn(LPCWSTR lpszColumnHeader,
          int nFormat,
          int nWidth,
          UINT nColumnNum) 
  {
    m_lpszColumnHeader = NULL;
    SetHeader(lpszColumnHeader);
    m_nFormat = nFormat;
    m_nWidth = nWidth;
    m_nColumnNum = nColumnNum;
  }

  ~CColumn() 
  {
    free(m_lpszColumnHeader);
  }

  LPCWSTR GetHeader() { return (LPCWSTR)m_lpszColumnHeader; }

  void SetHeader(LPCWSTR lpszColumnHeader) 
  { 
    if (m_lpszColumnHeader != NULL)
    {
      free(m_lpszColumnHeader);
    }

    // We are assuming the column header is NULL terminated.  Since this is usually
    // pulled from the resource and there is no good way to verify that it is NULL 
    // terminated this usage should be fine.

    size_t iLen = wcslen(lpszColumnHeader);

    m_lpszColumnHeader = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    if (m_lpszColumnHeader != NULL)
    {
      HRESULT hr = StringCchCopyW(m_lpszColumnHeader, iLen + 1, lpszColumnHeader);
      ASSERT(SUCCEEDED(hr));
    }
  }

  int  GetFormat() { return m_nFormat; }
  void SetFormat(int nFormat) { m_nFormat = nFormat; }
  int  GetWidth() { return m_nWidth; }
  void SetWidth(int nWidth) { m_nWidth = nWidth; }
  UINT GetColumnNum() { return m_nColumnNum; }
  void SetColumnNum(UINT nColumnNum) { m_nColumnNum = nColumnNum; }

protected:
  LPWSTR m_lpszColumnHeader;
  int   m_nFormat;
  int   m_nWidth;
  UINT  m_nColumnNum;
};


////////////////////////////////////////////////////////////////////////////////
// CColumnSet

class CColumnSet : public CList<CColumn*, CColumn*>
{
public :          
    CColumnSet(LPCWSTR lpszColumnID) 
    {
    // We are assuming the columnID is NULL terminated.  Since this is usually
    // hardcoded and there is no good way to verify that it is NULL terminated
    // this usage should be fine.

    size_t iLen = wcslen(lpszColumnID);
    m_lpszColumnID = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    if (m_lpszColumnID != NULL)
    {
        // Make a copy of the column set ID
        HRESULT hr = StringCchCopyW(m_lpszColumnID, iLen + 1, lpszColumnID);
        ASSERT(SUCCEEDED(hr));
    }
  }

  CColumnSet(LPCWSTR lpszColumnID, CList<CColumn*, CColumn*>&)
  {
    // We are assuming the columnID is NULL terminated.  Since this is usually
    // hardcoded and there is no good way to verify that it is NULL terminated
    // this usage should be fine.

    size_t iLen = wcslen(lpszColumnID);
    m_lpszColumnID = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    
    if (m_lpszColumnID)
    {
      // Make a copy of the column set ID
      HRESULT hr = StringCchCopyW(m_lpszColumnID, iLen + 1, lpszColumnID);
      ASSERT(SUCCEEDED(hr));
    }
  }

    ~CColumnSet() 
    {
    while(!IsEmpty())
    {
      CColumn* pColumn = RemoveTail();
      delete pColumn;
    }
        free(m_lpszColumnID);
    }

  void AddColumn(LPCWSTR lpszHeader, int nFormat, int nWidth, UINT nCol)
  {
    CColumn* pNewColumn = new CColumn(lpszHeader, nFormat, nWidth, nCol);
    AddTail(pNewColumn);
  }

    LPCWSTR GetColumnID() { return (LPCWSTR)m_lpszColumnID; }

    UINT GetNumCols() { return static_cast<UINT>(GetCount()); }

private :
    LPWSTR m_lpszColumnID;
};

////////////////////////////////////////////////////////////////////////////////
// CColumnSetList

class CColumnSetList : public CList<CColumnSet*, CColumnSet*>
{
public :
    // Find the column set given a column set ID
    CColumnSet* FindColumnSet(LPCWSTR lpszColumnID)
    {
        POSITION pos = GetHeadPosition();
        while (pos != NULL)
        {
            CColumnSet* pTempSet = GetNext(pos);
            ASSERT(pTempSet != NULL);

            LPCWSTR lpszTempNodeID = pTempSet->GetColumnID();

            if (wcscmp(lpszTempNodeID, lpszColumnID) == 0)
            {
                return pTempSet;
            }
        }
        return NULL;
    }

    void RemoveAndDeleteAllColumnSets()
    {
        while (!IsEmpty())
        {
            CColumnSet* pTempSet = RemoveTail();
            delete pTempSet;
        }
    }
};

///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject
// * this class contains the master tree data (i.e. the "document")
// * base class, have to derive from it


class CWatermarkInfoState; // fwd decl of private class

class CComponentDataObject:
  public IComponentData,
  public IExtendPropertySheet2,
    public IExtendContextMenu,
    public CPersistStreamImpl,
  public ISnapinHelp2,
  public IRequiredExtensions,
  public CComObjectRoot
{

BEGIN_COM_MAP(CComponentDataObject)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
  COM_INTERFACE_ENTRY(ISnapinHelp2)
  COM_INTERFACE_ENTRY(IRequiredExtensions)
END_COM_MAP()

#ifdef _DEBUG_REFCOUNT
    static unsigned int m_nOustandingObjects; // # of objects created
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        TRACE(_T("CComponentDataObject::InternalAddRef() refCount = %d\n"), dbg_cRef);
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        TRACE(_T("CComponentDataObject::InternalRelease() refCount = %d\n"), dbg_cRef);
        return CComObjectRoot::InternalRelease();
    }
#endif // _DEBUG_REFCOUNT

    CComponentDataObject();
    virtual ~CComponentDataObject();
    HRESULT FinalConstruct();
    void FinalRelease();

public:
// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent) = 0; // must override
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet2 interface members
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT lpDataObject, HBITMAP* lphWatermark, HBITMAP* lphHeader,
                                    HPALETTE* lphPalette, BOOL* pbStretch);

    HRESULT CreatePropertySheet(CTreeNode* pNode, HWND hWndParent, LPCWSTR lpszTitle);

public:

  //
  // IExtendContextMenu interface members
  //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                            LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
  
  //
  // IPersistStream interface members
  //
  STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream __RPC_FAR *pStm);
  STDMETHOD(Save)(IStream __RPC_FAR *pStm, BOOL fClearDirty);

  //
  // ISnapinHelp2 interface members
  //
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
  STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

  //
  // IRequiredExtensions interface members
  //
  STDMETHOD(EnableAllExtensions)() { return S_OK;} // load all always
  STDMETHOD(GetFirstExtension)(LPCLSID) { return S_FALSE;} // should not be called
  STDMETHOD(GetNextExtension)(LPCLSID) { return S_FALSE;} // should not be called

// virtual functions
protected:
    virtual HRESULT OnSetImages(LPIMAGELIST lpScopeImage) = 0; // must override
    virtual HRESULT OnExtensionExpand(LPDATAOBJECT, LPARAM)
        { return E_FAIL;}
  virtual HRESULT OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM arg);

// Notify handler declarations
private:
  HRESULT OnAdd(CTreeNode* cookie, LPARAM arg, LPARAM param);
  HRESULT OnRename(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnExpand(CInternalFormatCracker& ifc, 
                   LPARAM arg, 
                   LPARAM param, 
                   BOOL bAsync = TRUE);
  HRESULT OnSelect(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnContextMenu(CTreeNode* cookie, LPARAM arg, LPARAM param);
  HRESULT OnPropertyChange(LPARAM param, long fScopePane);

// Scope item creation helpers
private:
    void EnumerateScopePane(CTreeNode* cookie, 
                            HSCOPEITEM pParent, 
                            BOOL bAsync = TRUE);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);

// Helpers

public:
    LPCONSOLE GetConsole() { return m_pConsole;}

    HRESULT OnDeleteVerbHandler(CInternalFormatCracker& ifc, CComponentObject* pComponentObject);
    HRESULT OnRefreshVerbHandler(CInternalFormatCracker& ifc);
    HRESULT OnHelpHandler(CInternalFormatCracker& ifc, CComponentObject* pComponentObject);

    HRESULT AddNode(CTreeNode* pNodeToAdd);
  HRESULT AddNodeSorted(CTreeNode* pNodeToAdd);
    HRESULT DeleteNode(CTreeNode* pNodeToDelete);
  HRESULT DeleteMultipleNodes(CNodeList* pNodeList);
    HRESULT ChangeNode(CTreeNode* pNodeToChange, long changeMask);
    HRESULT UpdateVerbState(CTreeNode* pNodeToChange);
    HRESULT RemoveAllChildren(CContainerNode* pNode);
    HRESULT RepaintSelectedFolderInResultPane();
    HRESULT RepaintResultPane(CContainerNode* pNode);
    HRESULT DeleteAllResultPaneItems(CContainerNode* pNode);
    HRESULT SortResultPane(CContainerNode* pContainerNode);
  HRESULT UpdateResultPaneView(CContainerNode* pContainerNode);

    CPropertyPageHolderTable* GetPropertyPageHolderTable() { return &m_PPHTable; }
    CRunningThreadTable* GetRunningThreadTable() { return &m_RTTable; }
    CNotificationSinkTable* GetNotificationSinkTable() { return &m_NSTable; }

  void WaitForThreadExitMessage(CMTContainerNode* pNode);

    CWatermarkInfo* SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo);

    BOOL IsExtensionSnapin() { return m_bExtensionSnapin; }

  void SetLogFileName(PCWSTR pszLogName) { LOGFILE_NAME = pszLogName; }

protected:
    void SetExtensionSnapin(BOOL bExtensionSnapin)
            { m_bExtensionSnapin = bExtensionSnapin;}

private:
    HRESULT UpdateAllViewsHelper(LPARAM data, LONG_PTR hint);
    void HandleStandardVerbsHelper(CComponentObject* pComponentObj,
                                    LPCONSOLEVERB pConsoleVerb,
                                    BOOL bScope, BOOL bSelect,
                                    LPDATAOBJECT lpDataObject);
protected:
    virtual HRESULT SnapinManagerCreatePropertyPages(LPPROPERTYSHEETCALLBACK,
                                        LONG_PTR) {return S_FALSE; }
    virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES) {return FALSE; }
    
    virtual void OnInitialize();
    virtual void OnDestroy();

    // help handling
  virtual LPCWSTR GetHTMLHelpFileName() { return NULL; }
    BOOL WinHelp(LPCTSTR lpszHelpFileName, UINT uCommand, DWORD dwData);
    virtual void OnNodeContextHelp(CTreeNode*){}
  virtual void OnNodeContextHelp(CNodeList*) {}

public:
    virtual void OnDialogContextHelp(UINT, HELPINFO*) {}

  virtual BOOL IsMultiSelect() { return FALSE; }

// Scope pane helpers
public:

protected:
    HRESULT AddContainerNode(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem);
    HRESULT AddContainerNodeSorted(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem);

private:
    HRESULT DeleteContainerNode(CContainerNode* pNodeToDelete);
    HRESULT ChangeContainerNode(CContainerNode* pNodeToChange, long changeMask);
    void InitializeScopeDataItem(LPSCOPEDATAITEM pScopeDataItem, HSCOPEITEM pParentScopeItem, LPARAM lParam,
                                      int nImage, int nOpenImage, BOOL bHasChildren);

// Column Set helpers
public:
    CColumnSetList* GetColumnSetList() { return &m_ColList; }

private:
    CColumnSetList m_ColList;

// Result pane helpers
public:

protected:

private:
    HRESULT AddLeafNode(CLeafNode* pNodeToAdd);
    HRESULT DeleteLeafNode(CLeafNode* pNodeToDelete);
    HRESULT ChangeLeafNode(CLeafNode* pNodeToChange, long changeMask);

// Attributes
private:
    LPCONSOLE                         m_pConsole;               // IConsole interface pointer
  LPCONSOLENAMESPACE2             m_pConsoleNameSpace;    // IConsoleNameSpace interface pointer

    CPropertyPageHolderTable    m_PPHTable;             // property page holder table
    CRunningThreadTable           m_RTTable;                // table of running MT nodes
    CNotificationSinkTable      m_NSTable;              // notification sink table, for advise in events

    CWatermarkInfoState*      m_pWatermarkInfoState;        // internal watermark info for Wizards
    BOOL                        m_bExtensionSnapin;     // is this an extension?

// critical section (Serialization of calls to console)
public:
   // REVIEWED-2002/03/08-JeffJon-There appears to be no danger
   // of getting stuck in the critical section

    void Lock() { ::EnterCriticalSection(&m_cs); }
    void Unlock() { ::LeaveCriticalSection(&m_cs); }
private:
    CRITICAL_SECTION            m_cs;                   // general purpose critical section

// RootData
protected:
    CRootData* m_pRootData; // root node for the cache
    virtual CRootData* OnCreateRootData() = 0; // must override
public:
    CRootData* GetRootData() { ASSERT(m_pRootData != NULL); return m_pRootData;}

// Hidden window
private:
    CHiddenWnd m_hiddenWnd;     //  syncronization with background threads
  CTimerThread* m_pTimerThreadObj; // timer thread object
    HWND m_hWnd;                // thread safe HWND (gotten from the MFC CWnd)
public:
    BOOL PostExecMessage(CExecContext* pExec, LPARAM arg); // call from secondary thread
    BOOL PostForceEnumeration(CMTContainerNode* pContainerNode); // call from secondary thread
    HWND GetHiddenWindow() { ASSERT(m_hWnd != NULL); return m_hWnd;}

    BOOL OnCreateSheet(CPropertyPageHolderBase* pPPHolder, HWND hWnd);
    BOOL OnDeleteSheet(CPropertyPageHolderBase* pPPHolder, CTreeNode* pNode);

  HRESULT SetDescriptionBarText(CTreeNode* pTreeNode);

// Timer and Background Thread
public:
    BOOL StartTimerThread();
    void ShutDownTimerThread();
    BOOL PostMessageToTimerThread(UINT Msg, WPARAM wparam, LPARAM lParam);
    DWORD GetTimerInterval() { return m_dwTimerInterval;}
    
protected:
    DWORD m_dwTimerTime;    // sec

    // overrides that MUST be implemented
    virtual void OnTimer() { ASSERT(FALSE); }
    virtual void OnTimerThread(WPARAM, LPARAM) { ASSERT(FALSE); }
    virtual CTimerThread* OnCreateTimerThread() { return NULL; }
private:
    BOOL SetTimer();
    void KillTimer();
    void WaitForTimerThreadStartAck();
    DWORD m_nTimerThreadID;
    BOOL m_bTimerThreadStarted;
    DWORD m_dwTimerInterval; // sec

// friend class declarations
    friend class CDataObject; // for the GetRootData() member
    friend class CComponentObject; // for the FindObject() and OnPropertyChange() members
    friend class CHiddenWnd;
};


    
///////////////////////////////////////////////////////////////////////////////
// CComponentObject
// * this class is the view on the data contained in the "document"
// * base class, have to derive from it

class CComponentObject :
  public IComponent,
  public IExtendPropertySheet2,
    public IExtendContextMenu,
  public IExtendControlbar,
    public IResultDataCompareEx,
    public CComObjectRoot
{
public:

#ifdef _DEBUG_REFCOUNT
    static unsigned int m_nOustandingObjects; // # of objects created
    int dbg_cRef;
  ULONG InternalAddRef()
  {
        ++dbg_cRef;
    return CComObjectRoot::InternalAddRef();
  }
  ULONG InternalRelease()
  {
        --dbg_cRef;
    return CComObjectRoot::InternalRelease();
  }
#endif // _DEBUG_REFCOUNT

    CComponentObject();
    virtual ~CComponentObject();

BEGIN_COM_MAP(CComponentObject)
    COM_INTERFACE_ENTRY(IComponent)
  COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
  COM_INTERFACE_ENTRY(IExtendControlbar)
  COM_INTERFACE_ENTRY(IResultDataCompareEx)
END_COM_MAP()

public:
  //
  // IComponent interface members
  //
  STDMETHOD(Initialize)(LPCONSOLE lpConsole);
  STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
  STDMETHOD(Destroy)(MMC_COOKIE cookie);
  STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
  STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                      LPDATAOBJECT* ppDataObject);
  STDMETHOD(GetDisplayInfo)(LPRESULTDATAITEM  pResultDataItem);
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

  //
  // IExtendPropertySheet2 interface members
  //
  STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                                 LONG_PTR handle,
                                 LPDATAOBJECT lpIDataObject);
  STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
  STDMETHOD(GetWatermarks)(LPDATAOBJECT lpDataObject, HBITMAP* lphWatermark, HBITMAP* lphHeader,
                                  HPALETTE* lphPalette, BOOL* pbStretch);

  //
  // IExtendContextMenu interface members
  //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                                        LPCONTEXTMENUCALLBACK pCallbackUnknown,
                                        long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

  //
  // IExtendControlbar interface memebers
  //
  STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
  STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE type, LPARAM arg, LPARAM param);

  //
  // IResultDataCompare
  //
  STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

// Helpers for CComponentObject
public:
  void SetIComponentData(CComponentDataObject* pData);
    void SetSelectedNode(CTreeNode* pSelectedNode, DATA_OBJECT_TYPES selectedType)
    { m_pSelectedNode = pSelectedNode; m_selectedType = selectedType; }

// Notify event handlers
protected:
  HRESULT OnFolder(CTreeNode* cookie, LPARAM arg, LPARAM param);
  HRESULT OnShow(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnActivate(CTreeNode* cookie, LPARAM arg, LPARAM param);
    HRESULT OnResultItemClk(CInternalFormatCracker& ifc, BOOL fDblClick);
  HRESULT OnMinimize(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnPropertyChange(LPARAM param, long fScopePane);
  HRESULT OnUpdateView(LPDATAOBJECT lpDataObject, LPARAM data, LONG_PTR hint);
    HRESULT OnAddImages(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT SetDescriptionBarText(CTreeNode* pTreeNode);

    // Added by JEFFJON : response to MMCN_COLUMNS_CHANGED
    HRESULT OnColumnsChanged(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
    HRESULT OnColumnSortChanged(LPARAM arg, LPARAM param);

// Helper functions
protected:
  BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
  void Construct();
  void LoadResources();
  virtual HRESULT InitializeHeaders(CContainerNode* pContainerNode) = 0;
  virtual HRESULT InitializeToolbar(IToolbar*) { return E_NOTIMPL; }

public:
    HRESULT ForceSort(UINT iCol, DWORD dwDirection);

protected:
  void EnumerateResultPane(CContainerNode* pContainerNode);

// Result pane helpers
  virtual HRESULT InitializeBitmaps(CTreeNode* cookie) = 0;
    void HandleStandardVerbs(BOOL bScope, BOOL bSelect, LPDATAOBJECT lpDataObject);
    HRESULT AddResultPaneItem(CLeafNode* pNodeToInsert);
    HRESULT DeleteResultPaneItem(CLeafNode* pNodeToDelete);
    HRESULT ChangeResultPaneItem(CLeafNode* pNodeToChange, LONG_PTR changeMask);
    HRESULT FindResultPaneItemID(CLeafNode* pNode, HRESULTITEM* pItemID);

// Interface pointers
protected:
  LPCONSOLE          m_pConsole;            // IConsole interface pointer
  LPHEADERCTRL        m_pHeader;            // Result pane's header control interface
  LPRESULTDATA        m_pResult;          // My interface pointer to the result pane
  LPIMAGELIST         m_pImageResult;     // My interface pointer to the result pane image list
  LPTOOLBAR           m_pToolbar;         // Toolbar for view
  LPCONTROLBAR        m_pControlbar;      // control bar to hold my tool bars
  LPCONSOLEVERB       m_pConsoleVerb;       // pointer the console verb

    LPCOMPONENTDATA     m_pComponentData;   // Pointer to the IComponentData this object belongs to

// state variables for this window
    CContainerNode*     m_pSelectedContainerNode;   // scope item selection (MMCN_SHOW)
    CTreeNode*          m_pSelectedNode;            // item selection (MMC_SELECT)
    DATA_OBJECT_TYPES   m_selectedType;             // matching m_pSelectedNode
};

inline void CComponentObject::SetIComponentData(CComponentDataObject* pData)
{
    TRACE(_T("CComponentObject::SetIComponentData()\n"));
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown(); // does not addref
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec);

#endif //_COMPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\aclpag_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       aclpag_.cpp
//
//--------------------------------------------------------------------------



#include <aclpage.h>
#include <dssec.h>



///////////////////////////////////////////////////////////////////////
// CDynamicLibraryBase

class CDynamicLibraryBase
{
public:
	CDynamicLibraryBase()
	{
		m_lpszLibraryName = NULL;
		m_lpszFunctionName = NULL;
		m_lpszFunctionNameEx = NULL;
		m_hLibrary = NULL;
		m_pfFunction = NULL;
		m_pfFunctionEx = NULL;
	}
	virtual ~CDynamicLibraryBase()
	{
		if (m_hLibrary != NULL)
		{
			::FreeLibrary(m_hLibrary);
			m_hLibrary = NULL;
		}
	}
	BOOL Load()
	{
		if (m_hLibrary != NULL)
			return TRUE; // already loaded

		ASSERT(m_lpszLibraryName != NULL);
		m_hLibrary = ::LoadLibrary(m_lpszLibraryName);
		if (NULL == m_hLibrary)
		{
			// The library is not present
			return FALSE;
		}
		ASSERT(m_lpszFunctionName != NULL);
		ASSERT(m_pfFunction == NULL);
		m_pfFunction = ::GetProcAddress(m_hLibrary, m_lpszFunctionName );
		if ( NULL == m_pfFunction )
		{
			// The library is present but does not have the entry point
			::FreeLibrary( m_hLibrary );
			m_hLibrary = NULL;
			return FALSE;
		}

		if (m_lpszFunctionNameEx != NULL)
		{
			ASSERT(m_pfFunctionEx == NULL);
			m_pfFunctionEx = ::GetProcAddress(m_hLibrary, m_lpszFunctionNameEx);
			if ( NULL == m_pfFunctionEx)
			{
				::FreeLibrary( m_hLibrary );
				m_hLibrary = NULL;
				return FALSE;
			}
		}

		ASSERT(m_hLibrary != NULL);
		ASSERT(m_pfFunction != NULL);
		return TRUE;
	}


protected:
	LPCSTR	m_lpszFunctionName;
	LPCSTR	m_lpszFunctionNameEx;
	LPCTSTR m_lpszLibraryName;
	FARPROC m_pfFunction;
	FARPROC m_pfFunctionEx;
	HMODULE m_hLibrary;
};

///////////////////////////////////////////////////////////////////////
// CDsSecDLL

class CDsSecDLL : public CDynamicLibraryBase
{
public:
	CDsSecDLL()
	{
		m_lpszLibraryName = _T("dssec.dll");
		m_lpszFunctionName = "DSCreateISecurityInfoObject";
		m_lpszFunctionNameEx = "DSCreateISecurityInfoObjectEx";
	}
	HRESULT DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,		// in
								   LPCWSTR pwszObjectClass,			// in
								   LPSECURITYINFO* ppISecurityInfo	// out
								   );

	HRESULT DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,		// in
														LPCWSTR pwszObjectClass,	// in
														LPCWSTR pwszServer,			// in
														LPCWSTR pwszUsername,		// in
														LPCWSTR pwszPassword,		// in
														DWORD dwFlags,
														LPSECURITYINFO* ppISecurityInfo	// out
														);
};


HRESULT CDsSecDLL::DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,		// in
								   LPCWSTR pwszObjectClass,			// in
								   LPSECURITYINFO* ppISecurityInfo	// out
								   )
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return ((PFNDSCREATEISECINFO)m_pfFunction)
					(pwszObjectPath,pwszObjectClass, 0, ppISecurityInfo, NULL, NULL, 0);
}

HRESULT CDsSecDLL::DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,		// in
								   LPCWSTR pwszObjectClass,			// in
									LPCWSTR pwszServer,			// in
									LPCWSTR pwszUsername,		// in
									LPCWSTR pwszPassword,		// in
									DWORD	dwFlags,
								   LPSECURITYINFO* ppISecurityInfo	// out
								   )
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunctionEx != NULL);
	return ((PFNDSCREATEISECINFOEX)m_pfFunctionEx)
					(pwszObjectPath,pwszObjectClass, pwszServer,
					 pwszUsername, pwszPassword, dwFlags, ppISecurityInfo, NULL, NULL, 0);
}

///////////////////////////////////////////////////////////////////////
// CAclUiDLL

class CAclUiDLL : public CDynamicLibraryBase
{
public:
	CAclUiDLL()
	{
		m_lpszLibraryName = _T("aclui.dll");
		m_lpszFunctionName = "CreateSecurityPage";
		m_pfFunction = NULL;
		m_lpszFunctionNameEx = NULL;
		m_pfFunctionEx = NULL;
	}

	HPROPSHEETPAGE CreateSecurityPage( LPSECURITYINFO psi );
};


typedef HPROPSHEETPAGE (*ACLUICREATESECURITYPAGEPROC) (LPSECURITYINFO);

HPROPSHEETPAGE CAclUiDLL::CreateSecurityPage( LPSECURITYINFO psi )
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return ((ACLUICREATESECURITYPAGEPROC)m_pfFunction) (psi);
}


//////////////////////////////////////////////////////////////////////////
// CISecurityInformationWrapper

class CISecurityInformationWrapper : public ISecurityInformation
{
public:
	CISecurityInformationWrapper(CAclEditorPage* pAclEditorPage)
	{
		m_dwRefCount = 0;
		ASSERT(pAclEditorPage != NULL);
		m_pAclEditorPage = pAclEditorPage;
		m_pISecInfo = NULL;
	}
	~CISecurityInformationWrapper()
	{
		ASSERT(m_dwRefCount == 0);
    ISecurityInformation* pSecInfo = GetSecInfoPtr();
		if (pSecInfo != NULL)
			pSecInfo->Release();
	}
  void SetSecInfoPtr(ISecurityInformation* pSecInfo)
  {
    ASSERT(pSecInfo != NULL);
    m_pISecInfo = pSecInfo;
  }
  ISecurityInformation* GetSecInfoPtr()
  {
    return m_pISecInfo;
  }
public:
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj)
	{ 
		return GetSecInfoPtr()->QueryInterface(riid, ppvObj);
	}
	STDMETHOD_(ULONG,AddRef) ()
	{ 
		// trap the first addref to increment count on page holder
		if (m_dwRefCount == 0)
		{
			m_pAclEditorPage->m_pPageHolder->AddRef();
		}
		m_dwRefCount++;
		return GetSecInfoPtr()->AddRef();
	}
	STDMETHOD_(ULONG,Release) ()
	{
		m_dwRefCount--;
		// this might be the last release on the page holder
		// which would cause the holder to delete itself and
		// "this" in the process (i.e. "this" no more valid when
		// returning from the m_pPageHolder->Release() call
		ISecurityInformation* pISecInfo = GetSecInfoPtr();

		// trap the last release to decrement count on page holder
		if (m_dwRefCount == 0)
		{
			m_pAclEditorPage->m_pPageHolder->Release();
		}
		return pISecInfo->Release();
	}

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo )
	{
		return GetSecInfoPtr()->GetObjectInformation(pObjectInfo);
	}
	STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
							PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
							BOOL fDefault)
	{ 
		return GetSecInfoPtr()->GetSecurity(RequestedInformation,
										ppSecurityDescriptor,
										fDefault);
	}
	STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
							PSECURITY_DESCRIPTOR pSecurityDescriptor )
	{ 
		return GetSecInfoPtr()->SetSecurity(SecurityInformation,
										pSecurityDescriptor);
	}
	STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
								DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
								PSI_ACCESS *ppAccess,
								ULONG *pcAccesses,
								ULONG *piDefaultAccess )
	{ 
		return GetSecInfoPtr()->GetAccessRights(pguidObjectType,
											dwFlags,
											ppAccess,
											pcAccesses,
											piDefaultAccess);
	}
	STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
						   UCHAR *pAceFlags,
						   ACCESS_MASK *pMask)
	{ 
		return GetSecInfoPtr()->MapGeneric(pguidObjectType,
										pAceFlags,
										pMask);
	}
	STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
								ULONG *pcInheritTypes )
	{ 
		return GetSecInfoPtr()->GetInheritTypes(ppInheritTypes,
											pcInheritTypes);
	}
	STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
	{ 
		return GetSecInfoPtr()->PropertySheetPageCallback(hwnd, uMsg, uPage);
	}


private:
	DWORD m_dwRefCount;
	ISecurityInformation* m_pISecInfo;	// interface pointer to the wrapped interface
	CAclEditorPage* m_pAclEditorPage;	// back pointer

	//friend class CAclEditorPage;
};



//////////////////////////////////////////////////////////////////////////
// static instances of the dynamically loaded DLL's

CDsSecDLL g_DsSecDLL;
CAclUiDLL g_AclUiDLL;


//////////////////////////////////////////////////////////////////////////
// CAclEditorPage

CAclEditorPage* CAclEditorPage::CreateInstance(LPCTSTR lpszLDAPPath,
									CPropertyPageHolderBase* pPageHolder)
{
	CAclEditorPage* pAclEditorPage = new CAclEditorPage;
	if (pAclEditorPage != NULL)
	{
		pAclEditorPage->SetHolder(pPageHolder);
		if (FAILED(pAclEditorPage->Initialize(lpszLDAPPath)))
		{
			delete pAclEditorPage;
			pAclEditorPage = NULL;
		}
	}
	return pAclEditorPage;
}


CAclEditorPage* CAclEditorPage::CreateInstanceEx(LPCTSTR lpszLDAPPath,
																 LPCTSTR lpszServer,
																 LPCTSTR lpszUsername,
																 LPCTSTR lpszPassword,
																 DWORD dwFlags,
									CPropertyPageHolderBase* pPageHolder)
{
	CAclEditorPage* pAclEditorPage = new CAclEditorPage;
	if (pAclEditorPage != NULL)
	{
		pAclEditorPage->SetHolder(pPageHolder);
		if (FAILED(pAclEditorPage->InitializeEx(lpszLDAPPath,
																lpszServer,
																lpszUsername,
																lpszPassword,
																dwFlags)))
		{
			delete pAclEditorPage;
			pAclEditorPage = NULL;
		}
	}
	return pAclEditorPage;
}


CAclEditorPage::CAclEditorPage()
{
	m_pPageHolder = NULL;
	m_pISecInfoWrap = new CISecurityInformationWrapper(this);
}

CAclEditorPage::~CAclEditorPage()
{
	delete m_pISecInfoWrap;
}

HRESULT CAclEditorPage::Initialize(LPCTSTR lpszLDAPPath)
{
	// get ISecurityInfo* from DSSECL.DLL
	if (!g_DsSecDLL.Load())
		return E_INVALIDARG;
	
  ISecurityInformation* pSecInfo = NULL;
	HRESULT hr = g_DsSecDLL.DSCreateISecurityInfoObject(
										lpszLDAPPath,
										NULL, // pwszObjectClass
                    &pSecInfo);
  if (SUCCEEDED(hr))
    m_pISecInfoWrap->SetSecInfoPtr(pSecInfo);

  return hr;
}

HRESULT CAclEditorPage::InitializeEx(LPCTSTR lpszLDAPPath,
												 LPCTSTR lpszServer,
												 LPCTSTR lpszUsername,
												 LPCTSTR lpszPassword,
												 DWORD dwFlags)
{
	// get ISecurityInfo* from DSSECL.DLL
	if (!g_DsSecDLL.Load())
		return E_INVALIDARG;
	
  ISecurityInformation* pSecInfo = NULL;
	HRESULT hr = g_DsSecDLL.DSCreateISecurityInfoObjectEx(
										lpszLDAPPath,
										NULL, // pwszObjectClass
										lpszServer,
										lpszUsername,
										lpszPassword,
										dwFlags,
                    &pSecInfo);
  if (SUCCEEDED(hr))
    m_pISecInfoWrap->SetSecInfoPtr(pSecInfo);

  return hr;
}

HPROPSHEETPAGE CAclEditorPage::CreatePage()
{
	if (!g_AclUiDLL.Load())
		return NULL;

	// call into ACLUI.DLL to create the page
	// passing the wrapper interface
	return g_AclUiDLL.CreateSecurityPage(m_pISecInfoWrap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\compbas_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       compbas_.cpp
//
//--------------------------------------------------------------------------

#include <strsafe.h>

// initialize to the thread ID of the thread that loads the snapin
// that is the main thread
extern DWORD _MainThreadId = ::GetCurrentThreadId();

const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");
const TCHAR g_szNodeType[] = TEXT("NodeType");
const TCHAR g_szNameString[] = TEXT("NameString");
const TCHAR g_szNameStringIndirect[] = TEXT("NameStringIndirect");
const TCHAR g_szStandaloneSnap[] = TEXT("Standalone");
const TCHAR g_szExtensionSnap[] = TEXT("Extension");
const TCHAR g_szNodeTypes[] = TEXT("NodeTypes");
const TCHAR g_szExtensions[] = TEXT("Extensions");
const TCHAR g_szDynamicExtensions[] = TEXT("Dynamic Extensions");
const TCHAR g_szVersion[] = TEXT("Version");
const TCHAR g_szProvider[] = _T("Provider");
const TCHAR g_szAbout[] = _T("About");

const unsigned int MAX_KEY_PATH_LENGTH = 2047; // not including null
const unsigned int MAX_GUID_LENGTH = 127;      // not including null


HRESULT RegisterSnapin(const GUID* pSnapinCLSID,
                       const GUID* pStaticNodeGUID,
                       const GUID* pAboutGUID,
                       LPCTSTR lpszNameString, LPCTSTR lpszVersion, LPCTSTR lpszProvider,
             BOOL bExtension, _NODE_TYPE_INFO_ENTRY* pNodeTypeInfoEntryArray,
             UINT nSnapinNameID)
{
    OLECHAR szSnapinClassID[MAX_GUID_LENGTH + 1] = {0}, 
        szStaticNodeGuid[MAX_GUID_LENGTH + 1] = {0}, 
        szAboutGuid[MAX_GUID_LENGTH + 1] = {0};
    int numWritten;
    
    numWritten = ::StringFromGUID2(
        *pSnapinCLSID,
        szSnapinClassID,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    numWritten = ::StringFromGUID2(
        *pStaticNodeGUID,
        szStaticNodeGuid,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    numWritten = ::StringFromGUID2(
        *pAboutGUID,
        szAboutGuid,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    CRegKey regkeySnapins;
    LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open
    
    CRegKey regkeyThisSnapin;
    lRes = regkeyThisSnapin.Create(regkeySnapins, szSnapinClassID);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to create

    lRes = regkeyThisSnapin.SetValue(lpszNameString, g_szNameString);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes);

  // JeffJon 6/12/00 100624: MUI: MMC: Shared Folders snap-in
  //                      stores its display information in the registry
  if (nSnapinNameID != 0)
  {
    CString str;

    // NOTICE-2002/04/08-artm  Beware file name truncation.
    // Code iteratively grows the buffer size until either the buffer
    // gets too big or the module file name is read without truncation.
    //
    // See NTRAID#NTBUG9-540042 for more information and 
    //     NTRAID#NTBUG9-616513.

#ifdef DBG
    // on chk builds, use a small buffer size so that our growth algorithm
    // gets exercised
    unsigned      bufSizeInCharacters = 1;
#else
    unsigned      bufSizeInCharacters = _MAX_PATH;
#endif

    PWSTR szModule = 0;
    HRESULT hr = S_OK;

    do
    {
        // +1 for extra null-termination paranoia
        szModule = new WCHAR[bufSizeInCharacters + 1];
        if (!szModule)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        ::ZeroMemory(szModule, (bufSizeInCharacters + 1) * sizeof WCHAR);

        // Pass the buffer size, in characters.
        DWORD result =
            ::GetModuleFileName(AfxGetInstanceHandle(), szModule, bufSizeInCharacters);

        if (!result)
        {
            DWORD err = GetLastError();
            hr = HRESULT_FROM_WIN32(err);
            ASSERT(FAILED(hr));
            break;
        }

        if (result == bufSizeInCharacters)
        {
            // buffer was too small, so the value was truncated.  Resize the
            // buffer and try again.

            delete[] szModule;

            bufSizeInCharacters *= 2;
            if (bufSizeInCharacters > USHRT_MAX)   // effectively ~32K max
            {
                // too big. way too big. Bail out.
                ASSERT(false);
                hr = E_FAIL;
                break;
            }
            continue;
        }

        // We should always have a null terminated string.
        ASSERT(szModule[result] == 0);

        break;
    }
    while (true);

    if (SUCCEEDED(hr))
    {
        str.Format(_T("@%s,-%d"), szModule, nSnapinNameID);
    }

    delete [] szModule;
    szModule = NULL;

    if (FAILED(hr))
    {
        return hr;
    }

    lRes = regkeyThisSnapin.SetValue(str, g_szNameStringIndirect);
    if (lRes != ERROR_SUCCESS)
      return HRESULT_FROM_WIN32(lRes);
  }

    lRes = regkeyThisSnapin.SetValue(szAboutGuid, g_szAbout);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes);
    lRes = regkeyThisSnapin.SetValue(szStaticNodeGuid, g_szNodeType);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes);
    lRes = regkeyThisSnapin.SetValue(lpszProvider, g_szProvider);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes);
    lRes = regkeyThisSnapin.SetValue(lpszVersion, g_szVersion);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes);

    CRegKey regKeyStandaloneorExtension;
    lRes = regKeyStandaloneorExtension.Create(regkeyThisSnapin,
    bExtension ? g_szExtensionSnap : g_szStandaloneSnap);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes);

    CRegKey regKeyNodeTypes;
    lRes = regKeyNodeTypes.Create(regkeyThisSnapin, g_szNodeTypes);
    if (lRes != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(lRes);
    }

    OLECHAR szNodeGUID[MAX_GUID_LENGTH + 1];

    for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = pNodeTypeInfoEntryArray;
            pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
    {
        numWritten = ::StringFromGUID2(
            *(pCurrEntry->m_pNodeGUID),
            szNodeGUID,
            MAX_GUID_LENGTH + 1);
        if (numWritten <= 0)
        {
            ASSERT(false);
            return E_FAIL;
        }

        CRegKey regKeyNode;
        lRes = regKeyNode.Create(regKeyNodeTypes, szNodeGUID);
        if (lRes != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(lRes);
        }
    }

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT UnregisterSnapin(const GUID* pSnapinCLSID)
{
    OLECHAR szSnapinClassID[MAX_GUID_LENGTH + 1];
    int numWritten;

    numWritten = ::StringFromGUID2(
        *pSnapinCLSID,
        szSnapinClassID,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    CRegKey regkeySnapins;
    LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to open
  }
    
    lRes = regkeySnapins.RecurseDeleteKey(szSnapinClassID);
    ASSERT(lRes == ERROR_SUCCESS);
    return HRESULT_FROM_WIN32(lRes);
}


HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription)
{
    OLECHAR szNodeGuid[MAX_GUID_LENGTH + 1];
    int numWritten;

    numWritten = ::StringFromGUID2(
        *pGuid,
        szNodeGuid, 
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }


    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to open
  }

    CRegKey regkeyThisNodeType;
    lRes = regkeyThisNodeType.Create(regkeyNodeTypes, szNodeGuid);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to create
  }

    lRes = regkeyThisNodeType.SetValue(lpszNodeDescription);
    ASSERT(lRes == ERROR_SUCCESS);
    return HRESULT_FROM_WIN32(lRes);
}

HRESULT UnregisterNodeType(const GUID* pGuid)
{
    OLECHAR szNodeGuid[MAX_GUID_LENGTH + 1];
    int numWritten;

    numWritten = ::StringFromGUID2(
        *pGuid,
        szNodeGuid, 
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to open
  }

    lRes = regkeyNodeTypes.RecurseDeleteKey(szNodeGuid);
    ASSERT(lRes == ERROR_SUCCESS);
    return HRESULT_FROM_WIN32(lRes);
}

HRESULT RegisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
                              const GUID* pExtensionSnapinCLSID, LPCTSTR lpszDescription,
                BOOL bDynamic)
{
    OLECHAR szNodeGuid[MAX_GUID_LENGTH + 1], szExtensionSnapinCLSID[MAX_GUID_LENGTH + 1];
    int numWritten;

    numWritten = ::StringFromGUID2(
        *pNodeGuid, 
        szNodeGuid, 
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    numWritten = ::StringFromGUID2(
        *pExtensionSnapinCLSID, 
        szExtensionSnapinCLSID,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    //
    // compose full path of key up to the node GUID
    //

    WCHAR szKeyPath[MAX_KEY_PATH_LENGTH + 1];
    HRESULT hr;

    // NOTICE-2002/04/18-artm  ntraid#ntbug9-540061
    // StringCchPrintf() guarantees that string will be null terminated
    // and will not overrun the buffer.
    hr = StringCchPrintf(
        szKeyPath, 
        MAX_KEY_PATH_LENGTH + 1,
        L"%s\\%s",
        NODE_TYPES_KEY,
        szNodeGuid);

    if (FAILED(hr))
    {
        ASSERT(false);
        return hr;
    }
    
    CRegKey regkeyNodeTypesNode;
    LONG lRes = regkeyNodeTypesNode.Open(HKEY_LOCAL_MACHINE, szKeyPath);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to open
  }

    CRegKey regkeyExtensions;
    lRes = regkeyExtensions.Create(regkeyNodeTypesNode, g_szExtensions);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to create
  }

    CRegKey regkeyExtensionType;
    lRes = regkeyExtensionType.Create(regkeyExtensions, lpszExtensionType);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to create
  }

    lRes = regkeyExtensionType.SetValue(lpszDescription, szExtensionSnapinCLSID);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
  {
        return HRESULT_FROM_WIN32(lRes); // failed to set value
  }

  if (bDynamic)
  {
    // create a subkey under the node GUID
    CRegKey regkeyDynamicExtensions;
      lRes = regkeyDynamicExtensions.Create(regkeyNodeTypesNode, g_szDynamicExtensions);
      ASSERT(lRes == ERROR_SUCCESS);
      if (lRes != ERROR_SUCCESS)
          return HRESULT_FROM_WIN32(lRes); // failed to create

    // set value (same value as the extension type above)
    lRes = regkeyDynamicExtensions.SetValue(lpszDescription, szExtensionSnapinCLSID);
      ASSERT(lRes == ERROR_SUCCESS);
      if (lRes != ERROR_SUCCESS)
    {
          return HRESULT_FROM_WIN32(lRes); // failed to set value
    }
  }
  return HRESULT_FROM_WIN32(lRes);
}


HRESULT UnregisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
                              const GUID* pExtensionSnapinCLSID, BOOL bDynamic)
{
    OLECHAR szNodeGuid[MAX_GUID_LENGTH + 1], szExtensionSnapinCLSID[MAX_GUID_LENGTH + 1];
    int numWritten;

    numWritten = ::StringFromGUID2(
        *pNodeGuid, 
        szNodeGuid,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    numWritten = ::StringFromGUID2(
        *pExtensionSnapinCLSID, 
        szExtensionSnapinCLSID,
        MAX_GUID_LENGTH + 1);
    if (numWritten <= 0)
    {
        ASSERT(false);
        return E_FAIL;
    }

    //
    // compose full path of key up to the node GUID
    //

    WCHAR szKeyPath[MAX_KEY_PATH_LENGTH + 1];
    HRESULT hr;

    // NOTICE-2002/04/18-artm  ntraid#ntbug9-540061
    // StringCchPrintf() guarantees that string will be null terminated
    // and will not overrun the buffer.
    hr = StringCchPrintf(
        szKeyPath, 
        MAX_KEY_PATH_LENGTH + 1,
        L"%s\\%s",
        NODE_TYPES_KEY,
        szNodeGuid);

    if (FAILED(hr))
    {
        ASSERT(false);
        return hr;
    }
    
    CRegKey regkeyNodeTypesNode;
    LONG lRes = regkeyNodeTypesNode.Open(HKEY_LOCAL_MACHINE, szKeyPath);
    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

  lRes = ERROR_SUCCESS;

  // open the key for the Dynamic extensions
  if (bDynamic)
  {
    CRegKey regkeyDynamicExtensions;
      lRes = regkeyDynamicExtensions.Open(regkeyNodeTypesNode, g_szDynamicExtensions);
      if (lRes == ERROR_SUCCESS)
    {
      lRes = regkeyDynamicExtensions.DeleteValue(szExtensionSnapinCLSID);
    }
  }
  else
  {
    //
    // Open the extensions key
    //
    CRegKey regkeyExtensions;
    lRes = regkeyExtensions.Open(regkeyNodeTypesNode, g_szExtensions);
    if (lRes == ERROR_SUCCESS)
    {
      CRegKey regkeyExtensionType;
      lRes = regkeyExtensionType.Open(regkeyExtensions, lpszExtensionType);
      if (lRes == ERROR_SUCCESS)
      {
        lRes = regkeyExtensionType.DeleteValue(szExtensionSnapinCLSID);
      }
    }
  }
  lRes = ERROR_SUCCESS;
  return HRESULT_FROM_WIN32(lRes);
}




/////////////////////////////////////////////////////////////////////////////
// CTimerThread

BOOL CTimerThread::Start(HWND hWnd)
{
    ASSERT(m_hWnd == NULL);
    ASSERT(::IsWindow(hWnd));
    m_hWnd = hWnd;
    return CreateThread();
}

BOOL CTimerThread::PostMessageToWnd(WPARAM wParam, LPARAM lParam)
{
    ASSERT(::IsWindow(m_hWnd));
    return ::PostMessage(m_hWnd, CHiddenWnd::s_TimerThreadMessage, wParam, lParam);
}


/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

CWorkerThread::CWorkerThread()
{
    m_bAutoDelete = FALSE;
    m_bAbandoned = FALSE;
    m_hEventHandle = NULL;
    ExceptionPropagatingInitializeCriticalSection(&m_cs);
    m_hWnd = NULL;
}

CWorkerThread::~CWorkerThread()
{
    ::DeleteCriticalSection(&m_cs);
    if (m_hEventHandle != NULL)
    {
        VERIFY(::CloseHandle(m_hEventHandle));
        m_hEventHandle = NULL;
    }
}

BOOL CWorkerThread::Start(HWND hWnd)
{
    ASSERT(m_hWnd == NULL);
    ASSERT(::IsWindow(hWnd));
    m_hWnd = hWnd;

   // REVIEWED-2002/03/08-JeffJon-Squatting isn't an issue here because this is not a
   // named event

    ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
    m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
    if (m_hEventHandle == NULL)
  {
        return FALSE;
  }

    return CreateThread();
}

void CWorkerThread::Abandon()
{
    Lock();
    OnAbandon();
    m_bAutoDelete = TRUE;
    m_bAbandoned = TRUE;
    Unlock();
}


BOOL CWorkerThread::IsAbandoned()
{
    Lock();
    BOOL b = m_bAbandoned;
    Unlock();
    return b;
}

BOOL CWorkerThread::PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = IsAbandoned();
    if (b)
  {
        return TRUE; // no need to post
  }

    ASSERT(::IsWindow(m_hWnd));
    return ::PostMessage(m_hWnd, Msg, wParam, lParam);
}

void CWorkerThread::WaitForExitAcknowledge()
{
    BOOL b = IsAbandoned();
    if (b)
  {
        return;
  }

    VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE));
}



/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd


const UINT CHiddenWnd::s_NodeThreadHaveDataNotificationMessage =    WM_USER + 1;
const UINT CHiddenWnd::s_NodeThreadErrorNotificationMessage =       WM_USER + 2;
const UINT CHiddenWnd::s_NodeThreadExitingNotificationMessage =     WM_USER + 3;

const UINT CHiddenWnd::s_NodePropertySheetCreateMessage =           WM_USER + 4;
const UINT CHiddenWnd::s_NodePropertySheetDeleteMessage =           WM_USER + 5;

const UINT CHiddenWnd::s_ExecCommandMessage =                       WM_USER + 6;
const UINT CHiddenWnd::s_ForceEnumerationMessage =                  WM_USER + 7;
const UINT CHiddenWnd::s_TimerThreadMessage =                       WM_USER + 8;


CHiddenWnd::CHiddenWnd(CComponentDataObject* pComponentDataObject)
{
    m_pComponentDataObject = pComponentDataObject;
    m_nTimerID = 0;
}


LRESULT CHiddenWnd::OnNodeThreadHaveDataNotification(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    //TRACE(_T("CHiddenWnd::OnNodeThreadHaveDataNotification()\n"));
    ASSERT(m_pComponentDataObject != NULL);

    // call into the CTreeNode code
    CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
    ASSERT(pNode);
    ASSERT(pNode->IsContainer());
    pNode->OnThreadHaveDataNotification(m_pComponentDataObject);
    return 1;
}



LRESULT CHiddenWnd::OnNodeThreadExitingNotification(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    //TRACE(_T("CHiddenWnd::OnNodeThreadExitingNotification()\n"));
    ASSERT(m_pComponentDataObject != NULL);

    // call into the CTreeNode code
    CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
    ASSERT(pNode);
    ASSERT(pNode->IsContainer());
    pNode->OnThreadExitingNotification(m_pComponentDataObject);

    // notify anybody interested in this event
    m_pComponentDataObject->GetNotificationSinkTable()->Notify(
            CHiddenWnd::s_NodeThreadExitingNotificationMessage ,wParam,lParam);
    return 1;
}

LRESULT CHiddenWnd::OnNodeThreadErrorNotification(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    ASSERT(m_pComponentDataObject != NULL);

    // call into the CTreeNode code
    CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
    DWORD dwErr = static_cast<DWORD>(lParam);
    ASSERT(pNode);
    ASSERT(pNode->IsContainer());
    pNode->OnThreadErrorNotification(dwErr, m_pComponentDataObject);
    return 1;
}


LRESULT CHiddenWnd::OnNodePropertySheetCreate(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    //TRACE(_T("CHiddenWnd::OnNodePropertySheetCreate()\n"));
    ASSERT(m_pComponentDataObject != NULL);

    CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(wParam);
    ASSERT(pPPHolder != NULL);
    HWND hWnd = reinterpret_cast<HWND>(lParam);
    ASSERT(::IsWindow(hWnd));

    m_pComponentDataObject->GetPropertyPageHolderTable()->AddWindow(pPPHolder, hWnd);

    return 1;
}



LRESULT CHiddenWnd::OnNodePropertySheetDelete(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    //TRACE(_T("CHiddenWnd::OnNodePropertySheetDestroy()\n"));
    ASSERT(m_pComponentDataObject != NULL);

    CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(wParam);
    ASSERT(pPPHolder != NULL);
    CTreeNode* pNode = reinterpret_cast<CTreeNode*>(lParam);
    ASSERT(pNode != NULL);

    m_pComponentDataObject->GetPropertyPageHolderTable()->Remove(pPPHolder);
    pNode->OnDeleteSheet();
    //if Node is only for displaying the property sheet, delete the node
    //once the property sheet is deleted
    if(!pNode->HasSheet() && pNode->IsNodeForPropSheet())
    {
        delete pNode;
    }

    return 1;
}

LRESULT CHiddenWnd::OnExecCommand(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    //TRACE(_T("CHiddenWnd::OnExecCommand()\n"));
    ASSERT(m_pComponentDataObject != NULL);

    CExecContext* pExec = reinterpret_cast<CExecContext*>(wParam);
    ASSERT(pExec != NULL);

    pExec->Execute((long)lParam); // execute code
    TRACE(_T("CHiddenWnd::BeforeDone()\n"));
    pExec->Done();      // let the secondary thread proceed
    return 1;
}

LRESULT CHiddenWnd::OnForceEnumeration(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    TRACE(_T("CHiddenWnd::OnForceEnumeration()\n"));
    ASSERT(m_pComponentDataObject != NULL);
    // call into the CTreeNode code
    CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
    ASSERT(pNode);
    ASSERT(pNode->GetContainer() != NULL); // not the root!!!
    ASSERT(pNode->IsContainer());
    pNode->ForceEnumeration(m_pComponentDataObject);
    return 1;
}

LRESULT CHiddenWnd::OnTimerThread(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    //TRACE(_T("CHiddenWnd::OnTimerThread()\n"));
    ASSERT(m_pComponentDataObject != NULL);

    // NULL arguments means that the thread acknowledge it is running properly
    // only to be called once
    if ((wParam == 0) && (lParam == 0))
    {
        ASSERT(!m_pComponentDataObject->m_bTimerThreadStarted);
        m_pComponentDataObject->m_bTimerThreadStarted = TRUE;
    }
    else
    {
        // got some object specific message
        m_pComponentDataObject->OnTimerThread(wParam, lParam);
    }
    return 1;
}

LRESULT CHiddenWnd::OnTimer(UINT, WPARAM, LPARAM, BOOL&)
{
    ASSERT(m_pComponentDataObject != NULL);
    m_pComponentDataObject->OnTimer();
  return 1;
}



////////////////////////////////////////////////////////////////////////////////////
// CRunningThreadTable

#define RUNNING_THREAD_ARRAY_DEF_SIZE (4)


CRunningThreadTable::CRunningThreadTable(CComponentDataObject* pComponentData)
{
    m_pComponentData = pComponentData;

   size_t arraySizeInBytes = sizeof(CMTContainerNode*) * RUNNING_THREAD_ARRAY_DEF_SIZE;
    m_pEntries = (CMTContainerNode**)malloc(arraySizeInBytes);

  if (m_pEntries != NULL)
  {
     // This is acceptable usage of memset

      memset(m_pEntries,NULL, arraySizeInBytes);
  }
    m_nSize = RUNNING_THREAD_ARRAY_DEF_SIZE;
}

CRunningThreadTable::~CRunningThreadTable()
{
#ifdef _DEBUG
    for (int k=0; k < m_nSize; k++)
    {
        ASSERT(m_pEntries[k] == NULL);
    }
#endif      
    free(m_pEntries);
}

void CRunningThreadTable::Add(CMTContainerNode* pNode)
{
    ASSERT(pNode != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k] == NULL) // get the first empty spot
        {
            pNode->IncrementThreadLockCount();
            m_pEntries[k] = pNode;
            return;
        }
    }

    // all full, need to grow the array
    int nAlloc = m_nSize*2;
   size_t arraySizeInBytes = sizeof(CMTContainerNode*)*nAlloc;
   CMTContainerNode** temp = (CMTContainerNode**)realloc(m_pEntries, arraySizeInBytes);
   if (temp)
   {
      m_pEntries = temp;
   }
   else
   {
      return;
   }

   // This is acceptable usage
   memset(&m_pEntries[m_nSize], NULL, sizeof(CMTContainerNode*)*m_nSize);
    
   pNode->IncrementThreadLockCount();
    m_pEntries[m_nSize] = pNode;
    m_nSize = nAlloc;
}

BOOL CRunningThreadTable::IsPresent(CMTContainerNode* pNode)
{
  ASSERT(pNode != NULL);
  for (int k=0; k < m_nSize; k++)
  {
    if (m_pEntries[k] == pNode)
    {
      return TRUE;
    }
  }
  return FALSE;
}

void CRunningThreadTable::Remove(CMTContainerNode* pNode)
{
    ASSERT(pNode != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k] == pNode)
        {
            m_pEntries[k] = NULL;
            pNode->DecrementThreadLockCount();
            return; // assume no more that one holder entry
        }
    }
}

void CRunningThreadTable::RemoveAll()
{
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k] != NULL)
        {
            m_pEntries[k]->AbandonThread(m_pComponentData);
            m_pEntries[k] = NULL;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////
// CExecContext

CExecContext::CExecContext()
{
   // REVIEWED-2002/03/08-JeffJon-Squatting isn't an issue here because this is not a
   // named event

   m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
    ASSERT(m_hEventHandle != NULL);
}

CExecContext::~CExecContext()
{
    ASSERT(m_hEventHandle != NULL);
    VERIFY(::CloseHandle(m_hEventHandle));
}

void CExecContext::Done()
{
    VERIFY(0 != ::SetEvent(m_hEventHandle));
}

void CExecContext::Wait()
{
    ASSERT(m_hEventHandle != NULL);
    VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE));
}
    
////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkEvent

CNotificationSinkEvent::CNotificationSinkEvent()
{
   // REVIEWED-2002/03/08-JeffJon-Squatting isn't an issue here because this is not a
   // named event

   m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
    ASSERT(m_hEventHandle != NULL);
}

CNotificationSinkEvent::~CNotificationSinkEvent()
{
    ASSERT(m_hEventHandle != NULL);
    VERIFY(::CloseHandle(m_hEventHandle));
}

void CNotificationSinkEvent::OnNotify(DWORD, WPARAM, LPARAM)
{
    TRACE(_T("CNotificationSinkEvent::OnNotify()\n"));
    VERIFY(0 != ::SetEvent(m_hEventHandle));
}

void CNotificationSinkEvent::Wait()
{
    TRACE(_T("CNotificationSinkEvent::Wait()\n"));
    ASSERT(m_hEventHandle != NULL);
    VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE));
}


////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkTable

#define NOTIFICATION_SINK_ARRAY_DEF_SIZE (4)

CNotificationSinkTable::CNotificationSinkTable()
{
    ExceptionPropagatingInitializeCriticalSection(&m_cs);

   size_t arraySizeInBytes = sizeof(CNotificationSinkBase*) * NOTIFICATION_SINK_ARRAY_DEF_SIZE;
    m_pEntries = (CNotificationSinkBase**)malloc(arraySizeInBytes);

  if (m_pEntries != NULL)
  {
     // This is an acceptable usage
      memset(m_pEntries,NULL, arraySizeInBytes);
  }
    m_nSize = NOTIFICATION_SINK_ARRAY_DEF_SIZE;

}

CNotificationSinkTable::~CNotificationSinkTable()
{
    free(m_pEntries);
    ::DeleteCriticalSection(&m_cs);
}
    
void CNotificationSinkTable::Advise(CNotificationSinkBase* p)
{
    Lock();
    ASSERT(p != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k] == NULL) // get the first empty spot
        {
            m_pEntries[k] = p;
            Unlock();
            return;
        }
    }
    // all full, need to grow the array
    int nAlloc = m_nSize*2;
   CNotificationSinkBase** temp = (CNotificationSinkBase**)realloc(m_pEntries, sizeof(CNotificationSinkBase*)*nAlloc);
   if (temp)
   {
      m_pEntries = temp;

      // This is an acceptable usage
       memset(&m_pEntries[m_nSize], NULL, sizeof(CNotificationSinkBase*)*m_nSize);
       m_pEntries[m_nSize] = p;
       m_nSize = nAlloc;
   }
    Unlock();
}

void CNotificationSinkTable::Unadvise(CNotificationSinkBase* p)
{
    Lock();
    ASSERT(p != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k] == p)
        {
            m_pEntries[k] = NULL;
            Unlock();
            return; // assume no more that one holder entry
        }
    }
    Unlock();
}

void CNotificationSinkTable::Notify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2)
{
    Lock();
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k] != NULL)
        {
            m_pEntries[k]->OnNotify(dwEvent, dwArg1, dwArg2);
        }
    }
    Unlock();
}



///////////////////////////////////////////////////////////////////////////////
// CWatermarkInfoState (private class)

class CWatermarkInfoState
{
public:
  CWatermarkInfoState()
  {
    m_pWatermarkInfo = NULL;
    m_hBanner = m_hWatermark = NULL;
  }

  ~CWatermarkInfoState()
  {
    DeleteBitmaps();
    if (m_pWatermarkInfo != NULL)
    {
      delete m_pWatermarkInfo;
    }
  }
  void DeleteBitmaps()
  {
    if (m_hBanner != NULL)
    {
      ::DeleteObject(m_hBanner);
      m_hBanner = NULL;
    }
    if (m_hWatermark != NULL)
    {
      ::DeleteObject(m_hWatermark);
      m_hWatermark = NULL;
    }
  }
  void LoadBitmaps()
  {
    ASSERT(m_pWatermarkInfo != NULL);
    if (m_hBanner == NULL)
    {
      m_hBanner = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_pWatermarkInfo->m_nIDBanner));
    }
    if (m_hWatermark == NULL)
    {
      m_hWatermark = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_pWatermarkInfo->m_nIDWatermark));
    }
  }

  CWatermarkInfo* m_pWatermarkInfo;
  HBITMAP m_hBanner;
  HBITMAP m_hWatermark;
};

///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject implementation: helpers

#ifdef _DEBUG_REFCOUNT
unsigned int CComponentDataObject::m_nOustandingObjects = 0;
#endif // _DEBUG_REFCOUNT

CComponentDataObject::CComponentDataObject() :
          m_hiddenWnd((CComponentDataObject*)this), // initialize backpointer
      m_pTimerThreadObj(NULL),
          m_PPHTable(this), m_RTTable(this),
          m_pConsole(NULL), m_pConsoleNameSpace(NULL), m_pRootData(NULL), m_hWnd(NULL),
          m_nTimerThreadID(0x0), m_bTimerThreadStarted(FALSE), m_dwTimerInterval(1),
          m_dwTimerTime(0), m_pWatermarkInfoState(NULL), m_bExtensionSnapin(FALSE)
{
    ExceptionPropagatingInitializeCriticalSection(&m_cs);
#ifdef _DEBUG_REFCOUNT
    dbg_cRef = 0;
    ++m_nOustandingObjects;
    TRACE(_T("CComponentDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT

}

CComponentDataObject::~CComponentDataObject()
{
    ::DeleteCriticalSection(&m_cs);
#ifdef _DEBUG_REFCOUNT
    --m_nOustandingObjects;
    TRACE(_T("~CComponentDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT

    ASSERT(m_pConsole == NULL);
    ASSERT(m_pConsoleNameSpace == NULL);
    ASSERT(m_pRootData == NULL);
}

HRESULT CComponentDataObject::FinalConstruct()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!m_hiddenWnd.Create())
    {
        TRACE(_T("Failed to create hidden window\n"));
        return E_FAIL;
    }

    m_hWnd = m_hiddenWnd.m_hWnd;
    m_pRootData = OnCreateRootData();
    ASSERT(m_pRootData != NULL);

    return S_OK;
}

void CComponentDataObject::FinalRelease()
{
    if (m_hiddenWnd.m_hWnd != NULL)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        VERIFY(m_hiddenWnd.DestroyWindow());
    }
    // delete data
    if(m_pRootData != NULL)
    {
        delete m_pRootData;
        m_pRootData = NULL;
    }

    if (m_pWatermarkInfoState != NULL)
  {
        delete m_pWatermarkInfoState;
  }

    m_ColList.RemoveAndDeleteAllColumnSets();

#if defined(_USE_MTFRMWK_LOGGING)
  if (log_instance != NULL)
  {
    log_instance->KillInstance();
  }
#endif
}


///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IComponentData members


STDMETHODIMP CComponentDataObject::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(m_pRootData != NULL);
  ASSERT(pUnknown != NULL);
  HRESULT hr = E_FAIL;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pConsole == NULL);
  ASSERT(m_pConsoleNameSpace == NULL);

    // get the pointers we need to hold on to
  hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, reinterpret_cast<void**>(&m_pConsoleNameSpace));
    ASSERT(hr == S_OK);
    ASSERT(m_pConsoleNameSpace != NULL);
  hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
  ASSERT(hr == S_OK);
    ASSERT(m_pConsole != NULL);

  // add the images for the scope tree
  LPIMAGELIST lpScopeImage;

  hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
  ASSERT(hr == S_OK);

    // Set the images
    hr = OnSetImages(lpScopeImage); // Load the bitmaps from the dll
    ASSERT(hr == S_OK);

  lpScopeImage->Release();

    OnInitialize();

    return S_OK;
}

STDMETHODIMP CComponentDataObject::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  ASSERT(m_pConsoleNameSpace != NULL);
  HRESULT hr = S_OK;

  // Since it's my folder it has an internal format.
  // Design Note: for extension.  I can use the fact, that the data object doesn't have
  // my internal format and I should look at the node type and see how to extend it.

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (event == MMCN_PROPERTY_CHANGE)
  {
      ASSERT(lpDataObject == NULL);
    hr = OnPropertyChange(param, static_cast<long>(arg));
  }
  else
  {
    CInternalFormatCracker ifc;
    ifc.Extract(lpDataObject);

    if (ifc.GetCookieCount() == 0)
    {
            if ((event == MMCN_EXPAND) && (arg == TRUE) && IsExtensionSnapin())
            {
                return OnExtensionExpand(lpDataObject, param);
                // this is a namespace extension, need to add
                // the root of the snapin
                CContainerNode* pContNode = GetRootData();
                HSCOPEITEM pParent = param;
                pContNode->SetScopeID(pParent);
                pContNode->MarkExpanded();
                return AddContainerNode(pContNode, pParent);

            }
      else if ((event == MMCN_REMOVE_CHILDREN) && IsExtensionSnapin())
      {
        hr = OnRemoveChildren(lpDataObject, arg);
      }

      return S_OK; // Extensions not supported
    }

    switch(event)
    {
          case MMCN_PASTE:
              break;

      case MMCN_DELETE:
        hr = OnDeleteVerbHandler(ifc, NULL);
        break;

      case MMCN_REFRESH:
        hr = OnRefreshVerbHandler(ifc);
        break;

      case MMCN_RENAME:
        hr = OnRename(ifc, arg, param);
        break;

      case MMCN_EXPAND:
        hr = OnExpand(ifc, arg, param);
        break;

      case MMCN_EXPANDSYNC:
        hr = OnExpand(ifc, arg, param, FALSE);
        break;

      case MMCN_BTN_CLICK:
        break;

      case MMCN_SELECT:
        hr = OnSelect(ifc, arg, param);
        break;

      default:
        break;
    } // switch
  } // if

  return hr;
}

STDMETHODIMP CComponentDataObject::Destroy()
{
    InternalAddRef();
    TRACE(_T("CComponentDataObject::Destroy()\n"));
    
    OnDestroy();
  SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pConsole);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    VERIFY(m_hiddenWnd.DestroyWindow());    
    InternalRelease();
    return S_OK;
}

BOOL CComponentDataObject::PostExecMessage(CExecContext* pExec, LPARAM arg)
{
    ASSERT(pExec != NULL);
    ASSERT(::IsWindow(m_hWnd));
    return ::PostMessage(m_hWnd, CHiddenWnd::s_ExecCommandMessage,
                            (WPARAM)pExec, (LPARAM)arg);
}

BOOL CComponentDataObject::PostForceEnumeration(CMTContainerNode* pContainerNode)
{
    ASSERT(::IsWindow(m_hWnd));
    return ::PostMessage(m_hWnd, CHiddenWnd::s_ForceEnumerationMessage,
                            (WPARAM)pContainerNode, (LPARAM)0);
}

BOOL CComponentDataObject::OnCreateSheet(CPropertyPageHolderBase* pPPHolder, HWND hWnd)
{
    ASSERT(pPPHolder != NULL);
    ASSERT(::IsWindow(hWnd));
    ASSERT(::IsWindow(m_hWnd));
    TRACE(_T("\nCComponentDataObject::OnCreateSheet()\n"));
    return ::PostMessage(m_hWnd, CHiddenWnd::s_NodePropertySheetCreateMessage,
                            (WPARAM)pPPHolder, (LPARAM)hWnd);
}



BOOL CComponentDataObject::OnDeleteSheet(CPropertyPageHolderBase* pPPHolder, CTreeNode* pNode)
{
    ASSERT(pPPHolder != NULL);
    ASSERT(pNode != NULL);
    ASSERT(::IsWindow(m_hWnd));
    TRACE(_T("\nCComponentDataObject::OnDeleteSheet()\n"));
    return ::PostMessage(m_hWnd, CHiddenWnd::s_NodePropertySheetDeleteMessage,
                            (WPARAM)pPPHolder, (LPARAM)pNode);
}

void CComponentDataObject::OnInitialize()
{
    VERIFY(StartTimerThread());
}

void CComponentDataObject::OnDestroy()
{
    // stop timer and worker thread
    ShutDownTimerThread();
    // detach all the threads that might be still running
    GetRunningThreadTable()->RemoveAll();
    // tell all the open property sheets to shut down

    // shut down property sheets, if any
    GetPropertyPageHolderTable()->WaitForAllToShutDown();
}

STDMETHODIMP CComponentDataObject::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
  ASSERT(ppDataObject != NULL);

  CComObject<CDataObject>* pObject;

  CComObject<CDataObject>::CreateInstance(&pObject);
  ASSERT(pObject != NULL);

  if (!pObject)
  {
    // NTRAID#NTBUG9-657641-2002/07/11-sburns
    
    return E_FAIL;
  }
  
  // Save cookie and type for delayed rendering
  pObject->SetType(type);

  CTreeNode* pNode = 0;

  //
  // -1 is an uninitialized data object, just ignore
  //
  if (cookie != -1)
  {
    if (cookie == NULL)
    {
      pNode = GetRootData();
    }
    else
    {
      pNode = reinterpret_cast<CTreeNode*>(cookie);
    }
    ASSERT(pNode != NULL);
    pObject->AddCookie(pNode);
  }

  // save a pointer to "this"
  IUnknown* pUnkComponentData = GetUnknown(); // no addref
  ASSERT(pUnkComponentData != NULL);

  pObject->SetComponentData(pUnkComponentData); // will addref it

  return  pObject->QueryInterface(IID_IDataObject,
                  reinterpret_cast<void**>(ppDataObject));
}


STDMETHODIMP CComponentDataObject::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
  CTreeNode* pNode = reinterpret_cast<CTreeNode*>(pScopeDataItem->lParam);
    ASSERT(pNode != NULL);
    ASSERT(pNode->IsContainer());

    ASSERT(pScopeDataItem->mask & SDI_STR);
  pScopeDataItem->displayname = const_cast<LPWSTR>(pNode->GetDisplayName());

  ASSERT(pScopeDataItem->displayname != NULL);
  return S_OK;
}

STDMETHODIMP CComponentDataObject::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    ASSERT(lpDataObjectA != NULL);
    ASSERT(lpDataObjectB != NULL);

  CInternalFormatCracker ifcA, ifcB;
  VERIFY(SUCCEEDED(ifcA.Extract(lpDataObjectA)));
  VERIFY(SUCCEEDED(ifcB.Extract(lpDataObjectB)));

    CTreeNode* pNodeA = ifcA.GetCookieAt(0);
    CTreeNode* pNodeB = ifcB.GetCookieAt(0);

    ASSERT(pNodeA != NULL);
    ASSERT(pNodeB != NULL);

    if ( (pNodeA == NULL) || (pNodeB == NULL) )
  {
        return E_FAIL;
  }

    return (pNodeA == pNodeB) ? S_OK : S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Message handlers for CComponentDataObject::IComponentData::Notify()

HRESULT CComponentDataObject::OnAdd(CTreeNode*, LPARAM, LPARAM)
{
  return E_UNEXPECTED;
}

HRESULT CComponentDataObject::OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM)
{
  CInternalFormatCracker ifc;
  HRESULT hr = S_OK;
  hr = ifc.Extract(lpDataObject);
  if (SUCCEEDED(hr))
  {
    if (ifc.GetCookieCount() == 1)
    {
      CTreeNode* pNode = ifc.GetCookieAt(0);
      if (pNode != NULL)
      {
        if (pNode->IsContainer())
        {
          CContainerNode* pContainerNode = dynamic_cast<CContainerNode*>(pNode);
          if (pContainerNode != NULL)
          {
            pContainerNode->RemoveAllChildrenFromList();
          }
        }
      }
    }
    else
    {
      ASSERT(FALSE);
    }
  }
    return hr;
}


HRESULT CComponentDataObject::OnRename(CInternalFormatCracker& ifc, LPARAM, LPARAM param)
{
  HRESULT hr = S_FALSE;

  CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);
  hr = pNode->OnRename(this, (LPOLESTR)param);
  if (hr == S_OK)
  {
    UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNode), CHANGE_RESULT_ITEM);
  }
  return hr;
}

HRESULT CComponentDataObject::OnExpand(CInternalFormatCracker& ifc, 
                                       LPARAM arg, 
                                       LPARAM param,
                                       BOOL bAsync)
{
  if (arg == TRUE)
  {
    // Did Initialize get called?
    ASSERT(m_pConsoleNameSpace != NULL);

    //
    // I shouldn't have to deal with multiple select here...
    //
    ASSERT(ifc.GetCookieCount() == 1);
    CTreeNode* pNode = ifc.GetCookieAt(0);
    if (pNode == NULL)
    {
      ASSERT(pNode != NULL);
      return S_FALSE;
    }

    EnumerateScopePane(pNode, param, bAsync);
  }
  else if (!bAsync)
  {
    ASSERT(m_pConsoleNameSpace != NULL);

    //
    // I shouldn't have to deal with multiple select here...
    //
    ASSERT(ifc.GetCookieCount() == 1);
    CTreeNode* pNode = ifc.GetCookieAt(0);
    ASSERT(pNode != NULL);

    if (pNode && pNode->CanExpandSync())
    {
      MMC_EXPANDSYNC_STRUCT* pExpandStruct = reinterpret_cast<MMC_EXPANDSYNC_STRUCT*>(param);
      if (pExpandStruct && pExpandStruct->bExpanding)
      {
        EnumerateScopePane(pNode, pExpandStruct->hItem, bAsync);
        pExpandStruct->bHandled = TRUE;
      }
    }
    else
    {
      return S_FALSE;
    }
  }

  return S_OK;
}



HRESULT CComponentDataObject::OnSelect(CInternalFormatCracker&, LPARAM, LPARAM)
{
  return E_UNEXPECTED;
}

HRESULT CComponentDataObject::OnContextMenu(CTreeNode*, LPARAM, LPARAM)
{
  return S_OK;
}

HRESULT CComponentDataObject::OnPropertyChange(LPARAM param, long fScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    TRACE(_T("CComponentDataObject::OnPropertyChange()\n"));
    ASSERT(param != NULL);
    CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(param);
    ASSERT(pPPHolder != NULL);
    CTreeNode* pNode = pPPHolder->GetTreeNode();
    ASSERT(pNode != NULL);

    // allow both types in the result pane, but only scope items in the scope pane
    ASSERT(!fScopePane || (fScopePane && pNode->IsContainer()) );

    long changeMask = CHANGE_RESULT_ITEM; // default, the holder can change it
    BOOL bUpdate = pPPHolder->OnPropertyChange(fScopePane, &changeMask);
    // fire event to let the property page thread proceed
    pPPHolder->AcknowledgeNotify();

    if (bUpdate)
  {
        pNode->OnPropertyChange(this, fScopePane, changeMask);
  }
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IExtendPropertySheet2 memebers

STDMETHODIMP CComponentDataObject::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(lpIDataObject);
    if (FAILED(hr))
  {
        return hr;
  }
    
  //
    // this was an object created by the modal wizard, do nothing
  //
    if (ifc.GetCookieType() == CCT_UNINITIALIZED)
    {
        return hr;
    }

    if (ifc.GetCookieType() == CCT_SNAPIN_MANAGER)
  {
        return SnapinManagerCreatePropertyPages(lpProvider,handle);
  }

    CTreeNode* pNode = ifc.GetCookieAt(0);

  if (!pNode)
  {
    // NTRAID#NTBUG9-657822-2002/07/11-sburns
   
    return S_FALSE;
  }
    
  ASSERT(ifc.GetCookieType() == CCT_SCOPE || ifc.GetCookieType() == CCT_RESULT);

  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1)   // multiple selection
  {
    //
    // Delegate to the container
    //
    ASSERT(pNode->GetContainer() != NULL);
    hr = pNode->GetContainer()->CreatePropertyPages(lpProvider, handle, &nodeList);
  }
  else if (nodeList.GetCount() == 1)  // single selection
  {
    //
      // Delegate to the node
    //
      ASSERT(pNode != NULL);
      hr = pNode->CreatePropertyPages(lpProvider, handle, &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }

  if (FAILED(hr))
  {
     // MMC is expecting S_FALSE if no pages were added

     hr = S_FALSE;
  }

  return hr;
}

STDMETHODIMP CComponentDataObject::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CTreeNode* pNode;
    DATA_OBJECT_TYPES type;

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(lpDataObject);
    if (FAILED(hr))
  {
        return hr;
  }

  type = ifc.GetCookieType();
  pNode = ifc.GetCookieAt(0);

  //
  // Retrieve node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  //
    // this was an object created by the modal wizard, do nothing
  //
    if (type == CCT_UNINITIALIZED)
    {
        return hr;
    }

    if (type == CCT_SNAPIN_MANAGER)
  {
        return HasPropertyPages(type) ? S_OK : S_FALSE;
  }

  //
    // we have a node, so delegate to it
  //
    ASSERT(pNode != NULL);
  BOOL bDummy;

  if (nodeList.GetCount() == 1) // single selection
  {
      ASSERT((type == CCT_SCOPE) || (type == CCT_RESULT));
 
    if (pNode->GetSheetCount() > 0)
    {
      pNode->ShowPageForNode(this);
      return S_FALSE;
    }
    else if (pNode->DelegatesPPToContainer() && pNode->GetContainer()->GetSheetCount() > 0)
    {
      //
      // Find the page and bring it to foreground
      //
      pNode->ShowPageForNode(this);
      return S_FALSE;
    }
    if (pNode->HasPropertyPages(type, &bDummy, &nodeList))
    {
      hr = S_OK;
    }
    else
    {
      hr = S_FALSE;
    }
  }
  else if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);
    if (pNode->GetContainer()->HasPropertyPages(type, &bDummy, &nodeList))
    {
      hr = S_OK;
    }
    else
    {
      hr = S_FALSE;
    }
  }
  return hr;
}

HRESULT CComponentDataObject::CreatePropertySheet(CTreeNode* pNode, 
                                                  HWND hWndParent, 
                                                  LPCWSTR lpszTitle)
{
  HRESULT hr = S_OK;
  
  HWND hWnd = hWndParent;
  if (hWnd == NULL)
  {
    hr = m_pConsole->GetMainWindow(&hWnd);
    if (FAILED(hr))
    {
      ASSERT(FALSE);
      return hr;
    }
  }

    //
  // get an interface to a sheet provider
  //
    CComPtr<IPropertySheetProvider> spSheetProvider;
    hr = m_pConsole->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
    ASSERT(SUCCEEDED(hr));
    ASSERT(spSheetProvider != NULL);

  //
    // get an interface to a sheet callback
  //
    CComPtr<IPropertySheetCallback> spSheetCallback;
    hr = m_pConsole->QueryInterface(IID_IPropertySheetCallback,(void**)&spSheetCallback);
    ASSERT(SUCCEEDED(hr));
    ASSERT(spSheetCallback != NULL);


  //
    // get a sheet
  //
  MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pNode);
  DATA_OBJECT_TYPES type = (pNode->IsContainer()) ? CCT_SCOPE : CCT_RESULT;

  CComPtr<IDataObject> spDataObject;
  hr = QueryDataObject(cookie, type, &spDataObject);
  ASSERT(SUCCEEDED(hr));
  ASSERT(spDataObject != NULL);

    hr = spSheetProvider->CreatePropertySheet(lpszTitle, TRUE, cookie, 
                                            spDataObject, 0x0 /*dwOptions*/);
    ASSERT(SUCCEEDED(hr));

    hr = spSheetProvider->AddPrimaryPages(GetUnknown(),
                                                              TRUE /*bCreateHandle*/,
                                                              hWnd,
                                                              pNode->IsContainer() /* bScopePane*/);

  hr = spSheetProvider->AddExtensionPages();

    ASSERT(SUCCEEDED(hr));

    hr = spSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

CWatermarkInfo* CComponentDataObject::SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo)
{
  if (m_pWatermarkInfoState == NULL)
  {
    m_pWatermarkInfoState = new CWatermarkInfoState;
  }

  CWatermarkInfo* pOldWatermarkInfo = m_pWatermarkInfoState->m_pWatermarkInfo;
    m_pWatermarkInfoState->m_pWatermarkInfo = pWatermarkInfo;

  // we changed info, so dump the old bitmap handles
  m_pWatermarkInfoState->DeleteBitmaps();

    return pOldWatermarkInfo;
}

STDMETHODIMP CComponentDataObject::GetWatermarks(LPDATAOBJECT,
                                                                   HBITMAP* lphWatermark,
                                                                       HBITMAP* lphHeader,
                                                                         HPALETTE* lphPalette,
                                                                         BOOL* pbStretch)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

    *lphHeader = NULL;
    *lphWatermark = NULL;
    *lphPalette = NULL;
    *pbStretch = TRUE;

    if ((m_pWatermarkInfoState == NULL) || (m_pWatermarkInfoState->m_pWatermarkInfo == NULL))
  {
        return E_FAIL;
  }

  *pbStretch = m_pWatermarkInfoState->m_pWatermarkInfo->m_bStretch;
    *lphPalette = m_pWatermarkInfoState->m_pWatermarkInfo->m_hPalette;

  // load bitmaps if not loaded yet
  m_pWatermarkInfoState->LoadBitmaps();

  *lphHeader = m_pWatermarkInfoState->m_hBanner;
    if (*lphHeader == NULL)
  {
        return E_FAIL;
  }

  *lphWatermark = m_pWatermarkInfoState->m_hWatermark;
    if (*lphWatermark == NULL)
  {
        return E_FAIL;
  }

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IExtendContextMenu memebers

STDMETHODIMP CComponentDataObject::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT hr = S_OK;
    CTreeNode* pNode;
    DATA_OBJECT_TYPES type;

  CInternalFormatCracker ifc;
  hr = ifc.Extract(pDataObject);
  if (FAILED(hr))
  {
        return hr;
  }

  type = ifc.GetCookieType();

  pNode = ifc.GetCookieAt(0);
    ASSERT(pNode != NULL);
  if (pNode == NULL)
  {
    return hr;
  }

  CComPtr<IContextMenuCallback2> spContextMenuCallback2;
  hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (PVOID*)&spContextMenuCallback2);
  if (FAILED(hr))
  {
    return hr;
  }

  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);
    hr = pNode->GetContainer()->OnAddMenuItems(spContextMenuCallback2, 
                                               type, 
                                               pInsertionAllowed,
                                               &nodeList);
  }
  else if (nodeList.GetCount() == 1) // single selection
  {
      hr = pNode->OnAddMenuItems(spContextMenuCallback2, 
                               type, 
                               pInsertionAllowed,
                               &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
  return hr;
}

STDMETHODIMP CComponentDataObject::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(pDataObject);
  if (FAILED(hr))
  {
        return hr;
  }

    CTreeNode* pNode = ifc.GetCookieAt(0);
    ASSERT(pNode != NULL);
  
  //
  // Retrieve node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1)  // multiple selection
  {
    //
    // Delegate the command to the container
    //
    ASSERT(pNode->GetContainer() != NULL);

    hr = pNode->GetContainer()->OnCommand(nCommandID, 
                                          ifc.GetCookieType(),
                                          this,
                                          &nodeList);
  }
  else if (nodeList.GetCount() == 1)  // single selection
  {
    //
    // Let the node take care of it
    //
    hr = pNode->OnCommand(nCommandID,
                          ifc.GetCookieType(), 
                          this,
                          &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IPersistStream members

STDMETHODIMP CComponentDataObject::IsDirty()
{
    // forward to the root of the tree
    CRootData* pRootData = GetRootData();
    ASSERT(pRootData != NULL);
    return pRootData->IsDirty();
}

STDMETHODIMP CComponentDataObject::Load(IStream __RPC_FAR *pStm)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // forward to the root of the tree
    CRootData* pRootData = GetRootData();
    ASSERT(pRootData != NULL);
    return pRootData->Load(pStm);
}

STDMETHODIMP CComponentDataObject::Save(IStream __RPC_FAR *pStm, BOOL fClearDirty)
{
    // forward to the root of the tree
    CRootData* pRootData = GetRootData();
    ASSERT(pRootData != NULL);
    return pRootData->Save(pStm,fClearDirty);
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::ISnapinHelp2 memebers


//
// Helper function for appending a help file name to the system directory.
// 
// If returns S_OK, then helpFilePath will contain the full filename to the
// help file (including helpFileName).
//
HRESULT GetFullHelpFilePath(const CString& helpFileName, CString& helpFilePath)
{
    UINT nLen;
    helpFilePath.Empty();

    // Determine how long the path to the system directory is.
    // (does not include null)
    nLen = ::GetSystemWindowsDirectory(NULL, 0);
    if (nLen == 0)
    {
        ASSERT(false);  // This should never happen.
        return E_FAIL;
    }

    // Get a buffer big enough for system directory path, including null.
    // We intentionally make it extra large in the hopes that later
    // appending the name of the help file won't require allocating a larger
    // buffer and performing a copy.
    nLen = nLen < MAX_PATH ? MAX_PATH : nLen;
    nLen = (2 * nLen) + 1;

    LPWSTR lpszBuffer = helpFilePath.GetBuffer(nLen);

    // Copy system directory path to our buffer (with null).
    nLen = ::GetSystemWindowsDirectory(lpszBuffer, nLen);
    if (nLen == 0)
    {
        return E_FAIL;
    }

    // Normally the system directory path does not end in a '\'.  However,
    // if the system is installed directly to the root of a drive (e.g. C:\)
    // then the returned path does end with a '\'.  We need to check for this and
    // remove the '\' if it is there.
    WCHAR slash[] = L"\\";
    if (lpszBuffer[nLen - 1] == slash[0])
    {
        lpszBuffer[nLen - 1] = NULL;
    }

    // Release hold on buffer so string class can manage length and memory.
    helpFilePath.ReleaseBuffer();
    lpszBuffer = NULL;

    // Append help file name to path.
    helpFilePath += helpFileName;
    
    return S_OK;
}


STDMETHODIMP CComponentDataObject::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
  {
    return E_INVALIDARG;
  }

  LPCWSTR lpszHelpFileName = GetHTMLHelpFileName();
  if (lpszHelpFileName == NULL)
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

    //
    // Get the full path to the help file by concatenating the help file name
    // with the system directory.
    //
    CString szHelpFilePath;
    HRESULT hr;

    hr = GetFullHelpFilePath(lpszHelpFileName, szHelpFilePath);
    if (FAILED(hr))
    {
        ASSERT(false);  // Should never happen.
        return hr;
    }


  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }
  else
  {
    return E_OUTOFMEMORY;
  }

  return S_OK;
}

HRESULT CComponentDataObject::GetLinkedTopics(LPOLESTR*)
{
  return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject Helpers

HRESULT CComponentDataObject::UpdateAllViewsHelper(LPARAM data, LONG_PTR hint)
{
    ASSERT(m_pConsole != NULL);

  CComObject<CDummyDataObject>* pObject;
  CComObject<CDummyDataObject>::CreateInstance(&pObject);
  ASSERT(pObject != NULL);

    IDataObject* pDataObject;
  HRESULT hr = pObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(&pDataObject));
    ASSERT(SUCCEEDED(hr));
    ASSERT(pDataObject != NULL);

    hr = m_pConsole->UpdateAllViews(pDataObject,data, hint);
    pDataObject->Release();
    return hr;
}


void CComponentDataObject::HandleStandardVerbsHelper(CComponentObject* pComponentObj,
                                    LPCONSOLEVERB pConsoleVerb,
                                    BOOL bScope, BOOL bSelect,
                                    LPDATAOBJECT lpDataObject)
{
  // You should crack the data object and enable/disable/hide standard
  // commands appropriately.  The standard commands are reset everytime you get
  // called. So you must reset them back.

    ASSERT(pConsoleVerb != NULL);
    ASSERT(pComponentObj != NULL);
    ASSERT(lpDataObject != NULL);

    // reset the selection
    pComponentObj->SetSelectedNode(NULL, CCT_UNINITIALIZED);

  CInternalFormatCracker ifc;
  VERIFY(SUCCEEDED(ifc.Extract(lpDataObject)));

    CTreeNode* pNode = ifc.GetCookieAt(0);
    if (pNode == NULL)
  {
        return;
  }

  //
  // Retrieve node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    //
    // Delegate to the container
    //
    ASSERT(pNode->GetContainer() != NULL);

    pNode->GetContainer()->OnSetVerbState(pConsoleVerb, ifc.GetCookieType(), &nodeList);
  }
  else if (nodeList.GetCount() == 1)   // single selection
  {
    //
      // set selection, if any
    //
      if (bSelect)
    {
          pComponentObj->SetSelectedNode(pNode, ifc.GetCookieType());
    }

      ASSERT((ifc.GetCookieType() == CCT_SCOPE) || (ifc.GetCookieType() == CCT_RESULT));
      TRACE(_T("HandleStandardVerbsHelper: Node <%s> bScope = %d bSelect = %d, type = %s\n"),
          pNode->GetDisplayName(), bScope, bSelect,
          (ifc.GetCookieType() == CCT_SCOPE) ? _T("CCT_SCOPE") : _T("CCT_RESULT"));

      pConsoleVerb->SetDefaultVerb(pNode->GetDefaultVerb(ifc.GetCookieType(), &nodeList));
      pNode->OnSetVerbState(pConsoleVerb, ifc.GetCookieType(), &nodeList);
  }
}



void CComponentDataObject::EnumerateScopePane(CTreeNode* cookie, 
                                              HSCOPEITEM pParent,
                                              BOOL bAsync)
{
  ASSERT(m_pConsoleNameSpace != NULL); // make sure we QI'ed for the interface

    // find the node corresponding to the cookie
    ASSERT(cookie != NULL);
    ASSERT(cookie->IsContainer());
    CContainerNode* pContNode = (CContainerNode*)cookie;
    pContNode->MarkExpanded();

    if (pContNode == GetRootData())
  {
        pContNode->SetScopeID(pParent);
  }

    // allow the node to enumerate its children, if not enumerated yet
    if (!pContNode->IsEnumerated())
    {
        BOOL bAddChildrenNow = pContNode->OnEnumerate(this, bAsync);
        pContNode->MarkEnumerated();
        if (!bAddChildrenNow)
    {
            return;
    }
    }

    // scan the list of children, looking for containers and add them
    ASSERT(pParent != NULL);
    CNodeList* pChildList = pContNode->GetContainerChildList();
    ASSERT(pChildList != NULL);

    POSITION pos;
    for( pos = pChildList->GetHeadPosition(); pos != NULL; )
    {
        CContainerNode* pCurrChildNode = (CContainerNode*)pChildList->GetNext(pos);
        ASSERT(pCurrChildNode != NULL);
        if (pCurrChildNode->IsVisible())
        {
            AddContainerNode(pCurrChildNode, pParent);
        }
    }
}

HRESULT CComponentDataObject::OnDeleteVerbHandler(CInternalFormatCracker& ifc, CComponentObject*)
{
  HRESULT hr = S_OK;
    CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  //
  // Retrieve the cookie list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);
    pNode->GetContainer()->OnDelete(this, &nodeList);
  }
  else if (nodeList.GetCount() == 1) // single selection
  {
    pNode->OnDelete(this, &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
    return hr;
}

HRESULT CComponentDataObject::OnRefreshVerbHandler(CInternalFormatCracker& ifc)
{
  HRESULT hr = S_OK;
    CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  //
  // Retrieve the node list and the count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);

    pNode->GetContainer()->OnRefresh(this, &nodeList);
  }
  else if (nodeList.GetCount() == 1) // single selection
  {
    pNode->OnRefresh(this, &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
    return hr;
}

HRESULT CComponentDataObject::OnHelpHandler(CInternalFormatCracker& ifc, CComponentObject* pComponentObject)
{
  //
    // responding to MMCN_CONTEXTHELP
  //
  ASSERT(pComponentObject != NULL);

  HRESULT hr = S_OK;
    CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  //
  // Retrieve the node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // Multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);

    OnNodeContextHelp(&nodeList);
  }
  else if (nodeList.GetCount() == 1)  // Single selection
  {
    OnNodeContextHelp(pNode);
  }
  else
  {
    hr = E_FAIL;
  }
    return hr;
}

BOOL CComponentDataObject::WinHelp(LPCTSTR lpszHelpFileName,    // file, no path
                                    UINT uCommand,  // type of Help
                                    DWORD dwData    // additional data
                                    )
{
    HWND hWnd;
    GetConsole()->GetMainWindow(&hWnd);

    //
    // Get the full path to the help file by concatenating the help file name
    // with the system directory.
    //
    CString szHelpFilePath;
    HRESULT hr;

    hr = GetFullHelpFilePath(lpszHelpFileName, szHelpFilePath);
    if (FAILED(hr))
    {
        ASSERT(false);  // Should never happen.
        return FALSE;
    }

    return ::WinHelp(hWnd, szHelpFilePath, uCommand, dwData);
}



HRESULT CComponentDataObject::AddNode(CTreeNode* pNodeToAdd)
{
    ASSERT(pNodeToAdd != NULL);
    // if the node is hidden, just ignore
    if (!pNodeToAdd->IsVisible())
        return S_OK;

    if (pNodeToAdd->IsContainer())
    {
        ASSERT(pNodeToAdd->GetContainer() != NULL);
        HSCOPEITEM pParentScopeItem = pNodeToAdd->GetContainer()->GetScopeID();
        ASSERT(pParentScopeItem != NULL);
        return AddContainerNode((CContainerNode*)pNodeToAdd, pParentScopeItem);
    }
    return AddLeafNode((CLeafNode*)pNodeToAdd);
}

HRESULT CComponentDataObject::AddNodeSorted(CTreeNode* pNodeToAdd)
{
    ASSERT(pNodeToAdd != NULL);
    // if the node is hidden, just ignore
    if (!pNodeToAdd->IsVisible())
  {
        return S_OK;
  }

    if (pNodeToAdd->IsContainer())
    {
        ASSERT(pNodeToAdd->GetContainer() != NULL);
        HSCOPEITEM pParentScopeItem = pNodeToAdd->GetContainer()->GetScopeID();
        ASSERT(pParentScopeItem != NULL);
        return AddContainerNodeSorted((CContainerNode*)pNodeToAdd, pParentScopeItem);
    }
    return AddLeafNode((CLeafNode*)pNodeToAdd);
}

HRESULT CComponentDataObject::DeleteNode(CTreeNode* pNodeToDelete)
{
    if (pNodeToDelete->IsContainer())
    {
        return DeleteContainerNode((CContainerNode*)pNodeToDelete);
    }
    return DeleteLeafNode((CLeafNode*)pNodeToDelete);
}

HRESULT CComponentDataObject::DeleteMultipleNodes(CNodeList* pNodeList)
{
  HRESULT hr = S_OK;

  POSITION pos = pNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CTreeNode* pNode = pNodeList->GetNext(pos);
    if (pNode->IsContainer())
    {
      DeleteContainerNode((CContainerNode*)pNode);
    }
  }
  hr = UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeList), DELETE_MULTIPLE_RESULT_ITEMS);
  return hr;
}

HRESULT CComponentDataObject::ChangeNode(CTreeNode* pNodeToChange, long changeMask)
{
    if (!pNodeToChange->IsVisible())
  {
        return S_OK;    
  }

    if (pNodeToChange->IsContainer())
    {
        CContainerNode* pContNode = (CContainerNode*)pNodeToChange;
        //if (!pContNode->IsExpanded())
        //  return S_OK;
        return ChangeContainerNode(pContNode, changeMask);
    }
    return ChangeLeafNode((CLeafNode*)pNodeToChange, changeMask);
}

HRESULT CComponentDataObject::RemoveAllChildren(CContainerNode* pNode)
{
    // if the node is hidden or not expanded yet, just ignore
    if (!pNode->IsVisible() || !pNode->IsExpanded())
  {
        return S_OK;
  }

    ASSERT(pNode != NULL);
    HSCOPEITEM nID = pNode->GetScopeID();
    ASSERT(nID != 0);

    // remove the container itself
    HRESULT hr = m_pConsoleNameSpace->DeleteItem(nID, /*fDeleteThis*/ FALSE);
    ASSERT(SUCCEEDED(hr));
    DeleteAllResultPaneItems(pNode);
    // remove the result items from all the views (will do only if container selected)
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT CComponentDataObject::RepaintSelectedFolderInResultPane()
{
    return UpdateAllViewsHelper((long)NULL, REPAINT_RESULT_PANE);
}


HRESULT CComponentDataObject::RepaintResultPane(CContainerNode* pNode)
{
    ASSERT(pNode != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNode), REPAINT_RESULT_PANE);
}

HRESULT CComponentDataObject::DeleteAllResultPaneItems(CContainerNode* pNode)
{
    ASSERT(pNode != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNode), DELETE_ALL_RESULT_ITEMS);
}


HRESULT CComponentDataObject::AddContainerNode(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem)
{
    ASSERT(pNodeToInsert != NULL);

    if ((pNodeToInsert != GetRootData()) && (!pNodeToInsert->GetContainer()->IsExpanded()))
  {
        return S_OK;
  }

    //ASSERT(pNodeToInsert->GetScopeID() == 0);

    SCOPEDATAITEM scopeDataItem;
    InitializeScopeDataItem(&scopeDataItem,
                            pParentScopeItem,
                            reinterpret_cast<LPARAM>(pNodeToInsert), // lParam, use the node pointer as cookie
                            pNodeToInsert->GetImageIndex(FALSE), // close image
                            pNodeToInsert->GetImageIndex(TRUE),  // open image
                            pNodeToInsert->HasChildren());

    HRESULT hr = m_pConsoleNameSpace->InsertItem(&scopeDataItem);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
  {
        return hr;
  }

    // Note - On return, the ID member of 'scopeDataItem'
    // contains the handle to the newly inserted item, so we have to save
    ASSERT(scopeDataItem.ID != NULL);
    pNodeToInsert->SetScopeID(scopeDataItem.ID);
    return hr;
}

//
// Note : This should combined with the function above adding a third parameter that is a compare function,
//        which is NULL by default.  If it is NULL then we just skip the GetChildItem() and the while loop.
//
HRESULT CComponentDataObject::AddContainerNodeSorted(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem)
{
    ASSERT(pNodeToInsert != NULL);

    if ((pNodeToInsert != GetRootData()) && (!pNodeToInsert->GetContainer()->IsExpanded()))
  {
        return S_OK;
  }

    SCOPEDATAITEM scopeDataItem;
    InitializeScopeDataItem(&scopeDataItem,
                            pParentScopeItem,
                            reinterpret_cast<LPARAM>(pNodeToInsert), // lParam, use the node pointer as cookie
                            pNodeToInsert->GetImageIndex(FALSE), // close image
                            pNodeToInsert->GetImageIndex(TRUE),  // open image
                            pNodeToInsert->HasChildren());

  HSCOPEITEM pChildScopeItem;
  CTreeNode* pChildNode = NULL;

  // Enumerate through the scope node items and insert the new node in sorted order
  HRESULT hr = m_pConsoleNameSpace->GetChildItem(pParentScopeItem, &pChildScopeItem, (MMC_COOKIE*)&pChildNode);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
  {
    return hr;
  }

  while (pChildNode != NULL)
  {
    // REVIEW_JEFFJON : we should probably have a compare function as a parameter and use that here.
    // NOTICE-2002/04/22-artm  CTreeNode::GetDisplayName() will never return NULL, 
    // okay to use _wcsicoll() here.  Underlying implementation is CString object.
    if (_wcsicoll(pNodeToInsert->GetDisplayName(), pChildNode->GetDisplayName()) < 0)
    {
      // Insert the node before the node pointed to by pChildScopeItem
      scopeDataItem.relativeID = pChildScopeItem;
      scopeDataItem.mask |= SDI_NEXT;
      break;
    }
    pChildNode = NULL;
    hr = m_pConsoleNameSpace->GetNextItem(pChildScopeItem, &pChildScopeItem, (MMC_COOKIE*)&pChildNode);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
      return hr;
    }
  }
    hr = m_pConsoleNameSpace->InsertItem(&scopeDataItem);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
  {
        return hr;
  }

    // Note - On return, the ID member of 'scopeDataItem'
    // contains the handle to the newly inserted item, so we have to save
    ASSERT(scopeDataItem.ID != NULL);
    pNodeToInsert->SetScopeID(scopeDataItem.ID);
    return hr;
}

HRESULT CComponentDataObject::DeleteContainerNode(CContainerNode* pNodeToDelete)
{
    ASSERT(pNodeToDelete != NULL);
    ASSERT(pNodeToDelete->GetContainer() != NULL);
    HSCOPEITEM nID = pNodeToDelete->GetScopeID();
    ASSERT(nID != 0);
    HRESULT hr = m_pConsoleNameSpace->DeleteItem(nID, /*fDeleteThis*/ TRUE);
    pNodeToDelete->SetScopeID(0);
    return hr;
}


HRESULT CComponentDataObject::ChangeContainerNode(CContainerNode* pNodeToChange, long changeMask)
{
    ASSERT(pNodeToChange != NULL);
    ASSERT(changeMask & CHANGE_RESULT_ITEM);
    ASSERT(m_pConsoleNameSpace != NULL);

    if (!pNodeToChange->AddedToScopePane())
  {
        return S_OK;
  }

    SCOPEDATAITEM scopeDataItem;

   // This is an acceptable usage
    memset(&scopeDataItem, 0, sizeof(SCOPEDATAITEM));
    scopeDataItem.ID = pNodeToChange->GetScopeID();
    ASSERT(scopeDataItem.ID != 0);

    if (changeMask & CHANGE_RESULT_ITEM_DATA)
    {
        scopeDataItem.mask |= SDI_STR;
        scopeDataItem.displayname = MMC_CALLBACK;
    }
    if (changeMask & CHANGE_RESULT_ITEM_ICON)
    {
    scopeDataItem.mask |= SDI_IMAGE;
    scopeDataItem.nImage = pNodeToChange->GetImageIndex(FALSE);
    scopeDataItem.mask |= SDI_OPENIMAGE;
    scopeDataItem.nOpenImage = pNodeToChange->GetImageIndex(TRUE);
    }
    return m_pConsoleNameSpace->SetItem(&scopeDataItem);
}

HRESULT CComponentDataObject::AddLeafNode(CLeafNode* pNodeToAdd)
{
    // will have to broadcast to all views
    ASSERT(pNodeToAdd != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToAdd), ADD_RESULT_ITEM);
}

HRESULT CComponentDataObject::DeleteLeafNode(CLeafNode* pNodeToDelete)
{
    // will have to broadcast to all views
    ASSERT(pNodeToDelete != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToDelete), DELETE_RESULT_ITEM);
}

HRESULT CComponentDataObject::ChangeLeafNode(CLeafNode* pNodeToChange, long changeMask)
{
    // will have to broadcast to all views
    ASSERT(pNodeToChange != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToChange), changeMask);
}

HRESULT CComponentDataObject::UpdateVerbState(CTreeNode* pNodeToChange)
{
    // will have to broadcast to all views
    ASSERT(pNodeToChange != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToChange), UPDATE_VERB_STATE);
}

HRESULT CComponentDataObject::SetDescriptionBarText(CTreeNode* pTreeNode)
{
  ASSERT(pTreeNode != NULL);
  return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pTreeNode), UPDATE_DESCRIPTION_BAR);
}

HRESULT CComponentDataObject::SortResultPane(CContainerNode* pContainerNode)
{
    ASSERT(pContainerNode != NULL);
    return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pContainerNode), SORT_RESULT_PANE);
}

HRESULT CComponentDataObject::UpdateResultPaneView(CContainerNode* pContainerNode)
{
  ASSERT(pContainerNode != NULL);
  return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pContainerNode), UPDATE_RESULT_PANE_VIEW);
}

void CComponentDataObject::InitializeScopeDataItem(LPSCOPEDATAITEM pScopeDataItem,
                                        HSCOPEITEM pParentScopeItem, LPARAM lParam,
                                        int nImage, int nOpenImage, BOOL bHasChildren)
{
    ASSERT(pScopeDataItem != NULL);
    memset(pScopeDataItem, 0, sizeof(SCOPEDATAITEM));

    // set parent scope item
    pScopeDataItem->mask |= SDI_PARENT;
    pScopeDataItem->relativeID = pParentScopeItem;

    // Add node name, we implement callback
    pScopeDataItem->mask |= SDI_STR;
    pScopeDataItem->displayname = MMC_CALLBACK;

    // Add the lParam
    pScopeDataItem->mask |= SDI_PARAM;
    pScopeDataItem->lParam = lParam;
    
    // Add close image
    if (nImage != -1)
    {
        pScopeDataItem->mask |= SDI_IMAGE;
        pScopeDataItem->nImage = nImage;
    }
    // Add open image
    if (nOpenImage != -1)
    {
        pScopeDataItem->mask |= SDI_OPENIMAGE;
        pScopeDataItem->nOpenImage = nOpenImage;
    }
    // Add button to node if the folder has children
    if (bHasChildren == TRUE)
    {
        pScopeDataItem->mask |= SDI_CHILDREN;
        pScopeDataItem->cChildren = 1;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Timer and Background Thread

BOOL CComponentDataObject::StartTimerThread()
{
    ASSERT(::IsWindow(m_hWnd));
    m_pTimerThreadObj = OnCreateTimerThread();

    if (m_pTimerThreadObj == NULL)
  {
        return TRUE;
  }

    // start the the thread
    if (!m_pTimerThreadObj->Start(m_hWnd))
  {
        return FALSE;
  }

    ASSERT(m_pTimerThreadObj->m_nThreadID != 0);
    m_nTimerThreadID = m_pTimerThreadObj->m_nThreadID;

    WaitForTimerThreadStartAck();
    return SetTimer();
}

void CComponentDataObject::ShutDownTimerThread()
{
    KillTimer();
    PostMessageToTimerThread(WM_QUIT, 0,0);

  //
  // Wait for the thread to die or else we could AV since there may be more
  // messages in the queue than just the WM_QUIT
  //
  if (m_pTimerThreadObj != NULL)
  {
    DWORD dwRetState = ::WaitForSingleObject(m_pTimerThreadObj->m_hThread,INFINITE);
    ASSERT(dwRetState != WAIT_FAILED);
  }

  //
  // Threads now gone, delete the thread object
  //
  delete m_pTimerThreadObj;
  m_pTimerThreadObj = NULL;
}


BOOL CComponentDataObject::PostMessageToTimerThread(UINT Msg, WPARAM wParam, LPARAM lParam)
{
    if (m_nTimerThreadID != 0)
  {
    return ::PostThreadMessage(m_nTimerThreadID, Msg, wParam, lParam);
  }
  return TRUE;
}

BOOL CComponentDataObject::SetTimer()
{
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(m_hiddenWnd.m_nTimerID == 0);
    m_dwTimerTime = 0;
    DWORD dwTimerIntervalMillisec = m_dwTimerInterval*1000;
    m_hiddenWnd.m_nTimerID = m_hiddenWnd.SetTimer(1, dwTimerIntervalMillisec);
    return (m_hiddenWnd.m_nTimerID != 0);
}

void CComponentDataObject::KillTimer()
{
    ASSERT(::IsWindow(m_hWnd));
    if (m_hiddenWnd.m_nTimerID != 0)
    {
        VERIFY(m_hiddenWnd.KillTimer(static_cast<UINT>(m_hiddenWnd.m_nTimerID)));
        m_hiddenWnd.m_nTimerID = 0;
    }
}

void CComponentDataObject::WaitForTimerThreadStartAck()
{
    MSG tempMSG;
    ASSERT(!m_bTimerThreadStarted);
    while(!m_bTimerThreadStarted)
    {
        if (::PeekMessage(&tempMSG,m_hWnd,CHiddenWnd::s_TimerThreadMessage,
                                        CHiddenWnd::s_TimerThreadMessage,
                                        PM_REMOVE))
        {
            DispatchMessage(&tempMSG);
        }
    }
}

void CComponentDataObject::WaitForThreadExitMessage(CMTContainerNode* pNode)
{
  MSG tempMSG;
    while(GetRunningThreadTable()->IsPresent(pNode))
    {
        if (::PeekMessage(&tempMSG,
                      m_hiddenWnd.m_hWnd, 
                      CHiddenWnd::s_NodeThreadHaveDataNotificationMessage,
                      CHiddenWnd::s_NodeThreadExitingNotificationMessage, 
                      PM_REMOVE))
        {
          DispatchMessage(&tempMSG);
        }
  } // while
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject implementation
///////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG_REFCOUNT
unsigned int CComponentObject::m_nOustandingObjects = 0;
#endif // _DEBUG_REFCOUNT

CComponentObject::CComponentObject()
{
#ifdef _DEBUG_REFCOUNT
    dbg_cRef = 0;
    ++m_nOustandingObjects;
    TRACE(_T("CComponentObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT
    Construct();
}

CComponentObject::~CComponentObject()
{
#ifdef _DEBUG_REFCOUNT
    --m_nOustandingObjects;
    TRACE(_T("~CComponentObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT

  // Make sure the interfaces have been released
  ASSERT(m_pConsole == NULL);
  ASSERT(m_pHeader == NULL);

    //SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent
    if (m_pComponentData != NULL)
    {
        m_pComponentData->Release();
        m_pComponentData = NULL;
        TRACE(_T("~CComponentObject() released m_pCompomentData\n"));
    }
  Construct();
}


void CComponentObject::Construct()
{
  m_pConsole = NULL;
  m_pHeader = NULL;

  m_pResult = NULL;
  m_pImageResult = NULL;
  m_pComponentData = NULL;
  m_pToolbar = NULL;
  m_pControlbar = NULL;
    m_pConsoleVerb = NULL;

    m_pSelectedContainerNode = NULL;
    m_pSelectedNode = NULL;
    m_selectedType = CCT_UNINITIALIZED;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IComponent members

STDMETHODIMP CComponentObject::Initialize(LPCONSOLE lpConsole)
{
  ASSERT(lpConsole != NULL);

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // Save the IConsole pointer
  m_pConsole = lpConsole;
  m_pConsole->AddRef();

  // QI for a IHeaderCtrl
  HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                      reinterpret_cast<void**>(&m_pHeader));

  // Give the console the header control interface pointer
  if (SUCCEEDED(hr))
  {
    m_pConsole->SetHeader(m_pHeader);
  }

  m_pConsole->QueryInterface(IID_IResultData,
                      reinterpret_cast<void**>(&m_pResult));

  hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    ASSERT(hr == S_OK);

  hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
  ASSERT(hr == S_OK);

  return S_OK;
}

STDMETHODIMP CComponentObject::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  HRESULT hr = S_OK;


  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (event == MMCN_PROPERTY_CHANGE)
  {
      ASSERT(lpDataObject == NULL);
    hr = OnPropertyChange(param, static_cast<ULONG>(arg));
  }
  else if (event == MMCN_VIEW_CHANGE)
  {
    hr = OnUpdateView(lpDataObject,arg,param);
  }
    else if (event == MMCN_DESELECT_ALL)
  {
        TRACE(_T("CComponentObject::Notify -> MMCN_DESELECT_ALL \n"));
  }
    else if (event == MMCN_COLUMN_CLICK)
    {
        OnColumnSortChanged(arg, param);
    }
  else if (event == MMCN_CUTORMOVE)
  {
    hr = S_FALSE;
  }
    else if (lpDataObject != NULL)
  {
    CInternalFormatCracker ifc;
    ifc.Extract(lpDataObject);

    if (ifc.GetCookieCount() < 1)
    {
            CComponentDataObject* pComponentDataObject = (CComponentDataObject*)m_pComponentData;
            if ( (event == MMCN_ADD_IMAGES) && pComponentDataObject->IsExtensionSnapin() )
            {
                CTreeNode* pTreeNode = pComponentDataObject->GetRootData();
                return InitializeBitmaps(pTreeNode); // cookie for the root
      }
      return S_OK;
    }

    switch(event)
    {
      case MMCN_ACTIVATE:
        break;

      case MMCN_CLICK:
        OnResultItemClk(ifc, FALSE);
        break;

      case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

      case MMCN_ADD_IMAGES:
        OnAddImages(ifc, arg, param);
        break;

      case MMCN_SHOW:
        hr = OnShow(ifc, arg, param);
        break;

          case MMCN_COLUMNS_CHANGED:
          hr = OnColumnsChanged(ifc, arg, param);
              break;

          case MMCN_MINIMIZED:
        hr = OnMinimize(ifc, arg, param);
        break;

      case MMCN_SELECT:
        HandleStandardVerbs( (BOOL) LOWORD(arg)/*bScope*/,
                       (BOOL) HIWORD(arg)/*bSelect*/,lpDataObject);
        break;

          case MMCN_QUERY_PASTE:
              hr = S_FALSE;
              break;

      case MMCN_PASTE:
        AfxMessageBox(_T("CComponentObject::MMCN_PASTE"));
        break;

      case MMCN_DELETE:
          // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnDeleteVerbHandler(
                                                          ifc, this);
        break;
          case MMCN_REFRESH:
              // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnRefreshVerbHandler(
                                          ifc);

        //
        // Once the refresh has begun, update the verbs associated with the
        // object being refreshed.
        //
        HandleStandardVerbs( (BOOL) LOWORD(arg)/*bScope*/,
                       (BOOL) HIWORD(arg)/*bSelect*/,lpDataObject);

        break;

      case MMCN_RENAME:
        // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnRename(ifc, arg, param);
        break;

          case MMCN_CONTEXTHELP:
              // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnHelpHandler(ifc, this);
        break;
          default:
        hr = E_UNEXPECTED;
        break;
    }

  }

  return hr;
}

STDMETHODIMP CComponentObject::Destroy(MMC_COOKIE)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Release the interfaces that we QI'ed
  //
  if (m_pConsole != NULL)
  {
    //
    // Tell the console to release the header control interface
    //
    m_pConsole->SetHeader(NULL);
    SAFE_RELEASE(m_pHeader);
    SAFE_RELEASE(m_pToolbar);
    SAFE_RELEASE(m_pControlbar);

    SAFE_RELEASE(m_pResult);
    SAFE_RELEASE(m_pImageResult);
    SAFE_RELEASE(m_pConsoleVerb);

    // Release the IConsole interface last
    SAFE_RELEASE(m_pConsole);
  }
  return S_OK;
}

STDMETHODIMP CComponentObject::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
                                                 long* pViewOptions)
{
  CTreeNode* pNode;
  if (cookie == NULL)
  {
    pNode = ((CComponentDataObject*)m_pComponentData)->GetRootData();
  }
  else
  {
    pNode = reinterpret_cast<CTreeNode*>(cookie);
  }
  ASSERT(pNode != NULL);

  if (pNode != NULL)
  {
    return pNode->GetResultViewType((CComponentDataObject*)m_pComponentData, 
                                    ppViewType, 
                                    pViewOptions);
  }
  // Use default view
  if (((CComponentDataObject*)m_pComponentData)->IsMultiSelect())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
  }
  else
  {
      *pViewOptions = MMC_VIEW_OPTIONS_NONE;
  }
    *ppViewType = NULL;
  return S_FALSE;
}

STDMETHODIMP CComponentObject::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
  HRESULT hr = S_OK;

  ASSERT(ppDataObject != NULL);

  CComObject<CDataObject>* pObject;
  CComObject<CDataObject>::CreateInstance(&pObject);
  ASSERT(pObject != NULL);

  if (pObject != NULL)
  {
    CTreeNode* pNode = NULL;
    if (cookie == MMC_MULTI_SELECT_COOKIE) 
    {
      TRACE(_T("CDSEvent::GetDataObject() - multi-select.\n"));
      RESULTDATAITEM rdi;

      // This is an acceptable usage
      ZeroMemory(&rdi, sizeof(rdi));
      rdi.mask = RDI_STATE;
      rdi.nIndex = -1;
      rdi.nState = LVIS_SELECTED;
    
      do
      {
        rdi.lParam = 0;
        ASSERT(rdi.mask == RDI_STATE);
        ASSERT(rdi.nState == LVIS_SELECTED);
        hr = m_pResult->GetNextItem(&rdi);
        if (hr != S_OK)
          break;
      
        pNode = reinterpret_cast<CTreeNode*>(rdi.lParam);
        pObject->AddCookie(pNode);
      } while (1);
      // addref() the new pointer and return it.
      pObject->AddRef();
      *ppDataObject = pObject;
    }
    else
    {
      // Delegate it to the IComponentData implementation
      ASSERT(m_pComponentData != NULL);
      hr = m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
    }
  }
  return hr;
}

STDMETHODIMP CComponentObject::GetDisplayInfo(LPRESULTDATAITEM  pResultDataItem)
{
   ASSERT(pResultDataItem != NULL);

   if (pResultDataItem)
   {
      CTreeNode* pNode = reinterpret_cast<CTreeNode*>(pResultDataItem->lParam);

      ASSERT(pNode != NULL);
      if (pNode)
      {
         ASSERT(pResultDataItem->bScopeItem == pNode->IsContainer());

         if (pResultDataItem->mask & RDI_STR)
         {
            LPCWSTR lpszString = pNode->GetString(pResultDataItem->nCol);
            if (lpszString != NULL)
            {
               pResultDataItem->str = (LPWSTR)lpszString;
            }
         }

         if ((pResultDataItem->mask & RDI_IMAGE) && (pResultDataItem->nCol == 0))
         {
            pResultDataItem->nImage = pNode->GetImageIndex(FALSE);
         }
      }
   }
   return S_OK;
}

STDMETHODIMP CComponentObject::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
  return m_pComponentData->CompareObjects(lpDataObjectA, lpDataObjectB);
}


///////////////////////////////////////////////////////////////////////////////
// Message handlers for CComponentObject::IComponent::Notify()

HRESULT CComponentObject::OnFolder(CTreeNode*, LPARAM, LPARAM)
{
  ASSERT(FALSE);
  return S_OK;
}

HRESULT CComponentObject::OnShow(CInternalFormatCracker& ifc, LPARAM arg, LPARAM)
{
  HRESULT hr = S_OK;
    ASSERT(ifc.GetCookieCount() == 1);
  
  //
  // I shouldn't have to deal with multiple select here
  //
  CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  if (!pNode)
  {
    // NTRAID#NTBUG9-657633-2002/07/11-sburns

    return E_FAIL;
  }
  
    ASSERT(pNode->IsContainer());
    CContainerNode* pContainerNode = (CContainerNode*)pNode;

  // Note - arg is TRUE when it is time to enumerate
  if (arg == TRUE)
  {
    long lResultView;
    LPOLESTR lpoleResultView = NULL;
    pNode->GetResultViewType((CComponentDataObject*)m_pComponentData,
                              &lpoleResultView, 
                              &lResultView);
    if (lResultView == MMC_VIEW_OPTIONS_NONE || lResultView == MMC_VIEW_OPTIONS_MULTISELECT)
    {
       // Show the headers for this nodetype
      InitializeHeaders(pContainerNode);
      EnumerateResultPane(pContainerNode);
      m_pSelectedContainerNode = pContainerNode;
      SetDescriptionBarText(pContainerNode);
    }
    else
    {
      m_pSelectedContainerNode = pContainerNode;
      hr = pNode->OnShow(m_pConsole);
    }
  }
  else
  {
    // Removed by JEFFJON : new column header implementation
    // if we want we can notify ourselves that the focus is being lost
    //      SaveHeadersInfo(pContainerNode);
    m_pSelectedContainerNode = NULL;
    // Free data associated with the result pane items, because
    // your node is no longer being displayed.
    // Note: The console will remove the items from the result pane
  }
#ifdef _DEBUG
    if (m_pSelectedContainerNode == NULL)
        TRACE(_T("NULL selection\n"));
    else
        TRACE(_T("Node <%s> selected\n"), m_pSelectedContainerNode->GetDisplayName());
#endif
  return hr;
}

HRESULT CComponentObject::OnColumnsChanged(CInternalFormatCracker& ifc, LPARAM, LPARAM param)
{
  CTreeNode* pNode = ifc.GetCookieAt(0);
    ASSERT(pNode != NULL);
    ASSERT(pNode->IsContainer());
    CContainerNode* pContainerNode = (CContainerNode*)pNode;

    MMC_VISIBLE_COLUMNS* pVisibleCols = reinterpret_cast<MMC_VISIBLE_COLUMNS*>(param);
    pContainerNode->OnColumnsChanged(pVisibleCols->rgVisibleCols, pVisibleCols->nVisibleColumns);

    return S_OK;
}

HRESULT CComponentObject::OnColumnSortChanged(LPARAM, LPARAM)
{
    return S_OK;
}

HRESULT CComponentObject::ForceSort(UINT iCol, DWORD dwDirection)
{
    HRESULT hr = m_pResult->Sort(iCol, dwDirection, NULL);
    return hr;
}

HRESULT CComponentObject::OnActivate(CTreeNode*, LPARAM, LPARAM)
{
    ASSERT(FALSE);
  return S_OK;
}

HRESULT CComponentObject::OnResultItemClk(CInternalFormatCracker&, BOOL)
{
  return S_OK;
}

HRESULT CComponentObject::OnMinimize(CInternalFormatCracker&, LPARAM, LPARAM)
{
  return S_OK;
}

HRESULT CComponentObject::OnPropertyChange(LPARAM param, long fScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(param != NULL);
#ifdef _DEBUG
    TRACE(_T("CComponentObject::OnPropertyChange()\n"));
    CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(param);
    ASSERT(pPPHolder != NULL);
    CTreeNode* pNode = pPPHolder->GetTreeNode();
    ASSERT(pNode != NULL);

    // the item must be a result item and in the result pane
    ASSERT(!fScopePane);
#endif
    // we delegate the call to the IComponentData implementation
    CComponentDataObject* pComponentDataObject = (CComponentDataObject*)m_pComponentData;
    ASSERT(pComponentDataObject != NULL);
    return pComponentDataObject->OnPropertyChange(param, fScopePane);
}

HRESULT CComponentObject::OnUpdateView(LPDATAOBJECT, LPARAM data, LONG_PTR hint)
{
    if (m_pSelectedContainerNode == NULL)
  {
        return S_OK; // no selection for our IComponentData
  }

    if (hint == DELETE_ALL_RESULT_ITEMS)
    {
        // data contains the container whose result pane has to be refreshed
        CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
        ASSERT(pNode != NULL);

        // do it only if selected and we are using the standard list view,
    // if not, reselecting will do a delete/enumeration
    long lResultView;
    LPOLESTR lpoleResultView = NULL;
    pNode->GetResultViewType((CComponentDataObject*)m_pComponentData,
                             &lpoleResultView, 
                             &lResultView);
        if (m_pSelectedContainerNode == pNode && 
        (lResultView == MMC_VIEW_OPTIONS_NONE || lResultView == MMC_VIEW_OPTIONS_MULTISELECT))
        {
            ASSERT(m_pResult != NULL);
            VERIFY(SUCCEEDED(m_pResult->DeleteAllRsltItems()));
      SetDescriptionBarText(pNode);
        }
    }
  else if (hint == SORT_RESULT_PANE)
  {
    // data contains the container whose result pane has to be refreshed
    CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
    ASSERT(pNode != NULL);
    // do it only if selected, if not, reselecting will do a delete/enumeration
    if (m_pSelectedContainerNode == pNode)
    {
      MMC_SORT_SET_DATA* pColumnSortData = NULL;

      // build the column id
      LPCWSTR lpszColumnID = pNode->GetColumnID();

      // We are assuming the columnID is NULL terminated.  Since this is usually
      // hardcoded and there is no good way to verify that it is NULL terminated
      // this usage should be fine.

      size_t iLen = wcslen(lpszColumnID);
      iLen += 1; // Include space for the null.

      // allocate memory for the struct and add on enough to make the byte[1] into a string
      // for the column id
      // Add 1 to the length to include space for NULL.
      size_t arraySizeInBytes = sizeof(SColumnSetID) + (iLen * sizeof(WCHAR));
      SColumnSetID* pColumnID = (SColumnSetID*)malloc(arraySizeInBytes);
      if (!pColumnID)
      {
         return S_OK;
      }

      // This is an acceptable usage
      memset(pColumnID, 0, arraySizeInBytes);
      pColumnID->cBytes = static_cast<DWORD>(iLen * sizeof(WCHAR));

      // NOTICE-2002/04/18-artm  Part of fix for ntraid#ntbug9-540061.
      // Unlike wcscpy(), StringCchCopy() will ensure that the destination
      // buffer is null terminated and report an error code if there was
      // a truncation (won't overrun the destination buffer).
      //
      // Since we needed to use strsafe.h elsewhere in this file, I decided
      // to replace these dangerous wcscpy() uses that were deprecated by
      // strsafe.h.
      HRESULT err;
      err = StringCchCopyW(
          reinterpret_cast<LPWSTR>(pColumnID->id),    // destination string
          iLen,         // size of destination string (including null)
          lpszColumnID);    // source string

      if (FAILED(err))
      {
          ASSERT(false);    // This should never happen.
          // Even though there was an error we return S_OK here since that
          // is the behavior used above for out of memory failure.
          free(pColumnID);
          return S_OK;
      }

      // Get the sort column and direction
      IColumnData* pColumnData = NULL;
      HRESULT hr = m_pConsole->QueryInterface(IID_IColumnData, reinterpret_cast<void**>(&pColumnData));
      if (pColumnData != NULL)
        hr = pColumnData->GetColumnSortData(pColumnID, &pColumnSortData);
      if (SUCCEEDED(hr))
      {
        if (pColumnSortData != NULL)
        {
          UINT iCurrentSortColumn = pColumnSortData->pSortData->nColIndex;
          DWORD dwCurrentSortDirection = pColumnSortData->pSortData->dwSortOptions;

          VERIFY(SUCCEEDED(ForceSort(iCurrentSortColumn, dwCurrentSortDirection)));
          CoTaskMemFree(pColumnSortData);
        }
      }
      if (pColumnData != NULL)
        pColumnData->Release();
      free(pColumnID);
    }
  }
    else if (hint == REPAINT_RESULT_PANE)
    {
        // data contains the container whose result pane has to be refreshed
        CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
        if (pNode == NULL)
            pNode = m_pSelectedContainerNode; // passing NULL means apply to the current selection

        // update all the leaf nodes in the result pane
        CNodeList* pChildList = ((CContainerNode*)pNode)->GetLeafChildList();
        for( POSITION pos = pChildList->GetHeadPosition(); pos != NULL; )
        {
            CLeafNode* pCurrentChild = (CLeafNode*)pChildList->GetNext(pos);
            ChangeResultPaneItem(pCurrentChild,CHANGE_RESULT_ITEM);
        }
    }
  else if ( hint == DELETE_MULTIPLE_RESULT_ITEMS)
  {
    CNodeList* pNodeList = reinterpret_cast<CNodeList*>(data);
    ASSERT(pNodeList != NULL);

    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);
      if (!pNode->IsContainer())
      {
        DeleteResultPaneItem(static_cast<CLeafNode*>(pNode));
      }
    }
    SetDescriptionBarText(pNodeList->GetHead()->GetContainer());
  }
    else if ( (hint == ADD_RESULT_ITEM) || (hint == DELETE_RESULT_ITEM) || (hint & CHANGE_RESULT_ITEM))
    {
        // we deal with a leaf node
        CLeafNode* pNode = reinterpret_cast<CLeafNode*>(data);
        ASSERT(pNode != NULL);
        // consider only if the parent is selected, otherwise will enumerate later when selected
        if (m_pSelectedContainerNode == pNode->GetContainer())
        {
            if (hint & CHANGE_RESULT_ITEM)
            {
                ChangeResultPaneItem(pNode,hint);
            }
            else if ( hint ==  ADD_RESULT_ITEM)
            {
                AddResultPaneItem(pNode);
        SetDescriptionBarText(pNode);
            }
            else if ( hint ==  DELETE_RESULT_ITEM)
            {
                DeleteResultPaneItem(pNode);
        SetDescriptionBarText(pNode);
            }
        }
    }
    else if (hint == UPDATE_VERB_STATE)
    {
        CTreeNode* pTreeNode = reinterpret_cast<CTreeNode*>(data);
        ASSERT(pTreeNode != NULL);
        if (m_pSelectedNode == pTreeNode)
        {
            ASSERT(m_selectedType != CCT_UNINITIALIZED);
      CNodeList nodeList;
      nodeList.AddTail(pTreeNode);
            m_pConsoleVerb->SetDefaultVerb(pTreeNode->GetDefaultVerb(m_selectedType, &nodeList));
            pTreeNode->OnSetVerbState(m_pConsoleVerb, m_selectedType, &nodeList);
        }
    }
  else if (hint == UPDATE_DESCRIPTION_BAR)
  {
    CTreeNode* pTreeNode = reinterpret_cast<CTreeNode*>(data);
    ASSERT(pTreeNode != NULL);
    SetDescriptionBarText(pTreeNode);
  }
  else if (hint == UPDATE_RESULT_PANE_VIEW)
  {
    CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
    ASSERT(pNode != NULL);
    HSCOPEITEM hScopeID = pNode->GetScopeID();
    if (hScopeID != 0)
    {
      m_pConsole->SelectScopeItem(hScopeID);
    }
  }
  return S_OK;
}

HRESULT CComponentObject::SetDescriptionBarText(CTreeNode* pTreeNode)
{
  ASSERT(pTreeNode != NULL);
  HRESULT hr = S_OK;
  if (m_pSelectedContainerNode == pTreeNode)
  {
    LPWSTR lpszText = pTreeNode->GetDescriptionBarText();
    hr = m_pResult->SetDescBarText(lpszText);
  }
  else if (m_pSelectedContainerNode == pTreeNode->GetContainer())
  {
    LPWSTR lpszText = pTreeNode->GetContainer()->GetDescriptionBarText();
    hr = m_pResult->SetDescBarText(lpszText);
  }

  return hr;
}

HRESULT CComponentObject::OnAddImages(CInternalFormatCracker& ifc, LPARAM, LPARAM)
{
  CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);
    return InitializeBitmaps(pNode);
}


void CComponentObject::HandleStandardVerbs(BOOL bScope, BOOL bSelect, LPDATAOBJECT lpDataObject)
{
  if (lpDataObject == NULL)
  {
    return;
  }
    ((CComponentDataObject*)m_pComponentData)->HandleStandardVerbsHelper(
        this, m_pConsoleVerb, bScope, bSelect, lpDataObject);
}



void CComponentObject::EnumerateResultPane(CContainerNode* pContainerNode)
{
  ASSERT(m_pResult != NULL);        // make sure we QI'ed for the interfaces
  ASSERT(m_pComponentData != NULL);
    ASSERT(pContainerNode != NULL);

  //
    // get the list of children
    // subfolders already added by console, add only the leaf nodes
  //
  CNodeList* pChildList = pContainerNode->GetLeafChildList();
    ASSERT(pChildList != NULL);

    POSITION pos;
    for( pos = pChildList->GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pCurrChildNode = pChildList->GetNext(pos);
        ASSERT(pCurrChildNode != NULL);

    if(pCurrChildNode->IsVisible())
    {
            VERIFY(SUCCEEDED(AddResultPaneItem((CLeafNode*)pCurrChildNode)));
    }
    }
}

HRESULT CComponentObject::AddResultPaneItem(CLeafNode* pNodeToInsert)
{
    ASSERT(m_pResult != NULL);
    ASSERT(pNodeToInsert != NULL);
  RESULTDATAITEM resultItem;

  // This is an acceptable usage
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));

  resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  resultItem.str = MMC_CALLBACK;

    //use close image index on result pane
  resultItem.nImage = pNodeToInsert->GetImageIndex(FALSE);
  resultItem.lParam = reinterpret_cast<LPARAM>(pNodeToInsert);
  return m_pResult->InsertItem(&resultItem);
}

HRESULT CComponentObject::DeleteResultPaneItem(CLeafNode* pNodeToDelete)
{
    ASSERT(m_pResult != NULL);
    ASSERT(pNodeToDelete != NULL);
  RESULTDATAITEM resultItem;

  // This is an acceptable usage
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));

    HRESULTITEM itemID;
    HRESULT hr = m_pResult->FindItemByLParam(reinterpret_cast<LPARAM>(pNodeToDelete), &itemID);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
  {
        return hr;
  }
    return m_pResult->DeleteItem(itemID,0 /* all cols */);
}


HRESULT CComponentObject::ChangeResultPaneItem(CLeafNode* pNodeToChange, LONG_PTR changeMask)
{
    ASSERT(changeMask & CHANGE_RESULT_ITEM);
    ASSERT(m_pResult != NULL);
    ASSERT(pNodeToChange != NULL);
    HRESULTITEM itemID;

    HRESULT hr = m_pResult->FindItemByLParam(reinterpret_cast<LPARAM>(pNodeToChange), &itemID);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
  {
        return hr;
  }

  RESULTDATAITEM resultItem;

  // This is an acceptable usage
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));
    resultItem.itemID = itemID;
    if (changeMask & CHANGE_RESULT_ITEM_DATA)
    {
    //
        // UpdateItem() alone does not allow the
        // item string buffer to grow and you get "foo..." when
        // "foo" changes to "foobar" the first time (buffer grows)
    //
        resultItem.mask |= RDI_STR;
        resultItem.str = MMC_CALLBACK;
    //
        // this line asserts, use the one above ask Tony
    //
        //resultItem.str = (LPWSTR)pNodeToChange->GetDisplayName();
    }
    if (changeMask & CHANGE_RESULT_ITEM_ICON)
    {
        resultItem.mask |= RDI_IMAGE;
        resultItem.nImage = pNodeToChange->GetImageIndex(FALSE);
    }
    hr = m_pResult->SetItem(&resultItem);
    ASSERT(SUCCEEDED(hr));
    hr = m_pResult->UpdateItem(itemID);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT CComponentObject::FindResultPaneItemID(CLeafNode* pNode, HRESULTITEM*)
{
    ASSERT(FALSE);
    ASSERT(m_pResult != NULL);
  RESULTDATAITEM resultItem;

  // This is an acceptable usage
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));

    resultItem.mask = SDI_PARAM;
    resultItem.lParam = reinterpret_cast<LPARAM>(pNode);
    HRESULT hr = m_pResult->GetItem(&resultItem);
    ASSERT(SUCCEEDED(hr));
    return E_FAIL;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IExtendPropertySheet2 members

STDMETHODIMP CComponentObject::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
    IExtendPropertySheet2* pIExtendPropertySheet2;
    VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendPropertySheet2,
                    reinterpret_cast<void**>(&pIExtendPropertySheet2))));
    ASSERT(pIExtendPropertySheet2 != NULL);
  HRESULT hr = pIExtendPropertySheet2->CreatePropertyPages(lpProvider, handle, lpIDataObject);
    pIExtendPropertySheet2->Release();
    return hr;
}

STDMETHODIMP CComponentObject::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
    IExtendPropertySheet2* pIExtendPropertySheet2;
    VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendPropertySheet2,
                    reinterpret_cast<void**>(&pIExtendPropertySheet2))));
    ASSERT(pIExtendPropertySheet2 != NULL);
  HRESULT hr = pIExtendPropertySheet2->QueryPagesFor(lpDataObject);
    pIExtendPropertySheet2->Release();
    return hr;
}



STDMETHODIMP CComponentObject::GetWatermarks(LPDATAOBJECT lpDataObject,
                                                HBITMAP* lphWatermark,
                                                HBITMAP* lphHeader,
                                                HPALETTE* lphPalette,
                                                BOOL* pbStretch)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
    IExtendPropertySheet2* pIExtendPropertySheet2;
    VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendPropertySheet2,
                    reinterpret_cast<void**>(&pIExtendPropertySheet2))));
    ASSERT(pIExtendPropertySheet2 != NULL);
  HRESULT hr = pIExtendPropertySheet2->GetWatermarks(lpDataObject,
                                                lphWatermark,
                                                lphHeader,
                                                lphPalette,
                                                pbStretch);
    pIExtendPropertySheet2->Release();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IExtendContextMenu members

STDMETHODIMP CComponentObject::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    long *pInsertionAllowed)
{
  HRESULT hr = S_OK;

  CComPtr<IContextMenuCallback2> spContextMenuCallback2;
  hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (PVOID*)&spContextMenuCallback2);
  if (FAILED(hr))
  {
    return hr;
  }

  if (pDataObject == DOBJ_CUSTOMOCX)
  {
    //
    // A custom result pane is being used and we don't know what node it cooresponds to so we assume that it
    // is the previously selected container.
    //

    ASSERT(m_pSelectedContainerNode != NULL);
    CTreeNode* pNode = (CTreeNode*)m_pSelectedContainerNode;
    CNodeList nodeList;
    nodeList.AddTail(pNode);
    hr = m_pSelectedContainerNode->OnAddMenuItems(spContextMenuCallback2, 
                                                  CCT_UNINITIALIZED, 
                                                  pInsertionAllowed,
                                                  &nodeList);
  }
  else
  {
    //
    // Delegate it to the IComponentData implementation
    //
    ASSERT(m_pComponentData != NULL);
      IExtendContextMenu* pIExtendContextMenu;
      VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendContextMenu,
                      reinterpret_cast<void**>(&pIExtendContextMenu))));
      ASSERT(pIExtendContextMenu != NULL);
    hr = pIExtendContextMenu->AddMenuItems(pDataObject,
                                                      pContextMenuCallback,
                                                      pInsertionAllowed);
      pIExtendContextMenu->Release();
  }
    return hr;
}

STDMETHODIMP CComponentObject::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT hr = S_OK;
  if (pDataObject == DOBJ_CUSTOMOCX)
  {
    //
    // A custom result pane is being used and we don't know what node it cooresponds to so we assume that it
    // is the previously selected container.
    //
    ASSERT(m_pSelectedContainerNode != NULL);
    CTreeNode* pNode = (CTreeNode*)m_pSelectedContainerNode;
    CNodeList nodeList;
    nodeList.AddTail(pNode);
    hr = m_pSelectedContainerNode->OnCommand(nCommandID, 
                                             CCT_UNINITIALIZED, 
                                             (CComponentDataObject*)m_pComponentData,
                                             &nodeList);
  }
  else
  {
    // Delegate it to the IComponentData implementation
    ASSERT(m_pComponentData != NULL);
      IExtendContextMenu* pIExtendContextMenu;
      VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendContextMenu,
                      reinterpret_cast<void**>(&pIExtendContextMenu))));
      ASSERT(pIExtendContextMenu != NULL);
    hr = pIExtendContextMenu->Command(nCommandID, pDataObject);
      pIExtendContextMenu->Release();
  }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IExtendControlbar members

STDMETHODIMP CComponentObject::SetControlbar(LPCONTROLBAR pControlbar)
{
  HRESULT hr = S_OK;

  if (pControlbar == NULL)
  {
    //
    // Detach the controls here
    //
    if (m_pControlbar != NULL && m_pToolbar != NULL)
    {
      hr = m_pControlbar->Detach((IUnknown *) m_pToolbar);
      SAFE_RELEASE(m_pControlbar);
    }
  }
  else
  {
    //
    // Save the controlbar interface pointer
    //
    if (m_pControlbar == NULL)
    {
      m_pControlbar = pControlbar;
      m_pControlbar->AddRef();
    }

    //
    // Do something here that checks to see if we have toolbars
    // already created and use those.  If not then create one
    // and load everything necessary for it.
    //

    //
    // Create the toolbar
    //
    hr = m_pControlbar->Create (TOOLBAR,
                                this,
                                (IUnknown **) &m_pToolbar);
    if (SUCCEEDED(hr))
    {
      //
      // Load the toolbar
      //
      AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
      hr = InitializeToolbar(m_pToolbar);
      if (FAILED(hr))
      {
        hr = m_pControlbar->Detach((IUnknown*) m_pToolbar);
        SAFE_RELEASE(m_pControlbar);
      }
    }
  }
  return hr;
}

STDMETHODIMP CComponentObject::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState()); 

  HRESULT hr = S_OK;

  if (m_pControlbar == NULL)
  {
    return hr;
  }

  //
  // MMC provides two events here MMCN_SELECT at the time a node is selected
  // and MMCN_BTN_CLICK when a toolbar button is pressed
  //
  switch (event) 
  {
    case MMCN_SELECT:
      {
        //
        // Attach the toolbar to the controlbar
        //
        hr = m_pControlbar->Attach(TOOLBAR, (IUnknown *) m_pToolbar);

        if (SUCCEEDED(hr))
        {
          ASSERT(m_pToolbar != NULL);

          //
          // bSelect is TRUE if the node was selected, FALSE if the node was deselected
          // bScope is TRUE if the a scope node is selected, FALSE if a result node was selected
          //
          BOOL bSelect = HIWORD(arg);

          if (bSelect) 
          {
            CInternalFormatCracker ifc;
            hr = ifc.Extract((LPDATAOBJECT)param);
            if (SUCCEEDED(hr))
            {

               CTreeNode* pNode = ifc.GetCookieAt(0);
               ASSERT(pNode != NULL);

               CNodeList nodeList;
               ifc.GetCookieList(nodeList);

               if (ifc.GetCookieCount() > 1)  // multiple selection
               {
                 ASSERT(pNode->GetContainer() != NULL);
                 hr = pNode->GetContainer()->OnSetToolbarVerbState(m_pToolbar, 
                                                                   &nodeList);
               }
               else if (ifc.GetCookieCount() == 1)  // single selection
               {
                 hr = pNode->OnSetToolbarVerbState(m_pToolbar, 
                                                   &nodeList);
               }
            }
          }
        }
        break;
      }
    case MMCN_BTN_CLICK:
      {
        //
        // The arg is -1 for custom views like MessageView
        //
        if (DOBJ_CUSTOMOCX == (LPDATAOBJECT)arg)
        {
          if (m_pSelectedContainerNode != NULL)
          {
            CNodeList nodeList;
            nodeList.AddTail(m_pSelectedContainerNode);

            hr = m_pSelectedContainerNode->ToolbarNotify(static_cast<int>(param),
                                                         (CComponentDataObject*)m_pComponentData,
                                                         &nodeList);
          }
          else
          {
            hr = S_FALSE;
          }
        }
        else
        {
          CInternalFormatCracker ifc;
          hr = ifc.Extract((LPDATAOBJECT)arg);

          CTreeNode* pNode = ifc.GetCookieAt(0);
          ASSERT(pNode != NULL);

          CNodeList nodeList;
          ifc.GetCookieList(nodeList);

          if (ifc.GetCookieCount() > 1) // multiple selection
          {
            ASSERT(pNode->GetContainer() != NULL);
            hr = pNode->GetContainer()->ToolbarNotify(static_cast<int>(param), 
                                                      (CComponentDataObject*)m_pComponentData,
                                                      &nodeList);
          }
          else if (ifc.GetCookieCount() == 1) // single selection
          {
            hr = pNode->ToolbarNotify(static_cast<int>(param), 
                                      (CComponentDataObject*)m_pComponentData,
                                      &nodeList);
          }
          else
          {
            hr = S_FALSE;
          }
        }
        break;
      }

    default:
      {
        break;
      }
  }

  return hr;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IResultDataCompareEx members
// This compare is used to sort the item's in the listview
//
// Note: Assum sort is ascending when comparing.
STDMETHODIMP CComponentObject::Compare(RDCOMPARE* prdc, int* pnResult)
{
  if (pnResult == NULL)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

  if (prdc == NULL)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

    CTreeNode* pNodeA = reinterpret_cast<CTreeNode*>(prdc->prdch1->cookie);
    CTreeNode* pNodeB = reinterpret_cast<CTreeNode*>(prdc->prdch2->cookie);
    ASSERT(pNodeA != NULL);
    ASSERT(pNodeB != NULL);
    
    CContainerNode* pContNode = pNodeA->GetContainer();
    ASSERT(pContNode != NULL);

    // delegate the sorting to the container
    int nCol = prdc->nColumn;
    *pnResult = pContNode->Compare(pNodeA, pNodeB, nCol, prdc->lUserParam);

  return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentObject Helpers

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      // REVIEWED-2002/03/08-JeffJon-We want to propogate the exception

      ::InitializeCriticalSection(critsec);
   }

   //
   // propagate the exception to our caller.  
   //
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\dataobj_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dataobj_.cpp
//
//--------------------------------------------------------------------------


#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

const wchar_t* CCF_DNS_SNAPIN_INTERNAL = L"DNS_SNAPIN_INTERNAL"; 

CLIPFORMAT CDataObject::m_cfNodeType        = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDataObject::m_cfNodeTypeString  = (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);  
CLIPFORMAT CDataObject::m_cfDisplayName     = (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME); 
CLIPFORMAT CDataObject::m_cfCoClass         = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
CLIPFORMAT CDataObject::m_cfColumnID			  = (CLIPFORMAT)RegisterClipboardFormat(CCF_COLUMN_SET_ID);

CLIPFORMAT CDataObject::m_cfInternal        = (CLIPFORMAT)RegisterClipboardFormat(CCF_DNS_SNAPIN_INTERNAL); 
CLIPFORMAT CDataObject::m_cfMultiSel        = (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
CLIPFORMAT CDataObject::m_cfMultiObjTypes   = (CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);


#ifdef _DEBUG_REFCOUNT
unsigned int CDataObject::m_nOustandingObjects = 0;
#endif // _DEBUG_REFCOUNT

/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

HRESULT CInternalFormatCracker::Extract(LPDATAOBJECT lpDataObject)
{
  if (DOBJ_CUSTOMOCX == lpDataObject ||
      DOBJ_CUSTOMWEB == lpDataObject ||
      DOBJ_NULL      == lpDataObject)
  {
     return DV_E_CLIPFORMAT;
  }

  if (m_pInternal != NULL)
    _Free();

  SMMCDataObjects * pDO = NULL;
  
  STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
  FORMATETC formatetc = { CDataObject::m_cfInternal, NULL, 
                          DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };
  FORMATETC formatetc2 = { CDataObject::m_cfMultiSel, NULL, 
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };

  HRESULT hr = lpDataObject->GetData(&formatetc2, &stgmedium);
  if (FAILED(hr)) 
  {
  
    hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (FAILED(hr))
      return hr;
      
    m_pInternal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
  } 
  else 
  {
    pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
    for (UINT i = 0; i < pDO->count; i++) 
    {
      hr = pDO->lpDataObject[i]->GetDataHere(&formatetc, &stgmedium);
      if (FAILED(hr))
        break;
      
      m_pInternal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
      
      if (m_pInternal != NULL)
        break;
    }
  }
  return hr;

}

void CInternalFormatCracker::GetCookieList(CNodeList& list)
{
  for (DWORD dwCount = 0; dwCount < m_pInternal->m_cookie_count; dwCount++)
  {
    list.AddTail(m_pInternal->m_p_cookies[dwCount]);
  }
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
  HRESULT hr = DV_E_CLIPFORMAT;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // Based on the CLIPFORMAT write data to the stream
  const CLIPFORMAT cf = lpFormatetc->cfFormat;

  if(cf == m_cfNodeType)
  {
    hr = CreateNodeTypeData(lpMedium);
  }
  else if(cf == m_cfNodeTypeString) 
  {
    hr = CreateNodeTypeStringData(lpMedium);
  }
  else if (cf == m_cfDisplayName)
  {
    hr = CreateDisplayName(lpMedium);
  }
  else if (cf == m_cfCoClass)
  {
    hr = CreateCoClassID(lpMedium);
  }
  else if (cf == m_cfInternal)
  {
    hr = CreateInternal(lpMedium);
  }
  else if (cf == m_cfMultiObjTypes)
  {
    hr = CreateMultiSelectObject(lpMedium);
  }
	else
	{
		// if not successful, maybe there is a node specific clipboard format,
		// so ask the node itself to provide
		CTreeNode* pNode = GetTreeNodeFromCookie();
		ASSERT(pNode != NULL);
    if (pNode != NULL)
    {
		  hr = pNode->GetDataHere(cf, lpMedium, this);
    }
	}
	return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
	HRESULT hr = DV_E_CLIPFORMAT;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Based on the CLIPFORMAT write data to the stream
	const CLIPFORMAT cf = lpFormatetcIn->cfFormat;

	if (cf == m_cfColumnID)
	{
		hr = CreateColumnID(lpMedium);
	}
  else if (cf == m_cfMultiObjTypes)
  {
    hr = CreateMultiSelectObject(lpMedium);
  }
	else
	{
		// if not successful, maybe there is a node specific clipboard format,
		// so ask the node itself to provide
		CTreeNode* pNode = GetTreeNodeFromCookie();
    if (pNode != NULL)
    {
		  hr = pNode->GetData(cf, lpMedium, this);
    }
	}
	return hr;
}
    

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD, LPENUMFORMATETC*)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, size_t len, LPSTGMEDIUM lpMedium)
{
  HRESULT hr = DV_E_TYMED;

  // Do some simple validation
  if (pBuffer == NULL || lpMedium == NULL)
      return E_POINTER;

  // Make sure the type medium is HGLOBAL
  if (lpMedium->tymed == TYMED_HGLOBAL)
  {
    // Create the stream on the hGlobal passed in
    LPSTREAM lpStream;
    hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

    if (SUCCEEDED(hr))
    {
      // Write to the stream the number of bytes

       ULONG bytesToWrite = static_cast<ULONG>(min(len, ::GlobalSize(lpMedium->hGlobal)));
      unsigned long written;
		  hr = lpStream->Write(pBuffer, bytesToWrite, &written);

      // Because we told CreateStreamOnHGlobal with 'FALSE', 
      // only the stream is released here.
      // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
      // at the correct time.  This is according to the IDataObject specification.
      lpStream->Release();
    }
  }

  return hr;
}

HRESULT CDataObject::CreateColumnID(LPSTGMEDIUM lpMedium)
{
	CTreeNode* pTreeNode = GetTreeNodeFromCookie();
  if (pTreeNode == NULL)
  {
    return E_FAIL;
  }

	ASSERT(pTreeNode->IsContainer());
	CContainerNode* pContainerNode = (CContainerNode*)pTreeNode;

  // build the column id
  LPCWSTR lpszColumnID = pContainerNode->GetColumnID();

  // We are assuming the column ID is NULL terminated.  Since this is usually
  // hardcoded and there is no good way to verify that it is NULL terminated
  // this usage should be fine.

  size_t iLen = wcslen(lpszColumnID);
  iLen += 1;  // Include space for null.

  // allocate enough memory for the struct and the string for the column id
  size_t arraySizeInBytes = sizeof(SColumnSetID) + (iLen * sizeof(WCHAR));
  SColumnSetID* pColumnID = (SColumnSetID*)malloc(arraySizeInBytes);

  if (pColumnID != NULL)
  {
    memset(pColumnID, 0, arraySizeInBytes);
    pColumnID->cBytes = static_cast<DWORD>(iLen * sizeof(WCHAR));


    // NOTICE-2002/04/18-artm  Part of fix for ntraid#ntbug9-540061.
    // Unlike wcscpy(), StringCchCopy() will ensure that the destination
    // buffer is null terminated and report an error code if there was
    // a truncation (won't overrun the destination buffer).
    //
    // Since we needed to use strsafe.h elsewhere in this file, I decided
    // to replace these dangerous wcscpy() uses that were deprecated by
    // strsafe.h.
    HRESULT err;
    err = StringCchCopyW(
        reinterpret_cast<LPWSTR>(pColumnID->id),    // destination string
        iLen,         // size of destination string (including null)
        lpszColumnID);    // source string

    if (FAILED(err))
    {
        ASSERT(false);    // This should never happen.
        free(pColumnID);
        return err;
    }

    // copy the column id to global memory
    size_t cb = sizeof(SColumnSetID) + (iLen * sizeof(WCHAR));

    lpMedium->tymed = TYMED_HGLOBAL;
    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);

    if (lpMedium->hGlobal == NULL)
      return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    if (pb)
    {
      // REVIEWED-2002/03/0-JeffJon-The count of bytes is equal to the number
      // of bytes allocated

      memcpy(pb, pColumnID, cb);

      ::GlobalUnlock(lpMedium->hGlobal);
    }

   free(pColumnID);
  }
	return S_OK;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
	// First ask the related node, if failed, get the default GUID
	// from the root node
  CTreeNode* pNode = GetTreeNodeFromCookie();
  if (pNode == NULL)
  {
    return E_FAIL;
  }

	const GUID* pNodeType = pNode->GetNodeType();
	if (pNodeType == NULL)
  {
		pNodeType = GetDataFromComponentDataObject()->GetNodeType();
  }
  HRESULT hr = Create(pNodeType, sizeof(GUID), lpMedium);
  return hr;
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
  OLECHAR szNodeType[128] = {0};
	// First ask the related node, if failed, get the default GUID
	// from the root node
  CTreeNode* pNode = GetTreeNodeFromCookie();
  if (pNode == NULL)
  {
    return E_FAIL;
  }

	const GUID* pNodeType = pNode->GetNodeType();
	if (pNodeType == NULL)
  {
		pNodeType = GetDataFromComponentDataObject()->GetNodeType();
  }

	::StringFromGUID2(*pNodeType,szNodeType,128);
  return Create(szNodeType, BYTE_MEM_LEN_W(szNodeType), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager
	// We get it from the root node.
	CString szDispName;
	szDispName = GetDataFromComponentDataObject()->GetDisplayName();
    return Create(szDispName, (szDispName.GetLength()+1) * sizeof(wchar_t), lpMedium);
}


HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
	// TODO
	ASSERT(m_pUnkComponentData != NULL);
	IPersistStream* pIPersistStream = NULL;
	HRESULT hr = m_pUnkComponentData->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
	if (FAILED(hr))
		return hr;
	ASSERT(pIPersistStream != NULL);
    // Create the CoClass information
	CLSID clsid;
	VERIFY(SUCCEEDED(pIPersistStream->GetClassID(&clsid)));
    hr = Create(reinterpret_cast<const void*>(&clsid), sizeof(CLSID), lpMedium);
	ASSERT(SUCCEEDED(hr));
	pIPersistStream->Release();
	return hr;
}


HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
  HRESULT hr = S_OK;
  INTERNAL * pInt = NULL;
  void * pBuf = NULL;

  UINT size = sizeof(INTERNAL);
  size += sizeof(CTreeNode*) * (m_internal.m_cookie_count);
  pBuf = GlobalAlloc (GPTR, size);
  if (pBuf != NULL)
  {
    pInt = (INTERNAL *) pBuf;
    lpMedium->hGlobal = pBuf;
  
    // copy the data
    pInt->m_type = m_internal.m_type;
    pInt->m_cookie_count = m_internal.m_cookie_count;
  
    pInt->m_p_cookies = (CTreeNode**) ((BYTE *)pInt + sizeof(INTERNAL));
    
    // REVIEWED-2002/03/08-JeffJon-The number of bytes being copied
    // will fit in the supplied buffer

    memcpy (pInt->m_p_cookies, m_internal.m_p_cookies,
            sizeof(CTreeNode*) * (m_internal.m_cookie_count));
    hr = Create(pBuf, size, lpMedium);
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT CDataObject::CreateMultiSelectObject(LPSTGMEDIUM lpMedium)
{
  CTreeNode** cookieArray = NULL;
  cookieArray = (CTreeNode**) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                          m_internal.m_cookie_count*sizeof(CTreeNode*));
  if (!cookieArray) 
  {
    return E_OUTOFMEMORY;
  }

  for (UINT k=0; k<m_internal.m_cookie_count; k++)
  {
    cookieArray[k] = m_internal.m_p_cookies[k];
  }

  BOOL* bDuplicateArr = NULL;
  bDuplicateArr = (BOOL*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                     m_internal.m_cookie_count*sizeof(BOOL));
  if (!bDuplicateArr) 
  {
    if (cookieArray)
    {
      GlobalFree (cookieArray);
    }
    return E_OUTOFMEMORY;
  }

  UINT cCount = 0;
  for (UINT index = 0; index < m_internal.m_cookie_count; index++)
  {
    for (UINT j = 0; j < index; j++)
    {
      GUID Guid1 = *(cookieArray[index]->GetNodeType());
      GUID Guid2 = *(cookieArray[j]->GetNodeType());
      if (IsEqualGUID (Guid1, Guid2)) 
      {
        bDuplicateArr[index] = TRUE;
        break; //repeated GUID
      }
    }
    if (!bDuplicateArr[index])
    {
      cCount++;
    }
  }      

   
  UINT size = sizeof(SMMCObjectTypes) + (cCount) * sizeof(GUID);
  void * pTmp = ::GlobalAlloc(GPTR, size);
  if (!pTmp) 
  {
    if (cookieArray) 
    {
      GlobalFree (cookieArray);
    }
    if (bDuplicateArr) 
    {
      GlobalFree (bDuplicateArr);
    }
    return E_OUTOFMEMORY;
  }
    
  SMMCObjectTypes* pdata = reinterpret_cast<SMMCObjectTypes*>(pTmp);
  pdata->count = cCount;
  UINT i = 0;
  for (index=0; index<m_internal.m_cookie_count; index++)
  {
    if (!bDuplicateArr[index])
    {
      pdata->guid[i++] = *(cookieArray[index]->GetNodeType());
    }
  }
  ASSERT(i == cCount);
  lpMedium->hGlobal = pTmp;

  GlobalFree (cookieArray);
  GlobalFree (bDuplicateArr);

  return S_OK;
}


CRootData* CDataObject::GetDataFromComponentDataObject()
{
	CComponentDataObject* pObject = 
		reinterpret_cast<CComponentDataObject*>(m_pUnkComponentData);
	CRootData* pRootData = pObject->GetRootData();
	ASSERT(pRootData != NULL);
	return pRootData;
}

CTreeNode* CDataObject::GetTreeNodeFromCookie()
{
	CComponentDataObject* pObject = 
		reinterpret_cast<CComponentDataObject*>(m_pUnkComponentData);

	CTreeNode* pNode = NULL;
  if (m_internal.m_cookie_count > 0)
  {
    pNode = m_internal.m_p_cookies[0];
	  if (pNode == NULL)
    {
      return pObject->GetRootData();
    }
  }
	return pNode;
}

void CDataObject::AddCookie(CTreeNode* cookie)
{
  const UINT MEM_CHUNK_SIZE = 10;
  void * pTMP = NULL;

  if ((m_internal.m_cookie_count) % MEM_CHUNK_SIZE == 0) 
  {
    if (m_internal.m_p_cookies != NULL) 
    {
      pTMP = realloc (m_internal.m_p_cookies,
                      (m_internal.m_cookie_count +
                       MEM_CHUNK_SIZE) * sizeof (CTreeNode*));
    } 
    else 
    {
      pTMP = malloc (MEM_CHUNK_SIZE * sizeof (CTreeNode*));
    }
    if (pTMP == NULL) 
    {
      TRACE(_T("CDataObject::AddCookie - malloc/realloc failed.."));
      ASSERT (pTMP != NULL);

      if (m_internal.m_p_cookies)
      {
         free(m_internal.m_p_cookies);
         m_internal.m_p_cookies = 0;
         m_internal.m_cookie_count = 0;
         return;
      }
    }
    else
    {
      m_internal.m_p_cookies = (CTreeNode**)pTMP;
    }
  }
  m_internal.m_p_cookies[m_internal.m_cookie_count] = cookie;
  m_internal.m_cookie_count++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_MTFRMWK_TRACE)
  #if defined(TRACE)
    #undef TRACE
      void MtFrmwkTrace(LPCWSTR, ...);
      #define TRACE MtFrmwkTrace
  #endif
#else
  #if defined(TRACE)
    #undef TRACE
    #define TRACE
  #endif
#endif

#if defined(DBG)

  void MtFrmwkLogFile(LPCTSTR lpszFormat, ...);
  void MtFrmwkLogFileIfLog(BOOL bLog, LPCTSTR lpszFormat, ...);

  //
  // Copied from burnslib on 12-07-1999
  //
  #define TRACET MtFrmwkLogFile                      

  #define TRACE_LOGFILE MtFrmwkLogFile

  #define TRACE_LOGFILE_IF_NO_UI MtFrmwkLogFileIfLog

  #define TRACE_SCOPET(bLog, msg)                               \
      CScopeTracer __tracer(bLog, msg);

  #define TRACE_FUNCTION(func) TRACE_SCOPET(TRUE, TEXT(#func))

  #define TRACE_FUNCTION_IF_NO_UI(bLog, func) TRACE_SCOPET(bLog, TEXT(#func))
#else

  #define TRACET
  #define TRACE_LOGFILE
  #define TRACE_LOGFILE_IF_NO_UI
  #define TRACE_SCOPET(bLog, msg)
  #define TRACE_FUNCTION(func)
  #define TRACE_FUNCTION_IF_NO_UI(bLog, func)

#endif // defined(DBG)

// A ScopeTracer object emits text to the log upon construction and
// destruction.  Place one at the beggining of a lexical scope, and it will
// log when the scope is entered and exited.
//
// See TRACE_SCOPE, TRACE_CTOR, TRACE_DTOR, TRACE_FUNCTION, TRACE_FUNCTION2

class CScopeTracer
{
public:
  CScopeTracer(BOOL bLog, PCWSTR pszMessage);
  ~CScopeTracer();

private:

  CString szMessage;
  BOOL    m_bLog;
};

//
// Log provides an interface to a singleton application logging facility.
//
class CLogFile
{
  friend class CScopeTracer;

public:

  //
  // Returns a pointer to the single CLogFile instance.
  //
  static CLogFile* GetInstance();

  //
  // Closes and deletes the single CLogFile instance.  If GetInstance is
  // called after this point, then a new instance will be created.
  //
  static void KillInstance();

  //
  // Returns true if the log file is open, false if not.
  //
  BOOL IsOpen() const;

  void writeln(PCWSTR pszText);
  void indent();
  void outdent();

private:

  CLogFile(PCWSTR logBaseName);
  ~CLogFile();

  CString  szBase_name;
  HANDLE   file_handle;
  unsigned trace_line_number;

  //
  // not implemented; no instance copying allowed.
  //
  CLogFile(const CLogFile&);
  const CLogFile& operator=(const CLogFile&);
};

#define _USE_MTFRMWK_LOGGING

#if defined(_USE_MTFRMWK_ASSERT)
  #undef ASSERT
  #undef VERIFY
  #undef THIS_FILE
  #define THIS_FILE          __FILE__

  BOOL  MtFrmwkAssertFailedLine(LPCSTR lpszFileName, int nLine);
  #define ASSERT(f) \
	  do \
	  { \
      BOOL bPrefast = (f && L"a hack so that prefast doesn't bark"); \
	    if (!(bPrefast) &&  MtFrmwkAssertFailedLine(THIS_FILE, __LINE__)) \
		    ::DebugBreak(); \
	  } while (0) \

  #define VERIFY(f)          ASSERT(f)

#endif // _USE_MTFRMWK_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\mtfrmwk.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mtfrmwk.rc
//
#define IDM_WHATS_THIS                  52000
#define IDR_WHATS_THIS_CONTEXT_MENU1    52001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        153
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1297
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\snapbase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       snapbase.h
//
//--------------------------------------------------------------------------


#ifndef _SNAPBASE_H
#define _SNAPBASE_H

#include <mtfrmwk.h>
#include <dataobj.h>
#include <proppage.h>
#include <compbase.h>
#include <treedata.h>
#include <stdabout.h>

#endif // _SNAPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\stdabout.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	StdAbout.h
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
	public ISnapinAbout,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
	CSnapinAbout();

// ISnapinAbout
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
	// The following data members MUST be initialized by the constructor
	// of the derived class.
	UINT m_uIdStrDestription;		// Resource Id of the description
	CString m_szProvider;		// String of the provider (ie, Microsoft Corporation)
	CString m_szVersion;			// String of the version of the snapin
	UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
	UINT m_uIdBitmapSmallImage;
	UINT m_uIdBitmapSmallImageOpen;
	UINT m_uIdBitmapLargeImage;
   HBITMAP hBitmapSmallImage;
   HBITMAP hBitmapSmallImageOpen;
   HBITMAP hBitmapLargeImage;

	COLORREF m_crImageMask;

}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\proppage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       proppage.h
//
//--------------------------------------------------------------------------


#ifndef _PROPPAGE_H
#define _PROPPAGE_H

// proppage.h : header file
//


///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CTreeNode; 
class CContainerNode;
class CComponentDataObject;

class CPropertyPageHolderBase;
class CPropertyPageBase; 
class CPropertyPageHolderTable; 
class CWatermarkInfo;
 
typedef CList< CPropertyPageBase*, CPropertyPageBase* > CPropertyPageBaseList;

////////////////////////////////////////////////////////////////////
// CHiddenWndBase : Utility Hidden Window

class CHiddenWndBase : public CWindowImpl<CHiddenWndBase>
{
public:
  DECLARE_WND_CLASS(L"DNSMgrHiddenWindow")

	BOOL Create(HWND hWndParent = NULL); 	
	
	BEGIN_MSG_MAP(CHiddenWndBase)
  END_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSheetWnd

class CSheetWnd : public CHiddenWndBase
{
public:
	static const UINT s_SheetMessage;
	static const UINT s_SelectPageMessage;
	CSheetWnd(CPropertyPageHolderBase* pHolder) { m_pHolder = pHolder;}

  BEGIN_MSG_MAP(CSheetWnd)
    MESSAGE_HANDLER( WM_CLOSE, OnClose )
    MESSAGE_HANDLER( CSheetWnd::s_SheetMessage, OnSheetMessage )
    MESSAGE_HANDLER( CSheetWnd::s_SelectPageMessage, OnSelectPageMessage )
    CHAIN_MSG_MAP(CHiddenWndBase)
  END_MSG_MAP()

  LRESULT OnClose(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
	LRESULT OnSheetMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
	LRESULT OnSelectPageMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 

private:
	CPropertyPageHolderBase* m_pHolder;
};


/////////////////////////////////////////////////////////////////////////////
// CCloseDialogInfo

class CCloseDialogInfo
{
public:
	CCloseDialogInfo()
		{ m_hWnd = NULL; m_dwFlags = 0x0; }
	BOOL CloseDialog(BOOL bCheckForMsgBox);

	static BOOL CCloseDialogInfo::CloseMessageBox(HWND hWndParent);

	HWND m_hWnd;
	DWORD m_dwFlags;
};

/////////////////////////////////////////////////////////////////////////////
// CCloseDialogInfoStack

template <UINT nSize> class CCloseDialogInfoStack
{
public:
	CCloseDialogInfoStack()
	{ 
		m_nTop = 0; // first empty
		m_bForcedClose = FALSE;
	}
	BOOL IsEmpty()
	{
		return m_nTop <= 0;
	}
	BOOL Push(HWND hWnd, DWORD dwFlags)
	{
		ASSERT(hWnd  != NULL);
		ASSERT(::IsWindow(hWnd));
		if (m_nTop >= nSize)
			return FALSE;
		m_arr[m_nTop].m_hWnd = hWnd;
		m_arr[m_nTop].m_dwFlags = dwFlags;
		m_nTop++;
		return TRUE;
	}
	BOOL Pop()
	{
		if (m_bForcedClose)
			return TRUE; // going away
		if (m_nTop <= 0)
			return FALSE;
		m_nTop--;
		return TRUE;
	}
	void ForceClose(HWND hWndPage)
	{
		if (m_bForcedClose)
		{
			return; // avoid reentrancy
		}
		m_bForcedClose = TRUE;
		if (m_nTop > 0)
		{
			// have a stack to unwind
			BOOL bOutermost = TRUE;
			while (m_nTop > 0)
			{
				VERIFY(m_arr[m_nTop-1].CloseDialog(bOutermost));
				bOutermost = FALSE;
				m_nTop--;
			}
		}
		else
		{
			// empty stack, but might have a message box
			HWND hWndSheet = ::GetParent(hWndPage);
			ASSERT(hWndSheet != NULL);
			if (CCloseDialogInfo::CloseMessageBox(hWndSheet))
				VERIFY(::PostMessage(hWndSheet, WM_COMMAND, IDCANCEL, 0));
		}
	}
private:
	UINT m_nTop;
	CCloseDialogInfo m_arr[nSize];
	BOOL m_bForcedClose;
};


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

class CPropertyPageHolderBase
{
public:
// construction
	CPropertyPageHolderBase(CContainerNode* pContNode, CTreeNode* pNode, 
		CComponentDataObject* pComponentData);
	virtual ~CPropertyPageHolderBase();

// initialization
	// common
	void Attach(CPropertyPageHolderBase* pContHolder);
	BOOL EnableSheetControl(UINT nCtrlID, BOOL bEnable);

	// property sheet only
	static HRESULT CreateModelessSheet(CTreeNode* pNode, CComponentDataObject* pComponentData);
	HRESULT CreateModelessSheet(CTreeNode* pCookieNode);
	HRESULT CreateModelessSheet(LPPROPERTYSHEETCALLBACK pSheetCallback, LONG_PTR hConsoleHandle); 
	void SetStartPageCode(int nStartPageCode) 
		{ m_nStartPageCode = nStartPageCode;}

	// wizard only
	HRESULT DoModalWizard();
	INT_PTR DoModalDialog(LPCTSTR pszCaption);

// helpers
	// common
	void SetSheetWindow(HWND hSheetWindow);
  void SetSheetTitle(LPCWSTR lpszSheetTitle);
  void SetSheetTitle(UINT nStringFmtID, CTreeNode* pNode);

	void AddRef();
	void Release();

	DWORD GetRefCount() { return m_nCreatedCount;}
	CComponentDataObject* GetComponentData() { ASSERT(m_pComponentData != NULL); return m_pComponentData;}
  HWND GetMainWindow() { return m_hMainWnd;}

	// get/set for the node we are working on
	CTreeNode* GetTreeNode() { return m_pNode;}
	void SetTreeNode(CTreeNode* pNode) { m_pNode = pNode; }
	// get/set for the container we refer to
	CContainerNode* GetContainerNode() 
	{ 
		return m_pContNode;
	}
	void SetContainerNode(CContainerNode* pContNode) { ASSERT(pContNode != NULL); m_pContNode = pContNode; }
	
	
	BOOL IsWizardMode();
	BOOL IsModalSheet();
	void ForceDestroy();	// forcefull shut down running sheet

	void AddPageToList(CPropertyPageBase* pPage);
	BOOL RemovePageFromList(CPropertyPageBase* pPage, BOOL bDeleteObject);

	// property sheet only
	BOOL PushDialogHWnd(HWND hWndModalDlg);
	BOOL PopDialogHWnd();
	void CloseModalDialogs(HWND hWndPage);

	DWORD NotifyConsole(CPropertyPageBase* pPage);		// notify console of property changes
	void AcknowledgeNotify();							// acknowledge from the console
	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask); // execute from main thread

	// wizard only
	BOOL SetWizardButtons(DWORD dwFlags);
	BOOL SetWizardButtonsFirst(BOOL bValid) 
	{ 
		return SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
	}
	BOOL SetWizardButtonsMiddle(BOOL bValid) 
	{ 
		return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
	}
	BOOL SetWizardButtonsLast(BOOL bValid) 
	{ 
		return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
	}

	HRESULT AddPageToSheet(CPropertyPageBase* pPage);
	HRESULT AddPageToSheetRaw(HPROPSHEETPAGE hPage);
	HRESULT RemovePageFromSheet(CPropertyPageBase* pPage);
	HRESULT AddAllPagesToSheet();

protected:
	// common
	virtual HRESULT OnAddPage(int, CPropertyPageBase*) { return S_OK; }

	// property sheet only
	virtual void OnSheetMessage(WPARAM, LPARAM) {}
	virtual int OnSelectPageMessage(long) { return -1;}

	// wizard only
	void SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo);

private:
	void DeleteAllPages();
	void FinalDestruct();

// attributes
private:
	// common
	CString m_szSheetTitle;					// title for the sheet/wizard window
	CPropertyPageBaseList m_pageList;		// list of property page objects
	CPropertyPageHolderBase* m_pContHolder;	// prop page holder that migh contain this
	CComponentDataObject* m_pComponentData; // cached pointer to CComponentDataImplementation
  HWND m_hMainWnd;  // cached MMC frame window, if present

protected:
	BOOL m_bWizardMode;						// Wizard Mode (i.e. not modeless property sheet)
	BOOL m_bAutoDelete;						// delete itself when refcount goes to zero
	BOOL m_bAutoDeletePages;				// explicitely delete the property page C++ objects

  enum { useDefault, forceOn, forceOff } m_forceContextHelpButton; // setting for the [?] button

private:	
	DWORD	m_nCreatedCount;				// count of how many pages got actually created
	CTreeNode* m_pNode;						// node the pages (or the wizard) refer to
	CContainerNode* m_pContNode;			// container node the pages (or the wizard) refer to
	HWND m_hSheetWindow;					// window handle to the sheet (thread safe)

	// property sheet only
	LONG_PTR    m_hConsoleHandle;				// handle for notifications to console
	HANDLE m_hEventHandle;					// syncronization handle for property notifications
	CSheetWnd*	m_pSheetWnd;				// hidden window CWnd object for messages
	int			m_nStartPageCode;			// starting page code (not necessarily the page #)
	CCloseDialogInfoStack<5> m_dlgInfoStack;	// modal dialogs stack (to close them down)

	// wizard only
	IPropertySheetCallback* m_pSheetCallback; // cached pointer to add/remove pages
	CPropertySheet*			m_pDummySheet;	  // MFC surrogate property sheet for modal operations
	CWatermarkInfo*			m_pWatermarkInfo; // watermark info for Wiz 97 sheets

private:
	// property sheet only
	// variables to use across thread boundaries
	DWORD m_dwLastErr;						// generic error code
	CPropertyPageBase* m_pPropChangePage;	// page for which notification is valid
public:
	void SetError(DWORD dwErr) { m_dwLastErr = dwErr;}
	CPropertyPageBase* GetPropChangePage() 
			{ ASSERT(m_pPropChangePage != NULL); return m_pPropChangePage; }

	friend class CSheetWnd;
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

class CPropertyPageBase : public CPropertyPage
{
// Construction
private:
	CPropertyPageBase(){} // cannot use this constructor
public:
	CPropertyPageBase(UINT nIDTemplate, 
                    UINT nIDCaption = 0);
	virtual ~CPropertyPageBase();

// Overrides
public:
	virtual BOOL OnInitDialog()
	{
		CWinApp* pApp = AfxGetApp();
    ASSERT(pApp);
		return CPropertyPage::OnInitDialog();
	}
	virtual void OnCancel();
	virtual BOOL OnApply();

protected:
// Generated message map functions
	//{{AFX_MSG(CGeneralPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG

  afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnWhatsThis();
  virtual BOOL OnHelp(WPARAM wParam, LPARAM lParam);
  virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
  virtual void OnWizardHelp() {}

	DECLARE_MESSAGE_MAP()

// attributes
public:
	// common
	PROPSHEETPAGE  m_psp97;
	HPROPSHEETPAGE m_hPage; 
	void SetHolder(CPropertyPageHolderBase* pPageHolder)
	{ ASSERT((pPageHolder != NULL) && (m_pPageHolder == NULL)); m_pPageHolder = pPageHolder;}
	CPropertyPageHolderBase* GetHolder() { return m_pPageHolder;};

	// property seet only
	virtual BOOL OnPropertyChange(BOOL, long*) // execute from main thread
						{ return FALSE; /* do not repaint UI */ } 

	// wizard only
	UINT m_nPrevPageID;	// to be used by OnWizardBack()

	void InitWiz97(
      BOOL bHideHeader, 
      UINT nIDHeaderTitle, 
      UINT nIDHeaderSubTitle,
      bool hasHelp = false);

private:
	CString m_szHeaderTitle;
	CString m_szHeaderSubTitle;

protected:
	virtual void SetUIData(){}
	virtual void GetUIData(){}
  virtual LONG GetUIDataEx() { return 0;}
	virtual void SetDirty(BOOL bDirty);
	BOOL IsDirty() { return m_bIsDirty; }

private:
	CPropertyPageHolderBase* m_pPageHolder; // backpointer to holder
	BOOL m_bIsDirty;							// dirty flag

  HWND  m_hWndWhatsThis;  // hwnd of right click "What's this" help
};




/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderTable

class CPropertyPageHolderTable
{
public:
	CPropertyPageHolderTable(CComponentDataObject* pComponentData);
	~CPropertyPageHolderTable(); 

	void Add(CPropertyPageHolderBase* pPPHolder);
	void AddWindow(CPropertyPageHolderBase* pPPHolder, HWND hWnd);
	void Remove(CPropertyPageHolderBase* pPPHolder);

	void DeleteSheetsOfNode(CTreeNode* pNode);

	void WaitForAllToShutDown();

	// sheet notification mechanism
	void BroadcastMessageToSheets(CTreeNode* pNode, WPARAM wParam, LPARAM lParam);
	void BroadcastSelectPage(CTreeNode* pNode, long nPageCode);
	int  BroadcastCloseMessageToSheets(CTreeNode* pNode);

	struct PPAGE_HOLDER_TABLE_ENTRY
	{
		CPropertyPageHolderBase* pPPHolder;
		CTreeNode* pNode;
		HWND hWnd;
	};
	
	PPAGE_HOLDER_TABLE_ENTRY* GetPageHolderTableEntry(){return m_pEntries;}
	int GetPageHolderTableEntrySize(){return m_nSize;}

private:
	CComponentDataObject* m_pComponentData; // back pointer

	void WaitForSheetShutdown(int nCount, HWND* hWndArr = NULL);


	PPAGE_HOLDER_TABLE_ENTRY* m_pEntries;
	int m_nSize;
};


////////////////////////////////////////////////////////////
// CHelpDialog

class CHelpDialog : public CDialog
{
// Construction
private:
	CHelpDialog(){}
public:
	CHelpDialog(UINT nIDTemplate, CComponentDataObject* pComponentData);
  CHelpDialog(UINT nIDTemplate, CWnd* pParentWnd, CComponentDataObject* pComponentData);
  virtual ~CHelpDialog() {};

  virtual void OnOK() { CDialog::OnOK(); }

protected:
  afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnWhatsThis();
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	
	DECLARE_MESSAGE_MAP()

private:
  HWND  m_hWndWhatsThis;  // hwnd of right click "What's this" help
  CComponentDataObject* m_pComponentData;
};

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\proppag_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proppag_.cpp
//
//--------------------------------------------------------------------------



//////////////////////////////////////////////////////////////////////////
// private helper functions

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
                                LPARAM lParam /* pass a HWND* for return value*/ )
{
    ASSERT(hwnd);
    HWND hParentWnd = GetParent(hwnd);
    // the main window of the MMC console should staitsfy this condition
    if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
    {
        HWND* pH = (HWND*)lParam;
        *pH = hwnd;
        return FALSE; // stop enumerating
    }
    return TRUE;
}



HWND FindMMCMainWindow()
{
    DWORD dwThreadID = ::GetCurrentThreadId();
    ASSERT(dwThreadID != 0);
    HWND hWnd = NULL;
    EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
    
    ASSERT(hWnd != NULL);
    return hWnd;
}

////////////////////////////////////////////////////////////////////
// CHiddenWndBase : Utility Hidden Window


BOOL CHiddenWndBase::Create(HWND hWndParent)
{
  ASSERT(hWndParent == NULL || ::IsWindow(hWndParent));
  RECT rcPos;
  ZeroMemory(&rcPos, sizeof(RECT));
  HWND hWnd = CWindowImpl<CHiddenWndBase>::Create(hWndParent, 
                      rcPos, //RECT& rcPos, 
                      NULL,  //LPCTSTR szWindowName = NULL, 
                      (hWndParent) ? WS_CHILD : WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE, 
                      0x0,   //DWORD dwExStyle = 0, 
                      0      //UINT nID = 0 
                      );
  return hWnd != NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSheetWnd

const UINT CSheetWnd::s_SheetMessage = WM_USER + 100;
const UINT CSheetWnd::s_SelectPageMessage = WM_USER + 101;

LRESULT CSheetWnd::OnSheetMessage(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    ASSERT(m_pHolder != NULL);
    m_pHolder->OnSheetMessage(wParam,lParam);
    return 1;
}

LRESULT CSheetWnd::OnSelectPageMessage(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    TRACE(_T("CSheetWnd::OnSelectPageMessage()\n"));
    ASSERT(m_pHolder != NULL);
    int nPage = m_pHolder->OnSelectPageMessage((long)wParam);
    if (nPage >= 0)
    {
        // can use SendMessage() because the sheet has been created already
        VERIFY(PropSheet_SetCurSel(m_pHolder->m_hSheetWindow, NULL, nPage));
    }
   ::SetForegroundWindow(::GetParent(m_hWnd));
    return 1;
}

LRESULT CSheetWnd::OnClose(UINT, WPARAM, LPARAM, BOOL&)
{
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
// CCloseDialogInfo


struct FIND_MSG_BOX_INFO
{
    LPCTSTR lpszTitle;
    HWND hWnd;
    HWND hWndParent;
};

BOOL CALLBACK EnumMessageBoxProc(HWND hwnd, LPARAM lParam)
{
    static const size_t BuffSizeInCharacters = 256;

    FIND_MSG_BOX_INFO* pInfo = (FIND_MSG_BOX_INFO*)lParam;
    if (::GetParent(hwnd) != pInfo->hWndParent)
        return TRUE;

    TCHAR szTitle[BuffSizeInCharacters] = {0};
    ::GetWindowText(hwnd, szTitle, BuffSizeInCharacters);
    TRACE(_T("Title <%s>\n"), szTitle);

    if (_wcsnicmp(szTitle, pInfo->lpszTitle, BuffSizeInCharacters) == 0)
    {
        pInfo->hWnd = hwnd;
        return FALSE;
    }
    return TRUE;
}


HWND FindMessageBox(LPCTSTR lpszTitle, HWND hWndParent)
{
    FIND_MSG_BOX_INFO info;
    info.hWndParent = hWndParent;
    info.lpszTitle = lpszTitle;
    info.hWnd = NULL;
    EnumWindows(EnumMessageBoxProc, (LPARAM)&info);
    if (info.hWnd != NULL)
        return info.hWnd;
    return NULL;
}

BOOL CCloseDialogInfo::CloseMessageBox(HWND hWndParent)
{
    BOOL bClosed = FALSE;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    LPCTSTR lpszMsgBoxTitle = AfxGetApp()->m_pszAppName;
    HWND hWndMessageBox = FindMessageBox(lpszMsgBoxTitle, hWndParent);
    if (hWndMessageBox != NULL)
    {
        // figure out if there is a cancel button or not
        HWND hWndCtrl = ::GetDlgItem(hWndMessageBox, IDCANCEL);
        if (hWndCtrl != NULL)
        {
            VERIFY(::SendMessage(hWndMessageBox, WM_CLOSE, 0, 0) == 0);
            bClosed = TRUE;
        }
        else
        {
            // does it have just the OK button?
            hWndCtrl = ::GetDlgItem(hWndMessageBox, IDOK);
            if (hWndCtrl != NULL)
            {
                VERIFY(::SendMessage(hWndMessageBox, WM_COMMAND, IDOK, 0) == 0);
                bClosed = TRUE;
            }
            else
            {
                // does it have a NO button?
                hWndCtrl = ::GetDlgItem(hWndMessageBox, IDNO);
                if (hWndCtrl != NULL)
                {
                    VERIFY(::SendMessage(hWndMessageBox, WM_COMMAND, IDNO, 0) == 0);
                    bClosed = TRUE;
                }
            }
        }
    }
    return bClosed;
}

BOOL CCloseDialogInfo::CloseDialog(BOOL bCheckForMsgBox)
{
    if (bCheckForMsgBox)
        CloseMessageBox(m_hWnd);
    return (::SendMessage(m_hWnd, WM_CLOSE, 0, 0) == 0);
}



/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

CPropertyPageHolderBase::CPropertyPageHolderBase(CContainerNode* pContNode, CTreeNode* pNode,
        CComponentDataObject* pComponentData)
{
    m_szSheetTitle = (LPCWSTR)NULL;
    m_pDummySheet = NULL;

    // default setting for a self deleting modeless property sheet,
    // automatically deleting all the pages
    m_bWizardMode = FALSE;
    m_bAutoDelete = TRUE;
    m_bAutoDeletePages = TRUE;

    m_forceContextHelpButton = useDefault;

    m_pContHolder = NULL;
    m_nCreatedCount = 0;
    m_hSheetWindow = NULL;
    m_pSheetWnd = NULL;
    m_nStartPageCode = -1; // not set
    m_hConsoleHandle = 0;
    m_hEventHandle = NULL;
    m_pSheetCallback = NULL;

    // setup from arguments
    // For tasks in can be null ASSERT(pContNode != NULL); // must always have a valid container node to refer to
    m_pContNode = pContNode;
    ASSERT((pNode == NULL) || (pNode->GetContainer() == m_pContNode) );
    m_pNode = pNode;
    ASSERT(pComponentData != NULL);
    m_pComponentData = pComponentData;

  m_hMainWnd = NULL;
  LPCONSOLE pConsole = m_pComponentData->GetConsole();
  if (pConsole != NULL)
  {
    pConsole->GetMainWindow(&m_hMainWnd);
  }

    m_dwLastErr = 0x0;
    m_pPropChangePage = NULL;
    m_pWatermarkInfo = NULL;
}

CPropertyPageHolderBase::~CPropertyPageHolderBase()
{
    FinalDestruct();
    ASSERT(m_pSheetWnd == NULL);
    SAFE_RELEASE(m_pSheetCallback);
    if (m_hEventHandle != NULL)
    {
        VERIFY(::CloseHandle(m_hEventHandle));
        m_hEventHandle = NULL;
    }
    if (m_pDummySheet != NULL)
        delete m_pDummySheet;
}

void CPropertyPageHolderBase::Attach(CPropertyPageHolderBase* pContHolder)
{
    ASSERT( (m_pContHolder == NULL) && (pContHolder != NULL) );
    m_pContHolder = pContHolder;
    m_bWizardMode = pContHolder->IsWizardMode();
}

BOOL CPropertyPageHolderBase::EnableSheetControl(UINT nCtrlID, BOOL bEnable)
{
    if (m_pContHolder != NULL)
    {
        return m_pContHolder->EnableSheetControl(nCtrlID, bEnable);
    }
    ASSERT(::IsWindow(m_hSheetWindow));
    HWND hWndCtrl = ::GetDlgItem(m_hSheetWindow, nCtrlID);
    if (hWndCtrl == NULL)
        return FALSE;
    return ::EnableWindow(hWndCtrl, bEnable);
}

HRESULT CPropertyPageHolderBase::CreateModelessSheet(CTreeNode* pNode, CComponentDataObject* pComponentData)
{
    ASSERT(pNode != NULL);
    ASSERT(pComponentData != NULL);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // get an interface to a sheet provider
    IPropertySheetProvider* pSheetProvider;
    HRESULT hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&pSheetProvider);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pSheetProvider != NULL);

    // get an interface to a sheet callback
    IPropertySheetCallback* pSheetCallback;
    hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&pSheetCallback);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pSheetCallback != NULL);

    // create a data object for this node
    IDataObject* pDataObject;
    hr = pComponentData->QueryDataObject((MMC_COOKIE)pNode, CCT_SCOPE, &pDataObject);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pDataObject != NULL);

    // get a sheet
    hr = pSheetProvider->CreatePropertySheet(_T("SHEET TITLE"), TRUE, (MMC_COOKIE)pNode, pDataObject, 0x0 /*dwOptions*/);
    ASSERT(SUCCEEDED(hr));
    pDataObject->Release();

  HWND hWnd = NULL;
    hr = pComponentData->GetConsole()->GetMainWindow(&hWnd);
    ASSERT(SUCCEEDED(hr));
    ASSERT(hWnd == ::FindMMCMainWindow());

    IUnknown* pUnkComponentData = pComponentData->GetUnknown(); // no addref
    hr = pSheetProvider->AddPrimaryPages(pUnkComponentData,
                                            TRUE /*bCreateHandle*/,
                                            hWnd,
                                            TRUE /* bScopePane*/);
    ASSERT(SUCCEEDED(hr));

    hr = pSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
    ASSERT(SUCCEEDED(hr));

    // final interface release
    pSheetProvider->Release();
    pSheetCallback->Release();
    return hr;
}





HRESULT CPropertyPageHolderBase::CreateModelessSheet(CTreeNode* pCookieNode)
{
    ASSERT(!IsWizardMode());
    ASSERT(m_pContHolder == NULL);
    ASSERT(m_pComponentData != NULL);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // get an interface to a sheet provider
    IPropertySheetProvider* pSheetProvider;
    HRESULT hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&pSheetProvider);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pSheetProvider != NULL);

    // get an interface to a sheet callback
    IPropertySheetCallback* pSheetCallback;
    hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&pSheetCallback);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pSheetCallback != NULL);

    // create a data object for this node
    IDataObject* pDataObject;
    hr = m_pComponentData->QueryDataObject((MMC_COOKIE)pCookieNode, CCT_SCOPE, &pDataObject);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pDataObject != NULL);

    // get a sheet
    hr = pSheetProvider->CreatePropertySheet(m_szSheetTitle, TRUE, (MMC_COOKIE)pCookieNode, pDataObject, 0x0 /*dwOptions*/);
    ASSERT(SUCCEEDED(hr));
    pDataObject->Release();

    HWND hWnd = GetMainWindow();
    ASSERT(hWnd == ::FindMMCMainWindow());

    IUnknown* pUnkComponentData = m_pComponentData->GetUnknown(); // no addref
    hr = pSheetProvider->AddPrimaryPages(pUnkComponentData,
                                            TRUE /*bCreateHandle*/,
                                            NULL /*hWnd*/,
                                            FALSE /* bScopePane*/);
    ASSERT(SUCCEEDED(hr));

    hr = pSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
    ASSERT(SUCCEEDED(hr));

    // final interface release
    pSheetProvider->Release();
    pSheetCallback->Release();
    return hr;
}



HRESULT CPropertyPageHolderBase::CreateModelessSheet(LPPROPERTYSHEETCALLBACK pSheetCallback, LONG_PTR hConsoleHandle)
{
    ASSERT(m_pContHolder == NULL);
    ASSERT(pSheetCallback != NULL);
    ASSERT(m_pSheetCallback == NULL);

  //
  // REVIEW_JEFFJON : seems to be NULL when called from CComponentDataObject::CreatePropertySheet()
  //
    m_hConsoleHandle = hConsoleHandle;

    m_bWizardMode = FALSE; // we go modeless
    ASSERT(m_pNode != NULL);
    CPropertyPageHolderTable* pPPHTable = m_pComponentData->GetPropertyPageHolderTable();
    ASSERT(pPPHTable != NULL);

    // add the property sheet holder to the holder table
    pPPHTable->Add(this);
    // notify the node it has a sheet up
    m_pNode->OnCreateSheet();

    // temporarily attach the sheet callback to this object to add pages
    // do not addref, we will not hold on to it;
    m_pSheetCallback = pSheetCallback;
    
    HRESULT hr = AddAllPagesToSheet();
    m_pSheetCallback = NULL; // detach
    return hr;
}

void CPropertyPageHolderBase::SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo)
{
    ASSERT(m_pWatermarkInfo == NULL);
    ASSERT(pWatermarkInfo != NULL);
}

HRESULT CPropertyPageHolderBase::DoModalWizard()
{
    ASSERT(m_pContHolder == NULL);
    ASSERT(m_pComponentData != NULL);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_bWizardMode = TRUE;

    // get an interface to a sheet provider
    IPropertySheetProvider* pSheetProvider;
    HRESULT hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&pSheetProvider);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pSheetProvider != NULL);

    // get an interface to a sheet callback
    IPropertySheetCallback* pSheetCallback;
    hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&pSheetCallback);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pSheetCallback != NULL);
    m_pSheetCallback = pSheetCallback; // save to add/remove pages

    // Create a dummy data object. AddPrimaryPages will call
    // IextendPropertySheet2::QueryPagesFor() and
    // IextendPropertySheet2::CreatePropertyPages()
    // that will ignore the un-initialized data object
    MMC_COOKIE cookie = -1;
    DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
    IDataObject* pDataObject;
    hr = m_pComponentData->QueryDataObject(cookie, type, &pDataObject);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pDataObject != NULL);


    // Switch Watermark information, AddPrimaryPages will call
    // IextendPropertySheet2::GetWatermarks()
    CWatermarkInfo* pOldWatermarkInfo = NULL;
    if (m_pWatermarkInfo != NULL)
        pOldWatermarkInfo = m_pComponentData->SetWatermarkInfo(m_pWatermarkInfo);

    // create sheet
    hr = pSheetProvider->CreatePropertySheet( m_szSheetTitle, FALSE /* wizard*/,
                            (MMC_COOKIE)cookie, pDataObject, MMC_PSO_NEWWIZARDTYPE /*dwOptions*/);
    ASSERT(SUCCEEDED(hr));

    // add pages to sheet
    hr = AddAllPagesToSheet();
    ASSERT(SUCCEEDED(hr));

    // add pages
    hr = pSheetProvider->AddPrimaryPages((IExtendPropertySheet2*)m_pComponentData, FALSE, NULL,FALSE);
    ASSERT(SUCCEEDED(hr));

    // restore the old watermark info
    if (pOldWatermarkInfo != NULL)
        m_pComponentData->SetWatermarkInfo(pOldWatermarkInfo);

    // for further dynamic page manipulation, don't use the Console's sheet callback interface
    // but resurt to the Win32 API's
    m_pSheetCallback->Release();
    m_pSheetCallback = NULL;

    // show the modal wizard
    HWND hWnd = GetMainWindow();
    ASSERT(hWnd != NULL);
    hr = pSheetProvider->Show((LONG_PTR)hWnd, 0);
    ASSERT(SUCCEEDED(hr));

    pSheetProvider->Release();
    pDataObject->Release();

    return hr;
}


INT_PTR CPropertyPageHolderBase::DoModalDialog(LPCTSTR pszCaption)
{
    ASSERT(m_pDummySheet == NULL);
    m_bWizardMode = TRUE;
    m_bAutoDelete = FALSE; // use on the stack
    m_pDummySheet = new CPropertySheet();
    m_pDummySheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;
    m_pDummySheet->m_psh.pszCaption = pszCaption;
    VERIFY(SUCCEEDED(AddAllPagesToSheet()));
    return m_pDummySheet->DoModal();
}

void CPropertyPageHolderBase::SetSheetWindow(HWND hSheetWindow)
{
    ASSERT(hSheetWindow != NULL);
    if (m_pContHolder != NULL)
    {
        // we will use the HWND of the parent holder
        m_pContHolder->SetSheetWindow(hSheetWindow);
        return;
    }
    ASSERT( (m_hSheetWindow == NULL) || ((m_hSheetWindow == hSheetWindow)) );
    m_hSheetWindow = hSheetWindow;

    if (IsWizardMode())
    {
    if (m_forceContextHelpButton != useDefault)
    {
      DWORD dwStyle = ::GetWindowLong(m_hSheetWindow, GWL_EXSTYLE);
      if (m_forceContextHelpButton == forceOn)
      {
        dwStyle |= WS_EX_CONTEXTHELP; // force the [?] button
      }
      else
      {
        ASSERT(m_forceContextHelpButton == forceOff);
        dwStyle &= ~WS_EX_CONTEXTHELP; // get rid of the [?] button
      }
      ::SetWindowLong(m_hSheetWindow, GWL_EXSTYLE, dwStyle);
    }

        if (m_pDummySheet != NULL)
        {
            VERIFY(PushDialogHWnd(m_hSheetWindow));
        }
        return;
    }
    // hook up hidden window only when in sheet mode
    if(m_pSheetWnd == NULL)
    {
        CWinApp* pApp = AfxGetApp();
    ASSERT(pApp);
        ASSERT(!IsWizardMode());
        m_pSheetWnd = new CSheetWnd(this);
        VERIFY(m_pSheetWnd->Create(hSheetWindow));

        ASSERT(::GetParent(m_pSheetWnd->m_hWnd) == hSheetWindow);
        GetComponentData()->OnCreateSheet(this, m_pSheetWnd->m_hWnd);
        if (m_nStartPageCode > -1)
        {
            // we do a PostMessage() because we are in to middle of a page creation
            // and MFC does not digest this
            ::PostMessage(m_hSheetWindow, PSM_SETCURSEL, OnSelectPageMessage(m_nStartPageCode), NULL);
        }
        
    // if needed, set the wizard title
    if (!m_szSheetTitle.IsEmpty())
    {
      ::SetWindowText(m_hSheetWindow, (LPCWSTR)m_szSheetTitle);
    }
    }
}

void CPropertyPageHolderBase::SetSheetTitle(LPCWSTR lpszSheetTitle)
{
  ASSERT(!IsWizardMode());

    if (m_pContHolder != NULL)
    {
        // defer to parent holder
        m_pContHolder->SetSheetTitle(lpszSheetTitle);
        return;
    }
  m_szSheetTitle = lpszSheetTitle;

  // if the sheet has been created already, set right away
  if (m_hSheetWindow != NULL && !m_szSheetTitle.IsEmpty())
  {
    ::SetWindowText(m_hSheetWindow, (LPCWSTR)m_szSheetTitle);
  }
}

void CPropertyPageHolderBase::SetSheetTitle(UINT nStringFmtID, CTreeNode* pNode)
{
  ASSERT(!IsWizardMode());

    if (m_pContHolder != NULL)
    {
        // defer to parent holder
        m_pContHolder->SetSheetTitle(nStringFmtID, pNode);
        return;
    }

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString szFmt;
  VERIFY(szFmt.LoadString(nStringFmtID));
  m_szSheetTitle.Format((LPCWSTR)szFmt, pNode->GetDisplayName());

  // if the sheet has been created already, set right away
  if (m_hSheetWindow != NULL && !m_szSheetTitle.IsEmpty())
  {
    ::SetWindowText(m_hSheetWindow, (LPCWSTR)m_szSheetTitle);
  }
}


void CPropertyPageHolderBase::AddRef()
{
    if(m_pContHolder != NULL)
    {
        m_pContHolder->AddRef();
        return;
    }
    m_nCreatedCount++;
}
void CPropertyPageHolderBase::Release()
{
    if(m_pContHolder != NULL)
    {
        m_pContHolder->Release();
        return;
    }
    m_nCreatedCount--;
    if (m_nCreatedCount > 0)
        return;

    if(IsWizardMode())
    {
        if (m_pDummySheet != NULL)
            VERIFY(PopDialogHWnd());
    }
    else
    {
        // hidden window created only in sheet mode
        if (m_pSheetWnd != NULL)
        {
      if (m_pSheetWnd->m_hWnd != NULL)
              m_pSheetWnd->DestroyWindow();
        }
    }
    if (m_bAutoDelete)
        delete this;
}

BOOL CPropertyPageHolderBase::IsWizardMode()
{
    if(m_pContHolder != NULL)
    {
        return m_pContHolder->IsWizardMode();
    }
    return m_bWizardMode;
}

BOOL CPropertyPageHolderBase::IsModalSheet()
{
    if(m_pContHolder != NULL)
    {
        return m_pContHolder->IsModalSheet();
    }
    return m_pDummySheet != NULL;
}


void CPropertyPageHolderBase::ForceDestroy()
{
    ASSERT(!IsWizardMode()); // should never occur on modal wizard

    // contained by other holder
    if (m_pContHolder != NULL)
    {
        ASSERT(!m_bAutoDelete); // container responsible for deleting this holder
        m_pContHolder->ForceDestroy();
        return;
    }

    // this is the primary holder
    ASSERT(m_bAutoDelete); // should be self deleting sheet
    HWND hSheetWindow = m_hSheetWindow;
    if (hSheetWindow != NULL)
    {
        ASSERT(::IsWindow(hSheetWindow));
        // this message will cause the sheet to close all the pages,
        // and eventually the destruction of "this"
        VERIFY(::PostMessage(hSheetWindow, WM_COMMAND, IDCANCEL, 0L) != 0);
    }
    else
    {
        // explicitely delete "this", there is no sheet created
        delete this;
    }
}

DWORD CPropertyPageHolderBase::NotifyConsole(CPropertyPageBase* pPage)
{

    if(m_pContHolder != NULL)
    {
        return m_pContHolder->NotifyConsole(pPage);
    }

    ASSERT(m_pNode != NULL);
    if (IsWizardMode())
    {
        ASSERT(m_hConsoleHandle == NULL);
        return 0x0;
    }
    
    m_pPropChangePage = pPage; // to pass to the main thread
    m_dwLastErr = 0x0;

    if (m_hEventHandle == NULL)
    {
        // REVIEWED-2002/03/08-JeffJon-Squatting isn't an issue here because this is not a
      // named event

      m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
        ASSERT(m_hEventHandle != NULL);
    }

  if (m_hConsoleHandle != NULL)
  {
      MMCPropertyChangeNotify(m_hConsoleHandle, reinterpret_cast<LPARAM>(this));

      DWORD dwRet;
      do
      {
          ASSERT(::IsWindow(m_hSheetWindow));
          dwRet = MsgWaitForMultipleObjects(1,&m_hEventHandle,FALSE,INFINITE, QS_SENDMESSAGE);
          if(dwRet == (WAIT_OBJECT_0+1))
          {
              MSG tempMSG;
              PeekMessage(&tempMSG,m_hSheetWindow,0,0,PM_NOREMOVE);
          }
      }
      while(dwRet == (WAIT_OBJECT_0+1));
  }

    VERIFY(0 != ::ResetEvent(m_hEventHandle));

    m_pPropChangePage = NULL; // reset
    return m_dwLastErr;
}

void CPropertyPageHolderBase::AcknowledgeNotify()
{
    if(m_pContHolder != NULL)
    {
        m_pContHolder->AcknowledgeNotify();
        return;
    }
    ASSERT(!IsWizardMode());
    ASSERT(m_hEventHandle != NULL);
    //TRACE(_T("before SetEvent\n"));
    VERIFY(0 != ::SetEvent(m_hEventHandle));
    //TRACE(_T("after SetEvent\n"));
}

BOOL CPropertyPageHolderBase::OnPropertyChange(BOOL bScopePane, long* pChangeMask)
{
    ASSERT(!IsWizardMode());
    CPropertyPageBase* pPage = GetPropChangePage();
    if (pPage == NULL)
        return FALSE;
    return pPage->OnPropertyChange(bScopePane, pChangeMask);
}


BOOL CPropertyPageHolderBase::SetWizardButtons(DWORD dwFlags)
{
    ASSERT(IsWizardMode());
    if (m_pContHolder != NULL)
    {
        ASSERT(m_hSheetWindow == NULL);
        return m_pContHolder->SetWizardButtons(dwFlags);
    }
    ASSERT(::IsWindow(m_hSheetWindow));
    return (BOOL)SendMessage(m_hSheetWindow, PSM_SETWIZBUTTONS, 0, dwFlags);
}

HRESULT CPropertyPageHolderBase::AddPageToSheet(CPropertyPageBase* pPage)
{
    if (m_pContHolder != NULL)
    {
        ASSERT(m_hSheetWindow == NULL);
        return m_pContHolder->AddPageToSheet(pPage);
    }

    CWinApp* pApp = AfxGetApp();
  ASSERT(pApp);
    if (m_pSheetCallback != NULL)
    {
        VERIFY(SUCCEEDED(MMCPropPageCallback((void*)(&pPage->m_psp97))));
    }

    HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&pPage->m_psp97);
    if (hPage == NULL)
        return E_UNEXPECTED;
    pPage->m_hPage = hPage;
    if (m_pSheetCallback != NULL)
        return m_pSheetCallback->AddPage(hPage);
    else if (m_pDummySheet != NULL)
    {
        m_pDummySheet->AddPage(pPage);
        return S_OK;
    }
    else
    {
        ASSERT(::IsWindow(m_hSheetWindow));
        return PropSheet_AddPage(m_hSheetWindow, hPage) ? S_OK : E_FAIL;
    }
}

HRESULT CPropertyPageHolderBase::AddPageToSheetRaw(HPROPSHEETPAGE hPage)
{
    ASSERT(m_pSheetCallback != NULL);
    if ((hPage == NULL) || (m_pSheetCallback == NULL))
        return E_INVALIDARG;

    if (m_pContHolder != NULL)
    {
        ASSERT(m_hSheetWindow == NULL);
        return m_pContHolder->AddPageToSheetRaw(hPage);
    }

    // assume this is not a n MFC property page
    return m_pSheetCallback->AddPage(hPage);
}




HRESULT CPropertyPageHolderBase::RemovePageFromSheet(CPropertyPageBase* pPage)
{
    if (m_pContHolder != NULL)
    {
        ASSERT(m_hSheetWindow == NULL);
        return m_pContHolder->RemovePageFromSheet(pPage);
    }

    ASSERT(pPage->m_hPage != NULL);
    if (m_pSheetCallback != NULL)
        return m_pSheetCallback->RemovePage(pPage->m_hPage);
    else
    {
        ASSERT(::IsWindow(m_hSheetWindow));
        PropSheet_RemovePage(m_hSheetWindow, 0, pPage->m_hPage); // returns void
        return S_OK;
    }
}

HRESULT CPropertyPageHolderBase::AddAllPagesToSheet()
{
    POSITION pos;
    int nPage = 0;
    HRESULT hr = OnAddPage(nPage, NULL); // zero means add before the first
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
        
    for( pos = m_pageList.GetHeadPosition(); pos != NULL; )
    {
        CPropertyPageBase* pPropPage = m_pageList.GetNext(pos);
        hr = AddPageToSheet(pPropPage);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
        nPage++;
        hr = OnAddPage(nPage, pPropPage); // get called on nPage == 1,2, n-1
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }
    // add after the last
    return OnAddPage(-1, NULL); // -1 means
}


void CPropertyPageHolderBase::AddPageToList(CPropertyPageBase* pPage)
{
    ASSERT(pPage != NULL);
    pPage->SetHolder(this);
    m_pageList.AddTail(pPage);
}

BOOL CPropertyPageHolderBase::RemovePageFromList(CPropertyPageBase* pPage, BOOL bDeleteObject)
{
    ASSERT(pPage != NULL);
    POSITION pos = m_pageList.Find(pPage);
    if (pos == NULL)
        return FALSE;
    m_pageList.RemoveAt(pos);
    if (bDeleteObject)
        delete pPage;
    return TRUE;
}


void CPropertyPageHolderBase::DeleteAllPages()
{
    if (!m_bAutoDeletePages)
        return;
    // assume all pages out of the heap
    while (!m_pageList.IsEmpty())
    {
        delete m_pageList.RemoveTail();
    }
}

void CPropertyPageHolderBase::FinalDestruct()
{
    DeleteAllPages();
    if (IsWizardMode() || (m_pContHolder != NULL))
        return;

    if (m_hConsoleHandle != NULL)
  {
    MMCFreeNotifyHandle(m_hConsoleHandle);
  }

    // tell the component data object that the sheet is going away
    GetComponentData()->OnDeleteSheet(this,m_pNode);

    if (m_pSheetWnd != NULL)
    {
        delete m_pSheetWnd;
        m_pSheetWnd = NULL;
    }
    ASSERT(m_dlgInfoStack.IsEmpty());
}

BOOL CPropertyPageHolderBase::PushDialogHWnd(HWND hWndModalDlg)
{
    return m_dlgInfoStack.Push(hWndModalDlg, 0x0);
}

BOOL CPropertyPageHolderBase::PopDialogHWnd()
{
    return m_dlgInfoStack.Pop();
}


void CPropertyPageHolderBase::CloseModalDialogs(HWND hWndPage)
{
    m_dlgInfoStack.ForceClose(hWndPage);
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

BEGIN_MESSAGE_MAP(CPropertyPageBase, CPropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()


CPropertyPageBase::CPropertyPageBase(UINT nIDTemplate, 
                                     UINT nIDCaption) :
                        CPropertyPage(nIDTemplate, nIDCaption)
{
    m_hPage = NULL;
    m_pPageHolder = NULL;
    m_bIsDirty = FALSE;
    m_nPrevPageID = 0;

    // hack to have new struct size with old MFC and new NT 5.0 headers
    ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE));
    
   // REVIEWED-2002/03/08-JeffJon-This is acceptable usage

   memcpy(&m_psp97, &m_psp, m_psp.dwSize);
    m_psp97.dwSize = sizeof(PROPSHEETPAGE);
}


CPropertyPageBase::~CPropertyPageBase()
{
}

int CPropertyPageBase::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    m_pPageHolder->AddRef();
    int res = CPropertyPage::OnCreate(lpCreateStruct);
    ASSERT(res == 0);
    ASSERT(m_hWnd != NULL);
    ASSERT(::IsWindow(m_hWnd));
    HWND hParent = ::GetParent(m_hWnd);
    ASSERT(hParent);
    m_pPageHolder->SetSheetWindow(hParent);
    return res;
}

void CPropertyPageBase::OnDestroy()
{
    ASSERT(m_hWnd != NULL);
    CPropertyPage::OnDestroy();
    m_pPageHolder->Release();
}

void CPropertyPageBase::OnWhatsThis()
{
  //
  // Display context help for a control
  //
  if ( m_hWndWhatsThis )
  {
    //
    // Build our own HELPINFO struct to pass to the underlying
    // CS help functions built into the framework
    //
    int iCtrlID = ::GetDlgCtrlID(m_hWndWhatsThis);
    HELPINFO helpInfo;
    ZeroMemory(&helpInfo, sizeof(HELPINFO));
    helpInfo.cbSize = sizeof(HELPINFO);
    helpInfo.hItemHandle = m_hWndWhatsThis;
    helpInfo.iCtrlId = iCtrlID;

      m_pPageHolder->GetComponentData()->OnDialogContextHelp(m_nIDHelp, &helpInfo);
  }
}

BOOL CPropertyPageBase::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

  if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
  {
    //
    // Display context help for a control
    //
      m_pPageHolder->GetComponentData()->OnDialogContextHelp(m_nIDHelp, pHelpInfo);
  }

  return TRUE;
}

void CPropertyPageBase::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
  //
  // point is in screen coordinates
  //

  CMenu bar;
    if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
    {
        CMenu& popup = *bar.GetSubMenu (0);
        ASSERT(popup.m_hMenu);

        if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
               point.x,     // in screen coordinates
                 point.y,     // in screen coordinates
               this) )      // route commands through main window
        {
            m_hWndWhatsThis = 0;
            ScreenToClient (&point);
            CWnd* pChild = ChildWindowFromPoint (point,  // in client coordinates
                                                     CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
            if ( pChild )
      {
                m_hWndWhatsThis = pChild->m_hWnd;
      }
      }
    }
}

BOOL CPropertyPageBase::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
   NMHDR* hdr = reinterpret_cast<NMHDR*>(lParam);

   if (hdr &&
       hdr->code == PSN_HELP)
   {
      OnWizardHelp();
   }
   return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

void CPropertyPageBase::OnCancel()
{
    CString szTitle;
    GetWindowText(szTitle);
    TRACE(_T("CPropertyPageBase::OnCancel()called on <%s>\n"),(LPCTSTR)szTitle);
    CWinApp* pApp = AfxGetApp();
  ASSERT(pApp);
    ASSERT(::IsWindow(m_hWnd));
    m_pPageHolder->CloseModalDialogs(m_hWnd);
}

BOOL CPropertyPageBase::OnApply()
{
    if (IsDirty())
    {
        if (m_pPageHolder->NotifyConsole(this) == 0x0)
        {
            SetDirty(FALSE);
            return TRUE;
        }
        else
        {
#ifdef _DEBUG
            // test only
            AFX_MANAGE_STATE(AfxGetStaticModuleState());
            AfxMessageBox(_T("Apply Failed"));
#endif
            return FALSE;
        }
    }
    return TRUE;
}

void CPropertyPageBase::SetDirty(BOOL bDirty)
{
  if (!m_pPageHolder->IsWizardMode())
  {
      SetModified(bDirty);
  }
    m_bIsDirty = bDirty;
}   


void CPropertyPageBase::InitWiz97(BOOL bHideHeader,
                                       UINT nIDHeaderTitle,
                                       UINT nIDHeaderSubTitle,
                              bool hasHelp)
{
    if (bHideHeader)
    {
        // for first and last page of the wizard
        m_psp97.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        // for intermediate pages
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        m_szHeaderTitle.LoadString(nIDHeaderTitle);
        m_szHeaderSubTitle.LoadString(nIDHeaderSubTitle);

        m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp97.pszHeaderTitle = (LPCTSTR)m_szHeaderTitle;
        m_psp97.pszHeaderSubTitle = (LPCTSTR)m_szHeaderSubTitle;
    }

   if (hasHelp)
   {
      m_psp97.dwFlags |= PSP_HASHELP;
   }
}



/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderTable

#define PPAGE_HOLDER_ARRAY_DEF_SIZE (10)


CPropertyPageHolderTable::CPropertyPageHolderTable(CComponentDataObject* pComponentData)
{
    m_pComponentData = pComponentData;

   size_t arraySizeInBytes = sizeof(PPAGE_HOLDER_TABLE_ENTRY) * PPAGE_HOLDER_ARRAY_DEF_SIZE;
    m_pEntries = (PPAGE_HOLDER_TABLE_ENTRY*)malloc(arraySizeInBytes);
  if (m_pEntries != NULL)
  {
      memset(m_pEntries,0, arraySizeInBytes);
  }
    m_nSize = PPAGE_HOLDER_ARRAY_DEF_SIZE;

}
CPropertyPageHolderTable::~CPropertyPageHolderTable()
{
#ifdef _DEBUG
    for (int k=0; k < m_nSize; k++)
    {
        ASSERT(m_pEntries[k].pPPHolder == NULL);
        ASSERT(m_pEntries[k].pNode == NULL);
    }
#endif      
    free(m_pEntries);
}

void CPropertyPageHolderTable::Add(CPropertyPageHolderBase* pPPHolder)
{
    ASSERT(pPPHolder != NULL);
    ASSERT(pPPHolder->GetTreeNode() != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k].pPPHolder == NULL) // get the first empty spot
        {
            m_pEntries[k].pPPHolder = pPPHolder;
            m_pEntries[k].pNode = pPPHolder->GetTreeNode();
            m_pEntries[k].hWnd = NULL;
            return;
        }
    }
    // all full, need to grow the array
    int nAlloc = m_nSize*2;
   PPAGE_HOLDER_TABLE_ENTRY* temp = (PPAGE_HOLDER_TABLE_ENTRY*)realloc(m_pEntries, sizeof(PPAGE_HOLDER_TABLE_ENTRY)*nAlloc);
   if (temp)
   {
      m_pEntries = temp;
       memset(&m_pEntries[m_nSize], 0, sizeof(PPAGE_HOLDER_TABLE_ENTRY)*m_nSize);
       m_pEntries[m_nSize].pPPHolder = pPPHolder;
       m_pEntries[m_nSize].pNode = pPPHolder->GetTreeNode();
       m_pEntries[m_nSize].hWnd = NULL;
       m_nSize = nAlloc;
   }
}


void CPropertyPageHolderTable::AddWindow(CPropertyPageHolderBase* pPPHolder, HWND hWnd)
{
    // By now, the PPHolder might have gone away, so use it as a cookie
    // but do not call any methods on it.
    // The node is still valid, because we do not delete nodes from secondary
    // threads
    ASSERT(pPPHolder != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k].pPPHolder == pPPHolder)
        {
            ASSERT(m_pEntries[k].pNode != NULL);
            ASSERT(m_pEntries[k].pNode->GetSheetCount() > 0);
            m_pEntries[k].hWnd = hWnd;
            return; // assume no more that one holder entry
        }
    }
}



void CPropertyPageHolderTable::Remove(CPropertyPageHolderBase* pPPHolder)
{
    // By now, the PPHolder might have gone away, so use it as a cookie
    // but do not call any methods on it.
    // The node is still valid, because we do not delete nodes from secondary
    // threads
    ASSERT(pPPHolder != NULL);
    for (int k=0; k < m_nSize; k++)
    {
        if (m_pEntries[k].pPPHolder == pPPHolder)
        {
            ASSERT(m_pEntries[k].pNode != NULL);
            ASSERT(m_pEntries[k].pNode->GetSheetCount() > 0);
            m_pEntries[k].pPPHolder = NULL;
            m_pEntries[k].pNode = NULL;
            m_pEntries[k].hWnd = NULL;
            return; // assume no more that one holder entry
        }
    }
}


void CPropertyPageHolderTable::DeleteSheetsOfNode(CTreeNode* pNode)
{
    ASSERT(pNode != NULL);
    int nCount = BroadcastCloseMessageToSheets(pNode);
    WaitForSheetShutdown(nCount);
}


void CPropertyPageHolderTable::WaitForAllToShutDown()
{
    int nCount = 0;
    // allocate and array of HWND's for broadcast
    HWND* hWndArr = new HWND[m_nSize];

    if (hWndArr)
    {
        memset(hWndArr, 0x0, m_nSize*sizeof(HWND));

        for (int k=0; k < m_nSize; k++)
        {
            if (m_pEntries[k].pPPHolder != NULL)
            {
                m_pEntries[k].pPPHolder = NULL;
                m_pEntries[k].pNode = NULL;
                hWndArr[k] = ::GetParent(m_pEntries[k].hWnd);
                m_pEntries[k].hWnd = NULL;
                nCount++;
            }
        }

        // wait for shutdown (wait for posted messages to come through
        WaitForSheetShutdown(nCount, hWndArr);

        delete [] hWndArr;
    }
}

void CPropertyPageHolderTable::BroadcastSelectPage(CTreeNode* pNode, long nPageCode)
{
    for (int k=0; k < m_nSize; k++)
    {
        if ((m_pEntries[k].hWnd != NULL) && (m_pEntries[k].pNode == pNode))
        {
            ::PostMessage(m_pEntries[k].hWnd, CSheetWnd::s_SelectPageMessage, (WPARAM)nPageCode, 0);
        }
    }
}

void CPropertyPageHolderTable::BroadcastMessageToSheets(CTreeNode* pNode, WPARAM wParam, LPARAM lParam)
{
    for (int k=0; k < m_nSize; k++)
    {
        if ((m_pEntries[k].hWnd != NULL) && (m_pEntries[k].pNode == pNode))
        {
            ::PostMessage(m_pEntries[k].hWnd, CSheetWnd::s_SheetMessage, wParam, lParam);
        }
    }
}

int CPropertyPageHolderTable::BroadcastCloseMessageToSheets(CTreeNode* pNode)
{
    ASSERT(m_nSize > 0);
    int nCount = 0;
    // allocate and array of HWND's for broadcast
    HWND* hWndArr = new HWND[m_nSize];

    if (hWndArr)
    {
        memset(hWndArr, 0x0, m_nSize*sizeof(HWND));

        // find the HWND's that map to this node and its children
        for (int k=0; k < m_nSize; k++)
        {
            if (m_pEntries[k].hWnd != NULL)
            {
                if (m_pEntries[k].pNode == pNode)
                {
                    hWndArr[nCount++] = ::GetParent(m_pEntries[k].hWnd);
                }
                else if (pNode->IsContainer())
                {
                    if (m_pEntries[k].pNode->HasContainer((CContainerNode*)pNode))
                    {
                        hWndArr[nCount++] = ::GetParent(m_pEntries[k].hWnd);
                    }
                }
            }
        }
        // shut down the sheets
        for (int j=0; j < nCount; j++)
            ::PostMessage(hWndArr[j], WM_COMMAND, IDCANCEL, 0);

        delete [] hWndArr;
    }

    return nCount;
}



void CPropertyPageHolderTable::WaitForSheetShutdown(int nCount, HWND* hWndArr)
{
    ASSERT(m_pComponentData != NULL);
    HWND hWnd = m_pComponentData->GetHiddenWindow();
    ASSERT(::IsWindow(hWnd));
    MSG tempMSG;
    DWORD dwTimeStart = ::GetTickCount();
    while(nCount > 0)
    {
        if ( hWndArr != NULL && (::GetTickCount() > dwTimeStart + 2000) )
        {
            // force sheets shut down
            for (int j=0; j < nCount; j++)
                ::PostMessage(hWndArr[j], WM_COMMAND, IDCANCEL, 0);
            hWndArr = NULL;
        }

        if (::PeekMessage(&tempMSG,hWnd, CHiddenWnd::s_NodePropertySheetDeleteMessage,
                                         CHiddenWnd::s_NodePropertySheetDeleteMessage,
                                         PM_REMOVE))
        {
            TRACE(_T("-------------------->>>>enter while peek loop, nCount = %d\n"),nCount);
            DispatchMessage(&tempMSG);
            nCount--;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
    ON_WM_CONTEXTMENU()
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()


CHelpDialog::CHelpDialog(UINT nIDTemplate, CComponentDataObject* pComponentData) :
                          m_hWndWhatsThis(0),
              m_pComponentData(pComponentData),
              CDialog(nIDTemplate)
{
}

CHelpDialog::CHelpDialog(UINT nIDTemplate, CWnd* pParentWnd, CComponentDataObject* pComponentData) :
                          m_hWndWhatsThis(0),
              m_pComponentData(pComponentData),
              CDialog(nIDTemplate, pParentWnd)
{
}

void CHelpDialog::OnWhatsThis()
{
  //
  // Display context help for a control
  //
  if ( m_hWndWhatsThis )
  {
    //
    // Build our own HELPINFO struct to pass to the underlying
    // CS help functions built into the framework
    //
    int iCtrlID = ::GetDlgCtrlID(m_hWndWhatsThis);
    HELPINFO helpInfo;
    ZeroMemory(&helpInfo, sizeof(HELPINFO));
    helpInfo.cbSize = sizeof(HELPINFO);
    helpInfo.hItemHandle = m_hWndWhatsThis;
    helpInfo.iCtrlId = iCtrlID;

      m_pComponentData->OnDialogContextHelp(m_nIDHelp, &helpInfo);
  }
}

BOOL CHelpDialog::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

  if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
  {
    //
    // Display context help for a control
    //
      m_pComponentData->OnDialogContextHelp(m_nIDHelp, pHelpInfo);
  }

  return TRUE;
}

void CHelpDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
  //
  // point is in screen coordinates
  //

  CMenu bar;
    if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
    {
        CMenu& popup = *bar.GetSubMenu (0);
        ASSERT(popup.m_hMenu);

        if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
               point.x,     // in screen coordinates
                 point.y,     // in screen coordinates
               this) )      // route commands through main window
        {
            m_hWndWhatsThis = 0;
            ScreenToClient (&point);
            CWnd* pChild = ChildWindowFromPoint (point,  // in client coordinates
                                                     CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
            if ( pChild )
      {
                m_hWndWhatsThis = pChild->m_hWnd;
      }
      }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\dbg_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dbg_.cpp
//
//--------------------------------------------------------------------------

// We want to continue using _vsnwprintf() below so we silence
// the deprecation warnings.
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_MTFRMWK_TRACE) || defined(_USE_MTFRMWK_ASSERT)

#ifndef _MTFRMWK_INI_FILE
#define _MTFRMWK_INI_FILE (L"\\system32\\mtfrmwk.ini")
#endif


UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = _MTFRMWK_INI_FILE;
  WCHAR szFilePath[2*MAX_PATH];
    UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
    if (nLen == 0)
        return nDefault;

  // NOTICE-2002/04/18-artm  Part of fix for ntraid#ntbug9-540061.
  // We need strsafe.h for this file, and there was a dangerous fctn
  // here that was flagged as deprecated (I've replaced with StringCchCat()).
  HRESULT hr = StringCchCat(szFilePath, 2*MAX_PATH, lpszFile);
  if (FAILED(hr))
  {
      return nDefault;
  }

  // ISSUE-2002/03/08-JeffJon-Since this function is deprecated we should move
  // to using the registry to turn on the debugging flags

  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif // defined(_USE_MTFRMWK_TRACE) || defined(_USE_MTFRMWK_ASSERT)



#if defined(_USE_MTFRMWK_TRACE)

DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");


void MtFrmwkTrace(LPCTSTR lpszFormat, ...)
{
    if (g_dwTrace == 0)
        return;

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512];

    ZeroMemory(szBuffer, sizeof(szBuffer));

    nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR) - 1, lpszFormat, args);
    // was there an error? was the expanded string too long?
    ASSERT(nBuf >= 0);

    ::OutputDebugString(szBuffer);

    va_end(args);
}

#endif

#if defined(DBG)

void MtFrmwkLogFile(LPCTSTR lpszFormat, ...)
{
    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512];

    ZeroMemory(szBuffer, sizeof(szBuffer));

    nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR) - 1, lpszFormat, args);


    // If the string is truncated, we should still show it.

  CLogFile* _dlog = CLogFile::GetInstance();            
  if (_dlog)                                            
  {                                                     
     _dlog->writeln(szBuffer);                               
  }                                                     

    va_end(args);
}

void MtFrmwkLogFileIfLog(BOOL bLog, LPCTSTR lpszFormat, ...)
{
  if (bLog)
  {
      va_list args;
      va_start(args, lpszFormat);

      int nBuf;
      WCHAR szBuffer[512];

      ZeroMemory(szBuffer, sizeof(szBuffer));

      nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR) - 1, lpszFormat, args);

      // If the string is truncated, we should still show it.

    CLogFile* _dlog = CLogFile::GetInstance();            
    if (_dlog)                                            
    {                                                     
       _dlog->writeln(szBuffer);                               
    }                                                     

      va_end(args);
  }
}

#endif

//
// Copied and modified from burnslib on 12-07-1999 by JeffJon
//  Needed file logging on DnsSetup call from DCPromo.
//  I wanted it to behave like the DCPromo log but including all of
//  burnslib required too many alterations in the debugging behavior
//  already in place.
//
extern CString LOGFILE_NAME = _T("");
static CLogFile* log_instance = 0;

//
// # of spaces per indentation level
//
static const int TAB = 2;
static int margin = 0;

//
// index to Thread Local Storage slot where the per-thread debug state is
// kept.  Initialized in Startup
//
static DWORD tls_index = 0;

CLogFile* CLogFile::GetInstance()
{
  if (!log_instance && !LOGFILE_NAME.IsEmpty())
  {
    log_instance = new CLogFile(LOGFILE_NAME);
  }
  return log_instance;
}

void CLogFile::KillInstance()
{
  delete log_instance;
  log_instance = 0;
}

BOOL PathExists(PCWSTR pszPath)
{
  DWORD attrs = GetFileAttributes(pszPath);
  if (attrs != 0xFFFFFFFF)
  {
    return TRUE;
  }
  return FALSE;
}

HANDLE OpenFile(PCWSTR pszPath)
{
  //
  // remove the last element of the path to form the parent directory
  //

    HANDLE handle = ::CreateFile(pszPath,
                               GENERIC_WRITE,
                               0,
                               0,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               0);

  return handle;
}

PCWSTR GetSystemRootDirectory()
{
  static CString SYSTEMROOT;

  WCHAR buf[MAX_PATH + 1];

  DWORD result = ::GetWindowsDirectory(buf, MAX_PATH + 1);

  ASSERT(result != 0 && result <= MAX_PATH);
  if (result == 0 || result > MAX_PATH)
  {
    return NULL;
  }
  
  SYSTEMROOT = buf;
  return (PCWSTR)SYSTEMROOT;
}

// locate the log file with the highest-numbered extension, then add 1 and
// return the result.

int DetermineNextLogNumber(PCWSTR logDir, PCWSTR logBaseName)
{
  ASSERT(logDir != NULL);
  ASSERT(logBaseName != NULL);

  int largest = 0;

  CString filespec = CString(logDir) + L"\\" + CString(logBaseName) + L".*.log";

  WIN32_FIND_DATA findData;
  HANDLE ff = ::FindFirstFile(filespec, &findData);

  if (ff != INVALID_HANDLE_VALUE)
  {
    for (;;)
    {
      CString current = findData.cFileName;

      // grab the text between the dots: "nnn" in foo.nnn.ext

      // first dot

      int pos = current.Find(L".");
      if (pos == -1)
      {
        continue;
      }

      CString extension = current.Right(current.GetLength() - pos - 1);

      // second dot

      pos = extension.Find(L".");
      if (pos == -1)
      {
        continue;
      }

      extension = extension.Left(pos);

      long i = 0;
      i = wcstol(extension, L'\0', 10);
      largest = max(i, largest);

      if (!::FindNextFile(ff, &findData))
      {
        ::FindClose(ff);
        break;
      }
    }
  }

  // roll over after 255 
  return (++largest & 0xFF);
}

// Determine the name of the log file.  If a log file of that name already
// exists, rename the existing file to a numbered backup.  Create the new
// log file, return a handle to it.
// 
HANDLE OpenNewLogFile(PCWSTR pszLogBaseName, CString& logName)
{
  CString logDir = CString(GetSystemRootDirectory()) + L"\\debug";
  int i = DetermineNextLogNumber(logDir, pszLogBaseName);

  CString szCount;
  szCount.Format(L"%d", i);
  logName = logDir + L"\\" + pszLogBaseName + L"." + szCount + L".log";

  HANDLE result = OpenFile(logName);
  return result;
}

   

// Create a new log.
//
// logBaseName - base name of the log.  If logging-to-file is active, then a
// file in the %windir%\debug folder will be created/used.  The name of the
// file is of the form %windir%\debug\logBaseName.log.  If a file by that name
// already exists, then the existing file will be renamed
// %windir%\debug\logBaseName.xxx.log, where xxx is an integer 1 greater than
// the last so-numbered file in that directory.

CLogFile::CLogFile(PCWSTR pszLogBaseName)
   :
   szBase_name(pszLogBaseName),
   file_handle(INVALID_HANDLE_VALUE),
   trace_line_number(0)
{
  ASSERT(pszLogBaseName != NULL);

  if (pszLogBaseName != NULL)
  {
    CString logName;
    file_handle = OpenNewLogFile(pszLogBaseName, logName);

    if (file_handle != INVALID_HANDLE_VALUE)
    {
      CString szOpeningFile = L"opening log file ";
      szOpeningFile += logName;
      writeln(szOpeningFile);
    }
  }

  SYSTEMTIME localtime;
  ::GetLocalTime(&localtime);
  CString szTime;
  szTime.Format(L"%d/%d/%d %d:%d:%d.%d",
                 localtime.wMonth,
                 localtime.wDay,
                 localtime.wYear,
                 localtime.wHour,
                 localtime.wMinute,
                 localtime.wSecond,
                 localtime.wMilliseconds);

  writeln(szTime);
}



CLogFile::~CLogFile()
{
  if (IsOpen())
  {
    writeln(L"closing log file");
    ::CloseHandle(file_handle);
    file_handle = INVALID_HANDLE_VALUE;
  }
}

// guarded by caller

void CLogFile::indent()
{
  //
  // indent by adding to the margin
  //
  margin += TAB;
}

BOOL CLogFile::IsOpen() const
{
  return file_handle != INVALID_HANDLE_VALUE;
}



// guarded by caller

void CLogFile::outdent()
{
  //
  // outdent by subtracting from the margin
  //
  ASSERT(margin >= TAB);
  margin = max(0, margin - TAB);
}

void ConvertStringToANSI(PCWSTR pszWide, PSTR* ppAnsi)
{
  ASSERT(ppAnsi);
  ASSERT(pszWide);
  if (!pszWide || !ppAnsi)
  {
      return;
  }

  *ppAnsi = NULL;

  //
  // determine the size of the buffer required to hold the ANSI string
  //

  // This function assumes pszWide is NULL terminated.

  // REVIEWED-2002/03/08-JeffJon-This is proper usage

  int bufsize = 
     ::WideCharToMultiByte(
        CP_ACP, 
        0, 
        pszWide, 
        -1,     // Let WCtoMB determine length of pszWide.
        0, 0, 0, 0);

  if (bufsize > 0)
  {
    *ppAnsi = new CHAR[bufsize];
    if (*ppAnsi == NULL)
    {
      return;
    }
    memset(*ppAnsi, 0, bufsize);

    // We need to pass the size of the buffer *including* space for NULL
    // to WideCharToMultiByte().
    size_t result = ::WideCharToMultiByte(CP_ACP, 
                                          0, 
                                          pszWide, 
                                          -1,   // Let WCtoMB determine length of pszWide.
                                          *ppAnsi, 
                                          bufsize,
                                          0,
                                          0);
    ASSERT(result);

    if (!result)
    {
      *ppAnsi = NULL;
    }
  }
  
}

//
// Spews output to the log according to the current logging type and
// output options in effect.
//
// type - log output type of this output spewage.
//
// text - the spewage.  This is prefaced with the log name, thread id, spewage
// line number, and current indentation.
//
void CLogFile::writeln(PCWSTR pszText)
{
  CString white(L' ',margin);

  // Format the line with thread ID, line number, whitespace, and the text

  CString t = LOGFILE_NAME;
  t.Format(L" t:0x%x %3d ", ::GetCurrentThreadId(), trace_line_number);
  t += white;
  t += pszText;

  if (IsOpen())
  {
    ASSERT(file_handle != INVALID_HANDLE_VALUE);
    ASSERT(!t.IsEmpty());

    PSTR pAnsi;
    ConvertStringToANSI(t, &pAnsi);

    if (pAnsi)
    {
       // NTRAID#NTBUG9-657626-2002/07/11-sburns
       
       size_t bytesToWrite = sizeof(CHAR) * strlen(pAnsi);

       DWORD bytes_written = 0;
       BOOL  success =::WriteFile(file_handle,
                                  pAnsi,
                                  static_cast<ULONG>(bytesToWrite),
                                  &bytes_written,
                                  0);
       ASSERT(success);
       ASSERT(bytes_written == bytesToWrite);
       delete[] pAnsi;
    }
  }
  trace_line_number++;
}

CScopeTracer::CScopeTracer(BOOL bLog, PCWSTR pszMessage_)
  :
  szMessage(pszMessage_),
  m_bLog(bLog)
{
  // build this string once, instead of using the string literal in the
  // below expression (which would implicitly build the string on each
  // evaluation of that expression) as a slight performance gain.
  static const CString ENTER(L"Enter ");

  if (m_bLog)
  {
    CLogFile* li = CLogFile::GetInstance();
    li->writeln(ENTER + szMessage);
    li->indent();
  }
}

CScopeTracer::~CScopeTracer()
{
  // build this string once, instead of using the string literal in the
  // below expression (which would implicitly build the string on each
  // evaluation of that expression) as a slight performance gain.
  static const CString EXIT(L"Exit  ");

  if (m_bLog)
  {
    CLogFile* li = CLogFile::GetInstance();
    li->outdent();
    li->writeln(EXIT + szMessage);
  }
}



#if defined(_USE_MTFRMWK_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL MtFrmwkAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
  if (g_dwAssert == 0)
    return FALSE;

  WCHAR szMessage[_MAX_PATH*2];

    // assume the debugger or auxiliary port

    // NOTICE-2002/04/18-artm  Part of fix for ntraid#ntbug9-540061.
    HRESULT hr = StringCchPrintfW(
        szMessage,          // destination buffer,
        _MAX_PATH*2,        // size of dest. buffer, including null
        _T("Assertion Failed: File %hs, Line %d\n"),
        lpszFileName,
        nLine);

    // If the string is truncated, we should still show it.

    OutputDebugString(szMessage);

    // display the assert
    int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
        MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
    if (nCode == IDIGNORE)
  {
        return FALSE;   // ignore
  }

    if (nCode == IDRETRY)
  {
        return TRUE;    // will cause DebugBreak
  }

    abort();     // should not return 
    return TRUE;

}
#endif // _USE_MTFRMWK_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\stdabou_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabou_.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	StdAbout.cpp
//
//	Implementation of the ISnapinAbout interface
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

//#include "stdutils.h" // HrLoadOleString()

#include <strsafe.h>


HRESULT
HrCopyToOleString(
   const CString& szString,
   OUT LPOLESTR* ppaszOleString)
{
   if (ppaszOleString == NULL)
   {
       return E_POINTER;
   }

   size_t lengthWithNull = (szString.GetLength() + 1);

   *ppaszOleString = reinterpret_cast<LPOLESTR>
       (CoTaskMemAlloc( lengthWithNull * sizeof(wchar_t) ));

   if (*ppaszOleString == NULL)
   {
      return E_OUTOFMEMORY;
   }

   // NOTICE-2002/04/18-artm  Part of fix for ntraid#ntbug9-540061.
   // Using strsafe.h in dbg_.cpp causes dangerous use of wcscpy() in
   // this file to be deprecated.  Therefore, I've replaced with 
   // strsafe function that guarantees null termination of destination
   // and won't overrun the buffer.
   HRESULT hr = StringCchCopyW(
       *ppaszOleString,         // destination buffer
       lengthWithNull,             // size of destination buffer including null
       static_cast<LPCWSTR>(szString) );

	return hr;
}



HRESULT
HrLoadOleString(
	UINT uStringId,					// IN: String Id to load from the resource
	OUT LPOLESTR * ppaszOleString)	// OUT: Pointer to pointer to allocated OLE string
{
   if (ppaszOleString == NULL)
   {
      TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
      return E_POINTER;
   }

   CString strT;		// Temporary string
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
   VERIFY( strT.LoadString(uStringId) );

   return HrCopyToOleString(strT, ppaszOleString);
} // HrLoadOleString()






CSnapinAbout::CSnapinAbout() :
   hBitmapSmallImage(0),
   hBitmapSmallImageOpen(0),
   hBitmapLargeImage(0)
{
}

CSnapinAbout::~CSnapinAbout()
{
   if (hBitmapSmallImage)
   {
      DeleteObject(hBitmapSmallImage);
      hBitmapSmallImage = 0;
   }

   if (hBitmapSmallImageOpen)
   {
      DeleteObject(hBitmapSmallImageOpen);
      hBitmapSmallImageOpen = 0;
   }

   if (hBitmapLargeImage)
   {
      DeleteObject(hBitmapLargeImage);
      hBitmapLargeImage = 0;
   }
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
{
	return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
{
	return HrCopyToOleString(m_szProvider, OUT lpName);
}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
{
	return HrCopyToOleString(m_szVersion, OUT lpVersion);
}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
{
	if (hAppIcon == NULL)
		return E_POINTER;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
   *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
   if (*hAppIcon == NULL)
   {
      ASSERT(FALSE && "Unable to load icon");
      return E_FAIL;
   }
	return S_OK;
}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
{	
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(crMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

   if (!hBitmapSmallImage)
   {
      hBitmapSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
   }
   ASSERT(hBitmapSmallImage);
   *hSmallImage = hBitmapSmallImage;

   if (!hBitmapSmallImageOpen)
   {
      hBitmapSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
   }
   ASSERT(hBitmapSmallImageOpen);
	*hSmallImageOpen = hBitmapSmallImageOpen;

   if (!hBitmapLargeImage)
   {
      hBitmapLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));
   }
   ASSERT(hBitmapLargeImage);
	*hLargeImage = hBitmapLargeImage;

	*crMask = m_crImageMask;
	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
	{
		TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
	}
	#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
//	HISTORY
//	01-Aug-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "about.h"

#include "stdabout.cpp" 


/////////////////////////////////////////////////////////////////////
CComputerMgmtAbout::CComputerMgmtAbout()
	{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_COMPUTER;
	m_uIdBitmapSmallImage = IDB_COMPUTER_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_COMPUTER_SMALL;
	m_uIdBitmapLargeImage = IDB_COMPUTER_LARGE;
	m_crImageMask = RGB(255, 0, 255);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\treedat_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       treedat_.cpp
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////////////
// Miscellanea 
LPCWSTR g_lpszNullString = L"\0";


///////////////////////////////////////////////////////////////////////
// Global Helper functions

BOOL LoadContextMenuResources(MENUMAP* pMenuMap)
{
    HINSTANCE hInstance = _Module.GetModuleInstance();
    for (int i = 0; pMenuMap->ctxMenu[i].strName; i++)
    {
      // szBuffer is defined statically as part of the MENUDATARES structure with size of MAX_CONTEXT_MENU_STRLEN*2
        if (0 == ::LoadString(hInstance, pMenuMap->dataRes[i].uResID, pMenuMap->dataRes[i].szBuffer, MAX_CONTEXT_MENU_STRLEN*2))
            return FALSE;
        pMenuMap->ctxMenu[i].strName = pMenuMap->dataRes[i].szBuffer;
        for (WCHAR* pCh = pMenuMap->dataRes[i].szBuffer; (*pCh) != NULL; pCh++)
        {
            if ( (*pCh) == L'\n')
            {
                pMenuMap->ctxMenu[i].strStatusBarText = (pCh+1);
                (*pCh) = NULL;
                break;
            }
        }
    }
    return TRUE;
}

BOOL LoadResultHeaderResources(RESULT_HEADERMAP* pHeaderMap, int nCols)
{
    HINSTANCE hInstance = _Module.GetModuleInstance();
    for ( int i = 0; i < nCols ; i++)
    {
      // szBuffer is defined statically as part of the RESULT_HEADERMAP structure with size of MAX_RESULT_HEADER_STRLEN
        if ( 0 == ::LoadString(hInstance, pHeaderMap[i].uResID, pHeaderMap[i].szBuffer, MAX_RESULT_HEADER_STRLEN))
            return TRUE;
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////
// CTreeNode

BEGIN_TOOLBAR_MAP(CTreeNode)
END_TOOLBAR_MAP()

BOOL CTreeNode::HasContainer(CContainerNode* pContainerNode)
{
    if (m_pContainer == NULL)
        return FALSE; // root
    if (m_pContainer == pContainerNode)
        return TRUE; // got it
    return m_pContainer->HasContainer(pContainerNode);
}

HRESULT CTreeNode::GetResultViewType(CComponentDataObject* pComponentData,
                                     LPOLESTR* ppViewType, 
                                     long* pViewOptions)
{
  if (pComponentData->IsMultiSelect())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
  }
  else
  {
      *pViewOptions = MMC_VIEW_OPTIONS_NONE;
  }
    *ppViewType = NULL;
  return S_FALSE;
}

void CTreeNode::Show(BOOL bShow, CComponentDataObject* pComponentData)
{
    if (bShow)
    {
        ASSERT(m_dwNodeFlags & TN_FLAG_HIDDEN); // must be currently hidden
        SetFlagsDown(TN_FLAG_HIDDEN,FALSE); // mark it visible
        VERIFY(SUCCEEDED(pComponentData->AddNode(this)));
    }
    else
    {
        ASSERT(!(m_dwNodeFlags & TN_FLAG_HIDDEN)); // must be currently visible
        SetFlagsDown(TN_FLAG_HIDDEN,TRUE); // mark it hidden
        VERIFY(SUCCEEDED(pComponentData->DeleteNode(this)));
        if (IsContainer())
        {
            ((CContainerNode*)this)->RemoveAllChildrenFromList();
            ((CContainerNode*)this)->MarkEnumerated(FALSE);
        }
    }
}


void CTreeNode::SetFlagsDown(DWORD dwNodeFlags, BOOL bSet)
{
    if (bSet)
        m_dwNodeFlags |= dwNodeFlags; 
    else
        m_dwNodeFlags &= ~dwNodeFlags;      
}

void CTreeNode::SetFlagsUp(DWORD dwNodeFlags, BOOL bSet)
{
    if (bSet)
        m_dwNodeFlags |= dwNodeFlags; 
    else
        m_dwNodeFlags &= ~dwNodeFlags;      
    if (m_pContainer != NULL)
    {
        ASSERT(m_pContainer != this);
        m_pContainer->SetFlagsUp(dwNodeFlags, bSet);
    }
}

//
// Property Page methods
//
void CTreeNode::ShowPageForNode(CComponentDataObject* pComponentDataObject) 
{
    ASSERT(pComponentDataObject != NULL);
    pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(this, -1);
}

BOOL CTreeNode::HasPropertyPages(DATA_OBJECT_TYPES, 
                                 BOOL* pbHideVerb, 
                                 CNodeList*) 
{ 
  *pbHideVerb = TRUE; 
  return FALSE; 
}

//
// Menu Item methods
//
HRESULT CTreeNode::OnAddMenuItems(IContextMenuCallback2* pContextMenuCallback2, 
                                                    DATA_OBJECT_TYPES type,
                                                    long *pInsertionAllowed,
                                  CNodeList* pNodeList)
{
    HRESULT hr = S_OK;
    LPCONTEXTMENUITEM2 pContextMenuItem = NULL;
  
  if (pNodeList->GetCount() == 1) // single selection
  {
    pContextMenuItem = OnGetContextMenuItemTable();
      if (pContextMenuItem == NULL)
          return hr;

    //
      // Loop through and add each of the menu items
    //
      for (LPCONTEXTMENUITEM2 m = pContextMenuItem; m->strName; m++)
      {
          if (
                  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) &&
                      (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_NEW) ) ||
                  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) &&
                      (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TASK) ) ||
                  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) &&
                      (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_VIEW) ) ||
                  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) &&
                      (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TOP) )
             )
          {
              // make a temporary copy that can be modified
              CONTEXTMENUITEM2 tempItem;
              
           // REVIEWED-2002/03/08-JeffJon-This is an acceptable usage

           ::memcpy(&tempItem, m, sizeof(CONTEXTMENUITEM2));
              if (OnAddMenuItem(&tempItem, pInsertionAllowed))
              {
                  hr = pContextMenuCallback2->AddItem(&tempItem);
                  if (FAILED(hr))
                      break;
              }
          }
      }
  }
  else if (pNodeList->GetCount() > 1) // multiple selection
  {
    hr = OnAddMenuItemsMultipleSelect(pContextMenuCallback2, 
                                                        type,
                                                        pInsertionAllowed,
                                      pNodeList);
  }
    return hr;
}

BOOL CTreeNode::OnSetRenameVerbState(DATA_OBJECT_TYPES, 
                                     BOOL* pbHide, 
                                     CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES, 
                                     BOOL* pbHide, 
                                     CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                      BOOL* pbHide, 
                                      CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetCutVerbState(DATA_OBJECT_TYPES, 
                                  BOOL* pbHide, 
                                  CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetCopyVerbState(DATA_OBJECT_TYPES, 
                                   BOOL* pbHide, 
                                   CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetPasteVerbState(DATA_OBJECT_TYPES, 
                                    BOOL* pbHide, 
                                    CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetPrintVerbState(DATA_OBJECT_TYPES, 
                                    BOOL* pbHide, 
                                    CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

MMC_CONSOLE_VERB CTreeNode::GetDefaultVerb(DATA_OBJECT_TYPES type, 
                                           CNodeList* pNodeList)
{ 
    ASSERT((type == CCT_SCOPE) || (type == CCT_RESULT));
    if (type == CCT_SCOPE)
        return MMC_VERB_OPEN; 
    BOOL bHideVerbDummy;
    if (HasPropertyPages(type, &bHideVerbDummy, pNodeList))
        return MMC_VERB_PROPERTIES;
    return MMC_VERB_NONE;
}


void CTreeNode::OnSetVerbState(LPCONSOLEVERB pConsoleVerb, 
                               DATA_OBJECT_TYPES type,
                               CNodeList* pNodeList)
{
  //
  // Use the virtual functions to get the verb state
  //
  BOOL bHideCut;
  BOOL bCanCut = OnSetCutVerbState(type, &bHideCut, pNodeList);
  pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHideCut);
  pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bCanCut);


  BOOL bHideCopy;
  BOOL bCanCopy = OnSetCopyVerbState(type, &bHideCopy, pNodeList);
  pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHideCopy);
    pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bCanCopy);


  BOOL bHidePaste;
  BOOL bCanPaste = OnSetPasteVerbState(type, &bHidePaste, pNodeList);
  pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHidePaste);
    pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bCanPaste);


  BOOL bHidePrint;
  BOOL bCanPrint = OnSetPrintVerbState(type, &bHidePrint, pNodeList);
    pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHidePrint);
    pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bCanPrint);

  BOOL bHideRename;
  BOOL bCanRename = OnSetRenameVerbState(type, &bHideRename, pNodeList);
    pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHideRename);
    pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bCanRename);

    // MMC_VERB_PROPERTIES
    BOOL bHideProperties;
    BOOL bHasProperties = HasPropertyPages(type, &bHideProperties, pNodeList);
    pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bHasProperties);
    pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHideProperties);

    // MMC_VERB_DELETE
    BOOL bHideDelete;
    BOOL bCanDelete = OnSetDeleteVerbState(type, &bHideDelete, pNodeList);
    pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bCanDelete);
    pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHideDelete);

    // MMC_VERB_REFRESH
    BOOL bHideRefresh;
    BOOL bCanRefresh = OnSetRefreshVerbState(type, &bHideRefresh, pNodeList);
    pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bCanRefresh);
    pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHideRefresh);
}

HRESULT CTreeNode::OnSetToolbarVerbState(IToolbar*, 
                                         CNodeList*)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar using
  // hr = pToolbar->SetButtonState(event, MMC_BUTTON_STATE, bState);
  //
  return hr;
}   

void CTreeNode::DeleteHelper(CComponentDataObject* pComponentData)
{
    ASSERT(pComponentData != NULL);
    ASSERT(m_pContainer != NULL);
    ASSERT((CTreeNode*)m_pContainer != this);
    CContainerNode* pCont = m_pContainer;
    VERIFY(m_pContainer->RemoveChildFromList(this));
    ASSERT(m_pContainer == NULL);
    m_pContainer = pCont; // not in the container's list of children, but still needed
    
    // remove from UI only if the container is visible
    if (pCont->IsVisible())
        VERIFY(SUCCEEDED(pComponentData->DeleteNode(this))); // remove from the UI
}

void CTreeNode::IncrementSheetLockCount() 
{ 
    ++m_nSheetLockCount; 
    if (m_pContainer != NULL) 
        m_pContainer->IncrementSheetLockCount(); 
}

void CTreeNode::DecrementSheetLockCount() 
{ 
    --m_nSheetLockCount; 
    if (m_pContainer != NULL) 
        m_pContainer->DecrementSheetLockCount();
}

void CTreeNode::OnPropertyChange(CComponentDataObject* pComponentData, 
                                    BOOL, long changeMask)
{
    // function called when the PPHolder successfully updated the node
    ASSERT(pComponentData != NULL);
    VERIFY(SUCCEEDED(pComponentData->ChangeNode(this, changeMask)));
}

void CTreeNode::OnCreateSheet() 
{
    ++m_nSheetCount; 
    IncrementSheetLockCount();
    SetFlagsUp(TN_FLAG_HAS_SHEET, TRUE);
}

void CTreeNode::OnDeleteSheet() 
{ 
    DecrementSheetLockCount();
    --m_nSheetCount; 
    SetFlagsUp(TN_FLAG_HAS_SHEET,FALSE);
}

////////////////////////////////////////////////////////////////////////
// CNodeList

INT_PTR CNodeList::GetVisibleCount()
{
   INT_PTR result = 0;

   POSITION pos = GetHeadPosition();
   while (pos)
   {
      CTreeNode* pNode = GetNext(pos);
      if (pNode &&
          pNode->IsVisible())
      {
         ++result;
      }
   }

   return result;
}

////////////////////////////////////////////////////////////////////////
// CContainerNode

void CContainerNode::IncrementThreadLockCount() 
{ 
    ++m_nThreadLockCount; 
    if (m_pContainer != NULL) 
        m_pContainer->IncrementThreadLockCount(); 
}

void CContainerNode::DecrementThreadLockCount() 
{ 
    --m_nThreadLockCount; 
    if (m_pContainer != NULL) 
        m_pContainer->DecrementThreadLockCount();
}

BOOL CContainerNode::OnRefresh(CComponentDataObject* pComponentData,
                               CNodeList* pNodeList)
{
  BOOL bRet = TRUE;
  if (pNodeList->GetCount() == 1) // single selection
  {
      if (IsSheetLocked())
      {
          if (!CanCloseSheets())
              return FALSE;
          pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
      }
      ASSERT(!IsSheetLocked());

      RemoveAllChildrenHelper(pComponentData);
      ASSERT(!HasChildren());
      OnEnumerate(pComponentData);
      AddCurrentChildrenToUI(pComponentData);
      MarkEnumerated();
  }
  else // multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      //
      // Have each node refresh itself
      //
      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
    return bRet;
}

BOOL CContainerNode::RemoveChildFromList(CTreeNode* p) 
{ 
  if (p->IsContainer())
  {
        if (m_containerChildList.RemoveNode(p))
        {
            p->m_pContainer = NULL; 
            return TRUE;
        }
  }
  else
  {
    if (m_leafChildList.RemoveNode(p))
    {
      p->m_pContainer = NULL;
      return TRUE;
    }
  }
    return FALSE;
}

void CContainerNode::RemoveAllChildrenHelper(CComponentDataObject* pComponentData)
{
    ASSERT(pComponentData != NULL);
    // remove from the UI
    VERIFY(SUCCEEDED(pComponentData->RemoveAllChildren(this)));
    // remove from memory, recursively from the bottom
    RemoveAllChildrenFromList();
}

void CContainerNode::AddCurrentChildrenToUI(CComponentDataObject* pComponentData)
{
    POSITION pos;

  //
  // Add leaves
  //
    for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
        VERIFY(SUCCEEDED(pComponentData->AddNode(pCurrentChild)));
    }

  //
  // Add Containers
  //
    for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
        VERIFY(SUCCEEDED(pComponentData->AddNode(pCurrentChild)));
    }
}

void CContainerNode::SetFlagsDown(DWORD dwNodeFlags, BOOL bSet)
{
    CTreeNode::SetFlagsDown(dwNodeFlags,bSet);
    // scan the list of children
    POSITION pos;
    for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
        pCurrentChild->SetFlagsDown(dwNodeFlags,bSet);
    }
    for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
        pCurrentChild->SetFlagsDown(dwNodeFlags,bSet);
    }
}

void CContainerNode::SetFlagsOnNonContainers(DWORD dwNodeFlags, BOOL bSet)
{
    // do not set on urselves, we are a container
    // scan the list of children
    POSITION pos;
    for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
    pCurrentChild->SetFlagsDown(dwNodeFlags,bSet);
    }

  for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
  {
    CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
    ((CContainerNode*)pCurrentChild)->SetFlagsOnNonContainers(dwNodeFlags,bSet);
  }
}

BOOL CContainerNode::AddChildToList(CTreeNode* p) 
{ 
  BOOL bRet = FALSE;
    p->m_pContainer = this;
  if (p->IsContainer())
  {
    bRet = NULL != m_containerChildList.AddTail(p);
  }
  else
  {
    bRet = NULL != m_leafChildList.AddTail(p);
  }
    return bRet; 
}

BOOL CContainerNode::FindChild(CTreeNode* pNode, CTreeNode** ppContainer)
{
    *ppContainer = NULL;
    if (pNode == NULL)
        return FALSE; // no sense in continuing
    if (pNode == this)
    {
        *ppContainer = m_pContainer; 
        return TRUE; // the node is ourselves
    }

  //
  // If we are looking for a leaf node search the list of leaves first
  //
  if (!pNode->IsContainer())
  {
    POSITION pos;
    for (pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
    {
      CLeafNode* pCurrentLeafNode = (CLeafNode*)m_leafChildList.GetNext(pos);
      ASSERT(pCurrentLeafNode != NULL);

      if (pCurrentLeafNode == pNode)
      {
        *ppContainer = this;
        return TRUE;
      }
    }
  }

  //
    // scan and recurse the containers if necessary
  //
    POSITION contPos;
    for( contPos = m_containerChildList.GetHeadPosition(); contPos != NULL; )
    {
        CContainerNode* pCurrentChild = (CContainerNode*)m_containerChildList.GetNext(contPos);
        ASSERT(pCurrentChild != NULL);

        if (pCurrentChild == pNode)
        {
            *ppContainer = this;
            return TRUE;  // we directly contain the node
        }

    //
        // if the current node is a container, look inside it
    //
        if (pCurrentChild->FindChild(pNode,ppContainer))
    {
            return TRUE; // got it in the recursion
    }
    }
    return FALSE; // not found
}

BOOL CContainerNode::AddChildToListAndUI(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData)
{
    ASSERT(pComponentData != NULL);
    VERIFY(AddChildToList(pChildToAdd)); // at the end of the list of children
    ASSERT(pChildToAdd->GetContainer() == this); // inserted underneath

    // add to UI only if currently visible and already expanded
    if (!IsVisible() || !IsExpanded())
        return TRUE;
    return SUCCEEDED(pComponentData->AddNode(pChildToAdd)); // add to the UI
}

BOOL CContainerNode::AddChildToListAndUISorted(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData)
{
    ASSERT(pComponentData != NULL);
    VERIFY(AddChildToListSorted(pChildToAdd, pComponentData));
    ASSERT(pChildToAdd->GetContainer() == this); // inserted underneath

    // add to UI only if currently visible and already expanded
    if (!IsVisible() || !IsExpanded())
        return TRUE;
    return SUCCEEDED(pComponentData->AddNodeSorted(pChildToAdd)); // add to the UI
}

BOOL CContainerNode::AddChildToListSorted(CTreeNode* p, CComponentDataObject*)
{
  //
  // Containers will be sorted with respect to containers and leaves will be
  // sorted with respect to leaves but they won't be intermingled.
  //
    p->m_pContainer = this;
  
  CNodeList* pChildNodeList = NULL;
  if (p->IsContainer())
  {
    pChildNodeList = &m_containerChildList;
  }
  else
  {
    pChildNodeList = &m_leafChildList;
  }

  //
  // Find the position to insert the node in the list in sorted order
  //
  POSITION pos = pChildNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CTreeNode* pNodeInList = pChildNodeList->GetAt(pos);
    // NOTICE-2002/04/22-artm : using _wcsicoll() here is okay since GetDisplayName() never
    // returns NULL (underlying implementation is a CString object).
    if (_wcsicoll(p->GetDisplayName(), pNodeInList->GetDisplayName()) < 0)
    {
      break;
    }
    pChildNodeList->GetNext(pos);
  }
  if (pos == NULL)
  {
      return NULL != pChildNodeList->AddTail(p); 
  }
  return NULL != pChildNodeList->InsertBefore(pos, p);
}

void CContainerNode::RemoveAllChildrenFromList() 
{
  RemoveAllContainersFromList();
  RemoveAllLeavesFromList();
}

int CContainerNode::Compare(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol, LPARAM)
{
    // default sorting behavior
    LPCTSTR lpszA = pNodeA->GetString(nCol);
    LPCTSTR lpszB = pNodeB->GetString(nCol);
    // cannot process NULL strings, have to use ""
    ASSERT(lpszA != NULL);
    ASSERT(lpszB != NULL);
    return _tcsicoll( (lpszA != NULL) ? lpszA : g_lpszNullString, (lpszB != NULL) ? lpszB : g_lpszNullString);
}

void CContainerNode::ForceEnumeration(CComponentDataObject* pComponentData)
{
    if (IsEnumerated())
        return;
    OnEnumerate(pComponentData);
    MarkEnumerated();
}

void CContainerNode::MarkEnumerated(BOOL bEnum) 
{ 
    ASSERT(IsContainer()); 
    if (bEnum)
        m_dwNodeFlags |= TN_FLAG_CONTAINER_ENUM;
    else
        m_dwNodeFlags &= ~TN_FLAG_CONTAINER_ENUM;
}

void CContainerNode::MarkEnumeratedAndLoaded(CComponentDataObject* pComponentData)
{
    MarkEnumerated();
    OnChangeState(pComponentData); // move to loading
    OnChangeState(pComponentData); // move to loaded
}


/////////////////////////////////////////////////////////////////////////////
// CBackgroundThread

CBackgroundThread::CBackgroundThread()
{
    m_pQueryObj = NULL;
    m_bAutoDelete = FALSE;
    m_bAbandoned = FALSE;
    m_pContNode = NULL;
    m_hEventHandle = NULL;
    ExceptionPropagatingInitializeCriticalSection(&m_cs);
    m_nQueueCountMax = 10; 
}

CBackgroundThread::~CBackgroundThread()
{
    TRACE(_T("CBackgroundThread::~CBackgroundThread()\n"));
    ASSERT(IsAbandoned() || IsQueueEmpty());
    ::DeleteCriticalSection(&m_cs);
    if (m_hEventHandle != NULL)
    {
        VERIFY(::CloseHandle(m_hEventHandle));
        m_hEventHandle = NULL;
    }
    if (m_pQueryObj != NULL)
    {
        delete m_pQueryObj;
        m_pQueryObj = NULL;
    }
}

void CBackgroundThread::SetQueryObj(CQueryObj* pQueryObj) 
{ 
    ASSERT(pQueryObj != NULL);
    m_pQueryObj = pQueryObj;
    m_pQueryObj->SetThread(this);
}

BOOL CBackgroundThread::Start(CMTContainerNode* pNode, CComponentDataObject* pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_pContNode == NULL);
    m_pContNode = pNode;

    m_hHiddenWnd = pComponentData->GetHiddenWindow();

   // REVIEWED-2002/03/08-JeffJon-Squatting isn't an issue here because this is not a
   // named event

   ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
    m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
    if (m_hEventHandle == NULL)
        return FALSE;
    return CreateThread();
}

int CBackgroundThread::Run()
{
    ASSERT(m_pContNode != NULL);
    ASSERT(m_pQueryObj != NULL);
    TRACE(_T("CBackgroundThread::Run() started\n"));

    // NTRAID#NTBUG9-662019-2002/07/17-artm
    try
    {
        while (m_pQueryObj->Enumerate());

        // before exiting, have to make sure there are no items in the queue
        if (!IsQueueEmpty())
            VERIFY(PostHaveData());
    }
    catch (CMemoryException *exc)
    {
        // Tell the user about the error.
        exc->ReportError();
        exc->Delete();

        PostError(ERROR_OUTOFMEMORY);

        exit(-1);
    }

    VERIFY(PostExiting());

    // wait for the main thread to acknowledge the exiting message
    WaitForExitAcknowledge();

    ASSERT(IsAbandoned() || IsQueueEmpty()); // we cannot lose items in the queue
    TRACE(_T("CBackgroundThread::Run() terminated\n"));
    return 0;
}


void CBackgroundThread::Abandon()
{
    Lock();
    TRACE(_T("CBackgroundThread::Abandon()\n"));
    m_bAutoDelete = TRUE;
    m_bAbandoned = TRUE;
    Unlock();
  VERIFY(0 != ::SetEvent(m_hEventHandle));
}

BOOL CBackgroundThread::IsAbandoned()
{
    Lock();
    BOOL b = m_bAbandoned;
    Unlock();
    return b;
}

BOOL CBackgroundThread::OnAddToQueue(INT_PTR nCount) 
{
  BOOL bPostedMessage = FALSE;
    if (nCount >= m_nQueueCountMax)
  {
        VERIFY(PostHaveData());
    bPostedMessage = TRUE;
  }
  return bPostedMessage;
}


CObjBase* CBackgroundThread::RemoveFromQueue()
{
    Lock();
    ASSERT(m_pQueryObj != NULL);
    CObjBaseList* pQueue = m_pQueryObj->GetQueue();
    CObjBase* p =  pQueue->IsEmpty() ? NULL : pQueue->RemoveHead(); 
    Unlock();
    return p;
}

BOOL CBackgroundThread::IsQueueEmpty()
{
    Lock();
    ASSERT(m_pQueryObj != NULL);
    CObjBaseList* pQueue = m_pQueryObj->GetQueue();
    BOOL bRes = pQueue->IsEmpty(); 
    Unlock();
    return bRes;
}


BOOL CBackgroundThread::PostHaveData()
{
    return PostMessageToComponentDataRaw(CHiddenWnd::s_NodeThreadHaveDataNotificationMessage,
                            (WPARAM)m_pContNode, (LPARAM)0);
}

BOOL CBackgroundThread::PostError(DWORD dwErr) 
{ 
    return PostMessageToComponentDataRaw(CHiddenWnd::s_NodeThreadErrorNotificationMessage,
                            (WPARAM)m_pContNode, (LPARAM)dwErr);
}

BOOL CBackgroundThread::PostExiting()
{
    return PostMessageToComponentDataRaw(CHiddenWnd::s_NodeThreadExitingNotificationMessage,
                            (WPARAM)m_pContNode, (LPARAM)0);
}


BOOL CBackgroundThread::PostMessageToComponentDataRaw(UINT Msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = IsAbandoned();
    if (b)
  {
        return TRUE; // no need to post
  }

    ASSERT(m_pContNode != NULL);

    ASSERT(m_hHiddenWnd != NULL);
    ASSERT(::IsWindow(m_hHiddenWnd));
    return ::PostMessage(m_hHiddenWnd, Msg, wParam, lParam);
}


void CBackgroundThread::WaitForExitAcknowledge() 
{
    VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE)); 
}

////////////////////////////////////////////////////////////////////////
// CMTContainerNode


CMTContainerNode::~CMTContainerNode()
{
    ASSERT(m_pThread == NULL);
}


BOOL CMTContainerNode::OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync)
{
    OnChangeState(pComponentData);
    VERIFY(StartBackgroundThread(pComponentData, bAsync));
    return FALSE; // children not added, the thread will add them later
}


BOOL CMTContainerNode::OnRefresh(CComponentDataObject* pComponentData,
                                 CNodeList* pNodeList)
{
  BOOL bRet = TRUE;

  if (pNodeList->GetCount() == 1)  // single selection
  {
      BOOL bLocked = IsThreadLocked();
      ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
      if (bLocked)
          return FALSE; 
      if (IsSheetLocked())
      {
          if (!CanCloseSheets())
        {
           pComponentData->GetPropertyPageHolderTable()->BroadcastSelectPage(this, -1);
              return FALSE;
        }
          pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
      }
      ASSERT(!IsSheetLocked());

      RemoveAllChildrenHelper(pComponentData);
      ASSERT(!HasChildren());
      OnEnumerate(pComponentData); // will spawn a thread to do enumeration
      MarkEnumerated();
  }
  else // multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
    return TRUE;
}

void CMTContainerNode::AbandonThread(CComponentDataObject* pComponentData)
{
    if(m_pThread == NULL) // nothing running
        return;
    m_pThread->Abandon();
    m_pThread = NULL;
    pComponentData->GetRunningThreadTable()->Remove(this);
}



BOOL CMTContainerNode::StartBackgroundThread(CComponentDataObject* pComponentData, BOOL bAsync)
{
    ASSERT(m_pThread == NULL); // nothing running

    // notify the UI to change icon, if needed
    VERIFY(SUCCEEDED(pComponentData->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
    m_pThread = CreateThreadObject();
    ASSERT(m_pThread != NULL);
    m_pThread->SetQueryObj(OnCreateQuery());
    BOOL bRes =  m_pThread->Start(this, pComponentData);
    if (bRes)
    {
        pComponentData->GetRunningThreadTable()->Add(this);
        // we need to call UpdateVerbState() because the lock count changed
        // by adding the node from the running thread table
        VERIFY(SUCCEEDED(pComponentData->UpdateVerbState(this)));
    }

  //
  // If we don't want this call to be asynchronous then we have to wait for
  // the thread to finish
  //
  if (!bAsync)
  {
    pComponentData->WaitForThreadExitMessage(this);
  }
    return bRes;
}

void CMTContainerNode::OnThreadHaveDataNotification(CComponentDataObject* pComponentDataObject)
{
    ASSERT(m_pThread != NULL);
    ASSERT(IsThreadLocked());
    // do data transfer from thread queue
    CObjBase* p = m_pThread->RemoveFromQueue();
    while (p)
    {
        // add new node to the list of children and propagate to the UI
        OnHaveData(p,pComponentDataObject);
    p = m_pThread->RemoveFromQueue();
    }
}

void CMTContainerNode::OnThreadErrorNotification(DWORD dwErr, CComponentDataObject*)
{
    ASSERT(m_pThread != NULL);
    ASSERT(IsThreadLocked());
    OnError(dwErr);
}

void CMTContainerNode::OnThreadExitingNotification(CComponentDataObject* pComponentDataObject)
{
    ASSERT(m_pThread != NULL);
    ASSERT(IsThreadLocked());
#if (TRUE)
    // let the thread know it can shut down
    m_pThread->AcknowledgeExiting();
    VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_pThread->m_hThread,INFINITE));
    OnChangeState(pComponentDataObject);
    delete m_pThread;
    m_pThread = NULL;
    pComponentDataObject->GetRunningThreadTable()->Remove(this);
    // we need to call UpdateVerbState() because the lock count changed
    // by removing the node from the running thread table
    VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));

  TRACE(_T("OnThreadExitingNotification()\n"));

#else // maybe better way of doing it???
    // we are going to detach from the thread, so make copies of variables
    HANDLE hThread = m_pThread->m_hThread;
    CBackgroundThread* pThread = m_pThread;
    AbandonThread(pComponentDataObject); // sets m_pThread = NULL
    // acknowledge to thread
    pThread->AcknowledgeExiting();
    VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(hThread,INFINITE));
    OnChangeState(pComponentDataObject);
#endif

    VERIFY(SUCCEEDED(pComponentDataObject->SortResultPane(this)));
}




///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mtfrmwk\treedata.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _TREEDATA_H
#define _TREEDATA_H

/////////////////////////////////////////////////////////////////////////////
// Miscellanea 
extern LPCWSTR g_lpszNullString;


/////////////////////////////////////////////////////////////////////////////
// Generic Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
        TRACE(_T("Release called on NULL interface ptr")); 
    }
}

///////////////////////////////////////////////////////////////////
// Context Menu data structures and macros

#define MAX_CONTEXT_MENU_STRLEN 128

struct MENUDATARES
{
	WCHAR szBuffer[MAX_CONTEXT_MENU_STRLEN*2];
	UINT uResID;
};

struct MENUMAP
{
	MENUDATARES* dataRes;
	CONTEXTMENUITEM2* ctxMenu;
};

#define DECLARE_MENU(theClass) \
class theClass \
{ \
public: \
	static LPCONTEXTMENUITEM2 GetContextMenuItem() { return GetMenuMap()->ctxMenu; }; \
	static MENUMAP* GetMenuMap(); \
}; 

#define BEGIN_MENU(theClass) \
	 MENUMAP* theClass::GetMenuMap() { 

#define BEGIN_CTX static CONTEXTMENUITEM2 ctx[] = {

#define CTX_ENTRY_TOP(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0, languageIndependantStringID},
#define CTX_ENTRY_NEW(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, 0, languageIndependantStringID},
#define CTX_ENTRY_TASK(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0, languageIndependantStringID},
#define CTX_ENTRY_VIEW(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0, languageIndependantStringID},

#define END_CTX { NULL, NULL, 0, 0, 0, 0} };

#define BEGIN_RES  static MENUDATARES dataRes[] = {

#define RES_ENTRY(resID) {L"", resID },

#define END_RES   { NULL, 0 }	};


#define END_MENU \
		static MENUMAP menuMap = { dataRes, ctx }; \
		return &menuMap; } 


BOOL LoadContextMenuResources(MENUMAP* pMenuMap);

//
// Toolbar macros
//
#define DECLARE_TOOLBAR_MAP() \
public: \
  virtual HRESULT ToolbarNotify(int event, \
                                CComponentDataObject* pComponentData, \
                                CNodeList* pNodeList);

#define BEGIN_TOOLBAR_MAP(theClass) \
HRESULT theClass::ToolbarNotify(int event, \
                                CComponentDataObject* pComponentData, \
                                CNodeList* pNodeList) \
{ \
  HRESULT hr = S_OK; \
  event; \
  pComponentData; \
  pNodeList;


#define TOOLBAR_EVENT(toolbar_event, function) \
  if (event == toolbar_event) \
  { \
    hr = function(pComponentData, pNodeList); \
  }

#define END_TOOLBAR_MAP() \
  return hr; \
}

#define DECLARE_TOOLBAR_EVENT(toolbar_event, value) \
  static const int toolbar_event = value;

  
////////////////////////////////////////////////////////////
// header control resources data structures
#define MAX_RESULT_HEADER_STRLEN 128

struct RESULT_HEADERMAP
{
	WCHAR szBuffer[MAX_RESULT_HEADER_STRLEN];
	UINT uResID;
	int nFormat;
	int nWidth;
};

BOOL LoadResultHeaderResources(RESULT_HEADERMAP* pHeaderMap, int nCols);

////////////////////////////////////////////////////////////
// bitmap strips resources data structures
template <UINT nResID> class CBitmapHolder : public CBitmap
{
public:
	BOOL LoadBitmap() { return CBitmap::LoadBitmap(nResID);}
};

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CComponentDataObject;  
class CContainerNode;
class CMTContainerNode;
class CLeafNode;
class CPropertyPageHolderBase;
class CBackgroundThread;
class CQueryObj;

/////////////////////////////////////////////////////////////////////
// CObjBase
// base class for all objects relying on RTTI and class type info
class CObjBase
{
public:
	CObjBase() {}
	virtual ~CObjBase() {}
};

/////////////////////////////////////////////////////////////////////
// CTreeNode
// cannot construct objects of this class, have to derive from it

#define DECLARE_NODE_GUID() \
	static const GUID NodeTypeGUID; \
	virtual const GUID* GetNodeType() { return &NodeTypeGUID;}



// use the HIWORD for generic flags and leave the LOWORD for application specific data
#define TN_FLAG_HIDDEN				(0x00010000) // does not appear in the UI
#define TN_FLAG_NO_WRITE			(0x00020000) // cannot edit or create
#define TN_FLAG_NO_DELETE			(0x00040000) // cannot delete
#define TN_FLAG_HAS_SHEET			(0x00080000) // this node or a child has a property sheet up

#define TN_FLAG_CONTAINER			(0x00100000) // container (i.e. not leaf)
#define TN_FLAG_CONTAINER_ENUM		(0x00200000) // container node has been enumerated (back end)
#define TN_FLAG_CONTAINER_EXP		(0x00400000) // container node has been expanded (UI node)

class CTreeNode : public CObjBase
{
public:
	virtual ~CTreeNode() {}
	CContainerNode* GetContainer() { return m_pContainer; }
	void SetContainer(CContainerNode* pContainer) { m_pContainer = pContainer; }
	BOOL HasContainer(CContainerNode* pContainerNode);
	virtual LPCWSTR GetDisplayName() { return m_szDisplayName; }
	virtual void SetDisplayName(LPCWSTR lpszDisplayName) { m_szDisplayName = lpszDisplayName;}

  //
	// Data Object related data
  //
	virtual const GUID* GetNodeType() { return NULL;}
	virtual HRESULT GetDataHere(CLIPFORMAT, 
                              LPSTGMEDIUM, 
			                        CDataObject*) { return DV_E_CLIPFORMAT;}
	virtual HRESULT GetData(CLIPFORMAT, 
                              LPSTGMEDIUM, 
			                        CDataObject*) { return DV_E_CLIPFORMAT;}

  virtual HRESULT GetResultViewType(CComponentDataObject* pComponentData,
                                    LPOLESTR* ppViewType, 
                                    long* pViewOptions);
  virtual HRESULT OnShow(LPCONSOLE) { return S_OK; }

  //
	// flag manipulation API's
  //
	BOOL IsContainer() { return (m_dwNodeFlags & TN_FLAG_CONTAINER) ? TRUE : FALSE;}
	BOOL IsVisible() { return (m_dwNodeFlags & TN_FLAG_HIDDEN) ? FALSE : TRUE;}
	BOOL CanDelete() { return (m_dwNodeFlags & TN_FLAG_NO_DELETE) ? FALSE : TRUE;}
	virtual void SetFlagsDown(DWORD dwNodeFlags, BOOL bSet);
	void SetFlagsUp(DWORD dwNodeFlags, BOOL bSet);
	DWORD GetFlags() { return m_dwNodeFlags;}
  virtual BOOL CanExpandSync() { return FALSE; }

	virtual void Show(BOOL bShow, CComponentDataObject* pComponentData);
	
	

  //
  // Verb handlers
  //
  virtual HRESULT OnRename(CComponentDataObject*,
                           LPWSTR) { return S_FALSE; }
	virtual void OnDelete(CComponentDataObject* pComponentData, 
                        CNodeList* pNodeList) = 0;
	virtual BOOL OnRefresh(CComponentDataObject*,
                         CNodeList*)	{ return FALSE; }
	virtual HRESULT OnCommand(long, 
                            DATA_OBJECT_TYPES, 
                            CComponentDataObject*,
                            CNodeList*) { return S_OK; };

	virtual HRESULT OnAddMenuItems(IContextMenuCallback2* pContextMenuCallback2, 
									               DATA_OBJECT_TYPES type,
									               long *pInsertionAllowed,
                                 CNodeList* pNodeList);
  virtual HRESULT OnAddMenuItemsMultipleSelect(IContextMenuCallback2*, 
									                             DATA_OBJECT_TYPES,
									                             long*,
                                               CNodeList*) { return S_OK; }

	virtual MMC_CONSOLE_VERB GetDefaultVerb(DATA_OBJECT_TYPES type, 
                                          CNodeList* pNodeList);
	virtual void OnSetVerbState(LPCONSOLEVERB pConsoleVerb, 
                              DATA_OBJECT_TYPES type,
                              CNodeList* pNodeList);
  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, 
                                        CNodeList* pNodeList);

	virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);
	virtual BOOL OnSetCutVerbState(DATA_OBJECT_TYPES type, 
                                 BOOL* pbHide, 
                                 CNodeList* pNodeList);
	virtual BOOL OnSetCopyVerbState(DATA_OBJECT_TYPES type, 
                                  BOOL* pbHide, 
                                  CNodeList* pNodeList);
	virtual BOOL OnSetPasteVerbState(DATA_OBJECT_TYPES type, 
                                   BOOL* pbHide, 
                                   CNodeList* pNodeList);
	virtual BOOL OnSetPrintVerbState(DATA_OBJECT_TYPES type, 
                                   BOOL* pbHide, 
                                   CNodeList* pNodeList);

  //
  // Property Page methods
  //
  virtual BOOL DelegatesPPToContainer() { return FALSE; }
  virtual void ShowPageForNode(CComponentDataObject* pComponentDataObject); 
	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList); 
	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK,
                                      LONG_PTR,
                                      CNodeList*) { return E_FAIL; }
	virtual void OnPropertyChange(CComponentDataObject* pComponentData, 
									 BOOL bScopePane,long changeMask);
  virtual BOOL CanCloseSheets() { return TRUE;}
	void OnCreateSheet();
	void OnDeleteSheet();
	BOOL HasSheet() { return (m_dwNodeFlags & TN_FLAG_HAS_SHEET) ? TRUE : FALSE;}
	BOOL GetSheetCount() { return m_nSheetCount;}
	virtual void IncrementSheetLockCount();
	virtual void DecrementSheetLockCount();
	BOOL IsSheetLocked() { return m_nSheetLockCount > 0;}
	BOOL IsNodeForPropSheet(){ return  m_bNodeForPropSheet;}
	void NodeForPropSheet(){ m_bNodeForPropSheet = TRUE;}
  //
  // Misc.
  //
  virtual LPWSTR  GetDescriptionBarText() { return L""; }
	virtual LPCWSTR GetString(int nCol) = 0;
	virtual int     GetImageIndex(BOOL bOpenImage) = 0;
	virtual void    Trace() { TRACE(_T("Name %s "), (LPCTSTR)m_szDisplayName);}

	void DeleteHelper(CComponentDataObject* pComponentData);

protected:
	CString m_szDisplayName;		// name of the item
	CContainerNode* m_pContainer;	// back pointer to the container the node is in
	DWORD m_dwNodeFlags;
	LONG m_nSheetLockCount;			// keeps track if a node has been locked by a property sheet
	LONG m_nSheetCount;				// keeps track of the # of sheets the node has up
	BOOL m_bNodeForPropSheet;		// This node is created for property sheet display only
									// Once the propertysheet is destroyed, node should be deleted.
	CTreeNode() 
	{ 
		m_pContainer = NULL; 
		m_nSheetLockCount = 0; 
		m_dwNodeFlags = 0x0; //m_dwNodeFlags |= TN_FLAG_HIDDEN; 
		m_nSheetCount = 0; 
		m_bNodeForPropSheet = FALSE;
	}
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() { return NULL;}
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2,
								             long*) { return TRUE;}

	friend class CContainerNode; // to get access to the m_pContainer member

  //
  // Provides a default implementation for toolbar support
  //
  DECLARE_TOOLBAR_MAP()
};

///////////////////////////////////////////////////////////////////////
// CNodeList 
// collection of nodes
typedef CList<CTreeNode*,CTreeNode*> CNodeListBase;

class CNodeList : public CNodeListBase
{
public:
	BOOL RemoveNode(CTreeNode* p)
	{
		POSITION pos = Find(p);
		if (pos == NULL)
			return FALSE;
		RemoveAt(pos);
		return TRUE;
	}
	void RemoveAllNodes() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}
	BOOL HasNode(CTreeNode* p)
	{
		return NULL != Find(p);
	}

   INT_PTR GetVisibleCount();
};


////////////////////////////////////////////////////////////////////////
// CContainerNode
// node that can be a container of other nodes

class CContainerNode : public CTreeNode
{
public:
	CContainerNode() 
	{ 
		m_ID = 0; 
		m_dwNodeFlags |= TN_FLAG_CONTAINER; 
		m_nState = -1; 
		m_dwErr = 0x0;
		m_nThreadLockCount = 0;
	}
	virtual ~CContainerNode()  { ASSERT(m_nSheetLockCount == 0); RemoveAllChildrenFromList(); }
	CContainerNode* GetRootContainer()
		{ return (m_pContainer != NULL) ? m_pContainer->GetRootContainer() : this; }

  //
  // Thread Helpers
  //
	void IncrementThreadLockCount();
	void DecrementThreadLockCount();
	BOOL IsThreadLocked() { return m_nThreadLockCount > 0;}

	virtual BOOL OnEnumerate(CComponentDataObject*, BOOL bAsync = TRUE)
	{ bAsync; return TRUE;} // TRUE = add children in the list to UI

  //
  // Node state helpers
  //
	BOOL HasChildren() { return !m_containerChildList.IsEmpty() || !m_leafChildList.IsEmpty(); }
	void ForceEnumeration(CComponentDataObject* pComponentData);
  void MarkEnumerated(BOOL bEnum = TRUE);
	BOOL IsEnumerated() { ASSERT(IsContainer()); return (m_dwNodeFlags & TN_FLAG_CONTAINER_ENUM) ? TRUE : FALSE;}
	void MarkExpanded() {	ASSERT(IsContainer()); m_dwNodeFlags |= TN_FLAG_CONTAINER_EXP; }
	BOOL IsExpanded() { ASSERT(IsContainer()); return (m_dwNodeFlags & TN_FLAG_CONTAINER_EXP) ? TRUE : FALSE;}
	void MarkEnumeratedAndLoaded(CComponentDataObject* pComponentData);

	void SetScopeID(HSCOPEITEM ID) { m_ID = ID;}
	HSCOPEITEM GetScopeID() { return m_ID;}
	BOOL AddedToScopePane() { return GetScopeID() != 0;}

	virtual CColumnSet* GetColumnSet() = 0;
	virtual LPCWSTR GetColumnID() = 0;

	virtual void SetFlagsDown(DWORD dwNodeFlags, BOOL bSet);
	void SetFlagsOnNonContainers(DWORD dwNodeFlags,BOOL bSet);

  //
	// child list mainpulation API's
  //
	CNodeList* GetContainerChildList() { return &m_containerChildList; }
  CNodeList* GetLeafChildList() { return &m_leafChildList; }
	BOOL AddChildToList(CTreeNode* p);
  BOOL AddChildToListSorted(CTreeNode* p, CComponentDataObject* pComponentData); 
  BOOL RemoveChildFromList(CTreeNode* p);
	void RemoveAllChildrenFromList();
  void RemoveAllContainersFromList() { m_containerChildList.RemoveAllNodes(); }
  void RemoveAllLeavesFromList() { m_leafChildList.RemoveAllNodes(); }

  //
	// given a node, it searches for it recursively and if successful it returns the 
	// container the node is in
  //
	BOOL FindChild(CTreeNode* pNode, CTreeNode** ppContainer);
	
	BOOL AddChildToListAndUI(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData);
  BOOL AddChildToListAndUISorted(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData);

	virtual int Compare(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol, LPARAM lUserParam);

	virtual HRESULT CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK, 
		                                        LONG_PTR, 
                                            long) { return E_FAIL;}
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual void OnColumnsChanged(int*, int) {}
	void RemoveAllChildrenHelper(CComponentDataObject* pComponentData);

protected:
	virtual void OnChangeState(CComponentDataObject*) {}
	void AddCurrentChildrenToUI(CComponentDataObject* pComponentData);

	LONG m_nThreadLockCount;
	CNodeList m_leafChildList; // leaf contents of the node
  CNodeList m_containerChildList; // container contents of the node
	HSCOPEITEM m_ID;	// ID when the item is inserted in the master tree
	int m_nState;	// for general purpose finite state machine implementation
	DWORD m_dwErr;	// for general purpose error handling
};

////////////////////////////////////////////////////////////////////////
// CLeafNode
// node that is not a container of other nodes

class CLeafNode : public CTreeNode
{
public:

};


///////////////////////////////////////////////////////////////////
// data nodes

// the root, with folders in it
class CRootData : public CContainerNode
{
public:
	CRootData(CComponentDataObject* pComponentData) 
	{ 
		ASSERT(pComponentData != NULL);
		m_pComponentData = pComponentData; 
		m_bDirty = FALSE; 
	}
	virtual LPCWSTR GetString(int nCol) 
	{
		if (nCol == 0)
			return GetDisplayName();
		return g_lpszNullString; 
	}
	CComponentDataObject* GetComponentDataObject(){ return m_pComponentData;}

	CTreeNode* GetNodeFromCookie(MMC_COOKIE cookie)
	{
		// cookie == 0 means root to enumerate
		if (cookie == NULL)
		{
			return (CTreeNode*)this;
		}
		else
		{
			CTreeNode* pNode = (CTreeNode*)cookie;
			CTreeNode* pContainer;
			if (FindChild(pNode,&pContainer))
			{
				return pNode;
			}
		}
		return NULL;
	}
	// IStream manipulation helpers
	virtual HRESULT IsDirty() { return m_bDirty ? S_OK : S_FALSE; }
	virtual HRESULT Load(IStream*) { return S_OK; }
	virtual HRESULT Save(IStream*, BOOL) { return S_OK; }

	void SetDirtyFlag(BOOL bDirty) { m_bDirty = bDirty ;}

private:
	CComponentDataObject* m_pComponentData;
	BOOL m_bDirty;
	CString m_szSnapinType;		// constant part of the name loaded from resources
};


//////////////////////////////////////////////////////////////////////
// CBackgroundThread


class CBackgroundThread : public CWinThread
{
public:
	CBackgroundThread();
	virtual ~CBackgroundThread();
	
	void SetQueryObj(CQueryObj* pQueryObj);
	BOOL Start(CMTContainerNode* pNode, CComponentDataObject* pComponentData);
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run();								// MFC override

   // REVIEWED-2002/03/08-JeffJon-There appears to be no danger
   // of getting stuck in the critical section

	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	void Abandon();
	BOOL IsAbandoned();

	BOOL OnAddToQueue(INT_PTR nCount);
	CObjBase* RemoveFromQueue();
	BOOL IsQueueEmpty();
	BOOL PostHaveData();
	BOOL PostError(DWORD dwErr);
	BOOL PostExiting();
	void AcknowledgeExiting() { VERIFY(0 != ::SetEvent(m_hEventHandle));}

private:
	// communication with ComponentData object 
	BOOL PostMessageToComponentDataRaw(UINT Msg, WPARAM wParam, LPARAM lParam);
	void WaitForExitAcknowledge();

	CRITICAL_SECTION		m_cs;					// critical section to sync access to data
	HANDLE					m_hEventHandle;			// syncronization handle for shutdown notification

	CMTContainerNode*		m_pContNode;			// back pointer to node the thread is executing for
	CQueryObj*				m_pQueryObj;			// query object the thread is executing

	INT_PTR				m_nQueueCountMax;		// max size of the queue

	HWND					m_hHiddenWnd;			// handle to window to post messages
	BOOL					m_bAbandoned;
};



//////////////////////////////////////////////////////////////////////
// CQueryObj 

typedef CList<CObjBase*,CObjBase*> CObjBaseList;

class CQueryObj
{
public:
	CQueryObj() { m_dwErr = 0; m_pThread = NULL;}
	virtual ~CQueryObj()
	{
		while (!m_objQueue.IsEmpty()) 
			delete m_objQueue.RemoveTail();
	};

	void SetThread(CBackgroundThread* pThread)
	{
		ASSERT(pThread != NULL);
		m_pThread = pThread;
	}
	CBackgroundThread* GetThread() {return m_pThread;}
	virtual BOOL Enumerate() { return FALSE;}
	virtual BOOL AddQueryResult(CObjBase* pObj)
	{
		BOOL bRes = FALSE;
		if (m_pThread != NULL)
		{
      BOOL bPostedHaveDataMessage = FALSE;
			m_pThread->Lock();
			bRes = NULL != m_objQueue.AddTail(pObj);
			bPostedHaveDataMessage = m_pThread->OnAddToQueue(m_objQueue.GetCount());
			m_pThread->Unlock();

      // wait for the queue length to go down to zero
      if (bPostedHaveDataMessage)
      {
        INT_PTR nQueueCount = 0;
        do 
        {
          m_pThread->Lock();
          nQueueCount = m_objQueue.GetCount();
          m_pThread->Unlock();
          if (m_pThread->IsAbandoned())
          {
            break;
          }
          if (nQueueCount > 0)
          {
            ::Sleep(100);
          }
        }
        while (nQueueCount > 0);
      } // if
		}
		else
		{
			bRes = NULL != m_objQueue.AddTail(pObj);
		}
		ASSERT(bRes);
		return bRes;
	}
	virtual void OnError(DWORD dwErr)
	{
		if (m_pThread != NULL)
		{
			m_pThread->Lock();
			m_dwErr = dwErr;
			m_pThread->Unlock();
			m_pThread->PostError(dwErr);
		}
		else
		{
			m_dwErr = dwErr;
		}
	}

	CObjBaseList* GetQueue() { return &m_objQueue;}
	DWORD GetError() 
	{
		if (m_pThread != NULL)
		{
			m_pThread->Lock();
			DWORD dwErr = m_dwErr;
			m_pThread->Unlock();
			return dwErr;
		}
		else
		{
			return m_dwErr;
		}
	}
private:
	CBackgroundThread*	m_pThread;	// back pointer, if in the context of a thread
	CObjBaseList		m_objQueue;	// queue for results
	DWORD				m_dwErr;	// error code, if any
};

////////////////////////////////////////////////////////////////////////
// CMTContainerNode
// container that can do operations from a secondary thread

class CMTContainerNode : public CContainerNode
{
public:
	CMTContainerNode() 
	{ 
		m_pThread = NULL;
	}
	virtual ~CMTContainerNode();

	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);

protected:
		
	// thread creation
	virtual CBackgroundThread* CreateThreadObject() 
	{ 
		return new CBackgroundThread(); // override if need derived tipe of object
	} 

	// query creation
	virtual CQueryObj* OnCreateQuery()  // override to create a user defined query object
	{	
		return new CQueryObj(); // return a do-nothing query
	}

	// main message handler for thread messages
	virtual void OnThreadHaveDataNotification(CComponentDataObject* pComponentDataObject);
	virtual void OnThreadErrorNotification(DWORD dwErr, CComponentDataObject* pComponentDataObject);
	virtual void OnThreadExitingNotification(CComponentDataObject* pComponentDataObject);


	virtual void OnHaveData(CObjBase*, CComponentDataObject*) {}
	virtual void OnError(DWORD dwErr) { m_dwErr = dwErr; }

	BOOL StartBackgroundThread(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
	CBackgroundThread* GetThread() { ASSERT(m_pThread != NULL); return m_pThread;}

	void AbandonThread(CComponentDataObject* pComponentData);

private:
	CBackgroundThread* m_pThread;	// pointer to thread object executing the code

	friend class CHiddenWnd;			// to get OnThreadNotification()
	friend class CRunningThreadTable;	// to get AbandonThread()
};


#endif // _TREEDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

#include "stdabout.h"

//	About for "Computer Management" snapin
class CComputerMgmtAbout :
	public CSnapinAbout,
	public CComCoClass<CComputerMgmtAbout, &CLSID_ComputerManagementAbout>

{
public:
DECLARE_REGISTRY(CComputerMgmtAbout, _T("MYCOMPUT.ComputerMgmtAboutObject.1"), _T("MYCOMPUT.ComputerMgmtAboutObject.1"), IDS_MYCOMPUT_DESC, THREADFLAGS_BOTH)
	CComputerMgmtAbout();
};

// version and provider strings

#include <ntverp.h>
#define IDS_SNAPINABOUT_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPINABOUT_PROVIDER VER_COMPANYNAME_STR

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\cmponent.cpp ===
// cmponent.cpp : Implementation of CMyComputerComponent

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(cmponent.cpp)")

#include "dataobj.h"
#include "cmponent.h" // CMyComputerComponent
#include "compdata.h" // CMyComputerComponentData

#include "guidhelp.h" // ExtractData

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcmpnt.cpp" // CComponent

UINT g_aColumns0[4] =
	{IDS_COLUMN_NAME,IDS_COLUMN_TYPE,IDS_COLUMN_DESCRIPTION,0}; // SYSTEMTOOLS, SERVERAPPS, STORAGE
UINT g_aColumns1[2] =
	{IDS_COLUMN_NAME,0}; // MYCOMPUT_COMPUTER

UINT* g_Columns[MYCOMPUT_NUMTYPES] =
	{	g_aColumns1, // MYCOMPUT_COMPUTER
		g_aColumns0, // MYCOMPUT_SYSTEMTOOLS
		g_aColumns0, // MYCOMPUT_SERVERAPPS
		g_aColumns0  // MYCOMPUT_STORAGE
	};

UINT** g_aColumns = g_Columns;
//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
int g_aColumnWidths0[3] = {150,150,150};
int g_aColumnWidths1[1] = {450};
int* g_ColumnWidths[MYCOMPUT_NUMTYPES] =
	{	g_aColumnWidths1, // MYCOMPUT_COMPUTER
		g_aColumnWidths0, // MYCOMPUT_SYSTEMTOOLS
		g_aColumnWidths0, // MYCOMPUT_SERVERAPPS
		g_aColumnWidths0  // MYCOMPUT_STORAGE
	};
int** g_aColumnWidths = g_ColumnWidths;

CMyComputerComponent::CMyComputerComponent()
:	m_pSvcMgmtToolbar( NULL ),
	m_pMyComputerToolbar( NULL ),
	m_pControlbar( NULL ),
	m_pViewedCookie( NULL ),
	m_dwFlagsPersist( 0 ), 
	m_bForcingGetResultType (false)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}

CMyComputerComponent::~CMyComputerComponent()
{
	TRACE_METHOD(CMyComputerComponent,Destructor);
	VERIFY( SUCCEEDED(ReleaseAll()) );
}

HRESULT CMyComputerComponent::ReleaseAll()
{
	MFC_TRY;

	TRACE_METHOD(CMyComputerComponent,ReleaseAll);

	SAFE_RELEASE(m_pSvcMgmtToolbar);
	SAFE_RELEASE(m_pMyComputerToolbar);
	SAFE_RELEASE(m_pControlbar);
	// ISSUE: not ready for release yet
	// m_pViewedCookie->Release(); // JonN 10/1/01 465507
	// m_pViewedCookie = NULL;

	return CComponent::ReleaseAll();

	MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation

HRESULT CMyComputerComponent::LoadStrings()
{
	return S_OK;
}

HRESULT CMyComputerComponent::LoadColumns( CMyComputerCookie* pcookie )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // 2002/03/22-JonN 572859

	TEST_NONNULL_PTR_PARAM(pcookie);

	return LoadColumnsFromArrays( (INT)(pcookie->m_objecttype) );
}


HRESULT CMyComputerComponent::Show( CCookie* pcookie, LPARAM arg, HSCOPEITEM /*hScopeItem*/ )
{
	TEST_NONNULL_PTR_PARAM(pcookie);

	// 662617-2002/07/24-JonN LoadString was failing
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());

	if ( QueryComponentDataRef ().m_bMessageView )
	{
		CComPtr<IUnknown> spUnknown;
		CComPtr<IMessageView> spMessageView;

		HRESULT hr = m_pConsole->QueryResultView(&spUnknown);
		if (SUCCEEDED(hr))
		{
			hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
			if (SUCCEEDED(hr))
			{
				CString title;

				VERIFY (title.LoadString (IDS_TASKPADTITLE_COMPUTER));
				spMessageView->SetTitleText(title);
				spMessageView->SetBodyText(QueryComponentDataRef ().m_strMessageViewMsg);
				spMessageView->SetIcon(Icon_Information);
			}
			if ( E_NOINTERFACE == hr )
			{
				// The interface "IMessageView" was not found so call 
				// UpdateAllViews to force a call to GetResultType () which
				// will install it.  Since UpdateAllViews call MMCN_SHOW before
				// calling GetResultType, this flag will prevent an endless
				// loop
				// Note: This call is made here because it OnViewChange with 
				// this hint will call SelectScopeItem () which cannot be 
				// called during MMCN_EXPAND
				if ( !m_bForcingGetResultType )  
				{
					m_bForcingGetResultType = true;
					hr = m_pConsole->UpdateAllViews (0, 0, HINT_SELECT_ROOT_NODE);
				}
			}
		}
		return S_OK;
	}

	if ( 0 == arg )
	{
		if ( NULL == m_pResultData )
		{
			ASSERT( FALSE );
			return E_UNEXPECTED;
		}

// not needed		pcookie->ReleaseResultChildren();

		// ISSUE: not ready for release yet
		// m_pViewedCookie->Release(); // JonN 10/1/01 465507
		// m_pViewedCookie = NULL;

		return S_OK;
	}

	m_pViewedCookie = (CMyComputerCookie*)pcookie;
	// ISSUE: not ready for release yet
	// m_pViewedCookie->AddRef(); // JonN 10/1/01 465507

	if (   MYCOMPUT_COMPUTER == m_pViewedCookie->m_objecttype
	    && !(m_pViewedCookie->m_fRootCookieExpanded) )
	{
		m_pViewedCookie->m_fRootCookieExpanded = true;
		CComQIPtr<IConsole2, &IID_IConsole2> pIConsole2 = m_pConsole;
		ASSERT( pIConsole2 );
		if ( pIConsole2 )
		{
			// JonN 5/27/99 Some dead code in this directory contains bad templates for
			// looping on scopecookies, this is a better template
			POSITION pos = pcookie->m_listScopeCookieBlocks.GetHeadPosition();
			while (NULL != pos)
			{
				CBaseCookieBlock* pcookieblock = pcookie->m_listScopeCookieBlocks.GetNext( pos );
				TEST_NONNULL_PTR_PARAM(pcookieblock); // JonN 2/25/02 Security Push
				CMyComputerCookie* pChildCookie = (CMyComputerCookie*)pcookieblock;
				// JonN 03/07/00: PREFIX 56323
				switch ((NULL == pChildCookie) ? MYCOMPUT_COMPUTER
				                               : pChildCookie->m_objecttype)
				{
				case MYCOMPUT_SYSTEMTOOLS:
				case MYCOMPUT_STORAGE:
					{
						HRESULT hr = pIConsole2->Expand(pChildCookie->m_hScopeItem, TRUE);
						ASSERT(SUCCEEDED(hr));
					}
					break;
				default:
					break;
				}
			}
		}
	}

	LoadColumns( m_pViewedCookie );

	return PopulateListbox( m_pViewedCookie );
}

HRESULT CMyComputerComponent::OnNotifyAddImages( LPDATAOBJECT /*lpDataObject*/,
                                                 LPIMAGELIST lpImageList,
                                                 HSCOPEITEM /*hSelectedItem*/ )
{
	if ( QueryComponentDataRef ().m_bMessageView )
		return S_OK;
	else
		return QueryComponentDataRef().LoadIcons(lpImageList,TRUE);
}

HRESULT CMyComputerComponent::OnNotifySnapinHelp (LPDATAOBJECT pDataObject)
{
	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( pDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED(hr) )
	{
		ASSERT(FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = QueryComponentDataRef().ActiveCookie(pBaseParentCookie);
	if (NULL == pCookie)
	{
		ASSERT(FALSE);
		return S_OK;
	}
	LPCTSTR lpcszHelpTopic = L"compmgmt_topnode.htm";
	switch (pCookie->m_objecttype)
	{
	case MYCOMPUT_SYSTEMTOOLS:
		lpcszHelpTopic = L"system_tools_overview.htm";
		break;
	case MYCOMPUT_SERVERAPPS:
		lpcszHelpTopic = L"server_services_applications_overview.htm";
		break;
	case MYCOMPUT_STORAGE:
		lpcszHelpTopic = L"storage_devices_overview.htm";
		break;
	default:
		ASSERT(FALSE); // fall through
	case MYCOMPUT_COMPUTER:
		break;
	}

	return ShowHelpTopic( lpcszHelpTopic );
}

HRESULT CMyComputerComponent::PopulateListbox(CMyComputerCookie* /*pcookie*/)
{
// not needed	(void) pcookie->AddRefResultChildren();

	return S_OK; // no resultitems in this snapin
}

///////////////////////////////////////////////////////////////////////////////
/// IExtendContextMenu

STDMETHODIMP CMyComputerComponent::AddMenuItems(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed)
{
	MFC_TRY;

	TRACE_METHOD(CMyComputerComponent,AddMenuItems);
	TEST_NONNULL_PTR_PARAM(piDataObject);
	TEST_NONNULL_PTR_PARAM(piCallback);
	TEST_NONNULL_PTR_PARAM(pInsertionAllowed);
	TRACE( "CMyComputerComponent: extending menu\n" );

	if ( 0 == (CCM_INSERTIONALLOWED_VIEW & (*pInsertionAllowed)) )
		return S_OK; // no View menu

	//
	// CODEWORK This code will not work if My Computer becomes an extension,
	// since the RawCookie format will not be available.
	// WARNING cookie cast
	//
	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( piDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED(hr) )
	{
		ASSERT(FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = QueryComponentDataRef().ActiveCookie(pBaseParentCookie);
	if (NULL == pCookie)
	{
		ASSERT(FALSE);
		return S_OK;
	}
	switch (pCookie->m_objecttype)
	{
	case MYCOMPUT_COMPUTER:
	case MYCOMPUT_SYSTEMTOOLS:
	case MYCOMPUT_SERVERAPPS:
		break;
	default:
		ASSERT(FALSE); // fall through
	case MYCOMPUT_STORAGE:
		return S_OK;
	}

	return hr;

	MFC_CATCH;
} // CMyComputerComponent::AddMenuItems()


STDMETHODIMP CMyComputerComponent::Command(
                    LONG            lCommandID,
                    IDataObject*    piDataObject )
{
	MFC_TRY;

	TRACE_METHOD(CMyComputerComponent,Command);
	TEST_NONNULL_PTR_PARAM(piDataObject);
	TRACE( "CMyComputerComponent::Command: command %ld selected\n", lCommandID );

	switch (lCommandID)
	{
	case -1:
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	return S_OK;

	MFC_CATCH;

} // CMyComputerComponent::Command()

HRESULT CMyComputerComponent::OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL /*fSelected*/ )
{
	MFC_TRY;

	TRACE_METHOD(CMyComputerComponent,OnNotifySelect);
	TEST_NONNULL_PTR_PARAM(lpDataObject);

	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( lpDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED(hr) )
	{
		ASSERT(FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = QueryComponentDataRef().ActiveCookie(pBaseParentCookie);
	if (NULL == pCookie)
	{
		ASSERT(FALSE);
		return S_OK;
	}

	// Set the default verb to display the properties of the selected object
	// We do this so that extensions can add properties, we don't have any
#ifdef FIX538345
  //
  // 538345-2002/06/18-JonN Only permit a property sheet if none are
  // currently displayed
  BOOL fAllowProperties = (MYCOMPUT_COMPUTER == pCookie->m_objecttype);
  if (fAllowProperties)
  {
    CComQIPtr<IPropertySheetProvider,
              &IID_IPropertySheetProvider> pISP = m_pConsole;
    ASSERT(!!pISP);
    if (pISP)
    {
      HRESULT hr2 = pISP->FindPropertySheet( 0L,   // cookie
                                             this, // IComponent
                                             lpDataObject);
      if (S_OK == hr2)
        fAllowProperties = FALSE;
    }
  }
#endif
	m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,
	                             ENABLED,
#ifdef FIX538345
	                             fAllowProperties );
#else
	                             (MYCOMPUT_COMPUTER == pCookie->m_objecttype) );
#endif

	m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

	return S_OK;
	MFC_CATCH;
}

STDMETHODIMP CMyComputerComponent::GetResultViewType(
                                           MMC_COOKIE cookie,
                                           LPOLESTR* ppViewType,
                                           long* pViewOptions)
{
	MFC_TRY;
	TEST_NONNULL_PTR_PARAM(pViewOptions); // JonN 2/25/02 Security Push
	if ( QueryComponentDataRef ().m_bMessageView )
	{
		m_bForcingGetResultType = false;
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

		LPOLESTR psz = NULL;
		StringFromCLSID(CLSID_MessageView, &psz);

		USES_CONVERSION;

		if (psz != NULL)
		{
			*ppViewType = psz;
			return S_OK;
		}
		else
			return S_FALSE;
	}
	else
		return CComponent::GetResultViewType( cookie, ppViewType, pViewOptions );
	MFC_CATCH;
}

HRESULT CMyComputerComponent::OnViewChange (LPDATAOBJECT /*pDataObject*/, LPARAM /*data*/, LPARAM hint)
{
	HRESULT hr = S_OK;
	if ( (HINT_SELECT_ROOT_NODE & hint) )
	{
		hr = m_pConsole->SelectScopeItem (QueryComponentDataRef().QueryRootCookie().m_hScopeItem);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\cmponent.h ===
// cmponent.h : Declaration of CMyComputerComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "stdcmpnt.h" // CComponent
#include "cookie.h"  // CMyComputerCookie
#include "persist.h" // PersistStream

// forward declarations
class CMyComputerComponentData;

class CMyComputerComponent :
	  public CComponent
	, public IMyComputer
	, public IExtendContextMenu
	, public PersistStream
{
public:
	CMyComputerComponent();
	virtual ~CMyComputerComponent();
BEGIN_COM_MAP(CMyComputerComponent)
	COM_INTERFACE_ENTRY(IMyComputer)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IFileServiceMgmt

// IComponent implemented in CComponent
    HRESULT OnViewChange (LPDATAOBJECT pDataObject, LPARAM data, LPARAM hint);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);

// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
                    IDataObject*          piDataObject,
					IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed);
	STDMETHOD(Command)(
					LONG	        lCommandID,
                    IDataObject*    piDataObject );

	void ExpandAndSelect( MyComputerObjectType objecttype );
	void LaunchWelcomeApp();

// IPersistStream
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_MyComputer;
		return S_OK;
	}
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);


	// support methods for IComponent
	virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
	virtual HRESULT ReleaseAll();
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject,
	                                   LPIMAGELIST lpImageList,
	                                   HSCOPEITEM hSelectedItem );
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);

	HRESULT PopulateListbox(CMyComputerCookie* pcookie);
//	HRESULT PopulateServices(CMyComputerCookie* pcookie);

//	HRESULT AddServiceItems(CMyComputerCookie* pParentCookie, ENUM_SERVICE_STATUS * rgESS, DWORD nDataItems);

//	HRESULT EnumerateScopeChildren(CMyComputerCookie* pParentCookie, HSCOPEITEM hParent);

//	HRESULT LoadIcons();
	static HRESULT LoadStrings();
    HRESULT LoadColumns( CMyComputerCookie* pcookie );

	// support methods for IPersistStream
	enum	// Bit fields for m_dwFlagsPersist
		{
		// mskfFirst = 0x0001
		};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	void SetPersistentFlags(DWORD dwFlags)
		{
		m_dwFlagsPersist = dwFlags;
		}

	DWORD GetPersistentFlags()
		{
		return m_dwFlagsPersist;
		}

	CMyComputerComponentData& QueryComponentDataRef()
	{
		return (CMyComputerComponentData&)QueryBaseComponentDataRef();
	}

public:
	LPCONTROLBAR	m_pControlbar; // CODEWORK should use smartpointer
	LPTOOLBAR		m_pSvcMgmtToolbar; // CODEWORK should use smartpointer
	LPTOOLBAR		m_pMyComputerToolbar; // CODEWORK should use smartpointer
	CMyComputerCookie* m_pViewedCookie; // CODEWORK I hate to have to do this...
	static const GUID m_ObjectTypeGUIDs[MYCOMPUT_NUMTYPES];
	static const BSTR m_ObjectTypeStrings[MYCOMPUT_NUMTYPES];

private:
	bool m_bForcingGetResultType;
}; // class CMyComputerComponent


// Enumeration for the icons used
enum
	{
	iIconComputer = 0,			// Root of the snapin
	iIconComputerFail,			// Root of the snapin when we cannot connect to the computer
	iIconSystemTools,			// System Tools
	iIconStorage,				// Storage
	iIconServerApps,			// Server Applications

	iIconLast		// Must be last
	};

typedef enum _COLNUM_COMPUTER {
	COLNUM_COMPUTER_NAME = 0
} COLNUM_ROOT;

HRESULT LoadIconsIntoImageList(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\compdata.h ===
/////////////////////////////////////////////////////////////////////
// compdata.h : Declaration of CMyComputerComponentData
//
// HISTORY
// 01-Jan-1996		???			Creation
// 03-Jun-1997		t-danm		Added Command Line override.  Copied
//								from ..\mmcfmgmt\compdata.h.
//
/////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include <lmcons.h>		// For Lan Manager API constants.
#include "stdcdata.h"	// CComponentData
#include "persist.h"	// PersistStream
#include "cookie.h"		// CMyComputerCookie
#include "resource.h"	// IDS_MYCOMPUT_DESC
#include "cmponent.h"	// LoadIconsIntoImageList

// Helper function to correctly format the node name
CString FormatDisplayName (CString machineName);

// For UpdateAllViews/OnViewChange
#define HINT_SELECT_ROOT_NODE	0x00000001

class CMyComputerComponentData:
   	public CComponentData,
   	public IExtendPropertySheet,
	public PersistStream,
    public CHasMachineName,
   	public IExtendContextMenu,
	public CComCoClass<CMyComputerComponentData, &CLSID_MyComputer>
{
public:

// Use DECLARE_NOT_AGGREGATABLE(CMyComputerComponentData)
// if you don't want your object to support aggregation
DECLARE_AGGREGATABLE(CMyComputerComponentData)
DECLARE_REGISTRY(CMyComputerComponentData, _T("MYCOMPUT.ComputerObject.1"), _T("MYCOMPUT.ComputerObject.1"), IDS_MYCOMPUT_DESC, THREADFLAGS_BOTH)

	CMyComputerComponentData();
	~CMyComputerComponentData();
BEGIN_COM_MAP(CMyComputerComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IPersistStream
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_MyComputer;
		return S_OK;
	}
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent);
	HRESULT ExpandServerApps( HSCOPEITEM hParent, CMyComputerCookie* pcookie );

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

	virtual CCookie& QueryBaseRootCookie();

	inline CMyComputerCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CMyComputerCookie*)ActiveBaseCookie( pBaseCookie );
	}

	inline CMyComputerCookie& QueryRootCookie() { return *m_pRootCookie; }

	virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject);
	virtual HRESULT OnNotifyRelease(LPDATAOBJECT lpDataObject, HSCOPEITEM hItem);
	virtual HRESULT OnNotifyPreload(LPDATAOBJECT lpDataObject, HSCOPEITEM hRootScopeItem);

// CHasMachineName
	DECLARE_FORWARDS_MACHINE_NAME( m_pRootCookie )
	bool m_bCannotConnect;
	bool m_bMessageView;
	CString m_strMessageViewMsg;

protected:
	bool ValidateMachine(const CString &sName, bool bDisplayErr);
	HRESULT AddScopeNodes (HSCOPEITEM hParent, CMyComputerCookie& rParentCookie);
	HRESULT ChangeRootNodeName (const CString& newName);
	HRESULT OnChangeComputer (IDataObject* piDataObject);
	// The following members are used to support Command Line override.
	// This code was copied from ..\mmcfmgmt\compdata.h.

	enum	// Bit fields for m_dwFlagsPersist
		{
		mskfAllowOverrideMachineName = 0x0001
		};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	CString m_strMachineNamePersist;	// Machine name to persist into .msc file
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line
	
	void SetPersistentFlags(DWORD dwFlags)
		{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = !!(m_dwFlagsPersist & mskfAllowOverrideMachineName);
		}

	DWORD GetPersistentFlags()
		{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
		}

// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
                    IDataObject*          piDataObject,
					IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed);
	STDMETHOD(Command)(
					LONG	        lCommandID,
                    IDataObject*    piDataObject );

private:
	CMyComputerCookie*	m_pRootCookie;

}; // CMyComputerComponentData

#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\compdata.cpp ===
// compdata.cpp : Implementation of CMyComputerComponentData

#include "stdafx.h"
#include <lmerr.h>  		// For Lan Manager API error codes and return value types.
#include <lmcons.h> 		// For Lan Manager API constants.
#include <lmapibuf.h>		// For NetApiBufferFree.
#include <lmdfs.h>			// For DFS APIs.
#include <lmserver.h>		// For getting a domain of a server.

#include "macros.h"
USE_HANDLE_MACROS("MMCFMGMT(compdata.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "cookie.h"
#include "snapmgr.h"
#include "stdutils.h" // IsLocalComputername
#include "chooser2.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stdcdata.cpp" // CComponentData implementation
#include "chooser2.cpp" // CHOOSER2_PickTargetComputer implementation

// Helper function to convert message in NETMSG.DLL
int DisplayNetMsgError (
        HWND hWndParent, 
		const CString& computerName, 
        NET_API_STATUS dwErr, 
        CString& displayedMessage);

//
// CMyComputerComponentData
//

CMyComputerComponentData::CMyComputerComponentData()
: m_pRootCookie( NULL )
, m_dwFlagsPersist( 0 )
, m_fAllowOverrideMachineName( FALSE )
, m_bCannotConnect (false)
, m_bMessageView (false)
{
    //
    // We must refcount the root cookie, since a dataobject for it
    // might outlive the IComponentData.  JonN 9/2/97
    //
    m_pRootCookie = new CMyComputerCookie( MYCOMPUT_COMPUTER );
    ASSERT(NULL != m_pRootCookie);
// JonN 10/27/98 All CRefcountedObject's start with refcount==1
//    m_pRootCookie->AddRef();
    SetHtmlHelpFileName (L"compmgmt.chm");
}

CMyComputerComponentData::~CMyComputerComponentData()
{
    m_pRootCookie->Release();
    m_pRootCookie = NULL;
}

DEFINE_FORWARDS_MACHINE_NAME( CMyComputerComponentData, m_pRootCookie )

CCookie& CMyComputerComponentData::QueryBaseRootCookie()
{
	// ISSUE-2002/02/25-JonN handle better -- could return non-NULL bad ptr
    ASSERT(NULL != m_pRootCookie);
	return (CCookie&)*m_pRootCookie;
}


STDMETHODIMP CMyComputerComponentData::CreateComponent(LPCOMPONENT* ppComponent)
{
	MFC_TRY;

	// ISSUE 2002/02/25-JonN should be TEST_NON_NULL_PTR_PARAMS
    ASSERT(ppComponent != NULL);

    CComObject<CMyComputerComponent>* pObject;
    CComObject<CMyComputerComponent>::CreateInstance(&pObject);
	// ISSUE 2002/02/25-JonN handle pObject == NULL
    ASSERT(pObject != NULL);
	pObject->SetComponentDataPtr( (CMyComputerComponentData*)this );

    return pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));

	MFC_CATCH;
}

HRESULT CMyComputerComponentData::LoadIcons(LPIMAGELIST pImageList, BOOL /*fLoadLargeIcons*/)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // 2002/03/22-JonN 572859

	HINSTANCE hInstance = AfxGetInstanceHandle();
	// ISSUE 2002/02/25-JonN handle hInstance == NULL
	ASSERT(hInstance != NULL);

	// Structure to map a Resource ID to an index of icon
	struct RESID2IICON
		{
		UINT uIconId;	// Icon resource ID
		int iIcon;		// Index of the icon in the image list
		};
	const static RESID2IICON rgzLoadIconList[] =
		{
		// Misc icons
		{ IDI_COMPUTER, iIconComputer },
		{ IDI_COMPFAIL, iIconComputerFail },
		{ IDI_SYSTEMTOOLS, iIconSystemTools },
		{ IDI_STORAGE, iIconStorage },
		{ IDI_SERVERAPPS, iIconServerApps },

		{ 0, 0} // Must be last
		};


	for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
		{
	    HICON hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(rgzLoadIconList[i].uIconId));
		ASSERT(NULL != hIcon && "Icon ID not found in resources");
		HRESULT hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon, rgzLoadIconList[i].iIcon);
		ASSERT(SUCCEEDED(hr) && "Unable to add icon to ImageList");
		}

    return S_OK;
}


CString g_strMyComputer;
CString g_strSystemTools;
CString g_strServerApps;
CString g_strStorage;

BOOL g_fScopeStringsLoaded = FALSE;

void LoadGlobalCookieStrings()
{
	if (!g_fScopeStringsLoaded )
	{
		g_fScopeStringsLoaded = TRUE;
		VERIFY( g_strMyComputer.LoadString(IDS_SCOPE_MYCOMPUTER) );
		VERIFY( g_strSystemTools.LoadString(IDS_SCOPE_SYSTEMTOOLS) );
		VERIFY( g_strServerApps.LoadString(IDS_SCOPE_SERVERAPPS) );
		VERIFY( g_strStorage.LoadString(IDS_SCOPE_STORAGE) );
	}
}

// returns TRUE iff the child nodes should be added
// CODEWORK this is probably no longer necessary, we always return true
bool CMyComputerComponentData::ValidateMachine(const CString &sName, bool bDisplayErr)
{
	CWaitCursor			waitCursor;
	int					iRetVal = IDYES;
	SERVER_INFO_101*	psvInfo101 = 0;
	DWORD				dwr = ERROR_SUCCESS;
	DWORD				dwServerType = SV_TYPE_NT;

	m_bMessageView = false;

	// passed-in name is not the same as local machine
	if ( !IsLocalComputername(sName) )
	{
		dwr = ::NetServerGetInfo((LPTSTR)(LPCTSTR)sName,
				101, (LPBYTE*)&psvInfo101);
		if (dwr == ERROR_SUCCESS)
		{
			ASSERT( NULL != psvInfo101 );
			dwServerType = psvInfo101->sv101_type;
			::NetApiBufferFree (psvInfo101);
		}
		if (bDisplayErr && (dwr != ERROR_SUCCESS || !(SV_TYPE_NT & dwServerType)) )
		{
			CString	computerName (sName);

			if ( computerName.IsEmpty () )
			{
				// ISSUE 2002/02/25-JonN handle failure
				DWORD	dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
				VERIFY (::GetComputerName (
						computerName.GetBufferSetLength (dwSize),
						&dwSize));
				computerName.ReleaseBuffer ();
			}
			else
			{
				// Strip off the leading whack-whack
				if ( computerName.Find (L"\\\\") == 0 )
				{
					computerName = computerName.GetBuffer (computerName.GetLength ()) + 2;
					computerName.ReleaseBuffer ();
				}
			}

			CString	text;
			CString	caption;
			bool	bMessageDisplayed = false;

			switch (dwr)
			{
			case ERROR_NETWORK_UNREACHABLE:
				text.FormatMessage (IDS_CANT_CONNECT_TO_MACHINE_NETWORK_UNREACHABLE,
						computerName);
				break;

			case ERROR_NETNAME_DELETED:
				text.FormatMessage (IDS_CANT_CONNECT_TO_MACHINE_NETNAME_DELETED,
						computerName);
				break;

			case ERROR_SUCCESS:
				ASSERT( !(SV_TYPE_NT & dwServerType) );
				text.FormatMessage (IDS_CANT_CONNECT_TO_NON_NT_COMPUTER,
						computerName);
				dwr = ERROR_BAD_NETPATH;
				break;

			case ERROR_ACCESS_DENIED:
				// We will interpret this as success.
				return true;

			case ERROR_BAD_NETPATH:
			default:
				{
					HWND	hWndParent = 0;
					m_pConsole->GetMainWindow (&hWndParent);
					iRetVal = DisplayNetMsgError (hWndParent, computerName, 
							dwr, m_strMessageViewMsg);
					bMessageDisplayed = true;
					m_bMessageView = true;
					return false;
				}
				break;
			}


			if ( !bMessageDisplayed )
			{
				VERIFY (caption.LoadString (IDS_TASKPADTITLE_COMPUTER));
				m_pConsole->MessageBox (text, caption,
						MB_ICONINFORMATION | MB_YESNO, &iRetVal);
			}
		}
	}

	if (IDYES != iRetVal)
	{
		// revert to local computer focus
		QueryRootCookie().SetMachineName (L"");

		// Set the persistent name.  If we are managing the local computer
		// this name should be empty.
		m_strMachineNamePersist = L"";

		VERIFY (SUCCEEDED (ChangeRootNodeName (L"")) );
		iRetVal = IDYES;
		dwr = ERROR_SUCCESS;
	}


	m_bCannotConnect = (ERROR_SUCCESS != dwr);

	// Change root node icon
	SCOPEDATAITEM item;
	::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
	item.mask = SDI_IMAGE | SDI_OPENIMAGE;
	item.nImage = (m_bCannotConnect) ? iIconComputerFail : iIconComputer;
	item.nOpenImage = item.nImage;
	item.ID = QueryBaseRootCookie ().m_hScopeItem;
	VERIFY (SUCCEEDED (m_pConsoleNameSpace->SetItem (&item)));

	return true;
}

HRESULT CMyComputerComponentData::OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent)
{
	// ISSUE 2002/02/25-JonN handle NULL
	ASSERT( NULL != lpDataObject &&
	        NULL != hParent &&
			NULL != m_pConsoleNameSpace );

	if (!bExpanding)
		return S_OK;

	//
	// CODEWORK This code will not work if My Computer becomes an extension,
	// since the RawCookie format will not be available.
	// WARNING cookie cast
	//
	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( lpDataObject,
		                      CMyComputerDataObject::m_CFRawCookie,
							  reinterpret_cast<PBYTE>(&pBaseParentCookie),
							  sizeof(pBaseParentCookie) );
	ASSERT( SUCCEEDED(hr) );
	CMyComputerCookie* pParentCookie = ActiveCookie(pBaseParentCookie);
	// ISSUE 2002/02/25-JonN handle pParentCookie == NULL
	ASSERT( NULL != pParentCookie );

	// save the HSCOPEITEM of the root node
	if ( NULL == pParentCookie->m_hScopeItem )
	{
		pParentCookie->m_hScopeItem = hParent;

		// Ensure root node name is formatted correctly.
		CString	machineName	= pParentCookie->QueryNonNULLMachineName ();

		hr = ChangeRootNodeName (machineName);
	}
	else
	{
		ASSERT( pParentCookie->m_hScopeItem == hParent );
	}

	switch ( pParentCookie->m_objecttype )
	{
		// This node type has a child
		case MYCOMPUT_COMPUTER:
			break;

		// This node type has no children in this snapin but may have dynamic extensions
		case MYCOMPUT_SERVERAPPS:
			return ExpandServerApps( hParent, pParentCookie );

		// These node types have no children
		case MYCOMPUT_SYSTEMTOOLS:
		case MYCOMPUT_STORAGE:
			return S_OK;

		default:
			TRACE( "CMyComputerComponentData::EnumerateScopeChildren bad parent type\n" );
			ASSERT( FALSE );
			return S_OK;
	}

	if ( NULL == hParent ||
		 !((pParentCookie->m_listScopeCookieBlocks).IsEmpty()) )
	{
		ASSERT(FALSE);
		return S_OK;
	}

	LoadGlobalCookieStrings();

	hr = AddScopeNodes (hParent, *pParentCookie);

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
//	AddScopeNodes
//
//	Purpose: Add the nodes that appear immediately below the root node
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMyComputerComponentData::AddScopeNodes (HSCOPEITEM hParent, CMyComputerCookie& rParentCookie)
{
	if ( !(rParentCookie.m_listScopeCookieBlocks.IsEmpty()) )
	{
		return S_OK; // scope cookies already present
	}

	HRESULT	hr = S_OK;
	LPCWSTR lpcszMachineName = rParentCookie.QueryNonNULLMachineName();
	// ISSUE 2002/02/25-JonN handle lpcszMachineName == NULL

	if ( ValidateMachine (lpcszMachineName, true) )
	{
		SCOPEDATAITEM tSDItem;
		::ZeroMemory(&tSDItem,sizeof(tSDItem));
		tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
		tSDItem.displayname = MMC_CALLBACK;
		tSDItem.relativeID = hParent;
		tSDItem.nState = 0;


		// Create new cookies


		CMyComputerCookie* pNewCookie = new CMyComputerCookie(
			MYCOMPUT_SYSTEMTOOLS,
			lpcszMachineName );
		// ISSUE 2002/02/25-JonN handle pNewCookie == NULL
		rParentCookie.m_listScopeCookieBlocks.AddHead(
			(CBaseCookieBlock*)pNewCookie );
		// WARNING cookie cast
		tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
		tSDItem.nImage = QueryImage( *pNewCookie, FALSE );
		tSDItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
		hr = m_pConsoleNameSpace->InsertItem(&tSDItem);
		ASSERT(SUCCEEDED(hr));
		pNewCookie->m_hScopeItem = tSDItem.ID;
		ASSERT( NULL != pNewCookie->m_hScopeItem );

		pNewCookie = new CMyComputerCookie(
			MYCOMPUT_STORAGE,
			lpcszMachineName );
		// ISSUE 2002/02/25-JonN handle pNewCookie == NULL
		rParentCookie.m_listScopeCookieBlocks.AddHead(
			(CBaseCookieBlock*)pNewCookie );
		// WARNING cookie cast
		tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
		tSDItem.nImage = QueryImage( *pNewCookie, FALSE );
		tSDItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
		hr = m_pConsoleNameSpace->InsertItem(&tSDItem);
		ASSERT(SUCCEEDED(hr));
		pNewCookie->m_hScopeItem = tSDItem.ID;
		ASSERT( NULL != pNewCookie->m_hScopeItem );

		pNewCookie = new CMyComputerCookie(
			MYCOMPUT_SERVERAPPS,
			lpcszMachineName );
		// ISSUE 2002/02/25-JonN handle pNewCookie == NULL
		rParentCookie.m_listScopeCookieBlocks.AddHead(
			(CBaseCookieBlock*)pNewCookie );
		// WARNING cookie cast
		tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
		tSDItem.nImage = QueryImage( *pNewCookie, FALSE );
		tSDItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
		hr = m_pConsoleNameSpace->InsertItem(&tSDItem);
		ASSERT(SUCCEEDED(hr));
		pNewCookie->m_hScopeItem = tSDItem.ID;
		ASSERT( NULL != pNewCookie->m_hScopeItem );
	}
	else
		hr = S_FALSE;

	return hr;
}


HRESULT CMyComputerComponentData::OnNotifyDelete(LPDATAOBJECT /*lpDataObject*/)
{
	// CODEWORK The user hit the Delete key, I should deal with this
	return S_OK;
}


HRESULT CMyComputerComponentData::OnNotifyRelease(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM /*hItem*/)
{
	// JonN 01/26/00: COMPMGMT is never an extension
	return S_OK;
}


HRESULT CMyComputerComponentData::OnNotifyPreload(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM hRootScopeItem)
{
	ASSERT (m_fAllowOverrideMachineName);

	QueryBaseRootCookie ().m_hScopeItem = hRootScopeItem;
	CString		machineName = QueryRootCookie ().QueryNonNULLMachineName();

	return ChangeRootNodeName (machineName);
}

// global space to store the string handed back to GetDisplayInfo()
// CODEWORK should use "CComBSTR" for ANSI-ization
CString g_strResultColumnText;

BSTR CMyComputerComponentData::QueryResultColumnText(
	CCookie& basecookieref,
	int nCol )
{
	CMyComputerCookie& cookieref = (CMyComputerCookie&)basecookieref;
#ifndef UNICODE
#error not ANSI-enabled
#endif
	switch ( cookieref.m_objecttype )
	{
		case MYCOMPUT_COMPUTER:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strMyComputer));
			break;
		case MYCOMPUT_SYSTEMTOOLS:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strSystemTools));
			break;
		case MYCOMPUT_SERVERAPPS:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strServerApps));
			break;
		case MYCOMPUT_STORAGE:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strStorage));
			break;

		default:
			TRACE( "CMyComputerComponentData::EnumerateScopeChildren bad parent type\n" );
			ASSERT( FALSE );
			break;
	}

	return L"";
}

int CMyComputerComponentData::QueryImage(CCookie& basecookieref, BOOL /*fOpenImage*/)
{
	CMyComputerCookie& cookieref = (CMyComputerCookie&)basecookieref;
	switch ( cookieref.m_objecttype )
	{
		case MYCOMPUT_COMPUTER:
			if ( m_bCannotConnect )
				return iIconComputerFail;
			else
				return iIconComputer;

		case MYCOMPUT_SYSTEMTOOLS:
			return iIconSystemTools;

		case MYCOMPUT_SERVERAPPS:
			return iIconServerApps;

		case MYCOMPUT_STORAGE:
			return iIconStorage;

		default:
			TRACE( "CMyComputerComponentData::QueryImage bad parent type\n" );
			ASSERT( FALSE );
			break;
	}
	return iIconComputer;
}


///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CMyComputerComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	MFC_TRY;

	if (NULL == pDataObject)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
	HRESULT hr = ExtractData( pDataObject, CMyComputerDataObject::m_CFDataObjectType, (PBYTE)&dataobjecttype, sizeof(dataobjecttype) );
	if ( FAILED(hr) )
		return hr;
	if (CCT_SNAPIN_MANAGER == dataobjecttype)
		return S_OK; // Snapin Manager dialog

	CCookie* pBaseParentCookie = NULL;
	hr = ExtractData( pDataObject,
	                  CMyComputerDataObject::m_CFRawCookie,
	                  reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                  sizeof(pBaseParentCookie) );
	ASSERT( SUCCEEDED(hr) );
	CMyComputerCookie* pParentCookie = ActiveCookie(pBaseParentCookie);
	ASSERT( NULL != pParentCookie );
	if ( MYCOMPUT_COMPUTER == pParentCookie->m_objecttype )
		return S_OK; // allow extensibility

	return S_FALSE;

	MFC_CATCH;
}

STDMETHODIMP CMyComputerComponentData::CreatePropertyPages(
	LPPROPERTYSHEETCALLBACK pCallBack,
	LONG_PTR /*handle*/,		// This handle must be saved in the property page object to notify the parent when modified
	LPDATAOBJECT pDataObject)
{
	MFC_TRY;

	if (NULL == pCallBack || NULL == pDataObject)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
	HRESULT hr = ExtractData( pDataObject, CMyComputerDataObject::m_CFDataObjectType, (PBYTE)&dataobjecttype, sizeof(dataobjecttype) );
	if (CCT_SNAPIN_MANAGER != dataobjecttype)
	{
		CCookie* pBaseParentCookie = NULL;
		hr = ExtractData( pDataObject,
		                  CMyComputerDataObject::m_CFRawCookie,
		                  reinterpret_cast<PBYTE>(&pBaseParentCookie),
		                  sizeof(pBaseParentCookie) );
		ASSERT( SUCCEEDED(hr) );
		CMyComputerCookie* pParentCookie = ActiveCookie(pBaseParentCookie);
		ASSERT( NULL != pParentCookie );
		if ( MYCOMPUT_COMPUTER == pParentCookie->m_objecttype )
			return S_OK; // allow extensibility
		return S_FALSE;
	}

	//
	// Note that once we have established that this is a CCT_SNAPIN_MANAGER cookie,
	// we don't care about its other properties.  A CCT_SNAPIN_MANAGER cookie is
	// equivalent to a BOOL flag asking for the Node Properties page instead of a
	// managed object property page.  JonN 10/9/96
	//

	CMyComputerGeneral * pPage = new CMyComputerGeneral();
	// ISSUE 2002/02/25-JonN handle pPage == NULL
	pPage->SetCaption(IDS_SCOPE_MYCOMPUTER);

	// Initialize state of object
	ASSERT(NULL != m_pRootCookie);
	pPage->InitMachineName(m_pRootCookie->QueryTargetServer());
	pPage->SetOutputBuffers(
		OUT &m_strMachineNamePersist,
		OUT &m_fAllowOverrideMachineName,
		OUT &m_pRootCookie->m_strMachineName);	// Effective machine name

	HPROPSHEETPAGE hPage=CreatePropertySheetPage(&pPage->m_psp);
	hr = pCallBack->AddPage(hPage);
	ASSERT( SUCCEEDED(hr) );

	return S_OK;

	MFC_CATCH;
}

STDMETHODIMP CMyComputerComponentData::AddMenuItems(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
                    long*                 pInsertionAllowed)
{
	MFC_TRY;
	TRACE_METHOD(CMyComputerComponent,AddMenuItems);
	TEST_NONNULL_PTR_PARAM(piDataObject);
	TEST_NONNULL_PTR_PARAM(piCallback);
	TEST_NONNULL_PTR_PARAM(pInsertionAllowed);
	TRACE( "CMyComputerComponentData: extending menu\n" );

	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData (piDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED (hr) )
	{
		ASSERT (FALSE);
		return S_OK;
	}

	CMyComputerCookie* pCookie = ActiveCookie (pBaseParentCookie);
	if ( !pCookie )
	{
		ASSERT (FALSE);
		return S_OK;
	}

	if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
	{
		if ( MYCOMPUT_COMPUTER == pCookie->m_objecttype &&
				QueryBaseRootCookie ().m_hScopeItem)
		{
			hr = ::LoadAndAddMenuItem (piCallback,
					IDM_CHANGE_COMPUTER_TOP, IDM_CHANGE_COMPUTER_TOP,
					CCM_INSERTIONPOINTID_PRIMARY_TOP,
					0,
					AfxGetInstanceHandle (),
					_T("ChangeComputerTop") );
			// ISSUE 2002/02/25-JonN handle FAILED(hr)
		}
	}

	if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
	{
		if ( MYCOMPUT_COMPUTER == pCookie->m_objecttype &&
				QueryBaseRootCookie ().m_hScopeItem)
		{
			hr = ::LoadAndAddMenuItem (piCallback,
					IDM_CHANGE_COMPUTER_TASK, IDM_CHANGE_COMPUTER_TASK,
					CCM_INSERTIONPOINTID_PRIMARY_TASK,
					0,
					AfxGetInstanceHandle (),
					_T("ChangeComputerTask") );
			// ISSUE 2002/02/25-JonN handle FAILED(hr)
		}
	}
	// ISSUE 2002/02/25-JonN don't return failure even if items not added
	return hr;
	
    MFC_CATCH;
} // CMyComputerComponentData::AddMenuItems()

STDMETHODIMP CMyComputerComponentData::Command(
                    LONG            lCommandID,
                    IDataObject*    piDataObject )
{
    MFC_TRY;

    TRACE_METHOD(CMyComputerComponentData,Command);
    TEST_NONNULL_PTR_PARAM(piDataObject);
    TRACE( "CMyComputerComponentData::Command: command %ld selected\n", lCommandID );

	switch (lCommandID)
	{
	case IDM_CHANGE_COMPUTER_TASK:
	case IDM_CHANGE_COMPUTER_TOP:
		{
			ASSERT (QueryBaseRootCookie ().m_hScopeItem);
			return OnChangeComputer (piDataObject);
		}
		break;

	default:
		ASSERT(FALSE);
		break;
	}

    return S_OK;

    MFC_CATCH;

} // CMyComputerComponentData::Command()


///////////////////////////////////////////////////////////////////////////////
//
//	OnChangeComputer ()
//
//  Purpose:	Change the machine managed by the snapin
//
//	Input:		piDataObject - the selected node.  This should be the root node
//								the snapin.
//  Output:		Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////

//      1. Launch object picker and get new computer name
//      2. Change root node text
//      3. Save new computer name to persistent name
//      4. Delete subordinate nodes
//      5. Re-add subordinate nodes
HRESULT CMyComputerComponentData::OnChangeComputer(IDataObject * piDataObject)
{
	MFC_TRY;

#ifdef FIX538345
	// 538345-2002/06/18-JonN Only permit retarget if no property sheet
	// is currently displayed
	{
		CComQIPtr<IPropertySheetProvider,
		          &IID_IPropertySheetProvider> pISP = m_pConsole;
		ASSERT(!!pISP);
		if (pISP)
		{
			HRESULT hr2 = pISP->FindPropertySheet( 0L,   // cookie
			                                       NULL, // IComponent
			                                       piDataObject);
			if (S_OK == hr2)
				return S_OK; // BUGBUG BUGBUG
		}
	}
#endif

	HWND    hWndParent = NULL;
	HRESULT	hr = m_pConsole->GetMainWindow (&hWndParent);
	CComBSTR sbstrTargetComputer;
	//
	// JonN 12/7/99 using CHOOSER2
	//
	if ( CHOOSER2_PickTargetComputer( AfxGetInstanceHandle(),
	                                  hWndParent,
	                                  &sbstrTargetComputer ) )
	{
		CString strTargetComputer = sbstrTargetComputer;
		strTargetComputer.MakeUpper ();

		// added IsLocalComputername 1/27/99 JonN
		// If the user chooses the local computer, treat that as if they had chosen
		// "Local Computer" in Snapin Manager.  This means that there is no way to
		// reset the snapin to target explicitly at this computer without either
		// reloading the snapin from Snapin Manager, or going to a different computer.
		// When the Choose Target Computer UI is revised, we can make this more
		// consistent with Snapin Manager.
		if ( IsLocalComputername( strTargetComputer ) )
			strTargetComputer = L"";

		QueryRootCookie().SetMachineName (strTargetComputer);

		// Set the persistent name.  If we are managing the local computer
		// this name should be empty.
		m_strMachineNamePersist = strTargetComputer;

		hr = ChangeRootNodeName (strTargetComputer);
		if ( SUCCEEDED(hr) )
		{
			// Delete subordinates and re-add
			HSCOPEITEM	hRootScopeItem = QueryBaseRootCookie ().m_hScopeItem;
			MMC_COOKIE	lCookie = 0;
			HSCOPEITEM	hChild = 0;
							
			do {
				hr = m_pConsoleNameSpace->GetChildItem (hRootScopeItem,
						&hChild, &lCookie);
				if ( S_OK != hr )
					break;

				hr = m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
				ASSERT (SUCCEEDED (hr));
				if ( !SUCCEEDED(hr) )
					break;

				CMyComputerCookie* pCookie =
						reinterpret_cast <CMyComputerCookie*> (lCookie);
				if ( !pCookie )
					continue;

				CMyComputerCookie&	rootCookie = QueryRootCookie();
				POSITION			pos1 = 0;
				POSITION			pos2 = 0;
				CBaseCookieBlock*	pScopeCookie = 0;

				for ( pos1 = rootCookie.m_listScopeCookieBlocks.GetHeadPosition ();
					  ( pos2 = pos1) != NULL;
											   )
				{
					pScopeCookie = rootCookie.m_listScopeCookieBlocks.GetNext (pos1);
					ASSERT (pScopeCookie);
					if ( pScopeCookie == pCookie )
					{
						rootCookie.m_listScopeCookieBlocks.RemoveAt (pos2);
						pScopeCookie->Release ();
					}
				}
			} while (S_OK == hr);

			hr = AddScopeNodes (hRootScopeItem, QueryRootCookie ());
			hr = m_pConsole->UpdateAllViews (piDataObject, 0, HINT_SELECT_ROOT_NODE);
		}
	}

	return hr;
	MFC_CATCH;
}

///////////////////////////////////////////////////////////////////////////////
//
//	ChangeRootNodeName ()
//
//  Purpose:	Change the text of the root node
//
//	Input:		newName - the new machine name that the snapin manages
//  Output:		Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMyComputerComponentData::ChangeRootNodeName(const CString & newName)
{
	MFC_TRY;
	ASSERT (QueryBaseRootCookie ().m_hScopeItem);
	if ( !QueryBaseRootCookie ().m_hScopeItem )
		return E_UNEXPECTED;

	CString		machineName (newName);
	CString		formattedName = FormatDisplayName (machineName);


	SCOPEDATAITEM	item;
	::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
	item.mask = SDI_STR;
	item.displayname = (LPTSTR) (LPCTSTR) formattedName;
	item.ID = QueryBaseRootCookie ().m_hScopeItem;

	return m_pConsoleNameSpace->SetItem (&item);
	MFC_CATCH;
}


CString FormatDisplayName(CString machineName)
{
	CString	formattedName;

	// If strDisplayName is empty, then this manages the local machine.  Get
	// the local machine name.  Then format the computer name with the snapin
	// name
	if (machineName.IsEmpty())
	{
		VERIFY (formattedName.LoadString (IDS_SCOPE_MYCOMPUTER_LOCAL_MACHINE));
	}
	else
	{
		// strip off the leading whackWhack
		if ( machineName.Find (L"\\\\") == 0 )
		{
			machineName = machineName.GetBuffer (machineName.GetLength ()) + 2;
			machineName.ReleaseBuffer ();
		}
		machineName.MakeUpper ();
		formattedName.FormatMessage (IDS_SCOPE_MYCOMPUTER_ON_MACHINE, machineName);
	}


	return formattedName;
}


int DisplayNetMsgError (HWND hWndParent, const CString& computerName, NET_API_STATUS dwErr, CString& displayedMessage)
{
	int	retVal = IDNO;

	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	LPVOID	lpMsgBuf = 0;
	HMODULE hNetMsgDLL = ::LoadLibrary (L"netmsg.dll");
	if ( hNetMsgDLL )
	{
		::FormatMessage (
				FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
				hNetMsgDLL,
				dwErr,
				MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf, 0, NULL);
			
		// Display the string.
		CString	text;
		CString	caption;
	
		text.FormatMessage (IDS_CANT_CONNECT_TO_MACHINE, (LPCWSTR) computerName, (LPTSTR) lpMsgBuf);
		VERIFY (caption.LoadString (IDS_TASKPADTITLE_COMPUTER));

		retVal = ::MessageBox (hWndParent, text, caption, MB_ICONWARNING | MB_OK);

		displayedMessage = text;

		// Free the buffer.
		::LocalFree (lpMsgBuf);

		::FreeLibrary (hNetMsgDLL);
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\cookie.cpp ===
// Cookie.cpp : Implementation of CMyComputerCookie and related classes

#include "stdafx.h"
#include "cookie.h"

#include "atlimpl.cpp"

DECLARE_INFOLEVEL(MyComputerSnapin)

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(cookie.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcooki.cpp"
#include <compuuid.h> // defines nodetypes for the My Computer snapin

//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[MYCOMPUT_NUMTYPES] =
{
	{ // MYCOMPUT_COMPUTER
		structuuidNodetypeComputer,
		lstruuidNodetypeComputer    },
	{ // MYCOMPUT_SYSTEMTOOLS
		structuuidNodetypeSystemTools,
		lstruuidNodetypeSystemTools },
	{ // MYCOMPUT_SERVERAPPS
		structuuidNodetypeServerApps,
		lstruuidNodetypeServerApps  },
	{ // MYCOMPUT_STORAGE
		structuuidNodetypeStorage,
		lstruuidNodetypeStorage     }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = MYCOMPUT_NUMTYPES;


//
// CMyComputerCookie
//

// returns <0, 0 or >0
HRESULT CMyComputerCookie::CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult )
{
	// ISSUE-2002/02/27-JonN handle NULL
	ASSERT( NULL != pOtherCookie );

	CMyComputerCookie* pcookie = ((CMyComputerCookie*)pOtherCookie);
	if (m_objecttype != pcookie->m_objecttype)
	{
		*pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype); // arbitrary ordering
		return S_OK;
	}

	return CHasMachineName::CompareMachineNames( *pcookie, pnResult );
}

CCookie* CMyComputerCookie::QueryBaseCookie(int i)
{
    UNREFERENCED_PARAMETER (i);
	ASSERT( i == 0 );
	return (CCookie*)this;
}

int CMyComputerCookie::QueryNumCookies()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\cookie.h ===
// cookie.h : Declaration of CMyComputerCookie and related classes

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CMyComputerComponent::Initialize)

#include "nodetype.h"

/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

#include "stdcooki.h"

class CMyComputerCookie : public CCookie
                        , public CStoresMachineName
                        , public CBaseCookieBlock
{
public:
	CMyComputerCookie( MyComputerObjectType objecttype,
	                   LPCTSTR lpcszMachineName = NULL )
		: CStoresMachineName( lpcszMachineName )
		, m_objecttype( objecttype )
		, m_fRootCookieExpanded( false )
	{
	}

	// returns <0, 0 or >0
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult );

// CBaseCookieBlock
	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();

public:
	MyComputerObjectType m_objecttype;

	// JonN 5/27/99: The System Tools and Storage nodes are automatically expanded
	// the first time the Computer node is shown (see IComponent::Show())
	bool m_fRootCookieExpanded;
};


#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\dataobj.cpp ===
// DataObj.cpp : Implementation of data object classes

#include "stdafx.h"
#include "stdutils.h" // GetObjectType() utility routines

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(dataobj.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "resource.h" // IDS_SCOPE_MYCOMPUTER

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"

#ifdef __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__
//    Additional clipboard formats for the Service context menu extension
CLIPFORMAT g_cfServiceName = (CLIPFORMAT)::RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_NAME");
CLIPFORMAT g_cfServiceDisplayName = (CLIPFORMAT)::RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME");
#endif // __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__

//    Additional clipboard formats for the Send Console Message snapin
//CLIPFORMAT CMyComputerDataObject::m_cfSendConsoleMessageText = (CLIPFORMAT)::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageText"));
CLIPFORMAT CMyComputerDataObject::m_cfSendConsoleMessageRecipients = (CLIPFORMAT)::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageRecipients"));


/////////////////////////////////////////////////////////////////////
//    CMyComputerDataObject::IDataObject::GetDataHere()
HRESULT CMyComputerDataObject::GetDataHere(
    FORMATETC __RPC_FAR *pFormatEtcIn,
    STGMEDIUM __RPC_FAR *pMedium)
{
    MFC_TRY;

    // ISSUE-2002/02/27-JonN test for NULL pointers

    const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
    if (cf == m_CFNodeType)
    {
        const GUID* pguid = GetObjectTypeGUID( m_pcookie->m_objecttype );
        stream_ptr s(pMedium);
        return s.Write(pguid, sizeof(GUID));
    }
    else if (cf == m_CFSnapInCLSID)
    {
        const GUID* pguid = &CLSID_MyComputer;
        stream_ptr s(pMedium);
        return s.Write(pguid, sizeof(GUID));
    }
    else if (cf == m_CFNodeTypeString)
    {
        const BSTR strGUID = GetObjectTypeString( m_pcookie->m_objecttype );
        stream_ptr s(pMedium);
        return s.Write(strGUID);
    }
    else if (cf == m_CFDisplayName)
    {
        return PutDisplayName(pMedium);
    }
    else if (cf == m_CFDataObjectType)
    {
        stream_ptr s(pMedium);
        return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
    }
    else if (cf == m_CFMachineName)
    {
        stream_ptr s(pMedium);
        LPCWSTR pszMachineName = m_pcookie->QueryNonNULLMachineName();
        if (IsBadStringPtr(pszMachineName,(UINT_PTR)-1)) // JonN 2/6/02 Security Push
        {
          ASSERT(FALSE);
          return E_FAIL;
        }

        if ( !wcsncmp (pszMachineName, L"\\\\", 2) )
            pszMachineName += 2;    // skip whackwhack
        return s.Write(pszMachineName);
    }
    else if (cf == m_CFRawCookie)
    {
        stream_ptr s(pMedium);
        // CODEWORK This cast ensures that the data format is
        // always a CCookie*, even for derived subclasses
        CCookie* pcookie = (CCookie*)m_pcookie;
        return s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pcookie));
    }
    else if (cf == m_CFSnapinPreloads)
    {
        stream_ptr s(pMedium);
        // If this is TRUE, then the next time this snapin is loaded, it will
        // be preloaded to give us the opportunity to change the root node
        // name before the user sees it.
        return s.Write (reinterpret_cast<PBYTE>(&m_fAllowOverrideMachineName), sizeof (BOOL));
    }

    return DV_E_FORMATETC;

    MFC_CATCH;
} // CMyComputerDataObject::GetDataHere()


/////////////////////////////////////////////////////////////////////
//    CMyComputerDataObject::IDataObject::GetData()
//
//    Write data into the storage medium.
//    The data will be retrieved by the Send Console Message snapin.
//
//    HISTORY
//    12-Aug-97    t-danm        Creation.
//
HRESULT
CMyComputerDataObject::GetData(
    FORMATETC __RPC_FAR * pFormatEtcIn,
    STGMEDIUM __RPC_FAR * pMedium)
{
    // ISSUE-2002-02-27-JonN Should use MFC_TRY/MFC_CATCH

    // JonN 2/20/02 Security Push
    if (NULL == pFormatEtcIn || NULL == pMedium)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    const CLIPFORMAT cf = pFormatEtcIn->cfFormat;
    if (cf == m_cfSendConsoleMessageRecipients)
    {
        //
        // Write the list of recipients to the storage medium.
        // - The list of recipients is a group of UNICODE strings
        //     terminated by TWO null characters.c
        // - Allocated memory must include BOTH null characters.
        //
        ASSERT (m_pcookie);
        if ( m_pcookie )
        {
            CString    computerName = m_pcookie->QueryNonNULLMachineName ();
            if ( computerName.IsEmpty () )
            {
                DWORD    dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
                VERIFY (::GetComputerName (
                        computerName.GetBufferSetLength (dwSize),
                        &dwSize));
                computerName.ReleaseBuffer ();
            }
            size_t cch = computerName.GetLength () + 2;
            HGLOBAL hGlobal = ::GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
                                             cch * sizeof (WCHAR));
            if ( hGlobal )
            {
                // JonN 2/6/02 Security Push: memcpy -> StringCchCopy
                // this should leave two NULLS
                StringCchCopyW ((LPWSTR)hGlobal, cch, (LPCWSTR)computerName);
                pMedium->hGlobal = hGlobal;
                return S_OK;
            }
            else
                return E_OUTOFMEMORY;
        }
        else
            return E_UNEXPECTED;
    } else if (cf == m_CFNodeID2)
    {
        const LPCTSTR strGUID = GetObjectTypeString( m_pcookie->m_objecttype );

        // JonN 12/11/01 502856
        int cbString = (lstrlen(strGUID) + 1) * sizeof(TCHAR);

        pMedium->tymed = TYMED_HGLOBAL; 
        pMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                                         sizeof(SNodeID2) + cbString);
        if (!(pMedium->hGlobal))
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            SNodeID2 *pNodeID = (SNodeID2 *)GlobalLock(pMedium->hGlobal);
            if (!pNodeID)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                GlobalFree(pMedium->hGlobal);
                pMedium->hGlobal = NULL;
            } else
            {
                pNodeID->dwFlags = 0;
                pNodeID->cBytes = cbString;
                // JonN 2/6/02 Security Push: function usage approved
                CopyMemory(pNodeID->id, strGUID, cbString );
                GlobalUnlock(pMedium->hGlobal);
            }
        }
    } else
    {
        hr = DV_E_FORMATETC;
    }

    return hr;
} // CMyComputerDataObject::GetData()

//#endif // __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__


HRESULT CMyComputerDataObject::Initialize(
    CMyComputerCookie* pcookie,
    DATA_OBJECT_TYPES type,
    BOOL fAllowOverrideMachineName)
{
    // ISSUE-2002-/02/27-JonN check "type" parameter
    if (NULL == pcookie || NULL != m_pcookie)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    m_dataobjecttype = type;
    m_pcookie = pcookie;
    m_fAllowOverrideMachineName = fAllowOverrideMachineName;
    ((CRefcountedObject*)m_pcookie)->AddRef();
    return S_OK;
}


CMyComputerDataObject::~CMyComputerDataObject()
{
    if (NULL != m_pcookie)
    {
        ((CRefcountedObject*)m_pcookie)->Release();
    }
    else
    {
        ASSERT(FALSE);
    }
}


HRESULT CMyComputerDataObject::PutDisplayName(STGMEDIUM* pMedium)
    // Writes the "friendly name" to the provided storage medium
    // Returns the result of the write operation
{
    // JonN 2/20/02 Security Push
    if (NULL == pMedium)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    CString strDisplayName = m_pcookie->QueryTargetServer();
    CString formattedName = FormatDisplayName (strDisplayName);


    stream_ptr s(pMedium);
    return s.Write(formattedName);
}

// Register the clipboard formats
CLIPFORMAT CMyComputerDataObject::m_CFDisplayName =
    (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CMyComputerDataObject::m_CFNodeID2 =
    (CLIPFORMAT)RegisterClipboardFormat(CCF_NODEID2);
CLIPFORMAT CMyComputerDataObject::m_CFMachineName =
    (CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
    (CLIPFORMAT)RegisterClipboardFormat(L"MYCOMPUT_SNAPIN_RAW_COOKIE");


STDMETHODIMP CMyComputerComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    MFC_TRY;

    // ISSUE-2002/02/27-JonN This would be more efficient if an instance of
    // CMyComputerDataObject were permanently attached to CMyComputerCookie,
    // or better yet, if they were the same object.  QueryDataObject gets
    // called a lot...

    CMyComputerCookie* pUseThisCookie = (CMyComputerCookie*)ActiveBaseCookie(reinterpret_cast<CCookie*>(cookie));
    // JonN 2/20/02 Security Push
    if (NULL == pUseThisCookie)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    CComObject<CMyComputerDataObject>* pDataObject = NULL;
    HRESULT hRes = CComObject<CMyComputerDataObject>::CreateInstance(&pDataObject);
    if ( FAILED(hRes) )
        return hRes;

    HRESULT hr = pDataObject->Initialize( pUseThisCookie, type, m_fAllowOverrideMachineName);
    if ( SUCCEEDED(hr) )
    {
        hr = pDataObject->QueryInterface(IID_IDataObject,
                                         reinterpret_cast<void**>(ppDataObject));
    }
    if ( FAILED(hr) )
    {
        delete pDataObject;
        return hr;
    }

    return hr;

    MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\dataobj.h ===
// DataObj.h : Declaration of the data object classes

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__

#include "cookie.h" // CMyComputerCookie
#include "stddtobj.h" // class DataObject

class CMyComputerDataObject : public CDataObject
{
	DECLARE_NOT_AGGREGATABLE(CMyComputerDataObject)

public:

// debug refcount
#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

	CMyComputerDataObject()
		: m_pcookie( NULL )
		, m_objecttype( MYCOMPUT_COMPUTER )
		, m_dataobjecttype( CCT_UNINITIALIZED )
	{
	}

	~CMyComputerDataObject();

	virtual HRESULT Initialize( CMyComputerCookie* pcookie, DATA_OBJECT_TYPES type, BOOL fAllowOverrideMachineName );

	// IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);
	
	//#define __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__
    HRESULT STDMETHODCALLTYPE GetData(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

    HRESULT PutDisplayName(STGMEDIUM* pMedium);
	HRESULT PutServiceName(STGMEDIUM* pMedium);

protected:
	CMyComputerCookie* m_pcookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
	MyComputerObjectType m_objecttype;
	DATA_OBJECT_TYPES m_dataobjecttype;
	BOOL m_fAllowOverrideMachineName;	// From CMyComputerComponentData

public:
	// Clipboard formats
	static CLIPFORMAT m_CFDisplayName;
	static CLIPFORMAT m_CFNodeID2;
	static CLIPFORMAT m_CFMachineName;
//	static CLIPFORMAT m_cfSendConsoleMessageText;
	static CLIPFORMAT m_cfSendConsoleMessageRecipients;

}; // CMyComputerDataObject

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(MyComputerSnapin)
    #define DBG_COMP    MyComputerSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\dynexten.cpp ===
/////////////////////////////////////////////////////////////////////
// DynExten.cpp : enumerates installed services on (possibly remote) computer
//
// HISTORY
// 30-Oct-97	JonN		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("MMCFMGMT(dynexten.cpp)")

#include "compdata.h"
#include "cookie.h"
#include "regkey.h" // AMC::CRegKey

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR SERVICES_KEY[] = TEXT("System\\CurrentControlSet\\Control\\Server Applications");
const TCHAR CLSID_KEY[] = TEXT("Clsid\\");


HRESULT DynextenCheckInstall( const GUID& guidExtension, const TCHAR* pszExtension )
{
    HRESULT hr = S_OK;
#ifdef USE_CLASS_STORE
    IClassAccess* pIClassAccess = NULL;
#endif
    try
    {
        CString strRegPath = CLSID_KEY; // JonN 2/19/02 Security Push
        strRegPath += pszExtension;
        AMC::CRegKey regkeyInstalled;
        BOOL fFound = regkeyInstalled.OpenKeyEx( HKEY_CLASSES_ROOT, strRegPath, KEY_READ );
        if ( fFound )
        {
            return S_OK; // it is already installed
        }

// CODEWORK It would be more efficient to access the Class Store directly
// by calling CoGetClassAccess, then IClassAccess->GetAppInfo(), then CoInstall().
#ifdef USE_CLASS_STORE
        // now we have to get the Class Store to install it
        do { // false loop
            hr = CoGetClassAccess( &pIClassAccess );
            if ( FAILED(hr) )
                break;

            // now what???

        } while (FALSE); // false loop
#else
		IUnknown* pIUnknown = NULL;
		hr = ::CoCreateInstance( guidExtension,
		                         NULL,
		                         CLSCTX_INPROC,
		                         IID_IComponentData,
		                         (PVOID*)&pIUnknown );
		if (NULL != pIUnknown)
			pIUnknown->Release();
		// allow hr to fall through
#endif
    }
    catch (COleException* e)
    {
        // 2002/02/27-JonN I confirmed that this error path is called when
        // AMC::RegKey throws an exception
        e->Delete();
        return E_FAIL;
    }

#ifdef USE_CLASS_STORE
	if (NULL != pIClassAccess)
		pIClassAccess->Release();
#endif

    return hr;
}


//
// CMyComputerComponentData
//

static CLSID CLSID_DnsSnapin =
{ 0x80105023, 0x50B1, 0x11d1, { 0xB9, 0x30, 0x00, 0xA0, 0xC9, 0xA0, 0x6D, 0x2D } };

static CLSID CLSID_FileServiceManagementExt =	{0x58221C69,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};

HRESULT CMyComputerComponentData::ExpandServerApps(
	HSCOPEITEM hParent,
	CMyComputerCookie* pcookie )

{
	// ISSUE-2002/02/27-JonN check parameters

	try
	{
		AMC::CRegKey regkeyServices;
		BOOL fFound = TRUE;
		if (NULL == pcookie->QueryTargetServer())
		{
			fFound = regkeyServices.OpenKeyEx( HKEY_LOCAL_MACHINE, SERVICES_KEY, KEY_READ );
		}
		else
		{
			AMC::CRegKey regkeyRemoteComputer;
			regkeyRemoteComputer.ConnectRegistry(
			  const_cast<LPTSTR>(pcookie->QueryTargetServer()) );
			fFound = regkeyServices.OpenKeyEx( regkeyRemoteComputer, SERVICES_KEY, KEY_READ );
		}
		if ( !fFound )
		{
			return S_OK; // CODEWORK what return code?
		}
		CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> pIConsoleNameSpace2
			= m_pConsole;
		if ( !pIConsoleNameSpace2 )
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		TCHAR achValue[ MAX_PATH ];
		DWORD iSubkey;
		// 2002/02/15-JonN Security Push: handle ERROR_MORE_DATA better
		// MYCOMPUT appears to be the only user of EnumValue at this time
		for ( iSubkey = 0;
		      true;
		      iSubkey++ )
		{
			ZeroMemory( achValue, sizeof(achValue) );
			DWORD cchValue = sizeof(achValue)/sizeof(TCHAR);
			HRESULT hr = regkeyServices.EnumValue(
				iSubkey,
				achValue,
				&cchValue );
			if (S_OK != hr)
			{
				if (ERROR_MORE_DATA == hr)
					continue;
				ASSERT(ERROR_NO_MORE_ITEMS == hr);
				break;
			}

			GUID guidExtension;
			hr = ::CLSIDFromString( achValue, &guidExtension );
			if ( !SUCCEEDED(hr) )
				continue;
			hr = DynextenCheckInstall( guidExtension, achValue );
			if ( !SUCCEEDED(hr) )
				continue;
			hr = pIConsoleNameSpace2->AddExtension( hParent, &guidExtension );
			// ignore the return value
		}
	}
    catch (COleException* e)
    {
        e->Delete();
		return S_OK; // CODEWORK what return code?
    }
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\nodetype.h ===
// nodetype.h : Declaration of MyComputerObjectType

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _MyComputerObjectType {
	MYCOMPUT_COMPUTER = 0,
	MYCOMPUT_SYSTEMTOOLS,
	MYCOMPUT_SERVERAPPS,
	MYCOMPUT_STORAGE,
	MYCOMPUT_NUMTYPES // must be last
} MyComputerObjectType, *PMyComputerObjectType;
inline BOOL IsValidObjectType( MyComputerObjectType objecttype )
	{ return (objecttype >= MYCOMPUT_COMPUTER && objecttype < MYCOMPUT_NUMTYPES); }

#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\persist.cpp ===
// Persist.cpp : Implementation of persistence
//
// HISTORY
// 01-Jan-1996	???			Creation
// 03-Jun-1997	t-danm		Added a version number to storage and
//							Command Line override.
// 2002/02/27-JonN 558642 Security Push: check bytes read
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "compdata.h"
#include "safetemp.h"
#include "stdutils.h" // IsLocalComputername

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(persist.cpp)")

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCTSTR PchGetMachineNameOverride();	// Defined in chooser.cpp

/////////////////////////////////////////////////
//	The _dwMagicword is the internal version number.
//	Increment this number if you make a file format change.
#define _dwMagicword	10001


// IComponentData persistence (remember persistent flags and target computername

/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponentData::Load(IStream __RPC_FAR *pIStream)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT_DATA
	// JonN 2/20/02 Security Push
	if (NULL == pIStream)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword = 0;
	// 2002/02/27-JonN 558642 Security Push: check bytes read
	DWORD cbRead = 0;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), &cbRead );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	else if (cbRead != sizeof(dwMagicword))
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		TRACE0("INFO: CMyComputerComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read flags from stream
	DWORD dwFlags = 0;
	cbRead = 0;
	hr = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), &cbRead );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	else if (cbRead != sizeof(dwFlags))
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	SetPersistentFlags(dwFlags);

	// read server name from stream
	DWORD dwLen = 0;
	cbRead = 0;
	hr = pIStream->Read( &dwLen, sizeof(dwLen), &cbRead );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	else if (cbRead != sizeof(dwLen))
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	// JonN 2/20/02 Security Push
	if (sizeof(WCHAR) > dwLen || MAX_PATH*sizeof(WCHAR) < dwLen)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	LPWSTR lpwszMachineName = (LPWSTR)alloca( dwLen );
	// allocated from stack, we don't need to free
	if (NULL == lpwszMachineName)
	{
		AfxThrowMemoryException();
		return E_OUTOFMEMORY;
	}
	ZeroMemory( lpwszMachineName, dwLen );
	cbRead = 0;
	hr = pIStream->Read( (PVOID)lpwszMachineName, dwLen, &cbRead );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	else if (cbRead != dwLen)
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	// JonN 2/20/02 Security Push: force NULL-termination
	lpwszMachineName[(dwLen/sizeof(WCHAR))-1] = L'\0';

	m_strMachineNamePersist = lpwszMachineName;
	LPCTSTR pszMachineNameT = PchGetMachineNameOverride();
	if (m_fAllowOverrideMachineName && pszMachineNameT != NULL)
	{
		// Allow machine name override
	}
	else
	{
		pszMachineNameT = lpwszMachineName;
	}

	// JonN 1/27/99: If the persisted name is the local computername,
	// leave the persisted name alone but make the effective name (Local).
	if ( IsLocalComputername(pszMachineNameT) )
		pszMachineNameT = L"";

	QueryRootCookie().SetMachineName(pszMachineNameT);
#endif

	return S_OK;

	MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT_DATA
	// JonN 2/20/02 Security Push
	if (NULL == pIStream)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	DWORD dwFlags = GetPersistentFlags();
	hr = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	LPCWSTR lpwcszMachineName = m_strMachineNamePersist;
	DWORD dwLen = (DWORD) (::wcslen(lpwcszMachineName)+1)*sizeof(WCHAR);
	ASSERT( 4 == sizeof(DWORD) );
	hr = pIStream->Write( &dwLen, sizeof (DWORD), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = pIStream->Write( lpwcszMachineName, dwLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
#endif

	return S_OK;

	MFC_CATCH;
}


// IComponent persistence

/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponent::Load(IStream __RPC_FAR *pIStream)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword = 0;
	// 2002/02/27-JonN Security Push: check bytes read
	DWORD cbRead = 0;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), &cbRead );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	else if (cbRead != sizeof(dwMagicword))
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		TRACE0("INFO: CMyComputerComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read flags from stream
	DWORD dwFlags = 0;
	cbRead = 0;
	hr = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), &cbRead );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	else if (cbRead != sizeof(dwFlags))
	{
		ASSERT( FALSE );
		return E_FAIL;
	}
	SetPersistentFlags(dwFlags);
#endif

	return S_OK;

	MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponent::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	DWORD dwFlags = GetPersistentFlags();
	hr = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
#endif

	return S_OK;

	MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\snapmgr.h ===
// SnapMgr.h : header file for Snapin Manager property page
//

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#include "chooser.h"

typedef CChooseMachinePropPage CMyComputerGeneral;

#endif // ~__SNAPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\mycomput.cpp ===
// MyComput.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "MyComput.h"
#include "regkey.h" // AMC::CRegKey
#include "strings.h" // SNAPINS_KEY
#include "guidhelp.h" // GuidToCString
#include "macros.h" // MFC_TRY/MFC_CATCH
#include "stdutils.h" // g_aNodetypeGuids
#include "MyComput_i.c"
#include "about.h"		// CComputerMgmtAbout

#include "compdata.h" // CMyComputerComponentData
#include "snapreg.h" // RegisterSnapin

USE_HANDLE_MACROS("MYCOMPUT(MyComput.cpp)")                                        \

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MyComputer, CMyComputerComponentData)
	OBJECT_ENTRY(CLSID_ComputerManagementAbout, CComputerMgmtAbout)
END_OBJECT_MAP()

class CMyComputApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CMyComputApp theApp;

BOOL CMyComputApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CMyComputApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	MFC_TRY;

	HRESULT hr = S_OK;
	// registers object, typelib and all interfaces in typelib
	hr = _Module.RegisterServer(TRUE);

	CString strMyComputerCLSID, strMyComputerAboutCLSID;
	if (   FAILED(hr = GuidToCString( &strMyComputerCLSID, CLSID_MyComputer ))
	    || FAILED(hr = GuidToCString( &strMyComputerAboutCLSID, CLSID_ComputerManagementAbout ))
	   )
	{
		ASSERT(FALSE && "GuidToCString() failure");
		return SELFREG_E_CLASS;
	}

	try
	{
		AMC::CRegKey regkeySnapins;
		BOOL fFound = regkeySnapins.OpenKeyEx( HKEY_LOCAL_MACHINE, SNAPINS_KEY );
		if ( !fFound )
		{
			ASSERT(FALSE && "DllRegisterServer() - Unable to open key from registry.");
			return SELFREG_E_CLASS;
		}

		static int mycomput_types[4] = 
			{ MYCOMPUT_COMPUTER,
			  MYCOMPUT_SYSTEMTOOLS,
			  MYCOMPUT_SERVERAPPS,
			  MYCOMPUT_STORAGE };
		hr = RegisterSnapin( regkeySnapins,
		                     strMyComputerCLSID,
		                     g_aNodetypeGuids[MYCOMPUT_COMPUTER].bstr,
		                     IDS_REGISTER_MYCOMPUT,
		                     IDS_SNAPINABOUT_PROVIDER,
		                     IDS_SNAPINABOUT_VERSION,
		                     true,
		                     strMyComputerAboutCLSID,
		                     mycomput_types,
		                     4 );
		if ( FAILED(hr) )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}

		AMC::CRegKey regkeyNodeTypes;
		fFound = regkeyNodeTypes.OpenKeyEx( HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );
		if ( !fFound )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		AMC::CRegKey regkeyNodeType;
		for (int i = MYCOMPUT_COMPUTER; i < MYCOMPUT_NUMTYPES; i++)
		{
			regkeyNodeType.CreateKeyEx( regkeyNodeTypes, g_aNodetypeGuids[i].bstr );
			regkeyNodeType.CloseKey();
		}
	}
    catch (COleException* e)
    {
		ASSERT(FALSE);
        e->Delete();
		return SELFREG_E_CLASS;
    }

	return hr;

	MFC_CATCH;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	// ISSUE-2002/02/27-JonN Should probably remove MMC entries as well

	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mycomput.rc
//
#define IDS_PROJNAME                    100
#define IDS_MYCOMPUT_DESC               101
#define IDS_TITLE_ERROR                 103
#define IDS_TITLE_WARNING               104
#define IDS_COLUMN_NAME                 105
#define IDS_COLUMN_TYPE                 109
#define IDS_COLUMN_DESCRIPTION          110
#define IDS_ERROR_INVALID_COMPUTERNAME  111
#define IDS_SNAPINABOUT_DESCRIPTION     182
#define IDS_SCOPE_SYSTEMTOOLS           190
#define IDS_SCOPE_SERVERAPPS            191
#define IDS_SCOPE_STORAGE               192
#define IDS_SCOPE_MYCOMPUTER            193
#define IDS_SCOPE_MYCOMPUTER_ON_MACHINE 194
#define IDS_TASKPADTITLE_COMPUTER       203
#define IDI_SYSTEMTOOLS                 201
#define IDI_SERVERAPPS                  203
#define IDI_COMPUTER                    204
#define IDI_COMPFAIL                    205
#define IDB_COMPUTER_LARGE              218
#define IDB_COMPUTER_SMALL              219
#define IDI_STORAGE                     222
#define IDM_CHANGE_COMPUTER_TOP         251
#define IDS_SCOPE_MYCOMPUTER_LOCAL_MACHINE 252
#define IDS_CANT_CONNECT_TO_MACHINE     253
#define IDS_CANT_CONNECT_TO_MACHINE_NETWORK_UNREACHABLE 254
#define IDS_CANT_CONNECT_TO_MACHINE_NETNAME_DELETED 255
#define IDM_CHANGE_COMPUTER_TASK        256
#define IDS_CANT_CONNECT_TO_NON_NT_COMPUTER 257
#define IDS_REGISTER_MYCOMPUT           300
#define IDS_SHELL_MANAGE_VERB           400
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        223
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\snapmgr.cpp ===
// SnapMgr.cpp : implementation file for Snapin Manager property page
//

#include "stdafx.h"

#include "chooser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\mycomput\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage

// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "dbg.h"
#include "mmc.h"
#include "mycomput.h"

EXTERN_C const CLSID CLSID_MyComputer;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define STRSAFE_NO_DEPRECATE // corecopy uses comdef.h which uses wsprintf
#include <strsafe.h> // JonN 2/6/02 Security Push

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\adminmanageraz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       AdminManagerAz.cpp
//
//  Contents:   Implements CAdminManagerAz. CAdminManagerAz is thin wrapper
//					 for IAzAuthorizationStore interface.
//
//  History:    09-08-2001 Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\adddlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   
//
//  History:    08-28-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

/******************************************************************************
Class:	CBaseAddDialog
Purpose: This is the base class for all Add Dialog classes.
******************************************************************************/
class CBaseAddDialog: public CHelpEnabledDialog
{
public:
	CBaseAddDialog(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
				  CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected,
				  ULONG IDD_DIALOG,
				  INT nIDListCtrl,
				  COL_FOR_LV *pColForLv,
				  UINT uiListCtrlFlags)
				  :CHelpEnabledDialog(IDD_DIALOG),
				  m_listCtrl(uiListCtrlFlags,FALSE,pColForLv,TRUE),
				  m_listAzObjectsToDisplay(listAzObjectsToDisplay),
				  m_listAzObjectsSelected(listAzObjectsSelected),
				  m_nIDListCtrl(nIDListCtrl),
				  m_uiListCtrlFlags(uiListCtrlFlags)
	{
	}

	~CBaseAddDialog()
	{
	}
	
protected:
	virtual BOOL 
	OnInitDialog();
	
	virtual void 
	OnOkCancel(BOOL bCancel);
	
	virtual void 
	OnCancel();
	
	virtual void 
	OnOK();
private:

//DATA MEMBERS
	CSortListCtrl m_listCtrl;
	
	//List of objects to display. This is provided by 
	//caller of dialog box.
	CList<CBaseAz*,CBaseAz*>& m_listAzObjectsToDisplay;

	//List of objects selected by uses. This is return to
	//user.
	CList<CBaseAz*,CBaseAz*>& m_listAzObjectsSelected;

	//Control Id for ListBox Control
	INT m_nIDListCtrl;

	UINT m_uiListCtrlFlags;
};


/******************************************************************************
Class:	CAddOperationDlg
Purpose: Add Operation Dlg box
******************************************************************************/
class CAddOperationDlg :public CBaseAddDialog
{
public:
	CAddOperationDlg(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
						  CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected);

	~CAddOperationDlg();

	enum {IDD = IDD_ADD_OPERATION};
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CAddTaskDlg
Purpose: Add Task Dlg box
******************************************************************************/
class CAddTaskDlg :public CBaseAddDialog
{
public:
	CAddTaskDlg(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
					CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected,
					ULONG IDD_DIALOG);

	~CAddTaskDlg();
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CAddGroupDlg
Purpose: Add Group Dlg box
******************************************************************************/
class CAddGroupDlg :public CBaseAddDialog
{
public:
	CAddGroupDlg(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
					 CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected);

	~CAddGroupDlg();

	enum {IDD = IDD_ADD_GROUP};
private:
	DECLARE_MESSAGE_MAP()
};

//+----------------------------------------------------------------------------
//  Function:GetSelectedAzObjects   
//  Synopsis:Display the add dlg box for eObjecType and return the objects 
//				 selected by user   
//  Arguments:hwnd
//				  eObjectType: Shows Add Dlg for this objecttype
//				  pContainerAz:ContainerAz object from whose child objects are
//				  shown
//				  listObjectsSelected: Gets list of selected object types
//  Returns:    
//-----------------------------------------------------------------------------
BOOL GetSelectedAzObjects(IN HWND hWnd,
						  IN OBJECT_TYPE_AZ eObjectType,
						  IN CContainerAz* pContainerAz,
						  OUT CList<CBaseAz*,CBaseAz*>& listObjectsSelected);

//+----------------------------------------------------------------------------
//  Function:GetSelectedTasks   
//  Synopsis:Display the add dlg box for Tasks/RoleDefintions
//				 and return the objects selected by user   
//  Arguments:hwnd
//				  bTaskIsRoleDefintion if True Display AddTask else Add Role Def.
//				  pContainerAz:ContainerAz object from whose child objects are
//				  shown
//				  listObjectsSelected: Gets list of selected object types
//  Returns:    
//-----------------------------------------------------------------------------
BOOL GetSelectedTasks(IN HWND hWnd,
					  IN BOOL bTaskIsRoleDefintion,
					  IN CContainerAz* pContainerAz,
					  OUT CList<CBaseAz*,CBaseAz*>& listObjectsSelected);


/******************************************************************************
Class:	CAddDefinition
Purpose:Property Page for Add Definition Tab. Allows to add Role, Task or 
		Operation
******************************************************************************/
class CAddDefinition :public CPropertyPage
{
public:
	CAddDefinition(CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected,
				   ULONG IDD_DIALOG,
				   IN CContainerAz* pContainerAz,
				   IN OBJECT_TYPE_AZ eObjectType,
				   IN BOOL bTaskIsRoleDefintion)
				   :CPropertyPage(IDD_DIALOG),
				   m_listCtrl(COL_NAME |COL_PARENT_TYPE|COL_DESCRIPTION,FALSE,Col_For_Add_Object,TRUE),
				   m_listAzObjectsSelected(listAzObjectsSelected),
				   m_pContainerAz(pContainerAz),
				   m_eObjectType(eObjectType),
				   m_bTaskIsRoleDefintion(bTaskIsRoleDefintion),
				   m_iSortDirection(1),
				   m_iLastColumnClick(0)
	{
	}

	virtual BOOL 
	OnInitDialog();
		
	virtual void 
	OnCancel();
	
	virtual void 
	OnOK();
	
private:
	void 
	OnOkCancel(BOOL bCancel);

	DECLARE_MESSAGE_MAP()
//DATA MEMBERS

	CSortListCtrl m_listCtrl;
	
	//List of objects selected by uses. This is return to
	//user.
	CList<CBaseAz*,CBaseAz*>& m_listAzObjectsSelected;
	
	//
	//Cotainer which contians objects to be selected
	//
	CContainerAz* m_pContainerAz;
	
	//
	//Type of the object to be selected
	//
	OBJECT_TYPE_AZ m_eObjectType;

	//
	//used if m_eObjectType == TASK_AZ. m_bTaskIsRoleDefintion is
	//true, display only Role Definitions
	//
	BOOL m_bTaskIsRoleDefintion;				   
	int m_iSortDirection;
	int m_iLastColumnClick;
};

//+----------------------------------------------------------------------------
//  Function:GetSelectedDefinitions
//  Synopsis:Display the dlg boxes for Tasks/RoleDefintions/Operations
//			 and return the objects selected by user   
//  Arguments:hwnd
//			  bRoleDefintion if True Display Add Role dialog also.
//				  pContainerAz:ContainerAz object from whose child objects are
//				  shown
//				  listObjectsSelected: Gets list of selected object types
//  Returns:    
//-----------------------------------------------------------------------------
BOOL GetSelectedDefinitions(IN BOOL bAllowRoleDefinition,
							IN CContainerAz* pContainerAz,
							OUT CList<CBaseAz*,CBaseAz*>& listObjectsSelected);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\adddlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       AddDlg.cpp
//
//  Contents: Add Dialogs are presented when user clicks add button. For
//	 Add Task, Add Group etc. This file has implementation of add dlgs.
//
//----------------------------------------------------------------------------
#include "headers.h"

/******************************************************************************
Class:	CBaseAddDialog
Purpose: This is the base class for all Add Dialog classes.
******************************************************************************/

BOOL
CBaseAddDialog::
OnInitDialog()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CBaseAddDialog,OnInitDialog)

	VERIFY(m_listCtrl.SubclassDlgItem(m_nIDListCtrl,this));
	m_listCtrl.Initialize();


	//Add AzObjects from list to ListControl
	POSITION pos = m_listAzObjectsToDisplay.GetHeadPosition();
	for (int i=0;i < m_listAzObjectsToDisplay.GetCount();i++)
	{
		CBaseAz* pBaseAz = m_listAzObjectsToDisplay.GetNext(pos);
		//Add Item to ListControl
		VERIFY( AddBaseAzToListCtrl(&m_listCtrl,
									m_listCtrl.GetItemCount(),
									pBaseAz,
									m_uiListCtrlFlags) != -1);



	}

	//Sort the listctrl entries
	m_listCtrl.Sort();
	return TRUE;
}


void
CBaseAddDialog
::OnOK()
{
	OnOkCancel(FALSE);
}

void
CBaseAddDialog::
OnCancel()
{
	OnOkCancel(TRUE);
}

void
CBaseAddDialog::
OnOkCancel(BOOL bCancel)
{
	//Get ListCotrol

	int iRowCount = m_listCtrl.GetItemCount();

	for( int iRow = 0; iRow < iRowCount; iRow++)
	{
		CBaseAz* pBaseAz = (CBaseAz*)(m_listCtrl.GetItemData(iRow));
		ASSERT(pBaseAz);

		//user Pressed Cancel, delete all items
		if(bCancel)
			delete pBaseAz;
		else
		{
			//if checkbox for an item is checked, add it to the list
			//else delete it
			if(m_listCtrl.GetCheck(iRow))
				m_listAzObjectsSelected.AddTail(pBaseAz);
			else
				delete pBaseAz;
		}
	}

	if(bCancel)
		CDialog::OnCancel();
	else
		CDialog::OnOK();
}


/******************************************************************************
Class:	CAddOperationDlg
Purpose: Add Operation Dlg box
******************************************************************************/
BEGIN_MESSAGE_MAP(CAddOperationDlg, CBaseAddDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CAddOperationDlg
::CAddOperationDlg(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
						 CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected)
						:CBaseAddDialog(listAzObjectsToDisplay,
											 listAzObjectsSelected,
											 CAddOperationDlg::IDD,
											 IDC_LIST,
											 Col_For_Add_Object,
											 COL_NAME |COL_PARENT_TYPE|COL_DESCRIPTION)
{
}


CAddOperationDlg
::~CAddOperationDlg()
{
}

/******************************************************************************
Class:	CAddTaskDlg
Purpose: Add Task Dlg box
******************************************************************************/
BEGIN_MESSAGE_MAP(CAddTaskDlg, CBaseAddDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CAddTaskDlg::
CAddTaskDlg(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
				CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected,
				ULONG IDD_DIALOG)
				:CBaseAddDialog(listAzObjectsToDisplay,
									 listAzObjectsSelected,
									 IDD_DIALOG,
									 IDC_LIST,
									 Col_For_Add_Object,
									 COL_NAME |COL_PARENT_TYPE|COL_DESCRIPTION)
{
}

CAddTaskDlg
::~CAddTaskDlg()
{
}

/******************************************************************************
Class:	CAddGroupDlg
Purpose: Add Group Dlg box
******************************************************************************/
BEGIN_MESSAGE_MAP(CAddGroupDlg, CBaseAddDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CAddGroupDlg
::CAddGroupDlg(CList<CBaseAz*,CBaseAz*>& listAzObjectsToDisplay,
					CList<CBaseAz*,CBaseAz*>& listAzObjectsSelected)
					:CBaseAddDialog(listAzObjectsToDisplay,
										 listAzObjectsSelected,
										 CAddGroupDlg::IDD,
									    IDC_LIST,
									    Col_For_Add_Object,
									    COL_NAME |COL_PARENT_TYPE|COL_DESCRIPTION)
{
}

CAddGroupDlg
::~CAddGroupDlg()
{
}


//+----------------------------------------------------------------------------
//  Function:GetSelectedAzObjects   
//  Synopsis:Display the add dlg box for eObjecType and return the objects 
//				 selected by user   
//  Arguments:hwnd
//				  eObjectType: Shows Add Dlg for this objecttype
//				  pContainerAz:ContainerAz object from whose child objects are
//				  shown
//				  listObjectsSelected: Gets list of selected object types
//  Returns:    
//-----------------------------------------------------------------------------
BOOL GetSelectedAzObjects(IN HWND hWnd,
						  IN OBJECT_TYPE_AZ eObjectType,
						  IN CContainerAz* pContainerAz,
						  OUT CList<CBaseAz*,CBaseAz*>& listObjectsSelected)
{
	TRACE_FUNCTION_EX(DEB_SNAPIN,GetSelectedAzObjects)

	if(!pContainerAz)
	{
		ASSERT(pContainerAz);
		return FALSE;
	}

	
	//Get All the object of type eObjectType at pRoleTaskContainerAz
	CList<CBaseAz*,CBaseAz*> listChildObjectsToDisplay;
	HRESULT hr = GetAllAzChildObjects(pContainerAz,
									  eObjectType,
									  listChildObjectsToDisplay);

	if(FAILED(hr))
	{
		CString strError;
		GetSystemError(strError, hr);	

		//Display Generic Error Message
		DisplayError(hWnd,
						 IDS_ERROR_OPERATION_FAILED, 
						 (LPWSTR)(LPCWSTR)strError);

		return FALSE;
	}
	
	//if there are no objects to add, show the error message and quit
	if(!listChildObjectsToDisplay.GetCount())
	{
		switch(eObjectType)
		{
		case OPERATION_AZ:
			DisplayInformation(hWnd,IDS_NO_OPERATIONS_TO_ADD);
			break;
		case GROUP_AZ:
			DisplayInformation(hWnd,IDS_NO_GROUP_TO_ADD);
			break;
		default:
			ASSERT(FALSE);
			break;
		}
		return TRUE;
	}

	//Display Appropriate Dialog box 
	if(eObjectType == OPERATION_AZ)
	{
		CAddOperationDlg dlgAddOperation(listChildObjectsToDisplay,
													listObjectsSelected);		
		dlgAddOperation.DoModal();
	}
	else if(eObjectType == GROUP_AZ)
	{
		CAddGroupDlg dlgAddGroup(listChildObjectsToDisplay,
										 listObjectsSelected);		
		dlgAddGroup.DoModal();
	}
	return TRUE;
}



//+----------------------------------------------------------------------------
//  Function:GetSelectedTasks   
//  Synopsis:Display the add dlg box for Tasks/RoleDefintions
//				 and return the objects selected by user   
//  Arguments:hwnd
//				  bTaskIsRoleDefintion if True Display AddTask else Add Role Def.
//				  pContainerAz:ContainerAz object from whose child objects are
//				  shown
//				  listObjectsSelected: Gets list of selected object types
//  Returns:    
//-----------------------------------------------------------------------------
BOOL GetSelectedTasks(IN HWND hWnd,
					  IN BOOL bTaskIsRoleDefintion,
					  IN CContainerAz* pContainerAz,
					  OUT CList<CBaseAz*,CBaseAz*>& listObjectsSelected)
{
	if(!pContainerAz)
	{
		ASSERT(pContainerAz);
		return FALSE;
	}
	
	//Get All the object of type eObjectType at pRoleTaskContainerAz
	CList<CBaseAz*,CBaseAz*> listListOfAllTasks;
	HRESULT hr = GetAllAzChildObjects(pContainerAz,
												 TASK_AZ,
												 listListOfAllTasks);

	if(FAILED(hr))
	{
		CString strError;
		GetSystemError(strError, hr);	

		//Display Generic Error Message
		DisplayError(hWnd,
						 IDS_ERROR_OPERATION_FAILED, 
						 (LPWSTR)(LPCWSTR)strError);

		return FALSE;
	}

	CList<CBaseAz*,CBaseAz*> listChildObjectsToDisplay;
	POSITION pos = listListOfAllTasks.GetHeadPosition();
	for( int i = 0; i < listListOfAllTasks.GetCount(); ++i)
	{
		CTaskAz* pTaskAz = dynamic_cast<CTaskAz*>(listListOfAllTasks.GetNext(pos));
		ASSERT(pTaskAz);
		if((bTaskIsRoleDefintion && pTaskAz->IsRoleDefinition())
			||(!bTaskIsRoleDefintion) &&  !pTaskAz->IsRoleDefinition())
			listChildObjectsToDisplay.AddTail(pTaskAz);
		else
			delete pTaskAz;
	}
	
	//if there are no objects to add, show the error message and quit
	if(!listChildObjectsToDisplay.GetCount())
	{
		if(bTaskIsRoleDefintion)
			DisplayInformation(hWnd,IDS_NO_ROLE_DEFINITION_TO_ADD);		
		else
			DisplayInformation(hWnd,IDS_NO_TASKS_TO_ADD);
		return TRUE ;
	}

	CAddTaskDlg dlgAddTask(listChildObjectsToDisplay,
								  listObjectsSelected,
								  bTaskIsRoleDefintion? IDD_ADD_ROLE_DEFINITION_1 :IDD_ADD_TASK);		
	//Get List of Tasks to be Added
	dlgAddTask.DoModal();
	return TRUE;
}

/******************************************************************************
Class:	CAddDefinition
Purpose:Property Page for Add Definition Tab. Allows to add Role, Task or 
		Operation
******************************************************************************/
BEGIN_MESSAGE_MAP(CAddDefinition, CPropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAddDefinition::
OnInitDialog()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CAddDefinition,OnInitDialog)

	VERIFY(m_listCtrl.SubclassDlgItem(IDC_LIST,this));
	m_listCtrl.Initialize();

	//
	//Get List of Objects to Display
	//
	CList<CBaseAz*,CBaseAz*> listAzObjectsToDisplay;

	HRESULT hr = S_OK;
	if(m_eObjectType == TASK_AZ)
	{
		CList<CBaseAz*,CBaseAz*> listTasks;
		hr = GetAllAzChildObjects(m_pContainerAz,
								  TASK_AZ,
								  listTasks);
		if(SUCCEEDED(hr))
		{		
			POSITION pos = listTasks.GetHeadPosition();
			for( int i = 0; i < listTasks.GetCount(); ++i)
			{
				CTaskAz* pTaskAz = dynamic_cast<CTaskAz*>(listTasks.GetNext(pos));
				ASSERT(pTaskAz);
				if((m_bTaskIsRoleDefintion && pTaskAz->IsRoleDefinition())
					||(!m_bTaskIsRoleDefintion &&  !pTaskAz->IsRoleDefinition()))
				{
					listAzObjectsToDisplay.AddTail(pTaskAz);
				}
				else
					delete pTaskAz;
			}
		}
	}
	else
	{
		hr = GetAllAzChildObjects(m_pContainerAz,
								  m_eObjectType,
								  listAzObjectsToDisplay);
	}
	
	if(FAILED(hr))
	{
		CString strError;
		GetSystemError(strError, hr);	

		//Display Generic Error Message
		DisplayError(m_hWnd,
					 IDS_ERROR_OPERATION_FAILED, 
					 (LPWSTR)(LPCWSTR)strError);

		return FALSE;
	}

	
	//if there are no objects to add, show the error message and quit
	if(!listAzObjectsToDisplay.GetCount())
	{
		if(m_eObjectType == TASK_AZ)
		{
			if(m_bTaskIsRoleDefintion)
				DisplayInformation(m_hWnd,IDS_NO_ROLE_DEFINITION_TO_ADD);		
			else
				DisplayInformation(m_hWnd,IDS_NO_TASKS_TO_ADD);
		}
		else
		{
			DisplayInformation(m_hWnd,IDS_NO_OPERATIONS_TO_ADD);
		}
		return TRUE ;
	}


	//Add AzObjects from list to ListControl
	POSITION pos = listAzObjectsToDisplay.GetHeadPosition();
	for (int i=0;i < listAzObjectsToDisplay.GetCount();i++)
	{
		CBaseAz* pBaseAz = listAzObjectsToDisplay.GetNext(pos);
		//Add Item to ListControl
		VERIFY( AddBaseAzToListCtrl(&m_listCtrl,
									m_listCtrl.GetItemCount(),
									pBaseAz,
									COL_NAME |COL_PARENT_TYPE|COL_DESCRIPTION) != -1);



	}

	m_listCtrl.Sort();

	return TRUE;
}

void
CAddDefinition
::OnOK()
{
	OnOkCancel(FALSE);
}

void
CAddDefinition::
OnCancel()
{
	OnOkCancel(TRUE);
}

void
CAddDefinition::
OnOkCancel(BOOL bCancel)
{
	int iRowCount = m_listCtrl.GetItemCount();

	for( int iRow = 0; iRow < iRowCount; iRow++)
	{
		CBaseAz* pBaseAz = (CBaseAz*)m_listCtrl.GetItemData(iRow);
		ASSERT(pBaseAz);

		//user Pressed Cancel, delete all items
		if(bCancel)
			delete pBaseAz;
		else
		{
			//if checkbox for an item is checked, add it to the list
			//else delete it
			if(m_listCtrl.GetCheck(iRow))
				m_listAzObjectsSelected.AddTail(pBaseAz);
			else
				delete pBaseAz;
		}
	}

	if(bCancel)
		CDialog::OnCancel();
	else
		CDialog::OnOK();
}



//+----------------------------------------------------------------------------
//  Function:GetSelectedDefinitions
//  Synopsis:Display the dlg boxes for Tasks/RoleDefintions/Operations
//			 and return the objects selected by user   
//  Arguments:hwnd
//			  bRoleDefintion if True Display Add Role dialog also.
//				  pContainerAz:ContainerAz object from whose child objects are
//				  shown
//				  listObjectsSelected: Gets list of selected object types
//  Returns:    
//-----------------------------------------------------------------------------
BOOL GetSelectedDefinitions(IN BOOL bAllowRoleDefinition,
							IN CContainerAz* pContainerAz,
							OUT CList<CBaseAz*,CBaseAz*>& listObjectsSelected)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if(!pContainerAz)
	{
		ASSERT(pContainerAz);
		return FALSE;
	}


	CPropertySheet sheet(IDS_ADD_DEFINITION);

	CAddDefinition *ppageRole = NULL;
	//Add Role Definition Page
	if(bAllowRoleDefinition)
	{
		ppageRole= new CAddDefinition(listObjectsSelected,
									  IDD_ADD_ROLE_DEFINITION,
									  pContainerAz,
									  TASK_AZ,
									  TRUE);
		if(!ppageRole)
		{
			return FALSE;
		}
		sheet.AddPage(ppageRole);
	}

	//Add Task Page
	CAddDefinition pageTask(listObjectsSelected,
							IDD_ADD_TASK,
							pContainerAz,
							TASK_AZ,
							FALSE);
	sheet.AddPage(&pageTask);


	CContainerAz * pOperationContainer 
		= (pContainerAz->GetObjectType() == SCOPE_AZ) ? pContainerAz->GetParentAz():pContainerAz;

	//Add Operation Page
	CAddDefinition pageOperation(listObjectsSelected,
								 IDD_ADD_OPERATION,
								 pOperationContainer,
								 OPERATION_AZ,
								 FALSE);
	sheet.AddPage(&pageOperation);

    //Remove the apply button
    sheet.m_psh.dwFlags |= PSH_NOAPPLYNOW;

	//Display the sheet
	sheet.DoModal();	

	if(ppageRole)
		delete ppageRole;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);
   ~CDbg();

    void __cdecl Trace(PWSTR pszfmt, ...);
    void __cdecl Trace(LPSTR pszfmt, ...);
    void __cdecl DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void __cdecl DebugOut(unsigned long fDebugMask, PWSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, PWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);
    void IncIndent();
    void DecIndent();

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

    static ULONG s_idxTls;

private:

    ULONG
    _GetIndent();

    unsigned long   m_flInfoLevel; // must be the first data member
    unsigned long   m_flOutputOptions;
    LPTSTR          m_InfoLevelString;
};  // class CDbg

class CIndenter
{
public:

    CIndenter(CDbg *pdbg): m_pDbg(pdbg) { m_pDbg->IncIndent(); }
    ~CIndenter() { m_pDbg->DecIndent(); m_pDbg = NULL; }

private:

    CDbg *m_pDbg;
};

#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined

#define DEB_FUNCTION        0x00800000
#define DEB_RESOURCE        0x01000000
#define DEB_METHOD          0x02000000
#define DEB_USER8           0x04000000
#define DEB_USER9				 0x08000000
#define DEB_USER10			 0x10000000      // text processing
#define DEB_ELAPSEDTIME     0x20000000      // output elapsed time
#define DEB_NOCOMPNAME      0x40000000      // suppress component name

#define DEB_FORCE           0x1fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\adminmanageraz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       AdminMangagerAz.h
//
//  Contents:   Declares CAdminManagerAz. CAdminManagerAz is thin wrapper
//					 for IAzAuthorizationStore interface.

//
//  History:    09-08-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\adinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   
//
//  History:    01-30-2002  Hiteshr  Created
//
//----------------------------------------------------------------------------

/******************************************************************************
Class:	CADInfo
Purpose:Keeps a cache of Active Directory info avoiding multiple binds
******************************************************************************/
class CADInfo
{
public:
    HRESULT
    GetRootDSE();

    const CString&  
    GetDomainDnsName();

    const CString&
    GetDomainDn();
    
    const CString&
    GetRootDomainDnsName();

	const CString&
	GetRootDomainDn();

	const CString&
	GetRootDomainDCName();

    const CString&
    GetDomainDCName();
private:
    CString m_strDomainDnsName;
    CString m_strDomainDn;
    CString m_strRootDomainDnsName;
	CString m_strRootDomainDn;
	CString m_strRootDomainDcName;
    CString m_strDomainDcName;
    CComPtr<IADs> m_spRootDSE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\applicationaz.cpp ===
#include "headers.h"

CApplicationAz::
CApplicationAz(CComPtr<IAzApplication> spAzInterface)
					 :CGroupContainerAz<IAzApplication>(spAzInterface)
{

}


CApplicationAz::~CApplicationAz(){}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\applicationaz.h ===
class CApplicationAz : public CGroupContainerAz<IAzApplication>
{
public:
	CApplicationAz(CComPtr<IAzApplication> spAzInterface);
	virtual ~CApplicationAz();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\azimpl.cpp ===
#include "headers.h"

/*****************************************************************************



*****************************************************************************/
template<class IAzInterface>
CBaseAzImpl<IAzInterface>
::CBaseAzImpl(CComPtr<IAzInterface>& spAzInterface,
                  OBJECT_TYPE_AZ eObjectType,
                  CContainerAz* pParentContainerAz)
                  :CBaseAz(eObjectType,pParentContainerAz),
                  m_spAzInterface(spAzInterface)
{
}

template<class IAzInterface>
CBaseAzImpl<IAzInterface>::~CBaseAzImpl()
{
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::SetProperty(LONG lPropId, const CString& strPropValue)
{
    CComBSTR bstr = strPropValue;
    CComVariant var = bstr;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            var, 
                                                            CComVariant()); 
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::GetProperty(LONG lPropId, CString* pstrPropValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BSTR);
        *pstrPropValue = varName.bstrVal;
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::SetProperty(LONG lPropId, BOOL bValue)
{
    CComVariant varValue = bValue;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            varValue, 
                                                            CComVariant()); 
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::GetProperty(LONG lPropId, BOOL* pbValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BOOL);
        *pbValue = (varName.boolVal == VARIANT_TRUE);
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::SetProperty(LONG lPropId, LONG lValue)
{
    CComVariant varName = lValue;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                              varName, 
                                              CComVariant());   
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::GetProperty(LONG lPropId, LONG* plValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                              CComVariant(), 
                                              &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_I4);
        *plValue = varName.lVal;
    }
    CHECK_HRESULT(hr);
    return hr;  
}


template<class IAzInterface>
const CString&
CBaseAzImpl<IAzInterface>::GetName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAzImpl,GetName)

    if(!m_strName.IsEmpty())
        return m_strName;

    CComVariant varName;
    GetProperty(AZ_PROP_NAME, &m_strName);
    return m_strName;
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::SetName(const CString& strName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAzImpl,SetName)

    ASSERT(!strName.IsEmpty());
    
    HRESULT hr = SetProperty(AZ_PROP_NAME,strName);
    
    if(SUCCEEDED(hr))
        m_strName = strName;
    
    return hr;
}

template<class IAzInterface>
const CString&
CBaseAzImpl<IAzInterface>::GetDescription()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAzImpl,GetDescription)
    CComVariant varDesc;
    
    if(!m_strDescription.IsEmpty())
        return m_strDescription;

    HRESULT hr = m_spAzInterface->GetProperty(AZ_PROP_DESCRIPTION, 
                                                            CComVariant(), 
                                                            &varDesc);
    
    if(SUCCEEDED(hr))
    {
        ASSERT(varDesc.vt == VT_BSTR);
        m_strDescription = varDesc.bstrVal;
        return m_strDescription;
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        return m_strDescription;
    }   
}

template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::SetDescription(const CString& strDesc)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAzImpl,SetDescription)

    ASSERT(!strDesc.IsEmpty());
    CComBSTR bstrDesc = strDesc;
    CComVariant varDesc = bstrDesc;

    VARIANTARG dest;
    VariantInit(&dest);
    HRESULT hr1 = VariantChangeType(&dest,&varDesc,0,VT_BSTR);
    HRESULT hr = m_spAzInterface->SetProperty(AZ_PROP_DESCRIPTION, 
                                                            varDesc, 
                                                            CComVariant());

    if(SUCCEEDED(hr))
        m_strDescription = varDesc.bstrVal;

    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::Submit()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAzImpl,Submit)

    HRESULT hr = m_spAzInterface->Submit(0, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CBaseAzImpl<IAzInterface>::Clear()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAzImpl,Submit)

    HRESULT hr = m_spAzInterface->Submit(AZ_SUBMIT_FLAG_ABORT, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


/*****************************************************************************



*****************************************************************************/
template<class IAzInterface>
CContainerAzImpl<IAzInterface>
::CContainerAzImpl(CComPtr<IAzInterface>& spAzInterface,
                  OBJECT_TYPE_AZ eObjectType,
                  CContainerAz* pParentContainerAz)
                  :CContainerAz(eObjectType,pParentContainerAz),
                  m_spAzInterface(spAzInterface)
{
}

template<class IAzInterface>
CContainerAzImpl<IAzInterface>::~CContainerAzImpl()
{
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::SetProperty(LONG lPropId, const CString& strPropValue)
{
    CComBSTR bstr = strPropValue;
    CComVariant var = bstr;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                              var, 
                                              CComVariant());   
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::GetProperty(LONG lPropId, CString* pstrPropValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BSTR);
        *pstrPropValue = varName.bstrVal;
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::SetProperty(LONG lPropId, BOOL bValue)
{
    CComVariant varValue = bValue;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            varValue, 
                                                            CComVariant()); 
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::GetProperty(LONG lPropId, BOOL* pbValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BOOL);
        *pbValue = (varName.boolVal == VARIANT_TRUE);
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::SetProperty(LONG lPropId, LONG lValue)
{
    CComVariant varName = lValue;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            varName, 
                                                            CComVariant()); 
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::GetProperty(LONG lPropId, LONG* plValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                              CComVariant(), 
                                              &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_I4);
        *plValue = varName.lVal;
    }
    CHECK_HRESULT(hr);
    return hr;  
}



template<class IAzInterface>
const CString&
CContainerAzImpl<IAzInterface>::GetName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,GetName)

    if(!m_strName.IsEmpty())
        return m_strName;

    CComVariant varName;
    GetProperty(AZ_PROP_NAME, &m_strName);
    return m_strName;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::SetName(const CString& strName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,SetName)

    ASSERT(!strName.IsEmpty());
    
    HRESULT hr = SetProperty(AZ_PROP_NAME,strName);
    
    if(SUCCEEDED(hr))
        m_strName = strName;
    
    return hr;
}

template<class IAzInterface>
const CString&
CContainerAzImpl<IAzInterface>::GetDescription()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,GetDescription)
    CComVariant varDesc;
    
    if(!m_strDescription.IsEmpty())
        return m_strDescription;

    HRESULT hr = m_spAzInterface->GetProperty(AZ_PROP_DESCRIPTION, 
                                                            CComVariant(), 
                                                            &varDesc);
    
    if(SUCCEEDED(hr))
    {
        ASSERT(varDesc.vt == VT_BSTR);
        m_strDescription = varDesc.bstrVal;
        return m_strDescription;
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        return m_strDescription;
    }   
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::SetDescription(const CString& strDesc)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,SetDescription)

    ASSERT(!strDesc.IsEmpty());
    CComBSTR bstrDesc = strDesc;
    CComVariant varDesc = bstrDesc;

    VARIANTARG dest;
    VariantInit(&dest);
    HRESULT hr1 = VariantChangeType(&dest,&varDesc,0,VT_BSTR);
    HRESULT hr = m_spAzInterface->SetProperty(AZ_PROP_DESCRIPTION, 
                                                            varDesc, 
                                                            CComVariant());

    if(SUCCEEDED(hr))
        m_strDescription = varDesc.bstrVal;

    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::Submit()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,Submit)

    HRESULT hr = m_spAzInterface->Submit(0, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::Clear()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,Submit)

    HRESULT hr = m_spAzInterface->Submit(AZ_SUBMIT_FLAG_ABORT, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT
CContainerAzImpl<IAzInterface>::
CreateGroup(const CString& strGroupName, CGroupAz** ppGroupAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,CreateGroup)

    if(strGroupName.IsEmpty() || !ppGroupAz)
    {
        ASSERT(!strGroupName.IsEmpty());
        ASSERT(ppGroupAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strGroupName;
    HRESULT hr = S_OK;
    CComPtr<IAzApplicationGroup> spGroup;
    hr = m_spAzInterface->CreateApplicationGroup(bstrName,
                                                                CComVariant(),  //Reserved
                                                                &spGroup);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *ppGroupAz = new CGroupAz(spGroup,this);

    if(!*ppGroupAz)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    return S_OK;
}


template<class IAzInterface>
HRESULT
CContainerAzImpl<IAzInterface>::
OpenGroup(const CString& strGroupName, CGroupAz** ppGroupAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,OpenGroup);
    if(strGroupName.IsEmpty() || !ppGroupAz)
    {
        ASSERT(!strGroupName.IsEmpty());
        ASSERT(ppGroupAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strGroupName;
    HRESULT hr = S_OK;
    CComPtr<IAzApplicationGroup> spGroup;
    hr = m_spAzInterface->OpenApplicationGroup(bstrName,
                                                             CComVariant(), //Reserved
                                                             &spGroup);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppGroupAz = new CGroupAz(spGroup,this);

    if(!*ppGroupAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT
CContainerAzImpl<IAzInterface>::
DeleteGroup(const CString& strGroupName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,DeleteGroup)
    if(strGroupName.IsEmpty())
    {
        ASSERT(!strGroupName.IsEmpty());
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strGroupName;
    HRESULT hr = S_OK;
    CComPtr<IAzApplicationGroup> spGroup;
    hr = m_spAzInterface->DeleteApplicationGroup(bstrName,
                                                               CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}

    
template<class IAzInterface>
HRESULT
CContainerAzImpl<IAzInterface>::
GetGroupCollection(GROUP_COLLECTION** ppGroupCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,GetGroupCollection);
    if(!ppGroupCollection)
    {
        ASSERT(ppGroupCollection);
        return E_INVALIDARG;
    }
    
    CComPtr<IAzApplicationGroups> spAzGroups;

    HRESULT hr = m_spAzInterface->get_ApplicationGroups(&spAzGroups);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppGroupCollection = new GROUP_COLLECTION(spAzGroups,
                                                          this);
    if(!*ppGroupCollection)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::
GetPolicyUsers(IN LONG lPropId,
               OUT CList<CBaseAz*,CBaseAz*>& pListAdmins)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,GetPolicyUsers)
    
    HRESULT hr = S_OK;
    CList<PSID,PSID> listSids;
    do
    {
        CComVariant varUserList;
        hr = m_spAzInterface->GetProperty(lPropId,
                                          CComVariant(),
                                          &varUserList);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = SafeArrayToSidList(varUserList,
                                listSids);
        BREAK_ON_FAIL_HRESULT(hr);

        CSidHandler * pSidHandler = GetSidHandler();
        if(!pSidHandler)
        {
            ASSERT(pSidHandler);
            return E_UNEXPECTED;
        }

        hr = pSidHandler->LookupSids(this,listSids,pListAdmins);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    RemoveItemsFromList(listSids,TRUE);
    return hr;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::
AddPolicyUser(LONG lPropId,
              IN CBaseAz* pBaseAz)

{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,AddPolicyUser)
    
    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    CString strSid;
    if(GetStringSidFromSidCachecAz(pBaseAz,&strSid))
    {
        CComVariant varSid = strSid;
        m_spAzInterface->AddPropertyItem(lPropId, 
                                         varSid,
                                        CComVariant());
    }
    else
    {
        hr = E_FAIL;
    }
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CContainerAzImpl<IAzInterface>::
RemovePolicyUser(IN LONG lPropId,
                 IN CBaseAz* pBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,RemovePolicyUser)
    
    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }
    
    HRESULT hr = S_OK;
    CString strSid;
    if(GetStringSidFromSidCachecAz(pBaseAz,&strSid))
    {
        CComVariant var = strSid;
        hr = m_spAzInterface->DeletePropertyItem(lPropId,
                                                 var,
                                                 CComVariant()); 
    }
    else
    {
        hr = E_FAIL;
    }
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
BOOL 
CContainerAzImpl<IAzInterface>::
IsSecurable()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAzImpl,IsSecurable);
    HRESULT hr = S_OK;
    CComVariant varUserList;
    hr = m_spAzInterface->get_PolicyAdministrators(&varUserList);
    CHECK_HRESULT(hr);
    if(SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

/*****************************************************************************
Class: CRoleTaskContainerAzImpl


*****************************************************************************/
template<class IAzInterface>
CRoleTaskContainerAzImpl<IAzInterface>
::CRoleTaskContainerAzImpl(CComPtr<IAzInterface>& spAzInterface,
                                   OBJECT_TYPE_AZ eObjectType,
                                    CContainerAz* pParentContainerAz)
                                    :CRoleTaskContainerAz(eObjectType,pParentContainerAz),
                                    m_spAzInterface(spAzInterface)
{
}

template<class IAzInterface>
CRoleTaskContainerAzImpl<IAzInterface>::~CRoleTaskContainerAzImpl()
{
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::SetProperty(LONG lPropId, const CString& strPropValue)
{
    CComBSTR bstr = strPropValue;
    CComVariant var = bstr;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            var, 
                                                            CComVariant()); 

    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::GetProperty(LONG lPropId, CString* pstrPropValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BSTR);
        *pstrPropValue = varName.bstrVal;
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::SetProperty(LONG lPropId, BOOL bValue)
{
    CComVariant varValue = bValue;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            varValue, 
                                                            CComVariant()); 
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::GetProperty(LONG lPropId, BOOL* pbValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BOOL);
        *pbValue = (varName.boolVal == VARIANT_TRUE);
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::SetProperty(LONG lPropId, LONG lValue)
{
    CComVariant varName = lValue;
    
    HRESULT hr = m_spAzInterface->SetProperty(lPropId, 
                                                            varName, 
                                                            CComVariant()); 
    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::GetProperty(LONG lPropId, LONG* plValue)
{
    CComVariant varName;
    HRESULT hr = m_spAzInterface->GetProperty(lPropId, 
                                                            CComVariant(), 
                                                            &varName);
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_I4);
        *plValue = varName.lVal;
    }
    CHECK_HRESULT(hr);
    return hr;  
}

template<class IAzInterface>
const CString&
CRoleTaskContainerAzImpl<IAzInterface>::GetName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,GetName)

    if(!m_strName.IsEmpty())
        return m_strName;

    CComVariant varName;
    GetProperty(AZ_PROP_NAME, &m_strName);
    return m_strName;
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::SetName(const CString& strName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,SetName)

    ASSERT(!strName.IsEmpty());
    
    HRESULT hr = SetProperty(AZ_PROP_NAME,strName);
    
    if(SUCCEEDED(hr))
        m_strName = strName;
    
    return hr;
}

template<class IAzInterface>
const CString&
CRoleTaskContainerAzImpl<IAzInterface>::GetDescription()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,GetDescription)
    CComVariant varDesc;
    
    if(!m_strDescription.IsEmpty())
        return m_strDescription;

    HRESULT hr = m_spAzInterface->GetProperty(AZ_PROP_DESCRIPTION, 
                                                            CComVariant(), 
                                                            &varDesc);
    
    if(SUCCEEDED(hr))
    {
        ASSERT(varDesc.vt == VT_BSTR);
        m_strDescription = varDesc.bstrVal;
        return m_strDescription;
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        return m_strDescription;
    }   
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::SetDescription(const CString& strDesc)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,SetDescription)

    ASSERT(!strDesc.IsEmpty());
    CComBSTR bstrDesc = strDesc;
    CComVariant varDesc = bstrDesc;

    VARIANTARG dest;
    VariantInit(&dest);
    HRESULT hr1 = VariantChangeType(&dest,&varDesc,0,VT_BSTR);
    HRESULT hr = m_spAzInterface->SetProperty(AZ_PROP_DESCRIPTION, 
                                                            varDesc, 
                                                            CComVariant());

    if(SUCCEEDED(hr))
        m_strDescription = varDesc.bstrVal;

    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::Submit()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,Submit)

    HRESULT hr = m_spAzInterface->Submit(0, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::Clear()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,Submit)

    HRESULT hr = m_spAzInterface->Submit(AZ_SUBMIT_FLAG_ABORT, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>::
CreateGroup(const CString& strGroupName, CGroupAz** ppGroupAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,CreateGroup)

    if(strGroupName.IsEmpty() || !ppGroupAz)
    {
        ASSERT(!strGroupName.IsEmpty());
        ASSERT(ppGroupAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strGroupName;
    HRESULT hr = S_OK;
    CComPtr<IAzApplicationGroup> spGroup;
    hr = m_spAzInterface->CreateApplicationGroup(bstrName,
                                                                CComVariant(),  //Reserved
                                                                &spGroup);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *ppGroupAz = new CGroupAz(spGroup,this);

    if(!*ppGroupAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}


template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>::
OpenGroup(const CString& strGroupName, CGroupAz** ppGroupAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,OpenGroup);
    if(strGroupName.IsEmpty() || !ppGroupAz)
    {
        ASSERT(!strGroupName.IsEmpty());
        ASSERT(ppGroupAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strGroupName;
    HRESULT hr = S_OK;
    CComPtr<IAzApplicationGroup> spGroup;
    hr = m_spAzInterface->OpenApplicationGroup(bstrName,
                                                             CComVariant(), //Reserved
                                                             &spGroup);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppGroupAz = new CGroupAz(spGroup,this);

    if(!*ppGroupAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>::
DeleteGroup(const CString& strGroupName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,DeleteGroup)
    if(strGroupName.IsEmpty())
    {
        ASSERT(!strGroupName.IsEmpty());
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strGroupName;
    HRESULT hr = S_OK;
    CComPtr<IAzApplicationGroup> spGroup;
    hr = m_spAzInterface->DeleteApplicationGroup(bstrName,
                                                               CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}

    
template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>::
GetGroupCollection(GROUP_COLLECTION** ppGroupCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,GetGroupCollection);
    if(!ppGroupCollection)
    {
        ASSERT(ppGroupCollection);
        return E_INVALIDARG;
    }
    
    CComPtr<IAzApplicationGroups> spAzGroups;

    HRESULT hr = m_spAzInterface->get_ApplicationGroups(&spAzGroups);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppGroupCollection = new GROUP_COLLECTION(spAzGroups,
                                                          this);
    if(!*ppGroupCollection)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::
GetPolicyUsers(IN LONG lPropId,
               OUT CList<CBaseAz*,CBaseAz*>& pListAdmins)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,GetPolicyUsers)
    
    HRESULT hr = S_OK;
    CList<PSID,PSID> listSids;
    do
    {
        CComVariant varUserList;
        hr = m_spAzInterface->GetProperty(lPropId,
                                          CComVariant(),
                                          &varUserList);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = SafeArrayToSidList(varUserList,
                                listSids);
        BREAK_ON_FAIL_HRESULT(hr);

        CSidHandler * pSidHandler = GetSidHandler();
        if(!pSidHandler)
        {
            ASSERT(pSidHandler);
            return E_UNEXPECTED;
        }

        hr = pSidHandler->LookupSids(this,listSids,pListAdmins);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    RemoveItemsFromList(listSids,TRUE);
    return hr;
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::
AddPolicyUser(LONG lPropId,
              IN CBaseAz* pBaseAz)

{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,AddPolicyUser)
    
    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    CString strSid;
    if(GetStringSidFromSidCachecAz(pBaseAz,&strSid))
    {
        CComVariant varSid = strSid;
        hr = m_spAzInterface->AddPropertyItem(lPropId, 
                                              varSid,
                                              CComVariant());
    }
    else
    {
        hr = E_FAIL;
    }
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
HRESULT 
CRoleTaskContainerAzImpl<IAzInterface>::
RemovePolicyUser(IN LONG lPropId,
                 IN CBaseAz* pBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,RemovePolicyUser)

    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }
    
    HRESULT hr = S_OK;
    CString strSid;
    if(GetStringSidFromSidCachecAz(pBaseAz,&strSid))
    {
        CComVariant var = strSid;
        hr = m_spAzInterface->DeletePropertyItem(lPropId,
                                                 var,
                                                 CComVariant()); 
    }
    else
    {
        hr = E_FAIL;
    }
    CHECK_HRESULT(hr);
    return hr;
}

template<class IAzInterface>
BOOL 
CRoleTaskContainerAzImpl<IAzInterface>::
IsSecurable()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,IsSecurable);
    HRESULT hr = S_OK;
    CComVariant varUserList;
    hr = m_spAzInterface->get_PolicyAdministrators(&varUserList);
    if(SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}


template<class IAzInterface>
HRESULT CRoleTaskContainerAzImpl<IAzInterface>::CreateTask(const CString& strTaskName, CTaskAz** ppTaskAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,CreateTask)
    if(strTaskName.IsEmpty() || !ppTaskAz)
    {
        ASSERT(!strTaskName.IsEmpty());
        ASSERT(ppTaskAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strTaskName;
    HRESULT hr = S_OK;
    CComPtr<IAzTask> spTask;

    hr = m_spAzInterface->CreateTask(bstrName,
                                                CComVariant(),  //Reserved
                                                &spTask);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    hr = Submit();
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppTaskAz = new CTaskAz(spTask,this);

    if(!*ppTaskAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::OpenTask(const CString& strTaskName, CTaskAz** ppTaskAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,OpenTask)

    if(strTaskName.IsEmpty() || !ppTaskAz)
    {
        ASSERT(!strTaskName.IsEmpty());
        ASSERT(ppTaskAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strTaskName;
    HRESULT hr = S_OK;
    CComPtr<IAzTask> spTask;
    hr = m_spAzInterface->OpenTask(bstrName,
                                             CComVariant(), //Reserved
                                             &spTask);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppTaskAz = new CTaskAz(spTask,this);

    if(!*ppTaskAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::DeleteTask(const CString& strTaskName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,DeleteTask)
    if(strTaskName.IsEmpty())
    {
        ASSERT(!strTaskName.IsEmpty());
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strTaskName;
    HRESULT hr = S_OK;
    CComPtr<IAzTask> spTask;
    hr = m_spAzInterface->DeleteTask(bstrName,
                                                CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}
    
template<class IAzInterface> HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::GetTaskCollection(TASK_COLLECTION** ppTaskCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,GetTaskCollection)
    if(!ppTaskCollection)
    {
        ASSERT(ppTaskCollection);
        return E_INVALIDARG;
    }
    
    CComPtr<IAzTasks> spAzTasks;
    HRESULT hr = m_spAzInterface->get_Tasks(&spAzTasks);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppTaskCollection = new TASK_COLLECTION(spAzTasks,
                                                          this);
    if(!*ppTaskCollection)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

//
//Methods for Role
//
template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::CreateRole(const CString& strRoleName, CRoleAz** ppRoleAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,CreateRole)
    if(strRoleName.IsEmpty() || !ppRoleAz)
    {
        ASSERT(!strRoleName.IsEmpty());
        ASSERT(ppRoleAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strRoleName;
    HRESULT hr = S_OK;
    CComPtr<IAzRole> spRole;
    hr = m_spAzInterface->CreateRole(bstrName,
                                                CComVariant(),  //Reserved
                                                &spRole);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *ppRoleAz = new CRoleAz(spRole,this);

    if(!*ppRoleAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::OpenRole(const CString& strRoleName, CRoleAz** ppRoleAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,OpenRole)
    if(strRoleName.IsEmpty() || !ppRoleAz)
    {
        ASSERT(!strRoleName.IsEmpty());
        ASSERT(ppRoleAz);
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strRoleName;
    HRESULT hr = S_OK;
    CComPtr<IAzRole> spRole;
    hr = m_spAzInterface->OpenRole(bstrName,
                                             CComVariant(), //Reserved
                                             &spRole);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppRoleAz = new CRoleAz(spRole,this);

    if(!*ppRoleAz)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::DeleteRole(const CString& strRoleName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,DeleteRole)
    if(strRoleName.IsEmpty())
    {
        ASSERT(!strRoleName.IsEmpty());
        return E_INVALIDARG;
    }

    CComBSTR bstrName = strRoleName;
    HRESULT hr = S_OK;
    CComPtr<IAzRole> spRole;
    hr = m_spAzInterface->DeleteRole(bstrName,
                                                CComVariant()); //Reserved
                                            
    CHECK_HRESULT(hr);
    return hr;


}
template<class IAzInterface>
HRESULT
CRoleTaskContainerAzImpl<IAzInterface>
::GetRoleCollection(ROLE_COLLECTION** ppRoleCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleTaskContainerAzImpl,GetRoleCollection)
    if(!ppRoleCollection)
    {
        ASSERT(ppRoleCollection);
        return E_INVALIDARG;
    }
    
    CComPtr<IAzRoles> spAzRoles;
    HRESULT hr = m_spAzInterface->get_Roles(&spAzRoles);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppRoleCollection = new ROLE_COLLECTION(spAzRoles,
                                                        this);
    if(!*ppRoleCollection)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\attrmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       AttrMap.h
//
//  Contents:    Attribute maps to define a property page
//
//  History:    8-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

//
//Forward Declarations
//
struct ATTR_MAP;
class CBaseRolePropertyPage;


typedef HRESULT (*PATTR_FCN)(CDialog* pDlg,
                             CBaseAz* pBaseAz, 
                             ATTR_MAP * pAttrMap,
                             BOOL bDlgReadOnly,
                             CWnd* pWnd,
                             BOOL bNewObject,
                             BOOL *pbSilent);
//
//Enum for attribute Types
//
enum ATTR_TYPE
{   
    ARG_TYPE_BOOL,
    ARG_TYPE_STR,
    ARG_TYPE_INT,
    ARG_TYPE_LONG,  
};

//
//Information about one attibute
//
struct ATTR_INFO
{
    ATTR_TYPE attrType;     //Type of attribute.
    ULONG ulPropId;         //Correspoding Property for the attribute
    ULONG ulMaxLen;         //Maxlen for the property, only applicable for
                                    //property of ARG_TYPE_STR
};

//
//Map attribute to control, plus some extra info
//
struct ATTR_MAP
{
    ATTR_INFO attrInfo;
    BOOL bReadOnly;             //Is Readonly
    BOOL bUseForInitOnly;       //Use this map for property page initialization 
                                        //only Saving will be taken care somewhere else
    BOOL bRequired;             //Attribute is required. 
    ULONG idRequired;               //Message to show if required attribute is not 
                                        //entered by user
    BOOL bDefaultValue;         //Attribute has default value
    union                               //Default value of attribute
    {
        void*   vValue;
      LPTSTR  pszValue;
        long lValue;
        BOOL bValue;
    };
    UINT nControlId;                //Control ID corresponding to attribute
    PATTR_FCN pAttrInitFcn;     //Use this function for attribute init instead 
                                        //of generic routine
    PATTR_FCN pAttrSaveFcn;     //Use this function for attribute save instead 
                                        //of generic routine
};

//+----------------------------------------------------------------------------
//  Function:InitOneAttribute
//  Synopsis: Initializes one attribute defined by pAttrMapEntry   
//  Arguments:pBaseAz: BaseAz object whose attribute is to be initialized
//            pAttrMapEntry: Map entry defining the attribute
//            bDlgReadOnly: If dialog box is readonly
//            pWnd: Control Associated with attribute
//            pbErrorDisplayed: Is Error Displayed by this function
//  Returns:    
//   Note:      if Object is newly created, we directly set the value,
//                  For existing objects, get the current value of attribute and 
//                  only if its different from new value, set it.
//-----------------------------------------------------------------------------
HRESULT
InitOneAttribute(IN CDialog* pDlg,
                 IN CBaseAz * pBaseAz,                    
                 IN ATTR_MAP* pAttrMap,
                 IN BOOL bDlgReadOnly,
                 IN CWnd* pWnd,
                 OUT BOOL *pbErrorDisplayed);


//+----------------------------------------------------------------------------
//  Function:SaveOneAttribute   
//  Synopsis:Saves one attribute defined by pAttrMapEntry   
//  Arguments:pBaseAz: BaseAz object whose attribute is to be saved
//                pAttrMapEntry: Map entry defining the attribute
//                pWnd: Control Associated with attribute
//                bNewObject: If the object is a newly created object. 
//                pbErrorDisplayed: Is Error Displayed by this function
//  Returns:    
//   Note:      if Object is newly created, we directly set the value,
//                  For existing objects, get the current value of attribute and 
//                  only if its different from new value, set it.
//-----------------------------------------------------------------------------
HRESULT
SaveOneAttribute(IN CDialog *pDlg,
                 IN CBaseAz * pBaseAz,                    
                 IN ATTR_MAP* pAttrMap,
                 IN CWnd* pWnd,
                 IN BOOL bNewObject,
                 OUT BOOL *pbErrorDisplayed);

//+----------------------------------------------------------------------------
//  Function:InitDlgFromAttrMap   
//  Synopsis:Initializes Dialog box from Attribute Map
//  Arguments:
//                pDlg: Dialog Box 
//                pAttrMap: Attribute Map
//                pBaseAz: BaseAz object corresponding to attribute map
//                bDlgReadOnly: Dialog box is in Readonly Mode
//-----------------------------------------------------------------------------
BOOL 
InitDlgFromAttrMap(IN CDialog *pDlg,
                   IN ATTR_MAP* pAttrMap,
                   IN CBaseAz* pBaseAz,
                   IN BOOL bDlgReadOnly);


//+----------------------------------------------------------------------------
//  Function:SaveAttrMapChanges   
//  Synopsis:Saves the attributes defined in AttrMap
//  Arguments:pDlg: Dialog box 
//                pAttrMap: Attribute Map
//                pBaseAz: BaseAz object corresponding to attribute map
//                pbErrorDisplayed: Is Error Displayed by this function
//                ppErrorAttrMapEntry: In case of failuer get pointer to error
//                Attribute Map Entry.
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT
SaveAttrMapChanges(IN CDialog* pDlg,
                   IN ATTR_MAP* pAttrMap,
                   IN CBaseAz* pBaseAz, 
                   BOOL bNewObject,
                   OUT BOOL *pbErrorDisplayed, 
                   OUT ATTR_MAP** ppErrorAttrMapEntry);



//
//Declarations for attribute maps
//
extern ATTR_MAP ATTR_MAP_ADMIN_MANAGER_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_APPLICATION_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_SCOPE_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_GROUP_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_TASK_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_ROLE_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_OPERATION_GENERAL_PROPERTY[];
extern ATTR_MAP ATTR_MAP_NEW_OPERATION[];
extern ATTR_MAP ATTR_MAP_NEW_APPLICATION[];
extern ATTR_MAP ATTR_MAP_NEW_SCOPE[];
extern ATTR_MAP ATTR_MAP_NEW_GROUP[];
extern ATTR_MAP ATTR_MAP_NEW_TASK[];
extern ATTR_MAP ATTR_MAP_NEW_ADMIN_MANAGER[];
extern ATTR_MAP ATTR_MAP_OPEN_ADMIN_MANAGER[];
extern ATTR_MAP ATTR_MAP_ADMIN_MANAGER_ADVANCED_PROPERTY[];
extern ATTR_MAP ATTR_MAP_GROUP_QUERY_PROPERTY[];
extern ATTR_MAP ATTR_MAP_SCRIPT_DIALOG[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\assert.cpp ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------

#include "headers.h"
#pragma hdrstop

#include <shlwapi.h>
#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

#if DBG==1


    #include "malloc.h" // alloca

//
//  Globals
//

ULONG g_AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL  g_fInitializedTickCount = FALSE;
ULONG g_ulTickCountAtStart;
BOOL  g_fCritSecInit = FALSE;
CRITICAL_SECTION g_csMessageBuf;
static TCHAR g_szMessageBuf[2048];        // this is the message buffer

DECLARE_HEAPCHECKING;

//
//  Forward declration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  InitializeDebugging(void);
void  smprintf(ULONG ulCompMask, ULONG cchIndent, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
static int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

static int __cdecl w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4smprintf(LPTSTR  format, va_list arglist)
{
    int ret;

    EnterCriticalSection(&g_csMessageBuf);
    ret = StringCchVPrintf(g_szMessageBuf,
								   sizeof(g_szMessageBuf)/sizeof(TCHAR),
									format,
									arglist);
    OutputDebugString(g_szMessageBuf);
    LeaveCriticalSection(&g_csMessageBuf);
    return ret;
}




//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

CRITICAL_SECTION g_csDebugPrint;

void smprintf(
             ULONG ulCompMask,
             ULONG cchIndent,
             LPTSTR  pszComp,
             LPTSTR  ppszfmt,
             va_list pargs)
{
    if (ulCompMask & DEB_FORCE)
    {
        EnterCriticalSection(&g_csDebugPrint);

        if (ulCompMask & DEB_ELAPSEDTIME)
        {
            ULONG ulTicksNow = GetTickCount();

            if (!g_fInitializedTickCount)
            {
                g_fInitializedTickCount = TRUE;
                g_ulTickCountAtStart = ulTicksNow;
            }

            ULONG ulDelta;

            if (g_ulTickCountAtStart > ulTicksNow)
            {
                ulDelta = ulTicksNow + ((ULONG)-1) - g_ulTickCountAtStart;
            }
            else
            {
                ulDelta = ulTicksNow - g_ulTickCountAtStart;
            }
            w4dprintf(_T("%04u.%03u "), ulDelta / 1000, ulDelta % 1000);
        }

        if (!(ulCompMask & DEB_NOCOMPNAME))
        {
            DWORD pid = GetCurrentProcessId();
            DWORD tid = GetCurrentThreadId();

            w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
        }

        if (cchIndent)
        {
            TCHAR tzFmt[] = _T("%999s");
			if(cchIndent > 999)
				cchIndent = 999;

            if(SUCCEEDED(StringCchPrintf(tzFmt,6,_T("%%%us"), cchIndent)))
            {
                w4dprintf(tzFmt, _T(""));
            }
        }
        w4smprintf(ppszfmt, pargs);

        LeaveCriticalSection(&g_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

    #define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
    #define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
    #define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    if (!g_fCritSecInit) InitializeDebugging();

    *pulInfoLevel = DEF_INFOLEVEL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        ADMINDEBUGKEY,
                        0,
                        KEY_READ,
                        &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                            KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                                  REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                               (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                                 (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}

void InitializeDebugging(void)
{
    if (g_fCritSecInit) return;
    InitializeCriticalSection(&g_csMessageBuf);
    InitializeCriticalSection(&g_csDebugPrint);
    g_fCritSecInit = TRUE;
}



// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath))
    {
        if ((pPath[0] == '\\' || pPath[0] == ':')
            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return(LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static CHAR szModuleName[MAX_PATH + 1];
    ZeroMemory(szModuleName,sizeof(szModuleName));
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, MAX_PATH))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    if(FAILED(StringCchPrintf(szAssertCaption,
						  sizeof(szAssertCaption)/sizeof(TCHAR), 
						  _T("%hs: Assertion Failed"), 
						  pProcess)))
    {
        return IDCANCEL;
    }
                          


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    if(FAILED(StringCchPrintf(szDetails,sizeof(szDetails)/sizeof(TCHAR), _T(" Assertion:\t %s\n\n")       \
                             _T(" File:   \t\t %hs\n")        \
                             _T(" Line:   \t\t %d\n\n")       \
                             _T(" Module:   \t %hs\n")        \
                             _T(" Thread ID:\t %d.%d\n"),
                             szMsg, szFile, iLine, pszModuleName, pid, tid)))
    {
        return IDCANCEL;
    }


    int id = MessageBox(NULL,
                        szDetails,
                        szAssertCaption,
                        MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                            | MB_TASKMODAL
                            | MB_ICONEXCLAMATION
                            | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void __cdecl _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, 0, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (g_AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
                   szMessage, pszFileName, iLine, tid);
    }

    if (g_AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (g_AdminAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________



CDbg::CDbg(LPTSTR  str)
    :
m_InfoLevelString(str),
    m_flInfoLevel(DEF_INFOLEVEL),
    m_flOutputOptions(0)
{
    ULONG flRegistry = 0;

    CheckInit(m_InfoLevelString, &flRegistry);

    m_flInfoLevel = flRegistry & DEB_FORCE;
    m_flOutputOptions = flRegistry & ~DEB_FORCE;
}

CDbg::~CDbg()
{
	DEBUG_VERIFY_INSTANCE_COUNT(CAdminManagerAz)
	DEBUG_VERIFY_INSTANCE_COUNT(CAdminManagerNode)
	DEBUG_VERIFY_INSTANCE_COUNT(CApplicationAz)
	DEBUG_VERIFY_INSTANCE_COUNT(CApplicationNode)
	DEBUG_VERIFY_INSTANCE_COUNT(CGroupAz)
	DEBUG_VERIFY_INSTANCE_COUNT(CGroupNode)
	DEBUG_VERIFY_INSTANCE_COUNT(CMachineInfo)
	DEBUG_VERIFY_INSTANCE_COUNT(CNewApplicationDlg)
	DEBUG_VERIFY_INSTANCE_COUNT(CNewAuthorizationStoreDlg)
	DEBUG_VERIFY_INSTANCE_COUNT(CNewScopeDlg)
	DEBUG_VERIFY_INSTANCE_COUNT(COperationAz)
	DEBUG_VERIFY_INSTANCE_COUNT(COperationNode)
	DEBUG_VERIFY_INSTANCE_COUNT(COpenAuthorizationStoreDlg)
	DEBUG_VERIFY_INSTANCE_COUNT(CRoleAz)
	DEBUG_VERIFY_INSTANCE_COUNT(CRoleComponentDataObject)
	DEBUG_VERIFY_INSTANCE_COUNT(CRoleNode)
	DEBUG_VERIFY_INSTANCE_COUNT(CRoleRootData)
	DEBUG_VERIFY_INSTANCE_COUNT(CRoleSnapinAbout)
	DEBUG_VERIFY_INSTANCE_COUNT(CScopeAz)
	DEBUG_VERIFY_INSTANCE_COUNT(CScopeNode)
	DEBUG_VERIFY_INSTANCE_COUNT(SID_CACHE_ENTRY)
	DEBUG_VERIFY_INSTANCE_COUNT(CSidHandler)
	DEBUG_VERIFY_INSTANCE_COUNT(CTaskAz)
	DEBUG_VERIFY_INSTANCE_COUNT(CTaskNode)

	TlsFree(CDbg::s_idxTls);
   CDbg::s_idxTls = 0xFFFFFFFF;
   extern CRITICAL_SECTION g_csMessageBuf;
   extern CRITICAL_SECTION g_csDebugPrint;
   DeleteCriticalSection(&g_csMessageBuf);
   DeleteCriticalSection(&g_csDebugPrint);
}


void __cdecl CDbg::Trace(LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;

    LPTSTR ptcfmt = NULL;
	__try
	{
		ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		ptcfmt = NULL;
	}

	if(!ptcfmt)
		return;

    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pszfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void __cdecl CDbg::Trace(PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwzfmt) + 1;
    LPTSTR ptcfmt = NULL;
	__try
	{
		ptcfmt = (PWSTR)alloca(convert * sizeof(CHAR));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		ptcfmt = NULL;
	}

	if(!ptcfmt)
		return;

    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwzfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;
    LPTSTR ptcfmt = NULL;
	__try
	{
		ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		ptcfmt = NULL;
	}

	if(!ptcfmt)
		return;
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    va_list va;
    va_start (va, pszfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwzfmt) + 1;
    LPTSTR ptcfmt = NULL;
	__try
	{
		ptcfmt = (PWSTR)alloca(convert * sizeof(CHAR));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		ptcfmt = NULL;
	}

	if(!ptcfmt)
		return;

    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    va_list va;
    va_start (va, pwzfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                       err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, PWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    ptcMsg = (PWSTR)alloca(convert * sizeof(WCHAR));
    ptcMsg[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}


ULONG
    CDbg::_GetIndent()
{
    ULONG cchIndent = 0;

    if (s_idxTls != 0xFFFFFFFF)
    {
        cchIndent = static_cast<ULONG>
                        (reinterpret_cast<ULONG_PTR>
                            (TlsGetValue(s_idxTls)));
    }
    return cchIndent;
}

void CDbg::IncIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent++;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}

void CDbg::DecIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent--;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}




#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\baseaz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       baseaz.h
//
//  Contents:   Wrapper classes for IAzInterfaces
//
//  History:    9-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

//
//Enumeration For AzObject Types
//
enum OBJECT_TYPE_AZ
{
    ADMIN_MANAGER_AZ,
    APPLICATION_AZ,
    SCOPE_AZ,
    GROUP_AZ,
    ROLE_DEFINITION_AZ,
    TASK_AZ,
    ROLE_AZ,
    OPERATION_AZ,
    SIDCACHE_AZ,
    //
    //Below are not the acutal AZ Object Types. But 
    //they are needed in UI to represent various 
    //collection objects. 
    //
    GROUP_COLLECTION_AZ,
    ROLE_DEFINITION_COLLECTION_AZ,
    TASK_COLLECTION_AZ,
    ROLE_COLLECTION_AZ,
    OPERATION_COLLECTION_AZ,
    DEFINITION_COLLECTION_AZ,

    AZ_ENUM_END,
};


//AZ STORES TYPES
#define AZ_ADMIN_STORE_AD       0x1
#define AZ_ADMIN_STORE_XML      0x2
#define AZ_ADMIN_STORE_INVALID  0x3

//Forward Declaration
class CContainerAz;
class CAdminManagerAz;

/******************************************************************************
Class:  CBaseAz
Purpose: This is the base class for all AzObject classes.
******************************************************************************/
class CBaseAz
{
public:
    CBaseAz(OBJECT_TYPE_AZ eObjectType,
            CContainerAz* pParentContainerAz)
            :m_eObjectType(eObjectType),
            m_pParentContainerAz(pParentContainerAz)
    {
    }
    
    virtual ~CBaseAz(){}

    //
    //Generic Get/Set Property Methods. They are overloaded for 
    //various datatypes
    //
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                IN const CString& strPropName) = 0;
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                OUT CString* strPropName) = 0;
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                IN BOOL bValue) = 0;
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                OUT BOOL *pbValue) = 0;
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                IN LONG lValue) = 0;
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                OUT LONG* lValue) = 0;

    //
    //Most of the objects have some properties which are list
    //Following are generic methods to handle such properties
    //
    virtual HRESULT 
    GetMembers(IN LONG /*lPropId*/,
               OUT CList<CBaseAz*,CBaseAz*>& /*listMembers*/)
    {
        return E_NOTIMPL;
    }

    virtual HRESULT 
    AddMember(IN LONG /*lPropId*/,
              IN CBaseAz* /*pBaseAz*/)

    {
        return E_NOTIMPL;
    }

    virtual HRESULT 
    RemoveMember(IN LONG /*lPropId*/,
                 IN CBaseAz* /*pBaseAz*/)
    {
        return E_NOTIMPL;
    }

    //
    //Get Name and Description Method. They are frequently needed
    //so providing separate methods for them instead of using 
    //Get/Set Property methods
    //
    virtual const CString& 
    GetName()=0;
    
    virtual HRESULT 
    SetName(IN const CString& strName)=0;

    virtual const 
    CString& GetDescription()=0;
    
    virtual HRESULT 
    SetDescription(IN const CString& strDesc)=0;

    virtual int
    GetImageIndex() = 0;
    
    //Is This object writable by current user.
    virtual HRESULT 
    IsWritable(BOOL& brefWrite);

    //Submit all the changes done to object
    virtual HRESULT 
    Submit() = 0;
    
    //Clear All the changes done to object.
    virtual HRESULT 
    Clear() = 0;

    CContainerAz* GetParentAz()
    {
        return m_pParentContainerAz;
    }

    virtual 
    CString 
    GetParentType();
    
    OBJECT_TYPE_AZ 
    GetObjectType()
    {
        return m_eObjectType;
    }
    
    virtual const 
    CString& GetType()
    {
        return m_strType;
    }
    
    virtual CSidHandler*
    GetSidHandler();

    virtual CAdminManagerAz*
    GetAdminManager();

protected:
    virtual VOID 
    SetType(UINT nTypeStringId)
    {
        VERIFY(m_strType.LoadString(nTypeStringId));
    }

    //Type of object
    OBJECT_TYPE_AZ m_eObjectType;
    
    //Parent AzObject
    CContainerAz* m_pParentContainerAz;
    CString m_strName;
    CString m_strDescription;
    CString m_strType;
};

/******************************************************************************
Class:  CBaseAzImpl
Purpose: A templated class which implements CBaseAz methods
******************************************************************************/

template<class IAzInterface>
class CBaseAzImpl: public CBaseAz
{
public:
    CBaseAzImpl(CComPtr<IAzInterface>& pAzInterface,
                    OBJECT_TYPE_AZ eObjectType,
                    CContainerAz* pParentContainerAz);

    virtual ~CBaseAzImpl();

    //
    //CBaseAz overrides
    //
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN const CString& strPropName);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT CString* strPropName);
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN BOOL bValue);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT BOOL *pbValue);
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN LONG lValue);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT LONG* lValue);
    virtual const CString& GetName();
    virtual HRESULT SetName(IN const CString& strName);

    virtual const CString& GetDescription();
    virtual HRESULT SetDescription(IN const CString& strDesc);
    
    virtual HRESULT Submit();
    virtual HRESULT Clear();
protected:
    CComPtr<IAzInterface> m_spAzInterface;      
};

/******************************************************************************
Class:  CContainerAz
Purpose: AdminManagerAz, ApplicationAz and ScopeAz can contain child objects.
            All of them can contain group objects. CContainerAz is base class
            for all AzObjects which are container
******************************************************************************/
class CContainerAz  :public CBaseAz
{
public:
    CContainerAz(OBJECT_TYPE_AZ eObjectType,
                     CContainerAz* pParentContainerAz)
                     :CBaseAz(eObjectType,
                                 pParentContainerAz)
    {
    }                                   
    virtual ~CContainerAz(){}

    //
    //Create/Delete/Open an object of type eObjectType
    //
    virtual HRESULT 
    CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                   IN const CString& strName, 
                   OUT CBaseAz** ppBaseAz) = 0;

    virtual HRESULT 
    DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                   IN const CString& strName) = 0;

    virtual HRESULT 
    OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
               IN const CString& strName,
               OUT CBaseAz** ppBaseAz) = 0;


    //returns Child AzObject of type eObjectType
    HRESULT 
    GetAzChildObjects(IN OBJECT_TYPE_AZ eObjectType, 
                      IN OUT CList<CBaseAz*,CBaseAz*>& ListChildObjects);


    //
    //Group Methods
    //
    virtual HRESULT CreateGroup(IN const CString& strName, 
                                OUT CGroupAz** ppGroupAz) = 0;
    virtual HRESULT DeleteGroup(IN const CString& strName) =0;  
    virtual HRESULT OpenGroup(IN const CString& strGroupName, 
                              OUT CGroupAz** ppGroupAz) =0;
    virtual HRESULT GetGroupCollection(OUT GROUP_COLLECTION** ppGroupCollection) =0;

    //
    //Check if child objects can be created under this container, i.e.
    //if current user has access to create child objects
    //
    virtual HRESULT 
    CanCreateChildObject(BOOL& bCahCreateChild);

    virtual BOOL
    IsSecurable() = 0;

    virtual BOOL
    IsDelegatorSupported();

    virtual BOOL 
    IsAuditingSupported();
    //
    //Policy Reader and AdminProperty
    //
    virtual HRESULT 
    GetPolicyUsers( IN LONG lPropId,
                    OUT CList<CBaseAz*,CBaseAz*>& pListAdmins) = 0;
    
    virtual HRESULT 
    AddPolicyUser(LONG lPropId,
                  IN CBaseAz* pBaseAz) = 0;

    virtual HRESULT
    RemovePolicyUser(LONG lPropId,
                     IN CBaseAz* pBaseAz) = 0;


    //
    //CBaseAz Overrides
    //
    virtual HRESULT 
    GetMembers(IN LONG lPropId,
               OUT CList<CBaseAz*,CBaseAz*>& listMembers);

    virtual HRESULT 
    AddMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz);

    virtual HRESULT 
    RemoveMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz);
protected:
    //Get collection of object of type eObjectType
    virtual HRESULT 
    GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                          OUT CBaseAzCollection **ppBaseAzCollection) = 0;
    
};

/******************************************************************************
Class:  CContainerAzImpl
Purpose: A templated class which implements CContainerAz methods
******************************************************************************/
template<class IAzInterface>
class CContainerAzImpl: public CContainerAz
{
public:
    CContainerAzImpl(CComPtr<IAzInterface>& pAzInterface,
                          OBJECT_TYPE_AZ eObjectType,
                          CContainerAz* pParentContainerAz);

    virtual ~CContainerAzImpl();

    //
    //CContainerAz Overrides
    //
    virtual HRESULT CreateGroup(IN const CString& strName, 
                                OUT CGroupAz** ppGroupAz);
    virtual HRESULT DeleteGroup(IN const CString& strName);
    virtual HRESULT GetGroupCollection(OUT GROUP_COLLECTION** ppGroupCollection);
    virtual HRESULT OpenGroup(IN const CString& strGroupName, 
                              OUT CGroupAz** ppGroupAz);
    virtual HRESULT 
    GetPolicyUsers(IN LONG lPropId,
                   OUT CList<CBaseAz*,CBaseAz*>& pListAdmins);
    
    virtual HRESULT 
    AddPolicyUser(LONG lPropId,
                  IN CBaseAz* pBaseAz);

    virtual HRESULT
    RemovePolicyUser(LONG lPropId,
                     IN CBaseAz* pBaseAz);

    virtual BOOL
    IsSecurable();

    //
    //CBaseAz overrides
    //
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN const CString& strPropName);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                        OUT CString* strPropName);
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN BOOL bValue);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT BOOL *pbValue);
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN LONG lValue);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT LONG* lValue);
    virtual const CString& GetName();
    virtual HRESULT SetName(IN const CString& strName);

    virtual const CString& GetDescription();
    virtual HRESULT SetDescription(IN const CString& strDesc);
    
    virtual HRESULT Submit();
    virtual HRESULT Clear();

protected:
    CComPtr<IAzInterface> m_spAzInterface;      
};

/******************************************************************************
Class:  CRoleTaskContainerAz
Purpose: Base class for cotnaiers which can contain role and task. 
            CScopeAz and CApplicationAz will be derived from this
******************************************************************************/
class CRoleTaskContainerAz :public CContainerAz
{
public:
    CRoleTaskContainerAz(OBJECT_TYPE_AZ eObjectType,
                                CContainerAz* pParentContainerAz)
                                :CContainerAz(eObjectType,
                                                  pParentContainerAz)
    {
    }   
    virtual ~CRoleTaskContainerAz(){}

    //
    //Role and Task Methods
    //
    virtual HRESULT CreateRole(IN const CString& strName, 
                                        OUT CRoleAz** ppRoleAz)= 0;
    virtual HRESULT CreateTask(IN const CString& strName, 
                                        OUT CTaskAz** ppTaskAz)= 0; 
    virtual HRESULT DeleteRole(IN const CString& strName)= 0;
    virtual HRESULT DeleteTask(IN const CString& strName)= 0;   
    virtual HRESULT GetTaskCollection(OUT TASK_COLLECTION** ppTaskCollection)= 0;
    virtual HRESULT GetRoleCollection(OUT ROLE_COLLECTION** ppRoleCollection)= 0;
    virtual HRESULT OpenTask(IN const CString& strTaskName, 
                                     OUT CTaskAz** ppTaskAz)= 0;
    virtual HRESULT OpenRole(IN const CString& strRoleName, 
                                     OUT CRoleAz** ppRoleAz)= 0;
};
/******************************************************************************
Class:  CRoleTaskContainerAzImpl
Purpose: A templated class which implements CRoleTaskContainerAz methods
******************************************************************************/
template<class IAzInterface>
class CRoleTaskContainerAzImpl: public CRoleTaskContainerAz
{
public:
    CRoleTaskContainerAzImpl(CComPtr<IAzInterface>& pAzInterface,
                                     OBJECT_TYPE_AZ eObjectType,
                                     CContainerAz* pParentContainerAz);

    virtual ~CRoleTaskContainerAzImpl();

    //
    //CRoleTaskContainerAz Overrides
    //
    virtual HRESULT CreateRole(IN const CString& strName, 
                                        OUT CRoleAz** ppRoleAz);
    virtual HRESULT CreateTask(IN const CString& strName, 
                                        OUT CTaskAz** ppTaskAz);    
    virtual HRESULT DeleteRole(IN const CString& strName);
    virtual HRESULT DeleteTask(IN const CString& strName);  
    virtual HRESULT GetTaskCollection(OUT TASK_COLLECTION** ppTaskCollection);
    virtual HRESULT GetRoleCollection(OUT ROLE_COLLECTION** ppRoleCollection);
    virtual HRESULT OpenTask(IN const CString& strTaskName, 
                                     OUT CTaskAz** ppTaskAz);
    virtual HRESULT OpenRole(IN const CString& strRoleName, 
                                     OUT CRoleAz** ppRoleAz);

    //
    //CContainerAz Overrides
    //
    virtual HRESULT CreateGroup(IN const CString& strName, 
                                         OUT CGroupAz** ppGroupAz);
    virtual HRESULT DeleteGroup(IN const CString& strName);
    virtual HRESULT GetGroupCollection(OUT GROUP_COLLECTION** ppGroupCollection);
    virtual HRESULT OpenGroup(IN const CString& strGroupName, 
                                      OUT CGroupAz** ppGroupAz);
    virtual HRESULT 
    GetPolicyUsers(IN LONG lPropId,
                   OUT CList<CBaseAz*,CBaseAz*>& pListAdmins);
    
    virtual HRESULT 
    AddPolicyUser(LONG lPropId,
                  IN CBaseAz* pBaseAz);

    virtual HRESULT
    RemovePolicyUser(LONG lPropId,
                     IN CBaseAz* pBaseAz);

    virtual BOOL
    IsSecurable();

    //
    //CBaseAz overrides
    //
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN const CString& strPropName);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                        OUT CString* strPropName);
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN BOOL bValue);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT BOOL *pbValue);
    virtual HRESULT SetProperty(IN LONG lPropId, 
                                         IN LONG lValue);
    virtual HRESULT GetProperty(IN LONG lPropId, 
                                         OUT LONG* lValue);
    virtual const CString& GetName();
    virtual HRESULT SetName(IN const CString& strName);

    virtual const CString& GetDescription();
    virtual HRESULT SetDescription(IN const CString& strDesc);
    
    virtual HRESULT Submit();
    virtual HRESULT Clear();

protected:
    CComPtr<IAzInterface> m_spAzInterface;      
};

/******************************************************************************
Class:  CAdminManagerAz
Purpose: class for IAzAdminManager interface
******************************************************************************/
class CAdminManagerAz : public CContainerAzImpl<IAzAuthorizationStore>
{
public:
    CAdminManagerAz(CComPtr<IAzAuthorizationStore>& spAzInterface);
    virtual ~CAdminManagerAz();

    //
    //Functions for creating a new or opening an existing AdminManager 
    //object
    //
    HRESULT Initialize(IN ULONG lStoreType, 
                             IN ULONG lFlags, 
                             IN const CString& strPolicyURL);

    HRESULT OpenPolicyStore(IN ULONG lStoreType, 
                                    IN const CString& strPolicyURL);

    HRESULT CreatePolicyStore(IN ULONG lStoreType, 
                                      IN const CString& strPolicyURL);

    HRESULT DeleteSelf();

    HRESULT UpdateCache();

    //
    //Application Methods
    //
    HRESULT CreateApplication(const CString& strApplicationName,CApplicationAz ** ppApplicationAz);
    HRESULT DeleteApplication(const CString& strApplicationName);
    HRESULT GetApplicationCollection(APPLICATION_COLLECTION** ppApplicationCollection);

    //CContainerAz Overrides
    virtual HRESULT CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                                            IN const CString& strName, 
                                            OUT CBaseAz** ppBaseAz);

    virtual HRESULT DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                                             IN const CString& strName);

    virtual HRESULT OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
                                        IN const CString& strName,
                                        OUT CBaseAz** ppBaseAz);

    virtual HRESULT GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                                                      OUT CBaseAzCollection **ppBaseAzCollection);

    virtual const CString& GetName(){return m_strPolicyURL;}
    
    virtual const CString& GetDisplayName(){ return m_strAdminManagerName;}

    //XML Store or AD
    ULONG GetStoreType(){return m_ulStoreType;}

    HRESULT
    CreateSidHandler(const CString& strTargetComputerName);

    
    CSidHandler*
    GetSidHandler()
    {
        return m_pSidHandler;
    }

    CAdminManagerAz*
    GetAdminManager()
    {
        return this;
    }

    int
    GetImageIndex(){ return iIconStore;}

private:
    CString m_strPolicyURL;     //Entire path
    CString m_strAdminManagerName;  //leaf element which is used for display
    ULONG m_ulStoreType;
    CSidHandler* m_pSidHandler;
};

/******************************************************************************
Class:  CApplicationAz
Purpose: class for IAzApplication interface
******************************************************************************/
class CApplicationAz : public CRoleTaskContainerAzImpl<IAzApplication>
{
public:
    CApplicationAz(CComPtr<IAzApplication>& spAzInterface,
                        CContainerAz* pParentContainerAz);
    virtual ~CApplicationAz();

    //
    //Scope Methods
    //
    virtual HRESULT CreateScope(IN const CString& strScopeName, 
                                         OUT CScopeAz** ppScopeAz);
    virtual HRESULT DeleteScope(IN const CString& strScopeName);
    virtual HRESULT GetScopeCollection(OUT SCOPE_COLLECTION** ppScopeCollection);

    //
    //Methods for Operation, 
    //
    virtual HRESULT CreateOperation(IN const CString& strOperationName,
                                              OUT COperationAz** ppOperationAz);
    virtual HRESULT DeleteOperation(IN const CString& strOperationName);
    virtual HRESULT OpenOperation(IN const CString& strOperationName,
                                            OUT COperationAz** ppOperationAz);
    virtual HRESULT GetOperationCollection(OUT OPERATION_COLLECTION** ppOperationCollection);

    //
    //CContainerAz Overrides
    //
    virtual HRESULT CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                                            IN const CString& strName, 
                                            OUT CBaseAz** ppBaseAz);

    virtual HRESULT DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                                             IN const CString& strName);

    virtual HRESULT OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
                                        IN const CString& strName,
                                        OUT CBaseAz** ppBaseAz);

    virtual HRESULT GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                                                      OUT CBaseAzCollection **ppBaseAzCollection);
    int
    GetImageIndex(){ return iIconApplication;}
};

/******************************************************************************
Class:  CScopeAz
Purpose: class for IAzScope interface
******************************************************************************/
class CScopeAz: public CRoleTaskContainerAzImpl<IAzScope>
{
public:
    CScopeAz(CComPtr<IAzScope>& spAzInterface,
                CContainerAz* pParentContainerAz);
    virtual ~CScopeAz();

    //
    //CContainerAz Override
    //

    virtual HRESULT 
    CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                        IN const CString& strName, 
                        OUT CBaseAz** ppBaseAz);

    virtual HRESULT 
    DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                        IN const CString& strName);

    virtual HRESULT 
    OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
                  IN const CString& strName,
                  OUT CBaseAz** ppBaseAz);

    virtual HRESULT 
    GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                                 OUT CBaseAzCollection **ppBaseAzCollection);

    int
    GetImageIndex(){ return iIconScope;}

    HRESULT
    CanScopeBeDelegated(BOOL & bDelegatable);

    HRESULT
    BizRulesWritable(BOOL &bBizRuleWritable);
};

/******************************************************************************
Class:  CTaskAz
Purpose: class for IAzTask interface
******************************************************************************/
class CTaskAz: public CBaseAzImpl<IAzTask>
{
public:
    CTaskAz(CComPtr<IAzTask>& spAzInterface,
              CContainerAz* pParentContainerAz);
    virtual ~CTaskAz();
    
    BOOL IsRoleDefinition();

    HRESULT MakeRoleDefinition();

    //CBaseAz Overrides
    virtual HRESULT 
    GetMembers(IN LONG lPropId,
                  OUT CList<CBaseAz*,CBaseAz*>& listMembers);

    virtual HRESULT 
    AddMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz);

    virtual HRESULT 
    RemoveMember(IN LONG lPropId,
                     IN CBaseAz* pBaseAz);

    int
    GetImageIndex();

private:
    //Get Memeber Operations
    HRESULT GetOperations(OUT CList<CBaseAz*,CBaseAz*>& listOperationAz);

    //Get Member Tasks
    HRESULT GetTasks(OUT CList<CBaseAz*,CBaseAz*>& listTaskAz);

};



/******************************************************************************
Class:  CGroupAz
Purpose: class for IAzApplicationGroup interface
******************************************************************************/
class CGroupAz: public CBaseAzImpl<IAzApplicationGroup>
{
public:
    CGroupAz(CComPtr<IAzApplicationGroup>& spAzInterface,
                CContainerAz* pParentContainerAz);
    virtual ~CGroupAz();

    HRESULT GetGroupType(OUT LONG* plGroupType);
    HRESULT SetGroupType(IN LONG plGroupType);

    //Get Member groups of this group which are Windows Groups.
    HRESULT 
    GetWindowsGroups(OUT CList<CBaseAz*, CBaseAz*>& listWindowsGroups, 
                     IN BOOL bMember);

    //Add new windows group to member list
    HRESULT AddWindowsGroup(IN CBaseAz* pBaseAz, 
                                    IN BOOL bMember);


    //Get Member Groups of this group which are Application Groups
    HRESULT GetApplicationGroups(OUT CList<CBaseAz*,CBaseAz*>& listGroupAz, 
                                          IN BOOL bMember);
    //Add new Application group to member list
    HRESULT AddApplicationGroup(IN CBaseAz* pGroupAz, 
                                         IN BOOL bMember);

    //CBaseAz Overrides
    virtual HRESULT 
    GetMembers(IN LONG lPropId,
                  OUT CList<CBaseAz*,CBaseAz*>& listMembers);

    virtual HRESULT 
    AddMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz);

    virtual HRESULT 
    RemoveMember(IN LONG lPropId,
                     IN CBaseAz* pBaseAz);
    int
    GetImageIndex();

};
    

/******************************************************************************
Class:  CRoleAz
Purpose: class for IAzRole interface
******************************************************************************/
class CRoleAz: public CBaseAzImpl<IAzRole>
{
public:
    CRoleAz(CComPtr<IAzRole>& spAzInterface,
              CContainerAz* pParentContainerAz);
    virtual ~CRoleAz();

    //CBaseAz Overrides
    virtual HRESULT 
    GetMembers(IN LONG lPropId,
                  OUT CList<CBaseAz*,CBaseAz*>& listMembers);

    virtual HRESULT 
    AddMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz);

    virtual HRESULT 
    RemoveMember(IN LONG lPropId,
                     IN CBaseAz* pBaseAz);
    int
    GetImageIndex(){ return iIconRole;}
private:
    //Get Member operations
    HRESULT 
    GetOperations(OUT CList<CBaseAz*,CBaseAz*>& listOperationAz);

    //Get Member Tasks
    HRESULT GetTasks(CList<CBaseAz*,CBaseAz*>& listTaskAz);

    //Get Member groups of this group which are Windows Groups.
    HRESULT GetWindowsGroups(OUT CList<CBaseAz*,CBaseAz*>& listUsers);  

    //Get Member Groups of this group which are Application Groups
    HRESULT GetApplicationGroups(OUT CList<CBaseAz*,CBaseAz*>& listGroupAz);


};

/******************************************************************************
Class:  COperationAz
Purpose: class for IAzOperation interface
******************************************************************************/
class COperationAz: public CBaseAzImpl<IAzOperation>
{
public:
    COperationAz(CComPtr<IAzOperation>& spAzInterface,
                     CContainerAz* pParentContainerAz);
    virtual ~COperationAz();

    int
    GetImageIndex(){ return iIconOperation;}

private:

};

/******************************************************************************
Class:  CSidCacheAz
Purpose: class for IAzOperation interface
******************************************************************************/
class CSidCacheAz: public CBaseAz
{
public:
    CSidCacheAz(SID_CACHE_ENTRY *pSidCacheEntry,
                    CBaseAz* pOwnerBaseAz);
    virtual ~CSidCacheAz();

    PSID GetSid()
    { 
        return m_pSidCacheEntry->GetSid();
    }

    CBaseAz* GetOwnerAz()
    {
        return m_pOwnerBaseAz;
    }

    //
    //CBaseAz Override
    //
    CString GetParentType()
    {
        return m_pOwnerBaseAz->GetType();   
    }

    virtual HRESULT SetProperty(IN LONG /*lPropId*/, 
                                IN const CString& /*strPropName*/){return E_NOTIMPL;};
    virtual HRESULT GetProperty(IN LONG /*lPropId*/, 
                                OUT CString* /*strPropName*/){return E_NOTIMPL;};
    virtual HRESULT SetProperty(IN LONG /*lPropId*/, 
                                IN BOOL /*bValue*/){return E_NOTIMPL;};
    virtual HRESULT GetProperty(IN LONG /*lPropId*/, 
                                OUT BOOL* /*pbValue*/){return E_NOTIMPL;};
    virtual HRESULT SetProperty(IN LONG /*lPropId*/, 
                                IN LONG /*lValue*/){return E_NOTIMPL;};
    virtual HRESULT GetProperty(IN LONG /*lPropId*/, 
                                OUT LONG* /*lValue*/){return E_NOTIMPL;};

    //
    //Get Name and Description Method. They are frequently needed
    //so providing separate methods for them instead of using 
    //Get/Set Property methods
    //
    virtual const 
    CString& GetName()
    {
        return m_pSidCacheEntry->GetNameToDisplay();
    }

    virtual const
    CString& GetType()
    {
        return m_pSidCacheEntry->GetSidType();
    }
    virtual HRESULT SetName(IN const CString& /*strName*/){return E_NOTIMPL;}

    virtual const CString& GetDescription(){return m_strDescription;}
    virtual HRESULT SetDescription(IN const CString& /*strDesc*/){return E_NOTIMPL;}
    
    //Is This object writable by current user.
    virtual HRESULT 
    IsWritable(BOOL& brefWrite)
    {
        brefWrite = FALSE;
        return S_OK;
    }

    int
    GetImageIndex();


    //Submit all the changes done to object
    virtual HRESULT Submit(){return E_NOTIMPL;};
    //Clear All the changes done to object.
    virtual HRESULT Clear(){return E_NOTIMPL;};

private:
    SID_CACHE_ENTRY *m_pSidCacheEntry;
    //
    //CSidCacheAz is not a real object in AZ Schema. Its an object to represent
    //SIDS. SIDs appear in various member properties of BaseAz objects.
    //m_pOwnerBaseAz is back pointer to owner object which has this CSidCacheAz
    //object in member list of one of its property
    //
    CBaseAz* m_pOwnerBaseAz;
};

//+----------------------------------------------------------------------------
//  Function: GetAllAzChildObjects  
//  Synopsis: Functions gets the child objects of type eObjectType and appends
//                them to ListChildObjects. It gets the childobjects from 
//                pParentContainerAz and from parent/grandparent of 
//                pParentContainerAz.
//-----------------------------------------------------------------------------
HRESULT GetAllAzChildObjects(IN CContainerAz* pParentContainerAz, 
                                      IN OBJECT_TYPE_AZ eObjectType, 
                                      OUT CList<CBaseAz*,CBaseAz*>& ListChildObjects);

//+----------------------------------------------------------------------------
//  Function: GetPolicyUsersFromAllLevel  
//  Synopsis: Functions gets the PolicyUsers and appends
//                them to listPolicyUsers. It gets the PolicyUsers from 
//                pContainerAz and from parent/grandparent of 
//                pContainerAz.
//-----------------------------------------------------------------------------
HRESULT GetPolicyUsersFromAllLevel(IN LONG lPropId,
                                              IN CContainerAz* pContainerAz, 
                                              OUT CList<CBaseAz*,CBaseAz*>& listPolicyUsers);


//+----------------------------------------------------------------------------
//  Function: OpenObjectFromAllLevels 
//  Synopsis: Opens an object of type eObjectType and name strName. If object
//                cannot be opened at pParentContainerAz, function tries at 
//                parent/grandparent of pParentContainerAz
//-----------------------------------------------------------------------------
HRESULT OpenObjectFromAllLevels(IN CContainerAz* pParentContainerAz, 
                                          IN OBJECT_TYPE_AZ eObjectType, 
                                          IN const CString& strName,
                                          OUT CBaseAz** ppBaseAz);

//+----------------------------------------------------------------------------
//  Function:SafeArrayToAzObjectList
//  Synopsis:Input to function is a safearray of BSTR. Each BSTR in array is 
//               name of object of type eObjectType. Function converts this safe
//               array into a list of corresponding CBaseAz objects.
//  Arguments:var: Varaint of type VT_ARRAY|VT_BSTR
//                pParentContainerAz: Pointer of parent which contains objects
//                                           in safe array.                                       
//                eObjectType: Type of object in safe array
//                listAzObject: Gets list of CBaseAz objects
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT SafeArrayToAzObjectList(IN CComVariant& var,
                                            IN CContainerAz* pParentContainerAz, 
                                            IN OBJECT_TYPE_AZ eObjectType, 
                                            OUT CList<CBaseAz*,CBaseAz*>& listAzObject);


HRESULT 
SafeArrayToSidList(IN CComVariant& var,
                      OUT CList<PSID,PSID>& listSid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\comp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       comp.cpp
//
//  Contents:   IComponent implementation
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CRoleComponentObject)

CRoleComponentObject::CRoleComponentObject()
{
	TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CRoleComponentObject)
	DEBUG_INCREMENT_INSTANCE_COUNTER(CRoleComponentObject)
}
	
CRoleComponentObject::~CRoleComponentObject()
{
	TRACE_DESTRUCTOR_EX(DEB_SNAPIN, CRoleComponentObject)
	DEBUG_DECREMENT_INSTANCE_COUNTER(CRoleComponentObject)
}

HRESULT CRoleComponentObject::InitializeHeaders(CContainerNode* pContainerNode)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentObject,InitializeHeaders)

	if(!pContainerNode)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	HRESULT hr = S_OK;
	ASSERT(m_pHeader);

	CColumnSet* pColumnSet = pContainerNode->GetColumnSet();
	POSITION pos = pColumnSet->GetHeadPosition();
	while (pos != NULL)
	{
		CColumn* pColumn = pColumnSet->GetNext(pos);

		hr = m_pHeader->InsertColumn(pColumn->GetColumnNum(), 
                                   pColumn->GetHeader(),
								           pColumn->GetFormat(),
								           AUTO_WIDTH);
		if (FAILED(hr))
		{
			DBG_OUT_HRESULT(hr);
			return hr;
		}

		hr = m_pHeader->SetColumnWidth(pColumn->GetColumnNum(), pColumn->GetWidth());
		if (FAILED(hr))
		{
			DBG_OUT_HRESULT(hr);
			return hr;
		}
	}
	return hr;
}


HRESULT CRoleComponentObject::InitializeBitmaps(CTreeNode*)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentObject,InitializeBitmaps)

	// Structure to map a Resource ID to an index of icon
	return LoadIcons(m_pImageResult);
}

//CONST INT cButtons = sizeof(g_DNSMGR_SnapinButtons)/sizeof(MMCBUTTON);

HRESULT CRoleComponentObject::InitializeToolbar(IToolbar* pToolbar)
{

	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject, InitializeToolbar)
	if(!pToolbar)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	
	return S_OK;
}

HRESULT 
CRoleComponentObject::LoadToolbarStrings(MMCBUTTON * /*Buttons*/)
{
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\attrmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       AttrMap.cpp
//
//  Contents:    Attribute maps to define a property page
//
//  History:    8-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#include "headers.h"


//+----------------------------------------------------------------------------
//  Function:InitOneAttribute
//  Synopsis: Initializes one attribute defined by pAttrMapEntry   
//  Arguments:pBaseAz: BaseAz object whose attribute is to be initialized
//            pAttrMapEntry: Map entry defining the attribute
//            bDlgReadOnly: If dialog box is readonly
//            pWnd: Control Associated with attribute
//            bNewObject: If the object is a newly created object. 
//            pbErrorDisplayed: Is Error Displayed by this function
//  Returns:    
//   Note:      if Object is newly created, we directly set the value,
//                  For existing objects, get the current value of attribute and 
//                  only if its different from new value, set it.
//-----------------------------------------------------------------------------
HRESULT
InitOneAttribute(IN CDialog *pDlg,
                 IN CBaseAz * pBaseAz,                    
                 IN ATTR_MAP* pAttrMap,
                 IN BOOL bDlgReadOnly,
                 IN CWnd* pWnd,
                 OUT BOOL *pbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,InitOneAttribute)

    if(!pDlg || !pAttrMap || !pWnd || !pbErrorDisplayed)
    {
        //ASSERT(pBaseAz); For New Dialogs this value is null
        ASSERT(pDlg);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        ASSERT(pbErrorDisplayed);
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    //If a function is provided, delegate initialization to it.
    PATTR_FCN pAttrFcn = pAttrMap->pAttrInitFcn;
    if(pAttrFcn)
    {
        hr = (*pAttrFcn)(pDlg,
                         pBaseAz,                             
                         pAttrMap,
                         bDlgReadOnly,
                         pWnd,
                         !pBaseAz,
                         pbErrorDisplayed);
                              
        CHECK_HRESULT(hr);
        return hr;
    }
    
    ATTR_INFO* pAttrInfo = &(pAttrMap->attrInfo);

    switch (pAttrInfo->attrType)
    {
        case ARG_TYPE_STR:
        {
            CEdit* pEdit = (CEdit*)pWnd;
            if(pBaseAz)
            {
                //For existing object, Get the value of attribute and 
                //set it in the control
                CString strValue;
                hr = pBaseAz->GetProperty(pAttrInfo->ulPropId, &strValue);
                BREAK_ON_FAIL_HRESULT(hr);
                pEdit->SetWindowText(strValue);
            }
            else if(pAttrMap->bDefaultValue)
            {
                //For new objects, if default value is provided for 
                //the attribute, set it in the control
                CString strValue;
                if(IS_INTRESOURCE(pAttrMap->pszValue))
                    VERIFY(strValue.LoadString((ULONG)((ULONG_PTR)pAttrMap->pszValue)));
                else
                    strValue = pAttrMap->pszValue;

                pEdit->SetWindowText(strValue);
            }

            if(pAttrMap->bReadOnly || bDlgReadOnly)
                pEdit->SetReadOnly(TRUE);               

            if(pAttrInfo->ulMaxLen)
                pEdit->SetLimitText(pAttrInfo->ulMaxLen);
        
            break;
        }

        case ARG_TYPE_LONG:
        {           
            CEdit* pEdit = (CEdit*)pWnd;
            if(pBaseAz)
            {
                LONG lValue;
                hr = pBaseAz->GetProperty(pAttrInfo->ulPropId, &lValue);
                BREAK_ON_FAIL_HRESULT(hr);
                
                SetLongValue(pEdit,lValue);
            }
            else if(pAttrMap->bDefaultValue)
            {
                SetLongValue(pEdit, pAttrMap->lValue);
            }

            if(pAttrMap->bReadOnly || bDlgReadOnly)
                pEdit->SetReadOnly(TRUE);               

            if(pAttrInfo->ulMaxLen)
                pEdit->SetLimitText(pAttrInfo->ulMaxLen);

            break;
        }
        case ARG_TYPE_BOOL:
        {
            CButton* pBtn = (CButton*)pWnd;
            if(pBaseAz)
            {
                BOOL bValue;
                hr = pBaseAz->GetProperty(pAttrInfo->ulPropId, &bValue);
                BREAK_ON_FAIL_HRESULT(hr);
                if(bValue)
                    pBtn->SetCheck(1);
            }

            if(pAttrMap->bReadOnly || bDlgReadOnly)
            {
                pBtn->EnableWindow(FALSE);
            }
        }   
    }   

    return hr;
}

//+----------------------------------------------------------------------------
//  Function:SaveOneAttribute   
//  Synopsis:Saves one attribute defined by pAttrMapEntry   
//  Arguments:pBaseAz: BaseAz object whose attribute is to be saved
//                pAttrMapEntry: Map entry defining the attribute
//                pWnd: Control Associated with attribute
//                bNewObject: If the object is a newly created object. 
//                pbErrorDisplayed: Is Error Displayed by this function
//  Returns:    
//   Note:      if Object is newly created, we directly set the value,
//                  For existing objects, get the current value of attribute and 
//                  only if its different from new value, set it.
//-----------------------------------------------------------------------------
HRESULT
SaveOneAttribute(CDialog* pDlg,
                 CBaseAz * pBaseAz,                   
                 ATTR_MAP* pAttrMap,
                 CWnd* pWnd,
                 BOOL bNewObject,
                 BOOL *pbErrorDisplayed)
{

    TRACE_FUNCTION_EX(DEB_SNAPIN,SaveOneAttribute)

    if(!pDlg || !pBaseAz || !pAttrMap || !pWnd || !pbErrorDisplayed)
    {
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        ASSERT(pbErrorDisplayed);
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    //
    //bRequired assumes that its EditBox
    //
    if(pAttrMap->bRequired)
    {
        if(!((CEdit*)pWnd)->GetWindowTextLength())
        {
            DisplayError(pDlg->m_hWnd, pAttrMap->idRequired);
            *pbErrorDisplayed = TRUE;
            SetSel(*(CEdit*)pWnd);
            return E_INVALIDARG;
        }
    }
    
    //
    //If a function is provided delegate saving to it.
    //
    PATTR_FCN pAttrFcn = pAttrMap->pAttrSaveFcn;        
    if(pAttrFcn)
    {
        hr = (*pAttrFcn)(pDlg,
                         pBaseAz,                             
                         pAttrMap,
                         FALSE, //This is ignored by save functions
                         pWnd,
                         bNewObject,
                         pbErrorDisplayed);
                              
        CHECK_HRESULT(hr);
        return hr;
    }
    


    ATTR_INFO* pAttrInfo = &(pAttrMap->attrInfo);

    switch (pAttrInfo->attrType)
    {
        case ARG_TYPE_STR:
        {
            CString strNewValue;
            CEdit* pEdit = (CEdit*)pWnd;
            pEdit->GetWindowText(strNewValue);

            if(!bNewObject)
            {
                //
                //For existing object save the attribute value only if it has
                //changed
                //
                CString strOldValue;
                hr = pBaseAz->GetProperty(pAttrInfo->ulPropId, &strOldValue);
                BREAK_ON_FAIL_HRESULT(hr);

                if(strOldValue == strNewValue)
                    break;
            }
                                    
            hr = pBaseAz->SetProperty(pAttrInfo->ulPropId, strNewValue);
            CHECK_HRESULT(hr);
            break;
        }


        case ARG_TYPE_LONG:
        {
            CString strNewValue;
            CEdit* pEdit = (CEdit*)pWnd;
            pEdit->GetWindowText(strNewValue);

            LONG lNewValue;
            if(!ConvertStringToLong(strNewValue,lNewValue,pDlg->m_hWnd))
            {
                if(pbErrorDisplayed)
                    *pbErrorDisplayed = TRUE;
                SetSel(*(CEdit*)pWnd);
                return E_INVALIDARG;
            }
            lNewValue = _wtol(strNewValue);
            if(!bNewObject)
            {
                //
                //For existing object save the attribute value only if it has
                //changed
                //
                LONG lOldValue;
                hr = pBaseAz->GetProperty(pAttrInfo->ulPropId, &lOldValue);
                BREAK_ON_FAIL_HRESULT(hr);


                if(lNewValue == lOldValue)
                    break;
            }   
            
            hr = pBaseAz->SetProperty(pAttrInfo->ulPropId, lNewValue);
            CHECK_HRESULT(hr);
            break;
        }

        case ARG_TYPE_BOOL:
        {
            BOOL bNewValue;
            CButton* pCheckBox = (CButton*)pWnd;
            bNewValue = pCheckBox->GetCheck();
            if(!bNewObject)
            {
                BOOL bOldValue;
                hr = pBaseAz->GetProperty(pAttrInfo->ulPropId, &bOldValue);
                BREAK_ON_FAIL_HRESULT(hr);


                if(bNewValue == bOldValue)
                    break;
            }
            hr = pBaseAz->SetProperty(pAttrInfo->ulPropId, bNewValue);
            CHECK_HRESULT(hr);
            break;
        }   
    }

    return hr;
}

//+----------------------------------------------------------------------------
//  Function:InitDlgFromAttrMap   
//  Synopsis:Initializes Dialog box from Attribute Map
//  Arguments:
//                pDlg: Dialog Box 
//                pAttrMap: Attribute Map
//                pBaseAz: BaseAz object corresponding to attribute map
//                bDlgReadOnly: Dialog box is in Readonly Mode
//-----------------------------------------------------------------------------
BOOL 
InitDlgFromAttrMap(IN CDialog* pDlg,
                   IN ATTR_MAP* pAttrMap,
                   IN CBaseAz* pBaseAz,
                   IN BOOL bDlgReadOnly)
{
    if(!pDlg || !pAttrMap)
    {
        ASSERT(pDlg);
        //ASSERT(pBaseAz);  //For new objects this value is null
        ASSERT(pAttrMap);
        return FALSE;       
    }

    HRESULT hr = S_OK;
    BOOL bErrorDisplayed;

    while(pAttrMap->nControlId)
    {
        
        CWnd* pWnd = pDlg->GetDlgItem(pAttrMap->nControlId);
        if(!pWnd)
        {
            ASSERT(pWnd);
            hr = E_UNEXPECTED;
            break;
        }
        

        hr = InitOneAttribute(pDlg,
                              pBaseAz,                    
                              pAttrMap,
                              bDlgReadOnly,
                              pWnd,
                              &bErrorDisplayed);

        if(FAILED(hr))
        {
            return FALSE;
        }
        pAttrMap++;
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//  Function:SaveAttrMapChanges   
//  Synopsis:Saves the attributes defined in AttrMap
//  Arguments:pDlg: Dialog box 
//                pAttrMap: Attribute Map
//                pBaseAz: BaseAz object corresponding to attribute map
//                bNewObject if the object is new created
//                pbErrorDisplayed: Is Error Displayed by this function
//                ppErrorAttrMapEntry: In case of failuer get pointer to error
//                Attribute Map Entry.
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT
SaveAttrMapChanges(IN CDialog* pDlg,
                   IN ATTR_MAP* pAttrMap,
                   IN CBaseAz* pBaseAz,                      
                   IN BOOL bNewObject,
                   OUT BOOL *pbErrorDisplayed, 
                   OUT ATTR_MAP** ppErrorAttrMap)
{   
    if(!pDlg || !pAttrMap || !pBaseAz || !pbErrorDisplayed )
    {
        ASSERT(pDlg);
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pbErrorDisplayed);
        return E_POINTER;       
    }


    HRESULT hr = S_OK;

    while(pAttrMap->nControlId)
    {
        
        CWnd* pWnd = pDlg->GetDlgItem(pAttrMap->nControlId);
        if(!pWnd)
        {
            ASSERT(pWnd);
            hr = E_UNEXPECTED;
            break;
        }

        if(pAttrMap->bReadOnly || pAttrMap->bUseForInitOnly)
        {
            ++pAttrMap;
            continue;
        }
        
        //
        //Save this attribute
        //
        hr = SaveOneAttribute(pDlg,
                              pBaseAz,
                              pAttrMap,
                              pWnd,
                              bNewObject,
                              pbErrorDisplayed);
        if(FAILED(hr))
        {
            if(ppErrorAttrMap)
                *ppErrorAttrMap = pAttrMap;
            return hr;
        }

        ++pAttrMap;
    }
    return S_OK;
}



#define CMD_TYPE void*

#define DECLARE_ATTR_FN(fnname)            \
    HRESULT fnname(CDialog *pDlg,          \
                   CBaseAz* pBaseAz,       \
                   ATTR_MAP * pAttrMap,    \
                   BOOL bDlgReadOnly,      \
                   CWnd* pWnd,             \
                   BOOL bNewObject,        \
                   BOOL *bpSilent);                

#define ATTR_MAP_ENTRY(attrType,                    \
                       ulPropId,                    \
                       ulMaxLen,                    \
                       bReadOnly,               \
                       bUsedForInitOnly,        \
                       bRequired,               \
                       idRequired,              \
                       bDefaultValue,           \
                       value,                       \
                       nControlId,              \
                       pAttrInitFcn,            \
                       pAttrSaveFcn)            \
    {{attrType,ulPropId,ulMaxLen},              \
      bReadOnly,                                        \
      bUsedForInitOnly,                             \
      bRequired,                                        \
      idRequired,                                       \
      bDefaultValue,                                    \
      value,                                                \
      nControlId,                                       \
      pAttrInitFcn,                                 \
      pAttrSaveFcn}                                         
    
#define ATTR_END_ENTRY ATTR_MAP_ENTRY(((ATTR_TYPE)0),0,0,0,0,0,0,0,0,0,0,0)

#define ATTR_NORMAL_STRING_ENTRY( ulPropId, ulMaxLen, bReadOnly, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_STR,ulPropId,ulMaxLen,bReadOnly,FALSE,FALSE,0,FALSE,0,nControlId,NULL,NULL) 

#define ATTR_NORMAL_STRING_ENTRY_WITH_INIT_FP( ulPropId, ulMaxLen, bReadOnly, nControlId, fp) \
    ATTR_MAP_ENTRY(ARG_TYPE_STR,ulPropId,ulMaxLen,bReadOnly,FALSE,FALSE,0,FALSE,0,nControlId,fp,NULL) 

#define ATTR_NORMAL_STRING_ENTRY_WITH_SAVE_FP( ulPropId, ulMaxLen, bReadOnly, nControlId, fp) \
    ATTR_MAP_ENTRY(ARG_TYPE_STR,ulPropId,ulMaxLen,bReadOnly,FALSE,FALSE,0,FALSE,0,nControlId,NULL,fp) 

#define ATTR_REQUIRED_STRING_ENTRY(ulPropId, ulMaxLen, idRequired, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_STR,ulPropId,ulMaxLen,FALSE,FALSE,TRUE,idRequired,FALSE,0,nControlId,NULL,NULL) 

#define ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(ulPropId, ulMaxLen, idRequired, nControlId, fp) \
    ATTR_MAP_ENTRY(ARG_TYPE_STR,ulPropId,ulMaxLen,FALSE,FALSE,TRUE,idRequired,FALSE,0,nControlId,NULL,fp) 

#define ATTR_STRING_ENTRY_FOR_INIT_ONLY(ulMaxLen, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_STR,0,ulMaxLen,FALSE,TRUE,FALSE,0,FALSE,0,nControlId,NULL,NULL) 



#define ATTR_NORMAL_LONG_ENTRY(ulPropId, bReadOnly, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_LONG,ulPropId,0,bReadOnly,FALSE,FALSE,0,FALSE,0,nControlId,NULL, NULL) 

#define ATTR_REQUIRED_LONG_ENTRY(ulPropId, idRequired, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_LONG,ulPropId,0,FALSE,FALSE,TRUE,idRequired,FALSE,0,nControlId,NULL,NULL) 

#define ATTR_REQUIRED_LONG_ENTRY_WITH_SAVE_FP(ulPropId, idRequired, nControlId, fp) \
    ATTR_MAP_ENTRY(ARG_TYPE_LONG,ulPropId,0,FALSE,FALSE,TRUE,idRequired,FALSE,0,nControlId,NULL,fp) 

#define ATTR_REQUIRED_LONG_ENTRY_WITH_INIT_AND_SAVE_FP(ulPropId, idRequired, nControlId, ifp,sfp) \
    ATTR_MAP_ENTRY(ARG_TYPE_LONG,ulPropId,0,FALSE,FALSE,TRUE,idRequired,FALSE,0,nControlId,ifp,sfp) 

#define ATTR_REQUIRED_LONG_ENTRY_WITH_DEFAULT(ulPropId, idRequired, lValue, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_LONG,ulPropId,0,FALSE,FALSE,TRUE,idRequired,TRUE,(CMD_TYPE)lValue,nControlId,NULL,NULL) 

#define ATTR_NORMAL_BOOL_ENTRY(ulPropId, nControlId) \
    ATTR_MAP_ENTRY(ARG_TYPE_BOOL,ulPropId, 0, FALSE,FALSE,FALSE,0,FALSE,0,nControlId,NULL,NULL) 



//Functions

DECLARE_ATTR_FN(ATTR_INIT_FN_ADMIN_MANAGER_NAME)
DECLARE_ATTR_FN(ATTR_INIT_FN_ADMIN_MANAGER_STORE_TYPE)
DECLARE_ATTR_FN(ATTR_SAVE_FN_NAME)
DECLARE_ATTR_FN(ATTR_INIT_FN_GROUP_TYPE)
DECLARE_ATTR_FN(ATTR_SAVE_FN_OPERATION_ID)
DECLARE_ATTR_FN(ATTR_SAVE_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT)
DECLARE_ATTR_FN(ATTR_INIT_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT)
DECLARE_ATTR_FN(ATTR_SAVE_FN_ADMIN_MANAGER_LDAP_QUERY_TIMEOUT)

#define ATTR_DESCRIPTION \
    ATTR_NORMAL_STRING_ENTRY(AZ_PROP_DESCRIPTION,AZ_MAX_DESCRIPTION_LENGTH,FALSE,IDC_EDIT_DESCRIPTION)          

//
//ADMIN_MANAGER General Property page entry
//
#define ATTR_ADMIN_MANAGER_NAME                                                 \
    ATTR_NORMAL_STRING_ENTRY_WITH_INIT_FP(AZ_PROP_NAME,                 \
                                          AZ_MAX_POLICY_URL_LENGTH,                                 \
                                          TRUE,                             \
                                          IDC_EDIT_NAME,                    \
                                          ATTR_INIT_FN_ADMIN_MANAGER_NAME)              

#define ATTR_ADMIN_MANAGER_STORE_TYPE                                                   \
    ATTR_NORMAL_STRING_ENTRY_WITH_INIT_FP(AZ_PROP_NAME,                         \
                                                      0,                                            \
                                                      TRUE,                                     \
                                                      IDC_EDIT_STORE_TYPE,                  \
                                                      ATTR_INIT_FN_ADMIN_MANAGER_STORE_TYPE)                


ATTR_MAP ATTR_MAP_ADMIN_MANAGER_GENERAL_PROPERTY[] =
{
    ATTR_ADMIN_MANAGER_NAME,
    ATTR_DESCRIPTION,
    ATTR_ADMIN_MANAGER_STORE_TYPE,
    ATTR_END_ENTRY,
};

//
//ADMIN_MANAGER new/open dialog entry
//
#define ATTR_NEW_ADMIN_MANAGER_NAME                                                 \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_POLICY_URL_LENGTH,                       \
                                    IDC_EDIT_NAME)              


#define ATTR_NEW_ADMIN_MANAGER_DESC                                                 \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_DESCRIPTION_LENGTH,                      \
                                    IDC_EDIT_NAME)              

ATTR_MAP ATTR_MAP_NEW_ADMIN_MANAGER[] =
{
    ATTR_NEW_ADMIN_MANAGER_NAME,
    ATTR_NEW_ADMIN_MANAGER_DESC,
    ATTR_END_ENTRY,
};

ATTR_MAP ATTR_MAP_OPEN_ADMIN_MANAGER[] =
{
    ATTR_NEW_ADMIN_MANAGER_NAME,
    ATTR_END_ENTRY,
};

//
//ADMIN_MANAGER Advanced Property Page
//
#define ATTR_ADMIN_MANAGER_DOMAIN_TIMEOUT   \
    ATTR_REQUIRED_LONG_ENTRY_WITH_SAVE_FP(AZ_PROP_AZSTORE_DOMAIN_TIMEOUT,     \
                                          IDS_DOMAIN_TIMEOUT_REQUIRED,      \
                                          IDC_EDIT_DOMAIN_TIMEOUT,          \
                                          ATTR_SAVE_FN_ADMIN_MANAGER_LDAP_QUERY_TIMEOUT) 


#define ATTR_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT    \
    ATTR_REQUIRED_LONG_ENTRY_WITH_INIT_AND_SAVE_FP(AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT,     \
                                                  IDS_SCRIPT_ENGINE_TIMEOUT_REQUIRED,       \
                                                  IDC_EDIT_SCRIPT_ENGINE_TIMEOUT,           \
                                                  ATTR_INIT_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT,  \
                                                  ATTR_SAVE_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT) 

#define ATTR_ADMIN_MANAGER_MAX_SCRIPT_ENGINES   \
    ATTR_REQUIRED_LONG_ENTRY(AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES,      \
                             IDS_MAX_SCRIPT_ENGINES_REQUIRED,       \
                             IDC_EDIT_MAX_SCRIPT_ENGINE) 

ATTR_MAP ATTR_MAP_ADMIN_MANAGER_ADVANCED_PROPERTY[] =
{
    ATTR_ADMIN_MANAGER_DOMAIN_TIMEOUT,
    ATTR_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT,
    ATTR_ADMIN_MANAGER_MAX_SCRIPT_ENGINES,
    ATTR_END_ENTRY,
};


//
//APPLICATION General Property Page Entry
//
#define ATTR_APPLICATION_NAME                                                       \
    ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(AZ_PROP_NAME,                                   \
                                                      AZ_MAX_APPLICATION_NAME_LENGTH,           \
                                                      IDS_NAME_REQUIRED,                            \
                                                      IDC_EDIT_NAME,                                \
                                                      ATTR_SAVE_FN_NAME)


#define ATTR_APPLICATION_VERSION                                    \
    ATTR_NORMAL_STRING_ENTRY(AZ_PROP_APPLICATION_VERSION,           \
                             AZ_MAX_APPLICATION_VERSION_LENGTH,     \
                             FALSE,                         \
                             IDC_EDIT_VERSION)              


ATTR_MAP ATTR_MAP_APPLICATION_GENERAL_PROPERTY[] =
{
    ATTR_APPLICATION_NAME,
    ATTR_DESCRIPTION,
    ATTR_APPLICATION_VERSION,
    ATTR_END_ENTRY,
};

//
//New Application  Dlg Map 
//
#define ATTR_NEW_APPLICATION_NAME                                                   \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_APPLICATION_NAME_LENGTH,                     \
                                    IDC_EDIT_NAME)              


ATTR_MAP ATTR_MAP_NEW_APPLICATION[] =
{
    ATTR_NEW_APPLICATION_NAME,
    ATTR_DESCRIPTION,
    ATTR_APPLICATION_VERSION,
    ATTR_END_ENTRY,
};

//
//Scope General Property Page Entry
//
#define ATTR_SCOPE_NAME                                             \
    ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(AZ_PROP_NAME,                       \
                                                     AZ_MAX_SCOPE_NAME_LENGTH,      \
                                                     IDS_NAME_REQUIRED,                 \
                                                  IDC_EDIT_NAME,                        \
                                                      ATTR_SAVE_FN_NAME)                    

ATTR_MAP ATTR_MAP_SCOPE_GENERAL_PROPERTY[] =
{
    ATTR_SCOPE_NAME,
    ATTR_DESCRIPTION,
    ATTR_END_ENTRY,
};

//
//New SCOPE  Dlg Map 
//
#define ATTR_NEW_SCOPE_NAME                                                 \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_SCOPE_NAME_LENGTH,                       \
                                    IDC_EDIT_NAME)              


ATTR_MAP ATTR_MAP_NEW_SCOPE[] =
{
    ATTR_NEW_SCOPE_NAME,
    ATTR_DESCRIPTION,
    ATTR_END_ENTRY,
};



//
//Group General Property Page Entry
//
#define ATTR_GROUP_NAME                                             \
    ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(AZ_PROP_NAME,                       \
                                                     AZ_MAX_GROUP_NAME_LENGTH,      \
                                                     IDS_NAME_REQUIRED,                 \
                                                  IDC_EDIT_NAME,                        \
                                                      ATTR_SAVE_FN_NAME)                    

#define ATTR_GROUP_TYPE                                                 \
    ATTR_NORMAL_STRING_ENTRY_WITH_INIT_FP(AZ_PROP_GROUP_TYPE,                   \
                                          0,                                            \
                                          TRUE,                                     \
                                          IDC_EDIT_GROUP_TYPE,                  \
                                          ATTR_INIT_FN_GROUP_TYPE)              

ATTR_MAP ATTR_MAP_GROUP_GENERAL_PROPERTY[] =
{
    ATTR_GROUP_NAME,
    ATTR_DESCRIPTION,
    ATTR_GROUP_TYPE,
    ATTR_END_ENTRY,
};

//
//New GROUP  Dlg Map 
//
#define ATTR_NEW_GROUP_NAME                                                 \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_GROUP_NAME_LENGTH,                       \
                                    IDC_EDIT_NAME)              


ATTR_MAP ATTR_MAP_NEW_GROUP[] =
{
    ATTR_NEW_GROUP_NAME,
    ATTR_DESCRIPTION,
    ATTR_END_ENTRY,
};

//
//Group LDAP Query Property Page Entry
//
#define ATTR_GROUP_LDAP_QUERY                                           \
    ATTR_NORMAL_STRING_ENTRY(AZ_PROP_GROUP_LDAP_QUERY,          \
                                     AZ_MAX_GROUP_LDAP_QUERY_LENGTH,    \
                                     FALSE,                                 \
                                     IDC_EDIT_LDAP_QUERY)           

ATTR_MAP ATTR_MAP_GROUP_QUERY_PROPERTY[] =
{
    ATTR_GROUP_LDAP_QUERY,
    ATTR_END_ENTRY,
};

//
//Task General Property Page Entry
//
#define ATTR_TASK_NAME                                              \
    ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(AZ_PROP_NAME,                       \
                                                     AZ_MAX_TASK_NAME_LENGTH,       \
                                                     IDS_NAME_REQUIRED,                 \
                                                  IDC_EDIT_NAME,                        \
                                                      ATTR_SAVE_FN_NAME)                    

ATTR_MAP ATTR_MAP_TASK_GENERAL_PROPERTY[] =
{
    ATTR_TASK_NAME,
    ATTR_DESCRIPTION,
    ATTR_END_ENTRY,
};

//
//New TASK  Dlg Map 
//
#define ATTR_NEW_TASK_NAME                                                  \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_TASK_NAME_LENGTH,                        \
                                    IDC_EDIT_NAME)              


ATTR_MAP ATTR_MAP_NEW_TASK[] =
{
    ATTR_NEW_TASK_NAME,
    ATTR_DESCRIPTION,
    ATTR_END_ENTRY,
};

//
//Role General Property Page
//
#define ATTR_ROLE_NAME                                              \
    ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(AZ_PROP_NAME,                       \
                                            AZ_MAX_ROLE_NAME_LENGTH,        \
                                            IDS_NAME_REQUIRED,                  \
                                            IDC_EDIT_NAME,                      \
                                            ATTR_SAVE_FN_NAME)                  

ATTR_MAP ATTR_MAP_ROLE_GENERAL_PROPERTY[] =
{
    ATTR_ROLE_NAME,
    ATTR_DESCRIPTION,
    ATTR_END_ENTRY,
};


//
//Operation General Property Page Entry
//
#define ATTR_OPERATION_NAME                                             \
    ATTR_REQUIRED_STRING_ENTRY_WITH_SAVE_FP(AZ_PROP_NAME,                       \
                                                       AZ_MAX_OPERATION_NAME_LENGTH,        \
                                                       IDS_NAME_REQUIRED,                   \
                                                    IDC_EDIT_NAME,                      \
                                                        ATTR_SAVE_FN_NAME)                  

#define ATTR_OPERATION_ID                                                                           \
    ATTR_REQUIRED_LONG_ENTRY_WITH_SAVE_FP(AZ_PROP_OPERATION_ID,                         \
                                                     IDS_OPERATION_ID_REQUIRED,                 \
                                                  IDC_EDIT_OPERATION_NUMBER,                    \
                                                      ATTR_SAVE_FN_OPERATION_ID)                    


ATTR_MAP ATTR_MAP_OPERATION_GENERAL_PROPERTY[] =
{
    ATTR_OPERATION_NAME,
    ATTR_DESCRIPTION,
    ATTR_OPERATION_ID,
    ATTR_END_ENTRY,
};

//
//New Operation  Dlg Map 
//
#define ATTR_NEW_OPERATION_NAME                                                 \
    ATTR_STRING_ENTRY_FOR_INIT_ONLY(AZ_MAX_OPERATION_NAME_LENGTH,                       \
                                    IDC_EDIT_NAME)              


ATTR_MAP ATTR_MAP_NEW_OPERATION[] =
{
    ATTR_NEW_OPERATION_NAME,
    ATTR_DESCRIPTION,
    ATTR_OPERATION_ID,
    ATTR_END_ENTRY,
};


//
//Script Dialog
//
#define ATTR_SCRIPT_CODE                                            \
    ATTR_NORMAL_STRING_ENTRY(AZ_PROP_TASK_BIZRULE,          \
                                     AZ_MAX_TASK_BIZRULE_LENGTH,    \
                                     TRUE,                              \
                                     IDC_EDIT_CODE)         

#define ATTR_SCRIPT_PATH                                            \
    ATTR_NORMAL_STRING_ENTRY(AZ_PROP_TASK_BIZRULE_IMPORTED_PATH,            \
                                     AZ_MAX_TASK_BIZRULE_IMPORTED_PATH_LENGTH,  \
                                     FALSE,                             \
                                     IDC_EDIT_PATH)         

ATTR_MAP ATTR_MAP_SCRIPT_DIALOG[] =
{
    ATTR_SCRIPT_CODE,
    ATTR_SCRIPT_PATH,
    ATTR_END_ENTRY,
};



HRESULT 
ATTR_INIT_FN_ADMIN_MANAGER_NAME(CDialog* /*pDlg*/,
                                CBaseAz* pBaseAz, 
                                ATTR_MAP * pAttrMap,
                                BOOL /*bDlgReadOnly*/,
                                CWnd* pWnd,
                                BOOL /*bNewObject*/,
                                BOOL*)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_INIT_FN_ADMIN_MANAGER_NAME)

    if(!pBaseAz || !pAttrMap || !pWnd)
    {
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        return E_POINTER;
    }

    CString strName = pBaseAz->GetName();
    CEdit *pEdit = (CEdit*)pWnd;

    pEdit->SetWindowText(strName);
    pEdit->SetReadOnly(TRUE);
    pEdit->SetLimitText(pAttrMap->attrInfo.ulMaxLen);
    
    return S_OK;
}

HRESULT 
ATTR_INIT_FN_ADMIN_MANAGER_STORE_TYPE(CDialog* /*pDlg*/,
                                      CBaseAz* pBaseAz, 
                                      ATTR_MAP * pAttrMap,
                                      BOOL /*bDlgReadOnly*/,
                                      CWnd* pWnd,
                                      BOOL /*bNewObject*/,
                                      BOOL*)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_INIT_FN_ADMIN_MANAGER_STORE_TYPE)
    if(!pBaseAz || !pAttrMap || !pWnd)
    {
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        return E_POINTER;
    }

    CAdminManagerAz* pAdminManagerAz = dynamic_cast<CAdminManagerAz*>(pBaseAz);
    if(!pAdminManagerAz)
    {
        ASSERT(pAdminManagerAz);
        return E_UNEXPECTED;
    }

    //Set Store Type    
    ULONG ulStoreType = pAdminManagerAz->GetStoreType();
    CEdit* pEditStoreType = (CEdit*)pWnd;
    CString strStoreType;
    strStoreType.LoadString((ulStoreType == AZ_ADMIN_STORE_XML) ? IDS_SCOPE_TYPE_XML:IDS_SCOPE_TYPE_AD);
    pEditStoreType->SetWindowText(strStoreType);
    pEditStoreType->SetReadOnly(TRUE);

    return S_OK;
}

HRESULT 
ATTR_SAVE_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT(CDialog* pDlg,
                                                 CBaseAz* pBaseAz, 
                                                 ATTR_MAP * pAttrMap,
                                                 BOOL /*bDlgReadOnly*/,
                                                 CWnd* pWnd,
                                                 BOOL /*bNewObject*/,
                                                 BOOL* pbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_SAVE_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT)

    if(!pDlg || !pBaseAz || !pAttrMap || !pWnd || !pbErrorDisplayed)
    {
        ASSERT(pDlg);
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        ASSERT(pbErrorDisplayed);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    
    //Get new value of authorization script
    LONG lNewValue = 0;
    //Authorization script is disabled
    if( ((CButton*)(pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_DISABLED)))->GetCheck() == BST_CHECKED)
    {
        lNewValue = 0;
    }
    //Authorization script is enabled with no timeout value.
    else if( ((CButton*)(pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT)))->GetCheck() == BST_CHECKED)
    {
        lNewValue = -1;
    }        
    //Authorization script is enabled with timeout
    else if( ((CButton*)(pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT)))->GetCheck() == BST_CHECKED)
    {
        if(!GetLongValue((*(CEdit*)pWnd), lNewValue,pDlg->m_hWnd))
        {
            SetSel(*(CEdit*)pWnd);
            *pbErrorDisplayed = TRUE;
            return E_INVALIDARG;
        }
    }

        
    LONG lOldValue = 0;
    hr = pBaseAz->GetProperty(pAttrMap->attrInfo.ulPropId,&lOldValue);
    if(FAILED(hr))
    {
        return hr;
    }

    if(lNewValue == lOldValue)
        return S_OK;

    if(lNewValue != 0 && lNewValue != -1)
    {
        //
        //There is a minimum for scipt engine timeout
        //
        if(lNewValue < AZ_AZSTORE_MIN_SCRIPT_ENGINE_TIMEOUT)
        {
            DisplayError(pDlg->m_hWnd,
                        IDS_ADMIN_MIN_SCRIPT_ENGINE_TIMEOUT,
                        lNewValue,
                        AZ_AZSTORE_MIN_SCRIPT_ENGINE_TIMEOUT);
        
            SetSel(*(CEdit*)pWnd);

            *pbErrorDisplayed = TRUE;
            return E_INVALIDARG;
        }
    }
    
    hr = pBaseAz->SetProperty(pAttrMap->attrInfo.ulPropId,lNewValue);
    return hr;
}

HRESULT 
ATTR_INIT_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT(CDialog* pDlg,
                                                 CBaseAz* pBaseAz, 
                                                 ATTR_MAP * pAttrMap,
                                                 BOOL bDlgReadOnly,
                                                 CWnd* pWnd,
                                                 BOOL /*bNewObject*/,
                                                 BOOL* pbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_SAVE_FN_ADMIN_MANAGER_SCRIPT_ENGINE_TIMEOUT)

    if(!pDlg || !pBaseAz || !pAttrMap || !pWnd || !pbErrorDisplayed)
    {
        ASSERT(pDlg);
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        ASSERT(pbErrorDisplayed);
        return E_POINTER;
    }


    //Get Authorization Script timeout value
    LONG lAuthScriptTimout = 0;
    HRESULT hr = pBaseAz->GetProperty(pAttrMap->attrInfo.ulPropId,&lAuthScriptTimout);
    if(FAILED(hr))
    {
        return hr;
    }

    //Script timeout is infinite
    if(-1 == lAuthScriptTimout)
    {
        ((CButton*)pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT))->SetCheck(BST_CHECKED);
        //Disabel autorization script timeout textbox and set text to infinite
        CString strInfinite;
        VERIFY(strInfinite.LoadString(IDS_INFINITE));
        ((CEdit*)pWnd)->SetWindowText(strInfinite);
        pWnd->EnableWindow(FALSE);
    }
    else
    {
        SetLongValue((CEdit*)pWnd,lAuthScriptTimout);
        
        //Script is disabled
        if(0 == lAuthScriptTimout)
        {
            ((CButton*)pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_DISABLED))->SetCheck(BST_CHECKED);

            //Disable max script engine textbox
            (pDlg->GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE))->EnableWindow(FALSE);
            //Disable autorization script timeout textbox
            pWnd->EnableWindow(FALSE);
        }
        else
        {
            ((CButton*)pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT))->SetCheck(BST_CHECKED);
        }
    }

    if(bDlgReadOnly)
    {
        pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_DISABLED)->EnableWindow(FALSE);
        pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT)->EnableWindow(FALSE);
        pDlg->GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT)->EnableWindow(FALSE);
        ((CEdit*)pWnd)->SetReadOnly();
    }

    return hr;
}

HRESULT 
ATTR_SAVE_FN_ADMIN_MANAGER_LDAP_QUERY_TIMEOUT(CDialog* pDlg,
                                              CBaseAz* pBaseAz, 
                                              ATTR_MAP * pAttrMap,
                                              BOOL /*bDlgReadOnly*/,
                                              CWnd* pWnd,
                                              BOOL /*bNewObject*/,
                                              BOOL* pbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_SAVE_FN_ADMIN_MANAGER_LDAP_QUERY_TIMEOUT)

    if(!pDlg || !pBaseAz || !pAttrMap || !pWnd || !pbErrorDisplayed)
    {
        ASSERT(pDlg);
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        ASSERT(pbErrorDisplayed);
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    LONG lNewValue = 0;
    if(!GetLongValue((*(CEdit*)pWnd), lNewValue,pDlg->m_hWnd))
    {
        pWnd->SetFocus();
        SetSel(*(CEdit*)pWnd);
        *pbErrorDisplayed = TRUE;
        return E_INVALIDARG;
    }
        
    LONG lOldValue = 0;
    hr = pBaseAz->GetProperty(pAttrMap->attrInfo.ulPropId,&lOldValue);
    if(FAILED(hr))
    {
        return hr;
    }

    if(lNewValue == lOldValue)
        return S_OK;

    //
    //There is a minimum for scipt engine timeout
    //
    if(lNewValue < AZ_AZSTORE_MIN_DOMAIN_TIMEOUT)
    {
        DisplayError(pDlg->m_hWnd,
                         IDS_MIN_QUERY_TIMEOUT,
                         lNewValue,
                         AZ_AZSTORE_MIN_DOMAIN_TIMEOUT);

        *pbErrorDisplayed = TRUE;
        SetSel(*(CEdit*)pWnd);
        return E_INVALIDARG;
    }
    
    hr = pBaseAz->SetProperty(pAttrMap->attrInfo.ulPropId,lNewValue);
    return hr;
}

HRESULT 
ATTR_SAVE_FN_NAME(CDialog* pDlg,
                  CBaseAz* pBaseAz, 
                  ATTR_MAP * pAttrMap,
                  BOOL /*bDlgReadOnly*/,
                  CWnd* pWnd,
                  BOOL /*bNewObject*/,
                  BOOL* pbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_SAVE_FN_NAME)

    if(!pDlg || !pBaseAz || !pAttrMap || !pWnd)
    {
        ASSERT(pDlg);
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        return E_POINTER;
    }

    CString strNewName;
    ((CEdit*)pWnd)->GetWindowText(strNewName);

    CString strOldName = pBaseAz->GetName();

    if(strOldName == strNewName)
        return S_OK;

    HRESULT hr = pBaseAz->SetName(strNewName);

    if(FAILED(hr))
    {
        ErrorMap * pErrorMap = GetErrorMap(pBaseAz->GetObjectType());
        if(!pErrorMap)
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }

        if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        {
            if((pBaseAz->GetObjectType() == TASK_AZ) && ((CTaskAz*)pBaseAz)->IsRoleDefinition())
            {
                ::DisplayError(pDlg->m_hWnd,IDS_ROLE_DEFINITION_NAME_EXIST,strNewName);
            }           
            else
            {
                ::DisplayError(pDlg->m_hWnd,pErrorMap->idNameAlreadyExist,strNewName);
            }
            *pbErrorDisplayed = TRUE;
        }
        if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_NAME))
        {
            ::DisplayError(pDlg->m_hWnd,pErrorMap->idInvalidName,pErrorMap->pszInvalidChars);
            *pbErrorDisplayed = TRUE;
        }
    }

    return hr;
}


HRESULT 
ATTR_INIT_FN_GROUP_TYPE(CDialog* /*pDlg*/,
                        CBaseAz* pBaseAz, 
                        ATTR_MAP * pAttrMap,
                        BOOL /*bDlgReadOnly*/,
                        CWnd* pWnd,
                        BOOL /*bNewObject*/,
                        BOOL*)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_INIT_FN_GROUP_TYPE)
    if(!pBaseAz || !pAttrMap || !pWnd)
    {
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        return E_POINTER;
    }

    CGroupAz* pGroupAz = dynamic_cast<CGroupAz*>(pBaseAz);
    if(!pGroupAz)
    {
        ASSERT(pGroupAz);
        return E_UNEXPECTED;
    }

    //Get Store Type    
    LONG lGroupType;
    HRESULT hr = pGroupAz->GetGroupType(&lGroupType);
    if(FAILED(hr))
    {
        return hr;
    }
    
    CEdit* pEditGroupType = (CEdit*)pWnd;
    CString strGroupType;
    strGroupType.LoadString((lGroupType == AZ_GROUPTYPE_LDAP_QUERY) ? IDS_TYPE_LDAP_GROUP:IDS_TYPE_BASIC_GROUP);
    pEditGroupType->SetWindowText(strGroupType);
    pEditGroupType->SetReadOnly(TRUE);

    return S_OK;
}


HRESULT 
ATTR_SAVE_FN_OPERATION_ID(CDialog* pDlg,
                          CBaseAz* pBaseAz, 
                          ATTR_MAP * pAttrMap,
                          BOOL /*bDlgReadOnly*/,
                          CWnd* pWnd,
                          BOOL bNewObject,
                          BOOL* pbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ATTR_SAVE_FN_OPERATION_ID)
    if(!pDlg || !pBaseAz || !pAttrMap || !pWnd)
    {
        ASSERT(pDlg);
        ASSERT(pBaseAz);
        ASSERT(pAttrMap);
        ASSERT(pWnd);
        return E_POINTER;
    }

    
    COperationAz* pOperationAz = dynamic_cast<COperationAz*>(pBaseAz);
    if(!pOperationAz)
    {
        ASSERT(pOperationAz);
        return E_UNEXPECTED;
    }
    

    //Get new Operation ID
    LONG lNewOperationId = 0;
    if(!GetLongValue((*(CEdit*)pWnd), lNewOperationId,pDlg->m_hWnd))
    {
        SetSel(*(CEdit*)pWnd);
        *pbErrorDisplayed = TRUE;
        return E_INVALIDARG;
    }

    if(bNewObject)
    {
        LONG lOldOperationId = 0;
        HRESULT hr = pOperationAz->GetProperty(AZ_PROP_OPERATION_ID,&lOldOperationId);
        if(FAILED(hr))
        {
            return hr;
        }


        if(lNewOperationId == lOldOperationId)
            return S_OK;
    }

    HRESULT hr = pOperationAz->SetProperty(AZ_PROP_OPERATION_ID,lNewOperationId);

    if(FAILED(hr))
    {
        if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        {
            CString strOperationId;
            ((CEdit*)pWnd)->GetWindowText(strOperationId);
            ::DisplayError(pDlg->m_hWnd,
                           IDS_ERROR_OPERATION_ID_EXISTS,
                           strOperationId);
            *pbErrorDisplayed = TRUE;
            SetSel(*(CEdit*)pWnd);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\baseaz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       baseaz.cpp
//
//  Contents:   Implementation of Base Classes for AzObjects 
//
//  History:    09-01
//
//----------------------------------------------------------------------------
#include "headers.h"

/******************************************************************************
Class:  CBaseAz
Purpose: This is the base class for all AzObject classes.
******************************************************************************/
CString 
CBaseAz::
GetParentType()
{
    if(m_pParentContainerAz)
    {
        return m_pParentContainerAz->GetType();
    }
    //m_pParentContainerAz will be null for AdminManagerAz in which
    //case return the Type of the store
    return GetType();
}

CSidHandler*
CBaseAz::
GetSidHandler()
{
    //m_pParentContainerAz == NULL only for CAdminManagerAz which 
    //overrides this method. 
    ASSERT(m_pParentContainerAz);
    return m_pParentContainerAz->GetSidHandler();
}

CAdminManagerAz*
CBaseAz::
GetAdminManager()
{
    //m_pParentContainerAz == NULL only for CAdminManagerAz which 
    //overrides this method. 
    ASSERT(m_pParentContainerAz);
    return m_pParentContainerAz->GetAdminManager();
}

HRESULT
CBaseAz::IsWritable(BOOL& bRefWrite)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseAz,IsWritable)
    return GetProperty(AZ_PROP_WRITABLE, &bRefWrite);
}
/******************************************************************************
Class:  CContainerAz
Purpose: AdminManagerAz, ApplicationAz and ScopeAz can contain child objects.
            All of them can contain group objects. CContainerAz is base class
            for all AzObjects which are container
******************************************************************************/


HRESULT 
CContainerAz::
CanCreateChildObject(BOOL& bCahCreateChild)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAz,CanCreateChildObject)
    return GetProperty(AZ_PROP_CHILD_CREATE, &bCahCreateChild);
}

BOOL
CContainerAz::
IsAuditingSupported()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAz,IsAuditingSupported)

    BOOL bVal = 0;
    HRESULT hr = GetProperty(AZ_PROP_GENERATE_AUDITS,&bVal);
    CHECK_HRESULT(hr);
    HRESULT hr1 = GetProperty(AZ_PROP_APPLY_STORE_SACL,&bVal);
    CHECK_HRESULT(hr1);

    return (SUCCEEDED(hr) || SUCCEEDED(hr1));
}

//+----------------------------------------------------------------------------
//  Function:IsDelegatorSupported   
//  Synopsis:Checks if Container Supports delegator property   
//-----------------------------------------------------------------------------
BOOL
CContainerAz::
IsDelegatorSupported()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CContainerAz,IsDelegatorSupported)

    //Delegator Property is supported For AD Application,
    //AdminManager objects
    if(GetAdminManager()->GetStoreType() == AZ_ADMIN_STORE_AD)
    {
        if(GetObjectType() == ADMIN_MANAGER_AZ ||
           GetObjectType() == APPLICATION_AZ)
           return TRUE;
    }

    return FALSE;
}



/******************************************************************************
Class:  CAdminManagerAz
Purpose: class for IAzAdminManager interface
******************************************************************************/

DEBUG_DECLARE_INSTANCE_COUNTER(CAdminManagerAz);

CAdminManagerAz::
CAdminManagerAz(CComPtr<IAzAuthorizationStore>& spAzInterface)
                     :CContainerAzImpl<IAzAuthorizationStore>(spAzInterface,
                                                                    ADMIN_MANAGER_AZ,
                                                                    NULL),
                                                                    m_pSidHandler(NULL)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CAdminManagerAz);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CAdminManagerAz);
    SetType(IDS_TYPE_ADMIN_MANAGER);
}

CAdminManagerAz::~CAdminManagerAz()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CAdminManagerAz);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAdminManagerAz);
    if(m_pSidHandler)
        delete m_pSidHandler;
}

HRESULT
CAdminManagerAz::
UpdateCache()
{
    HRESULT hr = m_spAzInterface->UpdateCache(CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}

HRESULT
CAdminManagerAz::
DeleteSelf()
{
    HRESULT hr = m_spAzInterface->Delete(CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}

HRESULT
CAdminManagerAz::
CreateSidHandler(const CString& strTargetComputerName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,CreateSidHandler)

    CMachineInfo * pMachineInfo = new CMachineInfo();
    if(!pMachineInfo)
        return E_OUTOFMEMORY;

    pMachineInfo->InitializeMacineConfiguration(strTargetComputerName);

    m_pSidHandler = new CSidHandler(pMachineInfo);
    if(!m_pSidHandler)
    {
        delete pMachineInfo;
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   Initialize
//  Synopsis:   Associates IAzAuthorizationStore to a policy store
//  Arguments:  IN lStoreType   
//                   IN lFlags
//                   IN strPolicyURL
//                   See IAzAuthorizationStore for desc of Parameters
//  Returns:    hr
//-----------------------------------------------------------------------------
HRESULT CAdminManagerAz::Initialize(IN ULONG lStoreType,
                                    IN ULONG lFlags,
                                    IN const CString& strPolicyURL)
{

    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,Initialize)
    
    if(strPolicyURL.IsEmpty())
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    do
    {
        CString strFormalStoreName;
        //Get the formal Store Name
        NameToStoreName(lStoreType,
                        strPolicyURL,
                        FALSE,
                        strFormalStoreName);

        Dbg(DEB_SNAPIN, "lStoreType = %u, storeName = %ws, formalStoreName = %ws\n",lStoreType,(LPCWSTR)strPolicyURL,(LPCWSTR)strFormalStoreName );

        //Snapin always calls initailize in Manage Store mode
        lFlags |= AZ_AZSTORE_FLAG_MANAGE_STORE_ONLY;

        CComBSTR bstr = strFormalStoreName;
        hr = m_spAzInterface->Initialize(lFlags, 
                                         bstr,
                                         CComVariant());
        BREAK_ON_FAIL_HRESULT(hr);

        //Submit if creating new store
        if(lFlags & AZ_AZSTORE_FLAG_CREATE)
        {
            hr = Submit();
            BREAK_ON_FAIL_HRESULT(hr);
        }
    
        m_strPolicyURL = strPolicyURL;
        GetDisplayNameFromStoreURL(strFormalStoreName,m_strAdminManagerName);
        m_ulStoreType = lStoreType;

        //
        //Create the Sid Handler for the store
        //
        CComBSTR bstrTargetMachineName;
        HRESULT hr1 = m_spAzInterface->get_TargetMachine(&bstrTargetMachineName);
        CString strMachineName;
        if(SUCCEEDED(hr1) && (bstrTargetMachineName.Length() != 0))
        {
            strMachineName = bstrTargetMachineName;
        }
        hr = CreateSidHandler(strMachineName);
        BREAK_ON_FAIL_HRESULT(hr);

    
    }while(0);
    
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   OpenPolicyStore
//  Synopsis:   Open an existing policy store
//-----------------------------------------------------------------------------

HRESULT 
CAdminManagerAz::OpenPolicyStore(IN ULONG lStoreType,
                                            IN const CString& strPolicyURL)
{   
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,OpenPolicyStore)
    return Initialize(lStoreType, 0, strPolicyURL);
}


//+----------------------------------------------------------------------------
//  Function:   CreatePolicyStore
//  Synopsis:   Creates a new policy store
//-----------------------------------------------------------------------------
HRESULT 
CAdminManagerAz::CreatePolicyStore(IN ULONG lStoreType,
                                              IN const CString& strPolicyURL)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,OpenPolicyStore)
    return Initialize(lStoreType, AZ_AZSTORE_FLAG_CREATE, strPolicyURL);
}

//+----------------------------------------------------------------------------
//  Function:CreateApplication   
//  Synopsis:Create a new application  
//  Arguments:IN strApplicationName: Name of new application
//                OUT ppApplicationAz  : receives pointer to CApplicatioAz for new 
//                                               app
//----------------------------------------------------------------------------- 
HRESULT 
CAdminManagerAz::CreateApplication(IN const CString& strApplicationName,
                                              OUT CApplicationAz ** ppApplicationAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz, CreateApplication); 

    if(!ppApplicationAz)
    {
        ASSERT(ppApplicationAz);
        return E_POINTER;
    }
    

    HRESULT hr = S_OK;
    CComPtr<IAzApplication> spAzApplication;
    
    CComBSTR bstr = strApplicationName;
    hr = m_spAzInterface->CreateApplication(bstr,
                                                        CComVariant(),
                                                        &spAzApplication);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *ppApplicationAz = new CApplicationAz(spAzApplication,
                                                      this);
    if(!*ppApplicationAz)
    {
        return E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT 
CAdminManagerAz::DeleteApplication(const CString& strApplicationName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz, DeleteApplication); 

    HRESULT hr = S_OK;
    
    CComBSTR bstr = strApplicationName;
    hr = m_spAzInterface->DeleteApplication(bstr, CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}

HRESULT 
CAdminManagerAz::
GetApplicationCollection(APPLICATION_COLLECTION** ppApplicationCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,GetApplicationCollection)

        if(!ppApplicationCollection)
    {
        ASSERT(ppApplicationCollection);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    CComPtr<IAzApplications> spAzApplications;
    hr = m_spAzInterface->get_Applications(&spAzApplications);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    //Create AppCollection
    *ppApplicationCollection = 
            new APPLICATION_COLLECTION(spAzApplications,
                                                this);

    if(!*ppApplicationCollection)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    return hr;
}


HRESULT 
CAdminManagerAz::
CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                    IN const CString& strName, 
                    OUT CBaseAz** ppBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,CreateAzObject)
    if(!ppBaseAz)
    {
        ASSERT(ppBaseAz);
        return E_POINTER;
    }
    
    switch (eObjectType)
    {
        case APPLICATION_AZ:
        {
            return CreateApplication(strName, reinterpret_cast<CApplicationAz**>(ppBaseAz));            
        }
        case GROUP_AZ:
        {
            return CreateGroup(strName, reinterpret_cast<CGroupAz**>(ppBaseAz));            
        }       
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT 
CAdminManagerAz::
OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
              IN const CString& strName,
              OUT CBaseAz** ppBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,OpenObject)

    if(!ppBaseAz)
    {
        ASSERT(ppBaseAz);
        return E_POINTER;
    }
    switch (eObjectType)
    {
        case GROUP_AZ:
        {
            return OpenGroup(strName, reinterpret_cast<CGroupAz**>(ppBaseAz));          
        }       
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT 
CAdminManagerAz::
DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                    IN const CString& strName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAz,DeleteAzObject)
    switch (eObjectType)
    {
        case APPLICATION_AZ:
        {
            return DeleteApplication(strName);
        }
        case GROUP_AZ:
        {
            return DeleteGroup(strName);            
        }       
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT
CAdminManagerAz::
GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                             OUT CBaseAzCollection **ppBaseAzCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,GetAzObjectCollection)
    if(!ppBaseAzCollection)
    {
        ASSERT(ppBaseAzCollection);
        return E_POINTER;
    }

    switch (eObjectType)
    {
        case APPLICATION_AZ:
        {
            return GetApplicationCollection(reinterpret_cast<APPLICATION_COLLECTION**>(ppBaseAzCollection));            
        }
        case GROUP_AZ:
        {
            return GetGroupCollection(reinterpret_cast<GROUP_COLLECTION**>(ppBaseAzCollection));            
        }
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}



/******************************************************************************
Class:  CApplicationAz
Purpose: class for IAzApplication interface
******************************************************************************/

DEBUG_DECLARE_INSTANCE_COUNTER(CApplicationAz)

CApplicationAz::
CApplicationAz(IN CComPtr<IAzApplication>& spAzInterface,
                    IN CContainerAz* pParentContainerAz)
                    :CRoleTaskContainerAzImpl<IAzApplication>(spAzInterface,
                                                                            APPLICATION_AZ,
                                                                            pParentContainerAz)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CApplicationAz)
    DEBUG_INCREMENT_INSTANCE_COUNTER(CApplicationAz);
    SetType(IDS_TYPE_APPLICATION);  
}

//+----------------------------------------------------------------------------
//  Function:   Destructor
//-----------------------------------------------------------------------------
CApplicationAz::~CApplicationAz()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CApplicationAz)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CApplicationAz)
}

HRESULT 
CApplicationAz::
CreateOperation(IN const CString& strOperationName, 
                     OUT COperationAz** ppOperationAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,CreateOperation)
    if(!ppOperationAz)
    {
        ASSERT(ppOperationAz);
        return E_POINTER;
    }

    CComBSTR bstrName = strOperationName;
    HRESULT hr = S_OK;
    CComPtr<IAzOperation> spOperation;

    hr = m_spAzInterface->CreateOperation(bstrName,
                                                      CComVariant(),    //Reserved
                                                      &spOperation);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppOperationAz = new COperationAz(spOperation,this);
    if(!*ppOperationAz)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CApplicationAz
::DeleteOperation(IN const CString& strOperationName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,DeleteOperation)

    CComBSTR bstrName = strOperationName;
    HRESULT hr = S_OK;
    hr = m_spAzInterface->DeleteOperation(bstrName,
                                                     CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}

HRESULT
CApplicationAz
::OpenOperation(IN const CString& strOperationName, 
                     IN COperationAz** ppOperationAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,OpenOperation)
    if(!ppOperationAz)
    {
        ASSERT(ppOperationAz);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    CComBSTR bstrName = strOperationName;
    CComPtr<IAzOperation> spOperation;
    hr = m_spAzInterface->OpenOperation(bstrName,
                                                   CComVariant(),   //Reserved
                                                  &spOperation);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppOperationAz = new COperationAz(spOperation,this);

    if(!*ppOperationAz)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CApplicationAz
::GetOperationCollection(OUT OPERATION_COLLECTION** ppOperationCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,GetOperationCollection)

    if(!ppOperationCollection)
    {
        ASSERT(ppOperationCollection);
        return E_POINTER;
    }
    
    CComPtr<IAzOperations> spAzOperations;
    HRESULT hr = m_spAzInterface->get_Operations(&spAzOperations);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppOperationCollection = new OPERATION_COLLECTION(spAzOperations,
                                                                     this);
    if(!*ppOperationCollection)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT 
CApplicationAz::
CreateScope(IN const CString& strScopeName, 
                OUT CScopeAz** ppScopeAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,CreateScope)
    
    if(!ppScopeAz)
    {
        ASSERT(ppScopeAz);
        return E_POINTER;
    }

    CComBSTR bstrName = strScopeName;
    HRESULT hr = S_OK;
    CComPtr<IAzScope> spScope;

    hr = m_spAzInterface->CreateScope(bstrName,
                                                CComVariant(),  //Reserved
                                                &spScope);

    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *ppScopeAz = new CScopeAz(spScope,this);

    if(!*ppScopeAz)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT
CApplicationAz
::DeleteScope(IN const CString& strScopeName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,DeleteScope)

    CComBSTR bstrName = strScopeName;
    HRESULT hr = S_OK;
    hr = m_spAzInterface->DeleteScope(bstrName,
                                                CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}
    
HRESULT
CApplicationAz
::GetScopeCollection(OUT SCOPE_COLLECTION** ppScopeCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,GetScopeCollection)
    if(!ppScopeCollection)
    {
        ASSERT(ppScopeCollection);
        return E_POINTER;
    }
    
    CComPtr<IAzScopes> spAzScopes;
    HRESULT hr = m_spAzInterface->get_Scopes(&spAzScopes);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppScopeCollection = new SCOPE_COLLECTION(spAzScopes,
                                                          this);
    if(!*ppScopeCollection)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return hr;
    }

    return S_OK;
}

//CContainerAz Override
HRESULT 
CApplicationAz::
CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                    IN const CString& strName, 
                    OUT CBaseAz** ppBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,CreateAzObject)
    if(!ppBaseAz)
    {
        ASSERT(ppBaseAz);
        return E_POINTER;
    }
    
    switch (eObjectType)
    {
        case SCOPE_AZ:
        {
            return CreateScope(strName, reinterpret_cast<CScopeAz**>(ppBaseAz));            
        }
        case GROUP_AZ:
        {
            return CreateGroup(strName, reinterpret_cast<CGroupAz**>(ppBaseAz));            
        }       
        case TASK_AZ:
        {
            return CreateTask(strName, reinterpret_cast<CTaskAz**>(ppBaseAz));          
        }       
        case ROLE_AZ:
        {
            return CreateRole(strName, reinterpret_cast<CRoleAz**>(ppBaseAz));      
        }
        case OPERATION_AZ:
        {
            return CreateOperation(strName, reinterpret_cast<COperationAz**>(ppBaseAz));            
        }
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT 
CApplicationAz::
OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
              IN const CString& strName,
              OUT CBaseAz** ppBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,OpenObject)
    if(!ppBaseAz)
    {
        ASSERT(ppBaseAz);
        return E_POINTER;
    }
    switch (eObjectType)
    {
        case GROUP_AZ:
        {
            return OpenGroup(strName, reinterpret_cast<CGroupAz**>(ppBaseAz));          
        }       
        case TASK_AZ:
        {
            return OpenTask(strName, reinterpret_cast<CTaskAz**>(ppBaseAz));            
        }       
        case ROLE_AZ:
        {
            return OpenRole(strName, reinterpret_cast<CRoleAz**>(ppBaseAz));            
        }
        case OPERATION_AZ:
        {
            return OpenOperation(strName, reinterpret_cast<COperationAz**>(ppBaseAz));          
        }
        default:
        {
            return E_UNEXPECTED;
        }
    }
}



HRESULT
CApplicationAz::
DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                    IN const CString& strName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,DeleteAzObject)
    switch (eObjectType)
    {
        case SCOPE_AZ:
            return DeleteScope(strName);            
        case GROUP_AZ:
            return DeleteGroup(strName);                
        case TASK_AZ:
            return DeleteTask(strName);         
        case ROLE_AZ:
            return DeleteRole(strName);         
        case OPERATION_AZ:
            return DeleteOperation(strName);            
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT
CApplicationAz::
GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                             OUT CBaseAzCollection **ppBaseAzCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CApplicationAz,GetAzObjectCollection)
    if(!ppBaseAzCollection)
    {
        ASSERT(ppBaseAzCollection);
        return E_POINTER;
    }

    switch (eObjectType)
    {
        case SCOPE_AZ:
            return GetScopeCollection(reinterpret_cast<SCOPE_COLLECTION**>(ppBaseAzCollection));            
        case GROUP_AZ:
            return GetGroupCollection(reinterpret_cast<GROUP_COLLECTION**>(ppBaseAzCollection));            
        case TASK_AZ:
            return GetTaskCollection(reinterpret_cast<TASK_COLLECTION**>(ppBaseAzCollection));          
        case ROLE_AZ:
            return GetRoleCollection(reinterpret_cast<ROLE_COLLECTION**>(ppBaseAzCollection));          
        case OPERATION_AZ:
            return GetOperationCollection(reinterpret_cast<OPERATION_COLLECTION**>(ppBaseAzCollection));            
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

/******************************************************************************
Class:  CScopeAz
Purpose: Thin wrapper class around IAzApplication interface.
******************************************************************************/

DEBUG_DECLARE_INSTANCE_COUNTER(CScopeAz)

CScopeAz::CScopeAz(CComPtr<IAzScope>& spAzInterface,
                         CContainerAz* pParentContainerAz)
                         :CRoleTaskContainerAzImpl<IAzScope>(spAzInterface,
                                                                         SCOPE_AZ,
                                                                          pParentContainerAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopeAz)
    SetType(IDS_TYPE_SCOPE);
}

CScopeAz::~CScopeAz()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopeAz)
}

HRESULT 
CScopeAz::
CreateAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                    IN const CString& strName, 
                    OUT CBaseAz** ppBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScopeAz,CreateAzObject)
    if(!ppBaseAz)
    {
        ASSERT(ppBaseAz);
        return E_POINTER;
    }
    
    switch (eObjectType)
    {
        case GROUP_AZ:
            return CreateGroup(strName, reinterpret_cast<CGroupAz**>(ppBaseAz));            
        case TASK_AZ:
            return CreateTask(strName, reinterpret_cast<CTaskAz**>(ppBaseAz));          
        case ROLE_AZ:
            return CreateRole(strName, reinterpret_cast<CRoleAz**>(ppBaseAz));      
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT 
CScopeAz::
OpenObject(IN OBJECT_TYPE_AZ eObjectType, 
              IN const CString& strName,
              OUT CBaseAz** ppBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScopeAz,OpenObject)

    if(!ppBaseAz)
    {
        ASSERT(ppBaseAz);
        return E_POINTER;
    }
    switch (eObjectType)
    {
        case GROUP_AZ:
            return OpenGroup(strName, reinterpret_cast<CGroupAz**>(ppBaseAz));          
        case TASK_AZ:
            return OpenTask(strName, reinterpret_cast<CTaskAz**>(ppBaseAz));            
        case ROLE_AZ:
            return OpenRole(strName, reinterpret_cast<CRoleAz**>(ppBaseAz));            
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT
CScopeAz::
DeleteAzObject(IN OBJECT_TYPE_AZ eObjectType, 
                    IN const CString& strName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScopeAz,DeleteAzObject)
    switch (eObjectType)
    {
        case GROUP_AZ:
            return DeleteGroup(strName);            
        case TASK_AZ:
            return DeleteTask(strName);         
        case ROLE_AZ:
            return DeleteRole(strName);         
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}

HRESULT
CScopeAz::
GetAzObjectCollection(IN OBJECT_TYPE_AZ eObjectType, 
                             OUT CBaseAzCollection **ppBaseAzCollection)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScopeAz,GetAzObjectCollection)

    if(!ppBaseAzCollection)
    {
        ASSERT(ppBaseAzCollection);
        return E_POINTER;
    }

    switch (eObjectType)
    {
        case GROUP_AZ:
            return GetGroupCollection(reinterpret_cast<GROUP_COLLECTION**>(ppBaseAzCollection));            
        case TASK_AZ:
            return GetTaskCollection(reinterpret_cast<TASK_COLLECTION**>(ppBaseAzCollection));          
        case ROLE_AZ:
            return GetRoleCollection(reinterpret_cast<ROLE_COLLECTION**>(ppBaseAzCollection));          
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
}


HRESULT
CScopeAz::
CanScopeBeDelegated(BOOL & bDelegatable)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScopeAz,CanScopeBeDelegated)
    return GetProperty(AZ_PROP_SCOPE_CAN_BE_DELEGATED,&bDelegatable);
}

HRESULT
CScopeAz::
BizRulesWritable(BOOL &brefBizRuleWritable)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScopeAz,BizRulesWritable)
    return GetProperty(AZ_PROP_SCOPE_BIZRULES_WRITABLE,&brefBizRuleWritable);
}

/******************************************************************************
Class:  CTaskAz
Purpose: class for IAzTask interface
******************************************************************************/

DEBUG_DECLARE_INSTANCE_COUNTER(CTaskAz)

CTaskAz::
CTaskAz(CComPtr<IAzTask>& spAzInterface,
          CContainerAz* pParentContainerAz)
          :CBaseAzImpl<IAzTask>(spAzInterface,
                                        TASK_AZ,
                                        pParentContainerAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CTaskAz)
    CComVariant var;
    if(SUCCEEDED(m_spAzInterface->GetProperty(AZ_PROP_TASK_IS_ROLE_DEFINITION, 
                                                                 CComVariant(),
                                                                 &var)))
    {
        ASSERT(var.vt == VT_BOOL);
        if(var.boolVal == VARIANT_TRUE)
            SetType(IDS_TYPE_ROLE_DEFINITION);
        else
            SetType(IDS_TYPE_TASK);
    }
    else
        SetType(IDS_TYPE_TASK);

}

CTaskAz::~CTaskAz()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CTaskAz)
}

int
CTaskAz::
GetImageIndex()
{
    if(IsRoleDefinition())
        return iIconRoleDefinition;
    else
        return iIconTask;
}

HRESULT 
CTaskAz::
GetMembers(IN LONG lPropId,
              OUT CList<CBaseAz*,CBaseAz*>& listMembers)
{
    switch (lPropId)
    {
        case AZ_PROP_TASK_OPERATIONS:
            return GetOperations(listMembers);
        case AZ_PROP_TASK_TASKS:
            return GetTasks(listMembers);
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CTaskAz::
AddMember(IN LONG lPropId,
          IN CBaseAz* pBaseAz)
{
    if(!pBaseAz)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    switch (lPropId)
    {
        case AZ_PROP_TASK_OPERATIONS:
        case AZ_PROP_TASK_TASKS:
        {   
            CComVariant varTaskName = pBaseAz->GetName();
            HRESULT hr = m_spAzInterface->AddPropertyItem(lPropId, 
                                                          varTaskName,
                                                          CComVariant());
            CHECK_HRESULT(hr);
            return hr;

        }
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CTaskAz::
RemoveMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz)
{
    CComVariant var = pBaseAz->GetName();
    switch (lPropId)
    {
        case AZ_PROP_TASK_OPERATIONS:
        case AZ_PROP_TASK_TASKS:
        {
            return m_spAzInterface->DeletePropertyItem(lPropId,
                                                       var,
                                                       CComVariant());  
            break;
        }
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CTaskAz::
GetOperations(OUT CList<CBaseAz*,CBaseAz*>& listOperationAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskAz,GetOperations)
    
    HRESULT hr = S_OK;
    do
    {
        CComVariant varOperationList;
        hr = m_spAzInterface->GetProperty(AZ_PROP_TASK_OPERATIONS, 
                                          CComVariant(),
                                          &varOperationList);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        //Operations are contained by applications,
        //and they can only be opened at application
        //
        CContainerAz* pParetnContainerAz = GetParentAz();
        if(pParetnContainerAz->GetObjectType() == SCOPE_AZ)
            pParetnContainerAz = pParetnContainerAz->GetParentAz();

        ASSERT(pParetnContainerAz->GetObjectType() == APPLICATION_AZ);

        hr = SafeArrayToAzObjectList(varOperationList,
                                     pParetnContainerAz, 
                                     OPERATION_AZ, 
                                     listOperationAz);
        BREAK_ON_FAIL_HRESULT(hr);
    
    }while(0);
    
    return hr;
}


HRESULT 
CTaskAz::
GetTasks(OUT CList<CBaseAz*,CBaseAz*>& listTaskAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskAz,GetTasks)
    
    HRESULT hr = S_OK;
    do
    {
        CComVariant varTaskList;
        hr = m_spAzInterface->GetProperty(AZ_PROP_TASK_TASKS, 
                                                     CComVariant(),
                                                     &varTaskList);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = SafeArrayToAzObjectList(varTaskList,
                                              GetParentAz(), 
                                              TASK_AZ, 
                                              listTaskAz);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    return hr;
}



BOOL 
CTaskAz::
IsRoleDefinition()
{
    CComVariant var;
    if(SUCCEEDED(m_spAzInterface->GetProperty(AZ_PROP_TASK_IS_ROLE_DEFINITION, 
                                                                 CComVariant(),
                                                                 &var)));
    {
        ASSERT(var.vt == VT_BOOL);
        return (var.boolVal == VARIANT_TRUE);
    }
}

HRESULT 
CTaskAz::
MakeRoleDefinition()
{
    CComVariant var = TRUE;
    SetType(IDS_TYPE_ROLE_DEFINITION);
    HRESULT hr = m_spAzInterface->SetProperty(AZ_PROP_TASK_IS_ROLE_DEFINITION, 
                                              var,
                                              CComVariant());
    CHECK_HRESULT(hr);
    return hr;
}


DEBUG_DECLARE_INSTANCE_COUNTER(COperationAz)
COperationAz::
COperationAz(CComPtr<IAzOperation>& spAzInterface,
                 CContainerAz* pParentContainerAz)
                 :CBaseAzImpl<IAzOperation>(spAzInterface,
                                                     OPERATION_AZ,
                                                     pParentContainerAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(COperationAz)
    SetType(IDS_TYPE_OPERATION);
}

COperationAz::~COperationAz()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(COperationAz)
}




DEBUG_DECLARE_INSTANCE_COUNTER(CRoleAz)

CRoleAz::
CRoleAz(CComPtr<IAzRole>& spAzInterface,
          CContainerAz* pParentContainerAz)
          :CBaseAzImpl<IAzRole>(spAzInterface,
                                        ROLE_AZ,
                                        pParentContainerAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CRoleAz);
    SetType(IDS_TYPE_ROLE);
}

CRoleAz::~CRoleAz()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRoleAz)
}

HRESULT 
CRoleAz::
GetMembers(IN LONG lPropId,
              OUT CList<CBaseAz*,CBaseAz*>& listMembers)
{
    switch (lPropId)
    {
        case AZ_PROP_ROLE_APP_MEMBERS:
            return GetApplicationGroups(listMembers);
        case AZ_PROP_ROLE_MEMBERS:
            return GetWindowsGroups(listMembers);
        case AZ_PROP_ROLE_OPERATIONS:
            return GetOperations(listMembers);
        case AZ_PROP_ROLE_TASKS:
            return GetTasks(listMembers);

    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}


HRESULT 
CRoleAz::
GetWindowsGroups(OUT CList<CBaseAz*, CBaseAz*>& listWindowsGroups)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupAz,GetWindowsGroups)
    
    HRESULT hr = S_OK;
    CList<PSID,PSID> listSids;
    do
    {
        CComVariant varGroupList;
        hr = m_spAzInterface->GetProperty(AZ_PROP_ROLE_MEMBERS, 
                                                     CComVariant(),
                                                     &varGroupList);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = SafeArrayToSidList(varGroupList,
                                        listSids);
        BREAK_ON_FAIL_HRESULT(hr);

        CSidHandler * pSidHandler = GetSidHandler();
        if(!pSidHandler)
        {
            ASSERT(pSidHandler);
            return E_UNEXPECTED;
        }

        hr = pSidHandler->LookupSids(this,
                                     listSids,
                                     listWindowsGroups);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    RemoveItemsFromList(listSids,TRUE);
    return hr;
}


HRESULT 
CRoleAz::
GetApplicationGroups(CList<CBaseAz*,CBaseAz*>& listGroupAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupAz,GetApplicationGroups)
    
    HRESULT hr = S_OK;
    do
    {
        CComVariant varGroupList;
        hr = m_spAzInterface->GetProperty(AZ_PROP_ROLE_APP_MEMBERS,
                                                     CComVariant(),
                                                     &varGroupList);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = SafeArrayToAzObjectList(varGroupList,
                                              GetParentAz(), 
                                              GROUP_AZ, 
                                              listGroupAz);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    return hr;
}

HRESULT 
CRoleAz::
GetOperations(OUT CList<CBaseAz*,CBaseAz*>& listOperationAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskAz,GetOperations)
    
    HRESULT hr = S_OK;
    do
    {
        CComVariant varOperationList;
        hr = m_spAzInterface->GetProperty(AZ_PROP_ROLE_OPERATIONS, 
                                                     CComVariant(),
                                                     &varOperationList);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        //Operations are contained by applications,
        //and they can only be opened at application
        //
        CContainerAz* pParetnContainerAz = GetParentAz();
        if(pParetnContainerAz->GetObjectType() == SCOPE_AZ)
            pParetnContainerAz = pParetnContainerAz->GetParentAz();

        ASSERT(pParetnContainerAz->GetObjectType() == APPLICATION_AZ);

        hr = SafeArrayToAzObjectList(varOperationList,
                                              pParetnContainerAz, 
                                              OPERATION_AZ, 
                                              listOperationAz);
        BREAK_ON_FAIL_HRESULT(hr);
    
    }while(0);
    
    return hr;
}

HRESULT
CRoleAz::
GetTasks(OUT CList<CBaseAz*,CBaseAz*>& listTaskAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskAz,GetTasks)
    
    HRESULT hr = S_OK;
    do
    {
        CComVariant varTaskList;
        hr = m_spAzInterface->GetProperty(AZ_PROP_ROLE_TASKS, 
                                          CComVariant(),
                                          &varTaskList);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = SafeArrayToAzObjectList(varTaskList,
                                     GetParentAz(), 
                                     TASK_AZ, 
                                     listTaskAz);
    }while(0);
    
    return hr;
}

HRESULT 
CRoleAz::
AddMember(IN LONG lPropId,
             IN CBaseAz* pBaseAz)
{
    if(!pBaseAz)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    switch (lPropId)
    {
        case AZ_PROP_ROLE_OPERATIONS:
        case AZ_PROP_ROLE_TASKS:
        case AZ_PROP_ROLE_APP_MEMBERS:
        {
            CComVariant varName = pBaseAz->GetName();
            return m_spAzInterface->AddPropertyItem(lPropId, 
                                                                 varName,
                                                                 CComVariant());
        }
        case AZ_PROP_ROLE_MEMBERS:
        {
            CString strSid;
            if(GetStringSidFromSidCachecAz(pBaseAz, &strSid))
            {
                CComVariant var = strSid;
                return m_spAzInterface->AddPropertyItem(lPropId,
                                                                     var,
                                                                     CComVariant());
            
            }
            else
            {
                return E_FAIL;
            }
        }
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CRoleAz::
RemoveMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz)
{
    switch (lPropId)
    {
        case AZ_PROP_ROLE_OPERATIONS:   
        case AZ_PROP_ROLE_TASKS:
        case AZ_PROP_ROLE_APP_MEMBERS:
        {
            CComVariant var = pBaseAz->GetName();
            return m_spAzInterface->DeletePropertyItem(lPropId,
                                                                     var,
                                                                     CComVariant());
            break;
        }
        case AZ_PROP_ROLE_MEMBERS:
        {
            CString strSid;
            if(GetStringSidFromSidCachecAz(pBaseAz, &strSid))
            {
                CComVariant var = strSid;
                return m_spAzInterface->DeletePropertyItem(lPropId,
                                                                         var,
                                                                         CComVariant());
            
            }
            else
            {
                return E_FAIL;
            }
        }
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}


DEBUG_DECLARE_INSTANCE_COUNTER(CGroupAz)
CGroupAz::
CGroupAz(CComPtr<IAzApplicationGroup>& spAzInterface,
                 CContainerAz* pParentContainerAz)
                 :CBaseAzImpl<IAzApplicationGroup>(spAzInterface,
                                                             GROUP_AZ,
                                                              pParentContainerAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CGroupAz)

    CComVariant varType;
    LONG lGroupType = AZ_GROUPTYPE_BASIC;
    HRESULT hr = m_spAzInterface->GetProperty(AZ_PROP_GROUP_TYPE,
                                              CComVariant(),
                                              &varType);
    if(SUCCEEDED(hr))
    {
        ASSERT(varType.vt == VT_I4);
        lGroupType = varType.lVal;
    }

    SetType((lGroupType == AZ_GROUPTYPE_LDAP_QUERY) ? IDS_TYPE_LDAP_GROUP:IDS_TYPE_BASIC_GROUP);
}

CGroupAz::~CGroupAz()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CGroupAz)
}

HRESULT 
CGroupAz
::GetGroupType(LONG* plGroupType)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupAz,GetGroupType)
    if(!plGroupType)
    {
        ASSERT(plGroupType);
        return E_POINTER;
    }
    
    CComVariant varType;
    HRESULT hr = m_spAzInterface->GetProperty(AZ_PROP_GROUP_TYPE,
                                                            CComVariant(),
                                                            &varType);
    if(SUCCEEDED(hr))
    {
        ASSERT(varType.vt == VT_I4);
        *plGroupType = varType.lVal;
    }

    return hr;
}

HRESULT 
CGroupAz
::SetGroupType(LONG lGroupType)
{

    TRACE_METHOD_EX(DEB_SNAPIN,CGroupAz,SetGroupType)

    SetType((lGroupType == AZ_GROUPTYPE_LDAP_QUERY) ? IDS_TYPE_LDAP_GROUP:IDS_TYPE_BASIC_GROUP);
    
    CComVariant varType = lGroupType;

    return m_spAzInterface->SetProperty(AZ_PROP_GROUP_TYPE,
                                                    varType,
                                                    CComVariant());
}
HRESULT 
CGroupAz::
GetMembers(IN LONG lPropId,
              OUT CList<CBaseAz*,CBaseAz*>& listMembers)
{
    switch (lPropId)
    {
        case AZ_PROP_GROUP_APP_MEMBERS:
            return GetApplicationGroups(listMembers, TRUE);
        case AZ_PROP_GROUP_APP_NON_MEMBERS:
            return GetApplicationGroups(listMembers, FALSE);
        case AZ_PROP_GROUP_MEMBERS:
            return GetWindowsGroups(listMembers, TRUE);
        case AZ_PROP_GROUP_NON_MEMBERS:
            return GetWindowsGroups(listMembers, FALSE);
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CGroupAz::
AddMember(IN LONG lPropId,
             IN CBaseAz* pBaseAz)
{
    if(!pBaseAz)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    switch (lPropId)
    {
        case AZ_PROP_GROUP_APP_MEMBERS:         
        case AZ_PROP_GROUP_APP_NON_MEMBERS:
        {
            CComVariant varName = pBaseAz->GetName();
            return m_spAzInterface->AddPropertyItem(lPropId, 
                                                                 varName,
                                                                 CComVariant());

        }
        case AZ_PROP_GROUP_MEMBERS:
        case AZ_PROP_GROUP_NON_MEMBERS:
        {           
            CString strSid;
            if(GetStringSidFromSidCachecAz(pBaseAz, &strSid))
            {
                CComVariant var = strSid;
                return m_spAzInterface->AddPropertyItem(lPropId,
                                                                     var,
                                                                     CComVariant());
            
            }
            else
            {
                return E_FAIL;
            }
        }
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CGroupAz::
RemoveMember(IN LONG lPropId,
                 IN CBaseAz* pBaseAz)
{
    switch (lPropId)
    {
        case AZ_PROP_GROUP_APP_MEMBERS: 
        case AZ_PROP_GROUP_APP_NON_MEMBERS:
        {
            CComVariant var = pBaseAz->GetName();
            return m_spAzInterface->DeletePropertyItem(lPropId,
                                                                     var,
                                                                     CComVariant());
            break;
        }
        case AZ_PROP_GROUP_MEMBERS:
        case AZ_PROP_GROUP_NON_MEMBERS:
        {
            CString strSid;
            if(GetStringSidFromSidCachecAz(pBaseAz, &strSid))
            {
                CComVariant var = strSid;
                return m_spAzInterface->DeletePropertyItem(lPropId,
                                                                         var,
                                                                         CComVariant());
            
            }
            else
            {
                return E_FAIL;
            }
        }
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}


HRESULT 
CGroupAz::
GetApplicationGroups(CList<CBaseAz*,CBaseAz*>& listGroupAz, 
                            BOOL bMember)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupAz,GetApplicationGroups)
    
    HRESULT hr = S_OK;
    do
    {
        CComVariant varGroupList;
        hr = m_spAzInterface->GetProperty(bMember ? AZ_PROP_GROUP_APP_MEMBERS : AZ_PROP_GROUP_APP_NON_MEMBERS, 
                                                     CComVariant(),
                                                     &varGroupList);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = SafeArrayToAzObjectList(varGroupList,
                                              GetParentAz(), 
                                              GROUP_AZ, 
                                              listGroupAz);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    return hr;
}


HRESULT 
CGroupAz::
GetWindowsGroups(OUT CList<CBaseAz*, CBaseAz*>& listWindowsGroups, 
                      IN BOOL bMember)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupAz,GetWindowsGroups)
    
    HRESULT hr = S_OK;
    CList<PSID,PSID> listSids;
    do
    {
        CComVariant varGroupList;
        hr = m_spAzInterface->GetProperty(bMember ? AZ_PROP_GROUP_MEMBERS : AZ_PROP_GROUP_NON_MEMBERS, 
                                                     CComVariant(),
                                                     &varGroupList);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = SafeArrayToSidList(varGroupList,
                                        listSids);
        BREAK_ON_FAIL_HRESULT(hr);

        CSidHandler * pSidHandler = GetSidHandler();
        if(!pSidHandler)
        {
            ASSERT(pSidHandler);
            return E_UNEXPECTED;
        }

        hr = pSidHandler->LookupSids(this,
                                              listSids,
                                              listWindowsGroups);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    RemoveItemsFromList(listSids,TRUE);
    return hr;
}

int
CGroupAz::
GetImageIndex()
{
    LONG lGroupType = AZ_GROUPTYPE_LDAP_QUERY;
    if(SUCCEEDED(GetGroupType(&lGroupType)) && 
                 lGroupType == AZ_GROUPTYPE_LDAP_QUERY)
    {
        return iIconLdapGroup;
    }
    else
        return iIconBasicGroup;

}

CSidCacheAz::
CSidCacheAz(SID_CACHE_ENTRY *pSidCacheEntry,
                CBaseAz* pOwnerBaseAz)
:CBaseAz(SIDCACHE_AZ,NULL),
m_pOwnerBaseAz(pOwnerBaseAz),
m_pSidCacheEntry(pSidCacheEntry)
{
    ASSERT(m_pOwnerBaseAz);
    ASSERT(m_pSidCacheEntry);
}

CSidCacheAz::~CSidCacheAz()
{
}

int
CSidCacheAz::GetImageIndex()
{
    SID_NAME_USE sidType = m_pSidCacheEntry->GetSidNameUse();
    if(sidType == SidTypeDeletedAccount ||
        sidType == SidTypeInvalid ||
        sidType == SidTypeUnknown)
    {
        return iIconUnknownSid;
    }
    else if(sidType == SidTypeUser)
    {
        return iIconUser;
    }
    else if(sidType == SidTypeComputer)
    {
        return iIconComputerSid;
    }
    else    //Assume everything else is group
    {
        return iIconGroup;
    }
}


HRESULT 
CContainerAz::GetAzChildObjects(IN OBJECT_TYPE_AZ eObjectType, 
                                OUT CList<CBaseAz*,CBaseAz*>& ListChildObjects)
{

    HRESULT hr = S_OK;
    CBaseAzCollection *pBaseAzCollection = NULL;

    do
    {
        //Get the Collection Object
        hr = GetAzObjectCollection(eObjectType, 
                                   &pBaseAzCollection);

        BREAK_ON_FAIL_HRESULT(hr);

        //Get Count of child objects
        LONG lCount = 0;
        hr = pBaseAzCollection->Count(&lCount);
        BREAK_ON_FAIL_HRESULT(hr);  

        //Add Items to list
        CBaseAz* pBaseAz = NULL;
        for(LONG i = 1; i <= lCount; ++i)
        {
            pBaseAz = pBaseAzCollection->GetItem(i);
            if(pBaseAz)
            {
                ListChildObjects.AddTail(pBaseAz);
            }
        }

    }while(0);

    if(FAILED(hr))
    {
        RemoveItemsFromList(ListChildObjects);
    }
    
    if(pBaseAzCollection)
        delete pBaseAzCollection;

    return hr;
}

HRESULT 
CContainerAz::
GetMembers(IN LONG lPropId,
           OUT CList<CBaseAz*,CBaseAz*>& listMembers)
{
    switch (lPropId)
    {
        case AZ_PROP_POLICY_ADMINS:
        case AZ_PROP_POLICY_READERS:
        case AZ_PROP_DELEGATED_POLICY_USERS:
            return GetPolicyUsers(lPropId,listMembers);
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CContainerAz::
AddMember(IN LONG lPropId,
             IN CBaseAz* pBaseAz)
{
    switch (lPropId)
    {
        case AZ_PROP_POLICY_ADMINS:
        case AZ_PROP_POLICY_READERS:
        case AZ_PROP_DELEGATED_POLICY_USERS:
            return AddPolicyUser(lPropId,pBaseAz);
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

HRESULT 
CContainerAz::
RemoveMember(IN LONG lPropId,
             IN CBaseAz* pBaseAz)
{
    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }

    switch (lPropId)
    {
        case AZ_PROP_POLICY_ADMINS:
        case AZ_PROP_POLICY_READERS:
        case AZ_PROP_DELEGATED_POLICY_USERS:
            return RemovePolicyUser(lPropId, pBaseAz);
    }
    ASSERT(FALSE);
    return E_UNEXPECTED;
}


//+----------------------------------------------------------------------------
//  Function: GetAllAzChildObjects  
//  Synopsis: Functions gets the child objects of type eObjectType and appends
//                them to ListChildObjects. It gets the childobjects from 
//                pParentContainerAz and from parent/grandparent of 
//                pParentContainerAz.
//-----------------------------------------------------------------------------
HRESULT GetAllAzChildObjects(IN CContainerAz* pParentContainerAz, 
                                      IN OBJECT_TYPE_AZ eObjectType, 
                                      OUT CList<CBaseAz*,CBaseAz*>& ListChildObjects)
{
    if(!pParentContainerAz)
    {
        ASSERT(pParentContainerAz);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    
    while(pParentContainerAz)
    {
        hr = pParentContainerAz->GetAzChildObjects(eObjectType,
                                                                 ListChildObjects);
        BREAK_ON_FAIL_HRESULT(hr);

        if(eObjectType == TASK_AZ)
        {
                if(pParentContainerAz->GetObjectType() == APPLICATION_AZ)
                    break;
        }
        else if(eObjectType == GROUP_AZ)
        {
                if(pParentContainerAz->GetObjectType() == ADMIN_MANAGER_AZ)
                    break;              
        }
        else
        {
            break;
        }

        pParentContainerAz = pParentContainerAz->GetParentAz(); 
    }   
    return hr;
}

HRESULT 
GetPolicyUsersFromAllLevel(IN LONG lPropId,
                           IN CContainerAz* pContainerAz, 
                           OUT CList<CBaseAz*,CBaseAz*>& listPolicyUsers)
{
    if(!pContainerAz)
    {
        ASSERT(pContainerAz);
        return E_POINTER;
    }

    ASSERT((lPropId == AZ_PROP_POLICY_ADMINS) || (lPropId == AZ_PROP_POLICY_READERS)  || (lPropId == AZ_PROP_DELEGATED_POLICY_USERS));  

    HRESULT hr = S_OK;
    while(pContainerAz && pContainerAz->IsSecurable())
    {
        hr = pContainerAz->GetMembers(lPropId,
                                      listPolicyUsers);
        BREAK_ON_FAIL_HRESULT(hr);

        pContainerAz = pContainerAz->GetParentAz();
    }

    if(FAILED(hr))
    {
        RemoveItemsFromList(listPolicyUsers);
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  Function: OpenObjectFromAllLevels 
//  Synopsis: Opens an object of type eObjectType and name strName. If object
//                cannot be opened at pParentContainerAz, function tries at 
//                parent/grandparent of pParentContainerAz
//-----------------------------------------------------------------------------
HRESULT OpenObjectFromAllLevels(IN CContainerAz* pParentContainerAz, 
                                          IN OBJECT_TYPE_AZ eObjectType, 
                                          IN const CString& strName,
                                          OUT CBaseAz** ppBaseAz)
{
    if(!pParentContainerAz || !ppBaseAz)
    {
        ASSERT(pParentContainerAz);
        ASSERT(ppBaseAz);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    
    while(pParentContainerAz)
    {
        hr = pParentContainerAz->OpenObject(eObjectType,
                                                        strName,
                                                        ppBaseAz);

        if(SUCCEEDED(hr))
            break;


        if(eObjectType == TASK_AZ)
        {
                if(pParentContainerAz->GetObjectType() == APPLICATION_AZ)
                    break;
        }
        else if(eObjectType == GROUP_AZ)
        {
                if(pParentContainerAz->GetObjectType() == ADMIN_MANAGER_AZ)
                    break;              
        }
        else
        {
            break;
        }

        pParentContainerAz = pParentContainerAz->GetParentAz(); 
    }   
    return hr;
}

//+----------------------------------------------------------------------------
//  Function:SafeArrayToAzObjectList
//  Synopsis:Input to function is a safearray of BSTR. Each BSTR in array is 
//               name of object of type eObjectType. Function converts this safe
//               array into a list of corresponding CBaseAz objects.
//  Arguments:var: Varaint of type VT_ARRAY|VT_BSTR
//                pParentContainerAz: Pointer of parent which contains objects
//                                           in safe array.                                       
//                eObjectType: Type of object in safe array
//                listAzObject: Gets list of CBaseAz objects
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT SafeArrayToAzObjectList(IN CComVariant& var,
                                          IN CContainerAz* pParentContainerAz, 
                                          IN OBJECT_TYPE_AZ eObjectType, 
                                          OUT CList<CBaseAz*,CBaseAz*>& listAzObject)
{

    TRACE_FUNCTION_EX(DEB_SNAPIN,SafeArrayToAzObjectList)

    if((var.vt != (VT_ARRAY | VT_VARIANT)) || !pParentContainerAz)
    {
        ASSERT(var.vt == (VT_ARRAY | VT_VARIANT));  
        ASSERT(pParentContainerAz);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    do
    {
        BSTR HUGEP *pbstr = NULL;
        
        SAFEARRAY *psa = NULL;  
        psa = V_ARRAY(&var);

      LONG lStart;
      hr = SafeArrayGetLBound(psa, 1, &lStart);
      BREAK_ON_FAIL_HRESULT(hr);

        LONG lEnd;
      hr = SafeArrayGetUBound(psa, 1, &lEnd);
      BREAK_ON_FAIL_HRESULT(hr);


      for (LONG lCurrent = lStart; lCurrent <= lEnd; lCurrent++)
      {
            CComVariant varElement;

            hr = SafeArrayGetElement( psa, &lCurrent, &varElement);
            BREAK_ON_FAIL_HRESULT(hr);

         ASSERT(varElement.vt == VT_BSTR);

            CString strName = varElement.bstrVal;

            CBaseAz* pBaseAz = NULL;

            //Open the object. 
            hr = OpenObjectFromAllLevels(pParentContainerAz,
                                                  eObjectType,
                                                  strName,
                                                  &pBaseAz);
            BREAK_ON_FAIL_HRESULT(hr);

            listAzObject.AddTail(pBaseAz);
        }
    
    }while(0);

    if(FAILED(hr))
    {
        RemoveItemsFromList(listAzObject);
    }
    
    return hr;
}






HRESULT 
SafeArrayToSidList(IN CComVariant& var,
                      OUT CList<PSID,PSID>& listSid)
{

    TRACE_FUNCTION_EX(DEB_SNAPIN,SafeArrayToSidList)

    if((var.vt != (VT_ARRAY | VT_VARIANT)))
    {
        ASSERT(var.vt == (VT_ARRAY | VT_VARIANT));  
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    do
    {
        BSTR HUGEP *pbstr = NULL;
        
        SAFEARRAY *psa = NULL;  
        psa = V_ARRAY(&var);

      LONG lStart;
      hr = SafeArrayGetLBound(psa, 1, &lStart);
      BREAK_ON_FAIL_HRESULT(hr);

        LONG lEnd;
      hr = SafeArrayGetUBound(psa, 1, &lEnd);
      BREAK_ON_FAIL_HRESULT(hr);


      for (LONG lCurrent = lStart; lCurrent <= lEnd; lCurrent++)
      {
            CComVariant varElement;

            hr = SafeArrayGetElement( psa, &lCurrent, &varElement);
            BREAK_ON_FAIL_HRESULT(hr);

         ASSERT(varElement.vt == VT_BSTR);

            CString strSid = varElement.bstrVal;

            PSID pSid = NULL;

            if(!ConvertStringSidToSid(strSid, &pSid))
            {
                hr = E_FAIL;
                BREAK_ON_FAIL_HRESULT(hr);
            }
            listSid.AddTail(pSid);
        }
    
    }while(0);

    if(FAILED(hr))
    {
        RemoveItemsFromList(listSid, TRUE);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\comp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       comp.h
//
//  Contents:   Class Definition for IComponent
//
//  History:    08-01-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

class CRoleComponentObject : public CComponentObject
{
BEGIN_COM_MAP(CRoleComponentObject)
	COM_INTERFACE_ENTRY(IComponent) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CComponentObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CRoleComponentObject)
public:
	CRoleComponentObject();
	~CRoleComponentObject();

protected:
	virtual HRESULT InitializeHeaders(CContainerNode* pContainerNode);
	virtual HRESULT InitializeBitmaps(CTreeNode* cookie);
	virtual HRESULT InitializeToolbar(IToolbar* pToolbar);
	HRESULT LoadToolbarStrings(MMCBUTTON * Buttons);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\compdata.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       compdata.cpp
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#include "headers.h"

// {1F5EEC01-1214-4d94-80C5-4BDCD2014DDD}
const GUID CLSID_RoleSnapin = 
{ 0x1f5eec01, 0x1214, 0x4d94, { 0x80, 0xc5, 0x4b, 0xdc, 0xd2, 0x1, 0x4d, 0xdd } };

DEBUG_DECLARE_INSTANCE_COUNTER(CRoleComponentDataObject)

CRoleComponentDataObject::CRoleComponentDataObject()
{
	TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CRoleComponentDataObject)
	DEBUG_INCREMENT_INSTANCE_COUNTER(CRoleComponentDataObject)

	m_columnSetList.AddTail(new CRoleDefaultColumnSet(L"---Default Column Set---"));
}

CRoleComponentDataObject::~CRoleComponentDataObject()
{
	TRACE_DESTRUCTOR_EX(DEB_SNAPIN, CRoleComponentDataObject)
	DEBUG_DECREMENT_INSTANCE_COUNTER(CRoleComponentDataObject)
}

STDMETHODIMP 
CRoleComponentDataObject::
CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,CompareObjects)

	if(!lpDataObjectA || !lpDataObjectB)
	{
		ASSERT(lpDataObjectA);
		ASSERT(lpDataObjectB);
	}
  
	CInternalFormatCracker ifcA, ifcB;
	VERIFY(SUCCEEDED(ifcA.Extract(lpDataObjectA)));
	VERIFY(SUCCEEDED(ifcB.Extract(lpDataObjectB)));

	CTreeNode* pNodeA = ifcA.GetCookieAt(0);
	CTreeNode* pNodeB = ifcB.GetCookieAt(0);

    if(!pNodeA || !pNodeB)
    {
	    ASSERT(pNodeA != NULL);
	    ASSERT(pNodeB != NULL);
        return S_FALSE;
    }

	if(pNodeA == pNodeB)
		return S_OK;

	//Check if the are of same type container or leafnode
	if(pNodeA->IsContainer() != pNodeB->IsContainer())
		return S_FALSE;

	CBaseAz* pBaseAzA = (dynamic_cast<CBaseNode*>(pNodeA))->GetBaseAzObject();
	CBaseAz* pBaseAzB = (dynamic_cast<CBaseNode*>(pNodeB))->GetBaseAzObject();

	ASSERT(pBaseAzA);
	ASSERT(pBaseAzB);

	if(CompareBaseAzObjects(pBaseAzA,pBaseAzB))
	{
		return S_OK;
	}
	return S_FALSE;
}

CRootData* 
CRoleComponentDataObject::
OnCreateRootData()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject, OnCreateRootData)

	CRoleRootData* pRoleRootNode = new CRoleRootData(this);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString szSnapinName;
	szSnapinName.LoadString(IDS_SNAPIN_NAME);
	pRoleRootNode->SetDisplayName(szSnapinName);
	return pRoleRootNode;
}

STDMETHODIMP 
CRoleComponentDataObject::
CreateComponent(LPCOMPONENT* ppComponent)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,CreateComponent)
	
	if(!ppComponent)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	
	CComObject<CRoleComponentObject>* pObject;
	HRESULT hr = CComObject<CRoleComponentObject>::CreateInstance(&pObject);
	if(FAILED(hr))
	{
		DBG_OUT_HRESULT(hr);
		return hr;
	}
	
	ASSERT(pObject != NULL);
	
	//
	// Store IComponentData
	//
	pObject->SetIComponentData(this);
	
	hr = pObject->QueryInterface(IID_IComponent,
		reinterpret_cast<void**>(ppComponent));
	CHECK_HRESULT(hr);
	
	return hr;
}


BOOL 
CRoleComponentDataObject::LoadResources()
{
	return 
		LoadContextMenuResources(CRootDataMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CAdminManagerNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CApplicationNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CScopeNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CGroupCollectionNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CRoleCollectionNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CTaskCollectionNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CGroupNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CRoleNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CTaskNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(COperationCollectionNodeMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CRoleDefinitionCollectionNodeMenuHolder::GetMenuMap()) &&
		LoadResultHeaderResources(_DefaultHeaderStrings,N_DEFAULT_HEADER_COLS);
}


HRESULT 
CRoleComponentDataObject::OnSetImages(LPIMAGELIST lpScopeImage)
{
	TRACE_METHOD_EX(DEB_SNAPIN, CRoleComponentDataObject, OnSetImages)
	
	return LoadIcons(lpScopeImage);

}


LPCWSTR 
CRoleComponentDataObject::
GetHTMLHelpFileName()
{
	TRACE_METHOD_EX(DEB_SNAPIN, CRoleComponentDataObject, GetHTMLHelpFileName)	
	Dbg(DEB_SNAPIN,"HTMLHelpFile is %ws\n", g_szHTMLHelpFileName);
	return g_szHTMLHelpFileName;
}

void 
CRoleComponentDataObject::
OnNodeContextHelp(CNodeList* /*pNode*/)
{	
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,OnNodeContextHelp)

	CComPtr<IDisplayHelp> spHelp;
	HRESULT hr = GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
	if (SUCCEEDED(hr))
	{
		CString strHelpPath = g_szLinkHTMLHelpFileName;
		strHelpPath += L"::/";
		strHelpPath += g_szTopHelpNodeName;
	    spHelp->ShowTopic((LPOLESTR)(LPCWSTR)strHelpPath);
	}
}



void 
CRoleComponentDataObject::
OnNodeContextHelp(CTreeNode*)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,OnNodeContextHelp)
	CComPtr<IDisplayHelp> spHelp;
	HRESULT hr = GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
	if (SUCCEEDED(hr))
	{
		CString strHelpPath = g_szLinkHTMLHelpFileName;
		strHelpPath += L"::/";
		strHelpPath += g_szTopHelpNodeName;
	    spHelp->ShowTopic((LPOLESTR)(LPCWSTR)strHelpPath);
	}
}

void 
CRoleComponentDataObject::OnTimer()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,OnTimer)

}

void 
CRoleComponentDataObject::OnTimerThread(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,OnTimerThread)
}

CTimerThread* 
CRoleComponentDataObject::OnCreateTimerThread()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject,OnCreateTimerThread)
	return NULL;
}

CColumnSet* 
CRoleComponentDataObject::GetColumnSet(LPCWSTR lpszID)
{ 
	TRACE_METHOD_EX(DEB_SNAPIN,CRoleComponentDataObject, GetColumnSet)
	return m_columnSetList.FindColumnSet(lpszID);
}


void 
CBaseRoleExecContext::
Wait()
{ 
    // The message loop lasts until we get a WM_QUIT message,
    // upon which we shall return from the function.
    while (TRUE)
    {

        DWORD result = 0; 
        MSG msg ; 

        // Read all of the messages in this next loop, 
        // removing each message as we read it.
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
        { 
            // If it's a quit message
			if(msg.message == WM_QUIT)  
			{
				return; 
			}
			else if((msg.message == WM_LBUTTONDOWN) ||
					(msg.message == WM_RBUTTONDOWN) ||
					(msg.message == WM_KEYDOWN))
			{
				//Ignore these messages while in wait
				continue;
			}
            
			// Otherwise, dispatch the message.
            DispatchMessage(&msg); 
        } // End of PeekMessage while loop.

        // Wait for any message sent or posted to this queue 
        // or for one of the passed handles be set to signaled.
        result = MsgWaitForMultipleObjects(1, &m_hEventHandle, 
										   FALSE, INFINITE, QS_ALLINPUT); 

        // The result tells us the type of event we have.
        if (result == (WAIT_OBJECT_0 + 1))
        {
            // New messages have arrived. 
            // Continue to the top of the always while loop to 
            // dispatch them and resume waiting.
            continue;
        } 
        else 
        { 
            // One of the handles became signaled. 
            return;
        } // End of else clause.
    } // End of the always while loop. 
} 

void CDisplayHelpFromPropPageExecContext::
Execute(LPARAM /*arg*/)
{	
	CComPtr<IDisplayHelp> spHelp;
 	HRESULT hr = m_pComponentDataObject->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
	if (SUCCEEDED(hr))
	{
        hr = spHelp->ShowTopic((LPOLESTR)(LPCWSTR)m_strHelpPath);
        CHECK_HRESULT(hr);
	}
}

//
//Helper Class for displaying secondary property pages from
//Existing property pages. For example on double clicking
//a member of group, display the property of member. Since
//propertysheet needs to be brought up from main thread, a 
//message is posted from PropertyPage thread to Main thread.
//An instance of this class is sent as param and main
//thread calls execute on the Instance
//

void 
CPropPageExecContext::Execute(LPARAM /*arg*/)
{		
	FindOrCreateModelessPropertySheet((CRoleComponentDataObject*)pComponentDataObject,pTreeNode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\containernodes.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       Basecont.cpp
//
//  Contents:   
//
//  History:    08-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

/******************************************************************************
Class:  CBaseNode
Purpose: This common base class for all snapins node
******************************************************************************/
CBaseNode::
CBaseNode(CRoleComponentDataObject * pComponentDataObject,
          CAdminManagerNode* pAdminManagerNode,
          CBaseAz* pBaseAz,
          BOOL bDeleteBaseAzInDestructor)
          :m_pComponentDataObject(pComponentDataObject),
          m_pAdminManagerNode(pAdminManagerNode),
          m_pBaseAz(pBaseAz),
          m_bDeleteBaseAzInDestructor(bDeleteBaseAzInDestructor)
{
    ASSERT(m_pComponentDataObject);
    ASSERT(m_pAdminManagerNode);
    ASSERT(pBaseAz);
}


CSidHandler*
CBaseNode::
GetSidHandler()
{
    return GetAdminManagerNode()->GetSidHandler();
}

CBaseNode::
~CBaseNode()
{
    if(m_bDeleteBaseAzInDestructor)
    {
        delete m_pBaseAz;
    }
}


//+----------------------------------------------------------------------------
//  Function:DeleteAssociatedBaseAzObject   
//  Synopsis:This function deletes the baseaz object associated with the node.
//           It actually deletes it from the core. m_pBaseAz which is a reference
//           to the object is deleted in destructor. Once the object is deleted   
//           from core, any operation on m_pBaseAz will return error 
//           INVALID_HANDLE, So no operation should be done on it. This method
//           is called from the Generic Node Delete routine.
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT 
CBaseNode::
DeleteAssociatedBaseAzObject()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseNode,DeleteAssociatedBaseAzObject)

    CBaseAz* pBaseAz = GetBaseAzObject();
    CContainerAz* pContainerAzParent = pBaseAz->GetParentAz();
    if(pContainerAzParent)
    {
        return pContainerAzParent->DeleteAzObject(pBaseAz->GetObjectType(),
                                                  pBaseAz->GetName());
    }
    else
    {
        ASSERT(pContainerAzParent);
        return E_UNEXPECTED;
    }
}


/******************************************************************************
Class:  CBaseContainerNode
Purpose: This is the base class for snapin nodes which can contain 
child nodes.
******************************************************************************/
CBaseContainerNode::
CBaseContainerNode(CRoleComponentDataObject * pComponentDataObject,
                   CAdminManagerNode* pAdminManagerNode,
                   CContainerAz* pContainerAz,
                   OBJECT_TYPE_AZ* pChildObjectTypes,
                   LPCONTEXTMENUITEM2 pContextMenu,
                   BOOL bDeleteBaseAzInDestructor)
                   :CBaseNode(pComponentDataObject,
                              pAdminManagerNode,
                              pContainerAz,
                              bDeleteBaseAzInDestructor),
                   m_pColumnSet(NULL),
                   m_pChildObjectTypes(pChildObjectTypes),
                   m_pContextMenu(pContextMenu)
{
}

CBaseContainerNode::
~CBaseContainerNode()
{
}

//+----------------------------------------------------------------------------
//  Function:AddChildNodes   
//  Synopsis:This function add child nodes for object types listed in 
//               m_pChildObjectTypes  
//-----------------------------------------------------------------------------
HRESULT 
CBaseContainerNode::
AddChildNodes()
{
    //There are no child object types. Derived class must be handling 
    //enumeration itself.
    if(!m_pChildObjectTypes)
    {
        return S_OK;
    }
    
    //Clear All Children
    RemoveAllChildrenFromList();

    HRESULT hr = S_OK;
    OBJECT_TYPE_AZ * pChildObjectTypes = m_pChildObjectTypes;
    OBJECT_TYPE_AZ eObjectType;
    
    while((eObjectType = *pChildObjectTypes++) != AZ_ENUM_END)
    {
        if(eObjectType ==   APPLICATION_AZ ||
           eObjectType ==   SCOPE_AZ ||
           eObjectType ==   GROUP_AZ ||
           eObjectType ==   TASK_AZ ||
           eObjectType ==   ROLE_AZ ||
           eObjectType ==   OPERATION_AZ)
        {
            hr = EnumAndAddAzObjectNodes(eObjectType);
        }
        else if(eObjectType == GROUP_COLLECTION_AZ ||
                  eObjectType == TASK_COLLECTION_AZ ||
                  eObjectType == ROLE_COLLECTION_AZ ||
                  eObjectType == ROLE_DEFINITION_COLLECTION_AZ ||
                  eObjectType == OPERATION_COLLECTION_AZ ||
                  eObjectType == DEFINITION_COLLECTION_AZ)
        {
            hr = AddAzCollectionNode(eObjectType);
        }
        BREAK_ON_FAIL_HRESULT(hr);
    }

    if(FAILED(hr))
    {
        RemoveAllChildrenFromList();
    }
    return hr;
}

//+----------------------------------------------------------------------------
//  Function:AddAzCollectionNode 
//  Synopsis:Adds a collection    
//-----------------------------------------------------------------------------
HRESULT 
CBaseContainerNode
::AddAzCollectionNode(OBJECT_TYPE_AZ eObjectType)
{
    CContainerAz* pContainerAz = GetContainerAzObject();
    ASSERT(pContainerAz);

    CCollectionNode* pCollectionNode = NULL;

    switch (eObjectType)
    {
        case GROUP_COLLECTION_AZ:
        {
            pCollectionNode = new CGroupCollectionNode(GetComponentDataObject(),GetAdminManagerNode(),pContainerAz);        
            break;
        }
        case ROLE_DEFINITION_COLLECTION_AZ:
        {
            pCollectionNode = new CRoleDefinitionCollectionNode(GetComponentDataObject(),GetAdminManagerNode(),pContainerAz);
            break;
        }
        case TASK_COLLECTION_AZ:
        {
            pCollectionNode = new CTaskCollectionNode(GetComponentDataObject(),GetAdminManagerNode(),pContainerAz);     
            break;
        }
        case ROLE_COLLECTION_AZ:
        {
            pCollectionNode = new CRoleCollectionNode(GetComponentDataObject(),GetAdminManagerNode(),pContainerAz);     
            break;
        }
        case OPERATION_COLLECTION_AZ:
        {
            pCollectionNode = new COperationCollectionNode(GetComponentDataObject(),GetAdminManagerNode(),pContainerAz);        
            break;
        }
        case DEFINITION_COLLECTION_AZ:
        {
            pCollectionNode = new CDefinitionCollectionNode(GetComponentDataObject(),GetAdminManagerNode(),pContainerAz);       
            break;
        }
        default:
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }

    if(!pCollectionNode)
    {
        return E_OUTOFMEMORY;
    }

    //Add Node to snapin
    VERIFY(AddChildToList(pCollectionNode));

    return S_OK;
}

//+----------------------------------------------------------------------------
//  Function:EnumAndAddAzObjectNodes   
//  Synopsis:Get All the Child Objects of type eObjectType and adds them to
//               snapin   
//-----------------------------------------------------------------------------
HRESULT
CBaseContainerNode:: 
EnumAndAddAzObjectNodes(OBJECT_TYPE_AZ eObjectType)
{
    CList<CBaseAz*,CBaseAz*> listAzChildObject;

    //Get Child Object
    CContainerAz* pContainerAz = GetContainerAzObject();
    ASSERT(pContainerAz);

    HRESULT hr = pContainerAz->GetAzChildObjects(eObjectType,
                                                 listAzChildObject);
    if(FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    hr = AddAzObjectNodesToList(eObjectType,
                                listAzChildObject,
                                this);

    CHECK_HRESULT(hr);
    return hr;
}

BOOL 
CBaseContainerNode::
OnEnumerate(CComponentDataObject*, BOOL)
{
    TRACE_METHOD_EX(DEB_SNAPIN, CBaseContainerNode, OnEnumerate)

    HRESULT hr = AddChildNodes();
    if(FAILED(hr))
    {           
        //Display Error
        CString strError;
        GetSystemError(strError, hr);   
    
        //Display Generic Error Message
        DisplayError(NULL,
                     IDS_GENERIC_ENUMERATE_ERROR, 
                     (LPWSTR)(LPCWSTR)strError);

        return FALSE;
    }

    return TRUE; 
}

HRESULT 
CBaseContainerNode::
GetResultViewType(CComponentDataObject* ,
                  LPOLESTR* ppViewType, 
                  long* pViewOptions)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseContainerNode,GetResultViewType)
    if(!pViewOptions || !ppViewType)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
    *ppViewType = NULL;
   return S_FALSE;
}


BOOL
CBaseContainerNode::
OnAddMenuItem(LPCONTEXTMENUITEM2 , 
              long*)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseContainerNode,OnAddMenuItem)
    
    BOOL bCanCreateChild = FALSE;
    HRESULT hr = GetContainerAzObject()->CanCreateChildObject(bCanCreateChild);
    
    if(SUCCEEDED(hr) && bCanCreateChild)
        return TRUE;
    else
        return FALSE;
}

CColumnSet* 
CBaseContainerNode::
GetColumnSet()
{
    TRACE_METHOD_EX(DEB_SNAPIN, CBaseContainerNode, GetColumnSet);
    if (m_pColumnSet == NULL)
   {
        m_pColumnSet = GetComponentDataObject()->GetColumnSet(L"---Default Column Set---");
    }
    ASSERT(m_pColumnSet);
   return m_pColumnSet;
}

LPCWSTR 
CBaseContainerNode::
GetString(int nCol)
{
    if(nCol == 0)
        return GetName();
    if( nCol == 1)
        return GetType();
    if( nCol == 2)
        return GetDesc();

    ASSERT(FALSE);
    return NULL;
}

int 
CBaseContainerNode::
GetImageIndex(BOOL /*bOpenImage*/)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBaseContainerNode,GetImageIndex)
    return GetBaseAzObject()->GetImageIndex();
}

HRESULT 
CBaseContainerNode::
OnCommand(long nCommandID,
          DATA_OBJECT_TYPES, 
          CComponentDataObject* pComponentData,
          CNodeList* pNodeList)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerNode,OnCommand)
    if(!pNodeList || !pComponentData)
    {
        ASSERT(pNodeList);
        ASSERT(pComponentData);
        return E_POINTER;
    }
    
    if(pNodeList->GetCount() > 1)
    {
        return E_FAIL;
    }

    DoCommand(nCommandID,pComponentData, pNodeList);

    return S_OK;
}

BOOL 
CBaseContainerNode::
CanCloseSheets()
{
    //This function is called when there are open property sheets,
    //and operation cannot be done without closing them.
    ::DisplayInformation(NULL,
                         IDS_CLOSE_CONTAINER_PROPERTY_SHEETS,
                         GetDisplayName());
    return FALSE;
}

BOOL 
CBaseContainerNode::
OnSetDeleteVerbState(DATA_OBJECT_TYPES /*type*/, 
                     BOOL* pbHide, 
                     CNodeList* pNodeList)
{
    if(!pbHide || !pNodeList)
    {
        ASSERT(pbHide);
        ASSERT(pNodeList);
        return FALSE;
    }

    BOOL bWrite = FALSE;
    HRESULT hr = GetBaseAzObject()->IsWritable(bWrite);

    if(FAILED(hr) || !bWrite || (pNodeList->GetCount() == 1 && !IsNodeDeleteable()))
    {
        *pbHide = TRUE;
        return FALSE;
    }
    else
    {
        *pbHide = FALSE;
        return TRUE;
    }
    return TRUE;
}

void 
CBaseContainerNode::
OnDelete(CComponentDataObject* pComponentData, 
         CNodeList* pNodeList)
{
    GenericDeleteRoutine(this,pComponentData,pNodeList,TRUE);
}

/******************************************************************************
Class:  CAzContainerNode
Purpose: Snapin Nodes for BaseAz Objects which can contain other child 
            objects use CAzContainerNode as base class
******************************************************************************/
CAzContainerNode::
CAzContainerNode(CRoleComponentDataObject * pComponentDataObject,
                 CAdminManagerNode* pAdminManagerNode,
                 OBJECT_TYPE_AZ* pChildObjectTypes,
                 LPCONTEXTMENUITEM2 pContextMenu,
                 CContainerAz* pContainerAz)
                :CBaseContainerNode(pComponentDataObject,
                                    pAdminManagerNode,
                                    pContainerAz,
                                    pChildObjectTypes,
                                    pContextMenu)               
{
    SetDisplayName(GetName());    
}

CAzContainerNode::~CAzContainerNode()
{
    //Before delete the BaseAz object, delete all its child else
    //core will assert when we try to delete the child.
    RemoveAllChildrenFromList();
}




void 
GenericDeleteRoutine(CBaseNode* pBaseNode,
                     CComponentDataObject* pComponentData, 
                     CNodeList* pNodeList,
                     BOOL bConfirmDelete)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,GenericDeleteRoutine)

    if (!pNodeList || !pComponentData) 
    {
        ASSERT(pNodeList);
        ASSERT(pComponentData);
        return;
    }

    CTreeNode *pTreeNode = dynamic_cast<CTreeNode*>(pBaseNode);
    ASSERT(pTreeNode);

    //
    //If we are deleteing this node, check if there is any 
    //propertysheet up.
    //Node has any property sheet up. Display error and quit
    //
    if(pNodeList->GetCount() == 1)
    {       
        if (pTreeNode->IsSheetLocked())
        {
            ::DisplayInformation(NULL,
                                 IDS_CLOSE_CONTAINER_PROPERTY_SHEETS,
                                 pTreeNode->GetDisplayName());

            BringPropSheetToForeGround((CRoleComponentDataObject*)pComponentData,
                                       pTreeNode);

            return;
        }
    }
    
    //
    //Get Delete confirmation from user
    //
    if(bConfirmDelete)
    {
        if(pNodeList->GetCount() == 1)
        {
            CBaseAz* pBaseAz = pBaseNode->GetBaseAzObject();
            CString strType = pBaseAz->GetType();
            strType.MakeLower();            
            if(IDNO == DisplayConfirmation(NULL,
                                           IDS_DELETE_CONFIRMATION,
                                           (LPCTSTR)strType,
                                           (LPCTSTR)pBaseAz->GetName()))
            {
                return;
            }
        }
        else
        {
            //Ask Confirmation to delete all the objects
            if(IDNO == DisplayConfirmation(NULL,
                                           IDS_DELETE_SELECTED_CONFIRMATION))
            {
                return;
            }
        }
    }

    if(pNodeList->GetCount() == 1)
    {
        //
        //Delete the BaseAzObject associated with the node
        //
        HRESULT hr = pBaseNode->DeleteAssociatedBaseAzObject();     
        if(SUCCEEDED(hr))
        {
            pTreeNode->DeleteHelper(pComponentData);
            delete pTreeNode;
        }
        else
        {
            //Display Error
            CString strError;
            GetSystemError(strError, hr);   
            //Display Generic Error Message
            DisplayError(NULL,
                         IDS_DELETE_FAILED, 
                         (LPWSTR)(LPCWSTR)strError,
                         (LPWSTR)(LPCWSTR)pTreeNode->GetDisplayName());

            return;
        }
    }
    else
    {
        POSITION pos = pNodeList->GetHeadPosition();
        while (pos != NULL)
        {
            CTreeNode* pChildTreeNode = pNodeList->GetNext(pos);
            //
            //Node has any property sheet up. Display error and quit
            //
            if (pChildTreeNode->IsSheetLocked())
            {
                ::DisplayInformation(NULL,
                                     IDS_CLOSE_CONTAINER_PROPERTY_SHEETS,
                                     pChildTreeNode->GetDisplayName());
                return;
            }

            CBaseNode* pChildBaseNode = dynamic_cast<CBaseNode*>(pChildTreeNode);
            ASSERT(pChildBaseNode);
            if(!pChildBaseNode->IsNodeDeleteable())
                continue;

            HRESULT hr = pChildBaseNode->DeleteAssociatedBaseAzObject();        
            if(SUCCEEDED(hr))
            {
                pChildTreeNode->DeleteHelper(pComponentData);
                delete pChildTreeNode;
            }
            else
            {
                //Display Error
                CString strError;
                GetSystemError(strError, hr);   
                //Display Generic Error Message
                if(IDNO == DisplayConfirmation(NULL,
                                               IDS_FAILURE_IN_MULTIPLE_DELETE, 
                                               (LPWSTR)(LPCWSTR)strError,
                                               (LPWSTR)(LPCWSTR)pChildTreeNode->GetDisplayName()))
                {
                    break;
                }
            }
        }
    }
}


BOOL 
CAzContainerNode::
HasPropertyPages(DATA_OBJECT_TYPES , 
                 BOOL* pbHideVerb, 
                 CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
      *pbHideVerb = FALSE; // always show the verb
      return TRUE;
  }
  // Multiple selection
  *pbHideVerb = TRUE;
  return FALSE;
}

HRESULT 
CAzContainerNode::
CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle,
                    CNodeList* pNodeList)
{
    HRESULT hr = S_OK;
    if (!pNodeList || pNodeList->GetCount() > 1)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    if(!CanReadOneProperty(GetDisplayName(),
                           GetBaseAzObject()))
        return E_FAIL;

    //Add Property Pages
    UINT nPageNum = 0;

    CRolePropertyPageHolder* pHolder = NULL;    
    do 
    {
        CComponentDataObject* pComponentDataObject = GetComponentDataObject();
        ASSERT(pComponentDataObject != NULL);
    
        pHolder = new CRolePropertyPageHolder(GetContainer(), 
                                              this, 
                                              pComponentDataObject);
        if(!pHolder)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        while(1)
        {       
            hr = AddOnePageToList(pHolder, nPageNum);
            if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                hr = S_OK;
                break;
            }
            if(FAILED(hr))
            {
                break;
            }
            nPageNum++;
        }
        BREAK_ON_FAIL_HRESULT(hr);

        //
        //Add Security Page. Security Page is only supported by containers.
        //Depending on underlying store, application and scope may or may 
        //not support Security
        //
        CContainerAz* pContainerAz = GetContainerAzObject();
        if(pContainerAz->IsSecurable())
        {
            Dbg(DEB_SNAPIN, "Adding Security Page\n");

            CSecurityPropertyPage * pSecPropPage = 
                    new CSecurityPropertyPage(pContainerAz,this);

            if(!pSecPropPage)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            pHolder->AddPageToList(pSecPropPage);
            nPageNum++;
        }
        
        //
        //Add Auditing Page
        //
        if(pContainerAz->IsAuditingSupported())
        {
            Dbg(DEB_SNAPIN, "Adding Auditing page\n");

            CAuditPropertyPage *pAuditPage =
                new CAuditPropertyPage(pContainerAz,this);
            if(!pAuditPage)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            pHolder->AddPageToList(pAuditPage);
            nPageNum++;
        }
        if(nPageNum)
            return pHolder->CreateModelessSheet(lpProvider, handle);

    }while(0);

    if(FAILED(hr) || !nPageNum)
    {
        if(pHolder)
            delete pHolder;
    }
    return hr;
}

void 
CAzContainerNode::
OnPropertyChange(CComponentDataObject* pComponentData,
                      BOOL bScopePane,
                      long changeMask)
{
    if(!pComponentData)
    {
        ASSERT(pComponentData);
        return;
    }
    //Reset the display name
    SetDisplayName(GetName());  
    CTreeNode::OnPropertyChange(pComponentData,
                                         bScopePane,
                                         changeMask);
}

/******************************************************************************
Class:  CCollectionNode
Purpose: Base Class for snapin nodes which are used to group objects of 
            same type.
******************************************************************************/
CCollectionNode
::CCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,OBJECT_TYPE_AZ* pChildObjectTypes,
                  LPCONTEXTMENUITEM2 pContextMenu,
                  CContainerAz* pContainerAzObject,
                  UINT nNameStringID,
                  UINT nTypeStringID,
                  UINT nDescStringID)
                  :CBaseContainerNode(pComponentDataObject,
                                      pAdminManagerNode,
                                      pContainerAzObject,
                                      pChildObjectTypes,
                                      pContextMenu,
                                      FALSE)                  

{
    m_strName.LoadString(nNameStringID);
    m_strType.LoadString(nTypeStringID);
    m_strDesc.LoadString(nDescStringID);
    SetDisplayName(m_strName);
}


CCollectionNode
::~CCollectionNode()
{
}


/******************************************************************************
Class:  CAdminManagerNode
Purpose: Snapin Node for AdminManager object
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CAdminManagerNode)
OBJECT_TYPE_AZ 
CAdminManagerNode::childObjectTypes[] = {GROUP_COLLECTION_AZ,                                                     
                                                      APPLICATION_AZ,
                                                      AZ_ENUM_END,};

CAdminManagerNode
::CAdminManagerNode(CRoleComponentDataObject * pComponentDataObject,
                    CAdminManagerAz * pAdminManagerAz)
                    :CAzContainerNode(pComponentDataObject,
                                      this,
                                      childObjectTypes,
                                      CAdminManagerNodeMenuHolder::GetContextMenuItem(),
                                      pAdminManagerAz)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CAdminManagerNode)
    DEBUG_INCREMENT_INSTANCE_COUNTER(CAdminManagerNode)
    SetDisplayName(GetName());    
}

CAdminManagerNode::
~CAdminManagerNode()
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CAdminManagerNode)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAdminManagerNode)
}

//+----------------------------------------------------------------------------
//  Function:CreateFromStream   
//  Synopsis:Reads Data from .msc file and Creates AdminManagerNode
//-----------------------------------------------------------------------------
HRESULT 
CAdminManagerNode::
CreateFromStream(IN IStream* pStm, 
                      IN CRootData* pRootData,
                      IN CComponentDataObject * pComponentDataObject)
{
    if(!pStm || !pRootData || !pComponentDataObject)
    {
        ASSERT(pStm);
        ASSERT(pRootData);
        ASSERT(pComponentDataObject);
    }

    HRESULT hr = S_OK;

    do
    {
        ULONG cbRead = 0;

        //Read the Store Type
        ULONG ulStoreType;
        hr = pStm->Read((void*)&ulStoreType,sizeof(ULONG), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(ULONG));

        //Read the Length of Store Name
        INT nLen;
        hr = pStm->Read((void*)&nLen,sizeof(INT), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(INT));

        //Read Store Name
        LPWSTR pszBuffer = (LPWSTR)LocalAlloc(LPTR,nLen*sizeof(WCHAR));
        if(!pszBuffer)
            return E_OUTOFMEMORY;

        hr = pStm->Read((void*)pszBuffer,sizeof(WCHAR)*nLen, &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(WCHAR)*nLen);

        CString strStoreName = pszBuffer;
        LocalFree(pszBuffer);
        pszBuffer = NULL;

        //read authorization script directory
    
        //Read length of script directory
        INT nLenScriptDir;
        hr = pStm->Read((void*)&nLenScriptDir,sizeof(INT), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(INT));

        //Read authorization script directory
        CString strScriptDir;    
        if(nLenScriptDir > 0)
        {
            pszBuffer = (LPWSTR)LocalAlloc(LPTR,nLenScriptDir*sizeof(WCHAR));
            if(!pszBuffer)
                return E_OUTOFMEMORY;

            hr = pStm->Read((void*)pszBuffer,sizeof(WCHAR)*nLenScriptDir, &cbRead);
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(cbRead == sizeof(WCHAR)*nLenScriptDir);

            strScriptDir = pszBuffer;
            LocalFree(pszBuffer);
        }

        hr =   OpenAdminManager(NULL,
                                TRUE,
                                ulStoreType,
                                strStoreName,
                                strScriptDir,
                                pRootData,
                                pComponentDataObject);
    }while(0);

    return hr;
}

//+----------------------------------------------------------------------------
//  Function:SaveToStream   
//  Synopsis:Saves data for AdminManagerNode in .msc file   
//-----------------------------------------------------------------------------
HRESULT 
CAdminManagerNode::
SaveToStream(IStream* pStm)
{
    if(!pStm)
    {
        ASSERT(pStm);
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    do
    {
        CAdminManagerAz* pAdminMangerAz = (CAdminManagerAz*)GetContainerAzObject();
    
        ULONG cbWrite = 0;

        //Save the Type of Authorization Store
        ULONG ulStoreType = pAdminMangerAz->GetStoreType();
        hr = pStm->Write((void*)&ulStoreType, sizeof(ULONG),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(ULONG));

        //Save the Length of Authorization Store Name
        const CString &strName = pAdminMangerAz->GetName();
        INT nLen = strName.GetLength() + 1; //Include NULL
        hr = pStm->Write((void*)&nLen, sizeof(INT),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(INT));

        //Save Authorization Store Name
        hr = pStm->Write((void*)(LPCTSTR)strName, sizeof(WCHAR)*nLen,&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(WCHAR)*nLen);
    
        //
        //Save the Authorization script directory
        //

        //Save the length of Authorization script directory
        INT nLenScriptDir = m_strScriptDirectory.GetLength();
        if(nLenScriptDir)
            nLenScriptDir++;     //save null also

        pStm->Write((void*)&nLenScriptDir, sizeof(INT),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(INT));


        if(nLenScriptDir)
        {
            //save the Authorization script directory
            pStm->Write((void*)(LPCTSTR)m_strScriptDirectory, sizeof(WCHAR)*nLenScriptDir,&cbWrite);
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(cbWrite == sizeof(WCHAR)*nLenScriptDir);
        }
    }while(0);

    return hr;
}

const CString&
CAdminManagerNode::
GetScriptDirectory()
{
    if(m_strScriptDirectory.IsEmpty())
    {
        m_strScriptDirectory = ((CRoleRootData*)GetRootContainer())->GetXMLStorePath();
    }
    return m_strScriptDirectory;
}
void 
CAdminManagerNode::
DoCommand(long nCommandID,
          CComponentDataObject* pComponentData,
          CNodeList*)
{
    if(IDM_ADMIN_NEW_APP == nCommandID)
    {
        CNewApplicationDlg dlgNewApplication(GetComponentDataObject(),
                                                         this);
        dlgNewApplication.DoModal();
    }
    else if(IDM_ADMIN_CLOSE_ADMIN_MANAGER == nCommandID)
    {

        if (IsSheetLocked())
        {
            ::DisplayInformation(NULL,
                                 IDS_CLOSE_CONTAINER_PROPERTY_SHEETS,
                                 GetDisplayName());

            BringPropSheetToForeGround((CRoleComponentDataObject*)pComponentData,
                                       this);

            return;
        }
    
        DeleteHelper(pComponentData);
        delete this;
    }
    else if(IDM_ADMIN_RELOAD == nCommandID)        
    {
        if (IsSheetLocked())
        {
            ::DisplayInformation(NULL,
                                 IDS_CLOSE_CONTAINER_PROPERTY_SHEETS,
                                 GetDisplayName());

            BringPropSheetToForeGround((CRoleComponentDataObject*)pComponentData,
                                       this);

            return;
        }
 
        CAdminManagerAz* pAdminMangerAz = (CAdminManagerAz*)GetContainerAzObject();
        HRESULT hr = pAdminMangerAz->UpdateCache();
        if(SUCCEEDED(hr))
        {
            //Call Refresh on Root which will refresh
            //all adminmanager objects under it.
            CNodeList tempNodeList;
            tempNodeList.AddTail(this);            
            OnRefresh(GetComponentDataObject(), &tempNodeList);
        }
    }
}



HRESULT 
CAdminManagerNode::
AddOnePageToList(CRolePropertyPageHolder *pHolder, UINT nPageNumber)
{
    HRESULT hr = S_OK;

    if(!pHolder)
    {
        ASSERT(pHolder);
        return E_POINTER;
    }

    if(nPageNumber == 0)
    {
        CAdminManagerGeneralProperty * pGenPropPage = 
                new CAdminManagerGeneralProperty(GetContainerAzObject(),this);

        if(!pGenPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pGenPropPage);
        return hr;
    }

    if(nPageNumber == 1)
    {
        CAdminManagerAdvancedPropertyPage * pAdvPropPage = 
                new CAdminManagerAdvancedPropertyPage(GetContainerAzObject(),this);

        if(!pAdvPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pAdvPropPage);
        return hr;
    }
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

BOOL
CAdminManagerNode:: 
OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
              long * /*pInsertionAllowed*/)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerNode,OnAddMenuItem)
    if(pContextMenuItem2->lCommandID == IDM_ADMIN_NEW_APP)
    {
        
        BOOL bWrite = FALSE;
        HRESULT hr = GetBaseAzObject()->IsWritable(bWrite);

        if(SUCCEEDED(hr) && bWrite)
        {
        
            //Applications can be created only in developer mode
            if(((CRoleRootData*)GetRootContainer())->IsDeveloperMode())
                return TRUE;
        }
    }
    else if(pContextMenuItem2->lCommandID == IDM_ADMIN_CLOSE_ADMIN_MANAGER ||
            pContextMenuItem2->lCommandID == IDM_ADMIN_RELOAD)
    {
        return TRUE;
    }

    return FALSE;
}

HRESULT
CAdminManagerNode::
DeleteAssociatedBaseAzObject()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerNode,DeleteAssociatedBaseAzObject)

    //Delete the Admin Manager object
    CAdminManagerAz* pAdminManagerAz = (CAdminManagerAz*)GetContainerAzObject();
    HRESULT hr = pAdminManagerAz->DeleteSelf();
    if(SUCCEEDED(hr))
    {
        //This function is only called when AdminManager object
        //is deleted. Set the dirty flag so at the snapin exit time,
        //it will ask us to save it.
        CRootData* pRootData = (CRootData*)GetRootContainer();
        pRootData->SetDirtyFlag(TRUE);      
    }

    return hr;
}

/******************************************************************************
Class:  CApplicationNode
Purpose: Snapin Node for Application object
******************************************************************************/

DEBUG_DECLARE_INSTANCE_COUNTER(CApplicationNode)
OBJECT_TYPE_AZ CApplicationNode::childObjectTypes[] = {GROUP_COLLECTION_AZ,
                                                                         DEFINITION_COLLECTION_AZ,
                                                                         ROLE_COLLECTION_AZ,
                                                                         SCOPE_AZ,
                                                                         AZ_ENUM_END,};

CApplicationNode
::CApplicationNode(CRoleComponentDataObject * pComponentDataObject,
                   CAdminManagerNode* pAdminManagerNode,
                   CApplicationAz * pAzBase)
                   :CAzContainerNode(pComponentDataObject,
                                       pAdminManagerNode,
                                       childObjectTypes,
                                       CApplicationNodeMenuHolder::GetContextMenuItem(),
                                       pAzBase)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CApplicationNode)
    DEBUG_INCREMENT_INSTANCE_COUNTER(CApplicationNode)
}

CApplicationNode
::~CApplicationNode()
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CApplicationNode)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CApplicationNode)
}

void 
CApplicationNode
::DoCommand(LONG nCommandID,
            CComponentDataObject*,
            CNodeList*)

{
    if(IDM_APP_NEW_SCOPE == nCommandID)
    {
        CNewScopeDlg dlgNewScope(GetComponentDataObject(),
                                         this);
        dlgNewScope.DoModal();
    }
}

HRESULT 
CApplicationNode::
AddOnePageToList(CRolePropertyPageHolder *pHolder, UINT nPageNumber)
{
    HRESULT hr = S_OK;

    if(!pHolder)
    {
        ASSERT(pHolder);
        return E_POINTER;
    }

    if(nPageNumber == 0)
    {
        //
        //Add General Property Page
        //
        CApplicationGeneralPropertyPage * pGenPropPage = 
                new CApplicationGeneralPropertyPage(GetContainerAzObject(),this);

        if(!pGenPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pGenPropPage);
        return hr;
    }
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

/******************************************************************************
Class:  CScopeNode
Purpose: Snapin Node for Scope object
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CScopeNode)
OBJECT_TYPE_AZ CScopeNode::childObjectTypes[] = {GROUP_COLLECTION_AZ,
                                                          DEFINITION_COLLECTION_AZ,
                                                          ROLE_COLLECTION_AZ,
                                                          AZ_ENUM_END,};

CScopeNode
::CScopeNode(CRoleComponentDataObject * pComponentDataObject,
             CAdminManagerNode* pAdminManagerNode,
             CScopeAz * pAzBase)
            :CAzContainerNode(pComponentDataObject,
                              pAdminManagerNode,
                              childObjectTypes,
                              CScopeNodeMenuHolder::GetContextMenuItem(),
                              pAzBase)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CScopeNode)
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopeNode)
}

CScopeNode::~CScopeNode()
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CScopeNode)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopeNode)
}


HRESULT 
CScopeNode::
AddOnePageToList(CRolePropertyPageHolder *pHolder, UINT nPageNumber)
{
    HRESULT hr = S_OK;

    if(!pHolder)
    {
        ASSERT(pHolder);
        return E_POINTER;
    }

    if(nPageNumber == 0)
    {
        //
        //Add General Property Page
        //
        CScopeGeneralPropertyPage* pGenPropPage = 
                new CScopeGeneralPropertyPage(GetContainerAzObject(),this);

        if(!pGenPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pGenPropPage);
        return hr;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}


/******************************************************************************
Class:  CGroupCollectionNode
Purpose: Snapin Node under which all the groups will be listed
******************************************************************************/
OBJECT_TYPE_AZ CGroupCollectionNode::childObjectTypes[] = {GROUP_AZ,AZ_ENUM_END,};

CGroupCollectionNode
::CGroupCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject)
:CCollectionNode(pComponentDataObject,
              pAdminManagerNode,
              childObjectTypes,
                      CGroupCollectionNodeMenuHolder::GetContextMenuItem(),
                      pContainerAzObject,
                      IDS_NAME,
                      IDS_TYPE,
                      IDS_DESC)
{
}

CGroupCollectionNode::~CGroupCollectionNode()
{
}


void CGroupCollectionNode
::DoCommand(LONG nCommandID,
            CComponentDataObject*,
            CNodeList*)
{
    if(IDM_GROUP_CONTAINER_NEW_GROUP == nCommandID)
    {
        CNewGroupDlg dlgNewGroup(GetComponentDataObject(),
                                                 this);
        dlgNewGroup.DoModal();
    }
}


/******************************************************************************
Class:  CRoleCollectionNode
Purpose: Snapin Node under which all the Roles will be listed
******************************************************************************/
OBJECT_TYPE_AZ CRoleCollectionNode::childObjectTypes[] = {ROLE_AZ,AZ_ENUM_END,};

CRoleCollectionNode
::CRoleCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject)
                            :CCollectionNode(pComponentDataObject,pAdminManagerNode,childObjectTypes,
                                                  CRoleCollectionNodeMenuHolder::GetContextMenuItem(),
                                                  pContainerAzObject,
                                                  IDS_NAME,
                                                  IDS_TYPE,
                                                  IDS_DESC)
{
}

CRoleCollectionNode::~CRoleCollectionNode()
{
}

BOOL
CRoleCollectionNode::
CreateNewRoleObject(CBaseAz* pRoleDefinitionAz)
{
    if(!pRoleDefinitionAz)
    {
        ASSERT(pRoleDefinitionAz);
        return FALSE;
    }

    CString strOrgRoleDefinition = pRoleDefinitionAz->GetName();
    CString strRoleDefinition = strOrgRoleDefinition;

    CRoleAz* pRoleAz = NULL;
    CContainerAz* pContainerAz = GetContainerAzObject();
    HRESULT hr = S_OK;
    do
    {
        int i = 1;
        while(1)
        {
            hr = pContainerAz->CreateAzObject(ROLE_AZ,
                                              strRoleDefinition,
                                              reinterpret_cast<CBaseAz**>(&pRoleAz));
            if(FAILED(hr) && (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)))
            {
                //Maximum required size for _itow is 33.
                //When radix is 2, 32 char for 32bits + NULL terminator
                WCHAR buffer[33];
                _itow(i,buffer,10);
                strRoleDefinition = strOrgRoleDefinition + L"(" + buffer + L")";
                i++;
                continue;           
            }
            break;
        }

        BREAK_ON_FAIL_HRESULT(hr);

        //Add RoleDefiniton to Role
        hr = pRoleAz->AddMember(AZ_PROP_ROLE_TASKS,
                                        pRoleDefinitionAz);

        BREAK_ON_FAIL_HRESULT(hr);

        //Do Submit

        hr = pRoleAz->Submit();
        BREAK_ON_FAIL_HRESULT(hr);

        CRoleNode * pRoleNode = new CRoleNode(GetComponentDataObject(),GetAdminManagerNode(),pRoleAz);
        if(!pRoleNode)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        VERIFY(AddChildToListAndUI(pRoleNode,GetComponentDataObject()));
    }while(0);

    if(FAILED(hr))
    {
        if(pRoleAz)
            delete pRoleAz;

        CString strError;
        GetSystemError(strError, hr);   
        DisplayError(NULL,
                         IDS_CREATE_ROLE_GENERIC_ERROR,
                         (LPWSTR)(LPCTSTR)strError);
        return FALSE;
    }

    return TRUE;
}

void 
CRoleCollectionNode::
DoCommand(LONG nCommandID,
          CComponentDataObject*,
          CNodeList*)

{
    //Show Add Role Definitions dialog box and get selected 
    //Role Definitions
    if(nCommandID != IDM_ROLE_CONTAINER_ASSIGN_ROLE)
    {
        ASSERT(FALSE);
        return;
    }

    CList<CBaseAz*,CBaseAz*> listRoleDefSelected;
    if(!GetSelectedTasks(NULL,
                         TRUE,
                         GetContainerAzObject(),
                         listRoleDefSelected))
    {
        return;
    }

    if(listRoleDefSelected.IsEmpty())
        return;

    POSITION pos = listRoleDefSelected.GetHeadPosition();
    for(int i = 0; i < listRoleDefSelected.GetCount(); ++i)
    {
        CBaseAz* pBaseAz = listRoleDefSelected.GetNext(pos);
        if(!CreateNewRoleObject(pBaseAz))
            break;
    }

    RemoveItemsFromList(listRoleDefSelected);
}

/******************************************************************************
Class:  CRoleDefinitionCollectionNode
Purpose: Snapin Node under which all the Role definitions will be listed
******************************************************************************/
OBJECT_TYPE_AZ CRoleDefinitionCollectionNode::childObjectTypes[] = {ROLE_DEFINITION_AZ,AZ_ENUM_END,};

CRoleDefinitionCollectionNode
::CRoleDefinitionCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject)
:CCollectionNode(pComponentDataObject,pAdminManagerNode,
                 childObjectTypes,
                      CRoleDefinitionCollectionNodeMenuHolder::GetContextMenuItem(),
                      pContainerAzObject,
                      IDS_NAME,
                      IDS_TYPE,
                      IDS_DESC)
{
}

CRoleDefinitionCollectionNode::
~CRoleDefinitionCollectionNode()
{
}

void CRoleDefinitionCollectionNode::
DoCommand(LONG nCommandID,
          CComponentDataObject*,
          CNodeList*)

{
    if(IDM_ROLE_DEFINITION_CONTAINER_NEW_ROLE_DEFINITION == nCommandID)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CNewTaskDlg dlgNewTask(GetComponentDataObject(),
                                      this,
                                      IDD_NEW_ROLE_DEFINITION,
                                      TRUE);
        dlgNewTask.DoModal();
    }
}


BOOL 
CRoleDefinitionCollectionNode::
OnEnumerate(CComponentDataObject*, BOOL )
{
    //Clear All Children
    RemoveAllChildrenFromList();

    CList<CBaseAz*,CBaseAz*> listAzChildObject;
    CContainerAz* pContainerAz = GetContainerAzObject();

    HRESULT hr = pContainerAz->GetAzChildObjects(TASK_AZ,
                                                 listAzChildObject);
    if(FAILED(hr))
    {
        //Display Error
        CString strError;
        GetSystemError(strError, hr);   
    
        //Display Generic Error Message
        DisplayError(NULL,
                     IDS_GENERIC_ENUMERATE_ERROR, 
                     (LPWSTR)(LPCWSTR)strError);

        return FALSE;
    }

    POSITION pos = listAzChildObject.GetHeadPosition();
    for (int i=0;i < listAzChildObject.GetCount();i++)
    {
        CTaskAz* pTaskAz = static_cast<CTaskAz*>(listAzChildObject.GetNext(pos));
        if(pTaskAz->IsRoleDefinition())
        {
            
            CTaskNode* pTaskAzNode = 
                new CTaskNode(GetComponentDataObject(), GetAdminManagerNode(),pTaskAz);
                
            if(!pTaskAzNode)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }
            VERIFY(AddChildToList(pTaskAzNode));
        }
        else
        {
            delete pTaskAz;
        }
    }   
    return TRUE;
}

/******************************************************************************
Class:  CTaskCollectionNode
Purpose: Snapin Node under which all the Tasks will be listed
******************************************************************************/
OBJECT_TYPE_AZ CTaskCollectionNode::childObjectTypes[] = {TASK_AZ,AZ_ENUM_END,};

CTaskCollectionNode
::CTaskCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject)
:CCollectionNode(pComponentDataObject,
              pAdminManagerNode,childObjectTypes,
                      CTaskCollectionNodeMenuHolder::GetContextMenuItem(),
                      pContainerAzObject,
                      IDS_NAME,
                      IDS_TYPE,
                      IDS_DESC)
{
}

CTaskCollectionNode::~CTaskCollectionNode()
{

}

void CTaskCollectionNode::
DoCommand(LONG nCommandID,
          CComponentDataObject*,
          CNodeList*)

{
    if(IDM_TASK_CONTAINER_NEW_TASK == nCommandID)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CNewTaskDlg dlgNewTask(GetComponentDataObject(),
                                      this,
                                      IDD_NEW_TASK,
                                      FALSE);
        dlgNewTask.DoModal();
    }
}

BOOL 
CTaskCollectionNode::
OnEnumerate(CComponentDataObject*, BOOL )
{
    //Clear All Children
    RemoveAllChildrenFromList();

    CList<CBaseAz*,CBaseAz*> listAzChildObject;

    CContainerAz* pContainerAz = GetContainerAzObject();

    HRESULT hr = pContainerAz->GetAzChildObjects(TASK_AZ,
                                                 listAzChildObject);
    if(FAILED(hr))
    {
                //Display Error
        CString strError;
        GetSystemError(strError, hr);   
    
        //Display Generic Error Message
        DisplayError(NULL,
                     IDS_GENERIC_ENUMERATE_ERROR, 
                     (LPWSTR)(LPCWSTR)strError);

        return FALSE;
    }

    POSITION pos = listAzChildObject.GetHeadPosition();
    for (int i=0;i < listAzChildObject.GetCount();i++)
    {
        CTaskAz* pTaskAz = static_cast<CTaskAz*>(listAzChildObject.GetNext(pos));
        if(!pTaskAz->IsRoleDefinition())
        {
            
            CTaskNode* pTaskAzNode = 
                new CTaskNode(GetComponentDataObject(), GetAdminManagerNode(),pTaskAz);
                
            if(!pTaskAzNode)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }
            VERIFY(AddChildToList(pTaskAzNode));
        }
        else
        {
            delete pTaskAz;
        }
    }   
    return TRUE;
}

/******************************************************************************
Class:  COperationCollectionNode
Purpose: Snapin Node under which all the Operations will be listed
******************************************************************************/
OBJECT_TYPE_AZ COperationCollectionNode::childObjectTypes[] = {OPERATION_AZ,AZ_ENUM_END,};

COperationCollectionNode
::COperationCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject)
:CCollectionNode(pComponentDataObject,pAdminManagerNode,childObjectTypes,
                      COperationCollectionNodeMenuHolder::GetContextMenuItem(),
                      pContainerAzObject,
                      IDS_NAME,
                      IDS_TYPE,
                      IDS_DESC)
{
}

COperationCollectionNode::~COperationCollectionNode()
{

}

void COperationCollectionNode::
DoCommand(LONG nCommandID,
          CComponentDataObject*,
          CNodeList*)

{
    if(IDM_OPERATION_CONTAINER_NEW_OPERATION == nCommandID)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CNewOperationDlg dlgNewOperation(GetComponentDataObject(),
                                      this);
        dlgNewOperation.DoModal();
    }
}

/******************************************************************************
Class:  CDefinitionCollectionNode
Purpose: Snapin Node under which all the Definions nodes will be listed
******************************************************************************/
CDefinitionCollectionNode::
CDefinitionCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject)
:CCollectionNode(pComponentDataObject,
              pAdminManagerNode,
              NULL,
                      NULL,
                      pContainerAzObject,
                      IDS_NAME,
                      IDS_TYPE,
                      IDS_DESC)
{
}

    
CDefinitionCollectionNode::
~CDefinitionCollectionNode()
{
}


BOOL 
CDefinitionCollectionNode::
OnEnumerate(CComponentDataObject*, BOOL /*bAsync*/ )
{
    CContainerAz * pContainerAz = GetContainerAzObject();
    if(!pContainerAz)
    {
        ASSERT(pContainerAz);
        return FALSE;
    }


    HRESULT hr = S_OK;
    do
    {
        hr = AddAzCollectionNode(ROLE_DEFINITION_COLLECTION_AZ);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = AddAzCollectionNode(TASK_COLLECTION_AZ);
        BREAK_ON_FAIL_HRESULT(hr);

        if(pContainerAz->GetObjectType() == APPLICATION_AZ)
        {
            //Operation Node is only displayed in Developer Mode
            if(((CRoleRootData*)GetRootContainer())->IsDeveloperMode())
            {
                hr = AddAzCollectionNode(OPERATION_COLLECTION_AZ);
            }
        }

    }while(0);
    
    if(FAILED(hr))
    {
        //Display Error
        CString strError;
        GetSystemError(strError, hr);   
    
        //Display Generic Error Message
        DisplayError(NULL,
                     IDS_GENERIC_ENUMERATE_ERROR,
                     (LPWSTR)(LPCWSTR)strError);

        RemoveAllChildrenFromList();
        return FALSE;
    }

    return TRUE;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CRoleNode)
CRoleNode::
CRoleNode(CRoleComponentDataObject * pComponentDataObject,
          CAdminManagerNode* pAdminManagerNode,
          CRoleAz * pRoleAz)
          :CBaseNode(pComponentDataObject,
                     pAdminManagerNode,
                     pRoleAz,
                     iIconRole),
          m_pColumnSet(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CRoleNode)
    SetDisplayName(GetBaseAzObject()->GetName());
}

CRoleNode::
~CRoleNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRoleNode)
}


BOOL 
CRoleNode::
OnEnumerate(CComponentDataObject* pComponentData, BOOL)
{
    TRACE_METHOD_EX(DEB_SNAPIN, CRoleNode, OnEnumerate)

    //Clear All Children
    RemoveAllChildrenFromList();

    CList<CBaseAz*,CBaseAz*> listObjectsAppMember;
    //Get Application Group Members
    HRESULT hr = GetBaseAzObject()->GetMembers(AZ_PROP_ROLE_APP_MEMBERS,
                                               listObjectsAppMember);

    if(SUCCEEDED(hr))
    {                                   
        AddObjectsFromListToSnapin(listObjectsAppMember,
                                   pComponentData,
                                   FALSE);
    }

    //Get Member Windows Users/Groups
    CList<CBaseAz*,CBaseAz*> listObjectsMember;
    hr = GetBaseAzObject()->GetMembers(AZ_PROP_ROLE_MEMBERS,
                                        listObjectsMember);
    if(SUCCEEDED(hr))
    {
        AddObjectsFromListToSnapin(listObjectsMember,
                                   pComponentData,
                                   FALSE);
    }
    return TRUE; // there are already children, add them to the UI now
}

//+----------------------------------------------------------------------------
//  Function:AssignUsersAndGroups   
//  Synopsis:Function assigns Users and Groups to Role   
//  Arguments:
//  Returns:    
//-----------------------------------------------------------------------------
void
CRoleNode::
AssignUsersAndGroups(IN CComponentDataObject* pComponentData,
                            ULONG nCommandID)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleNode,AssignUsersAndGroups)

    if(!pComponentData)
    {
        ASSERT(FALSE);
        return ;
    }

    HRESULT hr = S_OK;
    
    //Get the MMC Framework window handle
    HWND hwnd;
    hr = (pComponentData->GetConsole())->GetMainWindow(&hwnd);
    if(FAILED(hr))
    {
        Dbg(DEB_SNAPIN,"Failed to get MainWindow handle\n");
        return;
    }

    CList<CBaseAz*,CBaseAz*> listObjectsSelected;
    if(nCommandID == IDM_ROLE_NODE_ASSIGN_APPLICATION_GROUPS)
    {
        //Display Add Groups dialog box and get list of users to add
        if(!GetSelectedAzObjects(hwnd,
                                         GROUP_AZ,
                                         GetBaseAzObject()->GetParentAz(),
                                         listObjectsSelected))
        {
            return;
        }
    }
    else if(nCommandID == IDM_ROLE_NODE_ASSIGN_WINDOWS_GROUPS)
    {
        CSidHandler* pSidHandler = GetSidHandler();
        ASSERT(pSidHandler);

        //Display Object Picker and get list of Users to add
        hr = pSidHandler->GetUserGroup(hwnd,
                                                 GetBaseAzObject(),
                                                 listObjectsSelected);
        if(FAILED(hr))
        {
            return;
        }
    }
    else
    {
        ASSERT(FALSE);
        return;
    }
    
    //Determine which property to modify
    ULONG lPropId = (nCommandID == IDM_ROLE_NODE_ASSIGN_APPLICATION_GROUPS) 
                         ? AZ_PROP_ROLE_APP_MEMBERS 
                         :AZ_PROP_ROLE_MEMBERS;

    CList<CBaseAz*, CBaseAz*> listObjectsAdded;
    
    //Add the list of Selected Users/Group to lPropId property of 
    //Role
    while(listObjectsSelected.GetCount())
    {
        CBaseAz* pMember = listObjectsSelected.RemoveHead();
        
        hr = GetBaseAzObject()->AddMember(lPropId, 
                                          pMember);
        
        if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        {
            hr = S_OK;
            delete pMember;
        }
        else if(SUCCEEDED(hr))
        {
            //Successfully Added. Add it to the list of objectsAdded.
            listObjectsAdded.AddTail(pMember);
        }
        else
        {
            //Display Generic Error. 
            CString strError;
            GetSystemError(strError, hr);   
            
            ::DisplayError(NULL,
                                IDS_ERROR_ADD_MEMBER_OBJECT,
                                (LPCTSTR)strError,
                                (LPCTSTR)pMember->GetName());

            delete pMember;
            hr = S_OK;
        }
    }

    //Do the submit, if Atleast one object has been added
    if(listObjectsAdded.GetCount())
    {
        hr = GetBaseAzObject()->Submit();
        if(FAILED(hr))
        {
            RemoveItemsFromList(listObjectsAdded);
        }
    }

    //For each objects in listObjectAdded, create a snapin node 
    //and add it to snapin
    AddObjectsFromListToSnapin(listObjectsAdded,
                               pComponentData,
                               TRUE);
}
//+----------------------------------------------------------------------------
//  Function:AddObjectsFromListToSnapin   
//  Synopsis:Take objects from List and creates corresponding snapin nodes for
//               them.   
//-----------------------------------------------------------------------------
void 
CRoleNode::
AddObjectsFromListToSnapin(CList<CBaseAz*,CBaseAz*> &listObjects,
                           CComponentDataObject* pComponentData,
                           BOOL bAddToUI)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleNode,AddObjectsFromListToSnapin)

    if(!pComponentData)
    {
        ASSERT(pComponentData);
        return; 
    }

    HRESULT hr = S_OK;
    while(listObjects.GetCount())
    {       
        CBaseAz* pObjectToAdd = listObjects.RemoveHead();
        if(pObjectToAdd->GetObjectType() == GROUP_AZ)
        {
            CGroupNode* pGroupNode = new CGroupNode(GetComponentDataObject(), 
                                                    GetAdminManagerNode(),
                                                    pObjectToAdd,
                                                    (CRoleAz*)GetBaseAzObject());
            if(!pGroupNode)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            if(bAddToUI)
            {
                VERIFY(AddChildToListAndUI(pGroupNode,pComponentData));
            }
            else
            {
                VERIFY(AddChildToList(pGroupNode));
            }
        }
        else 
        {
            ASSERT(pObjectToAdd->GetObjectType() == SIDCACHE_AZ);
            
            CSidCacheNode* pSidNode = new CSidCacheNode(GetComponentDataObject(), 
                                                        GetAdminManagerNode(),
                                                        pObjectToAdd,
                                                        (CRoleAz*)GetBaseAzObject());
            if(!pSidNode)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            if(bAddToUI)
            {
                VERIFY(AddChildToListAndUI(pSidNode,pComponentData));
            }
            else
            {
                VERIFY(AddChildToList(pSidNode));
            }
        }
    }
    if(FAILED(hr))
    {
        RemoveItemsFromList(listObjects);
    }
}


HRESULT 
CRoleNode::
GetResultViewType(CComponentDataObject* /*pComponentData*/,
                        LPOLESTR* ppViewType, 
                        long* pViewOptions)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleNode,GetResultViewType)
    if(!pViewOptions || !ppViewType)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
    *ppViewType = NULL;
   return S_FALSE;
}


BOOL
CRoleNode::
OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2, 
              long*)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleNode,OnAddMenuItem)
    if(!pContextMenuItem2)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    BOOL bWrite = FALSE;
    HRESULT hr = GetBaseAzObject()->IsWritable(bWrite);

    if(SUCCEEDED(hr) && bWrite)
        return TRUE;
    else
        return FALSE;
}

CColumnSet* 
CRoleNode::
GetColumnSet()
{
    TRACE_METHOD_EX(DEB_SNAPIN, CRoleNode, GetColumnSet);

    if (m_pColumnSet == NULL)
   {
        m_pColumnSet = GetComponentDataObject()->GetColumnSet(L"---Default Column Set---");
    }
    ASSERT(m_pColumnSet);
   return m_pColumnSet;
}


LPCWSTR CRoleNode::
GetString(int nCol)
{
    if(nCol == 0)
        return GetBaseAzObject()->GetName();
    if( nCol == 1)
        return GetBaseAzObject()->GetType();
    if( nCol == 2)
        return GetBaseAzObject()->GetDescription();

    ASSERT(FALSE);
    return NULL;
}

int 
CRoleNode::
GetImageIndex(BOOL /*bOpenImage*/)
{
    return GetBaseAzObject()->GetImageIndex();
}

HRESULT 
CRoleNode::
OnCommand(long nCommandID,
             DATA_OBJECT_TYPES, 
             CComponentDataObject* pComponentData,
             CNodeList* pNodeList)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerNode,OnCommand)
    if(!pComponentData || !pNodeList)
    {
        ASSERT(pComponentData);
        ASSERT(pNodeList);
        return E_POINTER;
    }
    
    if(pNodeList->GetCount() > 1)
    {
        return E_FAIL;
    }

    if((nCommandID == IDM_ROLE_NODE_ASSIGN_APPLICATION_GROUPS) ||
       (nCommandID == IDM_ROLE_NODE_ASSIGN_WINDOWS_GROUPS))
    {
        AssignUsersAndGroups(pComponentData,
                             nCommandID);
        return S_OK;
    }
    
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

//
//Helper Functions
//

BOOL 
CRoleNode::
OnSetDeleteVerbState(DATA_OBJECT_TYPES /*type*/, 
                     BOOL* pbHide, 
                     CNodeList* /*pNodeList*/)
{
    if(!pbHide)
    {
        ASSERT(pbHide);
        return FALSE;
    }

    BOOL bWrite = FALSE;
    HRESULT hr = GetBaseAzObject()->IsWritable(bWrite);

    if(FAILED(hr) || !bWrite)
    {
        *pbHide = TRUE;
        return FALSE;
    }
    else
    {
        *pbHide = FALSE;
        return TRUE;
    }
    return TRUE;
}

void 
CRoleNode::
OnDelete(CComponentDataObject* pComponentData, 
         CNodeList* pNodeList)
{
    GenericDeleteRoutine(this,pComponentData,pNodeList,TRUE);
}

BOOL 
CRoleNode::
HasPropertyPages(DATA_OBJECT_TYPES /*type*/, 
                 BOOL* pbHideVerb, 
                 CNodeList* pNodeList)
{
   if (!pNodeList || !pbHideVerb) 
    {
        ASSERT(pNodeList);
        ASSERT(pbHideVerb);
        return FALSE;
    }

    if (pNodeList->GetCount() == 1) // single selection
    {
        *pbHideVerb = FALSE; // always show the verb
        return TRUE;
    }

    // Multiple selection
    *pbHideVerb = TRUE;
    return FALSE;
}


HRESULT 
CRoleNode::
CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle,
                    CNodeList* pNodeList)
{

    if(!lpProvider || !pNodeList)
    {
        ASSERT(lpProvider);
        ASSERT(pNodeList);
        return E_POINTER;
    }

    if(!CanReadOneProperty(GetDisplayName(),
                           GetBaseAzObject()))
        return E_FAIL;


    HRESULT hr = S_OK;
    if (pNodeList->GetCount() > 1)
    {
        return hr;
    }
    CRolePropertyPageHolder* pHolder = NULL;
    
    do 
    {

        CComponentDataObject* pComponentDataObject = GetComponentDataObject();
        ASSERT(pComponentDataObject);
    
        pHolder = new CRolePropertyPageHolder(GetContainer(), 
                                              this, 
                                              pComponentDataObject);
        if(!pHolder)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //Add Property Pages

        //Add General Property Page
        CRoleGeneralPropertyPage * pGenPropPage = 
            new CRoleGeneralPropertyPage(GetBaseAzObject(),
                                         this);

        if(!pGenPropPage)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        pHolder->AddPageToList(pGenPropPage);
    

        return pHolder->CreateModelessSheet(lpProvider, handle);

    }while(0);

    if(FAILED(hr))
    {
        if(pHolder)
            delete pHolder;
    }
    return hr;
}

void 
CRoleNode
::OnPropertyChange(CComponentDataObject* pComponentData,
                         BOOL bScopePane,
                         long changeMask)
{
    if(!pComponentData)
    {
        ASSERT(pComponentData);
        return;
    }

    SetDisplayName(GetBaseAzObject()->GetName());   
    CTreeNode::OnPropertyChange(pComponentData,
                                         bScopePane,
                                         changeMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\compdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       compdata.h
//
//  Contents:   Class Definition for ComponentData		
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

extern const CLSID CLSID_RoleSnapin;    // In-Proc server GUID

class CBaseNode;
//
// CRoleComponentDataObject(.i.e "document")
//
class CRoleComponentDataObject :	
			public CComponentDataObject,
			public CComCoClass<CRoleComponentDataObject,&CLSID_RoleSnapin>
{

BEGIN_COM_MAP(CRoleComponentDataObject)
	COM_INTERFACE_ENTRY(IComponentData) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CComponentDataObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CRoleComponentDataObject)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) 
	{ 
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);
	}
public:
	
	CRoleComponentDataObject();

	~CRoleComponentDataObject();
	
	//
	// IComponentData interface members
	//
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);

	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
	


public:
	static BOOL LoadResources();
private:
	static BOOL FindDialogContextTopic(/*IN*/UINT nDialogID,
                                /*IN*/ HELPINFO* pHelpInfo,
                                /*OUT*/ ULONG* pnContextTopic);

// virtual functions
protected:
	virtual HRESULT OnSetImages(LPIMAGELIST lpScopeImage);
	
	virtual CRootData* OnCreateRootData();

	// help handling
   virtual LPCWSTR GetHTMLHelpFileName();
	
	virtual void OnNodeContextHelp(CNodeList* );
	virtual void OnNodeContextHelp(CTreeNode*);
public:


// Timer and Background Thread
protected:
	virtual void OnTimer();
	
	virtual void OnTimerThread(WPARAM wParam, LPARAM lParam);
	
	virtual CTimerThread* OnCreateTimerThread();

	DWORD m_dwTime; // in

public:
	CColumnSet* GetColumnSet(LPCWSTR lpszID); 

	// IPersistStream interface members
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		ASSERT(pClassID != NULL);
		memcpy(pClassID, (GUID*)&GetObjectCLSID(), sizeof(CLSID));
		return S_OK;
	}

  virtual BOOL IsMultiSelect() { return FALSE; }

private:
	CColumnSetList m_columnSetList;
};

//
//This class overrides CExecContext implementation of Wait.
//Wait is called in propertypage and if Execute method displays
//a new window, propertypage will get WM_ACTIVATE message which it
//must process before main thread can proceed. So to avoid deadlock
//our wait implementation will wait on both event and messages in 
//message queue.
//
class CBaseRoleExecContext:public CExecContext
{
public:
    virtual void Wait();
};
//
//Helper Class for displaying secondary property pages from
//Exsiting property pages. For example on double clicking
//a member of group, display the property of member. Since
//propertysheet needs to be brought up from main thread, a 
//message is posted from PropertyPage thread to Main thread.
//An instance of this class is sent as param and main
//thread calls execute on the Instance
//
class CPropPageExecContext : public CBaseRoleExecContext
{
public:
	virtual void Execute(LPARAM /*arg*/);
	
	CTreeNode* pTreeNode;
	CComponentDataObject* pComponentDataObject;
};

//
//Helper class for displaying help from property page
//
class CDisplayHelpFromPropPageExecContext : public CBaseRoleExecContext
{
public:
	virtual void Execute(LPARAM /*arg*/);
	CString m_strHelpPath;
	CComponentDataObject* m_pComponentDataObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\containernodes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       Rolecont.h
//
//  Contents:   Class declaration of Base Container class
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
//forward declarations
class CRolePropertyPageHolder;
class CAdminManagerNode;
/******************************************************************************
Class:  CBaseNode
Purpose: This common base class for all snapins node
******************************************************************************/
class CBaseNode
{
public:
    CBaseNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CBaseAz* pBaseAz,
              BOOL bDeleteBaseAzInDestructor = TRUE);

    virtual 
    ~CBaseNode();

    virtual CBaseAz*
    GetBaseAzObject() 
    {
        return m_pBaseAz;
    }

    virtual CSidHandler*
    GetSidHandler();

    CRoleComponentDataObject* 
    GetComponentDataObject()
    {
        return m_pComponentDataObject;
    }
    CAdminManagerNode* 
    GetAdminManagerNode()
    {
        return m_pAdminManagerNode;
    }
    void
    SetComponentDataObject(CRoleComponentDataObject * pComponentDataObject)
    {
        m_pComponentDataObject = pComponentDataObject;
    }
    void
    SetAdminManagerNode(CAdminManagerNode* pAdminManagerNode)
    {
        m_pAdminManagerNode = pAdminManagerNode;
    }

    virtual HRESULT 
    DeleteAssociatedBaseAzObject();

    virtual BOOL
    IsNodeDeleteable(){ return TRUE;};

private:
    CRoleComponentDataObject * m_pComponentDataObject;
    CAdminManagerNode* m_pAdminManagerNode;
    CBaseAz* m_pBaseAz;
    BOOL m_bDeleteBaseAzInDestructor;
};

/******************************************************************************
Class:  CBaseContainerNode
Purpose: This is the base class for snapin nodes which can contain 
child nodes.
******************************************************************************/
class CBaseContainerNode: public CContainerNode, public CBaseNode
{
public:
    CBaseContainerNode(CRoleComponentDataObject * pComponentDataObject,
                       CAdminManagerNode* pAdminManagerNode,
                       CContainerAz* pContainerAz,
                       OBJECT_TYPE_AZ* pChildObjectTypes,
                       LPCONTEXTMENUITEM2 pContextMenu,
                       BOOL bDeleteBaseAzInDestructor = TRUE);
    
    virtual 
    ~CBaseContainerNode();

    CContainerAz* 
    GetContainerAzObject(){return (CContainerAz*)GetBaseAzObject();}
protected:
    //Get Type/Name/Description
    virtual const 
    CString& GetType() = 0;
    
    virtual const 
    CString& GetName() = 0;
    
    virtual const 
    CString& GetDesc() = 0;

    virtual void
    DoCommand(LONG ,
              CComponentDataObject*,
              CNodeList*){};

    //Helper Functions for enumeration
    HRESULT 
    AddChildNodes();
    
    HRESULT 
    AddAzCollectionNode(OBJECT_TYPE_AZ eObjectType);
    
    HRESULT 
    EnumAndAddAzObjectNodes(OBJECT_TYPE_AZ eObjectType);
private:
    OBJECT_TYPE_AZ* m_pChildObjectTypes;
    LPCONTEXTMENUITEM2 m_pContextMenu;

public:
    //  
    //CTreeNode method overrides
    //
    virtual HRESULT 
    GetResultViewType(CComponentDataObject* pComponentData,
                            LPOLESTR* ppViewType, 
                     long* pViewOptions);   

    virtual BOOL 
    OnAddMenuItem(LPCONTEXTMENUITEM2,
                      long*);
    
    virtual 
    CColumnSet* GetColumnSet();
    
    virtual LPCWSTR 
    GetColumnID()
    {
        return GetColumnSet()->GetColumnID();
    }
    
    virtual LPCWSTR 
    GetString(int nCol);
    
    virtual int 
    GetImageIndex(BOOL bOpenImage);
    
    //
    // Verb handlers
    //
    virtual void 
    OnDelete(CComponentDataObject* pComponentData, 
                CNodeList* pNodeList);
    
    virtual HRESULT 
    OnCommand(long, 
                 DATA_OBJECT_TYPES, 
                 CComponentDataObject*,
                 CNodeList*);

    virtual BOOL 
    OnSetRefreshVerbState(DATA_OBJECT_TYPES /*type*/, 
                         BOOL* pbHide, 
                         CNodeList* /*pNodeList*/)
    {
        *pbHide = FALSE;
        return TRUE;
    }

    LPCONTEXTMENUITEM2 
    OnGetContextMenuItemTable()
    {
        return m_pContextMenu;
    }

    virtual BOOL 
    OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                        BOOL* pbHide, 
                        CNodeList* pNodeList);  

    virtual BOOL 
    CanCloseSheets();

    virtual BOOL 
    OnEnumerate(CComponentDataObject*, 
                    BOOL bAsync = TRUE);

private:
    CColumnSet* m_pColumnSet;
};




/******************************************************************************
Class:  CAzContainerNode
Purpose: Snapin Nodes for BaseAz Objects which can contain other child 
objects use CAzContainerNode as base class
******************************************************************************/
class CAzContainerNode: public CBaseContainerNode
{
public:
    CAzContainerNode(CRoleComponentDataObject * pComponentDataObject,
                     CAdminManagerNode* pAdminManagerNode,
                     OBJECT_TYPE_AZ* pChildObjectTypes,
                     LPCONTEXTMENUITEM2 pContextMenu,
                     CContainerAz* pContainerAz);

    virtual 
    ~CAzContainerNode();

protected:
    virtual HRESULT 
    AddOnePageToList(CRolePropertyPageHolder * /*pHolder*/, UINT /*nPageNumber*/)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
    
    //Get Type/Name/Description
    virtual const   CString& 
    GetType()
    {
        return GetBaseAzObject()->GetType();
    }
    
    virtual const CString& 
    GetName()
    {
        return GetBaseAzObject()->GetName();
    }
    
    virtual const CString& 
    GetDesc()
    {
        return GetBaseAzObject()->GetDescription();
    }
private:
public:
    virtual BOOL 
    HasPropertyPages(DATA_OBJECT_TYPES type, 
                    BOOL* pbHideVerb, 
                    CNodeList* pNodeList); 

    virtual HRESULT 
    CreatePropertyPages(LPPROPERTYSHEETCALLBACK,
                              LONG_PTR,
                       CNodeList*); 

    virtual void 
    OnPropertyChange(CComponentDataObject* pComponentData,
                          BOOL bScopePane,
                          long changeMask);

};

/******************************************************************************
Class:  CCollectionNode
Purpose: Base Class for snapin nodes which are used to group objects of 
            same type.
******************************************************************************/
class CCollectionNode: public CBaseContainerNode
{
public:
    CCollectionNode(CRoleComponentDataObject * pComponentDataObject,
                    CAdminManagerNode* pAdminManagerNode,
                    OBJECT_TYPE_AZ* pChildObjectTypes,
                    LPCONTEXTMENUITEM2 pContextMenu,
                    CContainerAz* pContainerAzObject,
                    UINT nNameStringID,
                    UINT nTypeStringID,
                    UINT nDescStringID);

    
    virtual 
    ~CCollectionNode();

    virtual BOOL
    IsNodeDeleteable(){ return FALSE;};

    virtual int 
    GetImageIndex(BOOL /*bOpenImage*/)
    {
        return iIconContainer;
    }


protected:
    virtual const 
    CString& GetType(){return m_strType;}
    
    virtual const 
    CString& GetName(){return m_strName;}
    
    virtual const 
    CString& GetDesc(){return m_strDesc;}

    
private:
    CString m_strName;
    CString m_strType;
    CString m_strDesc;
};
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       AdminMangerCont.h
//
//  Contents:   
//
//  History:    08-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

//Forward Declarations
class CGroupNode;
class CTaskNode;
class CRoleNode;
class COperationNode;
class CRolePropertyPageHolder;

/******************************************************************************
Class:  CAdminManagerNode
Purpose: Snapin Node for AdminManager object
******************************************************************************/
class CAdminManagerNode : public CAzContainerNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];

    CAdminManagerNode(CRoleComponentDataObject * pComponentDataObject,
                      CAdminManagerAz* pAdminManagerAz);
    
    ~CAdminManagerNode();   
    
    static HRESULT 
    CreateFromStream(IN IStream* pStm, 
                          IN CRootData* pRootData,
                          IN CComponentDataObject * pComponentDataObject);

    
    HRESULT 
    SaveToStream(IStream* pStm);

    const CString&
    GetScriptDirectory();
    
    void
    SetScriptDirectory(const CString& strScriptDirectory)
    {
        m_strScriptDirectory = strScriptDirectory;
    }

    void 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);


    HRESULT
    DeleteAssociatedBaseAzObject();

    CSidHandler*
    GetSidHandler()
    {
        return ((CAdminManagerAz*)GetContainerAzObject())->GetSidHandler();
    }

    virtual const 
    CString& GetName() { return ((CAdminManagerAz*)GetContainerAzObject())->GetDisplayName();}

    
    DECLARE_NODE_GUID()
protected:
    virtual HRESULT 
    AddOnePageToList(CRolePropertyPageHolder *pHolder, 
                          UINT nPageNumber);    
    virtual BOOL 
    OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
                  long *pInsertionAllowed);
private:
    CString m_strScriptDirectory;
};


/******************************************************************************
Class:  CApplicationNode
Purpose: Snapin Node for Application object
******************************************************************************/
class CApplicationNode: public CAzContainerNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];

    CApplicationNode(CRoleComponentDataObject * pComponentDataObject,
                     CAdminManagerNode* pAdminManagerNode,
                     CApplicationAz* pApplicationAz);
    virtual 
    ~CApplicationNode();
    
    void 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);

    
    DECLARE_NODE_GUID()

protected:
    virtual HRESULT 
    AddOnePageToList(CRolePropertyPageHolder *pHolder, 
                          UINT nPageNumber);
};


/******************************************************************************
Class:  CScopeNode
Purpose: Snapin Node for Scope object
******************************************************************************/
class CScopeNode: public CAzContainerNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];
    
    CScopeNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CScopeAz* pApplicationAz);
    
    virtual 
    ~CScopeNode();

    DECLARE_NODE_GUID()

protected:
    virtual HRESULT 
    AddOnePageToList(CRolePropertyPageHolder *pHolder, 
                          UINT nPageNumber);
};

/******************************************************************************
Class:  CGroupCollectionNode
Purpose: Snapin Node under which all the groups will be listed
******************************************************************************/
class CGroupCollectionNode:public CCollectionNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];

    CGroupCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject);
    
    virtual 
    ~CGroupCollectionNode();

    enum {IDS_NAME = IDS_NAME_GROUP_CONTAINER,
          IDS_TYPE = IDS_TYPE_GROUP_CONTAINER,
          IDS_DESC = IDS_DESC_GROUP_CONTAINER};

    void 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);


    DECLARE_NODE_GUID()
};

/******************************************************************************
Class:  CRoleDefinitionCollectionNode
Purpose: Snapin Node under which all the Role definitions will be listed
******************************************************************************/
class CRoleDefinitionCollectionNode:public CCollectionNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];
    
    CRoleDefinitionCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject);
    
    virtual 
    ~CRoleDefinitionCollectionNode();

    enum {IDS_NAME = IDS_NAME_ROLE_DEFINITION_CONTAINER,
           IDS_TYPE = IDS_TYPE_ROLE_DEFINITION_CONTAINER,
            IDS_DESC = IDS_DESC_ROLE_DEFINITION_CONTAINER};

    void 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);

    
    BOOL 
    OnEnumerate(CComponentDataObject*, BOOL );

    DECLARE_NODE_GUID()

};

/******************************************************************************
Class:  CTaskCollectionNode
Purpose: Snapin Node under which all the Tasks will be listed
******************************************************************************/
class CTaskCollectionNode:public CCollectionNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];
    
    CTaskCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject);
    
    virtual 
    ~CTaskCollectionNode();

    enum {IDS_NAME = IDS_NAME_TASK_CONTAINER,
          IDS_TYPE = IDS_TYPE_TASK_CONTAINER,
          IDS_DESC = IDS_DESC_TASK_CONTAINER};

    void 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);

    
    BOOL 
    OnEnumerate(CComponentDataObject*, BOOL );

    DECLARE_NODE_GUID()
};

/******************************************************************************
Class:  CRoleCollectionNode
Purpose: Snapin Node under which all the Roles will be listed
******************************************************************************/
class CRoleCollectionNode:public CCollectionNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];
    
    CRoleCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject);
    
    virtual 
    ~CRoleCollectionNode();

    enum {IDS_NAME = IDS_NAME_ROLE_CONTAINER,
          IDS_TYPE = IDS_TYPE_ROLE_CONTAINER,
          IDS_DESC = IDS_DESC_ROLE_CONTAINER};
    
    void 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);


    DECLARE_NODE_GUID()

private:
    BOOL 
    CreateNewRoleObject(CBaseAz* pBaseAz);
};

/******************************************************************************
Class:  COperationCollectionNode
Purpose: Snapin Node under which all the Operations will be listed
******************************************************************************/
class COperationCollectionNode:public CCollectionNode
{
public:
    static OBJECT_TYPE_AZ childObjectTypes[];
    
    COperationCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAzObject);
    
    virtual 
    ~COperationCollectionNode();

    enum {IDS_NAME = IDS_NAME_OPERATION_CONTAINER,
          IDS_TYPE = IDS_TYPE_OPERATION_CONTAINER,
          IDS_DESC = IDS_DESC_OPERATION_CONTAINER};

    VOID 
    DoCommand(LONG nCommandID,
              CComponentDataObject*,
              CNodeList*);


    DECLARE_NODE_GUID()
};

/******************************************************************************
Class:  CDefinitionCollectionNode
Purpose: Snapin Node under which all the Definions nodes will be listed
******************************************************************************/
class CDefinitionCollectionNode: public CCollectionNode
{
public: 
    CDefinitionCollectionNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,CContainerAz* pContainerAz);
    
    virtual 
    ~CDefinitionCollectionNode();
    
    enum {IDS_NAME = IDS_NAME_DEFINITION_CONTAINER,
           IDS_TYPE = IDS_TYPE_DEFINITION_CONTAINER,
            IDS_DESC = IDS_DESC_DEFINITION_CONTAINER};
    
    BOOL 
    OnEnumerate(CComponentDataObject*, BOOL bAsync = TRUE);

    DECLARE_NODE_GUID()
};

/******************************************************************************
Class:  CRoleNode
Purpose: Snapin Node for RoleAz object
******************************************************************************/
class CRoleNode:public CContainerNode, public CBaseNode
{   
public:
    CRoleNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CRoleAz* pRoleAz);
    
    virtual 
    ~CRoleNode();
    
    //CTreeNode method overrides
    virtual HRESULT 
    GetResultViewType(CComponentDataObject* pComponentData,
                      LPOLESTR* ppViewType, 
                      long* pViewOptions);  

    virtual BOOL 
    OnAddMenuItem(LPCONTEXTMENUITEM2,long*);
    
    virtual CColumnSet* 
    GetColumnSet();
    
    virtual LPCWSTR 
    GetColumnID(){return GetColumnSet()->GetColumnID();}
    
    virtual LPCWSTR 
    GetString(int nCol);
    
    virtual int 
    GetImageIndex(BOOL bOpenImage);
    
    // Verb handlers
    BOOL 
    OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                     BOOL* pbHide, 
                     CNodeList* pNodeList);

    virtual void 
    OnDelete(CComponentDataObject* pComponentData, 
                CNodeList* pNodeList);
    
    virtual HRESULT 
    OnCommand(long, 
                 DATA_OBJECT_TYPES, 
                 CComponentDataObject*,
                 CNodeList*);

    virtual BOOL 
    OnSetRefreshVerbState(DATA_OBJECT_TYPES /*type*/, 
                         BOOL* pbHide, 
                         CNodeList* /*pNodeList*/)
    {
        *pbHide = FALSE;
        return TRUE;
    }

    LPCONTEXTMENUITEM2 
    OnGetContextMenuItemTable()
    {
        return CRoleNodeMenuHolder::GetContextMenuItem();
    }

    virtual BOOL 
    OnEnumerate(CComponentDataObject*, 
                    BOOL bAsync = TRUE);
    BOOL 
    HasPropertyPages(DATA_OBJECT_TYPES /*type*/, 
                     BOOL* pbHideVerb, 
                     CNodeList* pNodeList);


    HRESULT 
    CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle,
                        CNodeList* pNodeList);

    void 
    OnPropertyChange(CComponentDataObject* pComponentData,
                     BOOL bScopePane,
                     long changeMask);

    DECLARE_NODE_GUID()

private:
    void
    AssignUsersAndGroups(IN CComponentDataObject* pComponentData,
                                IN ULONG nCommandID);

    void
    AddObjectsFromListToSnapin(CList<CBaseAz*,CBaseAz*> &listObjects,
                               CComponentDataObject* pComponentData,
                               BOOL bAddToUI);

    CColumnSet* m_pColumnSet;
};





void 
GenericDeleteRoutine(CBaseNode* pBaseNode,
                     CComponentDataObject* pComponentData, 
                     CNodeList* pNodeList,
                     BOOL bConfirmDelete);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       debug.hxx
//
//  Contents:   Debugging macros
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_HXX_
#define __DEBUG_HXX_

#include "stddbg.h"

#undef DEBUG_DECLARE_INSTANCE_COUNTER
#undef DEBUG_INCREMENT_INSTANCE_COUNTER
#undef DEBUG_DECREMENT_INSTANCE_COUNTER
#undef DEBUG_VERIFY_INSTANCE_COUNT

//
//We have DEB_USER1 to DEB_USER10 for custom debugging
//

#define DEB_PERF			DEB_USER1	//Timer info will be shown
#define DEB_DLL			DEB_USER2	//Use this for all the Sanpin 
												//Initialization stuff
#define DEB_SNAPIN		DEB_USER3	//Used for Snapin About

#if (DBG == 1)

//============================================================================
//
// Debug version
//
//============================================================================

#define DBG_COMP    roleInfoLevel
DECLARE_DEBUG(role)

#define DBG_OUT_HRESULT(hr) \
        DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr)

#define DBG_OUT_LRESULT(lr) \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr)

void
SayNoItf(
    PCSTR szComponent,
    REFIID riid);

#define DBG_OUT_NO_INTERFACE(qi, riid)  SayNoItf((qi), (riid))


// Instance counter

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
	//Fine to truncate
    if(SUCCEEDED(StringCchPrintfA(buf,sizeof(buf)/sizeof(char), "%s has %d instances left over.", pszClassName, cInstRem)))
    {
        //lint -save -e64
        Dbg(DEB_ERROR, "Memory leak: %hs\n", buf);
        //lint -restore
        ::MessageBoxA(NULL, buf, "OPD: Memory Leak", MB_OK);
    }
}

#define DEBUG_DECLARE_INSTANCE_COUNTER(cls)                 \
            int s_cInst_##cls = 0;

#define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)               \
            extern int s_cInst_##cls;                       \
            InterlockedIncrement((LPLONG) &s_cInst_##cls);

#define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)               \
            extern int s_cInst_##cls;                       \
            InterlockedDecrement((LPLONG) &s_cInst_##cls);

#define DEBUG_VERIFY_INSTANCE_COUNT(cls)                    \
            extern int s_cInst_##cls;                       \
                                                            \
            if (s_cInst_##cls)                              \
            {                                               \
                DbgInstanceRemaining(#cls, s_cInst_##cls);  \
            }

//+--------------------------------------------------------------------------
//
//  Class:      CTimer
//
//  Purpose:    Display on debugger time from ctor invocation to dtor
//              invocation.
//
//  History:    12-16-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

class CTimer
{
public:

    CTimer(): m_ulStart(0) { m_wzTitle[0] = L'\0'; };
    void __cdecl Init(LPCSTR pszTitleFmt, ...);
   ~CTimer();

private:

    ULONG   m_ulStart;
    WCHAR   m_wzTitle[512];
};

#define TIMER       CTimer TempTimer; TempTimer.Init

#define PING(msg)   DBG_COMP.PingDc(msg)



#else // !(DBG == 1)

//============================================================================
//
// Retail version
//
//============================================================================

#define DBG_OUT_HRESULT(hr)
#define DBG_OUT_LRESULT(lr)
#define DBG_DUMP_QUERY(title, query)
#define DBG_OUT_NO_INTERFACE(qi, riid)

#define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
#define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
#define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
#define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#define TIMER       ConsumePrintf
#define PING(msg)

inline void __cdecl ConsumePrintf(void *fmt, ...)
{
}

#endif // !(DBG == 1)

#endif // __DEBUG_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\debug.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       debug.cxx
//
//  Contents:   Debugging routines
//
//  History:    09-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.h"
#pragma hdrstop

DECLARE_INFOLEVEL(role)


#if (DBG == 1)

ULONG CDbg::s_idxTls;



void __cdecl
CTimer::Init(LPCSTR pszTitleFmt, ...)
{
    va_list va;
    va_start(va, pszTitleFmt);

    m_ulStart = GetTickCount();
    WCHAR wzTitleFmt[MAX_PATH];

    MultiByteToWideChar(CP_ACP,
                        0,
                        pszTitleFmt,
                        -1,
                        wzTitleFmt,
                        ARRAYLEN(wzTitleFmt));

    int iRet = _vsnwprintf(m_wzTitle, ARRAYLEN(m_wzTitle), wzTitleFmt, va);

    if (iRet == -1)
    {
        // resulting string too large and was truncated.  ensure null
        // termination.

        m_wzTitle[ARRAYLEN(m_wzTitle) - 1] = L'\0';
    }
    va_end(va);

}




CTimer::~CTimer()
{
    ULONG ulStop = GetTickCount();
    ULONG ulElapsedMS = ulStop - m_ulStart;

    ULONG ulSec = ulElapsedMS / 1000;
    ULONG ulMillisec = ulElapsedMS - (ulSec * 1000);

    Dbg(DEB_PERF, "Timer: %ws took %u.%03us\n", m_wzTitle, ulSec, ulMillisec);
}




PCWSTR
NextNonWs(
        PCWSTR pwzCur)
{
    while (wcschr(L" \t\n", *pwzCur))
    {
        pwzCur++;
    }
    return pwzCur;
}







//+--------------------------------------------------------------------------
//
//  Function:   IsSingleBitFlag
//
//  Synopsis:   Return TRUE if exactly one bit in [flags] is set, FALSE
//              otherwise.
//
//  History:    08-31-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsSingleBitFlag(
    ULONG flags)
{
    if (!flags)
    {
        return FALSE;
    }

    while (!(flags & 1))
    {
        flags >>= 1;
    }

    return !(flags & ~1UL);
}



#define DUMP_IF_SET(fl, bit)                    \
    if (((fl) & (bit)) == (bit))                \
    {                                           \
        Dbg(DEB_TRACE, "    %hs\n", #bit);      \
    }



void
IIDtoString(
    REFIID riid,
    CString *pstr)
{
    HRESULT     hr = S_OK;
    ULONG       lResult;
    LPOLESTR    pwzIID = NULL;
    HKEY        hkInterface = NULL;
    HKEY        hkIID = NULL;

    do
    {
        hr = StringFromIID(riid, &pwzIID);
        if (FAILED(hr)) break;

        lResult = RegOpenKey(HKEY_CLASSES_ROOT, L"Interface", &hkInterface);
        if (lResult != NO_ERROR) break;

        lResult = RegOpenKey(hkInterface, pwzIID, &hkIID);
        if (lResult != NO_ERROR) break;

        WCHAR wzInterfaceName[MAX_PATH] = L"";
        ULONG cbData = sizeof(wzInterfaceName);

        lResult = RegQueryValueEx(hkIID,
                                  NULL,
                                  NULL,
                                  NULL,
                                  (PBYTE)wzInterfaceName,
                                  &cbData);

        if (*wzInterfaceName)
        {
            *pstr = wzInterfaceName;
        }
        else
        {
            *pstr = pwzIID;
        }
    } while (0);

    if (hkIID)
    {
        RegCloseKey(hkIID);
    }

    if (hkInterface)
    {
        RegCloseKey(hkInterface);
    }

    CoTaskMemFree(pwzIID);
}

void
SayNoItf(
    PCSTR szComponent,
    REFIID riid)
{
    CString strIID;

    IIDtoString(riid, &strIID);
    Dbg(DEB_ERROR, "%hs::QI no interface %ws\n", szComponent, strIID);
}



#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       dllmain.cpp
//
//  Contents:   Module, Object Map and DLL entry points. Most of the code
//					 in this file is taken from Dns Manager Snapin implementation
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

//
//CRoleMgrModule Implementation
//

HRESULT WINAPI CRoleMgrModule::UpdateRegistryCLSID(const CLSID& clsid, 
																	BOOL bRegister)
{
	TRACE_METHOD_EX(DEB_DLL, CRoleMgrModule, UpdateRegistryCLSID);

	static const WCHAR szIPS32[] = _T("InprocServer32");
	static const WCHAR szCLSID[] = _T("CLSID");

	HRESULT hRes = S_OK;

	LPOLESTR lpOleStrCLSIDValue = NULL;
	::StringFromCLSID(clsid, &lpOleStrCLSIDValue);
	if (lpOleStrCLSIDValue == NULL)
	{	
		DBG_OUT_HRESULT(E_OUTOFMEMORY);	
		return E_OUTOFMEMORY;
	}

	CRegKey key;
	if (bRegister)
	{
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
		CHECK_LASTERROR(lRes);

		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpOleStrCLSIDValue);
			CHECK_LASTERROR(lRes);
			if (lRes == ERROR_SUCCESS)
			{
				WCHAR szModule[_MAX_PATH + 1];
				ZeroMemory(szModule,sizeof(szModule));
				::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
				lRes = key.SetKeyValue(szIPS32, szModule);
				CHECK_LASTERROR(lRes);
			}
		}
		if (lRes != ERROR_SUCCESS)
			hRes = HRESULT_FROM_WIN32(lRes);
	}
	else
	{
		key.Attach(HKEY_CLASSES_ROOT);
		if (key.Open(key, szCLSID) == ERROR_SUCCESS)
			key.RecurseDeleteKey(lpOleStrCLSIDValue);
	}
	::CoTaskMemFree(lpOleStrCLSIDValue);
	return hRes;
}

//
//Module
//
CRoleMgrModule _Module;

//
//Object Pikcer Clipboard format
//
UINT g_cfDsSelectionList = 0;


//
//Object Map
//
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_RoleSnapin, CRoleComponentDataObject)		// standalone snapin
   OBJECT_ENTRY(CLSID_RoleSnapinAbout, CRoleSnapinAbout)	// standalone snapin about
END_OBJECT_MAP()

CCommandLineOptions commandLineOptions;

//
//CRoleSnapinApp implementation
//
BOOL CRoleSnapinApp::InitInstance()
{
	#if (DBG == 1)
		CDbg::s_idxTls = TlsAlloc();
	#endif // (DBG == 1)

	TRACE_METHOD_EX(DEB_DLL,CRoleSnapinApp,InitInstance);
	
	_Module.Init(ObjectMap, m_hInstance);

	g_cfDsSelectionList = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


	//
	// Add theming support
	//
	SHFusionInitializeFromModuleID(m_hInstance, 2);

	//
	//Load Menus, Header Strings etc.
	//
	if (!CRoleComponentDataObject::LoadResources())
		return FALSE;

    commandLineOptions.Initialize();
    
    //Register Class for link window
    LinkWindow_RegisterClass();
    
	return CWinApp::InitInstance();
}

int CRoleSnapinApp::ExitInstance()
{
	TRACE_METHOD_EX(DEB_DLL,CRoleSnapinApp,ExitInstance);
	
	//
	//Theming support
	//
	SHFusionUninitialize();

    //Unregister class for link window
    LinkWindow_UnregisterClass(m_hInstance);

	//
	//CComModule Termintaion
	//
	_Module.Term();

	return CWinApp::ExitInstance();
}

CRoleSnapinApp theApp;

//
//Exported Functions
//
STDAPI DllCanUnloadNow(void)
{
	TRACE_FUNCTION_EX(DEB_DLL,DllCanUnloadNow);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if ((AfxDllCanUnloadNow() == S_OK) && (_Module.GetLockCount()==0)) 
	{
		Dbg(DEB_DLL, "Can Unload\n");
		return S_OK;	
	}		
	else
	{
		Dbg(DEB_DLL, "Cannot Unload, %u locks\n",_Module.GetLockCount());
		return S_FALSE;
	}
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	TRACE_FUNCTION_EX(DEB_DLL, DllGetClassObject);

	return _Module.GetClassObject(rclsid, riid, ppv);
}

//
//Add the Guids of nodes which can be extended by other snapin
//
static _NODE_TYPE_INFO_ENTRY NodeTypeInfoEntryArray[] = {
	{ NULL, NULL }
};



STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	TRACE_FUNCTION_EX(DEB_DLL, DllRegisterServer);

	//
	// registers all objects
	//
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	if (FAILED(hr))
	{
		DBG_OUT_HRESULT(hr);
		return hr;
	}

	CString 	szVersion =  VER_PRODUCTVERSION_STR;
	CString 	szProvider = VER_COMPANYNAME_STR;
	CString 	szSnapinName;
	szSnapinName.LoadString(IDS_SNAPIN_NAME);

	//
	// Register the standalone Role snapin into the console snapin list
	//
	hr = RegisterSnapin(&CLSID_RoleSnapin,
                       &CRoleRootData::NodeTypeGUID,
                       &CLSID_RoleSnapinAbout,
						     szSnapinName, 
							  szVersion, 
							  szProvider,
							  FALSE,
							  NodeTypeInfoEntryArray,
							  IDS_SNAPIN_NAME);

	if (FAILED(hr))
	{
		DBG_OUT_HRESULT(hr);
		return hr;
	}
	
	return hr;
}

STDAPI DllUnregisterServer(void)
{
	TRACE_FUNCTION_EX(DEB_DLL, DllUnregisterServer);

	HRESULT hr  = _Module.UnregisterServer();
	ASSERT(SUCCEEDED(hr));

	//
	// Un register the standalone snapin
	//
	hr = UnregisterSnapin(&CLSID_RoleSnapin);
	ASSERT(SUCCEEDED(hr));

	//
	// unregister the snapin nodes,
	// this removes also the server node, with the Services Snapin extension keys
	//
	for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = NodeTypeInfoEntryArray;
			pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
	{
		hr = UnregisterNodeType(pCurrEntry->m_pNodeGUID);
		ASSERT(SUCCEEDED(hr));
	}

	ASSERT(SUCCEEDED(hr));

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\dllmain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.hxx
//
//  Contents:   dll entry point
//
//  History:    07-27-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------


//
//CRoleMgrModule
//
class CRoleMgrModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

extern CRoleMgrModule _Module;
extern UINT g_cfDsSelectionList;
//
// CRoleSnapinApp
//
class CRoleSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

extern CRoleSnapinApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\enumaz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       enumaz.h
//
//  Contents:   
//
//  History:    08-13-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

//
//Forward Declaration
//
class CApplicationAz;
class CGroupAz;
class COperationAz;
class CTaskAz;
class CScopeAz;
class CRoleAz;
class CBaseAz;
class CContainerAz;

class CBaseAzCollection
{
public:
	virtual ~CBaseAzCollection(){}
	virtual HRESULT Count(LONG* plCount) = 0;
	virtual CBaseAz* GetItem(UINT iIndex) = 0;
};

template<class IAzCollection, class IAzInterface, class CObjectAz>
class CAzCollection:public CBaseAzCollection
{
public:
	CAzCollection(CComPtr<IAzCollection>& spAzCollection,
					  CContainerAz* pParentContainerAz);
	virtual ~CAzCollection();

	HRESULT Count(LONG* plCount);

	CBaseAz* GetItem(UINT iIndex);

	CBaseAz* GetParentAzObject(){return m_pParentBaseAz;}
private:
	CComPtr<IAzCollection> m_spAzCollection;
	//
	//This is the parent of all the AzObjects returned by
	//Next method.
	//
	CContainerAz* m_pParentContainerAz;
};

#include"enumaz.cpp"

typedef CAzCollection<IAzApplications,IAzApplication,CApplicationAz> APPLICATION_COLLECTION;
typedef CAzCollection<IAzApplicationGroups,IAzApplicationGroup,CGroupAz> GROUP_COLLECTION;
typedef CAzCollection<IAzOperations,IAzOperation,COperationAz> OPERATION_COLLECTION;
typedef CAzCollection<IAzTasks,IAzTask,CTaskAz> TASK_COLLECTION;
typedef CAzCollection<IAzScopes,IAzScope,CScopeAz> SCOPE_COLLECTION;
typedef CAzCollection<IAzRoles,IAzRole,CRoleAz> ROLE_COLLECTION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\gstrings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       gstrings.h
//
//  Contents:   Constant strings used by this app
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

extern LPCWSTR g_szContextHelpFileName;
extern LPCWSTR g_szHTMLHelpFileName;
extern LPCWSTR g_szLinkHTMLHelpFileName;
extern LPCWSTR g_szTopHelpNodeName;
extern LPCWSTR g_szVBScript;
extern LPCWSTR g_szJavaScript;
extern LPCWSTR g_szMSXML;
extern LPCWSTR g_szMSLDAP;
extern LPCWSTR g_szLDAP;
extern LPCWSTR g_pszAuthorizationStoreQueryFilter;
extern LPCWSTR g_pszFileStoreExtension;
extern LPCWSTR g_pszProgramDataPrefix;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\gstrings.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       gstrings.cpp
//
//  Contents:   Constant strings used by this app
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

LPCWSTR g_szContextHelpFileName = L"authm.hlp";
LPCWSTR g_szHTMLHelpFileName = L"\\help\\authmsnp.chm";
LPCWSTR g_szLinkHTMLHelpFileName = L"authm.chm";
LPCWSTR g_szTopHelpNodeName = L"Authm_topnode.htm";
LPCWSTR g_szVBScript = L"VBScript";
LPCWSTR g_szJavaScript = L"JScript";
LPCWSTR g_szMSXML = L"msxml://";
LPCWSTR g_szMSLDAP = L"msldap://";
LPCWSTR g_szLDAP = L"LDAP://";
LPCWSTR g_pszAuthorizationStoreQueryFilter = L"(objectCategory=msDS-AzAdminManager)";
LPCWSTR g_pszFileStoreExtension = L".xml";
LPCWSTR g_pszProgramDataPrefix = L"CN=Program Data,";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\enumaz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       EnumAz.cpp
//
//
//  History:    8-13-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#include "headers.h"

//DEBUG_DECLARE_INSTANCE_COUNTER(CAzCollection);

template<class IAzCollection, class IAzInterface, class CObjectAz>
CAzCollection<IAzCollection, IAzInterface, CObjectAz>
::CAzCollection(CComPtr<IAzCollection>& spAzCollection,
					 CContainerAz* pParentContainerAz)
					 :m_spAzCollection(spAzCollection),
					 m_pParentContainerAz(pParentContainerAz)
{
	TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CAzCollection);
//	DEBUG_INCREMENT_INSTANCE_COUNTER(CAzCollection);				
}
												
template<class IAzCollection, class IAzInterface, class CObjectAz>
CAzCollection<IAzCollection, IAzInterface, CObjectAz>
::~CAzCollection()
{
	TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CAzCollection);
//	DEBUG_DECREMENT_INSTANCE_COUNTER(CAzCollection##IAzCollection);
}

template<class IAzCollection, class IAzInterface, class CObjectAz>
HRESULT 
CAzCollection<IAzCollection, IAzInterface, CObjectAz>
::Count(LONG* plCount)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CAzCollection,Count)

	if(!plCount)
	{
		ASSERT(plCount);
		return E_POINTER;
	}
	HRESULT hr = m_spAzCollection->get_Count(plCount);
	CHECK_HRESULT(hr);
	return hr;
}


//
//
template<class IAzCollection, class IAzInterface, class CObjectAz>
CBaseAz* 
CAzCollection<IAzCollection, IAzInterface, CObjectAz>
::GetItem(UINT iIndex)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CAzCollection,Next);


	VARIANT var;
	VariantInit(&var);
	HRESULT hr = m_spAzCollection->get_Item(iIndex, &var);
	if(FAILED(hr))
	{
		//
		//*ppObjectAz is null and S_OK is returned when there are 
		//no more items. 
		//
		if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		{
			return NULL;
		}
		else
		{
			DBG_OUT_HRESULT(hr);
			return NULL;
		}			
	}
	
	ASSERT(VT_DISPATCH == var.vt);

	CComPtr<IDispatch> spDispatch = var.pdispVal;
	//VariantClear(&var);
	((IDispatch*)(var.pdispVal))->Release();
	CComPtr<IAzInterface>spAzInterface;

	hr = spDispatch.QueryInterface(&spAzInterface);
	if(FAILED(hr))
	{
		DBG_OUT_HRESULT(hr);
		return NULL;
	}
	//
	//Create CObjectAz and return it.
	//
	CObjectAz *pObjectAz = new CObjectAz(spAzInterface, m_pParentContainerAz);
	if(!pObjectAz)
	{
		hr = E_OUTOFMEMORY;
		DBG_OUT_HRESULT(hr);
		return NULL;
	}

 	return pObjectAz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\enumcontainer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\headers.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.cpp
//
//  Contents:   Predefined cpp File
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#include "headers.h"
#include "atlimpl.cpp"
#include "atlwin.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\headers.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   Master include file
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#ifndef __HEADERS_HXX_
#define __HEADERS_HXX_
//
// We have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.
//
#ifndef DBG
#pragma warning (disable: 4189 4100)
#endif

#define STRICT

#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "seopaque.h"   // RtlObjectAceSid, etc.



#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

//
// C++ RTTI
//
#include "typeinfo.h"
#define IS_CLASS(x,y) (typeid(x) == typeid(y))

//
// MFC Headers
//
#include "afxwin.h"
#include "afxdisp.h"
#include "afxdlgs.h"
#include "afxcmn.h"
#include "afxtempl.h"
#include "prsht.h"

//
//ATL Headers
//
#include <atlbase.h>

//
//Directory Service
//
#include <dsgetdc.h>    // DsGetDcName
#include <dsrole.h>     // DsRoleGetPrimaryDomainInformation

// Downlevel networking and security
#include <ntlsa.h>      // PLSA_HANDLE
#include <lmaccess.h>   // required by lmapibuf.h
#include <lmapibuf.h>   // NetApiBufferFree


#include "winldap.h"
#include "Ntdsapi.h"
#define SECURITY_WIN32
#include <security.h>   // TranslateName
#include <lm.h>         // NetApiBufferFree

#include "sddl.h"                       //ConvertStringSidToSid

#include "iads.h"

#include <objsel.h>     // DS Object Picker

//
//RoleManager Snapin Include File
//
#include "dllmain.h"

//
//More ATL Headers. They need to be after dllmain.h as
//they require _Module object
//
#include <atlcom.h>

/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE

#include <atlapp.h>
#include <atlwin.h>
#include <atlctrls.h>

#include "Dsclient.h"
//
// MMC Headers
//
#include "mmc.h"

#include "shlobjp.h"
//
//Fusion
//
#include <shfusion.h>

//
// Version info
//
#include <ntverp.h>

//
//Role Based Authorization Header file
//
#include <initguid.h>
#include "azroles.h"

//
// Standard Template Library
//

// STL won't build at warning level 4, bump it down to 3

#pragma warning(push,3)
//#include <memory>
#include <vector>
#include <map>
#include <set>
#include <list>
#pragma warning(disable: 4702)  // unreachable code
#include <algorithm>
#pragma warning(default: 4702)  // unreachable code
#include <utility>
// resume compiling at level 4
#pragma warning (pop)


using namespace std;

//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

//contains some inline functions to ease the retrieval of ADsOpenObject 
//flags dealing with the signing and sealing of LDAP traffic.  
#include "ADsOpenFlags.h"


//Framwork include file
//
#include "snapbase.h"

//
//RoleManager Snapin Include Files
//
#include "resource.h"
#include "macro.h"
#include "debug.h"
#include "gstrings.h"
#include "adinfo.h"
#include "rolesnap.h"
#include "rootdata.h"
#include "comp.h"
#include "compdata.h"
#include "snapabout.h"
#include "query.h"
#include "SidCache.h"
#include "EnumAz.h"
#include "BaseAz.h"
#include "AzImpl.cpp"
#include "AdminManagerAz.h"
#include "ContainerNodes.h"
#include "AttrMap.h"
#include "NewObjectDlg.h"
#include "LeafNodes.h"
#include "AddDlg.h"
#include "util.h"
#include "PropBase.h"
///////////////////////////////////////////////////////////////////
// workaround macro for MFC bug
// (see NTRAID 227193 and MFC "Monte Carlo" RAID db # 1034)

#define FIX_THREAD_STATE_MFC_BUG() \
        AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState(); \
  CWinThread _dummyWinThread; \
        if (pState->m_pCurrentWinThread == NULL) \
  { \
    pState->m_pCurrentWinThread = &_dummyWinThread; \
  }


//
// This determines whether or not the NDNC functionality is enabled or disabled
//
#define USE_NDNC

//Class For LinkControl
#define LINKWINDOW_CLASSW       L"Link Window"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\helpmap.cpp ===
#define BEGIN_HELP_ARRAY(x)	const DWORD g_aHelpIDs_##x[]={ ,
#define END_HELP_ARRAY		 0, 0 };
#define ARRAY_ENTRY(x,y) y, IDH_##x_##y,

//IDD_ADD_GROUP
BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    ARRAY_ENTRY(IDD_ADD_GROUP,IDC_LIST)
END_HELP_ARRAY

/*
//IDD_ADD_OPERATION
BEGIN_HELP_ARRAY(IDD_ADD_OPERATION)
    IDC_LIST,				IDH_LIST_ADD_OPERATION,
END_HELP_ARRAY

//IDD_ADD_ROLE_DEFINITION
BEGIN_HELP_ARRAY(IDD_ADD_ROLE_DEFINITION)
    IDC_LIST,				IDH_LIST_ADD_ROLE_DEFINITION,
END_HELP_ARRAY

//IDD_ADD_TASK
BEGIN_HELP_ARRAY(IDD_ADD_TASK)
    IDC_LIST,				IDH_LIST_ADD_TASK,
END_HELP_ARRAY

//IDD_ADMIN_MANAGER_ADVANCED_PROPERTY
BEGIN_HELP_ARRAY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY)
    IDC_EDIT_DOMAIN_TIMEOUT,				IDH_EDIT_DOMAIN_TIMEOUT,
	IDC_EDIT_SCRIPT_ENGINE_TIMEOUT,			IDH_EDIT_SCRIPT_ENGINE_TIMEOUT,
	IDC_EDIT_MAX_SCRIPT_ENGINE,				IDH_EDIT_MAX_SCRIPT_ENGINE,
END_HELP_ARRAY

//IDD_ADMIN_MANAGER_GENERAL_PROPPERTY
BEGIN_HELP_ARRAY(IDD_ADMIN_MANAGER_GENERAL_PROPPERTY)
    IDC_EDIT_NAME,				IDH_EDIT_NAME,
	IDC_EDIT_DESCRIPTION,		IDH_EDIT_DESCRIPTION,
	IDC_EDIT_STORE_TYPE,		IDH_EDIT_STORE_TYPE,
END_HELP_ARRAY


BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY

BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    IDC_LIST,				IDH_LIST_ADD_GROUP,
END_HELP_ARRAY
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\macro.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       macros.hxx
//
//  Contents:   Miscellaneous useful macros
//
//  History:    09-08-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#ifndef __MACROS_HXX__
#define __MACROS_HXX__

#define ARRAYLEN(a)                             (sizeof(a) / sizeof((a)[0]))
#define CHECK_NULL(pwz)                         (pwz) ? (pwz) : L"NULL"


#define BREAK_ON_FAIL_LRESULT(lr)   \
        if ((lr) != ERROR_SUCCESS)  \
        {                           \
            DBG_OUT_LRESULT(lr);    \
            break;                  \
        }

#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }

#define BREAK_ON_FAIL_NTSTATUS(nts) \
        if (NT_ERROR(nts))          \
        {                           \
            DBG_OUT_HRESULT(nts);   \
            break;                  \
        }

#define BREAK_ON_FAIL_PROCESS_RESULT(npr)   \
        if (NAME_PROCESSING_FAILED(npr))    \
        {                                   \
            break;                          \
        }


#define RETURN_ON_FAIL_HRESULT(hr)  \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            return;                 \
        }

#define RETURN_HR_ON_FAIL_HRESULT(hr)  \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            return hr;                 \
        }

#define HRESULT_FROM_LASTERROR  HRESULT_FROM_WIN32(GetLastError())


#endif // __MACROS_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\leafnodes.h ===
/******************************************************************************
Class:	CBaseLeafNode
Purpose: BaseNode class for all the non container object. 
******************************************************************************/
class CBaseLeafNode : public CLeafNode, public CBaseNode
{
public:
	CBaseLeafNode(CRoleComponentDataObject * pComponentDataObject,
				  CAdminManagerNode* pAdminManagerNode,
				  CBaseAz* pBaseAz);
	
	virtual ~CBaseLeafNode();
	
	DECLARE_NODE_GUID()
protected:

	virtual HRESULT 
	AddOnePageToList(IN CRolePropertyPageHolder* /*pHolder*/, 
					 IN UINT /*nPageNumber*/)
	{
		return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
	}

private:
public:

	//
	//Baseclass OverRides
	//
	virtual BOOL 
	OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
								BOOL* pbHide, 
								CNodeList* pNodeList);

	virtual void
	OnDelete(CComponentDataObject* pComponentData,
				CNodeList* pNodeList);

	virtual LPCWSTR 
	GetString(int nCol);
	
	virtual int 
	GetImageIndex(BOOL bOpenImage);

	virtual BOOL 
	HasPropertyPages(DATA_OBJECT_TYPES type, 
                    BOOL* pbHideVerb, 
						  CNodeList* pNodeList);

	virtual HRESULT 
	CreatePropertyPages(LPPROPERTYSHEETCALLBACK,
                       LONG_PTR,
							  CNodeList*);	
	void 
	OnPropertyChange(CComponentDataObject* pComponentData, 
						  BOOL, 
						  long changeMask);

	virtual BOOL 
	CanCloseSheets();
};

/******************************************************************************
Class:	CGroupNode
Purpose: Snapin Node for Application Group Object
******************************************************************************/
class CGroupNode : public CBaseLeafNode
{
public:
	CGroupNode(CRoleComponentDataObject * pComponentDataObject,
			   CAdminManagerNode* pAdminManagerNode,
			   CBaseAz* pBaseAz,
			   CRoleAz* pRoleAz = NULL);

	virtual
	~CGroupNode();

	virtual HRESULT AddOnePageToList(CRolePropertyPageHolder *pHolder, 
												UINT nPageNumber);
	
	virtual void
	OnDelete(CComponentDataObject* pComponentData,
				CNodeList* pNodeList);

	virtual HRESULT
	DeleteAssociatedBaseAzObject();

private:
	CRoleAz* m_pRoleAz;
};

/******************************************************************************
Class:	CTaskNode
Purpose: Snapin Node for Task Object
******************************************************************************/
class CTaskNode : public CBaseLeafNode
{
public:
	CTaskNode(CRoleComponentDataObject * pComponentDataObject,
			  CAdminManagerNode* pAdminManagerNode,
			  CBaseAz* pBaseAz);
	~CTaskNode();

	virtual HRESULT AddOnePageToList(CRolePropertyPageHolder *pHolder, 
												UINT nPageNumber);
};

/******************************************************************************
Class:	COperationNode
Purpose: Snapin Node for Operation Object
******************************************************************************/
class COperationNode : public CBaseLeafNode
{
public:
	COperationNode(CRoleComponentDataObject * pComponentDataObject,
				   CAdminManagerNode* pAdminManagerNode,
				   CBaseAz* pBaseAz);
	~COperationNode();

	virtual HRESULT 
	AddOnePageToList(CRolePropertyPageHolder *pHolder, 
					 UINT nPageNumber);

};

/******************************************************************************
Class:	CSidCacheNode
Purpose: Snapin Node for Windows Users/Groups which are represented by SID
******************************************************************************/
class CSidCacheNode : public CBaseLeafNode
{
public:
	CSidCacheNode(CRoleComponentDataObject * pComponentDataObject,
				  CAdminManagerNode* pAdminManagerNode,
				  CBaseAz* pBaseAz,
				  CRoleAz* pRoleAz);
	~CSidCacheNode();

	virtual void
	OnDelete(CComponentDataObject* pComponentData,
			 CNodeList* pNodeList);

	virtual HRESULT
	DeleteAssociatedBaseAzObject();

	BOOL 
	OnSetDeleteVerbState(DATA_OBJECT_TYPES , 
								BOOL* pbHide, 
								CNodeList* pNodeList);
	BOOL 
	HasPropertyPages(DATA_OBJECT_TYPES type, 
                     BOOL* pbHideVerb, 
					 CNodeList* pNodeList);

private:
	CRoleAz* m_pRoleAz;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\leafnodes.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       Basecont.cpp
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

/******************************************************************************
Class:  CBaseLeafNode
Purpose: BaseNode class for all the non container object. A node is a node in
snapins tree listview. 
******************************************************************************/
CBaseLeafNode::
CBaseLeafNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CBaseAz* pBaseAz)
              :CBaseNode(pComponentDataObject,
                         pAdminManagerNode,
                         pBaseAz)
{
    SetDisplayName(GetBaseAzObject()->GetName());   
}

CBaseLeafNode::
~CBaseLeafNode()
{
}

LPCWSTR 
CBaseLeafNode::
GetString(int nCol)
{
    CBaseAz * pBaseAz = GetBaseAzObject();
    ASSERT(pBaseAz);
    
    //Name
    if(nCol == 0)
        return pBaseAz->GetName();

    //Type
    if( nCol == 1)
        return pBaseAz->GetType();

    
    if( nCol == 2)
        return pBaseAz->GetDescription();

    ASSERT(FALSE);
    return NULL;
}

int 
CBaseLeafNode::
GetImageIndex(BOOL /*bOpenImage*/)
{
    return GetBaseAzObject()->GetImageIndex();
}


BOOL 
CBaseLeafNode::
OnSetDeleteVerbState(DATA_OBJECT_TYPES , 
                     BOOL* pbHide, 
                     CNodeList* pNodeList)
{
    if(!pbHide || !pNodeList)
    {
        ASSERT(pbHide);
        ASSERT(pNodeList);
        return FALSE;
    }

    CBaseAz* pBaseAz = GetBaseAzObject();
    ASSERT(pBaseAz);
    
    BOOL bWrite = FALSE;
    HRESULT hr = pBaseAz->IsWritable(bWrite);
    
    if(FAILED(hr) || !bWrite || pNodeList->GetCount() > 1)
    {
        *pbHide = TRUE;
        return FALSE;
    }
    else
    {
        *pbHide = FALSE;
        return TRUE;
    }
}

BOOL
CBaseLeafNode::
CanCloseSheets()
{
    //This function is called when there are open property sheets,
    //and operation cannot be done without closing them.
    ::DisplayInformation(NULL,
                         IDS_CLOSE_CONTAINER_PROPERTY_SHEETS,
                         GetDisplayName());
    return FALSE;
}

void 
CBaseLeafNode::
OnDelete(CComponentDataObject* pComponentData, 
            CNodeList* pNodeList)
{
    GenericDeleteRoutine(this,pComponentData,pNodeList,TRUE);
}

BOOL 
CBaseLeafNode::
HasPropertyPages(DATA_OBJECT_TYPES /*type*/, 
                 BOOL* pbHideVerb, 
                 CNodeList* pNodeList)
{
   if (!pNodeList || !pbHideVerb) 
    {
        ASSERT(pNodeList);
        ASSERT(pbHideVerb);
        return FALSE;
    }

    if (pNodeList->GetCount() == 1) // single selection
    {
        *pbHideVerb = FALSE; // always show the verb
        return TRUE;
    }

    // Multiple selection
    *pbHideVerb = TRUE;
    return FALSE;
}


HRESULT 
CBaseLeafNode::
CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle,
                    CNodeList* pNodeList)
{

    if(!lpProvider || !pNodeList)
    {
        ASSERT(lpProvider);
        ASSERT(pNodeList);
        return E_POINTER;
    }

    if(!CanReadOneProperty(GetDisplayName(),
                           GetBaseAzObject()))
        return E_FAIL;

    HRESULT hr = S_OK;
    if (pNodeList->GetCount() > 1)
    {
        return hr;
    }
    CRolePropertyPageHolder* pHolder = NULL;
    UINT nCountOfPages = 0;

    do 
    {

        CComponentDataObject* pComponentDataObject = GetComponentDataObject();
        ASSERT(pComponentDataObject);
    
        pHolder = new CRolePropertyPageHolder(GetContainer(), 
                                              this, 
                                              pComponentDataObject);
        if(!pHolder)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //Add Property Pages
        while(1)
        {       
            hr = AddOnePageToList(pHolder, nCountOfPages);
            if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                hr = S_OK;
                break;
            }
            if(FAILED(hr))
            {
                break;
            }
            nCountOfPages++;
        }
        BREAK_ON_FAIL_HRESULT(hr);

        if(nCountOfPages)
        {
            return pHolder->CreateModelessSheet(lpProvider, handle);
        }

    }while(0);

    if(FAILED(hr) || !nCountOfPages)
    {
        if(pHolder)
            delete pHolder;
    }
    return hr;
}

void 
CBaseLeafNode
::OnPropertyChange(CComponentDataObject* pComponentData,
                         BOOL bScopePane,
                         long changeMask)
{
    if(!pComponentData)
    {
        ASSERT(pComponentData);
        return;
    }

    SetDisplayName(GetBaseAzObject()->GetName());   
    CTreeNode::OnPropertyChange(pComponentData,
                                         bScopePane,
                                         changeMask);
}


/******************************************************************************
Class:  CGroupNode
Purpose: Snapin Node for Application Group Object
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CGroupNode)
CGroupNode::
CGroupNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CBaseAz* pBaseAz,
              CRoleAz* pRoleAz)
             :CBaseLeafNode(pComponentDataObject,pAdminManagerNode,
                            pBaseAz),
              m_pRoleAz(pRoleAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CGroupNode);
}

CGroupNode
::~CGroupNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CGroupNode)
}

HRESULT 
CGroupNode::
AddOnePageToList(CRolePropertyPageHolder *pHolder, UINT nPageNumber)
{
    HRESULT hr = S_OK;

    if(!pHolder)
    {
        ASSERT(pHolder);
        return E_POINTER;
    }

    if(nPageNumber == 0)
    {
        //Add General Property Page
        CGroupGeneralPropertyPage * pGenPropPage = 
            new CGroupGeneralPropertyPage(GetBaseAzObject(),this);

        if(!pGenPropPage)
        {
            return E_OUTOFMEMORY;
        }
        pHolder->AddPageToList(pGenPropPage);
        return hr;
    }
    
    //Get the type of grou[
    CGroupAz* pGroupAz = static_cast<CGroupAz*>(GetBaseAzObject());
    LONG lGroupType;
    hr = pGroupAz->GetGroupType(&lGroupType);
    if(FAILED(hr))
    {
        return hr;
    }

    if((lGroupType == AZ_GROUPTYPE_BASIC) && (nPageNumber == 1 || nPageNumber == 2))
    {
        //Add member/non-member page
        CGroupMemberPropertyPage * pGroupMemberPropertyPage =
                new CGroupMemberPropertyPage(GetBaseAzObject(),this,
                                                      (nPageNumber == 1) ? IDD_GROUP_MEMBER : IDD_GROUP_NON_MEMBER,
                                                      (nPageNumber == 1) ? TRUE : FALSE);

        if(!pGroupMemberPropertyPage)
        {
            return E_OUTOFMEMORY;
        }
        pHolder->AddPageToList(pGroupMemberPropertyPage);
        return hr;
    }

    if((lGroupType == AZ_GROUPTYPE_LDAP_QUERY) && (nPageNumber == 1))
    {
        //Add LDAP Query Property Page
        CGroupQueryPropertyPage * pQueryPropPage = 
            new CGroupQueryPropertyPage(GetBaseAzObject(),this);

        if(!pQueryPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pQueryPropPage);
        return hr;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

HRESULT
CGroupNode::
DeleteAssociatedBaseAzObject()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupNode,DeleteAssociatedBaseAzObject)

    HRESULT hr = S_OK;
    //If m_pRoleAz is present, this group node is used to
    //represent a member of Role. On delete delete it from
    //Role Membership. Else delete this object which is done
    //by base class delete
    CBaseAz* pBaseAz = GetBaseAzObject();
    if(!m_pRoleAz)
    {
        CContainerAz* pContainerAzParent = GetBaseAzObject()->GetParentAz();
        if(!pContainerAzParent)
        {
            ASSERT(pContainerAzParent);
            return E_UNEXPECTED;
        }

        hr = pContainerAzParent->DeleteAzObject(pBaseAz->GetObjectType(),
                                                pBaseAz->GetName());
    }       
    else
    {
        //Remove this group from Role Membership
        hr = m_pRoleAz->RemoveMember(AZ_PROP_ROLE_APP_MEMBERS,
                                                         pBaseAz);

        if(SUCCEEDED(hr))
        {
            hr = m_pRoleAz->Submit();
        }
    }
    return hr;
}

void
CGroupNode::
OnDelete(CComponentDataObject* pComponentData,
            CNodeList* pNodeList)
{
    GenericDeleteRoutine(this,
                         pComponentData,
                         pNodeList,
                         !m_pRoleAz);   //Don't ask for confirmation when removing group from a role
}

/******************************************************************************
Class:  CTaskNode
Purpose: Snapin Node for Task Object
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CTaskNode)
CTaskNode::
CTaskNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CBaseAz* pBaseAz)
:CBaseLeafNode(pComponentDataObject,
              pAdminManagerNode,
              pBaseAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CTaskNode);
}

CTaskNode
::~CTaskNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CTaskNode)
}

HRESULT 
CTaskNode::
AddOnePageToList(CRolePropertyPageHolder *pHolder, UINT nPageNumber)
{
    HRESULT hr = S_OK;
    if(!pHolder)
    {
        ASSERT(pHolder);
        return E_POINTER;
    }

    CTaskAz* pTaskAz = dynamic_cast<CTaskAz*>(GetBaseAzObject());
    ASSERT(pTaskAz);

    if(nPageNumber == 0)
    {
        //Set the Title to "Node_Name Definition Properties"
        pHolder->SetSheetTitle(IDS_FMT_PROP_SHEET_TITILE_FOR_ROLE_DEFINITION,
                               this);

        //Add General Property Page
        CTaskGeneralPropertyPage * pGenPropPage = 
                new CTaskGeneralPropertyPage(GetBaseAzObject(),
                                             this,
                                             pTaskAz->IsRoleDefinition());

        if(!pGenPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pGenPropPage);
        return hr;
    }
    else if(nPageNumber == 1)
    {
        //Add Definition Property Page
        CTaskDefinitionPropertyPage * pDefinitionPropPage = 
                new CTaskDefinitionPropertyPage(pTaskAz,
                                                this,
                                                pTaskAz->IsRoleDefinition());

        if(!pDefinitionPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pDefinitionPropPage);
        return hr;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

/******************************************************************************
Class:  COperationNode
Purpose: Snapin Node for Operation Object
******************************************************************************/

DEBUG_DECLARE_INSTANCE_COUNTER(COperationNode)

COperationNode::
COperationNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CBaseAz* pBaseAz)
             :CBaseLeafNode(pComponentDataObject,
              pAdminManagerNode,
              pBaseAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(COperationNode)
}

COperationNode
::~COperationNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(COperationNode)
}

HRESULT 
COperationNode::
AddOnePageToList(CRolePropertyPageHolder *pHolder, UINT nPageNumber)
{
    HRESULT hr = S_OK;

    if(!pHolder)
    {
        ASSERT(pHolder);
        return E_POINTER;
    }

    if(nPageNumber == 0)
    {
        //Set the Title to "Node_Name Definition Properties"
        pHolder->SetSheetTitle(IDS_FMT_PROP_SHEET_TITILE_FOR_ROLE_DEFINITION,
                               this);
        //
        //Add General Property Page
        //
        COperationGeneralPropertyPage * pGenPropPage = 
                new COperationGeneralPropertyPage(GetBaseAzObject(),this);

        if(!pGenPropPage)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        pHolder->AddPageToList(pGenPropPage);
        return hr;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}
/******************************************************************************
Class:  CSidCacheNode
Purpose: Snapin Node for Windows Users/Groups which are represented by SID
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CSidCacheNode)
CSidCacheNode::
CSidCacheNode(CRoleComponentDataObject * pComponentDataObject,
              CAdminManagerNode* pAdminManagerNode,
              CBaseAz* pBaseAz,
                  CRoleAz* pRoleAz)
                  :CBaseLeafNode(pComponentDataObject,
              pAdminManagerNode,
              pBaseAz),
                  m_pRoleAz(pRoleAz)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSidCacheNode)
    ASSERT(m_pRoleAz);
}

CSidCacheNode::~CSidCacheNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSidCacheNode)
}

HRESULT
CSidCacheNode::
DeleteAssociatedBaseAzObject()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSidCacheNode,DeleteAssociatedBaseAzObject)
    CBaseAz* pBaseAz = GetBaseAzObject();

    HRESULT hr = m_pRoleAz->RemoveMember(AZ_PROP_ROLE_MEMBERS,
                                                     pBaseAz);
    if(SUCCEEDED(hr))
    {
        hr = m_pRoleAz->Submit();
    }   
    return hr;
}

void
CSidCacheNode::
OnDelete(CComponentDataObject* pComponentData,
            CNodeList* pNodeList)
{
    GenericDeleteRoutine(this,pComponentData,pNodeList,FALSE);
}

BOOL 
CSidCacheNode::
OnSetDeleteVerbState(DATA_OBJECT_TYPES , 
                            BOOL* pbHide, 
                            CNodeList* pNodeList)
{
    if(!pbHide || !pNodeList)
    {
        ASSERT(pbHide);
        ASSERT(pNodeList);
        return FALSE;
    }

    BOOL bWrite = FALSE;
    HRESULT hr = m_pRoleAz->IsWritable(bWrite);

    if(FAILED(hr) || !bWrite || pNodeList->GetCount() > 1)
    {
        *pbHide = TRUE;
        return FALSE;
    }
    else
    {
        *pbHide = FALSE;
        return TRUE;
    }
}

BOOL 
CSidCacheNode::
HasPropertyPages(DATA_OBJECT_TYPES /*type*/, 
                 BOOL* pbHideVerb, 
                 CNodeList* /*pNodeList*/)
{
    if(!pbHideVerb)
    {
        ASSERT(pbHideVerb);
        return FALSE;
    }

    *pbHideVerb = TRUE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\newobjectdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       NewObjectDlg.cpp
//
//  Contents:   Dialog Boxes for creating new objects
//
//  History:    08-16-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

/******************************************************************************
Class:  CSortListCtrl
Purpose:Subclases ListCtrl class and handles initialization and sorting
******************************************************************************/
BEGIN_MESSAGE_MAP(CSortListCtrl, CListCtrl)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnListCtrlColumnClicked)
END_MESSAGE_MAP()



void
CSortListCtrl::
Initialize()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSortListCtrl,Initialize)
    
    //
    //Add Imagelist
    //  
    ListView_SetImageList(GetSafeHwnd(),
                          LoadImageList(::AfxGetInstanceHandle (), 
                                        MAKEINTRESOURCE(IDB_ICONS)),
                          LVSIL_SMALL);


    //Add ListBox Extended Style
    if(m_bCheckBox)
    {
        SetExtendedStyle(LVS_EX_FULLROWSELECT|
                         LVS_EX_INFOTIP|
                         LVS_EX_CHECKBOXES);
    }
    else
    {
        SetExtendedStyle(LVS_EX_FULLROWSELECT|
                         LVS_EX_INFOTIP);

    }

    //Add List box Columns
    AddColumnToListView(this,
                        m_pColForLv);
}

void
CSortListCtrl::
OnListCtrlColumnClicked(NMHDR* pNotifyStruct, LRESULT* /*pResult*/)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSortListCtrl,OnListCtrlColumnClicked)

    if(!pNotifyStruct)
    {
        ASSERT(pNotifyStruct);
        return;
    }

    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pNotifyStruct;
    if (m_iLastColumnClick == pnmlv->iSubItem)
        m_iSortDirection = -m_iSortDirection;
    else
        m_iSortDirection = 1;
    
    m_iLastColumnClick = pnmlv->iSubItem;

    
    ::SortListControl(this,
                      m_iLastColumnClick,
                      m_iSortDirection,
                      m_uiFlags,
                      m_bActionItem);
    
    EnsureListViewSelectionIsVisible(this);
}

void 
CSortListCtrl::
Sort()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSortListCtrl,Sort)

    ::SortListControl(this,
                      m_iLastColumnClick,
                      m_iSortDirection,
                      m_uiFlags,
                      m_bActionItem);
    EnsureListViewSelectionIsVisible(this);
}

/******************************************************************************
Class:  CHelpEnabledDialog
Purpose:Dialog box class with support for displaying help
******************************************************************************/
BEGIN_MESSAGE_MAP(CHelpEnabledDialog, CDialog)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()

BOOL 
CHelpEnabledDialog::
OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    DWORD_PTR pHelpMap = NULL;
    if(FindDialogContextTopic(m_nDialogId, &pHelpMap))
    {
        ASSERT(pHelpMap);
        ::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                  g_szContextHelpFileName,
                  HELP_WM_HELP,
                  pHelpMap);

        return TRUE;
    }
    return FALSE;
}

void 
CHelpEnabledDialog::
OnContextMenu(CWnd* /*pWnd*/, CPoint /*point*/) 
{
    DWORD_PTR pHelpMap = NULL;
    if(FindDialogContextTopic(m_nDialogId, &pHelpMap))
    {
        ::WinHelp(m_hWnd,
                  g_szContextHelpFileName,
                  HELP_CONTEXTMENU,
                  (DWORD_PTR)pHelpMap);
    }
}

INT_PTR
CHelpEnabledDialog::
DoModal()
{
    CThemeContextActivator activator;
    return CDialog::DoModal();
}


/******************************************************************************
Class:  CNewBaseDlg
Purpose: Base Dialog Class For creation of new objects
******************************************************************************/

BEGIN_MESSAGE_MAP(CNewBaseDlg, CHelpEnabledDialog)
    //{{AFX_MSG_MAP(CNewBaseDlg)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnEditChangeName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//+----------------------------------------------------------------------------
//  Function:Constructor   
//-----------------------------------------------------------------------------
CNewBaseDlg
::CNewBaseDlg(IN CComponentDataObject* pComponentData,
              IN CBaseContainerNode * pBaseContainerNode,
              IN ATTR_MAP* pAttrMap,
              IN ULONG IDD_DIALOG,
              IN OBJECT_TYPE_AZ eObjectType)
              :CHelpEnabledDialog(IDD_DIALOG),
              m_pComponentData(pComponentData),
              m_pBaseContainerNode(pBaseContainerNode),
              m_eObjectType(eObjectType),
              m_pAttrMap(pAttrMap)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewBaseDlg);
    ASSERT(m_pComponentData);
}

//+----------------------------------------------------------------------------
//  Function:Destructor   
//-----------------------------------------------------------------------------
CNewBaseDlg
::~CNewBaseDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewBaseDlg)
}

BOOL 
CNewBaseDlg
::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    //Ok is Enabled only when there is text in Name edit box
    //
    CButton* pButtonOK = (CButton*)GetDlgItem(IDOK);
    pButtonOK->EnableWindow(FALSE);
    //When OK is disabled CANCEL is default button
    SetDefID(IDCANCEL);

    if(m_pAttrMap)
    {
        return InitDlgFromAttrMap(this,
                                  m_pAttrMap,
                                  NULL,
                                  FALSE);
    }
    return TRUE;
}


void 
CNewBaseDlg
::OnEditChangeName()
{
    CButton* pBtnOK = (CButton*)GetDlgItem(IDOK);
    CButton* pBtnCancel = (CButton*)GetDlgItem(IDCANCEL);

    CString strName = GetNameText();

    if(!strName.IsEmpty())
    {
        pBtnOK->EnableWindow(TRUE);
        SetDefID(IDOK);
    }
    else
    {
        //When OK is disabled CANCEL is default button
        pBtnOK->EnableWindow(FALSE);
        SetDefID(IDCANCEL);
    }
}

CString 
CNewBaseDlg::GetNameText()
{
    CEdit* pEditStoreName = (CEdit*)GetDlgItem(IDC_EDIT_NAME);
    ASSERT(pEditStoreName);
    CString strEditStoreName;
    pEditStoreName->GetWindowText(strEditStoreName);
    TrimWhiteSpace(strEditStoreName);

    return strEditStoreName;
}

void
CNewBaseDlg::
SetNameText(const CString& strName)
{
    CEdit* pEditStoreName = (CEdit*)GetDlgItem(IDC_EDIT_NAME);
    ASSERT(pEditStoreName);
    pEditStoreName->SetWindowText(strName);
}

void 
CNewBaseDlg::OnOK()
{
    CBaseAz* pNewObjectAz = NULL;
    HRESULT hr = S_OK;

    BOOL bErrorDisplayed= FALSE;
    
    do
    {
        //Create New Object
        CString strName = GetNameText();
        ASSERT(!strName.IsEmpty());
        CContainerAz* pContainerAz = GetContainerAzObject();
        if(!pContainerAz)
        {
            ASSERT(pContainerAz);
            return;
        }

        //Create Object
        hr = pContainerAz->CreateAzObject(m_eObjectType,
                                          strName,
                                          &pNewObjectAz);

        BREAK_ON_FAIL_HRESULT(hr);

        //Save the properties defined by attribute map
        if(m_pAttrMap)
        {
            hr = SaveAttrMapChanges(this,
                                    m_pAttrMap,
                                    pNewObjectAz,
                                    TRUE,
                                    &bErrorDisplayed,
                                    NULL);
            BREAK_ON_FAIL_HRESULT(hr);      
        }
        

        //Set ObjectType Specific Properties
        hr = SetObjectTypeSpecificProperties(pNewObjectAz, bErrorDisplayed);
        BREAK_ON_FAIL_HRESULT(hr);

        //Do the submit on the object
        hr = pNewObjectAz->Submit();
        BREAK_ON_FAIL_HRESULT(hr);

        //Create correponding container/leaf node for the AzObject
        //and add it to the snapin
        VERIFY(SUCCEEDED(CreateObjectNodeAndAddToUI(pNewObjectAz)));

    
    }while(0);

    if(SUCCEEDED(hr))
    {
        CDialog::OnOK();
    }
    else
    {       
        if(!bErrorDisplayed)
            DisplayError(hr);

        if(pNewObjectAz)
            delete pNewObjectAz;
    }
}

HRESULT 
CNewBaseDlg::
CreateObjectNodeAndAddToUI(CBaseAz* pBaseAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CNewBaseDlg,CreateObjectNodeAndAddToUI)

    CTreeNode * pNewNode = NULL;
    if(!GetBaseContainerNode())
    {
        ASSERT(GetBaseContainerNode());
        return E_UNEXPECTED;
    }

    switch(m_eObjectType)
    {
        case    APPLICATION_AZ:
        {
            CApplicationAz* pApplicationAz = dynamic_cast<CApplicationAz*>(pBaseAz);
            if(!pApplicationAz)
            {
                ASSERT(FALSE);
                return E_UNEXPECTED;
            }
            pNewNode = new CApplicationNode(GetBaseContainerNode()->GetComponentDataObject(),
                                            GetBaseContainerNode()->GetAdminManagerNode(),
                                            pApplicationAz);
            break;
        }
    
        case    SCOPE_AZ:
        {
            CScopeAz* pScopeAz = dynamic_cast<CScopeAz*>(pBaseAz);
            if(!pScopeAz)
            {
                ASSERT(FALSE);
                return E_UNEXPECTED;
            }
            pNewNode = new CScopeNode(GetBaseContainerNode()->GetComponentDataObject(),
                                      GetBaseContainerNode()->GetAdminManagerNode(),
                                      pScopeAz);
            break;
        }
        case    GROUP_AZ:
        {
            CGroupAz* pGroupAz = dynamic_cast<CGroupAz*>(pBaseAz);
            if(!pGroupAz)
            {
                ASSERT(FALSE);
                return E_UNEXPECTED;
            }
            pNewNode = new CGroupNode(GetBaseContainerNode()->GetComponentDataObject(),
                                      GetBaseContainerNode()->GetAdminManagerNode(),
                                      pGroupAz);
            break;
        }
        case    TASK_AZ:
        {
            CTaskAz* pTaskAz = dynamic_cast<CTaskAz*>(pBaseAz);
            if(!pTaskAz)
            {
                ASSERT(FALSE);
                return E_UNEXPECTED;
            }
            pNewNode = new CTaskNode(GetBaseContainerNode()->GetComponentDataObject(),
                                     GetBaseContainerNode()->GetAdminManagerNode(),
                                     pTaskAz);
            break;
        }
        case    ROLE_AZ:
        {
            CRoleAz* pRoleAz = dynamic_cast<CRoleAz*>(pBaseAz);
            if(!pRoleAz)
            {
                ASSERT(FALSE);
                return E_UNEXPECTED;
            }
            pNewNode = new CRoleNode(GetBaseContainerNode()->GetComponentDataObject(),
                                     GetBaseContainerNode()->GetAdminManagerNode(),
                                     pRoleAz);
            break;
        }
        case OPERATION_AZ:
        {
            COperationAz* pOperationAz = dynamic_cast<COperationAz*>(pBaseAz);
            if(!pOperationAz)
            {
                ASSERT(FALSE);
                return E_UNEXPECTED;
            }
            pNewNode = new COperationNode(GetBaseContainerNode()->GetComponentDataObject(),
                                          GetBaseContainerNode()->GetAdminManagerNode(),
                                          pOperationAz);
            break;
        }
        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

        
    if(!pNewNode)
    {
        return E_OUTOFMEMORY;
    }

    VERIFY(GetBaseContainerNode()->AddChildToListAndUI(pNewNode,GetComponentData()));



    return S_OK;
}

VOID 
CNewBaseDlg::
DisplayError(HRESULT hr)
{
    ErrorMap * pErrorMap = GetErrorMap(m_eObjectType);
    if(!pErrorMap)
    {
        ASSERT(FALSE);
        return;
    }

    if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
    {
        ::DisplayError(m_hWnd,pErrorMap->idNameAlreadyExist,GetNameText());
        return;
    }
    if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_NAME))
    {
        ::DisplayError(m_hWnd,pErrorMap->idInvalidName,pErrorMap->pszInvalidChars);
        return;
    }

    //
    //Display Generic Error. 
    //
    CString strObjectType;
    VERIFY(strObjectType.LoadString(pErrorMap->idObjectType));
    strObjectType.MakeLower();
    CString strError;
    GetSystemError(strError, hr);   
    
    if(!strError.IsEmpty())
    {
        ::DisplayError(m_hWnd,
                            IDS_CREATE_NEW_GENERIC_ERROR,
                            (LPCTSTR)strError,
                            (LPCTSTR)strObjectType);
    }
    return;
}





/******************************************************************************
Class:  CNewApplicationDlg
Purpose: Dlg Class for creating new application
******************************************************************************/

BEGIN_MESSAGE_MAP(CNewApplicationDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(CNewApplicationDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DEBUG_DECLARE_INSTANCE_COUNTER(CNewApplicationDlg)

CNewApplicationDlg
::CNewApplicationDlg(IN CComponentDataObject* pComponentData,
                     IN CBaseContainerNode* pBaseContainerNode)
                     :CNewBaseDlg(pComponentData,
                                  pBaseContainerNode,
                                  ATTR_MAP_NEW_APPLICATION,
                                  IDD_NEW_APPLICATION,
                                  APPLICATION_AZ)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewApplicationDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNewApplicationDlg)
}

CNewApplicationDlg
::~CNewApplicationDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewApplicationDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNewApplicationDlg)
}


/******************************************************************************
Class:  CNewScopeDlg
Purpose: Dlg Class for creating new scope
******************************************************************************/
BEGIN_MESSAGE_MAP(CNewScopeDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(CNewScopeDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DEBUG_DECLARE_INSTANCE_COUNTER(CNewScopeDlg)

CNewScopeDlg
::CNewScopeDlg(IN CComponentDataObject* pComponentData,
                    IN CBaseContainerNode* pBaseContainerNode)
                    :CNewBaseDlg(pComponentData,
                                 pBaseContainerNode,
                                 ATTR_MAP_NEW_SCOPE,
                                 IDD_NEW_SCOPE,
                                 SCOPE_AZ)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewScopeDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNewScopeDlg)
}

CNewScopeDlg
::~CNewScopeDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewScopeDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNewScopeDlg)
}

/******************************************************************************
Class:  CNewGroupDlg
Purpose: Dlg Class for creating new group
******************************************************************************/
BEGIN_MESSAGE_MAP(CNewGroupDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(CNewGroupDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DEBUG_DECLARE_INSTANCE_COUNTER(CNewGroupDlg)

CNewGroupDlg
::CNewGroupDlg(IN CComponentDataObject* pComponentData,
                    IN CBaseContainerNode* pBaseContainerNode)
                    :CNewBaseDlg(pComponentData,
                                 pBaseContainerNode,
                                 ATTR_MAP_NEW_GROUP,
                                 IDD_NEW_GROUP,
                                 GROUP_AZ)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewGroupDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNewGroupDlg)
}

CNewGroupDlg
::~CNewGroupDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewGroupDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNewGroupDlg)
}

BOOL 
CNewGroupDlg
::OnInitDialog()
{
    //Do the base class initialization
    CNewBaseDlg::OnInitDialog();
    
    //Basic is the default group type
    CButton* pRadio = (CButton*)GetDlgItem(IDC_RADIO_GROUP_TYPE_BASIC);
    pRadio->SetCheck(TRUE);
    
    return TRUE;
}
//+----------------------------------------------------------------------------
//  Function:SetObjectTypeSpecificProperties   
//  Synopsis:Sets some propertis which are specicic to the object   
//  Arguments:pBaseAz: Pointer to baseAz object whose properties are
//               to be set
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT
CNewGroupDlg
::SetObjectTypeSpecificProperties(CBaseAz* pBaseAz, BOOL&)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CNewGroupDlg,SetObjectTypeSpecificProperties);
    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }
    
    CGroupAz* pGroupAz= dynamic_cast<CGroupAz*>(pBaseAz);
    if(!pGroupAz)
    {
        ASSERT(pGroupAz);
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;

    //Set Group Type
    if(((CButton*)GetDlgItem(IDC_RADIO_GROUP_TYPE_BASIC))->GetCheck())
        hr = pGroupAz->SetGroupType(AZ_GROUPTYPE_BASIC);
    else
        hr = pGroupAz->SetGroupType(AZ_GROUPTYPE_LDAP_QUERY);

    CHECK_HRESULT(hr);
    return hr;
}


/******************************************************************************
Class:  CNewTaskDlg
Purpose: Dlg Class for creating new Task/Role Definition
******************************************************************************/
BEGIN_MESSAGE_MAP(CNewTaskDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(CNewTaskDlg)
    ON_BN_CLICKED(IDC_ADD_TASK, OnButtonAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_EDIT_SCRIPT,OnButtonEditScript)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_TASK_OPERATION, OnListCtrlItemChanged)
    ON_NOTIFY(LVN_DELETEITEM, IDC_LIST_TASK_OPERATION, OnListCtrlItemDeleted)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DEBUG_DECLARE_INSTANCE_COUNTER(CNewTaskDlg)

CNewTaskDlg::
CNewTaskDlg(IN CComponentDataObject* pComponentData,
                IN CBaseContainerNode* pBaseContainerNode,
                IN ULONG IDD_DIALOG,
                IN BOOL bRoleDefinition)
                :CNewBaseDlg(pComponentData,
                             pBaseContainerNode,
                             ATTR_MAP_NEW_TASK,
                             IDD_DIALOG,
                             TASK_AZ),
                m_listCtrl(COL_NAME | COL_TYPE | COL_DESCRIPTION,FALSE,Col_For_Task_Role),
                m_bRoleDefinition(bRoleDefinition)              
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewTaskDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNewTaskDlg)
}

CNewTaskDlg
::~CNewTaskDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewTaskDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNewTaskDlg)
}


VOID
CNewTaskDlg::
DisplayError(HRESULT hr)
{
    ErrorMap * pErrorMap = GetErrorMap(TASK_AZ);
    if(!pErrorMap)
    {
        ASSERT(FALSE);
        return;
    }

    if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
    {
            ::DisplayError(m_hWnd,
                           pErrorMap->idNameAlreadyExist,
                           GetNameText());
        return;
    }
    if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_NAME))
    {
        if(m_bRoleDefinition)
        {
            ::DisplayError(m_hWnd,
                           IDS_ROLE_DEFINITION_NAME_INVALID,
                           pErrorMap->pszInvalidChars);
        }
        else
        {
            ::DisplayError(m_hWnd,
                           pErrorMap->idInvalidName,
                           pErrorMap->pszInvalidChars);
        }
        return;
    }

    //
    //Display Generic Error. 
    //
    CString strObjectType;
    VERIFY(strObjectType.LoadString(pErrorMap->idObjectType));
    strObjectType.MakeLower();

    CString strError;
    GetSystemError(strError, hr);   
    
    if(!strError.IsEmpty())
    {
        ::DisplayError(m_hWnd,
                       IDS_CREATE_NEW_GENERIC_ERROR,
                       (LPCTSTR)strError,
                       (LPCTSTR)strObjectType);
    }
    return;
}


BOOL 
CNewTaskDlg
::OnInitDialog()
{
    CNewBaseDlg::OnInitDialog();

    VERIFY(m_listCtrl.SubclassDlgItem(IDC_LIST_TASK_OPERATION,this));
    m_listCtrl.Initialize();

    //Remove button should be disabled in the begining
    CButton* pBtnRemove = (CButton*)GetDlgItem(IDC_REMOVE);
    pBtnRemove->EnableWindow(FALSE);

    return TRUE;
}

HRESULT 
CNewTaskDlg
::SetObjectTypeSpecificProperties(CBaseAz* pBaseAz, BOOL& refbErrorDisplayed)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CNewTaskDlg,SetObjectTypeSpecificProperties);
    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return E_POINTER;
    }
    
    CTaskAz* pTaskAz= dynamic_cast<CTaskAz*>(pBaseAz);
    if(!pTaskAz)
    {
        ASSERT(pTaskAz);
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    
    //Set the Role Definition Bit
    if(m_bRoleDefinition)
    {
        hr = pTaskAz->MakeRoleDefinition();
        if(FAILED(hr))
            return hr;
    }

    //Set Task and Operation Members
    int iCount = m_listCtrl.GetItemCount();
    for( int i = 0; i < iCount; ++i)
    {
        CBaseAz* pTaskOperatioAz = (CBaseAz*)m_listCtrl.GetItemData(i);
        if(pTaskOperatioAz)
        {
            if(pTaskOperatioAz->GetObjectType() == OPERATION_AZ) 
            {
                hr = pTaskAz->AddMember(AZ_PROP_TASK_OPERATIONS,
                                        pTaskOperatioAz);
            }
            else if(pBaseAz->GetObjectType() == TASK_AZ) 
            {
                hr = pTaskAz->AddMember(AZ_PROP_TASK_TASKS,
                                        pTaskOperatioAz);
            }
            if(FAILED(hr))
                return hr;
        }
    }
    
    //Set the Authorization Script Data
    hr = SaveAuthorizationScriptData(m_hWnd,
                                     *pTaskAz,
                                     m_strFilePath,
                                     m_strScriptLanguage,
                                     m_strScript,
                                     refbErrorDisplayed);

    return hr;
}


void
CNewTaskDlg::OnButtonAdd()
{
    //
    //Operations are contained only by Application object. If Current object 
    //is a scope, get its parent.
    

    //Show AddOperation Dialog box and get list of Selected Operation
    CList<CBaseAz*,CBaseAz*> listObjectsSelected;
    if(!GetSelectedDefinitions(m_bRoleDefinition,
                               GetContainerAzObject(),
                               listObjectsSelected))
    {
        return;
    }
    
    if(!listObjectsSelected.IsEmpty())
    {
        //Add Selected Operation to list control
        AddBaseAzFromListToListCtrl(listObjectsSelected,
                                    &m_listCtrl,
                                    COL_NAME | COL_TYPE | COL_DESCRIPTION,
                                    TRUE);

        m_listCtrl.Sort();
    }
}


void
CNewTaskDlg::OnButtonRemove()
{
    DeleteSelectedRows(&m_listCtrl);
}

void
CNewTaskDlg::OnButtonEditScript()
{
    if(IsBizRuleWritable(m_hWnd,*GetContainerAzObject()))
    {
        GetScriptData(FALSE,
                      *GetBaseContainerNode()->GetAdminManagerNode(),
                      m_strFilePath,
                      m_strScriptLanguage,
                      m_strScript);
    }
}

void
CNewTaskDlg
::OnListCtrlItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* pResult)
{
    if(!pResult)
        return;
    *pResult = 0;
    SetRemoveButton();
}

void
CNewTaskDlg
::OnListCtrlItemDeleted(NMHDR* pNotifyStruct, LRESULT* /*pResult*/)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pNotifyStruct;
    if(pnmlv->lParam)
    {
        delete (CBaseAz*)pnmlv->lParam;
    }
}



void
CNewTaskDlg
::SetRemoveButton()
{
    EnableButtonIfSelectedInListCtrl(&m_listCtrl,
                                     GetRemoveButton());
}

/******************************************************************************
Class:  CNewOperationDlg
Purpose: Dlg Class for creating new Operation
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CNewOperationDlg)
BEGIN_MESSAGE_MAP(CNewOperationDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(CNewTaskDlg)

    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CNewOperationDlg
::CNewOperationDlg(IN CComponentDataObject* pComponentData,
                         IN CBaseContainerNode* pBaseContainerNode)
                        :CNewBaseDlg(pComponentData,
                                         pBaseContainerNode,
                                         ATTR_MAP_NEW_OPERATION,
                                         IDD_NEW_OPERATION,
                                         OPERATION_AZ)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewOperationDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNewOperationDlg)
}

CNewOperationDlg
::~CNewOperationDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewOperationDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNewOperationDlg)
}



//+----------------------------------------------------------------------------
//  Function:  OpenCreateAdminManager 
//  Synopsis:  Open an existing an existing Authorization Store or 
//                 creates a new Authorization Store and adds corresponding
//                 AdminManager object to snapin 
//  Arguments:IN hWnd: Handle of window for dialog box
//                IN bNew   :If True create a new Authz store else open existing
//                               one
//            IN bOpenFromSavedConsole: This is valid when bNew is False.
//            True if open is in resopnse to a console file.
//            IN lStoreType: XML or AD
//            IN strName:   Name of store
//            IN strDesc:  Description. Only valid in case of new
//            IN strScriptDir : Script directory
//            IN pRootData: Snapin Rootdata
//            IN pComponentData: ComponentData
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT OpenCreateAdminManager(IN BOOL bNew,
                               IN BOOL bOpenFromSavedConsole,
                               IN ULONG lStoreType,
                               IN const CString& strStoreName,
                               IN const CString& strDesc,
                               IN const CString& strScriptDir,
                               IN CRootData* pRootData,
                               IN CComponentDataObject* pComponentData)
                                         
{
    TRACE_FUNCTION_EX(DEB_SNAPIN, OpenCreateAdminManager)

    if(!IsValidStoreType(lStoreType) || 
        strStoreName.IsEmpty() || 
        !pRootData)
    {
        ASSERT(IsValidStoreType(lStoreType));
        ASSERT(!strStoreName.IsEmpty());
        ASSERT(pRootData);
        return E_INVALIDARG;
    }

   
    HRESULT hr = S_OK;
    CAdminManagerAz* pAdminManagerAz = NULL;

    do
    {
        //Create CAzAdminManager instance
        CComPtr<IAzAuthorizationStore> spAzAdminManager;
        hr = spAzAdminManager.CoCreateInstance(CLSID_AzAuthorizationStore,
                                               NULL,
                                               CLSCTX_INPROC_SERVER);
        BREAK_ON_FAIL_HRESULT(hr);


        pAdminManagerAz = new CAdminManagerAz(spAzAdminManager);
        if(!pAdminManagerAz)
        {
            hr = E_OUTOFMEMORY;
            break;
        }


        if(bNew)
        {       
            //Create Policy Store
            hr = pAdminManagerAz->CreatePolicyStore(lStoreType,
                                                                 strStoreName);
        }else
        {
            //Open Policy Store
            hr = pAdminManagerAz->OpenPolicyStore(lStoreType,
                                                              strStoreName);
        }
        
        BREAK_ON_FAIL_HRESULT(hr);
        
        if(bNew)
        {
            //Set Description
            if(!strDesc.IsEmpty())
            {
                hr = pAdminManagerAz->SetDescription(strDesc);      
                BREAK_ON_FAIL_HRESULT(hr);
            }

            //All the changes are done. Submit
            hr = pAdminManagerAz->Submit();
            BREAK_ON_FAIL_HRESULT(hr);
        }


        //Create AdminManager Node and add to snapin
        CAdminManagerNode* pAdminManagerCont= 
            new CAdminManagerNode((CRoleComponentDataObject*)pComponentData,
                                  pAdminManagerAz);
        
        if(!pAdminManagerCont)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //Set the Authorization Script Dir
        pAdminManagerCont->SetScriptDirectory(strScriptDir);
    
        VERIFY(pRootData->AddChildToListAndUI(pAdminManagerCont,pComponentData));
        pAdminManagerCont->SetAdminManagerNode(pAdminManagerCont);
        pAdminManagerCont->SetComponentDataObject((CRoleComponentDataObject*)pComponentData);
        
        //If user in opening a new store, select that store
        if(!bOpenFromSavedConsole)
        {
            if(pAdminManagerCont->GetScopeID())
            {
                pComponentData->GetConsole()->SelectScopeItem(pAdminManagerCont->GetScopeID());
            }
        }

    }while(0);
    
    if(FAILED(hr))
    {
        if(pAdminManagerAz)
            delete pAdminManagerAz;
    }

    return hr;  
}


/******************************************************************************
Class:  CNewAuthorizationStoreDlg
Purpose: Dialog Class For creation of new Autorization Store
******************************************************************************/

BEGIN_MESSAGE_MAP(CNewAuthorizationStoreDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(CNewAuthorizationStoreDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_RADIO_AD_STORE,OnRadioChange)
    ON_BN_CLICKED(IDC_RADIO_XML_STORE,OnRadioChange)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DEBUG_DECLARE_INSTANCE_COUNTER(CNewAuthorizationStoreDlg)

CNewAuthorizationStoreDlg
::CNewAuthorizationStoreDlg(IN CComponentDataObject* pComponentData)
                        :CNewBaseDlg(pComponentData,
                                         NULL,
                                         ATTR_MAP_NEW_ADMIN_MANAGER,
                                         IDD_NEW_AUTHORIZATION_STORE,
                                         ADMIN_MANAGER_AZ),
                        m_bADAvailable(FALSE)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,CNewAuthorizationStoreDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNewAuthorizationStoreDlg)
}

CNewAuthorizationStoreDlg
::~CNewAuthorizationStoreDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,CNewAuthorizationStoreDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNewAuthorizationStoreDlg) 
}

BOOL 
CNewAuthorizationStoreDlg
::OnInitDialog()
{
    CWaitCursor waitCursor;
    //Initialize the base dialog 
    CNewBaseDlg::OnInitDialog();

    //XML is the default store
    CButton* pRadioXML      = (CButton*)GetDlgItem(IDC_RADIO_XML_STORE);
    pRadioXML->SetCheck(TRUE);

    //Check if active directory is available as store.
    m_bADAvailable = (GetRootData()->GetADState() != AD_NOT_AVAILABLE);

    //Set m_lLastRadioSelection to AD Store
    m_lLastRadioSelection = AZ_ADMIN_STORE_AD;
    //Get the default ad store name
    GetDefaultADContainerPath(GetRootData()->GetAdInfo(),FALSE,FALSE,m_strLastStoreName);

    //Initialize the store to Current Working direcotry
    CString strXMLStorePath = GetRootData()->GetXMLStorePath();
    SetNameText(strXMLStorePath);
    CEdit * pEdit = (CEdit*)GetDlgItem(IDC_EDIT_NAME);
    pEdit->SetFocus();
    pEdit->SetSel(strXMLStorePath.GetLength(),strXMLStorePath.GetLength(),FALSE);

    //We have changed the default focus
    return FALSE;    
}

ULONG
CNewAuthorizationStoreDlg::
GetStoreType()
{
    if(((CButton*)GetDlgItem(IDC_RADIO_AD_STORE))->GetCheck())
        return AZ_ADMIN_STORE_AD;
    else
        return AZ_ADMIN_STORE_XML;
}

void
CNewAuthorizationStoreDlg::
OnRadioChange()
{
    LONG lCurRadioSelection = GetStoreType();
    if(m_lLastRadioSelection == lCurRadioSelection)
    {
        CString strTemp = GetNameText();
        SetNameText(m_strLastStoreName);
        m_strLastStoreName = strTemp;
        m_lLastRadioSelection = (lCurRadioSelection == AZ_ADMIN_STORE_XML) ? AZ_ADMIN_STORE_AD : AZ_ADMIN_STORE_XML;
        //AD option is selected and AD is not available on the machine. In this case don't support
        //browse functionality, however allow to enter ADAM store path by entering path directly.
        if((AZ_ADMIN_STORE_AD == lCurRadioSelection) && 
           !m_bADAvailable)
        {
            GetDlgItem(IDC_BUTTON_BROWSE)->EnableWindow(FALSE);
        }
        else
            GetDlgItem(IDC_BUTTON_BROWSE)->EnableWindow(TRUE);

    }
}

void 
CNewAuthorizationStoreDlg
::OnButtonBrowse()
{
    CEdit * pEdit = (CEdit*)GetDlgItem(IDC_EDIT_NAME);
    if(GetStoreType() == AZ_ADMIN_STORE_XML)
    {
        CString strFileName;    
        if(GetFolderName(m_hWnd,
                        IDS_NEW_AUTHORIZATION_STORE,
                        GetRootData()->GetXMLStorePath(),
                        strFileName))
        {   
            pEdit->SetWindowText(strFileName);
            //Set the focus to the edit control and set caret to
            //end of filepath so that user can continue typing file name
            pEdit->SetFocus();
            pEdit->SetSel(strFileName.GetLength(),strFileName.GetLength(),FALSE);
        }
    }
    else
    {
        CString strDsContainerName;
        if(GetADContainerPath(m_hWnd,
                              IDS_NEW_AUTHORIZATION_STORE,
                              IDS_AD_CONTAINER_LOCATION,
                              strDsContainerName,
                              GetRootData()->GetAdInfo()))
        {
            pEdit->SetWindowText(strDsContainerName);
            //Set the Focus to edit control and set caret to
            //begining of editbox so that user add cn of the 
            //new store in the begining
            pEdit->SetFocus();
        }
    }

}

void
CNewAuthorizationStoreDlg
::OnOK()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CNewAuthorizationStoreDlg,OnOK)

    HRESULT hr = S_OK;
    //Get Store Name
    CString strStoreName = GetNameText();

    //Get Store Type
    ULONG lStoreType = GetStoreType();

    //NTRAID#NTBUG9-706617-2002/07/17-hiteshr Our validation code cannot validate
    //ADAM dn. Do not do any validation.
    //Validate the store name.
    //if(!ValidateStoreTypeAndName(m_hWnd,lStoreType,strStoreName))
    //    return;

    if(lStoreType == AZ_ADMIN_STORE_XML)
    {
        AddExtensionToFileName(strStoreName);
        ConvertToExpandedAndAbsolutePath(strStoreName);
        SetNameText(strStoreName);
        //creating new store. set the XML store path location
        SetXMLStoreDirectory(*GetRootData(),strStoreName);
    }
        
    CString strDesc;
    ((CEdit*)GetDlgItem(IDC_EDIT_DESCRIPTION))->GetWindowText(strDesc);


    hr = OpenCreateAdminManager(TRUE,
                                FALSE,
                                lStoreType,
                                strStoreName,
                                strDesc,
                                GetRootData()->GetXMLStorePath(),    //Default path for VB script is same as path for XML store
                                GetRootData(),
                                GetComponentData());                                         
    
    if(SUCCEEDED(hr))
    {
        CDialog::OnOK();
    }
    else
    {
        if(hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
        {
            ::DisplayError(m_hWnd,
                           IDS_CREATE_NEW_PATH_NOT_FOUND);
        }
        else if((lStoreType == AZ_ADMIN_STORE_XML) && (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)))
        {
            ::DisplayError(m_hWnd,IDS_ERROR_FILE_EXIST,(LPCTSTR)strStoreName);                         
        }
        else if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_NAME))
        {
            ::DisplayError(m_hWnd,IDS_ERROR_INVALID_NAME);
        }
        else if((lStoreType == AZ_ADMIN_STORE_AD) && (hr == HRESULT_FROM_WIN32(ERROR_CURRENT_DOMAIN_NOT_ALLOWED)))
        {
            ::DisplayError(m_hWnd,IDS_ERROR_DOMAIN_NOT_ALLOWED);
        }
        else
        {
            DisplayError(hr);
        }
    }
}


/******************************************************************************
Class:  COpenAuthorizationStoreDlg
Purpose: Dialog Class For Opening of existing Autorization Store
******************************************************************************/
BEGIN_MESSAGE_MAP(COpenAuthorizationStoreDlg, CNewBaseDlg)
    //{{AFX_MSG_MAP(COpenAuthorizationStoreDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_RADIO_AD_STORE,OnRadioChange)
    ON_BN_CLICKED(IDC_RADIO_XML_STORE,OnRadioChange)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DEBUG_DECLARE_INSTANCE_COUNTER(COpenAuthorizationStoreDlg)

COpenAuthorizationStoreDlg
::COpenAuthorizationStoreDlg(IN CComponentDataObject* pComponentData)
                        :CNewBaseDlg(pComponentData,
                                     NULL,
                                     ATTR_MAP_OPEN_ADMIN_MANAGER,
                                     IDD_OPEN_AUTHORIZATION_STORE,
                                     ADMIN_MANAGER_AZ),
                        m_bADAvailable(FALSE)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN,COpenAuthorizationStoreDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(COpenAuthorizationStoreDlg)
}

COpenAuthorizationStoreDlg
::~COpenAuthorizationStoreDlg()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN,COpenAuthorizationStoreDlg)
    DEBUG_DECREMENT_INSTANCE_COUNTER(COpenAuthorizationStoreDlg)    
}

ULONG
COpenAuthorizationStoreDlg
::GetStoreType()
{
    if(((CButton*)GetDlgItem(IDC_RADIO_AD_STORE))->GetCheck())
        return AZ_ADMIN_STORE_AD;
    else
        return AZ_ADMIN_STORE_XML;
}

BOOL 
COpenAuthorizationStoreDlg
::OnInitDialog()
{
    CWaitCursor waitCursor;
    //
    //XML is the default store
    //
    CButton* pRadioAD       = (CButton*)GetDlgItem(IDC_RADIO_XML_STORE);
    pRadioAD->SetCheck(TRUE);

    //Check if active directory is available as store.
    m_bADAvailable = (GetRootData()->GetADState() != AD_NOT_AVAILABLE);

    //Set m_lLastRadioSelection to AD STore
    m_lLastRadioSelection = AZ_ADMIN_STORE_AD;
   
    return CNewBaseDlg::OnInitDialog();
}


void 
COpenAuthorizationStoreDlg
::OnButtonBrowse()
{
    //Get Store Type
    ULONG lStoreType = GetStoreType();

    if(lStoreType == AZ_ADMIN_STORE_XML)
    {
        CString strFileName;
        
        if(GetFileName(m_hWnd,
                       TRUE,
                       IDS_OPEN_AUTHORIZATION_STORE,
                       GetRootData()->GetXMLStorePath(),
                       L"*.xml\0*.xml\0\0",
                       strFileName))
        {   
            ((CEdit*)GetDlgItem(IDC_EDIT_NAME))->SetWindowText(strFileName);
        }
    }
    else
    {
        CString strDN;
        BrowseAdStores(m_hWnd,
                       strDN,
                       GetRootData()->GetAdInfo());
        if(!strDN.IsEmpty())
            ((CEdit*)GetDlgItem(IDC_EDIT_NAME))->SetWindowText(strDN);
    }
}

void
COpenAuthorizationStoreDlg::
OnRadioChange()
{
    LONG lCurRadioSelection = GetStoreType();
    if(m_lLastRadioSelection == lCurRadioSelection)
    {
        CString strTemp = GetNameText();
        SetNameText(m_strLastStoreName);
        m_strLastStoreName = strTemp;
        m_lLastRadioSelection = (lCurRadioSelection == AZ_ADMIN_STORE_XML) ? AZ_ADMIN_STORE_AD : AZ_ADMIN_STORE_XML;

        //AD option is selected and AD is not available on the machine. In this case don't support
        //browse functionality, however allow to enter ADAM store path by entering path directly.
        if((AZ_ADMIN_STORE_AD == lCurRadioSelection) && 
            !m_bADAvailable)
        {
            GetDlgItem(IDC_BUTTON_BROWSE)->EnableWindow(FALSE);
        }
        else
            GetDlgItem(IDC_BUTTON_BROWSE)->EnableWindow(TRUE);
    }
}


void
COpenAuthorizationStoreDlg
::OnOK()
{
    TRACE_METHOD_EX(DEB_SNAPIN,COpenAuthorizationStoreDlg,OnOK)

    HRESULT hr = S_OK;
    //Get Store Name
    CString strStoreName = GetNameText();

    //Get Store Type
    ULONG lStoreType = GetStoreType();

    //Set the default xml store directory
    if(AZ_ADMIN_STORE_XML == lStoreType)
    {
        ConvertToExpandedAndAbsolutePath(strStoreName);
        SetNameText(strStoreName);
        SetXMLStoreDirectory(*GetRootData(),strStoreName);
    }
    
    hr = OpenAdminManager(m_hWnd,
                          FALSE,
                          lStoreType,
                          strStoreName,
                          GetRootData()->GetXMLStorePath(),
                          GetRootData(),
                          GetComponentData());
                                             
    if(SUCCEEDED(hr))
    {
        CDialog::OnOK();
    }
}

/******************************************************************************
Class:  CScriptDialog
Purpose: Dialog for Reading the script
******************************************************************************/

BEGIN_MESSAGE_MAP(CScriptDialog, CHelpEnabledDialog)
    //{{AFX_MSG_MAP(COpenAuthorizationStoreDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_BUTTON_RELOAD, OnReload)
    ON_BN_CLICKED(IDC_CLEAR_SCRIPT, OnClear)
    ON_BN_CLICKED(IDC_RADIO_VB_SCRIPT,OnRadioChange)
    ON_BN_CLICKED(IDC_RADIO_JAVA_SCRIPT,OnRadioChange)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnEditChangePath)
    ON_WM_CTLCOLOR()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CScriptDialog::
CScriptDialog(BOOL bReadOnly,
              CAdminManagerNode& adminManagerNode,
              CString& strFileName,
              CString& strScriptLanguage,
              CString& strScript)
              :CHelpEnabledDialog(IDD_SCRIPT),
              m_adminManagerNode(adminManagerNode),
              m_strFileName(strFileName),
              m_strScriptLanguage(strScriptLanguage),
              m_strScript(strScript),
              m_strRetFileName(strFileName),
              m_strRetScriptLanguage(strScriptLanguage),
              m_strRetScript(strScript),
              m_bDirty(FALSE),
              m_bReadOnly(bReadOnly),
              m_bInit(FALSE)
{
}

CScriptDialog::
~CScriptDialog()
{
}

BOOL 
CScriptDialog::
OnInitDialog()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScriptDialog,OnInitDialog)
    
    //If there is some script, set it else disable the clear script
    //button
    if(m_strScript.GetLength())
    {
        ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->SetWindowText(m_strScript);
    }
    else
    {
        GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(FALSE);
    }
    
    CEdit* pEditPath = ((CEdit*)GetDlgItem(IDC_EDIT_PATH));
    pEditPath->SetLimitText(AZ_MAX_TASK_BIZRULE_IMPORTED_PATH_LENGTH);

    //If there is a file name, set it else disable the reload script
    //button
    if(m_strFileName.GetLength())
    {
        pEditPath->SetWindowText(m_strFileName);
    }
    else
    {
        GetDlgItem(IDC_BUTTON_RELOAD)->EnableWindow(FALSE);
    }

    

    if(!m_strScriptLanguage.IsEmpty() && 
        (_wcsicmp(g_szJavaScript,m_strScriptLanguage) == 0))
    {
            CButton* pRadioJS   = (CButton*)GetDlgItem(IDC_RADIO_JAVA_SCRIPT);
            pRadioJS->SetCheck(TRUE);
    }
    else
    {
        CButton* pRadioVB   = (CButton*)GetDlgItem(IDC_RADIO_VB_SCRIPT);
        pRadioVB->SetCheck(TRUE);
    }

    if(m_bReadOnly)
    {
        GetDlgItem(IDC_RADIO_VB_SCRIPT)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO_JAVA_SCRIPT)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON_BROWSE)->EnableWindow(FALSE);     
        GetDlgItem(IDC_BUTTON_RELOAD)->EnableWindow(FALSE);
        GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(FALSE);
        ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->SetReadOnly(TRUE);
    }

    m_bInit = TRUE;

    return TRUE;
}


void
CScriptDialog::
OnRadioChange()
{
    m_bDirty = TRUE;
}


void
CScriptDialog::
MatchRadioWithExtension(const CString& strFileName)
{
    //Get the extension of file
    CString strExtension;
    if(GetFileExtension(strFileName,strExtension))
    {
        //If file extension is vbs
        if(_wcsicmp(strExtension,L"vbs") == 0)
        {
            ((CButton*)GetDlgItem(IDC_RADIO_VB_SCRIPT))->SetCheck(BST_CHECKED);
            ((CButton*)GetDlgItem(IDC_RADIO_JAVA_SCRIPT))->SetCheck(BST_UNCHECKED);
        }
        else if(_wcsicmp(strExtension,L"js") == 0)
        {
            ((CButton*)GetDlgItem(IDC_RADIO_JAVA_SCRIPT))->SetCheck(BST_CHECKED);
            ((CButton*)GetDlgItem(IDC_RADIO_VB_SCRIPT))->SetCheck(BST_UNCHECKED);
        }
    }
}
HBRUSH 
CScriptDialog::
OnCtlColor(CDC* pDC,
           CWnd* pWnd,
           UINT nCtlColor)
{
    // Call the base class implementation first! Otherwise, it may
    // undo what we're trying to accomplish here.
    HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
    
    if (pWnd->GetDlgCtrlID() == IDC_EDIT_CODE && (CTLCOLOR_STATIC == nCtlColor))
    {
        // set the read-only edit box background to white
        pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
        pDC->SetBkColor(GetSysColor(COLOR_WINDOW));  
        hbr = GetSysColorBrush(COLOR_WINDOW);        
    }
    
    return hbr;
}

void 
CScriptDialog
::OnEditChangePath()
{
    if(!m_bInit)
        return;

    m_bDirty = TRUE;
    HANDLE handle = INVALID_HANDLE_VALUE;

    do
    {
        //
        //If Path is cleared, clear the script 
        //
        if(!((CEdit*)GetDlgItem(IDC_EDIT_PATH))->GetWindowTextLength())
        {
            ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->SetWindowText(L"");
            m_strScript.Empty();
            m_strFileName.Empty();
            m_strScript.Empty();
      
            GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(FALSE);  
            GetDlgItem(IDC_BUTTON_RELOAD)->EnableWindow(FALSE); 
            break;
        }

        //
        //There is some text in the edit control. Try to load
        //that file
        //

        ((CButton*)GetDlgItem(IDC_BUTTON_RELOAD))->EnableWindow(TRUE);

        CString strFileName;
        ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->GetWindowText(strFileName);

        //If its same as existig file return
        if(_wcsicmp(strFileName,m_strFileName) == 0 )
            break;

        //Check if there is a file or directory with such name
        WIN32_FIND_DATA FindFileData;
        handle = FindFirstFile(strFileName,
                                      &FindFileData);
        //No such file or directory
        if(INVALID_HANDLE_VALUE == handle)
            break;

        //We are only interested in files
        if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            break;

        //Check if file has valid extension
        CString strExtension;
        if(GetFileExtension(strFileName,strExtension))
        {
            if(_wcsicmp(strExtension,L"vbs") == 0 || (_wcsicmp(strExtension,L"js") == 0))
            {
                m_strFileName = strFileName;
                ReloadScript(strFileName);
                MatchRadioWithExtension(strFileName);
            }
        }
  
    }while(0);

    if(INVALID_HANDLE_VALUE != handle)
    {
        FindClose(handle);
    }
}

void
CScriptDialog::
OnClear()
{
    ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->SetWindowText(L"");
    ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->SetWindowText(L"");
    m_strScript.Empty();
    m_strFileName.Empty();
    m_strScript.Empty();

    //Disable the clear button since there is nothing to clear,
    //but before disabling set focus to clear button
    //NTRAID#NTBUG9-663854-2002/07/17-hiteshr
    GetDlgItem(IDC_EDIT_PATH)->SetFocus();
    GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(FALSE);  
    //Disable the Reload button since script path is cleared.
    GetDlgItem(IDC_BUTTON_RELOAD)->EnableWindow(FALSE); 
    
    m_bDirty = TRUE;
}

void 
CScriptDialog::
OnBrowse()
{    
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_OPEN_SCRIPT_FILTER));

    // replace "|" with 0;
    const size_t  nFilterLen = szFileFilter.GetLength();
    PWSTR   pszFileFilter = new WCHAR [nFilterLen + 1];
    if ( pszFileFilter )
    {
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }
        CString strFileName;
        if(GetFileName(m_hWnd,
                       TRUE,
                       IDS_SELECT_AUTHORIZATION_SCRIPT,
                       m_adminManagerNode.GetScriptDirectory(),
                       pszFileFilter,
                       strFileName))
        {
            m_adminManagerNode.SetScriptDirectory(GetDirectoryFromPath(strFileName));

            //This will trigger OnEditChangePath which will load the file
            ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->SetWindowText(strFileName);
            m_bDirty = TRUE;
        }
        delete []pszFileFilter;
    }
}

void 
CScriptDialog::
OnReload()
{   
    //Get FileName
    CString strFileName;
    ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->GetWindowText(strFileName);
    
    //Reload the script
    ReloadScript(strFileName);
    MatchRadioWithExtension(strFileName);
}


void 
CScriptDialog::
OnOK()
{
    if(m_bDirty)
    {
        CString strFileName;
        ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->GetWindowText(strFileName);
        if(_wcsicmp(strFileName,m_strFileName) != 0 )
        {
            m_strFileName = strFileName;
            if(!ReloadScript(m_strFileName))
                return;
        }

        ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->GetWindowText(m_strScript);
        ((CEdit*)GetDlgItem(IDC_EDIT_PATH))->GetWindowText(m_strFileName);
        //If FileName is not empty and Script is empty,
        //reload the script
        if(!m_strFileName.IsEmpty() && m_strScript.IsEmpty())
        {
            if(!ReloadScript(m_strFileName))
                return;

            //Successfully loaded the script
            ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->GetWindowText(m_strScript);
        }

        CButton* pRadioVB   = (CButton*)GetDlgItem(IDC_RADIO_VB_SCRIPT);
        if(!m_strScript.IsEmpty())
        {
            if(pRadioVB->GetCheck())
                m_strScriptLanguage = g_szVBScript;
            else
                m_strScriptLanguage = g_szJavaScript;
        }
        else
            m_strScriptLanguage.Empty();

        //Copy to the Ret strings
        m_strRetFileName = m_strFileName;
        m_strRetScriptLanguage = m_strScriptLanguage;
        m_strRetScript = m_strScript;
    }
    
    CDialog::OnOK();
}





BOOL 
CScriptDialog::
ReloadScript(const CString& strFileName)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CScriptDialog,ReloadScript)
    if(strFileName.IsEmpty())
    {
        ASSERT(FALSE);
        return FALSE;
    }

    m_bDirty = TRUE;

    BYTE*  pBuffer = NULL;
    LPWSTR pszScript = NULL;
    BOOL bRet = FALSE;
    do
    {
        CFile file;
        CFileException fileException;

        if(!file.Open((LPCTSTR)strFileName, CFile::modeRead, &fileException))
        {
            //Failed to open the file. Show special error message 
            //in case path is incorrect
            if(CFileException::fileNotFound  == fileException.m_cause ||
               CFileException::badPath    == fileException.m_cause)
            {
                DisplayError(m_hWnd,
                             IDS_SCRIPT_NOT_FOUND,
                             (LPCTSTR)strFileName);
            }
            else
            {
                //Show generic error                
                DisplayError(m_hWnd,
                             IDS_CANNOT_OPEN_FILE,
                             (LPCTSTR)strFileName);
            }

            break;
        }

        //File is successfully opened
        
        //
        //MAXIMUM possible file size is AZ_MAX_TASK_BIZRULE_LENGTH WIDECHAR
        //Here we are considering 4bytes per Unicode which is maximum
        //
        if(file.GetLength() > AZ_MAX_TASK_BIZRULE_LENGTH*4)
        {
            DisplayError(m_hWnd, 
                         IDS_ERROR_BIZRULE_EXCEED_MAX_LENGTH,
                         AZ_MAX_TASK_BIZRULE_LENGTH);
            break;          
        }

        if(file.GetLength() == 0)
        {
            DisplayError(m_hWnd,
                         IDS_ERROR_EMPTY_SCRIPT_FILE,
                         strFileName);
            break;
        }

        //Allocate one extra byte for null termination. 
        pBuffer = (BYTE*)LocalAlloc(LPTR,file.GetLength() + sizeof(WCHAR));
        if(!pBuffer)
            break;
        
        int nRead = file.Read(pBuffer,
                             file.GetLength());

        if(!nRead)
        {

            ::DisplayError(m_hWnd,
                           IDS_CANNOT_READ_FILE_1,
                           (LPCTSTR)strFileName);
            break;
        }

        //Check if the file is unicode. First Character
        //in unicode file is 0xFEFF
        if(nRead >= 2 && (*(PWCHAR)pBuffer == 0xFEFF))
        {
            ((LPWSTR)pBuffer)[nRead/sizeof(WCHAR)] = 0;
            CString strScript = (LPWSTR)(pBuffer+2);
            PreprocessScript(strScript);
            ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->SetWindowText(strScript);
            //Enable the clear script button
            GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(TRUE);
            bRet = TRUE;
            break;
        }

        
        //Get the Size required for unicode
        int nWideChar = MultiByteToWideChar(CP_ACP, 
                                            MB_PRECOMPOSED,
                                            (LPCSTR)pBuffer,
                                            nRead,
                                            NULL,
                                            0);
        if(!nWideChar)
        {
            CString strError;
            GetSystemError(strError,HRESULT_FROM_WIN32(GetLastError()));
            ::DisplayError(m_hWnd,
                            IDS_FAILED_TO_READ_FILE,
                            (LPCTSTR)strError);
            
            break;
        }
        
        if(nWideChar > AZ_MAX_TASK_BIZRULE_LENGTH)
        {
            DisplayError(m_hWnd, 
                        IDS_ERROR_BIZRULE_EXCEED_MAX_LENGTH,
                        AZ_MAX_TASK_BIZRULE_LENGTH);
            break;
        }
        
        //Allocate one WCHAR extra for NULL termination
        pszScript = (LPWSTR)LocalAlloc(LPTR, (nWideChar+1)*sizeof(WCHAR));
        if(!pszScript)
            break;
        
        if(MultiByteToWideChar( CP_ACP, 
                                MB_PRECOMPOSED,
                                (LPCSTR)pBuffer,
                                nRead,
                                pszScript,
                                nWideChar))
        {
            pszScript[nWideChar] = 0;
            CString strScript = pszScript;
            PreprocessScript(strScript);
            ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->SetWindowText(strScript);
            //Enable the clear script button
            GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(TRUE);
            bRet = TRUE;
        }
        else
        {
            CString strError;
            GetSystemError(strError,HRESULT_FROM_WIN32(GetLastError()));
            ::DisplayError(m_hWnd,
                           IDS_FAILED_TO_READ_FILE,
                           (LPCTSTR)strError);
            
            break;
        }
    
    }while(0);

    if(pBuffer)
        LocalFree(pBuffer);
    if(pszScript) 
        LocalFree(pszScript);
    
    if(!bRet)
    {
        //IF failed to load the file, clear the script
        ((CEdit*)GetDlgItem(IDC_EDIT_CODE))->SetWindowText(L"");
        m_strScript.Empty();
        //Disable the clear button since there is nothing to clear
        GetDlgItem(IDC_CLEAR_SCRIPT)->EnableWindow(FALSE);
    }

    return bRet;
}




BOOL
GetScriptData(IN BOOL bReadOnly,
              IN CAdminManagerNode& adminManagerNode,
              IN OUT CString& strFileName,
              IN OUT CString& strScriptLanguage,
              IN OUT CString& strScript)
{
    CScriptDialog dlgScript(bReadOnly,
                            adminManagerNode,
                            strFileName,
                            strScriptLanguage,
                            strScript);

    if(IDOK == dlgScript.DoModal() && dlgScript.IsDirty())
        return TRUE;
    else
        return FALSE;
}

//+----------------------------------------------------------------------------
//  Function:SaveAuthorizationScriptData   
//  Synopsis:Saves the authorization script information for a task
//----------------------------------------------------------------------------- 
HRESULT
SaveAuthorizationScriptData(IN HWND hWnd,
                            IN CTaskAz& refTaskAz,
                            IN const CString& strFilePath,
                            IN const CString& strScriptLanguage,
                            IN const CString& strScript,
                            IN BOOL& refbErrorDisplayed)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,SaveAuthorizationScriptData)

    HRESULT hr = S_OK;

    if(!strScript.IsEmpty() && 
        strScriptLanguage.IsEmpty())
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    do
    {
        //NTRAID#NTBUG9-663899-2002/07/18-hiteshr
        //If bizrule and bizrule language are already set, say to VBScript,
        //changing bizrule language to jscript causes validataion of existing 
        //vb script with jscript engine which fails. As a work around, we 
        //first set bizrulelang and bizrule to empty, then set new bizrule 
        //and then bizrulelang

        //Set bizrule language to empty
        hr = refTaskAz.SetProperty(AZ_PROP_TASK_BIZRULE_LANGUAGE,
                                   L"");
        BREAK_ON_FAIL_HRESULT(hr);

        //Set bizrule to empty
        hr = refTaskAz.SetProperty(AZ_PROP_TASK_BIZRULE,
                                   L"");

        //Set bizrule language
        hr = refTaskAz.SetProperty(AZ_PROP_TASK_BIZRULE_LANGUAGE,
                                   strScriptLanguage);
        BREAK_ON_FAIL_HRESULT(hr);


        //Set bizrule
        hr = refTaskAz.SetProperty(AZ_PROP_TASK_BIZRULE,
                                   strScript);
        BREAK_ON_FAIL_HRESULT(hr);
                
        //Set bizrule file path
        hr = refTaskAz.SetProperty(AZ_PROP_TASK_BIZRULE_IMPORTED_PATH,
                                   strFilePath);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);

    if(FAILED(hr))
    {
        if(hr == OLESCRIPT_E_SYNTAX)
        {
            refbErrorDisplayed = TRUE;
            DisplayError(hWnd, IDS_SCRIPT_SYNTAX_INCORRECT,strFilePath);
        }
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  Function:GetAuthorizationScriptData   
//  Synopsis:Gets the authorization script data for a Task
//-----------------------------------------------------------------------------
HRESULT
GetAuthorizationScriptData(IN CTaskAz& refTaskAz,
                           OUT CString& strFilePath,
                           OUT CString& strScriptLanguage,
                           OUT CString& strScript)
{
    HRESULT hr = S_OK;

    do
    {
        hr = refTaskAz.GetProperty(AZ_PROP_TASK_BIZRULE_LANGUAGE,
                                   &strScriptLanguage);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = refTaskAz.GetProperty(AZ_PROP_TASK_BIZRULE,
                                   &strScript);
        BREAK_ON_FAIL_HRESULT(hr);

        PreprocessScript(strScript);
        
        hr = refTaskAz.GetProperty(AZ_PROP_TASK_BIZRULE_IMPORTED_PATH,
                                   &strFilePath);
        BREAK_ON_FAIL_HRESULT(hr);
    }while(0);

    return hr;
}

/******************************************************************************
Class:  COptionDlg
Purpose: Dialog for Selecting authorization manager options
******************************************************************************/
BEGIN_MESSAGE_MAP(COptionDlg, CHelpEnabledDialog)
    //{{AFX_MSG_MAP(CNewBaseDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
COptionDlg::
OnInitDialog()
{
    TRACE_METHOD_EX(DEB_SNAPIN,COptionDlg,OnInitDialog)
    if(m_refDeveloperMode)
    {
        ((CButton*)GetDlgItem(IDC_RADIO_DEVELOPER))->SetCheck(TRUE);
    }
    else
    {
        ((CButton*)GetDlgItem(IDC_RADIO_ADMINISTRATOR))->SetCheck(TRUE);
    }

    return TRUE;
}

void
COptionDlg::
OnOK()
{
    TRACE_METHOD_EX(DEB_SNAPIN,COptionDlg,OnOK)
    if(((CButton*)GetDlgItem(IDC_RADIO_DEVELOPER))->GetCheck())
        m_refDeveloperMode = TRUE;
    else
        m_refDeveloperMode = FALSE;

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\newobjectdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       PolicyStoreDlg.h
//
//  Contents:   Dialog boxes for Creating/Opening Policy Store
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

/******************************************************************************
Class:  CSortListCtrl
Purpose:Subclases ListCtrl class and handles initialization and sorting
******************************************************************************/
class CSortListCtrl : public CListCtrl
{
public:
    CSortListCtrl(UINT uiFlags,
                  BOOL bActionItem,
                  COL_FOR_LV *pColForLv,
                  BOOL bCheckBox = FALSE)
                  :m_iSortDirection(1),
                  m_iLastColumnClick(0),
                  m_uiFlags(uiFlags),
                  m_bActionItem(bActionItem),
                  m_pColForLv(pColForLv),
                  m_bCheckBox(bCheckBox)
    {
        ASSERT(m_pColForLv);
    }

    void Initialize();
    void Sort();

protected:
    afx_msg void
    OnListCtrlColumnClicked(NMHDR* pNotifyStruct, LRESULT* pResult);
private:
    int m_iSortDirection;
    int m_iLastColumnClick;
    UINT m_uiFlags;         //Contains info on columns of listctrl
    BOOL m_bActionItem;     //Is Item data in listentries is ActionItem.
                            //if False its of type CBaseAz* 
    COL_FOR_LV *m_pColForLv;
    BOOL m_bCheckBox;       //LVS_EX_CHECKBOXES style is used 
    WTL::CImageList m_imageList;
    DECLARE_MESSAGE_MAP()
};


class CHelpEnabledDialog: public CDialog
{
public:
    CHelpEnabledDialog(UINT nIDTemplate)
        :CDialog(nIDTemplate),
        m_nDialogId(nIDTemplate)
    {
    }

    INT_PTR DoModal();

protected:
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);  
    DECLARE_MESSAGE_MAP()
private:
    ULONG m_nDialogId;
};  



/******************************************************************************
Class:  CNewBaseDlg
Purpose: Base Dialog Class For creation of new objects
******************************************************************************/
class CNewBaseDlg : public CHelpEnabledDialog
{
public:
    CNewBaseDlg(IN CComponentDataObject* pComponentData,
                IN CBaseContainerNode * pBaseContainerNode,
                IN ATTR_MAP* pAttrMap,
                IN ULONG IDD_DIALOG,
                IN OBJECT_TYPE_AZ eObjectType);
    
    ~CNewBaseDlg();

protected:  
    
    virtual BOOL 
    OnInitDialog();
    
    afx_msg void 
    OnEditChangeName();
    
    virtual void 
    OnOK();

    //This Function should be implemented by derived classes which want to 
    //implement object type specific properties
    virtual HRESULT 
    SetObjectTypeSpecificProperties(IN CBaseAz* /*pBaseAz*/, 
                                    OUT BOOL& /*bErrorDisplayed*/){return S_OK;}
    
    virtual VOID 
    DisplayError(HRESULT hr);
    
        
    HRESULT 
    CreateObjectNodeAndAddToUI(CBaseAz* pBaseAz);
    
    
    CString 
    GetNameText();

    void
    SetNameText(const CString& strName);

    CRoleRootData* GetRootData() 
    { 
        return static_cast<CRoleRootData*>(m_pComponentData->GetRootData());
    }
    
    CComponentDataObject* GetComponentData(){return m_pComponentData;}
    CBaseContainerNode* GetBaseContainerNode(){return m_pBaseContainerNode;}
    CContainerAz* GetContainerAzObject()
    {
        CBaseContainerNode* pBaseContainerNode = GetBaseContainerNode();
        if(pBaseContainerNode)
        {
            return pBaseContainerNode->GetContainerAzObject();
        }
        return NULL;
    }

    DECLARE_MESSAGE_MAP()

private:
    CComponentDataObject* m_pComponentData;
    CBaseContainerNode * m_pBaseContainerNode;
    
    //Type of object created by this new dialog
    OBJECT_TYPE_AZ m_eObjectType;
    ATTR_MAP* m_pAttrMap;
};


/******************************************************************************
Class:  CNewApplicationDlg
Purpose: Dlg Class for creating new application
******************************************************************************/
class CNewApplicationDlg: public CNewBaseDlg
{
public:
    CNewApplicationDlg(IN CComponentDataObject* pComponentData,                         
                       IN CBaseContainerNode* pBaseContainerNode);
    ~CNewApplicationDlg();
private:
    DECLARE_MESSAGE_MAP()
};


/******************************************************************************
Class:  CNewScopeDlg
Purpose: Dlg Class for creating new scope
******************************************************************************/
class CNewScopeDlg: public CNewBaseDlg
{
public:
    CNewScopeDlg(IN CComponentDataObject* pComponentData,
                 IN CBaseContainerNode* pApplicationContainer);
    ~CNewScopeDlg();

private:
    DECLARE_MESSAGE_MAP()
};


/******************************************************************************
Class:  CNewGroupDlg
Purpose: Dlg Class for creating new group
******************************************************************************/
class CNewGroupDlg: public CNewBaseDlg
{

public:
    CNewGroupDlg(IN CComponentDataObject* pComponentData,
                     IN CBaseContainerNode* pApplicationContainer);
    ~CNewGroupDlg();
private:
    virtual BOOL 
    OnInitDialog();

    //Helper Functions For Creation of New Object
    virtual HRESULT 
    SetObjectTypeSpecificProperties(CBaseAz* pBaseAz, 
                                    BOOL& bSilent);

    DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:  CNewTaskDlg
Purpose: Dlg Class for creating new Task/Role Definition
******************************************************************************/
class CNewTaskDlg: public CNewBaseDlg
{
public:
    CNewTaskDlg(IN CComponentDataObject* pComponentData,
                IN CBaseContainerNode* pApplicationContainer,
                IN ULONG IDD_DIALOG,
                IN BOOL bRoleDefinition);
    ~CNewTaskDlg();

private:
    virtual BOOL 
    OnInitDialog();
    
    afx_msg void 
    OnButtonAdd();
        
    afx_msg void 
    OnButtonRemove();

    afx_msg void
    OnButtonEditScript();
    
    afx_msg void 
    OnListCtrlItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* pResult);
    
    afx_msg void
    OnListCtrlItemDeleted(NMHDR* /*pNotifyStruct*/, LRESULT* pResult);

    virtual VOID 
    DisplayError(HRESULT hr);

    void 
    SetRemoveButton();

    //Helper Functions For Creation of New Object
    virtual HRESULT 
    SetObjectTypeSpecificProperties(CBaseAz* pBaseAz, 
                                              BOOL& bSilent);

    CButton* 
    GetRemoveButton(){return (CButton*)GetDlgItem(IDC_REMOVE);}

    DECLARE_MESSAGE_MAP()

    CSortListCtrl m_listCtrl;

    BOOL m_bRoleDefinition;
    CString m_strFilePath;
    CString m_strScript;
    CString m_strScriptLanguage;
};

/******************************************************************************
Class:  CNewOperationDlg
Purpose: Dlg Class for creating new Operation
******************************************************************************/
class CNewOperationDlg: public CNewBaseDlg
{

public:
    CNewOperationDlg(IN CComponentDataObject* pComponentData,
                     IN CBaseContainerNode* pBaseContainerNode);
    ~CNewOperationDlg();
private:                                              
    DECLARE_MESSAGE_MAP()
};


class CNewAuthorizationStoreDlg: public CNewBaseDlg
{
public:
    CNewAuthorizationStoreDlg(CComponentDataObject* pComponentData);
    ~CNewAuthorizationStoreDlg();

private:
    virtual BOOL 
    OnInitDialog();
    
    virtual void 
    OnOK();
    
    afx_msg void 
    OnButtonBrowse();

    afx_msg void
    OnRadioChange();

    ULONG
    GetStoreType();
    
    DECLARE_MESSAGE_MAP()

    //User can switch between AD and XML store type.
    //These two variable stores the last setting of radio button
    //and text box. These are used to toggle the textbox values as
    //user toggle the radio buttons.
    CString m_strLastStoreName;
    LONG m_lLastRadioSelection;
    BOOL m_bADAvailable;
};

class COpenAuthorizationStoreDlg: public CNewBaseDlg
{
public:
    COpenAuthorizationStoreDlg(CComponentDataObject* pComponentData);
    ~COpenAuthorizationStoreDlg();

private:
    virtual BOOL 
    OnInitDialog();
    
    virtual void 
    OnOK();
    
    afx_msg void 
    OnButtonBrowse();
    
    afx_msg void
    OnRadioChange();

    ULONG
    GetStoreType();

    DECLARE_MESSAGE_MAP()

    //User can switch between AD and XML store type.
    //These two variable stores the last setting of radio button
    //and text box. These are used to toggle the textbox values as
    //user toggle the radio buttons.
    CString m_strLastStoreName;
    LONG m_lLastRadioSelection;
    BOOL m_bADAvailable;

};

/******************************************************************************
Class:  CScriptDialog
Purpose: Dialog for Reading the script
******************************************************************************/
class CScriptDialog : public CHelpEnabledDialog
{
public:
    CScriptDialog(BOOL bReadOnly,
                  CAdminManagerNode& adminManagerNode,
                  CString& strFileName,
                  CString& strScriptLanguage,
                  CString& strScript);
    ~CScriptDialog();

    virtual BOOL 
    OnInitDialog();
    
    void 
    OnOK();

    BOOL
    IsDirty(){ return m_bDirty;}

private:
    afx_msg void 
    OnBrowse();

    afx_msg void 
    OnReload();

    afx_msg void
    OnClear();

    afx_msg void
    OnRadioChange();

    afx_msg void 
    OnEditChangePath();

    afx_msg HBRUSH 
    OnCtlColor(CDC* pDC,
               CWnd* pWnd,
               UINT nCtlColor);


    BOOL 
    ReloadScript(const CString& strFileName);

    void
    MatchRadioWithExtension(const CString& strFileName);

    DECLARE_MESSAGE_MAP()

//DATA MEMBERS
    BOOL m_bDirty;

    //These is refrence to strings passed by client. We change them only
    //if ok is pressed
    CString& m_strRetFileName;
    CString& m_strRetScriptLanguage;
    CString& m_strRetScript;

    //We work on these strings during the lifetime of dialog
    CString m_strFileName;
    CString m_strScriptLanguage;
    CString m_strScript;
    BOOL m_bReadOnly;
    BOOL m_bInit;
    CAdminManagerNode& m_adminManagerNode;
};

//+----------------------------------------------------------------------------
//  Function:GetAuthorizationScriptData   
//  Synopsis:Gets the authorization script data for a Task
//-----------------------------------------------------------------------------
HRESULT
GetAuthorizationScriptData(IN CTaskAz& refTaskAz,
                           OUT CString& strFilePath,
                           OUT CString& strScriptLanguage,
                           OUT CString& strScript);


//+----------------------------------------------------------------------------
//  Function:SaveAuthorizationScriptData   
//  Synopsis:Saves the authorization script information for a task
//-----------------------------------------------------------------------------
HRESULT
SaveAuthorizationScriptData(IN HWND hWnd,
                            IN CTaskAz& refTaskAz,
                            IN const CString& strFilePath,
                            IN const CString& strScriptLanguage,
                            IN const CString& strScript,
                            IN BOOL& bErrorDisplayed);

//+----------------------------------------------------------------------------
//  Function:GetScriptData   
//  Synopsis:Displays the script Dialog. Dialog is initialized with info 
//               passed to the function and any changes made are returned.
//-----------------------------------------------------------------------------
BOOL
GetScriptData(IN BOOL bReadOnly,
              IN CAdminManagerNode& adminManagerNode,
              IN OUT CString& strFilePath,
              IN OUT CString& strScriptLanguage,
              IN OUT CString& strScript);


/******************************************************************************
Class:  COptionDlg
Purpose: Dialog for Selecting authorization manager options
******************************************************************************/
class COptionDlg : public CHelpEnabledDialog
{
public:
    COptionDlg(IN BOOL & refDeveloperMode)
               :CHelpEnabledDialog(IDD_OPTIONS),
               m_refDeveloperMode(refDeveloperMode)
    {
    }

    void 
    OnOK();

    BOOL 
    OnInitDialog();
private:    
    BOOL& m_refDeveloperMode;
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\propbase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"


/******************************************************************************
Class:  CRolePropertyPageHolder
Purpose: PropertyPageHolder used by this snapin
******************************************************************************/
CRolePropertyPageHolder::
CRolePropertyPageHolder(CContainerNode* pContNode, 
                        CTreeNode* pNode,
                        CComponentDataObject* pComponentData)
                        :CPropertyPageHolderBase(pContNode, 
                                                 pNode, 
                                                 pComponentData)
{
    CPropertyPageHolderBase::SetSheetTitle(IDS_FMT_PROP_SHEET_TITLE,pNode);
}


/******************************************************************************
Class:  CBaseRolePropertyPage
Purpose: Base Class for all property pages
******************************************************************************/
void  
CBaseRolePropertyPage::
OnCancel()
{
    if(IsDirty())
    {
        //Clear the cache of base object
        GetBaseAzObject()->Clear();
    }
    CPropertyPageBase::OnCancel();
}


BOOL 
CBaseRolePropertyPage::
OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    DWORD_PTR pHelpMap = NULL;
    if(FindDialogContextTopic(m_nDialogId, &pHelpMap))
    {
        ASSERT(pHelpMap);
        ::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                  g_szContextHelpFileName,
                  HELP_WM_HELP,
                  pHelpMap);

        return TRUE;
    }
    return FALSE;
}


/******************************************************************************
Class:  CGeneralPropertyPage
Purpose: An Attribute Map based property class which can be used by property
pages which are simple. Used by all general property pages
******************************************************************************/
BOOL 
CGeneralPropertyPage::
OnInitDialog()
{
    if(GetAttrMap())
    {
        BOOL bRet = InitDlgFromAttrMap(this,
                                       GetAttrMap(),
                                       GetBaseAzObject(),
                                       IsReadOnly());
        if(bRet)
            SetInit(TRUE);
        return bRet;
    }
    
    //Nothing to Init
    return TRUE;
}

BOOL 
CGeneralPropertyPage::
OnApply()
{
    if(!IsDirty())
        return TRUE;

    HRESULT hr = S_OK;
    BOOL bErrorDisplayed = FALSE;
    CBaseAz* pBaseAz = GetBaseAzObject();
    do
    {
                
        hr = SaveAttrMapChanges(this,
                                GetAttrMap(),
                                pBaseAz,    
                                FALSE,
                                &bErrorDisplayed, 
                                NULL);

        BREAK_ON_FAIL_HRESULT(hr);

        //Submit the changes
        hr = pBaseAz->Submit();
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);

    if(SUCCEEDED(hr))
    {
        SetDirty(FALSE);
        CRolePropertyPageHolder* pHolder = (CRolePropertyPageHolder*)GetHolder();
        ASSERT(pHolder);
        pHolder->NotifyConsole(this);
        return TRUE;
    }
    else
    {
        if(!bErrorDisplayed)
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
            
            ::DisplayError(m_hWnd,
                           IDS_GENERIC_PROPERTY_SAVE_ERROR,
                           (LPCTSTR)strError);
        }
        return FALSE;
    }
}




BEGIN_MESSAGE_MAP(CAdminManagerGeneralProperty, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CApplicationGeneralPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_VERSION, OnDirty)
END_MESSAGE_MAP()

BOOL 
CApplicationGeneralPropertyPage::
OnInitDialog()
{
    //Call the base class implementation
    CGeneralPropertyPage::OnInitDialog();

    //Application name and version info can only be modified in the the 
    //developer mode
    if(!((CRoleRootData*)(GetBaseNode()->GetAdminManagerNode()->GetRootContainer()))->IsDeveloperMode())
    {
        GetDlgItem(IDC_EDIT_NAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_VERSION)->EnableWindow(FALSE);
    }
    return TRUE;
}


BEGIN_MESSAGE_MAP(CScopeGeneralPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CGroupGeneralPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
END_MESSAGE_MAP()

BOOL
CGroupGeneralPropertyPage::
OnInitDialog()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupGeneralPropertyPage,OnInitDialog)
    LONG lGroupType;
    HRESULT hr = ((CGroupAz*)GetBaseAzObject())->GetGroupType(&lGroupType);
    if(SUCCEEDED(hr))
    {
        if(AZ_GROUPTYPE_LDAP_QUERY == lGroupType)
        {
            GetDlgItem(IDI_ICON_LDAP_GROUP)->ShowWindow(SW_SHOW);
        }
        else
        {
            GetDlgItem(IDI_ICON_BASIC_GROUP)->ShowWindow(SW_SHOW);
        }
    }

    //Call the base class Property page
    return CGeneralPropertyPage::OnInitDialog();
}

BEGIN_MESSAGE_MAP(CGroupQueryPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_LDAP_QUERY, OnDirty)
END_MESSAGE_MAP()


BEGIN_MESSAGE_MAP(CTaskGeneralPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(COperationGeneralPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_OPERATION_NUMBER, OnDirty)
END_MESSAGE_MAP()

/******************************************************************************
Class:  CAdminManagerAdvancedPropertyPage
Purpose: Limits Property Page for AdminManger
******************************************************************************/
BEGIN_MESSAGE_MAP(CAdminManagerAdvancedPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_TIMEOUT, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_SCRIPT_ENGINE_TIMEOUT, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_MAX_SCRIPT_ENGINE, OnDirty)
    ON_BN_CLICKED(IDC_BUTTON_DEFAULT, OnButtonDefault)
    ON_BN_CLICKED(IDC_RADIO_AUTH_SCRIPT_DISABLED, OnRadioChange)
    ON_BN_CLICKED(IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT,OnRadioChange)
    ON_BN_CLICKED(IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT,OnRadioChange)
END_MESSAGE_MAP()

BOOL
CAdminManagerAdvancedPropertyPage::
OnInitDialog()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAdvancedPropertyPage,OnInitDialog)
    //Call the base class Property page
    if(CGeneralPropertyPage::OnInitDialog())
    {
        if(IsReadOnly())
        {
            ((CButton*)GetDlgItem(IDC_BUTTON_DEFAULT))->EnableWindow(FALSE);
        }

        //Get the initial value for m_lAuthScriptTimeoutValue
        HRESULT hr = GetBaseAzObject()->GetProperty(AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT, &m_lAuthScriptTimeoutValue);
        if(FAILED(hr) || m_lAuthScriptTimeoutValue <= 0)
        {
            m_lAuthScriptTimeoutValue = AZ_AZSTORE_DEFAULT_SCRIPT_ENGINE_TIMEOUT;
        }


        //Set the limit text for all the three edit buttons

        //Get Length of Maximum Long
        long lMaxLong = LONG_MAX;
        WCHAR szMaxLongBuffer[34];
        _ltow(lMaxLong,szMaxLongBuffer,10);
        size_t nMaxLen = wcslen(szMaxLongBuffer);
        ((CEdit*)GetDlgItem(IDC_EDIT_DOMAIN_TIMEOUT))->SetLimitText((UINT)nMaxLen);
        ((CEdit*)GetDlgItem(IDC_EDIT_SCRIPT_ENGINE_TIMEOUT))->SetLimitText((UINT)nMaxLen);
        ((CEdit*)GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE))->SetLimitText((UINT)nMaxLen);
        return TRUE;
    }
    return FALSE;
}

void
CAdminManagerAdvancedPropertyPage::
OnButtonDefault()
{   
    TRACE_METHOD_EX(DEB_SNAPIN,CAdminManagerAdvancedPropertyPage,OnButtonDefault)
    //Authorization script is enabled with no timeout value.
    if( ((CButton*)GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT))->GetCheck() == BST_CHECKED)
    {
        SetLongValue((CEdit*)GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE),AZ_AZSTORE_DEFAULT_MAX_SCRIPT_ENGINES);
    }        
    //Authorization script is enabled with timeout
    else if(((CButton*)GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT))->GetCheck() == BST_CHECKED)
    {
        SetLongValue((CEdit*)GetDlgItem(IDC_EDIT_SCRIPT_ENGINE_TIMEOUT),AZ_AZSTORE_DEFAULT_SCRIPT_ENGINE_TIMEOUT);
        SetLongValue((CEdit*)GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE),AZ_AZSTORE_DEFAULT_MAX_SCRIPT_ENGINES);
    }

    SetLongValue((CEdit*)GetDlgItem(IDC_EDIT_DOMAIN_TIMEOUT),AZ_AZSTORE_DEFAULT_DOMAIN_TIMEOUT);
    SetDirty(TRUE);
}

void 
CAdminManagerAdvancedPropertyPage::
OnRadioChange()
{

    //
    //If the value in "Authorization script timeout" edit control is not IDS_INFINITE,
    //convert it to long and save it in m_lAuthScriptTimeoutValue. 
    //
    CString strInfinite;
    VERIFY(strInfinite.LoadString(IDS_INFINITE));
    CString strTimeoutValue;
    CEdit *pEditAuthScriptTimeout = (CEdit*)GetDlgItem(IDC_EDIT_SCRIPT_ENGINE_TIMEOUT);    
    pEditAuthScriptTimeout->GetWindowText(strTimeoutValue);
    if(strInfinite != strTimeoutValue)
    {    
      //Get the value of authorization script timeout textbox
      LONG lAuthScriptTimeoutValue = 0;
      if(GetLongValue(*pEditAuthScriptTimeout,lAuthScriptTimeoutValue,m_hWnd))
      {
         if(lAuthScriptTimeoutValue > 0)
               m_lAuthScriptTimeoutValue = lAuthScriptTimeoutValue;
      }
    }

    //Authorization script is disabled
    if( ((CButton*)GetDlgItem(IDC_RADIO_AUTH_SCRIPT_DISABLED))->GetCheck() == BST_CHECKED)
    {
        //Disable autorization script timeout textbox and set its value to zero
        SetLongValue(pEditAuthScriptTimeout,0);
        pEditAuthScriptTimeout->EnableWindow(FALSE);

        //Disable max script engine textbox and set its value to actual value in store
        LONG lMaxCachedScripts = 0;
        HRESULT hr = GetBaseAzObject()->GetProperty(AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES,&lMaxCachedScripts);
        if(SUCCEEDED(hr))
        {
            SetLongValue((CEdit*)GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE),lMaxCachedScripts);
        }
        GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE)->EnableWindow(FALSE);
    }
    //Authorization script is enabled with no timeout value.
    else if( ((CButton*)GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT))->GetCheck() == BST_CHECKED)
    {
        //Enable script engine textbox
        GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE)->EnableWindow(TRUE);

        //Disable autorization script timeout textbox and sets it value to "no timeout"
        pEditAuthScriptTimeout->SetWindowText(strInfinite);
        pEditAuthScriptTimeout->EnableWindow(FALSE);
    }        
    //Authorization script is enabled with timeout
    else if(((CButton*)GetDlgItem(IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT))->GetCheck() == BST_CHECKED)
    {
        //Enable script engine textbox
        GetDlgItem(IDC_EDIT_MAX_SCRIPT_ENGINE)->EnableWindow(TRUE);

        //Enable autorization script timeout textbox
        pEditAuthScriptTimeout->EnableWindow(TRUE);
        SetLongValue(pEditAuthScriptTimeout,m_lAuthScriptTimeoutValue);
    }

    SetDirty(TRUE);
}

//+----------------------------------------------------------------------------
//  Function:MakeBaseAzListToActionItemList   
//  Synopsis:Takes a list of BaseAz object and creates a list of ActionItems   
//-----------------------------------------------------------------------------
HRESULT
MakeBaseAzListToActionItemList(IN CList<CBaseAz*,CBaseAz*>& listBaseAz,
                               IN OUT CList<ActionItem*,ActionItem*>& listActionItem)
{
    while(listBaseAz.GetCount())
    {
        ActionItem* pActionItem = new ActionItem(listBaseAz.RemoveHead());
        if(!pActionItem)
            return E_OUTOFMEMORY;

        listActionItem.AddTail(pActionItem);
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:MakeBaseAzListToActionItemMap
//  Synopsis:Takes a list of BaseAz object and creates a map of ActionItems   
//-----------------------------------------------------------------------------
HRESULT
MakeBaseAzListToActionItemMap(IN CList<CBaseAz*,CBaseAz*>& listBaseAz,
                              IN OUT ActionMap& mapActionItems)
{
    while(listBaseAz.GetCount())
    {
        ActionItem* pActionItem = new ActionItem(listBaseAz.RemoveHead());
        if(!pActionItem)
            return E_OUTOFMEMORY;

        mapActionItems.insert(pair<const CString*,ActionItem*>(&(pActionItem->m_pMemberAz->GetName()),pActionItem));
    }
    return S_OK;
}

/******************************************************************************
Class:  CListCtrlPropertyPage
Purpose: Base class for property pages which have list control and primary 
action is to add/delete items from it.
******************************************************************************/

//+----------------------------------------------------------------------------
//  Function:AddMember   
//  Synopsis:Add one member to ActionList   
//  Returns:HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) if pMemberAz is already
//              in the list    
//-----------------------------------------------------------------------------
HRESULT
CListCtrlPropertyPage::
AddMember(IN CBaseAz* pMemberAz,
          IN OUT ActionMap& mapActionItem,
          IN UINT uiFlags)
{   
    TRACE_METHOD_EX(DEB_SNAPIN,CListCtrlPropertyPage,AddMember)

    if(!pMemberAz)
    {
        ASSERT(pMemberAz);
        return E_POINTER;
    }

    //Check if item is already present in the list
    ActionItem* pCurActionItem = NULL;
    for (ActionMap::iterator it = mapActionItem.lower_bound(&(pMemberAz->GetName()));
         it != mapActionItem.upper_bound(&(pMemberAz->GetName()));
         ++it)
    {
        pCurActionItem = (*it).second;
        if(pCurActionItem->action == ACTION_REMOVED)
        {
            pCurActionItem = NULL;
            continue;
        }
        
        CBaseAz* pCurBaseAz = pCurActionItem->m_pMemberAz;
        
        if(EqualObjects(pCurBaseAz,pMemberAz))
        {
            //Item already present
            break;
        }

        pCurActionItem = NULL;
        pCurBaseAz = NULL;
    }

    if(pCurActionItem)
    {
        if(pCurActionItem->action == ACTION_REMOVE)
        {
            pCurActionItem->action = ACTION_NONE;
        }
        else //pCurActionItem->action == ACTION_NONE
              //pCurActionItem->action == ACTION_ADD
        {
            return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
    }
    else
    {
        //Create a new Action item
        pCurActionItem = new ActionItem(pMemberAz);
        if(!pCurActionItem)
            return E_OUTOFMEMORY;

        pCurActionItem->action = ACTION_ADD;
        mapActionItem.insert(pair<const CString*,ActionItem*>(&(pCurActionItem->m_pMemberAz->GetName()),pCurActionItem));
    }

    //Add Current Item to listcontrol
    AddActionItemToListCtrl(&m_listCtrl,
                            0,
                            pCurActionItem, 
                            uiFlags);

    return S_OK;
}

BOOL
CListCtrlPropertyPage::
EqualObjects(CBaseAz* p1, CBaseAz* p2)
{
    if(p1 && 
       p2 &&
       (p1->GetObjectType() == p2->GetObjectType()) &&
       (p1->GetName() == p2->GetName()))
    {
        return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  Function:AddMembers
//  Synopsis:Add List of BaseAz items to list of action items.       
//  Returns: Number of items added.
//-----------------------------------------------------------------------------
int
CListCtrlPropertyPage::
AddMembers(IN CList<CBaseAz*,CBaseAz*>& listMembers,
           IN OUT ActionMap& mapActionItem,
           IN UINT uiFlags)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CListCtrlPropertyPage,AddMembers)

    if(listMembers.IsEmpty())
        return 0;

    int cItemsAdded = 0;
    while(listMembers.GetCount())
    {
        //Add Member
        CBaseAz* pMember = listMembers.RemoveHead();
        HRESULT hr = AddMember(pMember,
                               mapActionItem,
                               uiFlags);
    
        if(FAILED(hr))
        {
            if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
            {
                hr = S_OK;              
            }
            else
            {
                //Display Generic Error. 
                CString strError;
                GetSystemError(strError, hr);                   
                ::DisplayError(m_hWnd,
                                    IDS_ERROR_ADD_MEMBER_OBJECT,
                                    (LPCTSTR)strError,
                                    (LPCTSTR)pMember->GetName());

            }
            delete pMember;
            pMember = NULL;
        }
        else
        {
            cItemsAdded++;
            //An item has been added to list.
            //Enable Apply button
            OnDirty();
        }
    }

    m_listCtrl.Sort();
    return cItemsAdded;
}

BOOL 
CListCtrlPropertyPage::
OnInitDialog()
{
    VERIFY(m_listCtrl.SubclassDlgItem(m_nIdListCtrl,this));
    m_listCtrl.Initialize();

    //Remove button should be disabled in the begining
    GetRemoveButton()->EnableWindow(FALSE); 

    if(IsReadOnly())
        MakeControlsReadOnly();
    
    return TRUE;
}

//+----------------------------------------------------------------------------
//  Function:RemoveMember   
//  Synopsis:Set the action for ActionItem to remove   
//-----------------------------------------------------------------------------
void
CListCtrlPropertyPage::
RemoveMember(ActionItem* pActionItem)
{
    if(!pActionItem)
    {
        ASSERT(pActionItem);
        return;
    }

    if(pActionItem->action == ACTION_NONE)
        pActionItem->action = ACTION_REMOVE;
    else
    {
        //If this item was a newly added item,
        //marked it Removed. We won't attepmt to
        //remove it from the object
        pActionItem->action = ACTION_REMOVED;
    }
    OnDirty();
}

void
CListCtrlPropertyPage::
OnButtonRemove()
{
    //Remember the Position of first selected entry.
    int iFirstSelectedItem = m_listCtrl.GetNextItem(-1, LVIS_SELECTED);

    int iSelectedItem = -1;
    while( (iSelectedItem = m_listCtrl.GetNextItem(iSelectedItem, LVIS_SELECTED)) != -1)
    {
        RemoveMember((ActionItem*)(m_listCtrl.GetItemData(iSelectedItem)));
        m_listCtrl.DeleteItem(iSelectedItem);
        iSelectedItem--;        
   }

    if(m_listCtrl.GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;

    SelectListCtrlItem(&m_listCtrl, iFirstSelectedItem);
}

void
CListCtrlPropertyPage::
OnListCtrlItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* pResult)
{
    if(!pResult)
        return;
    *pResult = 0;
    if(!IsReadOnly())
    {
        SetRemoveButton();
    }
}


void
CListCtrlPropertyPage::
SetRemoveButton()
{
    EnableButtonIfSelectedInListCtrl(&m_listCtrl,
                                     GetRemoveButton());
}



//+----------------------------------------------------------------------------
//  Function:DoActionsFromActionList   
//  Synopsis:For each ActionItem in list, do the action. This function is 
//          called from the derived class OnApply. 
//-----------------------------------------------------------------------------
BOOL
CListCtrlPropertyPage::
DoActionsFromActionMap(IN ActionMap& mapActionItem,
                       LONG param)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CListCtrlPropertyPage,DoActionsFromActionList);
    
    HRESULT hr = S_OK;
    
    CBaseAz* pBaseAz = GetBaseAzObject();
    
    for (ActionMap::iterator it = mapActionItem.begin();
         it != mapActionItem.end();
         ++it)
    {
        ActionItem* pActionItem = (*it).second;
        
        //We need to take action only for add or remove
        if(pActionItem->action == ACTION_ADD || 
           pActionItem->action == ACTION_REMOVE)
        {
            //Derived class implements this function
            //and understands param
            hr = DoOneAction(pActionItem,
                             param);
            if(FAILED(hr))
            {
                CString strError;
                GetSystemError(strError, hr);               
                ::DisplayError(m_hWnd,
                               (pActionItem->action == ACTION_ADD) ? IDS_ADD_FAILED : IDS_DELETE_FAILED,
                               (LPCTSTR)strError,
                               (LPCTSTR)(pActionItem->m_pMemberAz->GetName()));         
                break;
            }
            else
            {
                if(pActionItem->action == ACTION_ADD)
                    //Item has been added
                    pActionItem->action = ACTION_NONE;
                else
                    //Item has been removed
                    pActionItem->action = ACTION_REMOVED;
            }
        }
    }
    
    if(FAILED(hr))
        return FALSE;
    
    return TRUE;
}


/******************************************************************************
Class:  CTaskDefinitionPropertyPage
Purpose: Property Page for Task Definition
******************************************************************************/
BEGIN_MESSAGE_MAP(CTaskDefinitionPropertyPage, CListCtrlPropertyPage)
    //{{AFX_MSG_MAP(CTaskDefinitionPropertyPage)
    ON_BN_CLICKED(IDC_ADD_TASK, OnButtonAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_EDIT_SCRIPT,OnButtonEditScript)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_TASK_OPERATION, OnListCtrlItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CTaskDefinitionPropertyPage::
~CTaskDefinitionPropertyPage()
{
    RemoveItemsFromActionMap(m_mapActionItem);
}

BOOL 
CTaskDefinitionPropertyPage::
OnInitDialog()
{
    HRESULT hr = S_OK;
    do
    {
        if(!CListCtrlPropertyPage::OnInitDialog())
        {
            hr = E_FAIL;
            break;
        }
        
        CBaseAz* pBaseAz = GetBaseAzObject();

        //Add Member Tasks
        CList<CBaseAz*,CBaseAz*> listTasks;
        hr = pBaseAz->GetMembers(AZ_PROP_TASK_TASKS,
                                 listTasks);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = MakeBaseAzListToActionItemMap(listTasks,
                                            m_mapActionItem);
        BREAK_ON_FAIL_HRESULT(hr);
        
        //Add Member Operations
        CList<CBaseAz*,CBaseAz*> listOperations;
        hr = pBaseAz->GetMembers(AZ_PROP_TASK_OPERATIONS,
                                 listOperations);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = MakeBaseAzListToActionItemMap(listOperations, 
                                            m_mapActionItem);
        BREAK_ON_FAIL_HRESULT(hr);

        //And Tasks and Operations to list control
        AddActionItemFromMapToListCtrl(m_mapActionItem,
                                        &m_listCtrl,
                                        GetUIFlags(),
                                        FALSE);

        //Get Script Data
        hr = GetAuthorizationScriptData(*(CTaskAz*)GetBaseAzObject(),
                                         m_strFileName,
                                         m_strScriptLanguage,
                                         m_strScript);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);
    
    if(FAILED(hr))
    {
        return FALSE;
    }

    //Sort the list control
    m_listCtrl.Sort();

    SetInit(TRUE);
    return TRUE;
}


void
CTaskDefinitionPropertyPage::
OnButtonAdd()
{
    CBaseAz* pBaseAz= GetBaseAzObject();
    CContainerAz* pContainerAz = pBaseAz->GetParentAz();
    ASSERT(pContainerAz);
    

    CList<CBaseAz*,CBaseAz*> listObjectsSelected;
    if(!GetSelectedDefinitions(IsRoleDefinition(),
                               pContainerAz,
                               listObjectsSelected))
    {
        return;
    }
    
    //Add selected members to appropriate property and to listctrl
    AddMembers(listObjectsSelected,
               m_mapActionItem,
               GetUIFlags());
    return; 
}

void
CTaskDefinitionPropertyPage::
OnButtonEditScript()
{
    if(IsBizRuleWritable(m_hWnd,*(GetBaseAzObject()->GetParentAz())))
    {
        if(GetScriptData(IsReadOnly(),
                         *GetBaseNode()->GetAdminManagerNode(),
                         m_strFileName,
                         m_strScriptLanguage,
                         m_strScript))
        {
            OnDirty();
            m_bScriptDirty = TRUE;            
        }
    }
}


HRESULT
CTaskDefinitionPropertyPage::
DoOneAction(IN ActionItem* pActionItem,
            LONG )
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,DoOneAction)

    if(!pActionItem)
    {
        ASSERT(pActionItem);
        return E_POINTER;
    }

    CBaseAz* pBaseAz = GetBaseAzObject();

    //Decide what property to change
    LONG lPropId = AZ_PROP_TASK_TASKS;
    if(pActionItem->m_pMemberAz->GetObjectType() == OPERATION_AZ)
        lPropId = AZ_PROP_TASK_OPERATIONS;

    if(pActionItem->action == ACTION_ADD)
        return pBaseAz->AddMember(lPropId,
                                  pActionItem->m_pMemberAz);
    else
        return  pBaseAz->RemoveMember(lPropId,
                                      pActionItem->m_pMemberAz);
}

void
CTaskDefinitionPropertyPage::
MakeControlsReadOnly()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,MakeControlsReadOnly)
        
    GetDlgItem(IDC_ADD_TASK)->EnableWindow(FALSE);
    GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE);
}


BOOL 
CTaskDefinitionPropertyPage::
OnApply()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,OnApply)

    if(!IsDirty())
        return TRUE;

    //Save the items from the action list
    if(!DoActionsFromActionMap(m_mapActionItem,
                                        0))
    {
        return FALSE;
    }

    HRESULT hr = S_OK;
    BOOL bErrorDisplayed = FALSE;

    //Save the authorization data
    if(m_bScriptDirty)
    {
        hr = SaveAuthorizationScriptData(m_hWnd,
                                        *(CTaskAz*)GetBaseAzObject(),
                                        m_strFileName,
                                        m_strScriptLanguage,
                                        m_strScript,
                                        bErrorDisplayed);           
    }

    if(SUCCEEDED(hr))
    {
        m_bScriptDirty = FALSE;
        hr = GetBaseAzObject()->Submit();
    }

    if(FAILED(hr))
    {
        if(!bErrorDisplayed)
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
                    
            ::DisplayError(m_hWnd,
                           IDS_GENERIC_PROPERTY_SAVE_ERROR,
                           (LPCTSTR)strError);
        }
        return FALSE;
    }
    else
    {
        SetDirty(FALSE);
        return TRUE;
    }
    return FALSE;
}


/******************************************************************************
Class:  Group Membership Property Page
Purpose: Property Page Group Definition
******************************************************************************/
BEGIN_MESSAGE_MAP(CGroupMemberPropertyPage, CListCtrlPropertyPage)
    //{{AFX_MSG_MAP(CGroupMemberPropertyPage)
    ON_BN_CLICKED(IDC_ADD_APPLICATION_GROUP, OnButtonAddApplicationGroups)
    ON_BN_CLICKED(IDC_ADD_WINDOWS_GROUPS, OnButtonAddWindowsGroups)
    ON_BN_CLICKED(IDC_REMOVE, OnButtonRemove)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_MEMBER, OnListCtrlItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CGroupMemberPropertyPage::
~CGroupMemberPropertyPage()
{
    RemoveItemsFromActionMap(m_mapActionItem);
}

BOOL 
CGroupMemberPropertyPage::
OnInitDialog()
{
    HRESULT hr = S_OK;
    do
    {
        if(!CListCtrlPropertyPage::OnInitDialog())
        {
            hr = E_FAIL;
            break;
        }
        
        CBaseAz* pBaseAz = static_cast<CBaseAz*>(GetBaseAzObject());
        
        //Add Member ApplicationGroups
        CList<CBaseAz*,CBaseAz*> listAppGroups;
        hr = pBaseAz->GetMembers(m_bMember ? AZ_PROP_GROUP_APP_MEMBERS : AZ_PROP_GROUP_APP_NON_MEMBERS,
                                 listAppGroups);
        BREAK_ON_FAIL_HRESULT(hr);
        
        hr = MakeBaseAzListToActionItemMap(listAppGroups,
                                           m_mapActionItem);
        BREAK_ON_FAIL_HRESULT(hr);
        
        
        //Add Member Windows Groups/User        
        CList<CBaseAz*,CBaseAz*> listWindowsGroups;
        hr = pBaseAz->GetMembers(m_bMember ? AZ_PROP_GROUP_MEMBERS : AZ_PROP_GROUP_NON_MEMBERS,
                                 listWindowsGroups);
        BREAK_ON_FAIL_HRESULT(hr);
        
        hr = MakeBaseAzListToActionItemMap(listWindowsGroups,
                                            m_mapActionItem);
        BREAK_ON_FAIL_HRESULT(hr);
        
        //Add Members to list control
        AddActionItemFromMapToListCtrl(m_mapActionItem,
                                        &m_listCtrl,
                                        GetUIFlags(),
                                        FALSE);
    }while(0);
    
    if(FAILED(hr))
    {
        return FALSE;
    }
    //Sort the list control
    m_listCtrl.Sort();
    
    SetInit(TRUE);
    return TRUE;
}

void
CGroupMemberPropertyPage::
MakeControlsReadOnly()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,MakeControlsReadOnly)
    
    GetDlgItem(IDC_ADD_APPLICATION_GROUP)->EnableWindow(FALSE);
    GetDlgItem(IDC_ADD_WINDOWS_GROUPS)->EnableWindow(FALSE);
    GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE);
}

void
CGroupMemberPropertyPage::
OnButtonAddApplicationGroups()
{
    CBaseAz* pBaseAz = GetBaseAzObject();
    CList<CBaseAz*,CBaseAz*> listObjectsSelected;

    if(!GetSelectedAzObjects(m_hWnd,
                             GROUP_AZ,
                             pBaseAz->GetParentAz(),
                             listObjectsSelected))
    {
        return;
    }
    
    AddMembers(listObjectsSelected,
               m_mapActionItem,
               GetUIFlags());   
}

void
CGroupMemberPropertyPage::
OnButtonAddWindowsGroups()
{

    CSidHandler* pSidHandler = GetBaseAzObject()->GetSidHandler();
    ASSERT(pSidHandler);

    //Display Object Picker and get list of Users to add
    CList<CBaseAz*,CBaseAz*> listWindowsGroups;
    HRESULT hr = pSidHandler->GetUserGroup(m_hWnd,
                                           GetBaseAzObject(),
                                           listWindowsGroups);
    if(FAILED(hr))
    {
        return;
    }
    
    TIMER("Time taken to AddMembers");
    AddMembers(listWindowsGroups,
               m_mapActionItem,
               GetUIFlags());
}


HRESULT
CGroupMemberPropertyPage::
DoOneAction(IN ActionItem* pActionItem,
                LONG )
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupMemberPropertyPage,DoOneAction)
    if(!pActionItem)
    {
        ASSERT(pActionItem);
        return E_POINTER;
    }

    CBaseAz* pBaseAz = GetBaseAzObject();
    CBaseAz* pMember = pActionItem->m_pMemberAz;

    LONG lPropId;
    if(pMember->GetObjectType() == GROUP_AZ)
    {
        lPropId = m_bMember ? AZ_PROP_GROUP_APP_MEMBERS : AZ_PROP_GROUP_APP_NON_MEMBERS;
    }
    else if(pMember->GetObjectType() == SIDCACHE_AZ)
    {
        lPropId = m_bMember ? AZ_PROP_GROUP_MEMBERS : AZ_PROP_GROUP_NON_MEMBERS;
    }
        
    if(pActionItem->action == ACTION_ADD)
        return pBaseAz->AddMember(lPropId,pMember);
    else
        return pBaseAz->RemoveMember(lPropId,pMember);
}

BOOL 
CGroupMemberPropertyPage::
OnApply()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CGroupMemberPropertyPage,OnApply)

    if(!IsDirty())
        return TRUE;

    if(DoActionsFromActionMap(m_mapActionItem,0))
    {       
        HRESULT hr = GetBaseAzObject()->Submit();
        if(FAILED(hr))
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
                
            ::DisplayError(m_hWnd,
                           IDS_GENERIC_PROPERTY_SAVE_ERROR,
                           (LPCTSTR)strError);
            return FALSE;
        }
        else
        {
            SetDirty(FALSE);
            return TRUE;
        }
    }
    return FALSE;
}

/******************************************************************************
Class:  CSecurityPropertyPage
Purpose: Security Property Page
******************************************************************************/
BEGIN_MESSAGE_MAP(CSecurityPropertyPage, CListCtrlPropertyPage)
    //{{AFX_MSG_MAP(CGroupMemberPropertyPage)
    ON_BN_CLICKED(IDC_ADD, OnButtonAddWindowsGroups)
    ON_BN_CLICKED(IDC_REMOVE, OnButtonRemove)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_MEMBER, OnListCtrlItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_USER_ROLE, OnComboBoxItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSecurityPropertyPage::
~CSecurityPropertyPage()
{
    RemoveItemsFromActionMap(m_mapAdminActionItem);
    RemoveItemsFromActionMap(m_mapReadersActionItem);
    RemoveItemsFromActionMap(m_mapDelegatedUsersActionItem);
}

BOOL 
CSecurityPropertyPage::
OnInitDialog()
{
    HRESULT hr = S_OK;
    do
    {
        if(!CListCtrlPropertyPage::OnInitDialog())
        {
            hr = E_FAIL;
            break;
        }

        CContainerAz* pContainerAz = static_cast<CContainerAz*>(GetBaseAzObject());
        CComboBox *pComboBox = (CComboBoxEx*)GetDlgItem(IDC_COMBO_USER_ROLE);

        //Add Items to combo box
        CString strName;
        VERIFY(strName.LoadString(IDS_POLICY_ADMIN));
        pComboBox->InsertString(0,strName);
        pComboBox->SetItemData(0,AZ_PROP_POLICY_ADMINS);

        VERIFY(strName.LoadString(IDS_POLICY_READER));
        pComboBox->InsertString(1,strName);
        pComboBox->SetItemData(1,AZ_PROP_POLICY_READERS);

        m_bDelegatorPresent = pContainerAz->IsDelegatorSupported();
        if(m_bDelegatorPresent)
        {
            VERIFY(strName.LoadString(IDS_POLICY_DELEGATOR));
            pComboBox->InsertString(2,strName);
            pComboBox->SetItemData(2,AZ_PROP_DELEGATED_POLICY_USERS);
        }
        pComboBox->SetCurSel(0);
        
        CList<CBaseAz*,CBaseAz*> listAdmins;
        CList<CBaseAz*,CBaseAz*> listReaders;
        CList<CBaseAz*,CBaseAz*> listDelegatedUsers;

        //Get List of Administrators and add it to listbox
        hr = GetPolicyUsersFromAllLevel(AZ_PROP_POLICY_ADMINS,
                                        pContainerAz,
                                        listAdmins);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = MakeBaseAzListToActionItemMap(listAdmins,
                                           m_mapAdminActionItem);
        BREAK_ON_FAIL_HRESULT(hr);
        
        AddActionItemFromMapToListCtrl(m_mapAdminActionItem,
                                       &m_listCtrl,
                                       GetUIFlags(),
                                       FALSE);
        //Get List of Readers
        hr = GetPolicyUsersFromAllLevel(AZ_PROP_POLICY_READERS,
                                        pContainerAz,
                                        listReaders);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = MakeBaseAzListToActionItemMap(listReaders,
                                           m_mapReadersActionItem);
        BREAK_ON_FAIL_HRESULT(hr);

        if(m_bDelegatorPresent)
        {
            //Get List of Delegated users
            hr = pContainerAz->GetMembers(AZ_PROP_DELEGATED_POLICY_USERS,
                                          listDelegatedUsers);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = MakeBaseAzListToActionItemMap(listDelegatedUsers,
                                                m_mapDelegatedUsersActionItem);
            BREAK_ON_FAIL_HRESULT(hr);
        }
    }while(0);
    
    if(FAILED(hr))
    {
        return FALSE;
    }
    //Sort the list control
    m_listCtrl.Sort();

    SetInit(TRUE);
    return TRUE;
}

ActionMap&
CSecurityPropertyPage::
GetListForComboSelection(LONG lComboSel)
{
    if(lComboSel == AZ_PROP_POLICY_ADMINS)
        return m_mapAdminActionItem;
    else if(lComboSel == AZ_PROP_POLICY_READERS)
        return m_mapReadersActionItem;
    else //AZ_PROP_DELEGATED_POLICY_USERS
        return m_mapDelegatedUsersActionItem;
}

void
CSecurityPropertyPage::
ReloadAdminList()
{
    HRESULT hr = S_OK;
    do
    {
        //We need to reload the Admin list if all the admins are removed.In that 
        //case core will add owner to the admin list and we need to refresh the 
        //list
        m_mapAdminActionItem.clear();

        CList<CBaseAz*,CBaseAz*> listAdmins;
        CContainerAz* pContainerAz = static_cast<CContainerAz*>(GetBaseAzObject());
        //Get List of Administrators and add it to listbox
        hr = GetPolicyUsersFromAllLevel(AZ_PROP_POLICY_ADMINS,
                                        pContainerAz,
                                        listAdmins);

        BREAK_ON_FAIL_HRESULT(hr);
    

        hr = MakeBaseAzListToActionItemMap(listAdmins,
                                           m_mapAdminActionItem);
        BREAK_ON_FAIL_HRESULT(hr);
        
        if(AZ_PROP_POLICY_ADMINS == m_LastComboSelection)
        {
            //Clear the current items from the list
            m_listCtrl.DeleteAllItems();

            AddActionItemFromMapToListCtrl(m_mapAdminActionItem,
                                           &m_listCtrl,
                                           GetUIFlags(),
                                           FALSE);
        }
    }while(0);

    //ToDO Display Error in case of failure
}


void
CSecurityPropertyPage::
MakeControlsReadOnly()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,MakeControlsReadOnly)    
    GetDlgItem(IDC_ADD)->EnableWindow(FALSE);
    GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE);
}

BOOL 
CSecurityPropertyPage::
HandleBizruleScopeInteraction()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,HandleBizruleScopeInteraction)   
    
    //Delegation is not allowed in ceratin conditions at scope level for AD 
    //store. 
    //Check if we are at scope level, store type is AD and we are modifying 
    //AZ_PROP_POLICY_ADMINS
    CBaseAz* pBaseAz = GetBaseAzObject();
    if(pBaseAz->GetObjectType() != SCOPE_AZ ||
       pBaseAz->GetAdminManager()->GetStoreType() != AZ_ADMIN_STORE_AD ||
       m_LastComboSelection != AZ_PROP_POLICY_ADMINS)
    {
        return TRUE;
    }

    CScopeAz* pScopeAz = dynamic_cast<CScopeAz*>(pBaseAz);
    if(!pScopeAz)
    {
        ASSERT(pScopeAz);
        return FALSE;
    }

    //Condition 1: Scope is not delegatable which is true when There are 
    //authorization scripts in objects defined in the scope.
    //If now user assigns someone to the Admin role for the scope 
    //(by clicking Add):
    BOOL bDelegatable = FALSE;
    HRESULT hr = pScopeAz->CanScopeBeDelegated(bDelegatable);
    if(FAILED(hr))
    {
        //Lets try to add and we will fail eventually and show the error
        return TRUE;
    }

    if(!bDelegatable)
    {
        DisplayError(m_hWnd,
                     IDS_SCOPE_NOT_DELEGATABLE,
                     (LPCWSTR)pScopeAz->GetName());
        return FALSE;
    }

    //Condition 2: The scope has not been delegated and there are not 
    //authorization scripts in objects defined in the scope, and the user 
    //now assigns someone to the Admin role for the scope (by clicking Add 
    //and selecting a user).

    BOOL bScriptWritable = FALSE;
    hr = pScopeAz->BizRulesWritable(bScriptWritable);
    if(SUCCEEDED(hr) && bScriptWritable)
    {
        DisplayInformation(m_hWnd,
                           IDS_DELEGATING_PREVENTS_SCRIPTS,
                           (LPCWSTR)pScopeAz->GetName());
    }

    return TRUE;
}

void 
CSecurityPropertyPage::
OnButtonAddWindowsGroups()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CTaskDefinitionPropertyPage,OnButtonAddWindowsGroups)    

    if(!HandleBizruleScopeInteraction())
        return;

    CSidHandler* pSidHandler = GetBaseAzObject()->GetSidHandler();
    ASSERT(pSidHandler);

    //Display Object Picker and get list of Users to add
    CList<CBaseAz*,CBaseAz*> listWindowsGroups;
    HRESULT hr = pSidHandler->GetUserGroup(m_hWnd,
                                           GetBaseAzObject(),
                                           listWindowsGroups);
    if(FAILED(hr))
    {
        return;
    }

    BOOL m_bAdminSelected = TRUE;
    
    AddMembers(listWindowsGroups,
               GetListForComboSelection(m_LastComboSelection),
               GetUIFlags());
}



void
CSecurityPropertyPage::
OnButtonRemove()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSecurityPropertyPage,OnButtonRemove)
    //
    //Only entries that were defined at this object level can
    //be deleted. Entries which are inherited from parent cannot
    //be deleted here. Check if there is atleast one entry which
    //can be deleted.
    //
    CBaseAz* pBaseAz = GetBaseAzObject();

    BOOL bAtleastOneInherited = FALSE;
    BOOL bAtleastOneExplicit = FALSE;

    int iSelectedItem = -1;
    while( (iSelectedItem = m_listCtrl.GetNextItem(iSelectedItem, LVIS_SELECTED)) != -1)
    {
        ActionItem* pActionItem = (ActionItem*)m_listCtrl.GetItemData(iSelectedItem);
        CSidCacheAz * pSidCacheAz = (CSidCacheAz *)pActionItem->m_pMemberAz;

        if(pBaseAz->GetType() == pSidCacheAz->GetParentType())
        {
            bAtleastOneExplicit = TRUE;
        }
        else
        {
            bAtleastOneInherited = TRUE;
        }
   }

    if(bAtleastOneInherited && !bAtleastOneExplicit)
    {
        ::DisplayInformation(m_hWnd,IDS_ALL_POLICY_USERS_INHERITED);
        return;
    }
    else if(bAtleastOneInherited && bAtleastOneExplicit)
    {
        //Ask user if wants to delete explict entries
        if(IDNO == ::DisplayConfirmation(m_hWnd,IDS_SOME_POLICY_USERS_INHERITED))
            return;
    }

    //Remember the Position of first selected entry.
    int iFirstSelectedItem = m_listCtrl.GetNextItem(-1, LVIS_SELECTED);

    iSelectedItem = -1;
    while( (iSelectedItem = m_listCtrl.GetNextItem(iSelectedItem, LVIS_SELECTED)) != -1)
    {
        ActionItem* pActionItem = (ActionItem*)m_listCtrl.GetItemData(iSelectedItem);
        CSidCacheAz * pSidCacheAz = (CSidCacheAz *)pActionItem->m_pMemberAz;

        if(pBaseAz->GetType() == pSidCacheAz->GetParentType())
        {
            RemoveMember(pActionItem);
            m_listCtrl.DeleteItem(iSelectedItem);
            iSelectedItem--;
        }
    }

    if(m_listCtrl.GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;

    SelectListCtrlItem(&m_listCtrl, iFirstSelectedItem);
}


void 
CSecurityPropertyPage::
OnComboBoxItemChanged()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSecurityPropertyPage,OnComboBoxItemChanged)

    CComboBox* pComboBox = (CComboBox*)GetDlgItem(IDC_COMBO_USER_ROLE);
    LONG lComboSelection = (LONG)pComboBox->GetItemData(pComboBox->GetCurSel());

    if(lComboSelection == m_LastComboSelection)
        return;

    m_listCtrl.DeleteAllItems();
    GetRemoveButton()->EnableWindow(FALSE);

    m_LastComboSelection = lComboSelection;     
    AddActionItemFromMapToListCtrl(GetListForComboSelection(m_LastComboSelection),
                                    &m_listCtrl,
                                    GetUIFlags(),
                                    FALSE);
        
    //Resort the items
    m_listCtrl.Sort();
}


BOOL
CSecurityPropertyPage::
EqualObjects(CBaseAz* p1, CBaseAz* p2)
{
    /* p1 is the item already in the list and p2 is the new item we are tying 
    to add. p1 and p2 are equal if and only if their names, objecttype and
    parent type are equal. In security page, we only list sid objects and 
    since sid object doesn't have parents, GetParentType for sid objcet
    returns the name of object sid is assigned to.*/
    if(p1 && 
       p2 &&
       (p1->GetObjectType() == p2->GetObjectType()) &&
       (p1->GetName() == p2->GetName()) &&
       (p1->GetParentType() == GetBaseAzObject()->GetType()))
    {
        return TRUE;
    }
    return FALSE;
}


HRESULT
CSecurityPropertyPage::
DoOneAction(ActionItem* pActionItem,
            LONG lPropId)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSecurityPropertyPage,DoOneAction)

    CBaseAz* pBaseAz = GetBaseAzObject();

    if(pActionItem->action == ACTION_ADD)
        return pBaseAz->AddMember(lPropId,
                                  pActionItem->m_pMemberAz);
    else
        return pBaseAz->RemoveMember(lPropId,
                                     pActionItem->m_pMemberAz);
}

BOOL 
CSecurityPropertyPage::
OnApply()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CSecurityPropertyPage,OnApply)

    if(!IsDirty())
        return TRUE;

    if(DoActionsFromActionMap(m_mapAdminActionItem,AZ_PROP_POLICY_ADMINS) &&
       DoActionsFromActionMap(m_mapReadersActionItem,AZ_PROP_POLICY_READERS) &&
       DoActionsFromActionMap(m_mapDelegatedUsersActionItem,AZ_PROP_DELEGATED_POLICY_USERS))
    {       
        HRESULT hr = GetBaseAzObject()->Submit();
        if(FAILED(hr))
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
                
            ::DisplayError(m_hWnd,
                                IDS_GENERIC_PROPERTY_SAVE_ERROR,
                                (LPCTSTR)strError);
            return FALSE;
        }
        else
        {
            ReloadAdminList();
            SetDirty(FALSE);
            return TRUE;
        }
    }
    return FALSE;
}


/******************************************************************************
Class:  CAuditPropertyPage
Purpose: Audit Property Page 
******************************************************************************/
BEGIN_MESSAGE_MAP(CAuditPropertyPage,CBaseRolePropertyPage)
    ON_BN_CLICKED(IDC_AUDIT_AUTHORIZATION_MANAGER, OnDirty)
    ON_BN_CLICKED(IDC_AUDIT_STORE, OnDirty)
    ON_NOTIFY(NM_CLICK, IDC_AUDIT_HELP_LINK, OnLinkClick)
    ON_NOTIFY(NM_RETURN, IDC_AUDIT_HELP_LINK, OnLinkClick)
END_MESSAGE_MAP()

void 
CAuditPropertyPage::
OnLinkClick(NMHDR* /*pNotifyStruct*/, LRESULT* /*pResult*/)
{

    CDisplayHelpFromPropPageExecContext ctx;
    ctx.m_strHelpPath= L"AuthM.chm::/authm_resources.htm";
    ctx.m_pComponentDataObject= GetBaseNode()->GetComponentDataObject();
    VERIFY(GetBaseNode()->GetComponentDataObject()->PostExecMessage(&ctx,NULL));
    ctx.Wait();
}

BOOL
CAuditPropertyPage::
OnInitDialog()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAuditPropertyPage,OnInitDialog)
    
    CBaseAz* pBaseAz = GetBaseAzObject();

    //At application level runtime auditing has different
    //lable
    if(APPLICATION_AZ == pBaseAz->GetObjectType())
    {
        CString strLabel;
        if(strLabel.LoadString(IDS_APP_AUDIT_STRING))
        {
            GetDlgItem(IDC_AUDIT_AUTHORIZATION_MANAGER)->SetWindowText(strLabel);
        }
    }
    
    BOOL bGenerateAudit = FALSE;
    BOOL bStoreSacl = FALSE;

    //Check is Generation of Audit by authorization store is supported
    if(SUCCEEDED(pBaseAz->GetProperty(AZ_PROP_GENERATE_AUDITS,&bGenerateAudit)))
    {
        m_bRunTimeAuditSupported = TRUE;
    }
    
    //Check if Generation of Audit by underlying store is supported
    if(SUCCEEDED(pBaseAz->GetProperty(AZ_PROP_APPLY_STORE_SACL,&bStoreSacl)))
    {
        m_bStoreSaclSupported = TRUE;
    }
    

    CButton* pBtnRuntimeAudit = (CButton*)GetDlgItem(IDC_AUDIT_AUTHORIZATION_MANAGER);
    CButton* pBtnSacl = (CButton*)GetDlgItem(IDC_AUDIT_STORE);
    
    if(IsReadOnly())
    {
        pBtnRuntimeAudit->EnableWindow(FALSE);
        pBtnSacl->EnableWindow(FALSE);
    }

    if(m_bRunTimeAuditSupported)
    {
        pBtnRuntimeAudit->SetCheck(bGenerateAudit ? BST_CHECKED : BST_UNCHECKED);
    }

    BOOL bParentStateStaticVisible = FALSE;
    if(m_bStoreSaclSupported)
    {
        pBtnSacl->SetCheck(bStoreSacl ? BST_CHECKED : BST_UNCHECKED);
        int idStrParentState = GetParentAuditStateStringId(AZ_PROP_APPLY_STORE_SACL);
        if(idStrParentState != -1)
        {
            CString strParentState;
            strParentState.LoadString(idStrParentState);
            GetDlgItem(IDC_PARENT_SACL_STATE)->SetWindowText(strParentState);
            bParentStateStaticVisible = TRUE;
        }
    }

    MoveAndHideControls(m_bRunTimeAuditSupported,
                        m_bStoreSaclSupported,
                        bParentStateStaticVisible);

    SetInit(TRUE);
    return TRUE;
}

//+----------------------------------------------------------------------------
//  Function: MoveAndHideControls  
//  Synopsis: Helper function to move and hide controls at initialization time
//-----------------------------------------------------------------------------
void
CAuditPropertyPage::
MoveAndHideControls(BOOL bRunTimeAuditSupported,
                    BOOL bStoreSaclSupported,
                    BOOL bParentStateShown)
{
    //
    //There is assumption here that controls are in following order.
    //1)Runtime Client Context checkbox
    //2)Policy store change checkbox
    //3)Static control displayig state of 2) at parent level
    //4)Help link
    //
    //if this order is getting changed. Order of this code must be changed.


    //Get Coordinates of controls
    RECT rcRuntimeAuditCheckBox;
    ZeroMemory(&rcRuntimeAuditCheckBox, sizeof(RECT));
    CButton* pBtnRuntimeAudit = (CButton*)GetDlgItem(IDC_AUDIT_AUTHORIZATION_MANAGER);
    pBtnRuntimeAudit->GetClientRect(&rcRuntimeAuditCheckBox);
    pBtnRuntimeAudit->MapWindowPoints(this,&rcRuntimeAuditCheckBox);
      
    RECT rcSaclCheckBox;    
    ZeroMemory(&rcSaclCheckBox, sizeof(RECT));
    CButton* pBtnSacl = (CButton*)GetDlgItem(IDC_AUDIT_STORE);
    pBtnSacl->GetClientRect(&rcSaclCheckBox);
    pBtnSacl->MapWindowPoints(this,&rcSaclCheckBox);
    
    RECT rcParentStateStatic;
    ZeroMemory(&rcParentStateStatic, sizeof(RECT));
    CWnd* pParentStateStaic = GetDlgItem(IDC_PARENT_SACL_STATE);
    pParentStateStaic->GetClientRect(&rcParentStateStatic);
    pParentStateStaic->MapWindowPoints(this,&rcParentStateStatic);
    
    RECT rcHelpLinkWindow;
    ZeroMemory(&rcHelpLinkWindow, sizeof(RECT));
    CWnd* pHelpLinkWindow = GetDlgItem(IDC_AUDIT_HELP_LINK);
    pHelpLinkWindow->GetClientRect(&rcHelpLinkWindow);
    pHelpLinkWindow->MapWindowPoints(this,&rcHelpLinkWindow);


    int iMoveup = 0;
    if(!bRunTimeAuditSupported)
    {
        pBtnRuntimeAudit->ShowWindow(SW_HIDE);
        iMoveup = rcSaclCheckBox.top - rcRuntimeAuditCheckBox.top;
    }

    if(bStoreSaclSupported)
    {
        if(iMoveup)
        {
            rcSaclCheckBox.top -= iMoveup;
            rcSaclCheckBox.bottom -= iMoveup;
            pBtnSacl->MoveWindow(&rcSaclCheckBox);
        }
    }
    else
    {
        pBtnSacl->ShowWindow(SW_HIDE);
        iMoveup += (rcParentStateStatic.top - rcSaclCheckBox.top);
    }
    
    if(bParentStateShown)
    {
        if(iMoveup)
        {
            rcParentStateStatic.top -= iMoveup;
            rcParentStateStatic.bottom -= iMoveup;
            pParentStateStaic->MoveWindow(&rcParentStateStatic);
        }
    }
    else
    {
        pParentStateStaic->ShowWindow(SW_HIDE);
        iMoveup += (rcHelpLinkWindow.top - rcParentStateStatic.top);
    }

    if(iMoveup)
    {
        rcHelpLinkWindow.top -= iMoveup;
        rcHelpLinkWindow.bottom -= iMoveup;
        pHelpLinkWindow->MoveWindow(&rcHelpLinkWindow);
    }
    
}

//+----------------------------------------------------------------------------
//  Function: GetParentAuditStateStringId  
//  Synopsis: This function gets resource id for message which explains
//            if lPropId is already set at parents  
//  Arguments:
//  Returns:    -1 the message is not to be displayed.
//-----------------------------------------------------------------------------
int
CAuditPropertyPage::
GetParentAuditStateStringId(LONG lPropId)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAuditPropertyPage,GetParentAuditStateStringId)

    if(lPropId != AZ_PROP_APPLY_STORE_SACL)
    {
        ASSERT(FALSE);
        return -1;
    }

    CBaseAz* pBaseAz = GetBaseAzObject();
    BOOL bPropSetForApp = FALSE;
    BOOL bPropSetForAuthMan = FALSE;
    if(pBaseAz->GetObjectType() == SCOPE_AZ)
    {
        //Check if Applicaiton has this property set
        CBaseAz* pApplicationAz = pBaseAz->GetParentAz();
        if(FAILED(pApplicationAz->GetProperty(lPropId,&bPropSetForApp)))
        {
            bPropSetForApp = FALSE;
        }

        //Check if Authorization Manager has this property set
        CBaseAz* pAuthorizationManager = pApplicationAz->GetParentAz();
        if(FAILED(pAuthorizationManager->GetProperty(lPropId,&bPropSetForAuthMan)))
        {
            bPropSetForAuthMan = FALSE;
        }

    }
    else if(pBaseAz->GetObjectType() == APPLICATION_AZ)
    {
        //
        //Check if Authorization Manager has this property set
        //
        CBaseAz* pAuthorizationManager = pBaseAz->GetParentAz();
        ASSERT(pAuthorizationManager);      
        if(FAILED(pAuthorizationManager->GetProperty(lPropId,&bPropSetForAuthMan)))
        {
            bPropSetForAuthMan = FALSE;
        }
    }

    int idstr = -1;

    if(bPropSetForAuthMan && bPropSetForApp)
    {
        idstr = IDS_SACL_SET_FOR_APP_AUTH;
    }
    else if(bPropSetForAuthMan)
    {
        idstr = IDS_SACL_SET_FOR_AUTH;
    }
    else if(bPropSetForApp)
    {
        idstr = IDS_SACL_SET_FOR_APP;
    }

    return idstr;

}


BOOL
CAuditPropertyPage::
OnApply()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CAuditPropertyPage,OnApply)

    if(!IsDirty())
        return TRUE;

    HRESULT hr = S_OK;
    BOOL bDisplayAuditMessageBox = FALSE;
    CBaseAz* pBaseAz = GetBaseAzObject();
    do
    {
        if(m_bRunTimeAuditSupported)
        {
            //Get the original setting
            BOOL bOriginalSetting = FALSE;
            hr = pBaseAz->GetProperty(AZ_PROP_GENERATE_AUDITS,&bOriginalSetting);
            BREAK_ON_FAIL_HRESULT(hr);
            
            //Get the new setting
            CButton* pBtn = (CButton*)GetDlgItem(IDC_AUDIT_AUTHORIZATION_MANAGER);
            BOOL bNewSetting = (pBtn->GetCheck() == BST_CHECKED);
            if(bNewSetting != bOriginalSetting)
            {
                if(bNewSetting)
                {
                    //We are turning auditing on, show the messagebox
                    bDisplayAuditMessageBox = TRUE;
                }                
                hr = pBaseAz->SetProperty(AZ_PROP_GENERATE_AUDITS,bNewSetting);
                BREAK_ON_FAIL_HRESULT(hr);
            }
        }

        if(m_bStoreSaclSupported)
        {
            //Get the original setting
            BOOL bOriginalSetting = FALSE;
            hr = pBaseAz->GetProperty(AZ_PROP_APPLY_STORE_SACL,&bOriginalSetting);
            BREAK_ON_FAIL_HRESULT(hr);
            
            //Get the new setting
            CButton * pBtn = (CButton*)GetDlgItem(IDC_AUDIT_STORE);
            BOOL bNewSetting = (pBtn->GetCheck() == BST_CHECKED);

            if(bNewSetting != bOriginalSetting)
            {
                if(bNewSetting)
                {
                    //We are turning auditing on, show the messagebox
                    bDisplayAuditMessageBox = TRUE;
                }

                hr = pBaseAz->SetProperty(AZ_PROP_APPLY_STORE_SACL,(pBtn->GetCheck() == BST_CHECKED));
                BREAK_ON_FAIL_HRESULT(hr);
            }
        }
    
    }while(0);

    if(SUCCEEDED(hr))
    {
        hr = pBaseAz->Submit();
        CHECK_HRESULT(hr);
    }

    if(FAILED(hr))
    {
        //Display Generic Error
        CString strError;
        GetSystemError(strError, hr);   
            
        ::DisplayError(m_hWnd,
                       IDS_GENERIC_PROPERTY_SAVE_ERROR,
                       (LPCTSTR)strError);
        return FALSE;
    }
    else
    {
        //Everything successful. Display Audit Message if required
        if(bDisplayAuditMessageBox)
        {
            DisplayWarning(m_hWnd,IDS_AUDIT_REQUIRE_EXTRA_SETTING);
        }
        SetDirty(FALSE);
        return TRUE;
    }
}


/******************************************************************************
Class:  CRoleGeneralPropertyPage
Purpose: General Property Page for Role
******************************************************************************/
BEGIN_MESSAGE_MAP(CRoleGeneralPropertyPage, CGeneralPropertyPage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnDirty)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnDirty)
    ON_BN_CLICKED(IDC_BUTTON_DEFINITION,OnShowDefinition)
END_MESSAGE_MAP()

void
CRoleGeneralPropertyPage::
OnShowDefinition()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleGeneralPropertyPage,OnShowDefinition)

    CRoleAz* pRoleAz = dynamic_cast<CRoleAz*>(GetBaseAzObject());
    ASSERT(pRoleAz);

    HRESULT hr = S_OK;

    do
    {
        //Get Member Tasks
        CList<CBaseAz*,CBaseAz*> listTask;
        hr = pRoleAz->GetMembers(AZ_PROP_ROLE_TASKS, listTask);
        BREAK_ON_FAIL_HRESULT(hr);

        //Get Member Operations
        CList<CBaseAz*, CBaseAz*> listOperations;
        hr = pRoleAz->GetMembers(AZ_PROP_ROLE_OPERATIONS, listOperations);
        BREAK_ON_FAIL_HRESULT(hr);

        BOOL bRoleFromDefinition = FALSE;

        //A Role Created From Role Definition( i.e. created via snapin)
        //should not have any member operations and should only have only
        //one task and that task should have RoleDefinition Bit on.
        if(listOperations.IsEmpty() && listTask.GetCount() == 1)
        {
            CTaskAz* pTaskAz = (CTaskAz*)listTask.GetHead();
            if(pTaskAz->IsRoleDefinition())
            {
                bRoleFromDefinition = TRUE;
                if(!DisplayRoleDefintionPropertyPages(pTaskAz))
                {
                    RemoveItemsFromList(listTask);
                }
            }
        }

        if(!bRoleFromDefinition)
        {
            RemoveItemsFromList(listTask);
            RemoveItemsFromList(listOperations);
            CRoleDefDialog dlgRoleDef(*pRoleAz);
            dlgRoleDef.DoModal();
        }


    }while(0);
}

BOOL
CRoleGeneralPropertyPage::
DisplayRoleDefintionPropertyPages(IN CTaskAz* pTaskAz)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleGeneralPropertyPage,DisplayRoleDefintionPropertyPages)
    if(!pTaskAz)
    {
        ASSERT(pTaskAz);
        return FALSE;
    }

    HRESULT hr = S_OK;
    do
    {
        //Create a Node for it(COOKIE)
        CTaskNode * pTaskNode = new CTaskNode(GetBaseNode()->GetComponentDataObject(),
                                              GetBaseNode()->GetAdminManagerNode(),
                                              pTaskAz);
        if(!pTaskNode)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        pTaskNode->NodeForPropSheet();
        pTaskNode->SetContainer(GetBaseNode()->GetAdminManagerNode());
        
        CPropPageExecContext ctx;
        ctx.pTreeNode = pTaskNode;
        ctx.pComponentDataObject = GetBaseNode()->GetComponentDataObject();
        VERIFY(GetBaseNode()->GetComponentDataObject()->PostExecMessage(&ctx,(WPARAM)FALSE));
        ctx.Wait();
    }while(0);

    if(SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

HRESULT
AddSingleActionItem(IN CBaseAz* pMemberAz,
                    IN CSortListCtrl& refListCtrl,
                    IN OUT CList<ActionItem*,ActionItem*>& listActionItem,
                    IN UINT uiFlags)
{   


    if(!pMemberAz)
    {
        ASSERT(pMemberAz);
        return E_POINTER;
    }

    //
    //Check if item is already present in the list
    //

    ActionItem* pCurActionItem = NULL;
    POSITION pos = listActionItem.GetHeadPosition();    
    
    for( int i = 0; i < listActionItem.GetCount(); ++i)
    {
        pCurActionItem = listActionItem.GetNext(pos);
        if(pCurActionItem->action == ACTION_REMOVED)
        {
            pCurActionItem = NULL;
            continue;
        }
        
        CBaseAz* pCurBaseAz = pCurActionItem->m_pMemberAz;
        ASSERT(pCurBaseAz);
        
        if((pCurBaseAz->GetObjectType() == pMemberAz->GetObjectType()) &&
            (pCurBaseAz->GetName() == pMemberAz->GetName()))
        {
            //Item already present
            break;
        }

        pCurActionItem = NULL;
        pCurBaseAz = NULL;
    }

    //
    //Item is already in the list
    //
    if(pCurActionItem)
    {
        //
        //If Pending action on the item is remove, change it to none
        //
        if(pCurActionItem->action == ACTION_REMOVE)
        {
            pCurActionItem->action = ACTION_NONE;
        }
        else //pCurActionItem->action == ACTION_NONE
              //pCurActionItem->action == ACTION_ADD
        {
            return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
    }
    else
    {
        //Create a new Action item
        pCurActionItem = new ActionItem(pMemberAz);
        if(!pCurActionItem)
            return E_OUTOFMEMORY;

        pCurActionItem->action = ACTION_ADD;
        listActionItem.AddTail(pCurActionItem);
    }

    //Add Current Item to listcontrol
    AddActionItemToListCtrl(&refListCtrl,
                            0,
                            pCurActionItem, 
                            uiFlags);

    return S_OK;
}

//+----------------------------------------------------------------------------
//  Function:AddMembers
//  Synopsis:Add List of BaseAz items to list of action items.       
//-----------------------------------------------------------------------------
void
AddActionItems(IN CList<CBaseAz*,CBaseAz*>& listMembers,
               IN CSortListCtrl& refListCtrl,
               IN HWND hWnd,
               IN OUT CList<ActionItem*,ActionItem*>& listActionItem,
               IN UINT uiFlags)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,AddActionItems)

    if(listMembers.IsEmpty())
        return ;

    while(listMembers.GetCount())
    {
        //Add Member
        CBaseAz* pMember = listMembers.RemoveHead();
        ASSERT(pMember);
        HRESULT hr = AddSingleActionItem(pMember,
                                         refListCtrl,
                                         listActionItem,
                                         uiFlags);
    
        if(FAILED(hr))
        {
            if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
            {
                hr = S_OK;              
            }
            else
            {
                //Display Generic Error. 
                CString strError;
                GetSystemError(strError, hr);                   
                ::DisplayError(hWnd,
                               IDS_ERROR_ADD_MEMBER_OBJECT,
                               (LPCTSTR)strError,
                               (LPCTSTR)pMember->GetName());

            }
            delete pMember;
            pMember = NULL;
        }
    }

    refListCtrl.Sort();
}

void
RemoveMember(ActionItem* pActionItem)
{
    if(!pActionItem)
    {
        ASSERT(pActionItem);
        return;
    }

    if(pActionItem->action == ACTION_NONE)
        pActionItem->action = ACTION_REMOVE;
    else
    {
        //If this item was a newly added item,
        //marked it Removed. We won't attepmt to
        //remove it from the object
        pActionItem->action = ACTION_REMOVED;
    }
}

/******************************************************************************
Class:  CRoleDefDialog
Purpose: Displays the role definition for role created out side UI.
******************************************************************************/
BEGIN_MESSAGE_MAP(CRoleDefDialog, CHelpEnabledDialog)
    //{{AFX_MSG_MAP(CTaskDefinitionPropertyPage)
    ON_BN_CLICKED(IDC_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnButtonRemove)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_OP_TASK, OnListCtrlItemChanged)
    ON_NOTIFY(LVN_DELETEITEM, IDC_LIST_OP_TASK, OnListCtrlItemDeleted)
    ON_NOTIFY(LVN_INSERTITEM, IDC_LIST_OP_TASK, OnListCtrlItemInserted)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CRoleDefDialog::
CRoleDefDialog(CRoleAz& refRoleAz)
              :CHelpEnabledDialog(IDD_ROLE_DEF_DIALOG),
              m_refRoleAz(refRoleAz),
              m_bDirty(FALSE),
              m_listCtrl(COL_NAME | COL_TYPE | COL_DESCRIPTION,
                         TRUE,
                         Col_For_Task_Role)
{
    //Check if Role Object is Readonly
    BOOL bWrite = FALSE;
    m_bReadOnly = TRUE;
    HRESULT hr = m_refRoleAz.IsWritable(bWrite);
    if(SUCCEEDED(hr))
        m_bReadOnly = !bWrite;
}

CRoleDefDialog::
~CRoleDefDialog()
{
    RemoveItemsFromList(m_listActionItem);
}

BOOL
CRoleDefDialog::
OnInitDialog()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleDefDialog,OnInitDialog)
    
    VERIFY(m_listCtrl.SubclassDlgItem(IDC_LIST_OP_TASK,this));
    m_listCtrl.Initialize();

    HRESULT hr = S_OK;

    do
    {
        //Add Member Tasks
        CList<CBaseAz*,CBaseAz*> listTasks;
        hr = m_refRoleAz.GetMembers(AZ_PROP_ROLE_TASKS,
                                    listTasks);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = MakeBaseAzListToActionItemList(listTasks,
                                            m_listActionItem);
        BREAK_ON_FAIL_HRESULT(hr);
            
        //Add Member Operations
        CList<CBaseAz*,CBaseAz*> listOperations;
        hr = m_refRoleAz.GetMembers(AZ_PROP_ROLE_OPERATIONS,
                                    listOperations);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = MakeBaseAzListToActionItemList(listOperations, 
                                            m_listActionItem);
        BREAK_ON_FAIL_HRESULT(hr);

        //And Tasks and Operations to list control
        AddActionItemFromListToListCtrl(m_listActionItem,
                                        &m_listCtrl,
                                        COL_NAME | COL_TYPE | COL_DESCRIPTION,
                                        FALSE);

    }while(0);

    //Make controls readonly
    if(IsReadOnly())
    {
        GetDlgItem(IDC_ADD)->EnableWindow(FALSE);
        GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE);
    }

    return TRUE;
}

void
CRoleDefDialog::
OnOK()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleDefDialog,OnOK)

    POSITION pos = m_listActionItem.GetHeadPosition();      
    BOOL bErrorDisplayed = FALSE;
    HRESULT hr = S_OK;
    for( int i = 0; i < m_listActionItem.GetCount(); ++i)
    {
        ActionItem* pActionItem = m_listActionItem.GetNext(pos);
    
        //We need to take action only for add or remove
        if(pActionItem->action == ACTION_ADD || 
           pActionItem->action == ACTION_REMOVE)
        {
            LONG lPropId = AZ_PROP_ROLE_TASKS;
            
            if(pActionItem->m_pMemberAz->GetObjectType() == OPERATION_AZ)
                lPropId = AZ_PROP_ROLE_OPERATIONS;

            if(pActionItem->action == ACTION_ADD)
                hr = m_refRoleAz.AddMember(lPropId,
                                            pActionItem->m_pMemberAz);
            else
                hr = m_refRoleAz.RemoveMember(lPropId,
                                              pActionItem->m_pMemberAz);
            if(FAILED(hr))
            {
                CString strError;
                GetSystemError(strError, hr);               
                ::DisplayError(m_hWnd,
                              (pActionItem->action == ACTION_ADD) ? IDS_ADD_FAILED : IDS_DELETE_FAILED,
                              (LPCTSTR)strError,
                              (LPCTSTR)(pActionItem->m_pMemberAz->GetName()));          
                bErrorDisplayed = TRUE;
                break;
            }
            else
            {
                if(pActionItem->action == ACTION_ADD)
                    //Item has been added
                    pActionItem->action = ACTION_NONE;
                else
                    //Item has been removed
                    pActionItem->action = ACTION_REMOVED;
            }
        }
    }
    
    if(SUCCEEDED(hr))
    {
        hr = m_refRoleAz.Submit();
    }

    if(FAILED(hr)) 
    {
        if(!bErrorDisplayed)
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
            ::DisplayError(m_hWnd,
                                IDS_GENERIC_PROPERTY_SAVE_ERROR,
                                (LPCTSTR)strError);
        }
    }
    else
    {
        CHelpEnabledDialog::OnOK();
    }
}


void
CRoleDefDialog::
OnButtonRemove()
{
    //Remember the Position of first selected entry.
    int iFirstSelectedItem = m_listCtrl.GetNextItem(-1, LVIS_SELECTED);

    int iSelectedItem = -1;
    while( (iSelectedItem = m_listCtrl.GetNextItem(iSelectedItem, LVIS_SELECTED)) != -1)
    {
        RemoveMember((ActionItem*)(m_listCtrl.GetItemData(iSelectedItem)));
        m_listCtrl.DeleteItem(iSelectedItem);
        iSelectedItem--;        
    }

    if(m_listCtrl.GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;

    SelectListCtrlItem(&m_listCtrl, iFirstSelectedItem);
}

void
CRoleDefDialog::
OnListCtrlItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* pResult)
{
    if(!pResult)
        return;
    *pResult = 0;
    if(!IsReadOnly())
    {
        EnableButtonIfSelectedInListCtrl(&m_listCtrl,
                                         (CButton*)GetDlgItem(IDC_REMOVE));
    }

}

void
CRoleDefDialog::
OnListCtrlItemDeleted(NMHDR* /*pNotifyStruct*/, LRESULT* /*pResult*/)
{
    SetDirty();
}

void
CRoleDefDialog::
OnButtonAdd()
{
    CContainerAz* pContainerAz = m_refRoleAz.GetParentAz();
    ASSERT(pContainerAz);   

    CList<CBaseAz*,CBaseAz*> listObjectsSelected;
    if(!GetSelectedDefinitions(TRUE,
                               pContainerAz,
                               listObjectsSelected))
    {
        return;
    }
    
    //Add selected members to appropriate property and to listctrl
    AddActionItems(listObjectsSelected,
                   m_listCtrl,
                   m_hWnd,
                   m_listActionItem,
                   COL_NAME | COL_TYPE | COL_DESCRIPTION);
    return; 
}

//+----------------------------------------------------------------------------
//  Function:BringPropSheetToForeGround   
//  Synopsis:Finds the property sheet for pNode and brings it to forground   
//  Returns: True if property sheet exists and is brought to foreground
//           else FALSE   
//-----------------------------------------------------------------------------
BOOL
BringPropSheetToForeGround(CRoleComponentDataObject *pComponentData,
                           CTreeNode * pNode)
                           
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,BringPropSheetToForeGround)

    if(!pNode || !pComponentData)
    {
        ASSERT(pNode);
        ASSERT(pComponentData);
        return FALSE;
    }

    HRESULT hr = S_OK;
    
    // create a data object for this node
    CComPtr<IDataObject> spDataObject;
    hr = pComponentData->QueryDataObject((MMC_COOKIE)pNode, CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));


    // get an interface to a sheet provider
    CComPtr<IPropertySheetProvider> spSheetProvider;
    hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
    ASSERT(SUCCEEDED(hr));
    
    //HACK: FindPropertySheet requires IComponent only for comparing objects.
    //Create a new IComponent and pass it to function and then relesae it
    LPCOMPONENT pComponent = NULL;
    hr = pComponentData->CreateComponent(&pComponent);
    if(SUCCEEDED(hr) && pComponent)
    {
        hr = spSheetProvider->FindPropertySheet((MMC_COOKIE)pNode, pComponent, spDataObject);
        //Release the IComponent
        pComponent->Release();
        if(hr == S_OK)
            return TRUE;
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//  Function:FindOrCreateModelessPropertySheet   
//  Synopsis:Displays property sheet for pCookieNode. If a propertysheet is
//           already up, function brings it to foreground, otherwise it creates
//           a new propertysheet. This should be used to create propertysheet
//           in response to events other that click properties context menu.   
//  Arguments:
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT 
FindOrCreateModelessPropertySheet(CRoleComponentDataObject *pComponentData,
                                  CTreeNode* pCookieNode)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,FindOrCreateModelessPropertySheet)

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    if(!pComponentData || !pCookieNode)
    {
        ASSERT(pComponentData);
        ASSERT(pCookieNode);
    }

    if(BringPropSheetToForeGround(pComponentData, pCookieNode))
    {
        //There is already a property sheet for this CookieNode.
        //We no longer need this Node
        delete pCookieNode;
        return S_OK;
    }

    HRESULT hr = S_OK;

    //bring up new property sheet for the pCookieNode
    do
    {
        // get an interface to a sheet provider
        CComPtr<IPropertySheetProvider> spSheetProvider;
        hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
        BREAK_ON_FAIL_HRESULT(hr);

    
        // get an interface to a sheet callback
        CComPtr<IPropertySheetCallback> spSheetCallback;
        hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&spSheetCallback);
        BREAK_ON_FAIL_HRESULT(hr);

        // create a data object for this node
        CComPtr<IDataObject> spDataObject;
        hr = pComponentData->QueryDataObject((MMC_COOKIE)pCookieNode, CCT_SCOPE, &spDataObject);
        BREAK_ON_FAIL_HRESULT(hr);


        // get a sheet
        hr = spSheetProvider->CreatePropertySheet(_T("SHEET TITLE"), TRUE, (MMC_COOKIE)pCookieNode, spDataObject, 0x0 /*dwOptions*/);
        BREAK_ON_FAIL_HRESULT(hr);

        HWND hWnd = NULL;
        hr = pComponentData->GetConsole()->GetMainWindow(&hWnd);
        ASSERT(SUCCEEDED(hr));

        IUnknown* pUnkComponentData = pComponentData->GetUnknown(); // no addref
        hr = spSheetProvider->AddPrimaryPages(pUnkComponentData,
                                              TRUE /*bCreateHandle*/,
                                              hWnd,
                                              TRUE /* bScopePane*/);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = spSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSQuery.h
//
//  Contents:  Query object for DS snapin
//
//--------------------------------------------------------------------------


#ifndef __QUERY_H__
#define __QUERY_H__

#define QUERY_PAGESIZE 50

//
// CDSSearch
//
class CDSSearch
{
public:
	CDSSearch(CComPtr<IDirectorySearch>& refspSearchObject);
	~CDSSearch();
	
	// INTERFACES
public:
	HRESULT 
	DoQuery(BOOL bAttrOnly = FALSE);
	
	HRESULT 
	GetNextRow();
	
	HRESULT 
	GetColumn(LPWSTR Attribute,
              PADS_SEARCH_COLUMN pColumnData);
	
	HRESULT 
	FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
	{
		return m_pObj->FreeColumn(pColumnData);
	};
	
	HRESULT 
	SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);  
	
	HRESULT 
	SetSearchScope(ADS_SCOPEENUM scope);
	
	HRESULT 
	SetFilterString (LPWSTR pszFilter) 
	{
		m_strFilter = pszFilter;
		return S_OK;
	};
	
	HRESULT 
	GetNextColumnName(LPWSTR *ppszColumnName);
	
	VOID 
	FreeColumnName(LPWSTR pszColumnName)
	{
		FreeADsMem(pszColumnName);		
	}    
	
	//Attributes
public:
	CComPtr<IDirectorySearch>& m_pObj;
	ADS_SEARCH_HANDLE  m_SearchHandle;
	
protected:
	CString m_strFilter;
	LPWSTR *  m_ppszAttr;
	DWORD     m_CountAttr;
	ADS_SCOPEENUM   m_scope;
	
private:
	void _Reset();
};
        


#endif //__DSQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\propbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       propbase.h
//
//  Contents:   
//
//  History:    8-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

/******************************************************************************
Class:	CRolePropertyPageHolder
Purpose: PropertyPageHolder used by this snapin
******************************************************************************/
class CRolePropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CRolePropertyPageHolder(CContainerNode* pContNode, 
							CTreeNode* pNode,
							CComponentDataObject* pComponentData);
};

/******************************************************************************
Class:	CBaseRolePropertyPage
Purpose: Base Class for all property pages
******************************************************************************/
class CBaseRolePropertyPage : public CPropertyPageBase
{
public:
	CBaseRolePropertyPage(CBaseAz * pBaseAz,
						  CBaseNode* pBaseNode,
						  ULONG IDD_DIALOG)
						  :CPropertyPageBase(IDD_DIALOG),
						  m_pBaseAz(pBaseAz),
						  m_pBaseNode(pBaseNode),
						  m_bInit(FALSE),
						  m_nDialogId(IDD_DIALOG)
	{
		ASSERT(pBaseAz);
		m_bReadOnly = TRUE;
		BOOL bWrite = FALSE;
		HRESULT hr = m_pBaseAz->IsWritable(bWrite);
		ASSERT(SUCCEEDED(hr));
		m_bReadOnly = !bWrite;
	}	
	
	afx_msg void 
	OnDirty() 
	{
		if(IsInitialized() && !IsReadOnly())
			SetDirty(TRUE);
	}
	
	virtual BOOL 
	OnPropertyChange(BOOL, 
					 long*){return TRUE;}
	void 
	OnCancel();

	virtual BOOL 
	OnHelp(WPARAM wParam, 
		   LPARAM lParam);


protected:
	BOOL 
	IsReadOnly()
	{
		return m_bReadOnly;
	}

	BOOL 
	IsInitialized(){ return m_bInit;}
	
	void SetInit(BOOL bInit){m_bInit = bInit;}
	
	CBaseAz* 
	GetBaseAzObject(){return m_pBaseAz;}

	CBaseNode* 
	GetBaseNode(){return m_pBaseNode;}
private:
	CBaseAz * m_pBaseAz;
	CBaseNode* m_pBaseNode;
	BOOL m_bInit;
	ULONG m_nDialogId;
	BOOL m_bReadOnly;
};


/******************************************************************************
Class:	CGeneralPropertyPage
Purpose: An Attribute Map based property class which can be used by property
pages which are simple. Used by all general property pages
******************************************************************************/
class CGeneralPropertyPage : public CBaseRolePropertyPage
{
public:
	CGeneralPropertyPage(CBaseAz * pBaseAz,
						 CBaseNode* pBaseNode,
						 ATTR_MAP* pAttrMap,
						 ULONG IDD_DIALOG)
						 :CBaseRolePropertyPage(pBaseAz,
												pBaseNode,
											    IDD_DIALOG),
						  m_pAttrMap(pAttrMap)							  
	{
	}
	
	virtual BOOL 
	OnInitDialog();
	
	virtual BOOL 
	OnApply();

protected:
	ATTR_MAP* 
	GetAttrMap(){return m_pAttrMap;}
private:
	ATTR_MAP* m_pAttrMap;
};


/******************************************************************************
Class:	CAdminManagerGeneralProperty
Purpose: General Property Page for AdminManger
******************************************************************************/
class CAdminManagerGeneralProperty:public CGeneralPropertyPage
{
public:
	CAdminManagerGeneralProperty(CBaseAz * pBaseAz,
								 CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_ADMIN_MANAGER_GENERAL_PROPERTY, 
							  IDD_ADMIN_MANAGER_GENERAL_PROPERTY)
	{
	}
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CApplicationGeneralPropertyPage
Purpose: General Property Page for Application
******************************************************************************/
class CApplicationGeneralPropertyPage:public CGeneralPropertyPage
{
public:
	CApplicationGeneralPropertyPage(CBaseAz * pBaseAz,
									CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_APPLICATION_GENERAL_PROPERTY, 
							  IDD_APPLICATION_GENERAL_PROPERTY)
	{
	}

    virtual BOOL 
	OnInitDialog();

private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CScopeGeneralPropertyPage
Purpose: General Property Page for Scope
******************************************************************************/
class CScopeGeneralPropertyPage:public CGeneralPropertyPage
{
public:
	CScopeGeneralPropertyPage(CBaseAz * pBaseAz,
							  CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_SCOPE_GENERAL_PROPERTY, 
							  IDD_SCOPE_GENERAL_PROPERTY)
	{
	}
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CGroupGeneralPropertyPage
Purpose: General Property Page for Group
******************************************************************************/
class CGroupGeneralPropertyPage:public CGeneralPropertyPage
{
public:
	CGroupGeneralPropertyPage(CBaseAz * pBaseAz,
							  CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_GROUP_GENERAL_PROPERTY, 
							  IDD_GROUP_GENERAL_PROPERTY)
    {
    }
	virtual BOOL 
	OnInitDialog();
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CTaskGeneralPropertyPage
Purpose: General Property Page for Task
******************************************************************************/
class CTaskGeneralPropertyPage:public CGeneralPropertyPage
{
public:
	CTaskGeneralPropertyPage(CBaseAz * pBaseAz,
							 CBaseNode* pBaseNode,
							 BOOL bRoleDefinition)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_TASK_GENERAL_PROPERTY, 
							  bRoleDefinition ? IDD_ROLE_DEFINITION_GENERAL_PROPERTY : IDD_TASK_GENERAL_PROPERTY)
	{
	}
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	COperationGeneralPropertyPage
Purpose: General Property Page for Operation
******************************************************************************/
class COperationGeneralPropertyPage:public CGeneralPropertyPage
{
public:
	COperationGeneralPropertyPage(CBaseAz * pBaseAz,
								  CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_OPERATION_GENERAL_PROPERTY, 
							  IDD_OPERATION_GENERAL_PROPERTY)
	{
	}
private:
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CAdminManagerAdvancedPropertyPage
Purpose: Limits Property Page for AdminManger
******************************************************************************/
class CAdminManagerAdvancedPropertyPage:public CGeneralPropertyPage
{
public:
	CAdminManagerAdvancedPropertyPage(CBaseAz * pBaseAz,
									  CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_ADMIN_MANAGER_ADVANCED_PROPERTY, 
							  IDD_ADMIN_MANAGER_ADVANCED_PROPERTY),
        m_lAuthScriptTimeoutValue(0)
	{
	}

	BOOL 
	OnInitDialog();
private:
	afx_msg void 
    OnRadioChange();
	
    afx_msg void
	OnButtonDefault();

    LONG m_lAuthScriptTimeoutValue;


	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CGroupQueryPropertyPage
Purpose: Query Property Page for Group
******************************************************************************/
class CGroupQueryPropertyPage:public CGeneralPropertyPage
{
public:
	CGroupQueryPropertyPage(CBaseAz * pBaseAz,
									  CBaseNode* pBaseNode)
		:CGeneralPropertyPage(pBaseAz, 
							  pBaseNode,
							  ATTR_MAP_GROUP_QUERY_PROPERTY, 
							  IDD_GROUP_LDAP_QUERY)
	{
	}
private:
	afx_msg void OnButtonDefineQuery();
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
Class:	CAuditPropertyPage
Purpose: Audit Property Page 
******************************************************************************/
class CAuditPropertyPage:public CBaseRolePropertyPage
{
public:
	CAuditPropertyPage(CBaseAz* pBaseAz,
					   CBaseNode* pBaseNode)
		:CBaseRolePropertyPage(pBaseAz, 
							   pBaseNode,
							   IDD_AUDIT),
							   m_bRunTimeAuditSupported(FALSE),
							   m_bStoreSaclSupported(FALSE)
	{
	}
	
	BOOL 
	OnInitDialog();

	BOOL 
	OnApply();
private:
	int
	GetParentAuditStateStringId(LONG lPropid);

    afx_msg void 
	OnLinkClick(NMHDR* /*pNotifyStruct*/, LRESULT* /*pResult*/);

    void
    MoveAndHideControls(BOOL bGenerateAuditSupported,
                        BOOL bStoreSaclSupported,
                        BOOL bParentStateShown);

	BOOL m_bStoreSaclSupported;
	BOOL m_bRunTimeAuditSupported;
	DECLARE_MESSAGE_MAP()

};


/******************************************************************************
Class:	CListCtrlPropertyPage
Purpose: Base class for property pages which have list control and primary 
action is to add/delete items from it.
******************************************************************************/
class CListCtrlPropertyPage:public CBaseRolePropertyPage
{
public:
	CListCtrlPropertyPage(CBaseAz * pBaseAz,
						  CBaseNode* pBaseNode,
						  ULONG IDD,
						  int iIdListCtrl,
						  int iIdRemoveBtn,
						  COL_FOR_LV* pColForLV,
						  UINT uiFlags)
						  :CBaseRolePropertyPage(pBaseAz,
												 pBaseNode,
												 IDD),
						   m_listCtrl(uiFlags,TRUE,pColForLV),												 
						   m_nIdRemoveBtn(iIdRemoveBtn),
						   m_uiFlags(uiFlags),
						   m_nIdListCtrl(iIdListCtrl)

	{
	}

	virtual 
	~CListCtrlPropertyPage()
	{
	}	

	virtual BOOL 
	OnInitDialog();
	
protected:
	afx_msg void 
	OnButtonRemove();
	
	afx_msg void 
	OnListCtrlItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* pResult);
	
	void 
	SetRemoveButton();
		
	int
	AddMembers(IN CList<CBaseAz*,CBaseAz*>& listNewMembersToAdd,
			   IN OUT ActionMap& mapActionItem,
			   IN UINT uiFlags);

	HRESULT
	AddMember(IN CBaseAz* pMemberAz,
			  IN OUT ActionMap& mapActionItem,
			  IN UINT uiFlags);

	BOOL 
	DoActionsFromActionMap(IN ActionMap& mapActions,
						   IN LONG param);

	virtual	HRESULT
	DoOneAction(IN ActionItem* pActionItem,
					IN LONG param) = 0;

	virtual void 
	RemoveMember(IN ActionItem* pActionItem);

	virtual void
	MakeControlsReadOnly() = 0;

    virtual BOOL
    EqualObjects(CBaseAz* p1, CBaseAz* p2);

	CButton*
	GetRemoveButton(){ return (CButton*)GetDlgItem(m_nIdRemoveBtn);}

	UINT GetUIFlags(){return m_uiFlags;}

	CSortListCtrl m_listCtrl;

private:
//DATA MEMBERS
	int m_nIdListCtrl;
	int m_nIdRemoveBtn;
	UINT m_uiFlags;
};

/******************************************************************************
Class:	CTaskDefinitionPropertyPage
Purpose: Property Page for Task Definition
******************************************************************************/
class CTaskDefinitionPropertyPage :public CListCtrlPropertyPage
{
public:
	CTaskDefinitionPropertyPage(CBaseAz * pBaseAz,
								CBaseNode* pBaseNode, 
								BOOL bRoleDefinition)
	:CListCtrlPropertyPage(pBaseAz,
						   pBaseNode,
						   bRoleDefinition? IDD_ROLE_DEFINITION_PROPERTY :IDD_TASK_DEFINITION_PROPERTY,
						   IDC_LIST_TASK_OPERATION,
						   IDC_REMOVE,
						   Col_For_Task_Role,
						   COL_NAME | COL_TYPE | COL_DESCRIPTION),
						   m_bRoleDefinition(bRoleDefinition),
						   m_bScriptDirty(FALSE)
	{
	}
	
	virtual
	~CTaskDefinitionPropertyPage();

	virtual BOOL 
	OnInitDialog();

	BOOL 
	OnApply();
private:
	afx_msg void 
	OnButtonAdd();

	afx_msg void
	OnButtonEditScript();

	HRESULT
	DoOneAction(IN ActionItem* pActionItem,
					IN LONG param);

	void
	MakeControlsReadOnly();

	BOOL IsRoleDefinition()
	{
		return m_bRoleDefinition;
	}


	DECLARE_MESSAGE_MAP()

	CString m_strFileName;
	CString m_strScriptLanguage;
	CString m_strScript;
	ActionMap m_mapActionItem;
	BOOL m_bRoleDefinition;
	BOOL m_bScriptDirty;
};



/******************************************************************************
Class:	Group Membership Property Page
Purpose: Property Page Group Definition
******************************************************************************/
class CGroupMemberPropertyPage :public CListCtrlPropertyPage
{
public:
	CGroupMemberPropertyPage(CBaseAz * pBaseAz,
							 CBaseNode* pBaseNode, 
							 LONG IDD, 
							 BOOL bMember)
	:CListCtrlPropertyPage(pBaseAz,
						   pBaseNode,
						   IDD,
						   IDC_LIST_MEMBER,
						   IDC_REMOVE,
						   Col_For_Task_Role,
						   COL_NAME | COL_TYPE | COL_DESCRIPTION),
						   m_bMember(bMember)
	{
	}
	
	virtual
	~CGroupMemberPropertyPage();

	virtual BOOL 
	OnInitDialog();

	BOOL 
	OnApply();

private:	
	afx_msg void 
	OnButtonAddApplicationGroups();
	
	afx_msg void 
	OnButtonAddWindowsGroups();
	
	HRESULT
	DoOneAction(IN ActionItem* pActionItem,
					IN LONG param);

	void
	MakeControlsReadOnly();

	DECLARE_MESSAGE_MAP()

//DATA MEMBERS
	ActionMap m_mapActionItem;
	BOOL m_bMember;
};

/******************************************************************************
Class:	CSecurityPropertyPage
Purpose: Security Property Page
******************************************************************************/
class CSecurityPropertyPage: public CListCtrlPropertyPage
{
public:	
	CSecurityPropertyPage(CBaseAz * pBaseAz,
						  CBaseNode* pBaseNode)
	:CListCtrlPropertyPage(pBaseAz,
						   pBaseNode,
						   IDD_SECURITY,
						   IDC_LIST_MEMBER,
						   IDC_REMOVE,
						   Col_For_Security_Page,
						   COL_NAME | COL_PARENT_TYPE),
						   m_LastComboSelection(AZ_PROP_POLICY_ADMINS),
						   m_bDelegatorPresent(FALSE)
	{
	}

	virtual
	~CSecurityPropertyPage();

	virtual BOOL 
	OnInitDialog();

	BOOL 
	OnApply();

	afx_msg void 
	OnButtonRemove();

private:
	afx_msg void 
	OnButtonAddWindowsGroups();
	
	afx_msg void 
	OnComboBoxItemChanged();

	//CListCtrlPropertyPage Override
	HRESULT
	DoOneAction(IN ActionItem* pActionItem,
				IN LONG param);

    void
    ReloadAdminList();

    virtual BOOL
    EqualObjects(CBaseAz* p1, CBaseAz* p2);

	void
	MakeControlsReadOnly();

	ActionMap &
	GetListForComboSelection(LONG lComboSel);

	BOOL 
	HandleBizruleScopeInteraction();
	
	DECLARE_MESSAGE_MAP()

//DATA MEMBERS
	ActionMap m_mapAdminActionItem;
	ActionMap m_mapReadersActionItem;
	ActionMap m_mapDelegatedUsersActionItem;
	BOOL m_bDelegatorPresent;
	LONG m_LastComboSelection;
};


/******************************************************************************
Class:	CRoleGeneralPropertyPage
Purpose: General Property Page for Role
******************************************************************************/
class CRoleGeneralPropertyPage:public CGeneralPropertyPage
{
public:
	CRoleGeneralPropertyPage(CBaseAz * pBaseAz,
							 CBaseNode* pBaseNode)
	:CGeneralPropertyPage(pBaseAz, 
						  pBaseNode,
						  ATTR_MAP_ROLE_GENERAL_PROPERTY, 
						  IDD_ROLE_GENERAL_PROPERTY)
	{
	}
private:
	afx_msg void 
	OnShowDefinition();

	BOOL
	DisplayRoleDefintionPropertyPages(IN CTaskAz* pTaskAz);

	DECLARE_MESSAGE_MAP()
};


/******************************************************************************
Class:	CRoleDefDialog
Purpose: Displays the role definition for role created out side UI.
******************************************************************************/
class CRoleDefDialog :public CHelpEnabledDialog
{
public:
	CRoleDefDialog(CRoleAz& refRoleAz);
	~CRoleDefDialog();

	virtual BOOL 
	OnInitDialog();
	
	virtual void 
	OnOK();

private:
	afx_msg void 
	OnButtonRemove();

	afx_msg void 
	OnButtonAdd();

	afx_msg void 
	OnListCtrlItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* pResult);
	
	afx_msg void 
	OnListCtrlItemDeleted(NMHDR* /*pNotifyStruct*/, LRESULT* pResult);
	
	afx_msg void 
	OnListCtrlItemInserted(NMHDR* /*pNotifyStruct*/, LRESULT* /*pResult*/){SetDirty();}

	void 
	SetRemoveButton();

	void
	SetDirty(){ m_bDirty = TRUE;}

	BOOL 
	IsDirty(){ return m_bDirty;}

	BOOL
	IsReadOnly(){return m_bReadOnly;}

	DECLARE_MESSAGE_MAP()


	CSortListCtrl m_listCtrl;
	CList<ActionItem*,ActionItem*> m_listActionItem;
	BOOL m_bReadOnly;
	CRoleAz& m_refRoleAz;
	BOOL m_bDirty;
};


//+----------------------------------------------------------------------------
//  Function:BringPropSheetToForeGround   
//  Synopsis:Finds the property sheet for pNode and brings it to forground   
//  Returns: True if property sheet exists and is brought to foreground
//			 else FALSE   
//-----------------------------------------------------------------------------
BOOL
BringPropSheetToForeGround(CRoleComponentDataObject *pComponentData,
						   CTreeNode * pNode);

//+----------------------------------------------------------------------------
//  Function:FindOrCreateModelessPropertySheet   
//  Synopsis:Displays property sheet for pCookieNode. If a propertysheet is
//			 already up, function brings it to foreground, otherwise it creates
//			 a new propertysheet. This should be used to create propertysheet
//			 in response to events other that click properties context menu.   
//  Arguments:
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT 
FindOrCreateModelessPropertySheet(CRoleComponentDataObject *pComponentData,
								  CTreeNode* pCookieNode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\query.cpp ===
#include "headers.h"

CDSSearch::
CDSSearch(CComPtr<IDirectorySearch>& refspSearchObject):
m_pObj(refspSearchObject)
{
	m_ppszAttr = NULL;
	m_CountAttr = NULL;
	m_SearchHandle = NULL;
	m_scope = ADS_SCOPE_SUBTREE;
}


void 
CDSSearch::
_Reset()
{
    if (m_SearchHandle) 
    {
		m_pObj->CloseSearchHandle(m_SearchHandle);
		m_SearchHandle = NULL;
    }
}

CDSSearch::
~CDSSearch()
{
	_Reset();
}

HRESULT 
CDSSearch::
SetAttributeList(LPTSTR *ppszAttribs, INT cAttrs)
{
	m_ppszAttr = ppszAttribs;
	m_CountAttr = cAttrs;
	return S_OK;
}

HRESULT 
CDSSearch::
SetSearchScope (ADS_SCOPEENUM scope)
{
	m_scope = scope;
	return S_OK;
}

const int NUM_PREFS = 5;
HRESULT 
_SetSearchPreference(IDirectorySearch* piSearch, 
					 ADS_SCOPEENUM scope, 
					 BOOL bAttrOnly)
{
	if (NULL == piSearch)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	
	int cPref = 4;
	
	ADS_SEARCHPREF_INFO aSearchPref[5];
	aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
	aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
	aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
	aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
	aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
	aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
	aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
	aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
	aSearchPref[2].vValue.Integer = FALSE;
	aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
	aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
	aSearchPref[3].vValue.Integer = scope;
	if(bAttrOnly)
	{	
		aSearchPref[4].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
		aSearchPref[4].vValue.dwType = ADSTYPE_BOOLEAN;
		aSearchPref[4].vValue.Integer = TRUE;
		++cPref;
	}
	
	return piSearch->SetSearchPreference (aSearchPref, cPref);
}


HRESULT CDSSearch::DoQuery(BOOL bAttrOnly)
{
	HRESULT hr = _SetSearchPreference(m_pObj, m_scope, bAttrOnly);
	
	if (SUCCEEDED(hr)) {
		hr = m_pObj->ExecuteSearch ((LPWSTR)(LPCTSTR)m_strFilter,
									m_ppszAttr,
									m_CountAttr,
									&m_SearchHandle);
	}
	
	return hr;
}

HRESULT
CDSSearch::
GetNextRow()
{
	DWORD status = ERROR_MORE_DATA;
	HRESULT hr = S_OK;
	HRESULT hr2 = S_OK;
	WCHAR Buffer1[512], Buffer2[512];
	while (status == ERROR_MORE_DATA ) 
	{
		hr = m_pObj->GetNextRow (m_SearchHandle);
		if (hr == S_ADS_NOMORE_ROWS) 
		{
			hr2 = ADsGetLastError(&status, Buffer1, 512,
				Buffer2, 512);
			ASSERT(SUCCEEDED(hr2));
		} else 
		{
			status = 0;
		}
	}
	return hr;
}

HRESULT
CDSSearch::
GetColumn(LPWSTR Attribute,
		  PADS_SEARCH_COLUMN pColumnData)
{
	return m_pObj->GetColumn (m_SearchHandle,
							  Attribute,
							  pColumnData);
}

HRESULT 
CDSSearch::GetNextColumnName(LPWSTR *ppszColumnName)
{  
		return m_pObj->GetNextColumnName(m_SearchHandle,
										 ppszColumnName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDS_SNAPIN_NAME                 1
#define IDS_SNAPINABOUT_DESCRIPTION     2
#define IDS_ROOT_OPEN_STORE             3
#define IDOK2                           3
#define IDS_ROOT_NEW_STORE              4
#define IDCANCEL2                       4
#define IDS_HEADER_NAME                 5
#define IDS_HEADER_TYPE                 6
#define IDS_HEADER_DESCRIPTION          7
#define IDS_MESSAGE_VIEW_NO_POLICY_STORE_TITLE 8
#define IDS_MESSAGE_VIEW_NO_POLICY_STORE_MESSAGE 9
#define IDS_ADMIN_NEW_APP               10
#define IDS_ADMIN_MANAGER_TYPE          11
#define IDS_APP_NEW_SCOPE               12
#define IDS_APP_NEW_ROLE                13
#define IDS_SCOPE_ADD_ROLE              14
#define IDS_FMT_PROP_SHEET_TITLE        15
#define IDS_GENERAL_PROP_PAGE_TITLE     16
#define IDS_SCOPE_TYPE_AD               17
#define IDS_SCOPE_TYPE_XML              18
#define IDS_TYPE_ADMIN_MANAGER          19
#define IDS_TYPE_APPLICATION            20
#define IDS_TYPE_BASIC_GROUP            21
#define IDS_TYPE_LDAP_GROUP             22
#define IDS_TYPE_ROLE                   23
#define IDS_TYPE_TASK                   24
#define IDS_TYPE_CONTAINER              25
#define IDS_TYPE_SCOPE                  26
#define IDS_TYPE_GROUP                  27
#define IDS_NAME_GROUP_CONTAINER        28
#define IDS_TYPE_GROUP_CONTAINER        29
#define IDS_DESC_GROUP_CONTAINER        30
#define IDS_GROUP_CONTAINER_NEW_GROUP   31
#define IDS_NAME_TASK_CONTAINER         32
#define IDS_TYPE_TASK_CONTAINER         33
#define IDS_DESC_TASK_CONTAINER         34
#define IDS_NAME_ROLE_CONTAINER         35
#define IDS_TYPE_ROLE_CONTAINER         36
#define IDS_DESC_ROLE_CONTAINER         37
#define IDS_ROLE_CONTAINER_NEW_ROLE     38
#define IDS_TASK_CONTAINER_NEW_TASK     39
#define IDS_APP_NEW_OPERATION           40
#define IDS_TYPE_OPERATION              41
#define IDS_NAME_DEFINITION_CONTAINER   42
#define IDS_TYPE_DEFINITION_CONTAINER   43
#define IDS_DESC_DEFINITION_CONTAINER   44
#define IDS_OPERATION_CONTAINER_NEW_OPERATION 45
#define IDS_TYPE_OPERATION_CONTAINER    46
#define IDS_DESC_OPERATION_CONTAINER    47
#define IDS_NAME_OPERATION_CONTAINER    48
#define IDS_ADMIN_MANAGER_NAME_EXIST    49
#define IDS_ADMIN_MANAGER_NAME_INVAILD  50
#define IDS_APPLICATION_NAME_EXIST      51
#define IDS_APPLICATION_NAME_INVAILD    52
#define IDS_SCOPE_NAME_EXIST            53
#define IDS_SCOPE_NAME_INVAILD          54
#define IDS_GROUP_NAME_EXIST            55
#define IDS_GROUP_NAME_INVAILD          56
#define IDS_TASK_NAME_EXIST             57
#define IDS_TASK_NAME_INVAILD           58
#define IDS_ROLE_NAME_EXIST             59
#define IDS_ROLE_NAME_INVAILD           60
#define IDS_OPERATION_NAME_EXIST        70
#define IDS_OPERATION_NAME_INVAILD      80
#define IDS_CREATE_NEW_GENERIC_ERROR    81
#define IDS_ADMIN_MANAGER_NOT_FOUND     82
#define IDS_OPEN_ADMIN_MANAGER_GENERIC_ERROR 83
#define IDS_NO_OPERATIONS_TO_ADD        84
#define IDS_NO_TASKS_TO_ADD             85
#define IDS_NAME_REQUIRED               86
#define IDS_OPERATION_ID_REQUIRED       87
#define IDS_OPERATION_ID_EXISTS         88
#define IDS_DOMAIN_TIMEOUT_REQUIRED     89
#define IDS_SCRIPT_ENGINE_TIMEOUT_REQUIRED 90
#define IDS_MAX_SCRIPT_ENGINES_REQUIRED 91
#define IDS_ADMIN_MIN_SCRIPT_ENGINE_TIMEOUT 92
#define IDS_NAME_ROLE_DEFINITION_CONTAINER 93
#define IDS_TYPE_ROLE_DEFINITION_CONTAINER 94
#define IDS_DESC_ROLE_DEFINITION_CONTAINER 95
#define IDS_ROLE_DEFINITION_CONTAINER_NEW_ROLE_DEFINITION 96
#define IDS_ERROR_ADD_MEMBER_OBJECT     97
#define IDS_TYPE_ROLE_DEFINITION        98
#define IDS_SID_DELETED                 99
#define IDS_SID_UNKNOWN                 100
#define IDD_NEW_POLICY_STORE            101
#define IDD_NEW_AUTHORIZATION_STORE     101
#define IDS_NT_USER_FORMAT              101
#define IDS_SID_INVALID                 102
#define IDB_ABOUT_16x16                 103
#define IDS_POLICY_ADMIN                103
#define IDB_ABOUT_32x32                 104
#define IDS_POLICY_READER               104
#define IDB_ABOUT_OPEN_16x16            105
#define IDS_NO_ROLE_DEFINITION_TO_ADD   105
#define IDI_ROLE_SNAPIN                 106
#define IDS_NO_GROUP_TO_ADD             106
#define IDS_HEADER_WHERE_DEFINED        107
#define IDS_ERROR_OPERATION_ID_EXISTS   108
#define IDS_ERROR_OPERATION_FAILED      109
#define IDD_NEW_APPLICATION             110
#define IDS_ROLE_CONTAINER_ASSIGN_ROLE  110
#define IDD_NEW_SCOPE                   111
#define IDS_CREATE_ROLE_GENERIC_ERROR   111
#define IDD_DIALOG1                     112
#define IDS_ROLE_NODE_ASSIGN_APPLICATION_GROUPS 112
#define IDD_GEN_POLICY_STORE            113
#define IDD_ADMIN_MANAGER_GENERAL_PROPPERTY 113
#define IDS_ROLE_NODE_ASSIGN_WINDOWS_GROUPS 113
#define IDD_ADMIN_MANAGER_GENERAL_PROPERTY 113
#define IDD_OPEN_AUTHORIZATION_STORE    114
#define IDS_DELETE_CONFIRMATION         114
#define IDD_NEW_GROUP                   115
#define IDS_ALL_POLICY_USERS_INHERITED  115
#define IDD_NEW_TASK                    116
#define IDS_SOME_POLICY_USERS_INHERITED 116
#define IDD_ADD_TASK                    117
#define IDS_OPEN_AUTHORIZATION_STORE    117
#define IDD_ADD_OPERATION               118
#define IDS_NEW_AUTHORIZATION_STORE     118
#define IDD_NEW_OPERATION               119
#define IDS_SELECT_AUTHORIZATION_SCRIPT 119
#define IDD_APPLICATION_GENERAL_PROPERTY 120
#define IDS_ERROR_BIZRULE_EXCEED_MAX_LENGTH 120
#define IDD_SCOPE_GENERAL_PROPERTY      121
#define IDS_CANNOT_OPEN_FILE            121
#define IDD_TASK_GENERAL_PROPERTY       122
#define IDS_FAILED_TO_READ_FILE         122
#define IDD_OPERATION_GENERAL_PROPERTY  123
#define IDS_DELETE_FAILED               123
#define IDD_GROUP_GENERAL_PROPERTY      124
#define IDS_CLOSE_CONTAINER_PROPERTY_SHEETS 124
#define IDS_GENERIC_ENUMERATE_ERROR     125
#define IDD_ADMIN_MANAGER_ADVANCED_PROPERTY 126
#define IDS_GENERIC_PROPERTY_SAVE_ERROR 126
#define IDD_TASK_DEFINITION_PROPERTY    127
#define IDS_ADD_FAILED                  127
#define IDD_NEW_ROLE_DEFINITION         128
#define IDS_AD_CONTAINER_LOCATION       128
#define IDD_GROUP_MEMBER                129
#define IDS_SCRIPT_SYNTAX_INCORRECT     129
#define IDD_ADD_GROUP                   130
#define IDS_ROLE_DEFINITION_NAME_EXIST  130
#define IDD_GROUP_NON_MEMBER            131
#define IDS_FS_AUDITING                 131
#define IDD_GROUP_LDAP_QUERY            132
#define IDS_ROOT_OPTIONS                132
#define IDD_SECURITY                    133
#define IDS_TYPE_WINDOWS_GROUP          133
#define IDD_ADD_ROLE_DEFINITION         134
#define IDS_TYPE_WINDOWS_USER           134
#define IDD_ROLE_DEFINITION_PROPERTY    135
#define IDS_TYPE_UNKNOWN                135
#define IDD_AUDIT                       136
#define IDS_TYPE_WINDOWS_COMPUTER       136
#define IDD_SCRIPT                      137
#define IDS_ADD_DEFINITION              137
#define IDD_OPTIONS                     138
#define IDS_GREATER_THAN_MAX_LONG       138
#define IDD_ROLE_GENERAL_PROPERTY       139
#define IDS_MIN_QUERY_TIMEOUT           139
#define IDI_STORE                       140
#define IDS_PROP_ERROR_OBJECT_DELETED   140
#define IDI_APP                         141
#define IDS_GENERIC_PROP_DISPLAY_ERROR  141
#define IDI_GROUP                       142
#define IDS_DELETE_SELECTED_CONFIRMATION 142
#define IDI_SCOPE                       143
#define IDS_FAILURE_IN_MULTIPLE_DELETE  143
#define IDI_ROLE                        144
#define IDS_INVALID_AD_STORE_NAME       144
#define IDI_TASK                        145
#define IDS_GENERIC_FAILURE             145
#define IDI_OPERATION                   146
#define IDS_NO_AD_STORE                 146
#define IDD_ADD_ROLE_DEFINITION_1       147
#define IDS_CREATE_NEW_PATH_NOT_FOUND   147
#define IDD_ROLE_DEF_DIALOG             148
#define IDS_POLICY_DELEGATOR            148
#define IDS_ERROR_FILE_EXIST            149
#define IDS_FMT_PROP_SHEET_TITILE_FOR_ROLE_DEFINITION 150
#define IDS_ERROR_INVALID_NAME          151
#define IDS_CANNOT_ACCESS_AD            152
#define IDS_SACL_SET_FOR_APP_AUTH       153
#define IDS_SACL_SET_FOR_AUTH           154
#define IDS_SACL_SET_FOR_APP            155
#define IDS_ADMIN_CLOSE_ADMIN_MANAGER   156
#define IDS_ERROR_DOMAIN_NOT_ALLOWED    157
#define IDS_SCRIPT_NOT_FOUND            158
#define IDS_ERROR_EMPTY_SCRIPT_FILE     159
#define IDS_CANNOT_READ_FILE_1          160
#define IDS_APP_AUDIT_STRING            161
#define IDS_INFINITE                    162
#define IDS_SCOPE_NOT_DELEGATABLE       163
#define IDS_DELEGATING_PREVENTS_SCRIPTS 164
#define IDS_BIZRULE_NOT_ALLOWED         165
#define IDI_LDAP_GROUP                  167
#define IDI_BASIC_GROUP                 168
#define IDS_OPEN_SCRIPT_FILTER          168
#define IDI_ROLE_DEFINITION             169
#define IDS_INVALIDSTORE_ON_COMMANDLINE 169
#define IDS_CANNOT_FIND_AUTHORIZATION_STORE 170
#define IDS_ADMIN_RELOAD                171
#define IDS_AUDIT_REQUIRE_EXTRA_SETTING 172
#define IDS_TASK_OP_ALREADY_EXIST       173
#define IDS_ROLE_DEFINITION_NAME_INVALID 174
#define IDI_CONTAINER                   178
#define IDB_ICONS                       180
#define IDI_COMPUTER                    190
#define IDI_USER                        191
#define IDI_UNKNOWN_SID                 192
#define IDD_BROWSE_AD_STORE             194
#define IDD_ROLE_DEFINITION_GENERAL_PROPERTY 195
#define IDC_STATIC_NAME                 1000
#define IDC_EDIT_NAME                   1001
#define IDC_EDIT_DESCRIPTION            1002
#define IDC_STATIC_STORE_TYPE1          1002
#define IDC_EDIT_DESCRIPTION2           1003
#define IDC_EDIT_OPERATION_NUMBER       1003
#define IDC_STATIC_VERSION              1003
#define IDC_STATIC_APP_VERSION          1003
#define IDC_EDIT_VERSION                1004
#define IDC_EDIT_APP_VERSION            1004
#define IDC_STATIC_STORE_TYPE_VALUE     1005
#define IDC_STATIC_STORE_TYP            1006
#define IDC_STATIC_STORE_TYPE           1006
#define IDC_RADIO_AD_STORE              1007
#define IDC_EDIT_STORE_TYPE             1007
#define IDC_RADIO_XML_STORE             1008
#define IDC_STATIC_GROUP_TYPE           1010
#define IDC_RADIO_GROUP_TYPE_BASIC      1011
#define IDC_EDIT_NAME1                  1012
#define IDC_RADIO_GROUP_TYPE_LDAP       1012
#define IDC_BUTTON_BROWSE               1013
#define IDC_STATIC_LIST                 1013
#define IDC_LIST_TASK_OPERATION         1015
#define IDC_ADD_TASK                    1016
#define IDC_LIST                        1016
#define IDC_ADD_OPERATION               1017
#define IDC_STATIC_OPERATION_NUMBER     1017
#define IDC_EDIT_GROUP_TYPE             1022
#define IDC_EDIT_DOMAIN_TIMEOUT         1023
#define IDC_EDIT_SCRIPT_ENGINE_TIMEOUT  1024
#define IDC_EDIT_MAX_SCRIPT_ENGINE      1025
#define IDC_STATIC_DOMAIN_TIMEOUT       1026
#define ID_STATIC_SCRIPT_ENGINE_TIMEOUT 1027
#define IDC_STATIC_MAX_SCRIPT_ENGINE    1028
#define IDC_ADD_ROLE                    1029
#define IDC_LIST_MEMBER                 1030
#define IDC_ADD_APPLICATION_GROUP       1031
#define IDC_ADD_WINDOWS_GROUPS          1032
#define IDC_EDIT_LDAP_QUERY             1032
#define IDC_STATIC_LDAP_QUERY           1033
#define IDC_BUTTON_DEFINE_QUERY         1034
#define IDC_COMBO_USER_ROLE             1035
#define IDC_ADD                         1036
#define IDC_AUDIT_AUTHORIZATION_MANAGER 1037
#define IDC_AUDIT_STORE                 1038
#define IDC_BUTTON_RELOAD               1039
#define IDC_STATIC_CODE                 1040
#define IDC_EDIT_CODE                   1041
#define IDC_STATIC_PATH                 1042
#define IDC_EDIT_PATH                   1043
#define IDC_RADIO_VB_SCRIPT             1045
#define IDC_RADIO_JAVA_SCRIPT           1046
#define IDC_CLEAR_SCRIPT                1047
#define IDC_STATIC_SCRIPT_TYPE          1048
#define IDC_STATIC_STORE_DESCRIPTION    1049
#define IDC_STATIC_USER_ROLE            1050
#define IDC_BUTTON_DEFAULT              1051
#define IDC_STATIC_ENABLE               1052
#define IDC_STATIC_APP_NOTE             1053
#define IDC_STATIC_NOTE                 1054
#define IDC_RADIO_DEVELOPER             1055
#define IDC_RADIO_ADMINISTRATOR         1057
#define IDC_STATIC_MODE                 1058
#define IDC_STATIC_NOTE1                1059
#define IDC_BUTTON_DEFINITION           1060
#define IDC_BUTTON_CHECK_SYNTAX         1061
#define IDC_LIST_OP_TASK                1062
#define IDC_STATIC_AD_INFO              1063
#define IDC_PARENT_SACL_STATE           1064
#define IDC_STATIC_AUTHORIZATION_SCRIPT_STATE 1065
#define IDC_RADIO_AUTH_SCRIPT_ENABLED_NO_TIMEOUT 1066
#define IDC_RADIO_AUTH_SCRIPT_DISABLED  1067
#define IDC_RADIO_AUTH_SCRIPT_ENABLED_WITH_TIMEOUT 1068
#define IDI_ICON_LDAP_GROUP             1070
#define IDI_ICON_BASIC_GROUP            1071
#define IDC_AUDIT_HELP_LINK             1072
#define IDC_EDIT_SCRIPT                 1074
#define IDC_REMOVE                      1118
#define IDC_STATIC_STORE_DESC           -1
#define IDC_STATIC_DESCRIPTION          65535
#define IDC_STATIC_APP_NAME             65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        196
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1073
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\helpmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       HelpMap.h
//
//  Contents:   Contains the Help ID and Mapping of control to helpids
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#define BEGIN_HELP_ARRAY(x)	const DWORD g_aHelpIDs_##x[]={ 
#define END_HELP_ARRAY		 0, 0 };
//X is DialogBox is ID, Y is Contrl ID
#define HELP_ID(x,y) 
#define ARRAY_ENTRY(x,y) y, IDH_##x##y,

#define IDH_NOHELP                      ((DWORD)-1)
#define ARRAY_ENTRY_NO_HELP(y) y, IDH_NOHELP,


//IDD_ADD_GROUP
#define IDH_IDD_ADD_GROUPIDC_LIST				0x00001000

//IDD_ADD_OPERATION
#define IDH_IDD_ADD_OPERATIONIDC_LIST			0x00002000

//IDD_ADD_ROLE_DEFINITION
#define IDH_IDD_ADD_ROLE_DEFINITIONIDC_LIST		0x00003000

//IDD_ADD_TASK
#define IDH_IDD_ADD_TASKIDC_LIST				0x00004000

//IDD_ADMIN_MANAGER_ADVANCED_PROPERTY
#define IDH_IDD_ADMIN_MANAGER_ADVANCED_PROPERTYIDC_EDIT_DOMAIN_TIMEOUT				0x00005000
#define IDH_IDD_ADMIN_MANAGER_ADVANCED_PROPERTYIDC_EDIT_SCRIPT_ENGINE_TIMEOUT		0x00005001
#define IDH_IDD_ADMIN_MANAGER_ADVANCED_PROPERTYIDC_EDIT_MAX_SCRIPT_ENGINE			0x00005002
#define IDH_IDD_ADMIN_MANAGER_ADVANCED_PROPERTYIDC_BUTTON_DEFAULT					0x00005003

//IDD_ADMIN_MANAGER_GENERAL_PROPERTY
#define IDH_IDD_ADMIN_MANAGER_GENERAL_PROPERTYIDC_EDIT_NAME						0x00006000
#define IDH_IDD_ADMIN_MANAGER_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION					0x00006001
#define IDH_IDD_ADMIN_MANAGER_GENERAL_PROPERTYIDC_EDIT_STORE_TYPE					0x00006002

//IDD_APPLICATION_GENERAL_PROPERTY
#define IDH_IDD_APPLICATION_GENERAL_PROPERTYIDC_EDIT_NAME							0x00007000
#define IDH_IDD_APPLICATION_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION					0x00007001
#define IDH_IDD_APPLICATION_GENERAL_PROPERTYIDC_EDIT_VERSION						0x00007002

//IDD_AUDIT
#define IDH_IDD_AUDITIDC_AUDIT_AUTHORIZATION_MANAGER			0x00008000
#define IDH_IDD_AUDITIDC_AUDIT_STORE							0x00008001


//IDD_GROUP_GENERAL_PROPERTY
#define IDH_IDD_GROUP_GENERAL_PROPERTYIDC_EDIT_NAME			0x00009000
#define IDH_IDD_GROUP_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION	0x00009001
#define IDH_IDD_GROUP_GENERAL_PROPERTYIDC_EDIT_GROUP_TYPE	0x00009002

//IDD_GROUP_LDAP_QUERY
#define IDH_IDD_GROUP_LDAP_QUERYIDC_EDIT_LDAP_QUERY			0x0000A000
#define IDH_IDD_GROUP_LDAP_QUERYIDC_BUTTON_DEFINE_QUERY		0x0000A001

//IDD_GROUP_MEMBER
#define IDH_IDD_GROUP_MEMBERIDC_LIST_MEMBER					0x0000B000
#define IDH_IDD_GROUP_MEMBERIDC_ADD_APPLICATION_GROUP		0x0000B001
#define IDH_IDD_GROUP_MEMBERIDC_ADD_WINDOWS_GROUPS			0x0000B002
#define IDH_IDD_GROUP_MEMBERIDC_REMOVE						0x0000B003

//IDD_GROUP_NON_MEMBER
#define IDH_IDD_GROUP_NON_MEMBERIDC_LIST_MEMBER				0x0000C000
#define IDH_IDD_GROUP_NON_MEMBERIDC_ADD_APPLICATION_GROUP	0x0000C001
#define IDH_IDD_GROUP_NON_MEMBERIDC_ADD_WINDOWS_GROUPS		0x0000C002
#define IDH_IDD_GROUP_NON_MEMBERIDC_REMOVE					0x0000C003

//IDD_NEW_APPLICATION
#define IDH_IDD_NEW_APPLICATIONIDC_EDIT_NAME				0x0000D000
#define IDH_IDD_NEW_APPLICATIONIDC_EDIT_DESCRIPTION			0x0000D001
#define IDH_IDD_NEW_APPLICATIONIDC_EDIT_VERSION				0x0000D002


//IDD_NEW_AUTHORIZATION_STORE
#define IDH_IDD_NEW_AUTHORIZATION_STOREIDC_RADIO_AD_STORE		0x0000E000
#define IDH_IDD_NEW_AUTHORIZATION_STOREIDC_RADIO_XML_STORE		0x0000E001
#define IDH_IDD_NEW_AUTHORIZATION_STOREIDC_EDIT_NAME			0x0000E002
#define IDH_IDD_NEW_AUTHORIZATION_STOREIDC_BUTTON_BROWSE		0x0000E003
#define IDH_IDD_NEW_AUTHORIZATION_STOREIDC_EDIT_DESCRIPTION		0x0000E004

//IDD_NEW_GROUP
#define IDH_IDD_NEW_GROUPIDC_EDIT_NAME						0x0000F000
#define IDH_IDD_NEW_GROUPIDC_EDIT_DESCRIPTION				0x0000F001
#define IDH_IDD_NEW_GROUPIDC_RADIO_GROUP_TYPE_BASIC			0x0000F002
#define IDH_IDD_NEW_GROUPIDC_RADIO_GROUP_TYPE_LDAP			0x0000F003

//IDD_NEW_OPERATION
#define IDH_IDD_NEW_OPERATIONIDC_EDIT_NAME					0x00010000
#define IDH_IDD_NEW_OPERATIONIDC_EDIT_DESCRIPTION			0x00010001
#define IDH_IDD_NEW_OPERATIONIDC_EDIT_OPERATION_NUMBER		0x00010002

//IDD_NEW_ROLE_DEFINITION
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_EDIT_NAME			0x00020000
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_EDIT_DESCRIPTION		0x00020002
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_LIST_TASK_OPERATION	0x00020003
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_ADD_TASK				0x00020004
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_ADD_ROLE				0x00020005
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_REMOVE				0x00020006
#define IDH_IDD_NEW_ROLE_DEFINITIONIDC_EDIT_SCRIPT			0x00020007

//IDD_NEW_SCOPE
#define IDH_IDD_NEW_SCOPEIDC_EDIT_NAME						0x00030001
#define IDH_IDD_NEW_SCOPEIDC_EDIT_DESCRIPTION				0x00030002

//IDD_NEW_TASK
#define IDH_IDD_NEW_TASKIDC_EDIT_NAME						0x00040000
#define IDH_IDD_NEW_TASKIDC_EDIT_DESCRIPTION				0x00040001
#define IDH_IDD_NEW_TASKIDC_LIST_TASK_OPERATION				0x00040002
#define IDH_IDD_NEW_TASKIDC_ADD_TASK						0x00040003
#define IDH_IDD_NEW_TASKIDC_ADD_OPERATION					0x00040004
#define IDH_IDD_NEW_TASKIDC_REMOVE							0x00040005
#define IDH_IDD_NEW_TASKIDC_EDIT_SCRIPT						0x00040006

//IDD_OPEN_AUTHORIZATION_STORE
#define IDH_IDD_OPEN_AUTHORIZATION_STOREIDC_RADIO_AD_STORE	0x00050000
#define IDH_IDD_OPEN_AUTHORIZATION_STOREIDC_RADIO_XML_STORE	0x00050001
#define IDH_IDD_OPEN_AUTHORIZATION_STOREIDC_EDIT_NAME		0x00050002
#define IDH_IDD_OPEN_AUTHORIZATION_STOREIDC_BUTTON_BROWSE	0x00050003

//IDD_NEW_OPERATION
#define IDH_IDD_OPERATION_GENERAL_PROPERTYIDC_EDIT_NAME				0x00060000
#define IDH_IDD_OPERATION_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION		0x00060001
#define IDH_IDD_OPERATION_GENERAL_PROPERTYIDC_EDIT_OPERATION_NUMBER	0x00060002

//IDD_ROLE_DEFINITION_PROPERTY
#define IDH_IDD_ROLE_DEFINITION_PROPERTYIDC_LIST_TASK_OPERATION		0x00070000
#define IDH_IDD_ROLE_DEFINITION_PROPERTYIDC_ADD_TASK				0x00070001
#define IDH_IDD_ROLE_DEFINITION_PROPERTYIDC_ADD_ROLE				0x00070002
#define IDH_IDD_ROLE_DEFINITION_PROPERTYIDC_REMOVE					0x00070003
#define IDH_IDD_ROLE_DEFINITION_PROPERTYIDC_EDIT_SCRIPT				0x00070004

//IDD_SCOPE_GENERAL_PROPERTY
#define IDH_IDD_SCOPE_GENERAL_PROPERTYIDC_EDIT_NAME				0x00080000
#define IDH_IDD_SCOPE_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION		0x00080001


//IDD_SCRIPT
#define IDH_IDD_SCRIPTIDC_RADIO_VB_SCRIPT		0x00090000
#define IDH_IDD_SCRIPTIDC_RADIO_JAVA_SCRIPT		0x00090001
#define IDH_IDD_SCRIPTIDC_EDIT_CODE				0x00090002
#define IDH_IDD_SCRIPTIDC_EDIT_PATH				0x00090003
#define IDH_IDD_SCRIPTIDC_BUTTON_BROWSE			0x00090004
#define IDH_IDD_SCRIPTIDC_BUTTON_RELOAD			0x00090005
#define IDH_IDD_SCRIPTIDC_CLEAR_SCRIPT			0x00090006

//IDD_SECURITY
#define IDH_IDD_SECURITYIDC_COMBO_USER_ROLE						0x000A0000
#define IDH_IDD_SECURITYIDC_LIST_MEMBER							0x000A0001
#define IDH_IDD_SECURITYIDC_ADD									0x000A0002
#define IDH_IDD_SECURITYIDC_REMOVE								0x000A0003

//IDD_TASK_DEFINITION_PROPERTY
#define IDH_IDD_TASK_DEFINITION_PROPERTYIDC_LIST_TASK_OPERATION	0x000B0000
#define IDH_IDD_TASK_DEFINITION_PROPERTYIDC_ADD_TASK			0x000B0001
#define IDH_IDD_TASK_DEFINITION_PROPERTYIDC_ADD_OPERATION		0x000B0002		
#define IDH_IDD_TASK_DEFINITION_PROPERTYIDC_REMOVE				0x000B0003
#define IDH_IDD_TASK_DEFINITION_PROPERTYIDC_EDIT_SCRIPT			0x000B0004

//IDD_TASK_GENERAL_PROPERTY
#define IDH_IDD_TASK_GENERAL_PROPERTYIDC_EDIT_NAME				0x000C0001
#define IDH_IDD_TASK_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION		0x000C0002

//IDD_ROLE_GENERAL_PROPERTY
#define IDH_IDD_ROLE_GENERAL_PROPERTYIDC_EDIT_NAME				0x000D0001
#define IDH_IDD_ROLE_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION		0x000D0002
#define IDH_IDD_ROLE_GENERAL_PROPERTYIDC_BUTTON_DEFINITION			0x000D0003


//IDD_ROLE_DEF_DIALOG
#define IDH_IDD_ROLE_DEF_DIALOGIDC_LIST_OP_TASK		0x000E0000
#define IDH_IDD_ROLE_DEF_DIALOGIDC_ADD				0x000E0001
#define IDH_IDD_ROLE_DEF_DIALOGIDC_REMOVE					0x000E0002

//IDD_BROWSE_AD_STORE
#define IDH_IDD_BROWSE_AD_STOREIDC_LIST				0x000F0001

//IDD_ADD_ROLE_DEFINITION_1
#define IDH_IDD_ADD_ROLE_DEFINITION_1IDC_LIST		0x00100001

//IDD_ROLE_DEFINITION_GENERAL_PROPERTY
#define IDH_IDD_ROLE_DEFINITION_GENERAL_PROPERTYIDC_EDIT_NAME				0x00200001
#define IDH_IDD_ROLE_DEFINITION_GENERAL_PROPERTYIDC_EDIT_DESCRIPTION		0x00200002


//IDD_ADD_GROUP
BEGIN_HELP_ARRAY(IDD_ADD_GROUP)
    ARRAY_ENTRY(IDD_ADD_GROUP,IDC_LIST)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY


//IDD_ADD_OPERATION
BEGIN_HELP_ARRAY(IDD_ADD_OPERATION)
    ARRAY_ENTRY(IDD_ADD_OPERATION,IDC_LIST)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_ADD_ROLE_DEFINITION
BEGIN_HELP_ARRAY(IDD_ADD_ROLE_DEFINITION)
	ARRAY_ENTRY(IDD_ADD_ROLE_DEFINITION,IDC_LIST)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_ADD_TASK
BEGIN_HELP_ARRAY(IDD_ADD_TASK)
    ARRAY_ENTRY(IDD_ADD_TASK,IDC_LIST)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_ADMIN_MANAGER_ADVANCED_PROPERTY
BEGIN_HELP_ARRAY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY,IDC_EDIT_DOMAIN_TIMEOUT)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY,IDC_EDIT_SCRIPT_ENGINE_TIMEOUT)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY,IDC_EDIT_MAX_SCRIPT_ENGINE)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY,IDC_BUTTON_DEFAULT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DOMAIN_TIMEOUT)
	ARRAY_ENTRY_NO_HELP(ID_STATIC_SCRIPT_ENGINE_TIMEOUT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_MAX_SCRIPT_ENGINE)
END_HELP_ARRAY

//IDD_ADMIN_MANAGER_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_ADMIN_MANAGER_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_ADMIN_MANAGER_GENERAL_PROPERTY,IDC_EDIT_STORE_TYPE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_STORE_TYPE)
END_HELP_ARRAY

//IDD_APPLICATION_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_APPLICATION_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_APPLICATION_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_APPLICATION_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_APPLICATION_GENERAL_PROPERTY,IDC_EDIT_VERSION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_VERSION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_APP_NOTE)
END_HELP_ARRAY

//IDD_AUDIT
BEGIN_HELP_ARRAY(IDD_AUDIT)
	ARRAY_ENTRY(IDD_AUDIT,IDC_AUDIT_AUTHORIZATION_MANAGER)
	ARRAY_ENTRY(IDD_AUDIT,IDC_AUDIT_STORE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_ENABLE)
END_HELP_ARRAY

//IDD_GROUP_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_GROUP_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_GROUP_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_GROUP_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_GROUP_GENERAL_PROPERTY,IDC_EDIT_GROUP_TYPE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_GROUP_TYPE)
END_HELP_ARRAY

//IDD_GROUP_LDAP_QUERY
BEGIN_HELP_ARRAY(IDD_GROUP_LDAP_QUERY)
	ARRAY_ENTRY(IDD_GROUP_LDAP_QUERY,IDC_EDIT_LDAP_QUERY)
	ARRAY_ENTRY(IDD_GROUP_LDAP_QUERY,IDC_BUTTON_DEFINE_QUERY)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LDAP_QUERY)
END_HELP_ARRAY

//IDD_GROUP_MEMBER
BEGIN_HELP_ARRAY(IDD_GROUP_MEMBER)
	ARRAY_ENTRY(IDD_GROUP_MEMBER,IDC_LIST_MEMBER)
	ARRAY_ENTRY(IDD_GROUP_MEMBER,IDC_ADD_APPLICATION_GROUP)
	ARRAY_ENTRY(IDD_GROUP_MEMBER,IDC_ADD_WINDOWS_GROUPS)
	ARRAY_ENTRY(IDD_GROUP_MEMBER,IDC_REMOVE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_GROUP_NON_MEMBER
BEGIN_HELP_ARRAY(IDD_GROUP_NON_MEMBER)
	ARRAY_ENTRY(IDD_GROUP_NON_MEMBER,IDC_LIST_MEMBER)
	ARRAY_ENTRY(IDD_GROUP_NON_MEMBER,IDC_ADD_APPLICATION_GROUP)
	ARRAY_ENTRY(IDD_GROUP_NON_MEMBER,IDC_ADD_WINDOWS_GROUPS)
	ARRAY_ENTRY(IDD_GROUP_NON_MEMBER,IDC_REMOVE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_NEW_APPLICATION
BEGIN_HELP_ARRAY(IDD_NEW_APPLICATION)
	ARRAY_ENTRY(IDD_NEW_APPLICATION,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_APPLICATION,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_NEW_APPLICATION,IDC_EDIT_VERSION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_APP_NOTE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_VERSION)
END_HELP_ARRAY


//IDD_NEW_AUTHORIZATION_STORE
BEGIN_HELP_ARRAY(IDD_NEW_AUTHORIZATION_STORE)
	ARRAY_ENTRY(IDD_NEW_AUTHORIZATION_STORE,IDC_RADIO_AD_STORE)
	ARRAY_ENTRY(IDD_NEW_AUTHORIZATION_STORE,IDC_RADIO_XML_STORE	)
	ARRAY_ENTRY(IDD_NEW_AUTHORIZATION_STORE,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_AUTHORIZATION_STORE,IDC_BUTTON_BROWSE)
	ARRAY_ENTRY(IDD_NEW_AUTHORIZATION_STORE,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_STORE_TYPE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_STORE_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_NEW_GROUP
BEGIN_HELP_ARRAY(IDD_NEW_GROUP)
	ARRAY_ENTRY(IDD_NEW_GROUP,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_GROUP,IDC_EDIT_DESCRIPTION	)
	ARRAY_ENTRY(IDD_NEW_GROUP,IDC_RADIO_GROUP_TYPE_BASIC)
	ARRAY_ENTRY(IDD_NEW_GROUP,IDC_RADIO_GROUP_TYPE_LDAP)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_GROUP_TYPE)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_NEW_OPERATION
BEGIN_HELP_ARRAY(IDD_NEW_OPERATION)
	ARRAY_ENTRY(IDD_NEW_OPERATION,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_OPERATION,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_NEW_OPERATION,IDC_EDIT_OPERATION_NUMBER)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_OPERATION_NUMBER)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_NEW_ROLE_DEFINITION
BEGIN_HELP_ARRAY(IDD_NEW_ROLE_DEFINITION)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_LIST_TASK_OPERATION)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_ADD_TASK)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_ADD_ROLE)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_REMOVE)
	ARRAY_ENTRY(IDD_NEW_ROLE_DEFINITION,IDC_EDIT_SCRIPT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_NEW_SCOPE
BEGIN_HELP_ARRAY(IDD_NEW_SCOPE)
	ARRAY_ENTRY(IDD_NEW_SCOPE,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_SCOPE,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NOTE)
END_HELP_ARRAY


//IDD_NEW_TASK
BEGIN_HELP_ARRAY(IDD_NEW_TASK)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_LIST_TASK_OPERATION)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_ADD_TASK)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_ADD_OPERATION)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_REMOVE)
	ARRAY_ENTRY(IDD_NEW_TASK,IDC_EDIT_SCRIPT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_OPEN_AUTHORIZATION_STORE
BEGIN_HELP_ARRAY(IDD_OPEN_AUTHORIZATION_STORE)
	ARRAY_ENTRY(IDD_OPEN_AUTHORIZATION_STORE,IDC_RADIO_AD_STORE)
	ARRAY_ENTRY(IDD_OPEN_AUTHORIZATION_STORE,IDC_RADIO_XML_STORE	)
	ARRAY_ENTRY(IDD_OPEN_AUTHORIZATION_STORE,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_OPEN_AUTHORIZATION_STORE,IDC_BUTTON_BROWSE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_STORE_TYPE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_NEW_OPERATION
BEGIN_HELP_ARRAY(IDD_OPERATION_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_OPERATION_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_OPERATION_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_OPERATION_GENERAL_PROPERTY,IDC_EDIT_OPERATION_NUMBER)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_OPERATION_NUMBER)
END_HELP_ARRAY

//IDD_ROLE_DEFINITION_PROPERTY
BEGIN_HELP_ARRAY(IDD_ROLE_DEFINITION_PROPERTY)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_PROPERTY,IDC_LIST_TASK_OPERATION)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_PROPERTY,IDC_ADD_TASK)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_PROPERTY,IDC_ADD_ROLE)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_PROPERTY,IDC_REMOVE)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_PROPERTY,IDC_EDIT_SCRIPT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_SCOPE_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_SCOPE_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_SCOPE_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_SCOPE_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NOTE)
END_HELP_ARRAY


//IDD_SCRIPT
BEGIN_HELP_ARRAY(IDD_SCRIPT)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_RADIO_VB_SCRIPT)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_RADIO_JAVA_SCRIPT)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_EDIT_CODE)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_EDIT_PATH)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_BUTTON_BROWSE)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_BUTTON_RELOAD)
	ARRAY_ENTRY(IDD_SCRIPT,IDC_CLEAR_SCRIPT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_SCRIPT_TYPE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_CODE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_PATH)
	ARRAY_ENTRY_NO_HELP(IDOK)
	ARRAY_ENTRY_NO_HELP(IDCANCEL)
END_HELP_ARRAY

//IDD_SECURITY
BEGIN_HELP_ARRAY(IDD_SECURITY)
	ARRAY_ENTRY(IDD_SECURITY,IDC_COMBO_USER_ROLE)
	ARRAY_ENTRY(IDD_SECURITY,IDC_LIST_MEMBER)
	ARRAY_ENTRY(IDD_SECURITY,IDC_ADD)
	ARRAY_ENTRY(IDD_SECURITY,IDC_REMOVE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_USER_ROLE)
END_HELP_ARRAY

//IDD_TASK_DEFINITION_PROPERTY
BEGIN_HELP_ARRAY(IDD_TASK_DEFINITION_PROPERTY)
	ARRAY_ENTRY(IDD_TASK_DEFINITION_PROPERTY,IDC_LIST_TASK_OPERATION)
	ARRAY_ENTRY(IDD_TASK_DEFINITION_PROPERTY,IDC_ADD_TASK)
	ARRAY_ENTRY(IDD_TASK_DEFINITION_PROPERTY,IDC_ADD_OPERATION)
	ARRAY_ENTRY(IDD_TASK_DEFINITION_PROPERTY,IDC_REMOVE)
	ARRAY_ENTRY(IDD_TASK_DEFINITION_PROPERTY,IDC_EDIT_SCRIPT)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_TASK_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_TASK_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_TASK_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_TASK_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
END_HELP_ARRAY


//IDD_ROLE_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_ROLE_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_ROLE_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_ROLE_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY(IDD_ROLE_GENERAL_PROPERTY,IDC_BUTTON_DEFINITION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
END_HELP_ARRAY


//IDD_ROLE_DEF_DIALOG
BEGIN_HELP_ARRAY(IDD_ROLE_DEF_DIALOG)
	ARRAY_ENTRY(IDD_ROLE_DEF_DIALOG,IDC_LIST_OP_TASK)
	ARRAY_ENTRY(IDD_ROLE_DEF_DIALOG,IDC_ADD)
	ARRAY_ENTRY(IDD_ROLE_DEF_DIALOG,IDC_REMOVE)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_BROWSE_AD_STORE
BEGIN_HELP_ARRAY(IDD_BROWSE_AD_STORE)
	ARRAY_ENTRY(IDD_BROWSE_AD_STORE,IDC_LIST)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_ADD_ROLE_DEFINITION_1
BEGIN_HELP_ARRAY(IDD_ADD_ROLE_DEFINITION_1)
	ARRAY_ENTRY(IDD_ADD_ROLE_DEFINITION_1,IDC_LIST)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_LIST)
END_HELP_ARRAY

//IDD_ROLE_DEFINITION_GENERAL_PROPERTY
BEGIN_HELP_ARRAY(IDD_ROLE_DEFINITION_GENERAL_PROPERTY)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_GENERAL_PROPERTY,IDC_EDIT_NAME)
	ARRAY_ENTRY(IDD_ROLE_DEFINITION_GENERAL_PROPERTY,IDC_EDIT_DESCRIPTION)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_NAME)
	ARRAY_ENTRY_NO_HELP(IDC_STATIC_DESCRIPTION)
END_HELP_ARRAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\rolesnap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       rolesnap.cpp
//
//  Contents:   Contains Menu, Column Headers etc info
//
//  History:    08-01-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"


//
//Context Menus
//
BEGIN_MENU(CRootDataMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_ROOT_NEW_STORE, L"_ROOT_NEW_STORE")
                CTX_ENTRY_TOP(IDM_ROOT_OPEN_STORE, L"_ROOT_OPEN_STORE")                
                CTX_ENTRY_TOP(IDM_ROOT_OPTIONS, L"_ROOT_OPTIONS")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_ROOT_NEW_STORE)
                RES_ENTRY(IDS_ROOT_OPEN_STORE)                
                RES_ENTRY(IDS_ROOT_OPTIONS)
        END_RES
END_MENU

BEGIN_MENU(CAdminManagerNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_ADMIN_NEW_APP, L"_ADMIN_NEW_APP")
				CTX_ENTRY_TOP(IDM_ADMIN_CLOSE_ADMIN_MANAGER, L"_CLOSE_ADMIN_MANAGER")
                CTX_ENTRY_TOP(IDM_ADMIN_RELOAD, L"_RELOAD_ADMIN_MANAGER")                
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_ADMIN_NEW_APP)
				RES_ENTRY(IDS_ADMIN_CLOSE_ADMIN_MANAGER)
                RES_ENTRY(IDS_ADMIN_RELOAD)
        END_RES
END_MENU

BEGIN_MENU(CApplicationNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_APP_NEW_SCOPE, L"_APP_NEW_SCOPE")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_APP_NEW_SCOPE)
        END_RES
END_MENU

BEGIN_MENU(CScopeNodeMenuHolder)
        BEGIN_CTX
        END_CTX
        BEGIN_RES
        END_RES
END_MENU

BEGIN_MENU(CGroupCollectionNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_GROUP_CONTAINER_NEW_GROUP, L"_GROUP_CONTAINER_NEW_GROUP")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_GROUP_CONTAINER_NEW_GROUP)
        END_RES
END_MENU

BEGIN_MENU(CRoleCollectionNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_ROLE_CONTAINER_ASSIGN_ROLE, L"_ROOT_OPEN_STORE")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_ROLE_CONTAINER_ASSIGN_ROLE)
        END_RES
END_MENU

BEGIN_MENU(CTaskCollectionNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_TASK_CONTAINER_NEW_TASK, L"_TASK_CONTAINER_NEW_TASK")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_TASK_CONTAINER_NEW_TASK)
        END_RES
END_MENU

BEGIN_MENU(COperationCollectionNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_OPERATION_CONTAINER_NEW_OPERATION, L"_OPERATION_CONTAINER_NEW_OPERATION")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_OPERATION_CONTAINER_NEW_OPERATION)
        END_RES
END_MENU

BEGIN_MENU(CRoleDefinitionCollectionNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_ROLE_DEFINITION_CONTAINER_NEW_ROLE_DEFINITION, L"_OPERATION_CONTAINER_NEW_OPERATION")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_ROLE_DEFINITION_CONTAINER_NEW_ROLE_DEFINITION)
        END_RES
END_MENU


BEGIN_MENU(CGroupNodeMenuHolder)
        BEGIN_CTX

        END_CTX
        BEGIN_RES

        END_RES
END_MENU

BEGIN_MENU(CRoleNodeMenuHolder)
        BEGIN_CTX
                CTX_ENTRY_TOP(IDM_ROLE_NODE_ASSIGN_APPLICATION_GROUPS, L"IDM_ROLE_NODE_ASSIGN_APPLICATION_GROUPS")
                CTX_ENTRY_TOP(IDM_ROLE_NODE_ASSIGN_WINDOWS_GROUPS, L"IDM_ROLE_NODE_ASSIGN_WINDOWS_GROUPS")
        END_CTX
        BEGIN_RES
                RES_ENTRY(IDS_ROLE_NODE_ASSIGN_APPLICATION_GROUPS)
                RES_ENTRY(IDS_ROLE_NODE_ASSIGN_WINDOWS_GROUPS)
        END_RES
END_MENU

BEGIN_MENU(CTaskNodeMenuHolder)
        BEGIN_CTX

        END_CTX
        BEGIN_RES

        END_RES
END_MENU

//
//Header Strings
//
RESULT_HEADERMAP _DefaultHeaderStrings[] =
{
        { L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
        { L"", IDS_HEADER_TYPE, LVCFMT_LEFT, 150},
        { L"", IDS_HEADER_DESCRIPTION, LVCFMT_LEFT, 360}
};

//
//Columns For Various ListBoxes
//

COL_FOR_LV Col_For_Task_Role[]=
{
    IDS_HEADER_NAME, 35,
    IDS_HEADER_TYPE, 25,
    IDS_HEADER_DESCRIPTION,40,
        LAST_COL_ENTRY_IDTEXT, 0,
};

//Column for Add Role, Add Task , Add Operation
//Listboxes
COL_FOR_LV Col_For_Add_Object[]=
{
        IDS_HEADER_NAME,        40,
        IDS_HEADER_WHERE_DEFINED,35,
        IDS_HEADER_DESCRIPTION,25,
        LAST_COL_ENTRY_IDTEXT,0,
};

COL_FOR_LV Col_For_Security_Page[]=
{
    IDS_HEADER_NAME, 50,
        IDS_HEADER_WHERE_DEFINED,50,
        LAST_COL_ENTRY_IDTEXT,0,
};


COL_FOR_LV Col_For_Browse_ADStore_Page[]=
{
        IDS_HEADER_NAME, 100,
        LAST_COL_ENTRY_IDTEXT,0,
};



#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0351 */
/* Compiler settings for azroles.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0351 */
/* Compiler settings for azroles.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\rolesnap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       rolesnap.h
//
//  Contents:   Contains Info which is common to many classes
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#define	BMP_COLOR_MASK RGB(255,0,255) // pink


//
// Context menus
//

// Identifiers for each of the commands in the context menu.
enum
{
	//
	// Items for the root node
	//
	IDM_ROOT_OPEN_STORE,
    IDM_ROOT_NEW_STORE,
	IDM_ROOT_OPTIONS,

	//
	//Items for the AdminManger Node
	//
	IDM_ADMIN_NEW_APP,
	IDM_ADMIN_CLOSE_ADMIN_MANAGER,
    IDM_ADMIN_RELOAD,

	//
	//Items for the Application node
	//
	IDM_APP_NEW_SCOPE,
	
	//
	//Items for Scope Node
	//
	IDM_SCOPE_ADD_ROLE,

	//
	//Items For Group Container Node
	//
	IDM_GROUP_CONTAINER_NEW_GROUP,

	//
	//Items For Role Container Node
	//
	IDM_ROLE_CONTAINER_ASSIGN_ROLE,

	//
	//Items for Role Definition container Node
	//
	IDM_ROLE_DEFINITION_CONTAINER_NEW_ROLE_DEFINITION,

	//
	//Items For Task Container Node
	//
	IDM_TASK_CONTAINER_NEW_TASK,

	//
	//Items For Operation Container Node
	//
	IDM_OPERATION_CONTAINER_NEW_OPERATION,

	//
	//Items for RoleNode
	//
	IDM_ROLE_NODE_ASSIGN_APPLICATION_GROUPS,
	IDM_ROLE_NODE_ASSIGN_WINDOWS_GROUPS,
};


DECLARE_MENU(CRootDataMenuHolder)
DECLARE_MENU(CAdminManagerNodeMenuHolder)
DECLARE_MENU(CApplicationNodeMenuHolder)
DECLARE_MENU(CScopeNodeMenuHolder)
DECLARE_MENU(CGroupCollectionNodeMenuHolder)
DECLARE_MENU(CTaskCollectionNodeMenuHolder)
DECLARE_MENU(CRoleCollectionNodeMenuHolder)
DECLARE_MENU(COperationCollectionNodeMenuHolder)
DECLARE_MENU(CRoleDefinitionCollectionNodeMenuHolder)
DECLARE_MENU(CGroupNodeMenuHolder)
DECLARE_MENU(CTaskNodeMenuHolder)
DECLARE_MENU(CRoleNodeMenuHolder)

//
// enumeration for image strips
//
enum
{
	ROOT_IMAGE = 0,

};



//
//Column Headers for result pane
//
extern RESULT_HEADERMAP _DefaultHeaderStrings[];
#define N_DEFAULT_HEADER_COLS 3


//
// CRoleDefaultColumnSet
//
class CRoleDefaultColumnSet : public CColumnSet
{
public :
	CRoleDefaultColumnSet(LPCWSTR lpszColumnID)
		: CColumnSet(lpszColumnID)
	{
		for (int iCol = 0; iCol < N_DEFAULT_HEADER_COLS; iCol++)
		{
      CColumn* pNewColumn = new CColumn(_DefaultHeaderStrings[iCol].szBuffer,
                                        _DefaultHeaderStrings[iCol].nFormat,
                                        _DefaultHeaderStrings[iCol].nWidth,
                                        iCol);
      AddTail(pNewColumn);
 		}
	}
};


//+----------------------------------------------------------------------------
//  Structure for Listview Columns and their width in percentage
//  
//  
//  
//-----------------------------------------------------------------------------

typedef struct _col_for_listview
{
    UINT    idText;     // Resource Id for column name
    UINT    iPercent;   // Percent of width
} COL_FOR_LV;

#define LAST_COL_ENTRY_IDTEXT 0xFFFF
//
//Columns For Various ListBoxes
//
extern COL_FOR_LV Col_For_Task_Role[];
extern COL_FOR_LV Col_For_Add_Object[];
extern COL_FOR_LV Col_For_Security_Page[];
extern COL_FOR_LV Col_For_Browse_ADStore_Page[];

#define COL_NAME 0x0001
#define COL_TYPE 0x0002
#define COL_PARENT_TYPE 0x0004
#define COL_DESCRIPTION	0x0008


// Enumeration for the icons used
enum
{
	iIconUnknownSid,
	iIconComputerSid,
	iIconGroup,
	iIconLocalGroup,		//This is not used, but since its in the imagelist
							//i added an entry here
	iIconUser,
	iIconBasicGroup,
	iIconLdapGroup,
    iIconOperation,
    iIconTask,
    iIconRoleDefinition,
    iIconStore,
	iIconApplication,
    iIconRole,
    iIconRoleSnapin,
    iIconScope,
	iIconContainer,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\rootdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.hxx
//
//  Contents:   Contains class definition for Snapin's Root Node
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

//Values for ADSTATE
#define AD_STATE_UNKNOWN	0
#define AD_NOT_AVAILABLE	1
#define AD_AVAILABLE		2


class CRoleRootData : public CRootData
{
public:
	CRoleRootData(CComponentDataObject* pComponentData);

	virtual ~CRoleRootData();

	BOOL
	IsDeveloperMode(){return m_bDeveloperMode;}

    const CString&
    GetXMLStorePath();
    
    void
    SetXMLStorePath(const CString& strXMLStorePath);
	//
	// node info
	//
	DECLARE_NODE_GUID()

	virtual HRESULT OnCommand(long nCommandID, 
                             DATA_OBJECT_TYPES type, 
                             CComponentDataObject* pComponentData,
                             CNodeList* pNodeList);
	//
	//Cannot Delete Root Node
	//
	virtual void OnDelete(CComponentDataObject*,
                         CNodeList*){ ASSERT(FALSE);}

	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
								  CNodeList* pNodeList);

	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide,
                                     CNodeList* pNodeList);

	virtual int GetImageIndex(BOOL) { return iIconRoleSnapin;}


	//
   // Filtering
	//
	BOOL IsAdvancedView() { return m_bAdvancedView; }
   
	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, 
									 BOOL bAsync = TRUE);

	//
	// IStream manipulation helpers overrides
	//
	virtual HRESULT IsDirty();
	
	virtual HRESULT Load(IStream* pStm);
	
	virtual HRESULT Save(IStream* pStm, BOOL fClearDirty);

	virtual CColumnSet* GetColumnSet();
  
	virtual LPCWSTR GetColumnID() { return GetColumnSet()->GetColumnID(); }

   HRESULT GetResultViewType(CComponentDataObject* pComponentData, 
                             LPOLESTR *ppViewType, 
                             long *pViewOptions);
  
   HRESULT OnShow(LPCONSOLE lpConsole);

	virtual BOOL CanExpandSync() { return TRUE; }

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES, 
								  BOOL* pbHideVerb, 
								  CNodeList*);

	DWORD
	GetADState();

	CADInfo& GetAdInfo(){return m_ADInfo;};

//	DECLARE_TOOLBAR_MAP()
protected:
	virtual BOOL CanCloseSheets();
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable();
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
										long *pInsertionAllowed);
	
private:
	void OnOpenPolicyStore(BOOL bNew);
	void OnOptions();

	BOOL m_bAdvancedView;	// view option toggle
	BOOL m_bDeveloperMode;

    CString m_strXMLStoreDirectory;

	DWORD m_dwADState;
	CADInfo m_ADInfo;
private:

	CColumnSet* m_pColumnSet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\rootdata.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       roledata.cpp
//
//  Contents:   Implementaion of Snapin's Root Node
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"
//
//CRoleRootData
//

// {356E1951-089F-4a2f-AD3E-775DB8B899E9}
const GUID CRoleRootData::NodeTypeGUID =
{ 0x356e1951, 0x89f, 0x4a2f, { 0xad, 0x3e, 0x77, 0x5d, 0xb8, 0xb8, 0x99, 0xe9 } };

const GUID CAdminManagerNode::NodeTypeGUID =
// {579D6E87-2DDC-4a45-A12B-41FA73D4153C}
{ 0x579d6e87, 0x2ddc, 0x4a45, { 0xa1, 0x2b, 0x41, 0xfa, 0x73, 0xd4, 0x15, 0x3c } };

const GUID CApplicationNode::NodeTypeGUID =
// {F65C5386-6970-48b2-BF11-178C4B5DB18D}
{ 0xf65c5386, 0x6970, 0x48b2, { 0xbf, 0x11, 0x17, 0x8c, 0x4b, 0x5d, 0xb1, 0x8d } };

const GUID CScopeNode::NodeTypeGUID =
// {E114ECCB-03C9-45fa-97B1-AFACF1300AC3}
{ 0xe114eccb, 0x3c9, 0x45fa, { 0x97, 0xb1, 0xaf, 0xac, 0xf1, 0x30, 0xa, 0xc3 } };

const GUID CGroupCollectionNode::NodeTypeGUID =
// {6346FECB-D27F-446f-A388-FF32CE3649BB}
{ 0x6346fecb, 0xd27f, 0x446f, { 0xa3, 0x88, 0xff, 0x32, 0xce, 0x36, 0x49, 0xbb } };

const GUID CRoleDefinitionCollectionNode::NodeTypeGUID =
// {B3F21054-16DD-4528-98B9-64704F2DD72A}
{ 0xb3f21054, 0x16dd, 0x4528, { 0x98, 0xb9, 0x64, 0x70, 0x4f, 0x2d, 0xd7, 0x2a } };

const GUID CTaskCollectionNode::NodeTypeGUID =
// {D3BBCC7C-44A6-4914-ABC3-3A84D9D9293F}
{ 0xd3bbcc7c, 0x44a6, 0x4914, { 0xab, 0xc3, 0x3a, 0x84, 0xd9, 0xd9, 0x29, 0x3f } };

const GUID CRoleCollectionNode::NodeTypeGUID =
// {DB409E8C-94CC-4af7-A8EF-A3B850B14249}
{ 0xdb409e8c, 0x94cc, 0x4af7, { 0xa8, 0xef, 0xa3, 0xb8, 0x50, 0xb1, 0x42, 0x49 } };

const GUID COperationCollectionNode::NodeTypeGUID =
// {A5539402-429E-44d5-B99C-F0378AEE370B}
{ 0xa5539402, 0x429e, 0x44d5, { 0xb9, 0x9c, 0xf0, 0x37, 0x8a, 0xee, 0x37, 0xb } };

const GUID CDefinitionCollectionNode::NodeTypeGUID =
// {0E6E6CAC-5EB4-4d52-81D8-AC8CB4DF487C}
{ 0xe6e6cac, 0x5eb4, 0x4d52, { 0x81, 0xd8, 0xac, 0x8c, 0xb4, 0xdf, 0x48, 0x7c } };

const GUID CRoleNode::NodeTypeGUID =
// {94A20351-7977-4698-B8AC-D362504A7EEC}
{ 0x94a20351, 0x7977, 0x4698, { 0xb8, 0xac, 0xd3, 0x62, 0x50, 0x4a, 0x7e, 0xec } };

const GUID CBaseLeafNode::NodeTypeGUID =
// {475BFD50-96E4-407a-977E-E031747C3C50}
{ 0x475bfd50, 0x96e4, 0x407a, { 0x97, 0x7e, 0xe0, 0x31, 0x74, 0x7c, 0x3c, 0x50 } };


DEBUG_DECLARE_INSTANCE_COUNTER(CRoleRootData);

CRoleRootData::
CRoleRootData(CComponentDataObject* pComponentData)
              :CRootData(pComponentData),
              m_bDeveloperMode(FALSE),
              m_dwADState(AD_STATE_UNKNOWN)
{
    TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CRoleRootData)

    DEBUG_INCREMENT_INSTANCE_COUNTER(CRoleRootData);

    m_bAdvancedView = FALSE;
    m_pColumnSet = NULL;
}

CRoleRootData::~CRoleRootData()
{
    TRACE_DESTRUCTOR_EX(DEB_SNAPIN, CRoleRootData)
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRoleRootData);
}

DWORD
CRoleRootData::
GetADState()
{
    if( m_dwADState == AD_STATE_UNKNOWN)
    {
        if(m_ADInfo.GetRootDSE() == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN))
            m_dwADState = AD_NOT_AVAILABLE;
        else
            m_dwADState = AD_AVAILABLE;
    }
    return m_dwADState;
}


//+----------------------------------------------------------------------------
//  Function:OnOpenPolicyStore   
//  Synopsis:Invokes the Dialog box for creating new policy store or
//               opening the existing store
//  Arguments:bNew If TRUE show Dialog box for new Policy Store else
//                show dialog box for opening exisitng policy store
//  Returns:    
//-----------------------------------------------------------------------------
void
CRoleRootData
::OnOpenPolicyStore(BOOL bNew)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if(bNew)
    {
        CNewAuthorizationStoreDlg dlgNewAuthzStore(GetComponentDataObject());
        dlgNewAuthzStore.DoModal();
    }
    else
    {
        COpenAuthorizationStoreDlg dlgOpenAuthzStore(GetComponentDataObject());
        dlgOpenAuthzStore.DoModal();
    }
}

void
CRoleRootData::
OnOptions()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,OnOptions)
    BOOL bCurrentMode = m_bDeveloperMode;
    COptionDlg dlgOptions(m_bDeveloperMode);
    dlgOptions.DoModal();
    //Mode has been changed, refresh the screen
    if(bCurrentMode != m_bDeveloperMode)
    {
        //Call Refresh on Root which will refresh
        //all adminmanager objects under it.
        CNodeList tempNodeList;
        tempNodeList.AddTail(this);            
        OnRefresh(GetComponentDataObject(), &tempNodeList);
    }
}

HRESULT 
CRoleRootData::OnCommand(long nCommandID, 
                        DATA_OBJECT_TYPES,
                        CComponentDataObject* /*pComponentData*/,
                        CNodeList* pNodeList)
{
    
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,OnCommand)
    
    //
    // Multiple selection not allowed
    //
    if (pNodeList->GetCount() > 1) 
    {
        return E_FAIL;
    }

    switch (nCommandID)
    {
        case IDM_ROOT_OPEN_STORE:
            {
                OnOpenPolicyStore(FALSE);
            }
            break;
        case IDM_ROOT_NEW_STORE:
            {
                OnOpenPolicyStore(TRUE);
            }
            break;
        case IDM_ROOT_OPTIONS:
            {
                OnOptions();
            }
            break;
        default:
            ASSERT(FALSE); 
            return E_FAIL;
    }
//  pComponentData->UpdateResultPaneView(this);
    return S_OK;
}

BOOL 
CRoleRootData::
OnRefresh(CComponentDataObject* pComponentData,
          CNodeList* pNodeList)
{

    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,OnRefresh)

    //This is the refresh for root node. There should never 
    //be multiple selection
    if (pNodeList->GetCount() != 1) // single selection
    {
        return FALSE;
    }
    
    //Get all the container child of Root Object and refresh them.
    CNodeList * pChildNodeList = GetContainerChildList();
    if(!pChildNodeList || pChildNodeList->IsEmpty())
    {
        return FALSE;
    }

    BOOL bReturn = TRUE;
    POSITION pos = pChildNodeList->GetHeadPosition();
    while (pos != NULL)
    {
        CTreeNode* pChildNode = pNodeList->GetNext(pos);
        if(pChildNode)
        {
            //
            // Have each node refresh itself
            //
            CNodeList tempNodeList;
            tempNodeList.AddTail(pChildNode);
            
            if (!pChildNode->OnRefresh(pComponentData, &tempNodeList))
            {
                bReturn = FALSE;
            }
        }
    }


    return bReturn;
}


BOOL
CRoleRootData::OnSetRefreshVerbState(DATA_OBJECT_TYPES /*type*/, 
                                     BOOL* pbHide,
                                     CNodeList* /*pNodeList*/)
{

    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,OnSetRefreshVerbState)
    *pbHide = FALSE;
    return TRUE;
}

BOOL 
CRoleRootData::OnEnumerate(CComponentDataObject* /*pComponentData*/, BOOL)
{
    TRACE_METHOD_EX(DEB_SNAPIN, CRoleRootData, OnEnumerate)
    return TRUE; // there are already children, add them to the UI now
}

HRESULT 
CRoleRootData::IsDirty()
{
    TRACE_METHOD_EX(DEB_SNAPIN, CRoleRootData, IsDirty)

    return CRootData::IsDirty();
}

#define AUTHORIZATION_MANAGER_STREAM_VERSION ((DWORD)0x07)

const CString&
CRoleRootData::
GetXMLStorePath()
{
    //default is current working directory
    if(m_strXMLStoreDirectory.IsEmpty())
    {
        GetCurrentWorkingDirectory(m_strXMLStoreDirectory);
    }

    return m_strXMLStoreDirectory;
}
    
void
CRoleRootData::
SetXMLStorePath(const CString& strXMLStorePath)
{
    m_strXMLStoreDirectory = strXMLStorePath;
}


HRESULT 
CRoleRootData::Load(IStream* pStm)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,Load)
    // assume never get multiple loads
    if(!m_containerChildList.IsEmpty() || !m_leafChildList.IsEmpty())
        return E_FAIL;

    //if Options are specified at commandline, we don't
    //read console file
    if(commandLineOptions.CommandLineOptionSpecified())
    {
        return OpenAdminManager(NULL,
                                TRUE,
                                commandLineOptions.GetStoreType(),
                                commandLineOptions.GetStoreName(),
                                GetXMLStorePath(),
                                this,
                                GetComponentDataObject());
    }

    HRESULT hr = S_OK;
    
    do
    {
        ULONG cbRead;
        // read the version ##
        DWORD dwVersion;
        hr = pStm->Read((void*)&dwVersion,sizeof(DWORD), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cbRead == sizeof(DWORD));
        
        if (dwVersion != AUTHORIZATION_MANAGER_STREAM_VERSION)
        {
            Dbg(DEB_SNAPIN,"Invaild version number\n");
            hr = E_FAIL;
            break;
        }

        // read authorization manager mode
        hr = pStm->Read((void*)&m_bDeveloperMode,sizeof(BOOL), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(BOOL));

        //read xml store path
    
        //Read the Length of XML Store path
        INT nLenXMLStorePath;
        hr = pStm->Read((void*)&nLenXMLStorePath,sizeof(INT), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(INT));

        //Read XML Store path
        if(nLenXMLStorePath > 0)
        {
            LPWSTR pszBuffer = (LPWSTR)LocalAlloc(LPTR,nLenXMLStorePath*sizeof(WCHAR));
            if(!pszBuffer)
                return E_OUTOFMEMORY;

            hr = pStm->Read((void*)pszBuffer,sizeof(WCHAR)*nLenXMLStorePath, &cbRead);
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(cbRead == sizeof(WCHAR)*nLenXMLStorePath);

            m_strXMLStoreDirectory = pszBuffer;
            LocalFree(pszBuffer);
        }

        UINT nCount;
        // load the list of Authorization Managers 
        hr = pStm->Read((void*)&nCount,sizeof(UINT), &cbRead);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbRead == sizeof(UINT));

        CComponentDataObject* pComponentData = GetComponentDataObject();
        for (int k=0; k< (int)nCount; k++)
        {
            hr = CAdminManagerNode::CreateFromStream(pStm,this,pComponentData);
            BREAK_ON_FAIL_HRESULT(hr);
        }
    }while(0);

    return hr;
}

HRESULT 
CRoleRootData::Save(IStream* pStm, BOOL fClearDirty)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData, Save)

    UINT nCount;
    ULONG cbWrite;

    HRESULT hr = S_OK;
    do
    {    
        // write the version ##
        DWORD dwVersion = AUTHORIZATION_MANAGER_STREAM_VERSION;
        hr = pStm->Write((void*)&dwVersion, sizeof(DWORD),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(DWORD));

        // save authorization manager mode
        hr = pStm->Write((void*)&m_bDeveloperMode, sizeof(BOOL),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(BOOL));

        //
        //Save the xml store path 
        //

        //Save the length of xml store path
        INT nLenXMLStorePath = m_strXMLStoreDirectory.GetLength();
        if(nLenXMLStorePath)
            nLenXMLStorePath++;     //save null also

        hr = pStm->Write((void*)&nLenXMLStorePath, sizeof(INT),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(INT));


        if(nLenXMLStorePath)
        {
            //save the xml store path
            hr = pStm->Write((void*)(LPCTSTR)m_strXMLStoreDirectory, sizeof(WCHAR)*nLenXMLStorePath,&cbWrite);
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(cbWrite == sizeof(WCHAR)*nLenXMLStorePath);
        }
    

        // write # of Authorization Manager Loaded
        nCount = (UINT)m_containerChildList.GetCount();
        hr = pStm->Write((void*)&nCount, sizeof(UINT),&cbWrite);
        BREAK_ON_FAIL_HRESULT(hr);
        ASSERT(cbWrite == sizeof(UINT));

        // loop through the list of servers and serialize them
        POSITION pos;
        for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
        {
            CAdminManagerNode* pAdminManagerNode = 
                (CAdminManagerNode*)m_containerChildList.GetNext(pos);
        
            hr = pAdminManagerNode->SaveToStream(pStm);
            BREAK_ON_FAIL_HRESULT(hr);
        }
    }while(0);

    if (fClearDirty)
        SetDirtyFlag(FALSE);
    return hr;
}

CColumnSet* 
CRoleRootData::GetColumnSet()
{
    TRACE_METHOD_EX(DEB_SNAPIN, CRoleRootData, GetColumnSet);

    if (m_pColumnSet == NULL)
   {
        m_pColumnSet = ((CRoleComponentDataObject*)GetComponentDataObject())->GetColumnSet(L"---Default Column Set---");
    }
   return m_pColumnSet;
}


HRESULT 
CRoleRootData::GetResultViewType(CComponentDataObject*, 
                                LPOLESTR *ppViewType, 
                                long *pViewOptions)
{

    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,GetResultViewType)

    if(!ppViewType || !pViewOptions)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }
    
    HRESULT hr = S_FALSE;

    if (m_containerChildList.IsEmpty() && m_leafChildList.IsEmpty())
    {
        Dbg(DEB_SNAPIN,"Result View Type is MessageView\n");
    
        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        LPOLESTR psz = NULL;
        StringFromCLSID(CLSID_MessageView, &psz);

        USES_CONVERSION;

        if (psz != NULL)
        {
            *ppViewType = psz;
            hr = S_OK;
        }   
    }
    else
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
        hr = S_FALSE;
    }
    return hr;
}

HRESULT 
CRoleRootData::OnShow(LPCONSOLE lpConsole)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,OnShow)

    CComPtr<IUnknown> spUnknown;
    CComPtr<IMessageView> spMessageView;

    HRESULT hr = lpConsole->QueryResultView(&spUnknown);
    if (FAILED(hr))
        return S_OK;

    hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
    if (SUCCEEDED(hr))
    {
        //
        // Load and set the title text of the message view
        //
        CString szTitle;
        VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NO_POLICY_STORE_TITLE));
        spMessageView->SetTitleText(szTitle);

        //
        // Load and set the body text of the message view
        //
        CString szMessage;
        VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NO_POLICY_STORE_MESSAGE));
        spMessageView->SetBodyText(szMessage);

        spMessageView->SetIcon(Icon_Error);
    }

    return S_OK;
}


BOOL 
CRoleRootData::CanCloseSheets()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,CanCloseSheets)
    return TRUE;
}


LPCONTEXTMENUITEM2 
CRoleRootData::OnGetContextMenuItemTable()
{ 
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData, OnGetContextMenuItemTable)

    return CRootDataMenuHolder::GetContextMenuItem();
                
}


BOOL
CRoleRootData::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2, 
                             long*)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,OnAddMenuItem)
    if(pContextMenuItem2->lCommandID == IDM_ROOT_NEW_STORE)
    {
        if(IsDeveloperMode())
                return TRUE;
        else
            return FALSE;
    }

    return TRUE;
}

BOOL CRoleRootData::HasPropertyPages(DATA_OBJECT_TYPES, 
                                                 BOOL* pbHideVerb, 
                                                 CNodeList*)
{
    TRACE_METHOD_EX(DEB_SNAPIN,CRoleRootData,HasPropertyPages)
    
    *pbHideVerb = TRUE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\sidcache.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       sidcache.cpp
//
//  Contents:   
//
//  History:    
//----------------------------------------------------------------------------

#include "headers.h"

const struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth[1]; // we currently need at most 2 subauthorities
} g_StaticSids[] =
{
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ADMINS}       },
};

#define IsAliasSid(pSid)                EqualPrefixSid(pSid, (PSID)&g_StaticSids[0])

 
/******************************************************************************
Class:	SID_CACHE_ENTRY
Purpose: Contains info for a single security principle
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(SID_CACHE_ENTRY);

SID_CACHE_ENTRY::
SID_CACHE_ENTRY(PSID pSid)
					:m_SidType(SidTypeUnknown)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(SID_CACHE_ENTRY);
	ASSERT(pSid);
	DWORD dwLen = GetLengthSid(pSid);
	m_pSid = new BYTE[dwLen];
	ASSERT(m_pSid);
	CopySid(dwLen,m_pSid,pSid);
	ConvertSidToStringSid(m_pSid,&m_strSid);
	m_strType.LoadString(IDS_TYPE_UNKNOWN);
	m_strNameToDisplay = m_strSid;
	m_SidType = SidTypeUnknown;
}

SID_CACHE_ENTRY::
~SID_CACHE_ENTRY()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(SID_CACHE_ENTRY);
	delete[] m_pSid;
}

	
VOID 
SID_CACHE_ENTRY::
AddNameAndType(IN SID_NAME_USE SidType, 
			   const CString& strAccountName,
			   const CString& strLogonName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//Empty the m_strNameToDisplay which was made using
	//ealier values of strAccountName and strLogonName
	m_strNameToDisplay.Empty();
	m_strType.Empty();
	m_SidType = SidType;
	m_strAccountName = strAccountName;
	m_strLogonName = strLogonName;

	//
	//Set the Display Name
	//
	if(m_SidType == SidTypeDeletedAccount ||
	   m_SidType == SidTypeInvalid ||
	   m_SidType == SidTypeUnknown)
	{
		UINT idFormat;
		if(m_SidType == SidTypeDeletedAccount)
			idFormat = IDS_SID_DELETED;
		if(m_SidType == SidTypeInvalid)
			idFormat = IDS_SID_INVALID;
		if(m_SidType == SidTypeUnknown)
			idFormat = IDS_SID_UNKNOWN;
		
		FormatString(m_strNameToDisplay,idFormat,LPCTSTR(m_strSid));
	}
	else if(!m_strAccountName.IsEmpty())
	{
		if(!m_strLogonName.IsEmpty())
		{
			//Both the names are present. 
			FormatString(m_strNameToDisplay, 
						 IDS_NT_USER_FORMAT,
						 (LPCTSTR)m_strAccountName,
						 (LPCTSTR)m_strLogonName);
			
		}
		else
		{
			m_strNameToDisplay = m_strAccountName;
		}
	}
	else
	{	
		//Just return the sid in string format
		m_SidType = SidTypeUnknown;
		m_strNameToDisplay = m_strSid;
	}

	//
	//Set Sid Type String
	//
	if(m_SidType == SidTypeDeletedAccount ||
	   m_SidType == SidTypeInvalid ||
	   m_SidType == SidTypeUnknown)
	{
		m_strType.LoadString(IDS_TYPE_UNKNOWN);
	}
	else if(m_SidType == SidTypeUser)
	{
		m_strType.LoadString(IDS_TYPE_WINDOWS_USER);
	}
	else if(m_SidType == SidTypeComputer)
	{
		m_strType.LoadString(IDS_TYPE_WINDOWS_COMPUTER);
	}
	else	//Assume everything else is group
	{
		m_strType.LoadString(IDS_TYPE_WINDOWS_GROUP);
	}
}



/******************************************************************************
Class:	CMachineInfo
Purpose: Contains all the info for machine.
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CMachineInfo);
CMachineInfo::
CMachineInfo():m_bIsStandAlone(TRUE),
				   m_bIsDC(FALSE)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(CMachineInfo);
}

CMachineInfo::
~CMachineInfo()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CMachineInfo);
}

//+----------------------------------------------------------------------------
//  Function:InitializeMacineConfiguration  
//  Synopsis:Get the information about TargetComputer's conficguration   
//-----------------------------------------------------------------------------
VOID
CMachineInfo::
InitializeMacineConfiguration(IN const CString& strTargetComputerName)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CMachineInfo,InitializeMacineConfiguration)
		
	//
	//Initialize the values to default
	//
	m_strTargetComputerName = strTargetComputerName;
	m_bIsStandAlone = TRUE;
	m_strDCName.Empty();
	m_bIsDC = FALSE;
	m_strTargetDomainFlat.Empty();
	m_strTargetDomainDNS.Empty();
	
	HRESULT                             hr = S_OK;
	ULONG                               ulResult;
	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
	PDOMAIN_CONTROLLER_INFO             pdci = NULL;
	
	do
	{
		PCWSTR pwzMachine = strTargetComputerName;
		
			
		ulResult = DsRoleGetPrimaryDomainInformation(pwzMachine,
			DsRolePrimaryDomainInfoBasic,
			(PBYTE *)&pDsRole);
		
		if (ulResult != NO_ERROR)
		{
			DBG_OUT_LRESULT(ulResult);
			break;
		}
		
		if(!pDsRole)
		{
			//We should never reach here, but sadly DsRoleGetPrimaryDomainInformation
			//sometimes succeeds but pDsRole is null. 
			ASSERT(FALSE);
			break;
		}
		
		Dbg(DEB_SNAPIN, "DsRoleGetPrimaryDomainInformation returned:\n");
		Dbg(DEB_SNAPIN, "DomainNameFlat: %ws\n", CHECK_NULL(pDsRole->DomainNameFlat));
		Dbg(DEB_SNAPIN, "DomainNameDns: %ws\n", CHECK_NULL(pDsRole->DomainNameDns));
		Dbg(DEB_SNAPIN, "DomainForestName: %ws\n", CHECK_NULL(pDsRole->DomainForestName));
		
		//
		// If machine is in a workgroup, we're done.
		//
		if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
			pDsRole->MachineRole == DsRole_RoleStandaloneServer)
		{
			Dbg(DEB_SNAPIN, "Target machine is not joined to a domain\n");
			m_bIsStandAlone = TRUE;
			m_bIsDC = FALSE;
			break;
		}
		
		//
		// Target Computer is joined to a domain
		//
		m_bIsStandAlone = FALSE;
		if (pDsRole->DomainNameFlat)
		{
			m_strTargetDomainFlat = pDsRole->DomainNameFlat;
		}
		if (pDsRole->DomainNameDns)
		{
			m_strTargetDomainDNS = pDsRole->DomainNameDns;
		}
		
		//
		// TargetComputer is Joined to a domain and is dc
		//
		if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
			pDsRole->MachineRole == DsRole_RoleBackupDomainController)
		{
			m_bIsDC = TRUE;
			m_strDCName = m_strTargetComputerName;
			break;
		}
		
		//
		//Target computer is Joined to domain and is not a DC.
		//Get a DC for the domain
		//
		PWSTR pwzDomainNameForDsGetDc;
		ULONG flDsGetDc = DS_DIRECTORY_SERVICE_PREFERRED;
		
		if (pDsRole->DomainNameDns)
		{
			pwzDomainNameForDsGetDc = pDsRole->DomainNameDns;
			flDsGetDc |= DS_IS_DNS_NAME;
			Dbg(DEB_TRACE,
				"DsGetDcName(Domain=%ws, flags=DS_IS_DNS_NAME | DS_DIRECTORY_SERVICE_PREFERRED)\n",
				CHECK_NULL(pwzDomainNameForDsGetDc));
		}
		else
		{
			pwzDomainNameForDsGetDc = pDsRole->DomainNameFlat;
			flDsGetDc |= DS_IS_FLAT_NAME;
			Dbg(DEB_TRACE,
				"DsGetDcName(Domain=%ws, flags=DS_IS_FLAT_NAME | DS_DIRECTORY_SERVICE_PREFERRED)\n",
				CHECK_NULL(pwzDomainNameForDsGetDc));
		}
		
		ulResult = DsGetDcName(NULL,  
			pwzDomainNameForDsGetDc,
			NULL,
			NULL,
			flDsGetDc,
			&pdci);
		
		if (ulResult != NO_ERROR)
		{
			Dbg(DEB_ERROR,
				"DsGetDcName for domain %ws returned %#x, Too bad don't have the dc name\n",
				pwzDomainNameForDsGetDc,
				ulResult);
			break;
		}
		
		ASSERT(pdci);
		
		m_strDCName = pdci->DomainControllerName;
    } while (0);
	
    if (pdci)
    {
        NetApiBufferFree(pdci);
    }
	
    if (pDsRole)
    {
        DsRoleFreeMemory(pDsRole);
    }
}

int
CopyUnicodeString(CString* pstrDest, PLSA_UNICODE_STRING pSrc)
{
    ULONG cchSrc;

    // If UNICODE, cchDest is size of destination buffer in chars
    // Else (MBCS) cchDest is size of destination buffer in bytes

    if (pstrDest == NULL )
        return 0;


    if (pSrc == NULL || pSrc->Buffer == NULL)
        return 0;

    // Get # of chars in source (not including NULL)
    cchSrc = pSrc->Length/sizeof(WCHAR);

    //
    // Note that pSrc->Buffer may not be NULL terminated so we can't just
    // call lstrcpynW with cchDest.  Also, if we call lstrcpynW with cchSrc,
    // it copies the correct # of chars, but then overwrites the last char
    // with NULL giving an incorrect result.  If we call lstrcpynW with
    // (cchSrc+1) it reads past the end of the buffer, which may fault (360251)
    // causing lstrcpynW's exception handler to return 0 without NULL-
    // terminating the resulting string.
    //
    // So let's just copy the bits.
    //
	 CString temp(pSrc->Buffer,cchSrc);

	*pstrDest = temp;
	return cchSrc;
}



VOID
GetAccountAndDomainName(int index,
								PLSA_TRANSLATED_NAME pTranslatedNames,
								PLSA_REFERENCED_DOMAIN_LIST pRefDomains,
								CString* pstrAccountName,
								CString* pstrDomainName,
								SID_NAME_USE* puse)
{
	PLSA_TRANSLATED_NAME pLsaName = &pTranslatedNames[index];
	PLSA_TRUST_INFORMATION pLsaDomain = NULL;

	// Get the referenced domain, if any
	if (pLsaName->DomainIndex >= 0 && pRefDomains)
	{
		pLsaDomain = &pRefDomains->Domains[pLsaName->DomainIndex];
	}

   CopyUnicodeString(pstrAccountName,&pLsaName->Name); 
         
	if (pLsaDomain)
	{
		CopyUnicodeString(pstrDomainName,&pLsaDomain->Name);
	}

	*puse = pLsaName->Use;
}


HRESULT
TranslateNameInternal(IN const CString&  strAccountName,
                      IN EXTENDED_NAME_FORMAT AccountNameFormat,
                      IN EXTENDED_NAME_FORMAT DesiredNameFormat,
                      OUT CString* pstrTranslatedName)
{
   if (!pstrTranslatedName)
	{
		ASSERT(pstrTranslatedName);
		return E_POINTER;
	}

	HRESULT hr = S_OK;
   
	//
   // cchTrans is static so that if a particular installation's
   // account names are really long, we'll not be resizing the
   // buffer for each account.
   //
   static ULONG cchTrans = MAX_PATH;
   ULONG cch = cchTrans;

   LPTSTR lpszTranslatedName = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
   if (lpszTranslatedName == NULL)
		return E_OUTOFMEMORY;

    *lpszTranslatedName = L'\0';

    //
    // TranslateName is delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        while(!::TranslateName(strAccountName,
                               AccountNameFormat,
                               DesiredNameFormat,
                               lpszTranslatedName,
                               &cch))
        {
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
				LocalFree(lpszTranslatedName);
				lpszTranslatedName = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
                if (!lpszTranslatedName)
				{	
					hr = E_OUTOFMEMORY;
					break;
				}

                *lpszTranslatedName = L'\0';
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }

        cchTrans = max(cch, cchTrans);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
    }



    if (FAILED(hr))
    {
		 if(lpszTranslatedName)
		 {	
			 LocalFree(lpszTranslatedName);
		 }
    }
	 else
	 {
		 *pstrTranslatedName = lpszTranslatedName;
	 }
	
	return hr;
}





#define DSOP_FILTER_COMMON1 ( DSOP_FILTER_INCLUDE_ADVANCED_VIEW \
                            | DSOP_FILTER_USERS                 \
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE   \
                            | DSOP_FILTER_GLOBAL_GROUPS_SE      \
                            | DSOP_FILTER_COMPUTERS             \
                            )
#define DSOP_FILTER_COMMON2 ( DSOP_FILTER_COMMON1               \
                            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS \
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE\
                            )
#define DSOP_FILTER_COMMON3 ( DSOP_FILTER_COMMON2               \
                            | DSOP_FILTER_BUILTIN_GROUPS        \
                            )

#define DSOP_FILTER_DL_COMMON1      ( DSOP_DOWNLEVEL_FILTER_USERS           \
                                    | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS   \
                                    )

#define DSOP_FILTER_DL_COMMON2      ( DSOP_FILTER_DL_COMMON1                    \
                                    | DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS  \
                                    )

#define DSOP_FILTER_DL_COMMON3      ( DSOP_FILTER_DL_COMMON2                \
                                    | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS    \
                                    )
// Same as DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS, except no CREATOR flags.
// Note that we need to keep this in sync with any object picker changes.
#define DSOP_FILTER_DL_WELLKNOWN    ( DSOP_DOWNLEVEL_FILTER_WORLD               \
                                    | DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER  \
                                    | DSOP_DOWNLEVEL_FILTER_ANONYMOUS           \
                                    | DSOP_DOWNLEVEL_FILTER_BATCH               \
                                    | DSOP_DOWNLEVEL_FILTER_DIALUP              \
                                    | DSOP_DOWNLEVEL_FILTER_INTERACTIVE         \
                                    | DSOP_DOWNLEVEL_FILTER_NETWORK             \
                                    | DSOP_DOWNLEVEL_FILTER_SERVICE             \
                                    | DSOP_DOWNLEVEL_FILTER_SYSTEM              \
                                    | DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER     \
                                    )


#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f|DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

// The domain to which the target computer is joined.
// Make 2 scopes, one for uplevel domains, the other for downlevel.
#define JOINED_DOMAIN_SCOPE(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON2 & ~(DSOP_FILTER_UNIVERSAL_GROUPS_SE|DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE)),DSOP_FILTER_COMMON2,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON2)

// The domain for which the target computer is a Domain Controller.
// Make 2 scopes, one for uplevel domains, the other for downlevel.
#define JOINED_DOMAIN_SCOPE_DC(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON3 & ~DSOP_FILTER_UNIVERSAL_GROUPS_SE),DSOP_FILTER_COMMON3,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

// Target computer scope.  Computer scopes are always treated as
// downlevel (i.e., they use the WinNT provider).
#define TARGET_COMPUTER_SCOPE(f)\
DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

// The Global Catalog
#define GLOBAL_CATALOG_SCOPE(f) \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_GLOBAL_CATALOG,(f),DSOP_FILTER_COMMON1|DSOP_FILTER_WELL_KNOWN_PRINCIPALS,0,0,0)

// The domains in the same forest (enterprise) as the domain to which
// the target machine is joined.  Note these can only be DS-aware
#define ENTERPRISE_SCOPE(f)     \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,(f),DSOP_FILTER_COMMON1,0,0,0)

// Domains external to the enterprise but trusted directly by the
// domain to which the target machine is joined.
#define EXTERNAL_SCOPE(f)       \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN|DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,\
    (f),DSOP_FILTER_COMMON1,0,0,DSOP_DOWNLEVEL_FILTER_USERS|DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS)

// Workgroup scope.  Only valid if the target computer is not joined
// to a domain.
#define WORKGROUP_SCOPE(f)      \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_WORKGROUP,(f),0,0,0, DSOP_FILTER_DL_COMMON1|DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS )

//
// Array of Default Scopes
//
static const DSOP_SCOPE_INIT_INFO g_aDefaultScopes[] =
{
    JOINED_DOMAIN_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    TARGET_COMPUTER_SCOPE(0),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
// Same as above, but without the Target Computer
// Used when the target is a Domain Controller
//
static const DSOP_SCOPE_INIT_INFO g_aDCScopes[] =
{
    JOINED_DOMAIN_SCOPE_DC(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
// Array of scopes for standalone machines
//
static const DSOP_SCOPE_INIT_INFO g_aStandAloneScopes[] =
{
//
//On Standalone machine Both User And Groups are selected by default
//
    TARGET_COMPUTER_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS),
};

//
// Attributes that we want the Object Picker to retrieve
//
static const LPCTSTR g_aszOPAttributes[] =
{
    TEXT("ObjectSid"),
};






/******************************************************************************
Class:	CSidHandler
Purpose: class for handling tasks related to selecting windows users, 
converting sids to name etc.
******************************************************************************/
DEBUG_DECLARE_INSTANCE_COUNTER(CSidHandler);

CSidHandler::
CSidHandler(CMachineInfo* pMachineInfo)
				:m_pMachineInfo(pMachineInfo),
				m_bObjectPickerInitialized(FALSE)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(CSidHandler);
	InitializeCriticalSection(&m_csSidHandlerLock);
	InitializeCriticalSection(&m_csSidCacheLock);
}

CSidHandler::~CSidHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CSidHandler);
	delete m_pMachineInfo;
	//Remove itesm from the map
	LockSidHandler();
	for (SidCacheMap::iterator it = m_mapSidCache.begin();
		 it != m_mapSidCache.end();
		 ++it)
	{
		delete (*it).second;
	}
	UnlockSidHandler();
	DeleteCriticalSection(&m_csSidCacheLock);
	DeleteCriticalSection(&m_csSidHandlerLock);
}

PSID_CACHE_ENTRY 
CSidHandler::
GetEntryFromCache(PSID pSid)
{
	PSID_CACHE_ENTRY pSidCache = NULL;
	LockSidHandler();

	//Check if item in the cache
	CString strSid;
	ConvertSidToStringSid(pSid,&strSid);

	SidCacheMap::iterator it = m_mapSidCache.find(&strSid);
	if(it != m_mapSidCache.end())
		pSidCache = (*it).second;

	if(!pSidCache)
	{
		//No in the cache Create a new entry and add to the cache
		pSidCache = new SID_CACHE_ENTRY(pSid);
		if(pSidCache)
		{
			m_mapSidCache.insert(pair<const CString*,PSID_CACHE_ENTRY>(&(pSidCache->GetStringSid()),pSidCache));			
		}
	}
	UnlockSidHandler();
	return pSidCache;
}

//+----------------------------------------------------------------------------
//  Synopsis: CoCreateInstance ObjectPikcer
//-----------------------------------------------------------------------------
HRESULT
CSidHandler::
GetObjectPicker()
{
	LockSidHandler();
	TRACE_METHOD_EX(DEB_SNAPIN,CSidHandler,GetObjectPicker)
	HRESULT hr = S_OK;
	if (!m_spDsObjectPicker)
	{
		hr = CoCreateInstance(CLSID_DsObjectPicker,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IDsObjectPicker,
							  (LPVOID*)&m_spDsObjectPicker);
		CHECK_HRESULT(hr);
	}
	UnlockSidHandler();
	return hr;
}

//+----------------------------------------------------------------------------
//  Function: InitObjectPicker  
//  Synopsis: Initializes the object picker. This needs to be done once in 
//				  lifetime  
//-----------------------------------------------------------------------------
HRESULT
CSidHandler::InitObjectPicker()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CSidHandler,InitObjectPicker)

	HRESULT hr = S_OK;
	hr = GetObjectPicker();
	if(FAILED(hr))
		return hr;        

	LockSidHandler();
	do
	{
		if(m_bObjectPickerInitialized)
			break;
		
		DSOP_INIT_INFO InitInfo;
		InitInfo.cbSize = sizeof(InitInfo);   
		InitInfo.flOptions = DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK | DSOP_FLAG_MULTISELECT;

		//Select the appropriate scopes
		PCDSOP_SCOPE_INIT_INFO pScopes;
		ULONG cScopes;
		if(m_pMachineInfo->IsStandAlone())
		{
			cScopes = ARRAYLEN(g_aStandAloneScopes);
			pScopes = g_aStandAloneScopes;
		}
		else if(m_pMachineInfo->IsDC())
		{
			cScopes = ARRAYLEN(g_aDCScopes);
			pScopes = g_aDCScopes;
		}
		else
		{
			pScopes = g_aDefaultScopes;
			cScopes = ARRAYLEN(g_aDefaultScopes);
		}



		InitInfo.pwzTargetComputer = m_pMachineInfo->GetMachineName();
		InitInfo.cDsScopeInfos = cScopes;
		
		InitInfo.aDsScopeInfos = (PDSOP_SCOPE_INIT_INFO)LocalAlloc(LPTR, sizeof(*pScopes)*cScopes);
		if (!InitInfo.aDsScopeInfos)
		{
			hr = E_OUTOFMEMORY;
			break;
		}

		CopyMemory(InitInfo.aDsScopeInfos, pScopes, sizeof(*pScopes)*cScopes);
		InitInfo.cAttributesToFetch = ARRAYLEN(g_aszOPAttributes);
		InitInfo.apwzAttributeNames = (LPCTSTR*)g_aszOPAttributes;
		
		if (m_pMachineInfo->IsDC())
		{
			for (ULONG i = 0; i < cScopes; i++)
			{
				// Set the DC name if appropriate
				if(InitInfo.aDsScopeInfos[i].flType & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN)
				{
					InitInfo.aDsScopeInfos[i].pwzDcName = InitInfo.pwzTargetComputer;
				}
			}
		}
		
		//Initialize the object picker
		hr = m_spDsObjectPicker->Initialize(&InitInfo);
		
		if (SUCCEEDED(hr))
		{
			m_bObjectPickerInitialized = TRUE;   
		}
		
		if(InitInfo.aDsScopeInfos)
			LocalFree(InitInfo.aDsScopeInfos);

	}while(0);

	UnlockSidHandler();
	
	return hr;
}

//+----------------------------------------------------------------------------
//  Synopsis: Pops up object pikcer. Function also does the sidlookop for 
//				  objects selected. Information is returned in listSidCacheEntry
//-----------------------------------------------------------------------------

HRESULT
CSidHandler::	
GetUserGroup(IN HWND hDlg, 					 
				 IN CBaseAz* pOwnerAz,
				 OUT CList<CBaseAz*,CBaseAz*>& listWindowsGroups)
{
	if(!pOwnerAz)
	{
		ASSERT(pOwnerAz);
		return E_POINTER;
	}

	TRACE_METHOD_EX(DEB_SNAPIN,CSidHandler,GetUserGroup)

   HRESULT hr;
   LPDATAOBJECT pdoSelection = NULL;
   STGMEDIUM medium = {0};
   FORMATETC fe = { (CLIPFORMAT)g_cfDsSelectionList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
   PDS_SELECTION_LIST pDsSelList = NULL;
 	do
	{

		// Create and initialize the Object Picker object
		hr = InitObjectPicker();
		if (FAILED(hr))
			return hr;

		// Bring up the object picker dialog
		hr = m_spDsObjectPicker->InvokeDialog(hDlg, &pdoSelection);
		BREAK_ON_FAIL_HRESULT(hr);

		//User Pressed cancel
		if (S_FALSE == hr)
		{
			hr = S_OK;
			break;
		}

		hr = pdoSelection->GetData(&fe, &medium);
		BREAK_ON_FAIL_HRESULT(hr);

		pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);
		if (!pDsSelList)
		{
			hr = E_FAIL;
			BREAK_ON_FAIL_HRESULT(hr);
		}
		
		CList<SID_CACHE_ENTRY*,SID_CACHE_ENTRY*> listSidCacheEntry;
		CList<SID_CACHE_ENTRY*,SID_CACHE_ENTRY*> listUnresolvedSidCacheEntry;
		

		//Get the listof sidcache entries from pDsSelList
		hr = GetSidCacheListFromOPOutput(pDsSelList,
										 listSidCacheEntry,
										 listUnresolvedSidCacheEntry);
		BREAK_ON_FAIL_HRESULT(hr);


		//Resolve the sids not resolved in listSidCacheEntry
		LookupSidsHelper(listUnresolvedSidCacheEntry,
						 m_pMachineInfo->GetMachineName(),
						 m_pMachineInfo->IsStandAlone(),
						 m_pMachineInfo->IsDC(),
						 FALSE);
		
		POSITION pos = listSidCacheEntry.GetHeadPosition();
		for( int i = 0; i < listSidCacheEntry.GetCount(); ++i)
		{
			SID_CACHE_ENTRY* pSidCacheEntry = listSidCacheEntry.GetNext(pos);
			CSidCacheAz* pSidCacheAz = new CSidCacheAz(pSidCacheEntry,
													   pOwnerAz);
			if(!pSidCacheAz)
			{
				hr = E_OUTOFMEMORY;
				break;
			}
			listWindowsGroups.AddTail(pSidCacheAz);
		}
	}while(0);
   
	if (pDsSelList)
		GlobalUnlock(medium.hGlobal);

	ReleaseStgMedium(&medium);
	
	if(pdoSelection)
		pdoSelection->Release();

	return hr;
}

//+----------------------------------------------------------------------------
//  Function:LookupSidsHelper   
//  Synopsis:Calls LsaLookupSid for sids in listSids. First it tries on 
//				 strServerName machine and next it tries on DC( if possible).
//  Arguments:listSidCacheEntry
//  Returns:    
//-----------------------------------------------------------------------------
VOID
CSidHandler::
LookupSidsHelper(IN OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listSidCacheEntry,
				 IN const CString& strServerName,
				 IN BOOL bStandAlone,
				 IN BOOL bIsDC,
				 IN BOOL bSecondTry)
{
	TRACE_METHOD_EX(DEB_SNAPIN,CSidHandler,LookupSidsHelper)
	PLSA_REFERENCED_DOMAIN_LIST pRefDomains = NULL;
    PLSA_TRANSLATED_NAME pTranslatedNames = NULL;
	LSA_HANDLE hlsa = NULL;
	CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY> listUnknownSids;
	PSID *ppSid = NULL;

	if(!listSidCacheEntry.GetCount())
		return;

	do
	{
		//
		//Open LsaConnection
		//
		hlsa = GetLSAConnection(strServerName, 
										POLICY_LOOKUP_NAMES);
		if (NULL == hlsa && 
			 !strServerName.IsEmpty() && 
			 !bSecondTry)
		{      
			CString strLocalMachine = L"";
			hlsa = GetLSAConnection(strLocalMachine, POLICY_LOOKUP_NAMES);
		}
   
		if (hlsa == NULL)
		{
			break;
		}
		//
		//Now we have LSA Connection
		//Do LookupSids
		//	
		int cSids = (int)listSidCacheEntry.GetCount();
		ppSid = new PSID[cSids];
		if(!ppSid)
		{
			break;
		}
		
		POSITION pos = listSidCacheEntry.GetHeadPosition();
		for (int i=0;i < cSids; i++)
		{
			PSID_CACHE_ENTRY pSidCacheEntry = listSidCacheEntry.GetNext(pos);
			ppSid[i] = pSidCacheEntry->GetSid();
		}


										 
		DWORD dwStatus = 0;
		

		dwStatus = LsaLookupSids(hlsa,
								cSids,
								ppSid,
								&pRefDomains,
								&pTranslatedNames);

		if (STATUS_SUCCESS == dwStatus || 
			STATUS_SOME_NOT_MAPPED == dwStatus ||
			STATUS_NONE_MAPPED == dwStatus)
		{
			ASSERT(pTranslatedNames);
			ASSERT(pRefDomains);

			//
			// Build cache entries with NT4 style names
			//
			pos = listSidCacheEntry.GetHeadPosition();
			for (int i = 0; i < cSids; i++)
			{
				PSID_CACHE_ENTRY pSidCacheEntry = listSidCacheEntry.GetNext(pos);
				PSID pSid =  pSidCacheEntry->GetSid();
				BOOL bNoCache = FALSE;

				CString strAccountName;
				CString strDomainName;
				SID_NAME_USE sid_name_use;
				GetAccountAndDomainName(i,
										pTranslatedNames,
										pRefDomains,
										&strAccountName,
										&strDomainName,
										&sid_name_use);
			
				CString strLogonName;
				//
				// Build NT4 "domain\user" style name
				//
				if (!strDomainName.IsEmpty() && !strAccountName.IsEmpty())
				{
					 strLogonName  = strDomainName;
					 strLogonName += L"\\";
					 strLogonName += strAccountName;
				}

				switch (sid_name_use)
				{
					case SidTypeUser:            
					{
						if(!bStandAlone)
						{
							// Get "User Principal Name" etc.
							CString strNewLogonName;
							CString strNewAccountName;
							GetUserFriendlyName(strLogonName,
												&strNewLogonName,
												&strNewAccountName);
							if (!strNewLogonName.IsEmpty())
								strLogonName = strNewLogonName;
							if (!strNewAccountName.IsEmpty())
								strAccountName = strNewAccountName;
						}
						break;
					}
					case SidTypeGroup:           
					case SidTypeDomain:          
						break;
					case SidTypeAlias:           
					{
						if (!IsAliasSid(pSid))
						{
							sid_name_use = SidTypeGroup;
							break;
						}
						if(!m_pMachineInfo->GetTargetDomainFlat().IsEmpty() && 
							!strAccountName.IsEmpty())
						{
							strLogonName = m_pMachineInfo->GetTargetDomainFlat();
							strLogonName += L"\\";
							strLogonName += strAccountName;
						}
						break;
					}
					// else Fall Through
					case SidTypeWellKnownGroup:    
					{
						// No logon name for these
						strLogonName.Empty();
						break;
					}
					case SidTypeDeletedAccount: 
					case SidTypeInvalid:         // 7
						break;
					case SidTypeUnknown:         // 8
					{
						// Some SIDs can only be looked up on a DC, so
						// if pszServer is not a DC, remember them and
						// look them up on a DC after this loop is done.
						if (!bSecondTry && !bStandAlone && !bIsDC && !(m_pMachineInfo->GetDCName()).IsEmpty())
						{
							//Add to unknown list
							listUnknownSids.AddTail(pSidCacheEntry);
							bNoCache = TRUE;
						}
						break;
					}
					case SidTypeComputer:         // 9
					{
					//	TODO
					// Strip the trailing '$'
						break;
					}
				}

				if (!bNoCache)
				{
					//Only one sidcahce entry per sid chache handler can
					//be updated at a time. Which is fine.
					LockSidCacheEntry();
					pSidCacheEntry->AddNameAndType(sid_name_use,
												   strAccountName, 
												   strLogonName);
					UnlockSidCacheEntry();
				}

			}
		}

	}while(0);
   // Cleanup
    if(pTranslatedNames)
		LsaFreeMemory(pTranslatedNames);
    if(pRefDomains)
       LsaFreeMemory(pRefDomains);
    if(hlsa)
		LsaClose(hlsa);
	if(ppSid)
		delete[] ppSid;


	if (!listUnknownSids.IsEmpty())
   {
      //
      // Some (or all) SIDs were unknown on the target machine,
      // try a DC for the target machine's primary domain.
      //
      // This typically happens for certain Alias SIDs, such
      // as Print Operators and System Operators, for which LSA
      // only returns names if the lookup is done on a DC.
      //
		LookupSidsHelper(listUnknownSids,
						 m_pMachineInfo->GetDCName(),
						 FALSE,
						 TRUE,
						 TRUE);
	}
}

//+----------------------------------------------------------------------------
//  Function:	GetUserFriendlyName   
//  Synopsis:  Gets name in Domain\Name format and returns UPN name and
//					Display Name. 
//  Arguments:
//  Returns:    
//-----------------------------------------------------------------------------
void
CSidHandler::
GetUserFriendlyName(IN const CString & strSamLogonName,
                    OUT CString *pstrLogonName,
                    OUT CString *pstrDisplayName)
{

	if(strSamLogonName.IsEmpty()|| !pstrLogonName || !pstrDisplayName)
	{
		ASSERT(strSamLogonName.IsEmpty());
		ASSERT(!pstrLogonName);
		ASSERT(!pstrDisplayName);
		return;
	}
	//
	// Start by getting the FQDN.  Cracking is most efficient when the
	// FQDN is the starting point.
	//
	// TranslateName takes a while to complete, so bUseSamCompatibleInfo
	// should be TRUE whenever possible, e.g. for local accounts on a non-DC
	// or anything where we know a FQDN doesn't exist.
	//
	CString strFQDN;
	if (FAILED(TranslateNameInternal(strSamLogonName,
                                    NameSamCompatible,
                                    NameFullyQualifiedDN,
                                    &strFQDN)))
	{
		return;
	}

	//
	//Get UPN
	//
	TranslateNameInternal(strFQDN,
                         NameFullyQualifiedDN,
                         NameUserPrincipal,
                         pstrLogonName);


	//
	//Get Display Name
	//
	TranslateNameInternal(strFQDN,
								 NameFullyQualifiedDN,
                         NameDisplay,
                         pstrDisplayName);
}

//+----------------------------------------------------------------------------
//  Function: LookupSids
//  Synopsis: Given a list of sids, retuns a list of corresponding
//				  CSidCacheAz objects  
//  Arguments:
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT
CSidHandler::
LookupSids(IN CBaseAz* pOwnerAz,
			  IN CList<PSID,PSID>& listSids,
			  OUT CList<CBaseAz*,CBaseAz*>& listSidCacheAz)
{
	if(!pOwnerAz)
	{
		ASSERT(pOwnerAz);
		return E_POINTER;
	}

	HRESULT hr = S_OK;

	CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY> listSidCacheEntries;
	CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY> listUnResolvedSidCacheEntries;

	
	hr = GetSidCacheListFromSidList(listSids,
									listSidCacheEntries,
									listUnResolvedSidCacheEntries);
	
	if(FAILED(hr))
	{
		return hr;
	}
	
	//Do the Lookup for unresolved sids
	LookupSidsHelper(listUnResolvedSidCacheEntries,
					 m_pMachineInfo->GetMachineName(),
					 m_pMachineInfo->IsStandAlone(),
					 m_pMachineInfo->IsDC(),
				     FALSE);

	POSITION pos = listSidCacheEntries.GetHeadPosition();
	for( int i = 0; i < listSidCacheEntries.GetCount(); ++i)
	{
		PSID_CACHE_ENTRY pSidCacheEntry = listSidCacheEntries.GetNext(pos);
		CSidCacheAz* pSidCacheAz = new CSidCacheAz(pSidCacheEntry,
																 pOwnerAz);
		if(!pSidCacheAz)
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		listSidCacheAz.AddTail(pSidCacheAz);
	}

	if(FAILED(hr))
	{
		RemoveItemsFromList(listSidCacheAz);
	}
	
	return hr;
}

//+----------------------------------------------------------------------------
//  Function: GetSidCacheListFromSidList
//				  Gets a list of sids and returns corresponding list of sidcache 
//				  entries and unresolved sid cache entries
//  Arguments:listSid: List of sids
//				  listSidCacheEntry: Gets list of SidCacheEntries
//				  listUnresolvedSidCacheEntry Gets List of unresolved 
//				  SidCacheEntries
//-----------------------------------------------------------------------------
HRESULT
CSidHandler::
GetSidCacheListFromSidList(IN CList<PSID,PSID>& listSid,
									OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listSidCacheEntry,
									OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listUnresolvedSidCacheEntry)
{
	POSITION pos = listSid.GetHeadPosition();
	
	for( int i = 0; i < listSid.GetCount(); ++i)
	{
		PSID pSid = listSid.GetNext(pos);

		PSID_CACHE_ENTRY pEntry = GetEntryFromCache(pSid);
		if(!pEntry)
		{
			return E_OUTOFMEMORY;
		}		
		
		listSidCacheEntry.AddTail(pEntry);
		
		if(!pEntry->IsSidResolved())
			listUnresolvedSidCacheEntry.AddTail(pEntry);
	}
	return S_OK;
}

//+----------------------------------------------------------------------------
//  Function: GetSidCacheListFromOPOutput
//  Synopsis: Gets the sid from Object Pickers output and returns corresponding
//				  list of SidCacheEntries. Also returns sids of unresolved sids.
//				  
//  Arguments:pDsSelList selection list from OP.
//				  listSidCacheEntry: Gets list of SidCacheEntries
//				  listUnresolvedSidCacheEntry Gets List of unresolved 
//				  SidCacheEntries
//-----------------------------------------------------------------------------
HRESULT
CSidHandler::
GetSidCacheListFromOPOutput(IN PDS_SELECTION_LIST pDsSelList,
									 OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listSidCacheEntry,
									 OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listUnresolvedSidCacheEntry)
{
	if(!pDsSelList)
	{
		ASSERT(pDsSelList);
		return E_POINTER;
	}

	HRESULT hr = S_OK;
	int cNames = pDsSelList->cItems;
   for (int i = 0; i < cNames; i++)
   {
		PSID pSid = NULL;
      LPVARIANT pvarSid = pDsSelList->aDsSelection[i].pvarFetchedAttributes;

      if (NULL == pvarSid || (VT_ARRAY | VT_UI1) != V_VT(pvarSid)
			|| FAILED(SafeArrayAccessData(V_ARRAY(pvarSid), &pSid)))
		{
			continue;
		}

		PSID_CACHE_ENTRY pEntry = GetEntryFromCache(pSid);
		if(!pEntry)
		{
			return E_OUTOFMEMORY;
		}		
		
		listSidCacheEntry.AddTail(pEntry);
		
		if(!pEntry->IsSidResolved())
			listUnresolvedSidCacheEntry.AddTail(pEntry);
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\snapbase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       snapbase.cpp
//
//  Contents:   Includes sources from Snapin Framework
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#include "headers.h"
#include "snapbase.h"

#include "stdabou_.cpp"
#include "compbas_.cpp"
#include "proppag_.cpp"
#include "dataobj_.cpp"
#include "treedat_.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\snapabout.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       snapabout.h
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

extern const CLSID CLSID_RoleSnapinAbout;    // In-Proc server GUID

//
// CRoleSnapinAbout
//
class CRoleSnapinAbout :
	public CSnapinAbout,
	public CComCoClass<CRoleSnapinAbout, &CLSID_RoleSnapinAbout>

{
public:
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) 
	{ 
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);
	}
	
	CRoleSnapinAbout();
	~CRoleSnapinAbout();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\sidcache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
class CBaseAz;

class SID_CACHE_ENTRY
{
public:
	SID_CACHE_ENTRY(PSID pSid);
	~SID_CACHE_ENTRY();
		
	BOOL
	IsSidResolved() const {return (m_SidType != SidTypeUnknown);} 

	const CString& 
	GetNameToDisplay() const{ 	return m_strNameToDisplay;}

	const CString&
	GetSidType() const 	{return m_strType;}

	PSID GetSid() const {return m_pSid;}
	
	SID_NAME_USE GetSidNameUse() const { return m_SidType;}

	const CString& 
	GetStringSid()const { return m_strSid;}
	
	VOID 
	AddNameAndType(IN SID_NAME_USE SidType, 
				   IN const CString& strAccountName,
				   IN const CString& strLogonName);
	
private:
	SID_NAME_USE m_SidType;
	PSID    m_pSid;
	CString m_strSid;
	CString m_strType;
	CString m_strAccountName;
	CString m_strLogonName;
	CString m_strNameToDisplay;
};

typedef SID_CACHE_ENTRY* PSID_CACHE_ENTRY;

struct ltstr
{
  bool operator()(const CString* s1, const CString* s2) const
  {
    return (*s1 < *s2) ;
  }
};

typedef map<const CString*,PSID_CACHE_ENTRY,ltstr> SidCacheMap;


class CMachineInfo
{
public:
	CMachineInfo();
	~CMachineInfo();
	
	VOID 
	InitializeMacineConfiguration(IN const CString& strTargetComputerName);
	
	const CString& 
	GetMachineName(){return m_strTargetComputerName;}
	
	BOOL 
	IsStandAlone(){return m_bIsStandAlone;}
	
	const CString& 
	GetDCName(){return m_strDCName;}
	
	BOOL 
	IsDC(){return m_bIsDC;}

	const CString&
	GetTargetDomainFlat(){return m_strTargetDomainFlat;}

	const CString&
	GetTargetDomainDNS(){return m_strTargetDomainDNS;}

private:
	CString m_strTargetComputerName;
	BOOL m_bIsStandAlone;
	CString m_strDCName;
	BOOL	m_bIsDC;
	CString m_strTargetDomainFlat;
	CString m_strTargetDomainDNS;
};


class CSidHandler
{
public:
	CSidHandler(CMachineInfo* pMachineInfo);
	~CSidHandler();

	HRESULT
	LookupSids(IN CBaseAz* pOwnerAz,
				  IN CList<PSID,PSID>& listSids,
				  OUT CList<CBaseAz*,CBaseAz*>& listSidCacheEntries);
	
	//
	//Popsup Object Picker and returns selected users/groups listSids 
	//
	HRESULT 
	GetUserGroup(IN HWND hDlg, 	
					 IN CBaseAz*pOwnerAz,
					 OUT CList<CBaseAz*,CBaseAz*>& listSidCacheEntry);

private:
	VOID 
	GetUserFriendlyName(IN const CString & strSamLogonName,
                       OUT CString *pstrLogonName,
                       OUT CString *pstrDisplayName);
	VOID
	LookupSidsHelper(IN OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listSids,
						  IN const CString& strServerName,
						  IN BOOL bStandAlone,
						  IN BOOL bIsDC,
						  IN BOOL bSecondTry);


	HRESULT 
	GetObjectPicker();
	
	HRESULT 
	InitObjectPicker();

	PSID_CACHE_ENTRY 
	GetEntryFromCache(PSID pSid);

	HRESULT
	GetSidCacheListFromOPOutput(IN PDS_SELECTION_LIST pDsSelList,
										 OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listSidCacheEntry,
										 OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listUnresolvedSidCacheEntry);

	HRESULT
	GetSidCacheListFromSidList(IN CList<PSID,PSID>& listSid,
										OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listSidCacheEntry,
										OUT CList<PSID_CACHE_ENTRY,PSID_CACHE_ENTRY>& listUnresolvedSidCacheEntry);

	
	CComPtr<IDsObjectPicker> m_spDsObjectPicker;
	BOOL	m_bObjectPickerInitialized;
	CMachineInfo *m_pMachineInfo;
	SidCacheMap m_mapSidCache;
	//This critical section is used to protect SidHandler function 
	//from multiple threads
	CRITICAL_SECTION m_csSidHandlerLock;
	//Need this lock before modifying an entry in SidCache
	CRITICAL_SECTION m_csSidCacheLock;
    void LockSidHandler()     { EnterCriticalSection(&m_csSidHandlerLock); }
    void UnlockSidHandler()   { LeaveCriticalSection(&m_csSidHandlerLock); }
	void LockSidCacheEntry()  { EnterCriticalSection(&m_csSidCacheLock); }	
	void UnlockSidCacheEntry(){ LeaveCriticalSection(&m_csSidCacheLock); }
};

void
GetFileServerName(const CString& strPath,
				  OUT CString& strTargetMachineName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\snapabout.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       snapabout.cpp
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------

#include "headers.h" 

DEBUG_DECLARE_INSTANCE_COUNTER(CRoleSnapinAbout)

// {FA9342F0-B15B-473c-A746-14FCD4C4A6AA}
const GUID CLSID_RoleSnapinAbout = 
{ 0xfa9342f0, 0xb15b, 0x473c, { 0xa7, 0x46, 0x14, 0xfc, 0xd4, 0xc4, 0xa6, 0xaa } };


CRoleSnapinAbout::CRoleSnapinAbout()
{
	TRACE_CONSTRUCTOR_EX(DEB_SNAPIN, CRoleSnapinAbout);

	DEBUG_INCREMENT_INSTANCE_COUNTER(CRoleSnapinAbout);

   m_szProvider = VER_COMPANYNAME_STR;
	m_szVersion = VER_PRODUCTVERSION_STR;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_ROLE_SNAPIN;
	m_uIdBitmapSmallImage = IDB_ABOUT_16x16;
	m_uIdBitmapSmallImageOpen = IDB_ABOUT_16x16;
	m_uIdBitmapLargeImage = IDB_ABOUT_32x32;
	m_crImageMask = BMP_COLOR_MASK;
}

CRoleSnapinAbout::~CRoleSnapinAbout()
{

	TRACE_DESTRUCTOR_EX(DEB_SNAPIN, CRoleSnapinAbout);

	DEBUG_DECREMENT_INSTANCE_COUNTER(CRoleSnapinAbout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"
#include <tchar.h>

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

#undef ASSERT
#undef ASSERTMSG

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    #define DBG_INDENTER    \
            CIndenter Indent(&DBG_COMP)

    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD_EX(Infolevel, Class, Method) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION_EX(Infolevel, Function) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __cdecl __DummyDbg(ULONG, PCWSTR, ...) { }
    inline void __cdecl __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __cdecl __DummyTrace(PCWSTR, ...) { }
    inline void __cdecl __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK
    #define DBG_INDENTER

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)
    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls)
    #define TRACE_DESTRUCTOR_EX(Infolevel, cls)
    #define TRACE_METHOD_EX(Infolevel, ClassName, MethodName)
    #define TRACE_FUNCTION_EX(Infolevel, FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   e

    #define ASSERT(e)
    #define VERIFY(e)   ((void)(e))

#endif // DBG==1



#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
//	HISTORY
//	01-Aug-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "about.h"

#include "stdabout.cpp" 


/////////////////////////////////////////////////////////////////////
CSchemaMgmtAbout::CSchemaMgmtAbout()
{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CLASS;
	m_uIdBitmapSmallImage = IDB_CLASS_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CLASS_SMALL;
	m_uIdBitmapLargeImage = IDB_CLASS;
	m_crImageMask = RGB(0, 255, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

#include "stdabout.h"

//	About for "Schema Manager" snapin
class CSchemaMgmtAbout :
	public CSnapinAbout,
	public CComCoClass<CSchemaMgmtAbout, &CLSID_SchemaManagementAbout>

{
public:
DECLARE_REGISTRY(CSchemaMgmtAbout, _T("SCHMMGMT.SchemaMgmtAboutObject.1"), _T("SCHMMGMT.SchemaMgmtAboutObject.1"), IDS_SCHMMGMT_DESC, THREADFLAGS_BOTH)
	CSchemaMgmtAbout();
};

// version and provider strings

#include <ntverp.h>
#define IDS_SNAPINABOUT_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPINABOUT_PROVIDER VER_COMPANYNAME_STR

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\aclpage.h ===
#ifndef _ACLPAGE_H
#define _ACLPAGE_H


//
// aclpage.h : header file
// This was originally appropriated from the dnsmgr snap in.
//

class CISecurityInformationWrapper;

class CAclEditorPage
{
public:

    ~CAclEditorPage();

    static
    HRESULT CreateInstance( CAclEditorPage ** ppAclPage, LPCTSTR lpszLDAPPath,
							LPCTSTR lpszObjectClass );

    HPROPSHEETPAGE CreatePage();

private:

    CAclEditorPage();

    HRESULT Initialize( LPCTSTR lpszLDAPPath, LPCTSTR lpszObjectClass );

    static BOOL IsReadOnly( LPCTSTR lpszLDAPPath );

    //
    // data
    //

    CISecurityInformationWrapper* m_pISecInfoWrap;

    friend class CISecurityInformationWrapper;
};


typedef HPROPSHEETPAGE (WINAPI *ACLUICREATESECURITYPAGEPROC) (LPSECURITYINFO);


#endif //_ACLPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\util.h ===
//+---------------------------------------------------------------------------
//
//	Microsoft Windows
//	Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//	File:		util.h
//
//	Contents:	
//
//	History:	07-26-2001	Hiteshr  Created
//
//----------------------------------------------------------------------------

//
//Action items are used to for list controls which manage membership of 
//core properties. For ex: membership of group. Items can be
//deleted and added from listbox at any time, but they are added to core
//object only when apply button is pressed. Action item keeps track of action
//to do on each item on Apply.
//
enum ACTION
{
	ACTION_NONE,	
	ACTION_ADD, 	
	ACTION_REMOVE,
	ACTION_REMOVED,
};
	
struct ActionItem
{
	ActionItem(CBaseAz* pBaseAz):
				m_pMemberAz(pBaseAz),
				action(ACTION_NONE)
				{}
	~ActionItem()
	{
		if(m_pMemberAz)
			delete m_pMemberAz;
	}
	CBaseAz* m_pMemberAz;
	ACTION action;
};


typedef multimap<const CString*,ActionItem*,ltstr> ActionMap;

VOID
RemoveItemsFromActionMap(ActionMap& map);

//+----------------------------------------------------------------------------
//	Function:  IsValidStoreType 
//	Synopsis:	Validates Store Type
//-----------------------------------------------------------------------------
BOOL IsValidStoreType(ULONG lStoreType);

//+----------------------------------------------------------------------------
//	Function:  ValidateStoreTypeAndName 
//	Synopsis:  Validates the user entered AD Store Name
//	Arguments: strName: User entered store name to verify
//	Returns:   TRUE if name is valid else false 
//-----------------------------------------------------------------------------
BOOL
ValidateStoreTypeAndName(IN HWND hWnd,
						 IN LONG ulStoreType,
						 IN const CString& strName);

//+----------------------------------------------------------------------------
//	Function:  NameToFormatStoreName
//	Synopsis:  Converts user entered name to format which core understands
//	Arguments: ulStoreType: Type of store
//			   strName: User entered store name 
//			   bUseLDAP:use LDAP string to format AD name instead msldap
//			   strFormalName: gets the output ldap name
//-----------------------------------------------------------------------------
void
NameToStoreName(IN LONG ulStoreType,
				IN const CString& strName,				
				IN BOOL bUseLDAP,
				OUT CString& strFormalName);



//+----------------------------------------------------------------------------
//	Function: AddColumnToListView  
//	Synopsis: Add Columns to Listview and set column width according to 
//				  percentage specified in the COL_FOR_LV					
//	Arguments:IN pListCtrl: ListCtrl pointer
//				  IN pColForLV: Column Infomration Array
//
//	Returns:	
//-----------------------------------------------------------------------------
VOID
AddColumnToListView(IN CListCtrl* pListCtrl,
						  IN COL_FOR_LV* pColForLV);

//+----------------------------------------------------------------------------
//	Function: BaseAzInListCtrl	
//	Synopsis: Checks if Object of type eObjectTypeAz named strName is 
//			  in the Listview. If its present, returns 
//			  its index else returns -1. 
//	Arguments:IN pListCtrl: ListCtrl pointer
//			  IN strName: string to search for
//			  IN eObjectTypeAz Compare the object of this type only
//
//	Returns:  If its present, returns its index else returns -1
//-----------------------------------------------------------------------------
int 
BaseAzInListCtrl(IN CListCtrl* pListCtrl,
					  IN const CString& strName,
					  IN OBJECT_TYPE_AZ eObjectTypeAz);

//+----------------------------------------------------------------------------
//	Function: AddBaseAzFromListToListCtrl  
//	Synopsis: Take the items from List and Add them to ListCtrl. Doesn't
//			  add the items which are already in ListCtrl
//	Arguments:listBaseAz: List of items
//			  pListCtrl: ListControl Pointer
//			  uiFlags : Column Info
//			  bCheckDuplicate: Check for duplicate items
//	Returns: The index of the new item if it is successful; otherwise, -1 
//	NOTE: Function assume the Order of column is Name, Type and Description
//-----------------------------------------------------------------------------
void
AddBaseAzFromListToListCtrl(IN CList<CBaseAz*, CBaseAz*>& listBaseAz,
							IN CListCtrl* pListCtrl,
							IN UINT uiFlags,
							IN BOOL bCheckDuplicate);
//+----------------------------------------------------------------------------
//	Function: AddActionItemFromListToListCtrl  
//	Synopsis: Take the Actions items from List and Add them to ListCtrl. 
//	Arguments:listBaseAz: List of items
//			  pListCtrl: ListControl Pointer
//			  uiFlags : Column Info
//			  bCheckDuplicate: Check for duplicate items
//	Returns: The index of the new item if it is successful; otherwise, -1 
//	NOTE: Function assume the Order of column is Name, Type and Description
//-----------------------------------------------------------------------------
void
AddActionItemFromListToListCtrl(IN CList<ActionItem*, ActionItem*>& listActionItem,
										 IN CListCtrl* pListCtrl,
										 IN UINT uiFlags,
										 IN BOOL bCheckDuplicate);


//+----------------------------------------------------------------------------
//	Function: AddActionItemFromMapToListCtrl  
//	Synopsis: Take the Actions items from Map and Add them to ListCtrl. 
//	Arguments:listBaseAz: List of items
//			  pListCtrl: ListControl Pointer
//			  uiFlags : Column Info
//			  bCheckDuplicate: Check for duplicate items
//	Returns: The index of the new item if it is successful; otherwise, -1 
//	NOTE: Function assume the Order of column is Name, Type and Description
//-----------------------------------------------------------------------------
void
AddActionItemFromMapToListCtrl(IN ActionMap& mapActionItem,
							   IN CListCtrl* pListCtrl,
							   IN UINT uiFlags,
							   IN BOOL bCheckDuplicate);

//+----------------------------------------------------------------------------
//	Function: AddActionItemToListCtrl  
//	Synopsis: Adds a new item to ListCtrl.
//	Arguments:pListCtrl: ListControl Pointer
//			  iIndex:	 Index at which to Add
//			  pActionItem: Item to add
//			  uiFlags: column info
//	Returns: The index of the new item if it is successful; otherwise, -1 
//-----------------------------------------------------------------------------
int 
AddActionItemToListCtrl(IN CListCtrl* pListCtrl,
							  IN int iIndex,
							  IN ActionItem* pActionItem,
							  IN UINT uiFlags);

//+----------------------------------------------------------------------------
//	Function: AddBaseAzToListCtrl  
//	Synopsis: Adds a new item to ListCtrl.
//	Arguments:pListCtrl: ListControl Pointer
//			  iIndex:	 Index at which to Add
//			  pBaseAz: Item to add
//			  uiFlags: column info
//	Returns: The index of the new item if it is successful; otherwise, -1 
//-----------------------------------------------------------------------------
int 
AddBaseAzToListCtrl(IN CListCtrl* pListCtrl,
						  IN int iIndex,
						  IN CBaseAz* pBaseAz,
						  IN UINT uiFlags);


//+----------------------------------------------------------------------------
//	Function: EnableButtonIfSelectedInListCtrl	
//	Synopsis: Enables the button if something is selected in Listctrl
//	Arguments:
//	Returns: TRUE if Enabled the button, FALSE if didn't. 
//-----------------------------------------------------------------------------
BOOL
EnableButtonIfSelectedInListCtrl(IN CListCtrl * pListCtrl,
											IN CButton* pButton);

//+----------------------------------------------------------------------------
//	Function: DeleteSelectedRows  
//	Synopsis: Deletes the selected rows 
//-----------------------------------------------------------------------------
void
DeleteSelectedRows(IN CListCtrl* pListCtrl);

//+----------------------------------------------------------------------------
//	Function: SelectListCtrlItem  
//	Synopsis: Select the item in List Ctrl and mark it visible
//	Arguments:
//	Returns: 
//-----------------------------------------------------------------------------
void
SelectListCtrlItem(IN CListCtrl* pListCtrl,
						 IN int iSelected);



//+----------------------------------------------------------------------------
//	Synopsis: Empties the list and calls delete on items in list
//-----------------------------------------------------------------------------
template<class T>
VOID RemoveItemsFromList(IN CList<T, T>& list, BOOL bLocalFree = FALSE)
{
	while(!list.IsEmpty())
	{
		if(bLocalFree)
			LocalFree(list.RemoveTail());
		else
			delete list.RemoveTail();
	}
}

template<class T>
VOID
EmptyList(IN CList<T, T>& list)
{
	while(!list.IsEmpty())
		list.RemoveTail();
}

//+----------------------------------------------------------------------------
//	Synopsis: Gets long value from Edit box
//	Returns: FALSE if edit box is empty. Assumes only numeric can be entered 
//	 in edit box
//-----------------------------------------------------------------------------
BOOL 
GetLongValue(CEdit& refEdit, LONG& reflValue, HWND hWnd = NULL);
//+----------------------------------------------------------------------------
//	Synopsis: Sets long value in Edit box
//	Returns: 
//-----------------------------------------------------------------------------
VOID SetLongValue(CEdit* pEdit, LONG lValue);


//+----------------------------------------------------------------------------
//	Synopsis: Converts a sid in binary format to a sid in string format
//-----------------------------------------------------------------------------
BOOL 
ConvertSidToStringSid(IN PSID Sid, 
							 OUT CString* pstrSid);
//+----------------------------------------------------------------------------
//	Synopsis:  Converts a sid in string format to sid in binary format
//-----------------------------------------------------------------------------
BOOL 
ConvertStringSidToSid(IN const CString& strSid, 
							 OUT PSID *ppSid);
//+----------------------------------------------------------------------------
//	Function:GetStringSidFromSidCachecAz   
//	Synopsis:Gets the string sid from CSidCacheAz object   
//-----------------------------------------------------------------------------
BOOL 
GetStringSidFromSidCachecAz(CBaseAz* pBaseAz,
									 CString* pstrStringSid);
//+----------------------------------------------------------------------------
//	Function: AddBaseAzItemsFromListCtrlToList	
//	Synopsis: Add items from ListCtrl to List	
//-----------------------------------------------------------------------------
VOID
AddBaseAzItemsFromListCtrlToList(IN CListCtrl* pListCtrl,
											OUT CList<CBaseAz*,CBaseAz*>& listBaseAz);
//+----------------------------------------------------------------------------
//	Function:GetFileName   
//	Synopsis:Displays FileOpen dialog box and return file selected by user	 
//	Arguments:hwndOwner : owner window
//			  bOpen: File must exist
//			  nIDTitle : title of open dialog box
//			  pszFilter : filter 
//			  strFileName : gets selected file name
//
//-----------------------------------------------------------------------------
BOOL
GetFileName(IN HWND hwndOwner,
			IN BOOL bOpen,
			IN int	nIDTitle,
            IN const CString& strInitFolderPath,
			IN LPCTSTR pszFilter,
			CString& strFileName);




template<class CObjectAz, class CObjectAzNode>
class AddChildNodes
{
public:
	static HRESULT DoEnum(IN CList<CBaseAz*, CBaseAz*>& listAzChildObject,
						  IN CBaseContainerNode* pContainerNode)
	{	
		HRESULT hr = S_OK;

		POSITION pos = listAzChildObject.GetHeadPosition();
		for (int i=0;i < listAzChildObject.GetCount();i++)
		{
			CObjectAz* pObjectAz= dynamic_cast<CObjectAz*>(listAzChildObject.GetNext(pos));
			if(pObjectAz)
			{
				//Create Container/Leaf Node corresponding to CObjectAz
				CObjectAzNode* pObjectAzNode = 
					new CObjectAzNode(pContainerNode->GetComponentDataObject(),
									  pContainerNode->GetAdminManagerNode(),
									  pObjectAz);
				
				if(!pObjectAzNode)
				{
					hr = E_OUTOFMEMORY;
					DBG_OUT_HRESULT(hr);
					break;
				}
				VERIFY(pContainerNode->AddChildToList(pObjectAzNode));
			}
			else
			{
				ASSERT(FALSE);
				hr = E_UNEXPECTED;
				break;
			}
		}

		return hr;
	}

};


typedef AddChildNodes<CApplicationAz, CApplicationNode> ADD_APPLICATION_FUNCTION;
typedef AddChildNodes<CScopeAz, CScopeNode> ADD_SCOPE_FUNCTION;
typedef AddChildNodes<CRoleAz, CRoleNode> ADD_ROLE_FUNCTION;
typedef AddChildNodes<COperationAz, COperationNode> ADD_OPERATION_FUNCTION;
typedef AddChildNodes<CTaskAz, CTaskNode> ADD_TASK_FUNCTION;
typedef AddChildNodes<CGroupAz, CGroupNode> ADD_GROUP_FUNCTION;


//+----------------------------------------------------------------------------
//	Function:  AddAzObjectNodesToList 
//	Synopsis:  Adds the nodes for object of type eObjectType to the Container
//			   node. 
//	Arguments:IN eObjectType:	Type of object
//			  IN listAzChildObject: List of objects to be added
//			  IN pContainerNode: Container in snapin to which new nodes will
//								 be added.	
//	Returns:	
//-----------------------------------------------------------------------------
HRESULT 
AddAzObjectNodesToList(IN OBJECT_TYPE_AZ eObjectType,
							  IN CList<CBaseAz*, CBaseAz*>& listAzChildObject,
							  IN CBaseContainerNode* pContainerNode);


////////////////////////////////////////////////////////////////////////////////////
// Theme support

class CThemeContextActivator
{
public:
	CThemeContextActivator() : m_ulActivationCookie(0)
	{ 
		SHActivateContext (&m_ulActivationCookie); 
	}

	~CThemeContextActivator()
		{ SHDeactivateContext (m_ulActivationCookie); }

private:
	ULONG_PTR m_ulActivationCookie;
};

//
//Error Handling
//
VOID
vFormatString(CString &strOutput, UINT nIDPrompt, va_list *pargs);
VOID
FormatString(CString &strOutput, UINT nIDPrompt, ...);

int DisplayMessageBox(HWND hWnd,
							 const CString& strMessage,
							 UINT uStyle);
VOID
GetSystemError(CString &strOutput, DWORD dwErr);

void DisplayError(HWND hWnd, UINT nIDPrompt, ...);

void 
DisplayInformation(HWND hWnd, UINT nIDPrompt, ...);

int DisplayConfirmation(HWND hwnd,
								UINT nIDPrompt,
								...);

void 
DisplayWarning(HWND hWnd, UINT nIDPrompt, ...);

BOOL
IsDeleteConfirmed(HWND hwndOwner,
						CBaseAz& refBaseAz);




//
//This struct maps the common error messages for each object type
//
struct ErrorMap
{
	OBJECT_TYPE_AZ eObjectType;
	UINT idObjectType;
	UINT idNameAlreadyExist;
	UINT idInvalidName; 
	LPWSTR pszInvalidChars;
};

ErrorMap *GetErrorMap(OBJECT_TYPE_AZ eObjectType);



//+----------------------------------------------------------------------------
//	Function: GetLSAConnection
//	Synopsis: Wrapper for LsaOpenPolicy  
//-----------------------------------------------------------------------------
LSA_HANDLE
GetLSAConnection(IN const CString& strServer, 
					  IN DWORD dwAccessDesired);

//+----------------------------------------------------------------------------
//	Function:CompareBaseAzObjects	
//	Synopsis:Compares two baseaz objects for equivalance. If two pAzA and pAzB
//			 are two different instances of same coreaz object, they are equal	 
//-----------------------------------------------------------------------------
BOOL 
CompareBaseAzObjects(CBaseAz* pAzA, CBaseAz* pAzB);


//+----------------------------------------------------------------------------
//	Function:  OpenCreateAdminManager 
//	Synopsis:  Open an existing an existing Authorization Store or 
//			   creates a new Authorization Store and adds corresponding
//			   AdminManager object to snapin 
//	Arguments:IN hWnd: Handle of window for dialog box
//			  IN bNew: If True create a new Authz store else open existing
//					   one
//			  IN bOpenFromSavedConsole: This is valid when bNew is False.
//				True if open is in resopnse to a console file.
//			  IN lStoreType: XML or AD
//			  IN strName:	Name of store
//			  IN strDesc:  Description. Only valid in case of new
//            IN strScriptDir : Script directory
//			  IN pRootData: Snapin Rootdata
//			  IN pComponentData: ComponentData
//	Returns:	
//-----------------------------------------------------------------------------
HRESULT OpenCreateAdminManager(IN BOOL bNew,
							   IN BOOL bOpenFromSavedConsole,
							   IN ULONG lStoreType,
							   IN const CString& strStoreName,
							   IN const CString& strDesc,
                               IN const CString& strScriptDir,
							   IN CRootData* pRootData,
							   IN CComponentDataObject* pComponentData);

//+----------------------------------------------------------------------------
//	Function:  OpenAdminManager 
//	Synopsis:  Open an existing an existing Authorization Store adds 
//				corresponding adminManager object to snapin 
//	Arguments:IN hWnd: Handle of window for dialog box
//			  IN bOpenFromSavedConsole: True if open is in resopnse to a console 
//				file.
//			  IN lStoreType: XML or AD
//			  IN strName:	Name of store
//            IN strScriptDir : Script directory
//			  IN pRootData: Snapin Rootdata
//			  IN pComponentData: ComponentData
//	Returns:	
//-----------------------------------------------------------------------------
HRESULT OpenAdminManager(IN HWND hWnd,
						 IN BOOL bOpenFromSavedConsole,
						 IN ULONG lStoreType,
						 IN const CString& strStoreName,
                         IN const CString& strStoreDir,
						 IN CRootData* pRootData,
						 IN CComponentDataObject* pComponentData);


//+----------------------------------------------------------------------------
//	Function:GetADContainerPath   
//	Synopsis:Displays a dialog box to allow for selecting a AD container   
//-----------------------------------------------------------------------------
BOOL
GetADContainerPath(HWND hWndOwner,
				   ULONG nIDCaption,
				   ULONG nIDTitle,
				   CString& strPath,
				   CADInfo& refAdInfo);


BOOL FindDialogContextTopic(/*IN*/UINT nDialogID,
							/*IN*/DWORD_PTR* pMap);
//+----------------------------------------------------------------------------
//	Function:CanReadOneProperty   
//	Synopsis:Function tries to read IsWriteable property. If that fails displays
//			 an error message. This is used before adding property pages.	 
//			 if we cannot read IsWritable property,thereisn't much hope.
//-----------------------------------------------------------------------------
BOOL 
CanReadOneProperty(LPCWSTR pszName,
				   CBaseAz* pBaseAz);


struct CompareInfo
{
	BOOL bActionItem;
	UINT uiFlags;
	int iColumn;
	int iSortDirection;
};

//+----------------------------------------------------------------------------
//	Function: ListCompareProc  
//	Synopsis: Comparison function used by list control	
//-----------------------------------------------------------------------------
int CALLBACK
ListCompareProc(LPARAM lParam1,
				LPARAM lParam2,
				LPARAM lParamSort);
//+----------------------------------------------------------------------------
//	Function:SortListControl   
//	Synopsis:Sorts a list control
//	Arguments:pListCtrl: List control to sort
//			  iColumnClicked: column clicked
//			  iSortDirection: direction in which to sort
//			  uiFlags:	column info
//			  bActionItem: if item in list is actionitem
//-----------------------------------------------------------------------------
void
SortListControl(CListCtrl* pListCtrl,
				int ColumnClicked,
				int SortDirection,
				UINT uiFlags,
				BOOL bActionItem);

//+----------------------------------------------------------------------------
//	Synopsis: Ensures that selection in listview control is visible
//-----------------------------------------------------------------------------
void
EnsureListViewSelectionIsVisible(CListCtrl *pListCtrl);

//+----------------------------------------------------------------------------
//	Synopsis:Convert input number in string format to long. if number is out
//			 of range displays a message.	
//-----------------------------------------------------------------------------
BOOL 
ConvertStringToLong(LPCWSTR pszInput, 
					long &reflongOutput,
					HWND hWnd = NULL);

VOID 
SetSel(CEdit& refEdit);

void
TrimWhiteSpace(CString& str);

//+----------------------------------------------------------------------------
//	Function:LoadIcons	 
//	Synopsis:Adds icons to imagelist   
//-----------------------------------------------------------------------------
HRESULT
LoadIcons(LPIMAGELIST pImageList);

//+----------------------------------------------------------------------------
//	Function: LoadImageList  
//	Synopsis: Loads image list	
//-----------------------------------------------------------------------------
HIMAGELIST
LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID);

//+----------------------------------------------------------------------------
//	Function:BrowseAdStores   
//	Synopsis:Displays a dialog box with list of AD stores available.   
//	Arguments:strDN: Gets the selected ad store name
//-----------------------------------------------------------------------------
void
BrowseAdStores(IN HWND hwndOwner,
			   OUT CString& strDN,
			   IN CADInfo& refAdInfo);

//+----------------------------------------------------------------------------
//	Function:GetFolderName	 
//	Synopsis:Displays Folder selection dialog box and return folder selected 
//			 by user   
//	Arguments:hwndOwner : owner window
//			  nIDTitle : title of dialog box
//			  strInitBrowseRoot : location of the root folder from which to 
//			  start browsing
//			  strFolderName : gets selected file name
//-----------------------------------------------------------------------------
BOOL
GetFolderName(IN HWND hwndOwner,
			  IN INT nIDTitle,
			  IN const CString& strInitBrowseRoot,
			  IN OUT CString& strFolderName);

//+----------------------------------------------------------------------------
//	Function: AddExtensionToFileName  
//	Synopsis: Functions adds .xml extension to name of file if no extension 
//			  is present.  
//	Arguments:
//	Returns:	
//-----------------------------------------------------------------------------
VOID
AddExtensionToFileName(IN OUT CString& strFileName);


//+----------------------------------------------------------------------------
//	Function:GetCurrentWorkingDirectory
//	Synopsis:Gets the current working directory   
//-----------------------------------------------------------------------------
BOOL
GetCurrentWorkingDirectory(IN OUT CString& strCWD);

//+----------------------------------------------------------------------------
//	Function: GetFileExtension	
//	Synopsis: Get the extension of the file.
//-----------------------------------------------------------------------------
BOOL
GetFileExtension(IN const CString& strFileName,
				 OUT CString& strExtension);

//+--------------------------------------------------------------------------
//	Function:	AzRoleAdsOpenObject
//	Synopsis:	A wrapper around ADsOpenObject
//+--------------------------------------------------------------------------
HRESULT AzRoleAdsOpenObject(LPWSTR lpszPathName, 
							LPWSTR lpszUserName, 
							LPWSTR lpszPassword, 
							REFIID riid, 
							VOID** ppObject,
							BOOL bBindToServer = FALSE);

VOID
GetDefaultADContainerPath(IN CADInfo& refAdInfo,
						  IN BOOL bAddServer,
						  IN BOOL bAddLdap,
						  OUT CString& strPath);
//+--------------------------------------------------------------------------
//	Function:	IsBizRuleWritable
//	Synopsis:	Checks if bizrules are writable for this object
//+--------------------------------------------------------------------------
BOOL
IsBizRuleWritable(HWND hWnd, CContainerAz& refBaseAz);



/******************************************************************************
Class:	CCommandLineOptions
Purpose:class for reading the command line options for console file
******************************************************************************/
class CCommandLineOptions
{
public:
	CCommandLineOptions():m_bInit(FALSE),
						  m_bCommandLineSpecified(FALSE),
						  m_lStoreType(AZ_ADMIN_STORE_INVALID)

	{
	}
	void Initialize();
	const CString& GetStoreName() const { return m_strStoreName;}
	LONG GetStoreType() const { return m_lStoreType;}
	BOOL CommandLineOptionSpecified() const { return m_bCommandLineSpecified;}	  
private:
	BOOL m_bInit;
	BOOL m_bCommandLineSpecified;
	CString m_strStoreName;
	LONG m_lStoreType;
};

extern CCommandLineOptions commandLineOptions;

//+----------------------------------------------------------------------------
//	Function:  GetDisplayNameFromStoreURL 
//	Synopsis:  Get the display name for the store. 
//	Arguments: strPolicyURL: This is store url in msxml://filepath or
//				 msldap://dn format. 
//			   strDisplayName: This gets the display name. For xml, display 
//			   name is name of file, for AD its name of leaf element
//	Returns:	
//-----------------------------------------------------------------------------
void
GetDisplayNameFromStoreURL(IN const CString& strPolicyURL,
						   OUT CString& strDisplayName);


void
SetXMLStoreDirectory(IN CRoleRootData& roleRootData,
					 IN const CString& strXMLStorePath);
//+----------------------------------------------------------------------------
//  Function:  GetDirectoryFromPath 
//  Synopsis:  Removes the file name from the input file path and return
//             the folder path. For Ex: Input is C:\temp\foo.xml. Return
//             value will be C:\temp\
//-----------------------------------------------------------------------------
CString 
GetDirectoryFromPath(IN const CString& strPath);
//+----------------------------------------------------------------------------
//  Function:  ConvertToExpandedAndAbsolutePath 
//  Synopsis:  Expands the environment variables in the input path and also
//             makes it absolute if necessary.
//-----------------------------------------------------------------------------
void
ConvertToExpandedAndAbsolutePath(IN OUT CString& strPath);

//+----------------------------------------------------------------------------
//  Function:  PreprocessScript 
//  Synopsis:  Script is read from XML file and displayed multi line edit control. 
//             End of line in the XML is indicated by LF instead of CRLF sequence, 
//             however Edit Control requires CRLF sequence to format correctly and 
//             with only LF it displays everything in a single line with a box for 
//             LF char. This function checks if script uses LF for line termination
//             and changes it with CRLF sequence.
//-----------------------------------------------------------------------------
void
PreprocessScript(CString& strScript);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\rolemgr\util.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       headers.h
//
//  Contents:   
//
//  History:    07-26-2001  Hiteshr  Created
//
//----------------------------------------------------------------------------
#include "headers.h"

//+----------------------------------------------------------------------------
//  Function:IsValidStoreType   
//  Synopsis:Vaildates the store type    
//-----------------------------------------------------------------------------
BOOL IsValidStoreType(ULONG lStoreType)
{
    if((lStoreType == AZ_ADMIN_STORE_XML) ||
       (lStoreType == AZ_ADMIN_STORE_AD))
        return TRUE;

    return FALSE;
}


//+----------------------------------------------------------------------------
//  Function: AddColumnToListView  
//  Synopsis: Add Columns to Listview and set column width according to 
//                percentage specified in the COL_FOR_LV                    
//  Arguments:IN pListCtrl: ListCtrl pointer
//                IN pColForLV: Column Infomration Array
//
//  Returns:    
//-----------------------------------------------------------------------------
VOID
AddColumnToListView(IN CListCtrl* pListCtrl,
                    IN COL_FOR_LV* pColForLV)
{
    if(!pListCtrl || !pColForLV)
    {
        ASSERT(pListCtrl);
        ASSERT(pColForLV);
    }

    UINT iTotal = 0;
    RECT rc;
    
    pListCtrl->GetClientRect(&rc);
    
    for( UINT iCol = 0; pColForLV[iCol].idText != LAST_COL_ENTRY_IDTEXT; ++iCol)
    {
        CString strHeader;
        VERIFY(strHeader.LoadString(pColForLV[iCol].idText));
        LV_COLUMN col;
        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (LPWSTR)(LPCTSTR)strHeader;
        col.iSubItem = iCol;

        col.cx = (rc.right * pColForLV[iCol].iPercent) / 100;

        pListCtrl->InsertColumn(iCol,&col);
        iTotal += col.cx;
    }
}

//+----------------------------------------------------------------------------
//  Function: BaseAzInListCtrl  
//  Synopsis: Checks if Object of type eObjectTypeAz named strName is 
//            in the Listview. If its present, returns 
//            its index else returns -1. 
//  Arguments:IN pListCtrl: ListCtrl pointer
//            IN strName: string to search for
//            IN eObjectTypeAz Compare the object of this type only
//
//  Returns:  If its present, returns its index else returns -1
//-----------------------------------------------------------------------------
int 
BaseAzInListCtrl(IN CListCtrl* pListCtrl,
                 IN const CString& strName,
                 IN OBJECT_TYPE_AZ eObjectTypeAz)
{
    if(!pListCtrl)
    {
        ASSERT(pListCtrl);
        return -1;
    }

    int iCount = pListCtrl->GetItemCount();
    for( int i = 0; i < iCount; ++i)
    {
        CBaseAz* pBaseAz = (CBaseAz*)pListCtrl->GetItemData(i);
        if(pBaseAz)
        {
            if((pBaseAz->GetObjectType() == eObjectTypeAz) &&
                (pBaseAz->GetName() == strName))
                return i;
        }
    }
    return -1;
}

//+----------------------------------------------------------------------------
//  Function: AddBaseAzFromListToListCtrl  
//  Synopsis: Take the items from List and Add them to ListCtrl. Doesn't
//            add the items which are already in ListCtrl
//  Arguments:listBaseAz: List of items
//            pListCtrl: ListControl Pointer
//            uiFlags : Column Info
//            bCheckDuplicate: Check for duplicate items
//  Returns: The index of the new item if it is successful; otherwise, -1 
//  NOTE: Function assume the Order of column is Name, Type and Description
//-----------------------------------------------------------------------------
void
AddBaseAzFromListToListCtrl(IN CList<CBaseAz*, CBaseAz*>& listBaseAz,
                            IN CListCtrl* pListCtrl,
                            IN UINT uiFlags,
                            IN BOOL bCheckDuplicate)
{
    //Remember index of selected item
    int iFirstSelectedItem = pListCtrl->GetNextItem(-1, LVIS_SELECTED);
    
    POSITION pos = listBaseAz.GetHeadPosition();

    for (int i = 0; i < listBaseAz.GetCount(); i++)
    {
        CBaseAz* pBaseAz = listBaseAz.GetNext(pos);
            
        //Check if item is in ListControl
        if(!bCheckDuplicate || 
            BaseAzInListCtrl(pListCtrl, 
            pBaseAz->GetName(),
            pBaseAz->GetObjectType()) == -1)
        {
            VERIFY( AddBaseAzToListCtrl(pListCtrl,
                                        pListCtrl->GetItemCount(),
                                        pBaseAz,
                                        uiFlags) != -1);
            
        }
    }
    
    //Restore Selection
    if(pListCtrl->GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;
    
    SelectListCtrlItem(pListCtrl, iFirstSelectedItem);
    
}

//+----------------------------------------------------------------------------
//  Function: AddActionItemFromListToListCtrl  
//  Synopsis: Take the Actions items from List and Add them to ListCtrl. 
//  Arguments:listBaseAz: List of items
//            pListCtrl: ListControl Pointer
//            uiFlags : Column Info
//            bCheckDuplicate: Check for duplicate items
//  Returns: The index of the new item if it is successful; otherwise, -1 
//  NOTE: Function assume the Order of column is Name, Type and Description
//-----------------------------------------------------------------------------
void
AddActionItemFromListToListCtrl(IN CList<ActionItem*, ActionItem*>& listActionItem,
                                IN CListCtrl* pListCtrl,
                                IN UINT uiFlags,
                                IN BOOL bCheckDuplicate)
{
    //Remember index of selected item
    int iFirstSelectedItem = pListCtrl->GetNextItem(-1, LVIS_SELECTED);
    
    POSITION pos = listActionItem.GetHeadPosition();
    for (int i = 0; i < listActionItem.GetCount(); i++)
    {
        ActionItem* pActionItem = listActionItem.GetNext(pos);
        
        if(pActionItem->action == ACTION_REMOVE ||
           pActionItem->action == ACTION_REMOVED)
            continue;
        
        //Check if item is in ListControl
        if(!bCheckDuplicate || 
           BaseAzInListCtrl(pListCtrl, 
           (pActionItem->m_pMemberAz)->GetName(),
           (pActionItem->m_pMemberAz)->GetObjectType()) == -1)
        {
            VERIFY( AddActionItemToListCtrl(pListCtrl,
                                            pListCtrl->GetItemCount(),
                                            pActionItem,
                                            uiFlags) != -1);
            
        }
    }
    
    //Restore Selection
    if(pListCtrl->GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;
    
    SelectListCtrlItem(pListCtrl, iFirstSelectedItem);
    
}

//+----------------------------------------------------------------------------
//  Function: AddActionItemFromMapToListCtrl  
//  Synopsis: Take the Actions items from Map and Add them to ListCtrl. 
//  Arguments:listBaseAz: List of items
//            pListCtrl: ListControl Pointer
//            uiFlags : Column Info
//            bCheckDuplicate: Check for duplicate items
//  Returns: The index of the new item if it is successful; otherwise, -1 
//  NOTE: Function assume the Order of column is Name, Type and Description
//-----------------------------------------------------------------------------
void
AddActionItemFromMapToListCtrl(IN ActionMap& mapActionItem,
                               IN CListCtrl* pListCtrl,
                               IN UINT uiFlags,
                               IN BOOL bCheckDuplicate)
{
    //Remember index of selected item
    int iFirstSelectedItem = pListCtrl->GetNextItem(-1, LVIS_SELECTED);
    
  for (ActionMap::iterator it = mapActionItem.begin();
       it != mapActionItem.end();
       ++it)
    {
        ActionItem* pActionItem = (*it).second;
        
        if(pActionItem->action == ACTION_REMOVE ||
           pActionItem->action == ACTION_REMOVED)
            continue;
        
        //Check if item is in ListControl
        if(!bCheckDuplicate || 
           BaseAzInListCtrl(pListCtrl, 
           (pActionItem->m_pMemberAz)->GetName(),
           (pActionItem->m_pMemberAz)->GetObjectType()) == -1)
        {
            VERIFY( AddActionItemToListCtrl(pListCtrl,
                                            pListCtrl->GetItemCount(),
                                            pActionItem,
                                            uiFlags) != -1);
            
        }
    }
    
    //Restore Selection
    if(pListCtrl->GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;
    
    SelectListCtrlItem(pListCtrl, iFirstSelectedItem);
}   
//+----------------------------------------------------------------------------
//  Function: AddBaseAzToListCtrl  
//  Synopsis: Adds a new item to ListCtrl.
//  Arguments:pListCtrl: ListControl Pointer
//            iIndex:    Index at which to Add
//            pBaseAz: Item to add
//            uiFlags: column info
//  Returns: The index of the new item if it is successful; otherwise, -1 
//-----------------------------------------------------------------------------
int 
AddBaseAzToListCtrl(IN CListCtrl* pListCtrl,
                    IN int iIndex,
                    IN CBaseAz* pBaseAz,
                    IN UINT uiFlags)
{
    if(!pListCtrl || !pBaseAz)
    {
        ASSERT(pListCtrl);
        ASSERT(pBaseAz);
        return -1;
    }

    //Add Name and Item Data
    CString strName = pBaseAz->GetName();
    int iNewIndex = pListCtrl->InsertItem(LVIF_TEXT|LVIF_STATE|LVIF_PARAM|LVIF_IMAGE, 
                                          iIndex,strName,0,0,
                                          pBaseAz->GetImageIndex(),
                                          (LPARAM)pBaseAz);

    if(iNewIndex == -1)
        return iNewIndex;

    int iCol = 1;
    
    if(uiFlags & COL_TYPE )
    {
        CString strType = pBaseAz->GetType();
        pListCtrl->SetItemText(iNewIndex,
                               iCol,
                               (LPWSTR)(LPCTSTR)strType);
        iCol++;
    }

    if(uiFlags & COL_PARENT_TYPE)
    {
        CString strParentType = pBaseAz->GetParentType();
        pListCtrl->SetItemText(iNewIndex,
                               iCol,
                               (LPWSTR)(LPCTSTR)strParentType);
        iCol++;
    }

    if(uiFlags & COL_DESCRIPTION)
    {
        //Add Description
        CString strDesc = pBaseAz->GetDescription();
        pListCtrl->SetItemText(iNewIndex,
                               iCol,
                               (LPWSTR)(LPCTSTR)strDesc);
    }

    return iNewIndex;
}



//+----------------------------------------------------------------------------
//  Function: AddActionItemToListCtrl  
//  Synopsis: Adds a new item to ListCtrl.
//  Arguments:pListCtrl: ListControl Pointer
//            iIndex:    Index at which to Add
//            pActionItem: Item to add
//            uiFlags: column info
//  Returns: The index of the new item if it is successful; otherwise, -1 
//-----------------------------------------------------------------------------
int 
AddActionItemToListCtrl(IN CListCtrl* pListCtrl,
                        IN int iIndex,
                        IN ActionItem* pActionItem,
                        IN UINT uiFlags)
{
    if(!pListCtrl || !pActionItem)
    {
        ASSERT(pListCtrl);
        ASSERT(pActionItem);
        return -1;
    }

    CBaseAz* pBaseAz = pActionItem->m_pMemberAz;

    //Add Name and Item Data
    CString strName = pBaseAz->GetName();
    int iNewIndex = pListCtrl->InsertItem(LVIF_TEXT|LVIF_STATE|LVIF_PARAM|LVIF_IMAGE, 
                                          iIndex, 
                                          strName,
                                          0,0,
                                          pBaseAz->GetImageIndex(),
                                          (LPARAM)pActionItem);

    if(iNewIndex == -1)
        return iNewIndex;

    int iCol = 1;
    
    if(uiFlags & COL_TYPE )
    {
        CString strType = pBaseAz->GetType();
        pListCtrl->SetItemText(iNewIndex,
                               iCol,
                               (LPWSTR)(LPCTSTR)strType);
        iCol++;
    }

    if(uiFlags & COL_PARENT_TYPE)
    {
        CString strParentType = pBaseAz->GetParentType();
        pListCtrl->SetItemText(iNewIndex,
                                     iCol,
                                     (LPWSTR)(LPCTSTR)strParentType);
        iCol++;

    }

    if(uiFlags & COL_DESCRIPTION)
    {
        //Add Description
        CString strDesc = pBaseAz->GetDescription();
        pListCtrl->SetItemText(iNewIndex,
                                     iCol,
                                     (LPWSTR)(LPCTSTR)strDesc);
    }

    return iNewIndex;

}

//+----------------------------------------------------------------------------
//  Function: EnableButtonIfSelectedInListCtrl  
//  Synopsis: Enables the button if something is selected in Listctrl
//  Arguments:
//  Returns: TRUE if Enabled the button, FALSE if didn't. 
//-----------------------------------------------------------------------------
BOOL
EnableButtonIfSelectedInListCtrl(IN CListCtrl * pListCtrl,
                                 IN CButton* pButton)
{
    if(!pListCtrl || !pButton)
    {
        ASSERT(pListCtrl);
        ASSERT(pButton);
        return FALSE;
    }

    int nSelectedItem = pListCtrl->GetNextItem(-1, LVIS_SELECTED);

    if (nSelectedItem != -1)
   {
        pButton->EnableWindow(TRUE);
        return TRUE;
    }
    else
    {
        if(pButton->GetFocus() == pButton)
            pListCtrl->SetFocus();
        pButton->EnableWindow(FALSE);
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//  Function: DeleteSelectedRows  
//  Synopsis: Deletes the selected rows 
//-----------------------------------------------------------------------------
void
DeleteSelectedRows(IN CListCtrl* pListCtrl)
{
    //Remember the Position of first selected entry.
    //In the end set the position back to it
    int iFirstSelectedItem = pListCtrl->GetNextItem(-1, LVIS_SELECTED);

    int iSelectedItem = -1;
    while( (iSelectedItem = pListCtrl->GetNextItem(-1, LVIS_SELECTED)) != -1)
    {
        pListCtrl->DeleteItem(iSelectedItem);
   }

    if(pListCtrl->GetItemCount() <= iFirstSelectedItem)
        --iFirstSelectedItem;

    SelectListCtrlItem(pListCtrl, iFirstSelectedItem);
}


//+----------------------------------------------------------------------------
//  Function: SelectListCtrlItem  
//  Synopsis: Select the item in List Ctrl and mark it visible
//-----------------------------------------------------------------------------
void
SelectListCtrlItem(IN CListCtrl* pListCtrl,
                   IN int iSelected)
{
    if(iSelected == -1)
        iSelected = 0;
    pListCtrl->SetItemState(iSelected,
                            LVIS_SELECTED| LVIS_FOCUSED,
                            LVIS_SELECTED| LVIS_FOCUSED);
    pListCtrl->EnsureVisible(iSelected,FALSE);
}

//+----------------------------------------------------------------------------
//  Function: AddBaseAzItemsFromListCtrlToList  
//  Synopsis: Add items from ListCtrl to List   
//-----------------------------------------------------------------------------
VOID
AddBaseAzItemsFromListCtrlToList(IN CListCtrl* pListCtrl,
                                 OUT CList<CBaseAz*,CBaseAz*>& listBaseAz)
{
    if(!pListCtrl)
    {
        ASSERT(pListCtrl);
        return;
    }

    int iCount = pListCtrl->GetItemCount();
    for( int i = 0; i < iCount; ++i)
    {
        CBaseAz* pBaseAz = (CBaseAz*)pListCtrl->GetItemData(i);
        listBaseAz.AddTail(pBaseAz);
    }
}

//+----------------------------------------------------------------------------
//  Synopsis: Gets long value from Edit box
//  Returns: FALSE if edit box is empty. Assumes only numeric can be entered 
//   in edit box
//-----------------------------------------------------------------------------
GetLongValue(CEdit& refEdit, LONG& reflValue, HWND hWnd)
{
    CString strValue;
    refEdit.GetWindowText(strValue);
    if(strValue.IsEmpty())
    {
        reflValue = 0;
        return TRUE;
    }

    return ConvertStringToLong(strValue, reflValue, hWnd);
}
//+----------------------------------------------------------------------------
//  Synopsis: Sets long value in Edit box
//-----------------------------------------------------------------------------
VOID SetLongValue(CEdit* pEdit, LONG lValue)
{
    //Maximum required size for _itow is 33.
    //When radix is 2, 32 char for 32bits + NULL terminator
                
    WCHAR buffer[33];
    _ltow(lValue,buffer,10);
    pEdit->SetWindowText(buffer);
    return;
}

//+----------------------------------------------------------------------------
//  Synopsis: Converts a sid in binary format to a sid in string format
//-----------------------------------------------------------------------------
BOOL ConvertSidToStringSid(IN PSID pSid, OUT CString* pstrSid)
{
    if(!pSid || !pstrSid)
    {
        ASSERT(pSid);
        ASSERT(pstrSid);
        return FALSE;
    }

    LPWSTR pszSid = NULL;
    if(ConvertSidToStringSid(pSid, &pszSid))
    {
        ASSERT(pszSid);
        *pstrSid = pszSid;
        LocalFree(pszSid);
        return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  Synopsis:  Converts a sid in string format to sid in binary format
//-----------------------------------------------------------------------------
BOOL ConvertStringSidToSid(IN const CString& strSid, OUT PSID *ppSid)
{
    if(!ppSid)
    {
        ASSERT(ppSid);
        return FALSE;
    }
    return ::ConvertStringSidToSid((LPCTSTR)strSid,ppSid);
}

//+----------------------------------------------------------------------------
//  Function:GetStringSidFromSidCachecAz   
//  Synopsis:Gets the string sid from CSidCacheAz object   
//-----------------------------------------------------------------------------
BOOL 
GetStringSidFromSidCachecAz(CBaseAz* pBaseAz,
                            CString* pstrStringSid)
{
    if(!pBaseAz || !pstrStringSid)
    {
        ASSERT(pBaseAz);
        ASSERT(pstrStringSid);
        return FALSE;
    }

    CSidCacheAz *pSidCacheAz = dynamic_cast<CSidCacheAz*>(pBaseAz);
    if(!pSidCacheAz)
    {
        ASSERT(pSidCacheAz);
        return FALSE;
    }

    return ConvertSidToStringSid(pSidCacheAz->GetSid(), pstrStringSid);
}


//+----------------------------------------------------------------------------
//  Function:  AddAzObjectNodesToList 
//  Synopsis:  Adds the nodes for object of type eObjectType to the Container
//             node. 
//  Arguments:IN eObjectType:   Type of object
//            IN listAzChildObject: List of objects to be added
//            IN pContainerNode: Container in snapin to which new nodes will
//                               be added.  
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT 
AddAzObjectNodesToList(IN OBJECT_TYPE_AZ eObjectType,
                       IN CList<CBaseAz*, CBaseAz*>& listAzChildObject,
                       IN CBaseContainerNode* pContainerNode)
{
    if(!pContainerNode)
    {
        ASSERT(pContainerNode);
        return E_POINTER;
    }
    switch (eObjectType)
    {

        case    APPLICATION_AZ:
            return ADD_APPLICATION_FUNCTION::DoEnum(listAzChildObject,pContainerNode);      
        case SCOPE_AZ:
            return ADD_SCOPE_FUNCTION::DoEnum(listAzChildObject,pContainerNode);        
        case GROUP_AZ:
            return ADD_GROUP_FUNCTION::DoEnum(listAzChildObject,pContainerNode);        
        case TASK_AZ:
            return ADD_TASK_FUNCTION::DoEnum(listAzChildObject,pContainerNode);     
        case ROLE_AZ:
            return ADD_ROLE_FUNCTION::DoEnum(listAzChildObject,pContainerNode);     
        case OPERATION_AZ:
            return ADD_OPERATION_FUNCTION::DoEnum(listAzChildObject,pContainerNode);        
    }

    ASSERT(FALSE);
    return E_UNEXPECTED;
}



//
//Error Handling and Message Display Routines
//
VOID
vFormatString(CString &strOutput, UINT nIDPrompt, va_list *pargs)
{
    CString strFormat;
    if(!strFormat.LoadString(nIDPrompt))
        return;
    
    LPWSTR pszResult = NULL;
    
    if(FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                     strFormat,
                     0,
                     0,
                     (LPTSTR)&pszResult,
                     1,
                     pargs) && pszResult)
    {
        strOutput = pszResult;
        LocalFree(pszResult);
    }
    
    return;
}

VOID
FormatString(CString &strOutput, UINT nIDPrompt, ...)
{
    CString strFormat;
    if(!strFormat.LoadString(nIDPrompt))
        return;
    
    va_list args;
    va_start(args, nIDPrompt);
    
    LPWSTR pszResult = NULL;
    
    if(FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                     strFormat,
                     0,
                     0,
                     (LPTSTR)&pszResult,
                     1,
                     &args))
    {
        strOutput = pszResult;
        LocalFree(pszResult);
    }
    
    va_end(args);
    
    return;
}

VOID
GetSystemError(CString &strOutput, DWORD dwErr)
{
    
    LPWSTR pszErrorMsg = NULL;
    
    if( FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
                             NULL,
                             dwErr,
                             MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), 
                             (LPWSTR) &pszErrorMsg,    
                             0,    
                             NULL) && pszErrorMsg)
    {
        strOutput = pszErrorMsg;
        LocalFree(pszErrorMsg);
    }
    else
    {
        strOutput.Format(L"<0x%08x>",dwErr);
    }       
    return;
}


int DisplayMessageBox(HWND hWnd,
                      const CString& strMessage,
                      UINT uStyle)
{   
    CThemeContextActivator activator;

    CString strTitle;
    strTitle.LoadString(IDS_SNAPIN_NAME);
        
    return ::MessageBox(hWnd, strMessage, strTitle, uStyle|MB_TASKMODAL);
}

int FormatAndDisplayMessageBox(HWND hWnd,
                                UINT uStyle,
                                UINT nIDPrompt,
                                va_list &args)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CThemeContextActivator activator;
    
    CString strMessage;
    vFormatString(strMessage,nIDPrompt,&args);
    int iReturn = 0;
    if(!strMessage.IsEmpty())
        iReturn = DisplayMessageBox(hWnd, strMessage,uStyle);
    
    va_end(args);

    return iReturn;
}

void 
DisplayError(HWND hWnd, UINT nIDPrompt, ...)
{
    va_list args;
    va_start(args, nIDPrompt);
    FormatAndDisplayMessageBox(hWnd, MB_OK | MB_ICONERROR,nIDPrompt,args);    
    va_end(args);
}

void 
DisplayInformation(HWND hWnd, UINT nIDPrompt, ...)
{
    va_list args;
    va_start(args, nIDPrompt);
    FormatAndDisplayMessageBox(hWnd, MB_OK | MB_ICONINFORMATION,nIDPrompt,args);    
    va_end(args);
}

void 
DisplayWarning(HWND hWnd, UINT nIDPrompt, ...)
{
    va_list args;
    va_start(args, nIDPrompt);
    FormatAndDisplayMessageBox(hWnd, MB_OK | MB_ICONWARNING, nIDPrompt,args);    
    va_end(args);
}


int 
DisplayConfirmation(HWND hwnd, UINT nIDPrompt,...)
{
    va_list args;
    va_start(args, nIDPrompt);    
    int iReturn = FormatAndDisplayMessageBox(hwnd, MB_YESNO | MB_ICONEXCLAMATION,nIDPrompt,args);    
    va_end(args);    
    return iReturn;
}

BOOL
IsDeleteConfirmed(HWND hwndOwner,
                  CBaseAz& refBaseAz)
{
    CString strType = refBaseAz.GetType();
    strType.MakeLower();            
    return IDYES == DisplayConfirmation(hwndOwner,
                                        IDS_DELETE_CONFIRMATION,
                                        (LPCTSTR)strType,
                                        (LPCTSTR)refBaseAz.GetName());
}

//
//Error Map for object types containing some common error info for 
//each object type
//
ErrorMap ERROR_MAP[] = 
{
    {   ADMIN_MANAGER_AZ,
        IDS_TYPE_ADMIN_MANAGER,
        IDS_ADMIN_MANAGER_NAME_EXIST,
        IDS_ADMIN_MANAGER_NAME_INVAILD,
        L"\\ / : * ? \" < > | [tab]",
    },
    {   APPLICATION_AZ,
        IDS_TYPE_APPLICATION,
        IDS_APPLICATION_NAME_EXIST,
        IDS_APPLICATION_NAME_INVAILD,
        L"\\ / : * ? \" < > | [tab]",
    },
    {   SCOPE_AZ,
        IDS_TYPE_SCOPE,
        IDS_SCOPE_NAME_EXIST,
        IDS_SCOPE_NAME_INVAILD,
        L"",
    },
    {   GROUP_AZ,
        IDS_TYPE_GROUP,
        IDS_GROUP_NAME_EXIST,
        IDS_GROUP_NAME_INVAILD,
        L"\\ / : * ? \" < > | [tab]",
    },
    {   TASK_AZ,
        IDS_TYPE_TASK,
        IDS_TASK_OP_ALREADY_EXIST,
        IDS_TASK_NAME_INVAILD,
        L"\\ / : * ? \" < > | [tab]",
    },
    {   ROLE_AZ,
        IDS_TYPE_ROLE,
        IDS_ROLE_NAME_EXIST,
        IDS_ROLE_NAME_INVAILD,
        L"\\ / : * ? \" < > | [tab]",
    },
    {   OPERATION_AZ,
        IDS_TYPE_OPERATION,
        IDS_TASK_OP_ALREADY_EXIST,
        IDS_OPERATION_NAME_INVAILD,
        L"\\ / : * ? \" < > | [tab]",
    },
};

ErrorMap *GetErrorMap(OBJECT_TYPE_AZ eObjectType)
{
    for(int i = 0; i < ARRAYLEN(ERROR_MAP); ++i)
    {
        if(ERROR_MAP[i].eObjectType == eObjectType)
            return ERROR_MAP + i;
    }
    return NULL;
}


    

//+----------------------------------------------------------------------------
//  Function: GetLSAConnection
//  Synopsis: Wrapper for LsaOpenPolicy  
//-----------------------------------------------------------------------------
LSA_HANDLE
GetLSAConnection(IN const CString& strServer, 
                      IN DWORD dwAccessDesired)
{   
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetLSAConnection)
        
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    
    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;
    
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;
    
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    
    if (!strServer.IsEmpty() && 
        RtlCreateUnicodeString(&uszServer, (LPCTSTR)strServer))
    {
        puszServer = &uszServer;
    }
    
    LSA_HANDLE hPolicy = NULL;
    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);
    
    if (puszServer)
        RtlFreeUnicodeString(puszServer);
    
    return hPolicy;
}


//+----------------------------------------------------------------------------
//  Function:GetFileName   
//  Synopsis:Displays FileOpen dialog box and return file selected by user   
//  Arguments:hwndOwner : owner window
//            bOpen: File must exist
//            nIDTitle : title of open dialog box
//            pszFilter : filter 
//            strFileName : gets selected file name
//
//-----------------------------------------------------------------------------
BOOL
GetFileName(IN HWND hwndOwner,
            IN BOOL bOpen,
            IN INT nIDTitle,
            IN const CString& strInitFolderPath,
            IN LPCTSTR pszFilter,
            IN OUT CString& strFileName)
{

    TRACE_FUNCTION_EX(DEB_SNAPIN,GetFileName)

    OPENFILENAME of;
    ZeroMemory(&of,sizeof(OPENFILENAME));

    WCHAR szFilePathBuffer[MAX_PATH];
    ZeroMemory(szFilePathBuffer,sizeof(szFilePathBuffer));

    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwndOwner;
    of.lpstrFilter = pszFilter;
    of.nFilterIndex = 1;
    of.lpstrFile = szFilePathBuffer;
    of.nMaxFile = MAX_PATH;
    of.lpstrInitialDir = (LPCWSTR)strInitFolderPath;
    if(nIDTitle)
    {
        CString strTitle;
        if(strTitle.LoadString(nIDTitle))
            of.lpstrTitle =  (LPWSTR)(LPCTSTR)strTitle;
    }

    of.Flags = OFN_HIDEREADONLY;
    if(bOpen)
        of.Flags |= (OFN_FILEMUSTEXIST |OFN_PATHMUSTEXIST);

    if(GetOpenFileName(&of))
    {
        strFileName = of.lpstrFile;
        return TRUE;
    }

    return FALSE;
}

int ServerBrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM /*lParam*/, LPARAM lpData)
{
    switch (uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hwnd, BFFM_SETEXPANDED, TRUE, lpData); 
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
            break;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//  Function:GetFolderName   
//  Synopsis:Displays Folder selection dialog box and return folder selected 
//           by user   
//  Arguments:hwndOwner : owner window
//            nIDTitle : title of dialog box
//            strInitBrowseRoot : location of the root folder from which to 
//            start browsing
//            strFolderName : gets selected file name
//-----------------------------------------------------------------------------
BOOL
GetFolderName(IN HWND hwndOwner,
              IN INT nIDTitle,
              IN const CString& strInitBrowseRoot,
              IN OUT CString& strFolderName)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetFolderName)

    BROWSEINFO bi;
    ZeroMemory(&bi,sizeof(bi));

    WCHAR szBuffer[MAX_PATH];
    szBuffer[0] = 0;

    CString strTitle;
    VERIFY(strTitle.LoadString(nIDTitle));

    bi.hwndOwner = hwndOwner;
    bi.pszDisplayName = szBuffer;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;
    bi.lpszTitle = strTitle;
    bi.lpfn = ServerBrowseCallbackProc;  
    bi.lParam = (LPARAM)(LPCWSTR)strInitBrowseRoot;

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if(pidl)
    {
        WCHAR szFolderPath[MAX_PATH];
        if(SHGetPathFromIDList(pidl,szFolderPath))
        {
            PathAddBackslash(szFolderPath);
            strFolderName = szFolderPath;
        }
    }
    
    return !strFolderName.IsEmpty();
}

//+----------------------------------------------------------------------------
//  Function:GetADContainerPath   
//  Synopsis:Displays a dialog box to allow for selecting a AD container   
//-----------------------------------------------------------------------------
BOOL
GetADContainerPath(HWND hWndOwner,
                   ULONG nIDCaption,
                   ULONG nIDTitle,
                   CString& strPath,
                   CADInfo& refAdInfo)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetADContainerPath)

    HRESULT hr = refAdInfo.GetRootDSE(); 
    CHECK_HRESULT(hr);

    if(FAILED(hr))
    {
        DisplayError(hWndOwner,IDS_CANNOT_ACCESS_AD);
        return FALSE;
    }


    CString strRootDomainPath;
    if(!refAdInfo.GetRootDomainDn().IsEmpty())
    {       
        if(!refAdInfo.GetRootDomainDCName().IsEmpty())
        {
            strRootDomainPath = L"LDAP://" + 
                                refAdInfo.GetRootDomainDCName() + 
                                L"/" + 
                                refAdInfo.GetRootDomainDn();
        }
        else
        {
            strRootDomainPath = L"LDAP://" + refAdInfo.GetRootDomainDn();
        }
    }

    
    DSBROWSEINFOW dsbrowse;
    ZeroMemory(&dsbrowse,sizeof(dsbrowse));
    dsbrowse.cbStruct = sizeof(dsbrowse);

    //Set Root of search to forest root
    if(!strRootDomainPath.IsEmpty())
        dsbrowse.pszRoot = (LPCTSTR)strRootDomainPath;

    //Construct the path to which tree will expand on opening of
    //dialog box
    CString strInitialPath;
    GetDefaultADContainerPath(refAdInfo,TRUE,TRUE,strInitialPath);

    WCHAR szPath[MAX_PATH];
    ZeroMemory(szPath,sizeof(szPath));
    
    if(!strInitialPath.IsEmpty() && MAX_PATH > strInitialPath.GetLength())
    {
        wcscpy(szPath,(LPCTSTR)strInitialPath);
    }
    
    dsbrowse.hwndOwner = hWndOwner;
    CString strCaption;
    if(nIDCaption)
    {
        strCaption.LoadString(nIDCaption);
        dsbrowse.pszCaption = strCaption;
    }

    CString strTitle;
    if(nIDTitle)
    {
        strTitle.LoadString(nIDTitle);
        dsbrowse.pszTitle = strTitle;
    }

    dsbrowse.pszPath = szPath;
    dsbrowse.cchPath = MAX_PATH;
    dsbrowse.dwFlags = DSBI_ENTIREDIRECTORY|DSBI_RETURN_FORMAT|DSBI_INCLUDEHIDDEN|DSBI_EXPANDONOPEN;
    dsbrowse.dwReturnFormat = ADS_FORMAT_X500_NO_SERVER;

    BOOL bRet = FALSE;
    BOOL iRet = 0;
    iRet = DsBrowseForContainer(&dsbrowse);
    if(IDOK == iRet)
    {
        //Path contains LDAP:// string which we don't want
        size_t nLen = wcslen(g_szLDAP);
        if(_wcsnicmp(dsbrowse.pszPath,g_szLDAP,nLen) == 0 )
            strPath = (dsbrowse.pszPath + nLen);
        else
            strPath = dsbrowse.pszPath;
        bRet = TRUE;
    }
    else if (-1 == iRet)
    {
        Dbg(DEB_SNAPIN, "DsBrowseForContainer Failed\n");
        DisplayError(hWndOwner,IDS_CANNOT_ACCESS_AD);       
    }

    return bRet;
}


//+----------------------------------------------------------------------------
//  Function:CompareBaseAzObjects   
//  Synopsis:Compares two baseaz objects for equivalance. If two pAzA and pAzB
//           are two different instances of same coreaz object, they are equal   
//-----------------------------------------------------------------------------
BOOL 
CompareBaseAzObjects(CBaseAz* pAzA, CBaseAz* pAzB)
{
    if(pAzA == pAzB)
        return TRUE;

    if(!pAzA || !pAzB)
        return FALSE;
    
        
    if(!(pAzA->GetObjectType() == pAzB->GetObjectType() &&
       pAzA->GetName() == pAzB->GetName()))

       return FALSE;

    //If object if of type AdminManager, it must be same node
    if(pAzA->GetObjectType() == ADMIN_MANAGER_AZ)
        return (pAzA == pAzB);


    //Two objects with same name and object type can exist under different
    //parent-> Check if their parents are same->

    if(pAzA->GetParentAz()->GetName() == pAzB->GetParentAz()->GetName())
        return TRUE;

    return FALSE;
}


//+----------------------------------------------------------------------------
//
//Below Code maps dialog box id to Help Map
//Ported from DNS Manager
//
//-----------------------------------------------------------------------------
#include "HelpMap.H"
#define BEGIN_HELP_MAP(map) static DWORD_PTR map[] = {
#define HELP_MAP_ENTRY(x)   x, (DWORD_PTR)&g_aHelpIDs_##x ,
#define END_HELP_MAP         0, 0 };


#define NEXT_HELP_MAP_ENTRY(p) ((p)+2)
#define MAP_ENTRY_DLG_ID(p) (*p)
#define MAP_ENTRY_TABLE(p) ((DWORD*)(*(p+1)))
#define IS_LAST_MAP_ENTRY(p) (MAP_ENTRY_DLG_ID(p) == 0)



BEGIN_HELP_MAP(AuthManContextHelpMap)
    HELP_MAP_ENTRY(IDD_ADD_GROUP)
    HELP_MAP_ENTRY(IDD_ADD_OPERATION)
    HELP_MAP_ENTRY(IDD_ADD_ROLE_DEFINITION)
    HELP_MAP_ENTRY(IDD_ADD_TASK)
    HELP_MAP_ENTRY(IDD_ADMIN_MANAGER_ADVANCED_PROPERTY)
    HELP_MAP_ENTRY(IDD_ADMIN_MANAGER_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_APPLICATION_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_AUDIT)
    HELP_MAP_ENTRY(IDD_GROUP_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_GROUP_LDAP_QUERY)
    HELP_MAP_ENTRY(IDD_GROUP_MEMBER)
    HELP_MAP_ENTRY(IDD_GROUP_NON_MEMBER)
    HELP_MAP_ENTRY(IDD_NEW_APPLICATION)
    HELP_MAP_ENTRY(IDD_NEW_AUTHORIZATION_STORE)
    HELP_MAP_ENTRY(IDD_NEW_GROUP)
    HELP_MAP_ENTRY(IDD_NEW_OPERATION)
    HELP_MAP_ENTRY(IDD_NEW_ROLE_DEFINITION)
    HELP_MAP_ENTRY(IDD_NEW_SCOPE)
    HELP_MAP_ENTRY(IDD_NEW_TASK)
    HELP_MAP_ENTRY(IDD_OPEN_AUTHORIZATION_STORE)
    HELP_MAP_ENTRY(IDD_OPERATION_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_ROLE_DEFINITION_PROPERTY)
    HELP_MAP_ENTRY(IDD_SCOPE_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_ROLE_DEFINITION_PROPERTY)
    HELP_MAP_ENTRY(IDD_SECURITY)
    HELP_MAP_ENTRY(IDD_TASK_DEFINITION_PROPERTY)
    HELP_MAP_ENTRY(IDD_TASK_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_ROLE_DEFINITION_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_ROLE_GENERAL_PROPERTY)
    HELP_MAP_ENTRY(IDD_ROLE_DEF_DIALOG)
    HELP_MAP_ENTRY(IDD_BROWSE_AD_STORE)
    HELP_MAP_ENTRY(IDD_SCRIPT)
    HELP_MAP_ENTRY(IDD_ADD_ROLE_DEFINITION_1)
END_HELP_MAP


//+----------------------------------------------------------------------------
//  Function:FindDialogContextTopic   
//  Synopsis:Finds the helpmap for a given dialog id   
//-----------------------------------------------------------------------------
BOOL 
FindDialogContextTopic(IN UINT nDialogID,
                       OUT DWORD_PTR* pMap)
{
    if(!pMap)
    {
        ASSERT(pMap);
        return FALSE;
    }

    const DWORD_PTR* pMapEntry = AuthManContextHelpMap;
    while (!IS_LAST_MAP_ENTRY(pMapEntry))
    {
        if (nDialogID == MAP_ENTRY_DLG_ID(pMapEntry))
        {
            DWORD_PTR pTable = (DWORD_PTR)MAP_ENTRY_TABLE(pMapEntry);
            ASSERT(pTable);
            *pMap = pTable;
            return TRUE;
        }
        pMapEntry = NEXT_HELP_MAP_ENTRY(pMapEntry);
    }
    return FALSE;
}


//+----------------------------------------------------------------------------
//  Function:CanReadOneProperty   
//  Synopsis:Function tries to read IsWriteable property. If that fails displays
//           an error message. This is used before adding property pages.    
//           if we cannot read IsWritable property,thereisn't much hope.
//-----------------------------------------------------------------------------
BOOL CanReadOneProperty(LPCWSTR pszName,
                        CBaseAz* pBaseAz)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,CanReadOneProperty)

    if(!pBaseAz)
    {
        ASSERT(pBaseAz);
        return FALSE;
    }

    BOOL bWrite;
    HRESULT hr = pBaseAz->IsWritable(bWrite);
    if(SUCCEEDED(hr))
    {
        return TRUE;
    }
    else
    {
        if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE))
        {
            DisplayError(NULL,
                         IDS_PROP_ERROR_OBJECT_DELETED,
                         pszName);

        }
        else
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
            DisplayError(NULL,
                         IDS_GENERIC_PROP_DISPLAY_ERROR,
                         (LPCWSTR)strError,
                         pszName);

        }
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//  Function: ListCompareProc  
//  Synopsis: Comparison function used by list control  
//-----------------------------------------------------------------------------
int CALLBACK
ListCompareProc(LPARAM lParam1,
                LPARAM lParam2,
                LPARAM lParamSort)
{
    int iResult = CSTR_EQUAL;

    if(!lParam1 || !lParam2 || !lParamSort)
    {
        ASSERT(lParam1);
        ASSERT(lParam2);
        ASSERT(lParamSort);
        return iResult;
    }

    CompareInfo *pCompareInfo = (CompareInfo*)lParamSort;
    
    CBaseAz* pBaseAz1 = NULL;
    CBaseAz* pBaseAz2 = NULL;

    if(pCompareInfo->bActionItem)
    {
        pBaseAz1 = ((ActionItem*)lParam1)->m_pMemberAz;
        pBaseAz2 = ((ActionItem*)lParam2)->m_pMemberAz;
    }
    else
    {
        pBaseAz1 = (CBaseAz*)lParam1;
        pBaseAz2 = (CBaseAz*)lParam2;
    }
    

    CString str1;
    CString str2;

    int iColType = -1;
    int iColParentType = -1;
    int iColDescription = -1;
    
    int iCol = 1;
    if(pCompareInfo->uiFlags & COL_TYPE )
    {
        iColType = iCol++;
    }
    if(pCompareInfo->uiFlags & COL_PARENT_TYPE)
    {
        iColParentType = iCol++;
    }
    if(pCompareInfo->uiFlags & COL_DESCRIPTION)
    {
        iColDescription = iCol++;
    }

    if (pBaseAz1 && pBaseAz2)
    {
        if(pCompareInfo->iColumn == 0)
        {
            str1 = pBaseAz1->GetName();
            str2 = pBaseAz2->GetName();
        }
        else if(pCompareInfo->iColumn == iColType)
        {
            str1 = pBaseAz1->GetType();
            str2 = pBaseAz2->GetType();
        }
        else if(pCompareInfo->iColumn == iColDescription)
        {
            str1 = pBaseAz1->GetDescription();
            str2 = pBaseAz2->GetDescription();
        }
        else if(pCompareInfo->iColumn == iColParentType)
        {
            str1 = pBaseAz1->GetParentType();
            str2 = pBaseAz2->GetParentType();
        }

        iResult = CompareString(LOCALE_USER_DEFAULT, 0, str1, -1, str2, -1) - 2;        
        iResult *= pCompareInfo->iSortDirection;
    }

    return iResult;
}

//+----------------------------------------------------------------------------
//  Function:SortListControl   
//  Synopsis:Sorts a list control
//  Arguments:pListCtrl: List control to sort
//            iColumnClicked: column clicked
//            iSortDirection: direction in which to sort
//            uiFlags:  column info
//            bActionItem: if item in list is actionitem
//-----------------------------------------------------------------------------
void
SortListControl(CListCtrl* pListCtrl,
                int iColumnClicked,
                int iSortDirection,
                UINT uiFlags,
                BOOL bActionItem)
{
    if(!pListCtrl)
    {
        ASSERT(pListCtrl);
        return;
    }

    CompareInfo compareInfo;
    compareInfo.bActionItem = bActionItem;
    compareInfo.iColumn = iColumnClicked;
    compareInfo.iSortDirection = iSortDirection;
    compareInfo.uiFlags = uiFlags;
    pListCtrl->SortItems(ListCompareProc,
                        (DWORD_PTR)&compareInfo);    
}

//+----------------------------------------------------------------------------
//  Synopsis: Ensures that selection in listview control is visible
//-----------------------------------------------------------------------------
void
EnsureListViewSelectionIsVisible(CListCtrl *pListCtrl)
{
    ASSERT(pListCtrl);

    int iSelected = pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    if (-1 != iSelected)
        pListCtrl->EnsureVisible(iSelected, FALSE);
}


//+----------------------------------------------------------------------------
//  Synopsis:Convert input number in string format to long. if number is out
//           of range displays a message.   
//-----------------------------------------------------------------------------
BOOL 
ConvertStringToLong(LPCWSTR pszInput, 
                    long &reflongOutput,
                    HWND hWnd)
{
    if(!pszInput)
    {
        ASSERT(pszInput);
        return FALSE;
    }
    //
    //Get the Max len of long
    long lMaxLong = LONG_MAX;
    WCHAR szMaxLongBuffer[34];
    _ltow(lMaxLong,szMaxLongBuffer,10);
    size_t nMaxLen = wcslen(szMaxLongBuffer);

    //
    //Get the length of input
    LPCWSTR pszTempInput = pszInput;
    if(pszInput[0] == L'-')
    {
        pszTempInput++;
    }

    //
    //Length of input greater than length of Max Long, than 
    //input is out of range.
    size_t nInputLen = wcslen(pszTempInput);
    if(nInputLen > nMaxLen)
    {
        if(hWnd)
        {
            DisplayError(hWnd,IDS_GREATER_THAN_MAX_LONG,pszTempInput,szMaxLongBuffer);
        }
        return FALSE;
    }

    //
    //Convert input to int64 and check its less that max integer
    //
    __int64 i64Input = _wtoi64(pszTempInput);
    if(i64Input > (__int64)lMaxLong)
    {
        if(hWnd)
        {
            DisplayError(hWnd,IDS_GREATER_THAN_MAX_LONG,pszTempInput,szMaxLongBuffer);
        }
        return FALSE;
    }
    //
    //Value is good
    //
    reflongOutput = _wtol(pszInput);
    return TRUE;
}

VOID 
SetSel(CEdit& refEdit)
{
    refEdit.SetFocus();
    refEdit.SetSel(0,-1);
}

//+----------------------------------------------------------------------------
//  Function:  ValidateStoreTypeAndName 
//  Synopsis:  Validates the user entered AD Store Name
//  Arguments: strName: User entered store name to verify
//  Returns:   TRUE if name is valid else false 
//-----------------------------------------------------------------------------
BOOL
ValidateStoreTypeAndName(HWND hWnd,
                         LONG ulStoreType,
                         const CString& strName)
{

    TRACE_FUNCTION_EX(DEB_SNAPIN,ValidateStoreTypeAndName)

    //Store Name is not entered in the valid format. We should come here only 
    //when store name is entered at the command line. 
    if((AZ_ADMIN_STORE_INVALID == ulStoreType) ||
        strName.IsEmpty())
    {
        DisplayError(hWnd,IDS_INVALIDSTORE_ON_COMMANDLINE);
        return FALSE;
    }

    //No validation is required for XML Store
    if(ulStoreType == AZ_ADMIN_STORE_XML)
    {
        return TRUE;
    }

    ASSERT(ulStoreType == AZ_ADMIN_STORE_AD);
    BOOL bRet = FALSE;
    PDS_NAME_RESULT pResult = NULL;
    do
    {
        //Get the store name with LDAP:// prefix
        CString strFormalName;
        NameToStoreName(AZ_ADMIN_STORE_AD,
                        strName,
                        TRUE,
                        strFormalName);

        Dbg(DEB_SNAPIN, "AD store name entered is: %ws\n", CHECK_NULL(strFormalName));

        CComPtr<IADsPathname> spPathName;
        HRESULT hr = spPathName.CoCreateInstance(CLSID_Pathname,
                                                 NULL,
                                                 CLSCTX_INPROC_SERVER);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = spPathName->Set(CComBSTR(strFormalName),
                             ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);


        //Get the DN entered by user
        CComBSTR bstrDN;
        hr = spPathName->Retrieve(ADS_FORMAT_X500_DN,&bstrDN);
        BREAK_ON_FAIL_HRESULT(hr);


        if(bstrDN.Length() == 0)
        {
            Dbg(DEB_SNAPIN, "spPathName->Retrieve returned 0 len DN\n");
            break;
        }

        //Do a syntactical crack for the DN to see if its a valid DN
        LPCWSTR pszName = bstrDN;

        if( DsCrackNames(NULL,
                         DS_NAME_FLAG_SYNTACTICAL_ONLY,
                         DS_FQDN_1779_NAME,
                         DS_CANONICAL_NAME,
                         1,
                         &pszName,
                         &pResult) != DS_NAME_NO_ERROR)
        {
            Dbg(DEB_SNAPIN, "DsCrackName failed to crack the name");
            break;
        }

        ASSERT(pResult);
        
        if(pResult->rItems->status == DS_NAME_NO_ERROR)
        {
            bRet = TRUE;
        }
    }while(0);
    
    if(pResult)
        DsFreeNameResult(pResult);
    
    if(!bRet)
    {
        DisplayError(hWnd,IDS_INVALID_AD_STORE_NAME);
    }

    return bRet;
}

//+----------------------------------------------------------------------------
//  Function:  NameToFormatStoreName
//  Synopsis:  Converts user entered name to format which core understands
//  Arguments: ulStoreType: Type of store
//             strName: User entered store name 
//             bUseLDAP:use LDAP string to format AD name instead msldap
//             strFormalName: gets the output ldap name
//-----------------------------------------------------------------------------
void
NameToStoreName(IN LONG lStoreType,
                IN const CString& strName,              
                IN BOOL bUseLDAP,
                OUT CString& strFormalName)
{
    strFormalName.Empty();

    if(lStoreType == AZ_ADMIN_STORE_XML)
    {
        if(_wcsnicmp(strName,g_szMSXML,wcslen(g_szMSXML)) == 0 )
        {
            strFormalName = strName;
        }
        else
        {
            strFormalName = g_szMSXML + strName;
        }
        return;
    }
    else if(lStoreType == AZ_ADMIN_STORE_AD)
    {
        LPCWSTR lpcszPrefix = bUseLDAP ? g_szLDAP : g_szMSLDAP;
        LPCWSTR lpcszOtherPrefix = bUseLDAP ? g_szMSLDAP  : g_szLDAP;

        if(_wcsnicmp(strName,lpcszPrefix,wcslen(lpcszPrefix)) == 0 )
        {
            strFormalName = strName;
        }
        else
        {
            size_t nlen = wcslen(lpcszOtherPrefix);
            //Check if user has put other prefix in the name
            if(_wcsnicmp(strName,lpcszOtherPrefix,nlen) == 0 )
            {
                strFormalName = lpcszPrefix + strName.Right(strName.GetLength() - (int)nlen);
            }
            else
            {
                strFormalName = lpcszPrefix + strName;
            }
        }
        return;
    }

    ASSERT(FALSE);
    return;
}


void
TrimWhiteSpace(CString& str)
{
    str.TrimLeft(L"\t ");
    str.TrimRight(L"\t ");
}

BOOL
TranslateNameFromDnToDns(const CString& strInputDN,
                         CString& strOutputDNS)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,TranslateNameFromDnToDns)
    
    if(strInputDN.IsEmpty())
        return FALSE;

    strOutputDNS.Empty();
    
    Dbg(DEB_SNAPIN, "DN of Forest is %ws\n", (LPCWSTR)strInputDN);

    LPCWSTR pstrName = strInputDN;
    PDS_NAME_RESULT pResult;
    if( DS_NAME_NO_ERROR
        == DsCrackNames(NULL,
                        DS_NAME_FLAG_SYNTACTICAL_ONLY,
                        DS_FQDN_1779_NAME,
                        DS_CANONICAL_NAME,
                        1,
                        (LPWSTR*)(&pstrName),
                        &pResult))
    {
        if(pResult && 
           pResult->cItems == 1 && 
           pResult->rItems[0].status  == DS_NAME_NO_ERROR &&
           pResult->rItems[0].pDomain)
        {           
            strOutputDNS = pResult->rItems[0].pDomain;
            Dbg(DEB_SNAPIN, "DNS of Forest is %ws\n", (LPCWSTR)strOutputDNS);
        }

        if(pResult)
        {
            DsFreeNameResult(pResult);
        }
    }
    return !strOutputDNS.IsEmpty();
}


//+----------------------------------------------------------------------------
//  Function:GetSearchObject   
//  Synopsis:Get IDirectorySearch object to search at forest   
//-----------------------------------------------------------------------------
HRESULT 
GetSearchObject(IN CADInfo& refAdInfo,
                OUT CComPtr<IDirectorySearch>& refspSearchObject)
{   
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetSearchObject)
        
    HRESULT hr = S_OK;
    do
    {   
        //
        hr = refAdInfo.GetRootDSE();
        BREAK_ON_FAIL_HRESULT(hr);
       
        const CString& strForestDNS = refAdInfo.GetRootDomainDnsName();

        CString strGCPath = L"GC://";
        strGCPath += strForestDNS;
        

        //
        //Get IDirectorySearch Object
        //
        hr = AzRoleAdsOpenObject((LPWSTR)(LPCWSTR)strGCPath,        
                                 NULL,                     
                                 NULL,                     
                                 IID_IDirectorySearch,                       
                                 (void**)&refspSearchObject);
        
        BREAK_ON_FAIL_HRESULT(hr);

    }while(0);

    return hr;
}


//
// Attributes that we want the Object Picker to retrieve
//
static const LPCTSTR g_aszOPAttributes[] =
{
    TEXT("distinguishedName"),
};
        
//+----------------------------------------------------------------------------
//  Function:GetListOfAuthorizationStore   
//  Synopsis:Search at GC for AD policy stores and returns list.   
//-----------------------------------------------------------------------------
HRESULT
GetListOfAuthorizationStore(IN CADInfo& refAdInfo,
                            OUT CList<CString,CString> &strList)
{
    HRESULT hr = S_OK;
    
    //If List is not empty, empty it
    while(!strList.IsEmpty())
        strList.RemoveHead();

    do
    {
        TIMER("Time to search GC for AD Stores");

        CComPtr<IDirectorySearch> spSearchObject;
        CString str;
        hr = GetSearchObject(refAdInfo,
                             spSearchObject);
        BREAK_ON_FAIL_HRESULT(hr);

        CDSSearch searchObject(spSearchObject);
        searchObject.SetFilterString((LPWSTR)g_pszAuthorizationStoreQueryFilter);
        searchObject.SetAttributeList((LPWSTR*)g_aszOPAttributes,1);
        
        hr = searchObject.DoQuery();
        BREAK_ON_FAIL_HRESULT(hr);
        
        int iIndex = 0;
        while(TRUE)
        {
            hr = searchObject.GetNextRow();
                
            //We are done
            if(hr == S_ADS_NOMORE_ROWS)
            {
                hr = S_OK;
                break;
            }
            BREAK_ON_FAIL_HRESULT(hr);
            
            ADS_SEARCH_COLUMN ColumnData;
            hr = searchObject.GetColumn((LPWSTR)g_aszOPAttributes[0], &ColumnData);
            if(SUCCEEDED(hr))
            {
                ASSERT(ADSTYPE_DN_STRING == ColumnData.dwADsType);
                strList.AddTail(ColumnData.pADsValues->DNString);
                searchObject.FreeColumn(&ColumnData);
            }               
        }//End of while loop
    }while(0);

    if(!strList.IsEmpty())
        return S_OK;

    return hr;
}


/******************************************************************************
Class:  CBaseAddDialog
Purpose:Displays a dialog box with list of AD Policy stores
******************************************************************************/
class CBrowseADStoreDlg : public CHelpEnabledDialog
{
public:
    CBrowseADStoreDlg(CList<CString,CString>&strList,
                      CString& strSelectedADStorePath)
                      :CHelpEnabledDialog(IDD_BROWSE_AD_STORE),
                      m_strList(strList),
                      m_strSelectedADStorePath(strSelectedADStorePath)
    {
    }
    
    virtual BOOL 
    OnInitDialog();
    
    virtual void 
    OnOK();
private:
    CList<CString,CString> &m_strList;
    CString& m_strSelectedADStorePath;
};

BOOL
CBrowseADStoreDlg::
OnInitDialog()
{
    CListCtrl* pListCtrl = (CListCtrl*)GetDlgItem(IDC_LIST);
    ASSERT(pListCtrl);
    //
    //Initialize the list control
    //
    ListView_SetImageList(pListCtrl->GetSafeHwnd(),
                          LoadImageList(::AfxGetInstanceHandle (), 
                                        MAKEINTRESOURCE(IDB_ICONS)),
                                        LVSIL_SMALL);


    //Add ListBox Extended Style
    pListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT |
                                LVS_EX_INFOTIP);

    //Add List box Columns
    AddColumnToListView(pListCtrl,Col_For_Browse_ADStore_Page);

    POSITION pos = m_strList.GetHeadPosition();
    for (int i=0;i < m_strList.GetCount();i++)
    {
        pListCtrl->InsertItem(LVIF_TEXT|LVIF_STATE|LVIF_IMAGE, 
                              i,
                              m_strList.GetNext(pos),
                              0,
                              0,
                              iIconStore,
                              NULL);

    }
    
    return TRUE;
}

void
CBrowseADStoreDlg::
OnOK()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CBrowseADStoreDlg,OnOK)
    CListCtrl* pListCtrl = (CListCtrl*)GetDlgItem(IDC_LIST);
    int iSelected = -1;
    if((iSelected = pListCtrl->GetNextItem(-1, LVIS_SELECTED)) != -1)
    {
        m_strSelectedADStorePath = pListCtrl->GetItemText(iSelected,0);
    }
    CHelpEnabledDialog::OnOK();
}

//+----------------------------------------------------------------------------
//  Function:BrowseAdStores   
//  Synopsis:Displays a dialog box with list of AD stores available.   
//  Arguments:strDN: Gets the selected ad store name
//-----------------------------------------------------------------------------
void
BrowseAdStores(IN HWND hwndOwner,
               OUT CString& strDN,
               IN CADInfo& refAdInfo)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,BrowseAdStores)

    CList<CString,CString> strList;
    if(SUCCEEDED(GetListOfAuthorizationStore(refAdInfo,
                                            strList)))
    {
        if(!strList.IsEmpty())
        {
            CBrowseADStoreDlg dlg(strList,strDN);
            dlg.DoModal();
        }
        else
        {
            DisplayInformation(hwndOwner,
                               IDS_NO_AD_STORE);
        }
    }
    else
    {
        //Display Error
        DisplayError(hwndOwner,
                     IDS_CANNOT_ACCESS_AD);
    }
}

    






//+----------------------------------------------------------------------------
//  Function:LoadIcons   
//  Synopsis:Adds icons to imagelist   
//-----------------------------------------------------------------------------
HRESULT
LoadIcons(LPIMAGELIST pImageList)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,LoadIcons)
    if(!pImageList)
    {
        ASSERT(pImageList);
        return E_POINTER;
    }

    struct RESID2IICON
    {
        UINT uIconId;   // Icon resource ID
        int iIcon;      // Index of the icon in the image list
    };
    const static RESID2IICON rgzLoadIconList[] =
    {
        {IDI_UNKNOWN_SID,       iIconUnknownSid},
        {IDI_COMPUTER,          iIconComputerSid},
        {IDI_GROUP,             iIconGroup},
        //iIconLocalGroup,      //This is not used, but since its in the imagelist
        //                      //i added an entry here
        {IDI_USER,              iIconUser,},
        { IDI_BASIC_GROUP,      iIconBasicGroup},
        { IDI_LDAP_GROUP,       iIconLdapGroup},
        { IDI_OPERATION,        iIconOperation},
        { IDI_TASK,             iIconTask},
        { IDI_ROLE_DEFINITION,  iIconRoleDefinition},
        { IDI_STORE,            iIconStore},
        { IDI_APP,              iIconApplication},
        { IDI_ROLE,             iIconRole},
        { IDI_ROLE_SNAPIN,      iIconRoleSnapin},
        { IDI_SCOPE,            iIconScope},
        { IDI_CONTAINER,        iIconContainer},
        { 0, 0} // Must be last
    };


    for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
    {
        HICON hIcon = 
            ::LoadIcon (AfxGetInstanceHandle (),
                        MAKEINTRESOURCE (rgzLoadIconList[i].uIconId));
        ASSERT (hIcon && "Icon ID not found in resources");
        
        pImageList->ImageListSetIcon ((PLONG_PTR) hIcon,
                                       rgzLoadIconList[i].iIcon);
    }
    
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function: LoadImageList  
//  Synopsis: Loads image list  
//-----------------------------------------------------------------------------
HIMAGELIST
LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID)
{
    HIMAGELIST himl = NULL;
    HBITMAP hbm = LoadBitmap(hInstance, pszBitmapID);

    if (hbm != NULL)
    {
        BITMAP bm;
        GetObject(hbm, sizeof(BITMAP), &bm);

        himl = ImageList_Create(bm.bmHeight,    // height == width
                                bm.bmHeight,
                                ILC_COLOR | ILC_MASK,
                                bm.bmWidth / bm.bmHeight,
                                0);  // don't need to grow
        if (himl != NULL)
            ImageList_AddMasked(himl, hbm, CLR_DEFAULT);

        DeleteObject(hbm);
    }

    return himl;
}

//+----------------------------------------------------------------------------
//  Function: AddExtensionToFileName  
//  Synopsis: Functions adds .xml extension to name of file if no extension 
//            is present.  
//  Arguments:
//  Returns:    
//-----------------------------------------------------------------------------
VOID
AddExtensionToFileName(IN OUT CString& strFileName)
{
    if(strFileName.IsEmpty())
        return;

    //if the last char is "\" don't do anything
    if((strFileName.ReverseFind(L'\\') + 1) == strFileName.GetLength())
        return;
    
    int iLastDot = strFileName.ReverseFind(L'.');
    if(iLastDot != -1)
    {
        //if there are three chars after last dot,
        //file has extension. Index returned is zero based
        if(strFileName.GetLength() == (iLastDot + 3 + 1))
            return;
    }

    //File doesn't have extension. Add extension to the file.
    strFileName += g_pszFileStoreExtension;
}

//+----------------------------------------------------------------------------
//  Function: GetFileExtension  
//  Synopsis: Get the extension of the file.
//-----------------------------------------------------------------------------
BOOL
GetFileExtension(IN const CString& strFileName,
                 OUT CString& strExtension)
{
    if(strFileName.IsEmpty())
        return FALSE;


    //Find the position of last dot 
    int iLastDot = strFileName.ReverseFind(L'.');
    if(iLastDot != -1)
    {
        strExtension = strFileName.Right(strFileName.GetLength() - (iLastDot+1));
        return TRUE;
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//  Function:GetCurrentWorkingDirectory
//  Synopsis:Gets the current working directory   
//-----------------------------------------------------------------------------
BOOL
GetCurrentWorkingDirectory(IN OUT CString& strCWD)
{   
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetCurrentWorkingDirectory)

    strCWD.Empty();
    LPWSTR pszBuffer = NULL;
    
    do
    {
        int nLen = 0;
        WCHAR szBuffer[MAX_PATH];

        if((nLen = GetCurrentDirectory(MAX_PATH,szBuffer)) != 0)
        {
            //If the return value is less than MAX_PATH, function
            //was successful. If its greater, buffer is not big enough,
            //dynamically allocate it below.
            if(nLen < MAX_PATH)
            {
                strCWD = szBuffer;
                break;
            }

            //Bigger buffer is required
            pszBuffer = new WCHAR[nLen];
            if(pszBuffer)
            {
                if((nLen = GetCurrentDirectory(nLen,pszBuffer)) != 0)
                {
                    strCWD = pszBuffer;
                    break;
                }
            }
        }
    }while(0);//FALSE LOOP

    if(pszBuffer)
        delete [] pszBuffer;

    //Add \ at the end of string
    if(!strCWD.IsEmpty() && 
       ((strCWD.ReverseFind(L'\\') + 1) != strCWD.GetLength()))
    {
        strCWD += L'\\';
    }


    return !strCWD.IsEmpty();
}

VOID
RemoveItemsFromActionMap(ActionMap& mapActionItem)
{
  for (ActionMap::iterator it = mapActionItem.begin();
       it != mapActionItem.end();
       ++it)
    {
        delete (*it).second;
    }
}

/******************************************************************************
Class:  CADInfo
Purpose:Keeps a cache of Active Directory info avoiding multiple binds
******************************************************************************/

HRESULT
CADInfo::
GetRootDSE()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetRootDSE)
    HRESULT hr = S_OK;
    if(m_spRootDSE == NULL)
    {
        //
        //Bind to RootDSE
        //
        hr = AzRoleAdsOpenObject(L"LDAP://RootDSE",     
                                 NULL,                     
                                 NULL,
                                 IID_IADs,                       
                                 (void**)&m_spRootDSE);     
        CHECK_HRESULT(hr);
    }

    return hr;
}

const CString&
CADInfo::GetDomainDnsName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetDomainDnsName)
    if(m_strDomainDnsName.IsEmpty())
    {
        if(m_strDomainDn.IsEmpty())
            GetDomainDn();

        if(!m_strDomainDn.IsEmpty())
        {
            TranslateNameFromDnToDns(m_strDomainDn,m_strDomainDnsName);
            Dbg(DEB_SNAPIN, "Domain Dns is: %ws\n", CHECK_NULL((LPCTSTR)m_strDomainDnsName));
        }
    }
    return m_strDomainDnsName;
}

const CString&
CADInfo::GetDomainDn()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetDomainDn)

    if((m_spRootDSE != NULL) && m_strDomainDn.IsEmpty())
    {
        // Get the default name
        VARIANT Default;
        VariantInit(&Default);
        HRESULT hr = m_spRootDSE->Get (CComBSTR(L"defaultNamingContext"), &Default);
        if(SUCCEEDED(hr))
        {
            ASSERT(VT_BSTR == Default.vt);
            if(VT_BSTR == Default.vt)
            {
                m_strDomainDn = Default.bstrVal;
                ::VariantClear(&Default);
        
                Dbg(DEB_SNAPIN, "Domain Dn is: %ws\n", CHECK_NULL((LPCTSTR)m_strDomainDn));
            }
        }
    }
    return m_strDomainDn;
}


const CString&
CADInfo::GetRootDomainDnsName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetRootDomainDnsName)
    if(m_strRootDomainDnsName.IsEmpty())
    {
        if(m_strRootDomainDn.IsEmpty())
            GetRootDomainDn();

        if(!m_strRootDomainDn.IsEmpty())
        {
            TranslateNameFromDnToDns(m_strRootDomainDn,m_strRootDomainDnsName);
            Dbg(DEB_SNAPIN, "Root Domain Dns is: %ws\n", CHECK_NULL((LPCTSTR)m_strRootDomainDnsName));
        }
    }
    return m_strRootDomainDnsName;
}

const CString&
CADInfo::GetRootDomainDn()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetRootDomainDn)
    if((m_spRootDSE != NULL) && m_strRootDomainDn.IsEmpty())
    {
        // Get the default name
        VARIANT Default;
        VariantInit(&Default);
        HRESULT hr = m_spRootDSE->Get(CComBSTR(L"rootDomainNamingContext"), &Default);
        if(SUCCEEDED(hr))
        {
            //Convert DN to DNS name 
            m_strRootDomainDn = Default.bstrVal;
            ::VariantClear(&Default);
            
            Dbg(DEB_SNAPIN, "Root Domain DN is: %ws\n", CHECK_NULL((LPCTSTR)m_strRootDomainDn));
        }
    }

    return m_strRootDomainDn;
}

BOOL GetDcNameForDomain(IN const CString& strDomainName,
                        OUT CString& strDCName)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetDcNameForDomain)
    if(strDomainName.IsEmpty())
    {
        return FALSE;
    }

    strDCName.Empty();

    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    //Get the DC Name
    DWORD dwErr = DsGetDcName(NULL,
                              (LPCWSTR)strDomainName,
                              NULL,
                              NULL,
                              DS_IS_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED,
                              &pDomainInfo);
    if((ERROR_SUCCESS == dwErr) && pDomainInfo)
    {
        LPWSTR pszDCName = pDomainInfo->DomainControllerName;
        
        //The returned computer name is prefixed with \\
        //Remove backslashes
        if(pszDCName[0] == L'\\' && pszDCName[1] == L'\\')
            pszDCName += 2;
        
        //If a DNS-style name is returned, it is terminated with a period,
        //indicating that the returned name is an absolute (non-relative)
        //DNS name. 
        //We don't need period, remove it
        
        //DomainControllerName is in DNS format.
        if(pDomainInfo->Flags & DS_DNS_CONTROLLER_FLAG)
        {
            size_t dwLen = wcslen(pszDCName);
            if(dwLen && (L'.' == pszDCName[dwLen -1]))
            {
                pszDCName[dwLen -1] = L'\0';
            }
        }
        Dbg(DEB_SNAPIN, "DC is %ws\n", pszDCName);        
        strDCName = pszDCName;        
        NetApiBufferFree(pDomainInfo);
        return TRUE;
    }
    
    return FALSE;
}

const CString&
CADInfo::
GetRootDomainDCName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetRootDomainDCName)

    if((m_spRootDSE != NULL) && m_strRootDomainDcName.IsEmpty())
    {
        GetDcNameForDomain(GetRootDomainDnsName(),m_strRootDomainDcName);
    }
    
    return m_strRootDomainDcName;
}

const CString&
CADInfo::
GetDomainDCName()
{
    TRACE_METHOD_EX(DEB_SNAPIN,CADInfo,GetDomainDCName)
    
    if((m_spRootDSE != NULL) && m_strDomainDcName.IsEmpty())
    {
        
        GetDcNameForDomain(GetDomainDnsName(),m_strDomainDcName);
    }
    
    return m_strDomainDcName;
}

//+--------------------------------------------------------------------------
//  Function:   AzRoleAdsOpenObject
//  Synopsis:   A thin wrapper around ADsOpenObject
//+--------------------------------------------------------------------------
HRESULT AzRoleAdsOpenObject(LPWSTR lpszPathName, 
                            LPWSTR lpszUserName, 
                            LPWSTR lpszPassword, 
                            REFIID riid, 
                            VOID** ppObject,
                            BOOL bBindToServer)
{
    static DWORD additionalFlags = GetADsOpenObjectFlags();
    DWORD dwFlags = ADS_SECURE_AUTHENTICATION | additionalFlags;

    if (bBindToServer)
    {
        //
        // If we know we are connecting to a specific server and not domain in general
        // then pass the ADS_SERVER_BIND flag to save ADSI the trouble of figuring it out
        //
        dwFlags |= ADS_SERVER_BIND;
    }


    //
    //Get IDirectorySearch Object
    //
    return ADsOpenObject(lpszPathName,      
                         lpszUserName,                     
                         lpszPassword,                     
                         additionalFlags,                        
                         riid,                       
                         ppObject);
}

VOID
GetDefaultADContainerPath(IN CADInfo& refAdInfo,
                          IN BOOL bAddServer,
                          IN BOOL bAddLdap,
                          OUT CString& strPath)
{
    strPath.Empty();
    if(!refAdInfo.GetDomainDn().IsEmpty())
    {
        if(!refAdInfo.GetDomainDCName().IsEmpty())
        {
            if(bAddLdap)
            {
                strPath += L"LDAP://";
            }
            if(bAddServer)
            {
                strPath += refAdInfo.GetDomainDCName();
                strPath += L"/";
            }
            strPath += g_pszProgramDataPrefix;
            strPath += refAdInfo.GetDomainDn();
        }
        else
        {
            if(bAddLdap)
            {
                strPath = L"LDAP://";
            }
            strPath += g_pszProgramDataPrefix;
            strPath += refAdInfo.GetDomainDn();
        }
    }
}

//+--------------------------------------------------------------------------
//  Function:   IsBizRuleWritable
//  Synopsis:   Checks if bizrules are writable for this object
//+--------------------------------------------------------------------------
BOOL
IsBizRuleWritable(HWND hWnd, CContainerAz& refBaseAz)
{
	CScopeAz* pScopeAz = dynamic_cast<CScopeAz*>(&refBaseAz);
	//Bizrules are always writable for at
	//application level
	if(!pScopeAz)
	{
		return TRUE;
	}

	BOOL bBizRuleWritable = TRUE;
	HRESULT hr = pScopeAz->BizRulesWritable(bBizRuleWritable);
	if(SUCCEEDED(hr) && !bBizRuleWritable)
	{
		DisplayInformation(hWnd, 
						   IDS_BIZRULE_NOT_ALLOWED,
						   pScopeAz->GetName());
		return FALSE;
	}

	return TRUE;
}


//+--------------------------------------------------------------------------
//  Function:   ParseStoreURL
//  Synopsis:   Extracts the store name and type from a store url
//              store url are in format msldap://DN or msxml://filepath
//+--------------------------------------------------------------------------
void
ParseStoreURL(IN const CString& strStoreURL,
              OUT CString& refstrStoreName,
              OUT LONG& reflStoreType)
{
    if(_wcsnicmp(strStoreURL,g_szMSXML,wcslen(g_szMSXML)) == 0 )
    {
        reflStoreType = AZ_ADMIN_STORE_XML;
        refstrStoreName = strStoreURL.Mid((int)wcslen(g_szMSXML));        
    }
    else if(_wcsnicmp(strStoreURL,g_szMSLDAP,wcslen(g_szMSLDAP)) == 0 )
    {
        reflStoreType = AZ_ADMIN_STORE_AD;
        refstrStoreName = strStoreURL.Mid((int)wcslen(g_szMSLDAP));
    }
    else
    {
        reflStoreType = AZ_ADMIN_STORE_INVALID;
        refstrStoreName = strStoreURL;
    }
}


/******************************************************************************
Class:  CCommandLineOptions
Purpose:class for reading the command line options for console file
******************************************************************************/
void 
CCommandLineOptions::
Initialize()
{
	TRACE_METHOD_EX(DEB_SNAPIN,CCommandLineOptions,Initialize)
    
    //This should be called only once
    if(m_bInit)
    {
        return;
    }

    m_bInit = TRUE;

    // see if we have command line arguments
    
    // Count of arguments
    int cArgs = 0;					
    // Array of pointers to string
    LPCWSTR * lpServiceArgVectors = (LPCWSTR *)CommandLineToArgvW(GetCommandLineW(), 
                                                        &cArgs);
    if (lpServiceArgVectors == NULL || cArgs <= 2)
    {
        // none, just return
        return;
    }

    m_bCommandLineSpecified = TRUE;
    CString strStoreURL = lpServiceArgVectors[2];
    ParseStoreURL(strStoreURL,
                  m_strStoreName,
                  m_lStoreType);

    Dbg(DEB_SNAPIN, "Store URL Name entered at commandline is %ws\n", CHECK_NULL(strStoreURL));
    Dbg(DEB_SNAPIN, "Store Name entered at commandline is %ws\n", CHECK_NULL(m_strStoreName));
    Dbg(DEB_SNAPIN, "AD store type entered is: %u\n", m_lStoreType);
}


//+----------------------------------------------------------------------------
//  Function:  OpenAdminManager 
//  Synopsis:  Open an existing Authorization Store adds 
//              corresponding adminManager object to snapin 
//  Arguments:IN hWnd: Handle of window for dialog box
//            IN bOpenFromSavedConsole: True if open is in response to a console 
//              file.
//            IN lStoreType: XML or AD
//            IN strName:   Name of store
//            IN strScriptDir : Script directory
//            IN pRootData: Snapin Rootdata
//            IN pComponentData: ComponentData
//  Returns:    
//-----------------------------------------------------------------------------
HRESULT OpenAdminManager(IN HWND hWnd,
                         IN BOOL bOpenFromSavedConsole,
                         IN ULONG lStoreType,
                         IN const CString& strStoreName,
                         IN const CString& strScriptDir,
                         IN CRootData* pRootData,
                         IN CComponentDataObject* pComponentData)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,OpenAdminManager)
    if(!pRootData || !pComponentData)
    {
        ASSERT(pRootData);
        ASSERT(pComponentData);
        return E_POINTER;
    }

   //NTRAID#NTBUG9-706617-2002/07/17-hiteshr Our validation code cannot validate
    //ADAM dn. Do not do any validation.

    ////Vaidate the store name
    //if(!ValidateStoreTypeAndName(hWnd,
    //                            lStoreType,
    //                            strStoreName))
    //{
    //    return E_INVALIDARG;
    //}

     
    HRESULT hr = OpenCreateAdminManager(FALSE,
                                        bOpenFromSavedConsole,
                                        lStoreType,
                                        strStoreName,
                                        L"",
                                        strScriptDir,
                                        pRootData,
                                        pComponentData);
                                         
    if(FAILED(hr))
    {
        //Display Error
        if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            if(!bOpenFromSavedConsole)
            {
                ::DisplayError(hWnd, 
                               IDS_ADMIN_MANAGER_NOT_FOUND,
                               (LPCTSTR)strStoreName);
            }
            else
            {
                ::DisplayError(hWnd, 
                               IDS_CANNOT_FIND_AUTHORIZATION_STORE,
                               (LPCTSTR)strStoreName);

            }
        }       
        else if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_NAME))
        {
            ErrorMap * pErrorMap = GetErrorMap(ADMIN_MANAGER_AZ);
            ::DisplayError(hWnd,
                           pErrorMap->idInvalidName,
                           pErrorMap->pszInvalidChars);            
        }
        else
        {
            //Display Generic Error
            CString strError;
            GetSystemError(strError, hr);   
            ::DisplayError(hWnd,
                           IDS_OPEN_ADMIN_MANAGER_GENERIC_ERROR,
                           (LPCTSTR)strError);
                                

        }
    }   

    return hr;
}

//+----------------------------------------------------------------------------
//  Function:  GetDisplayNameFromStoreURL 
//  Synopsis:  Get the display name for the store. 
//  Arguments: strPolicyURL: This is store url in msxml://filepath or
//               msldap://dn format. 
//             strDisplayName: This gets the display name. For xml, display 
//             name is name of file, for AD its name of leaf element
//  Returns:    
//-----------------------------------------------------------------------------
void
GetDisplayNameFromStoreURL(IN const CString& strPolicyURL,
                           OUT CString& strDisplayName)
{
    //Store URL format has msxml:// or msldap:// prefix
    //Get the store name without any prefix
    CString strStorePath;
    LONG lStoreType;
    ParseStoreURL(strPolicyURL,
                  strStorePath,
                  lStoreType);

    //Default Display Name of store is path without prefix.
    strDisplayName = strStorePath;
    
    if(AZ_ADMIN_STORE_INVALID == lStoreType)
    {
        ASSERT(FALSE);
        return;
    }

    //For XML store, display name is name of the file
    if(AZ_ADMIN_STORE_XML == lStoreType)
    {
        strDisplayName = PathFindFileName(strStorePath);
    }
    //For AD store, display name is name of the leaf element
    else
    {
        do
        {
            CComPtr<IADsPathname> spPathName;
            HRESULT hr = spPathName.CoCreateInstance(CLSID_Pathname,
                                                     NULL,
                                                     CLSCTX_INPROC_SERVER);
            BREAK_ON_FAIL_HRESULT(hr);

            //The path which we have right now can be dn or server/dn.
            //append LDAP:// to it.
            CString strLDAPStorePath = g_szLDAP + strStorePath;

            hr = spPathName->Set(CComBSTR(strLDAPStorePath),
                                 ADS_SETTYPE_FULL);
            BREAK_ON_FAIL_HRESULT(hr);

            //Get the leaf element. This will return leaf element in the 
            //format cn=foo. We only want "foo".
            CComBSTR bstrLeaf;
            hr = spPathName->Retrieve(ADS_FORMAT_LEAF ,&bstrLeaf);
            BREAK_ON_FAIL_HRESULT(hr);
            
            if(bstrLeaf.Length())
            {
                strDisplayName = bstrLeaf;
                strDisplayName.Delete(0,strDisplayName.Find(L'=') + 1);
            }
        }while(0);
    }
}

void
SetXMLStoreDirectory(IN CRoleRootData& roleRootData,
                     IN const CString& strXMLStorePath)
{
    CString strXMLStoreDirectory = GetDirectoryFromPath(strXMLStorePath);
    roleRootData.SetXMLStorePath(strXMLStoreDirectory);
}

//+----------------------------------------------------------------------------
//  Function:  GetDirectoryFromPath 
//  Synopsis:  Removes the file name from the input file path and return
//             the folder path. For Ex: Input is C:\temp\foo.xml. Return
//             value will be C:\temp\
//-----------------------------------------------------------------------------
CString 
GetDirectoryFromPath(IN const CString& strPath)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,GetDirectoryFromPath)
    Dbg(DEB_SNAPIN, "Input path", CHECK_NULL(strPath));

    CString strDir;
    if(strPath.GetLength() < MAX_PATH) 
    {
        WCHAR szPath[MAX_PATH];
        HRESULT hr = StringCchCopy(szPath,MAX_PATH,(LPCWSTR)strPath);
        if(FAILED(hr))
            return strDir;
        
        if(!PathRemoveFileSpec(szPath))
            return strDir;

        PathAddBackslash(szPath);

        strDir = szPath;        
    }
    Dbg(DEB_SNAPIN, "Output Dir", CHECK_NULL(strDir));
    return strDir;
}

//+----------------------------------------------------------------------------
//  Function:  ConvertToExpandedAndAbsolutePath 
//  Synopsis:  Expands the environment variables in the input path and also
//             makes it absolute if necessary.
//-----------------------------------------------------------------------------
void
ConvertToExpandedAndAbsolutePath(IN OUT CString& strPath)
{
    TRACE_FUNCTION_EX(DEB_SNAPIN,ConvertToExpandedAndAbsolutePath)
    Dbg(DEB_SNAPIN, "Input name", CHECK_NULL(strPath));
    do
    {
        //
        //Expand evironment variables in the path
        //

        WCHAR szExpandedPath[MAX_PATH];
        DWORD dwSize = ExpandEnvironmentStrings(strPath,
                                                szExpandedPath,
                                                MAX_PATH);

        //Buffer is small, allocate required buffer and try again
        if(dwSize > MAX_PATH)
        {
            LPWSTR pszExpandedPath = (LPWSTR)LocalAlloc(LPTR,dwSize*sizeof(WCHAR));
            if(pszExpandedPath)
            {
                dwSize = ExpandEnvironmentStrings(strPath,
                                                  pszExpandedPath,
                                                  dwSize);
                if(dwSize)
                {
                    strPath = pszExpandedPath;
                }

                LocalFree(pszExpandedPath);
                pszExpandedPath = NULL;

                if(!dwSize)
                {
                    break;
                }
            }
        }
        else if(dwSize)
        {
            strPath = szExpandedPath;
        }
        else
        {
            break;
        }


        //Make absolute path
        WCHAR szAbsolutePath[MAX_PATH];
        dwSize = GetFullPathName(strPath,
                                 MAX_PATH,
                                 szAbsolutePath,
                                 NULL);
         //Buffer is small
        if(dwSize > MAX_PATH)
        {
            LPWSTR pszAbsolutePath = (LPWSTR)LocalAlloc(LPTR,dwSize*sizeof(WCHAR));
            if(pszAbsolutePath)
            {
                dwSize = GetFullPathName(strPath,
                                         MAX_PATH,
                                         pszAbsolutePath,
                                         NULL);                                         
                if(dwSize)
                {
                    strPath = pszAbsolutePath;
                }

                LocalFree(pszAbsolutePath);
                pszAbsolutePath = NULL;
            }
        }
        else if(dwSize)
        {
            strPath = szAbsolutePath;
        }      
    }while(0);
    Dbg(DEB_SNAPIN, "Output name", CHECK_NULL(strPath));
}
//+----------------------------------------------------------------------------
//  Function:  PreprocessScript 
//  Synopsis:  Script is read from XML file and displayed multi line edit control. 
//             End of line in the XML is indicated by LF instead of CRLF sequence, 
//             however Edit Control requires CRLF sequence to format correctly and 
//             with only LF it displays everything in a single line with a box for 
//             LF char. This function checks if script uses LF for line termination
//             and changes it with CRLF sequence.
//-----------------------------------------------------------------------------
void
PreprocessScript(CString& strScript)
{

    WCHAR chLF = 0x0a;
    WCHAR szCRLF[3] = {0x0D, 0x0A, 0};

    if(strScript.Find(chLF) != -1 && strScript.Find(szCRLF) == -1)
    {
        CString strProcessedScript;

        int len = strScript.GetLength();
        for( int i = 0; i < len; ++i)
        {
            WCHAR ch = strScript.GetAt(i);
            if(ch == chLF)
            {
                strProcessedScript += szCRLF;
            }
            else
            {
                strProcessedScript += ch;
            }
        }
        strScript = strProcessedScript;
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\aclpage.cpp ===
#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(aclpage.cpp)")
#include "dataobj.h"
#include "compdata.h"
#include "cookie.h"
#include "snapmgr.h"
#include "schmutil.h"
#include "cache.h"
#include "relation.h"
#include "attrpage.h"
#include "advui.h"
#include "aclpage.h"
#include "ntsecapi.h"  
#include "sddlp.h"


HRESULT
GetDomainSid(LPCWSTR pszLdapPath, PSID *ppSid);

//
// CDynamicLibraryBase
// This is the base class for CDSSecDll and CAclUiDll.
// This was taken from the dnsmgr snap in.
//

class CDynamicLibraryBase {

public:

    CDynamicLibraryBase() {
        m_lpszLibraryName = NULL;
        m_lpszFunctionName = NULL;
        m_hLibrary = NULL;
        m_pfFunction = NULL;
    }

    virtual ~CDynamicLibraryBase() {

        if ( m_hLibrary != NULL ) {
            ::FreeLibrary(m_hLibrary);
            m_hLibrary = NULL;
        }
    }

    //
    // Load a DLL and get a single entry point.
    //

    BOOL Load() {

        if (m_hLibrary != NULL)
            return TRUE; // already loaded

         ASSERT(m_lpszLibraryName != NULL);
         m_hLibrary = ::LoadLibrary(m_lpszLibraryName);

         if (NULL == m_hLibrary) {
             // The library is not present
             return FALSE;
         }

         ASSERT(m_lpszFunctionName != NULL);
         ASSERT(m_pfFunction == NULL);

         m_pfFunction = ::GetProcAddress(m_hLibrary, m_lpszFunctionName );
         if ( NULL == m_pfFunction ) {
             // The library is present but does not have the entry point
             ::FreeLibrary( m_hLibrary );
             m_hLibrary = NULL;
             return FALSE;
         }

         ASSERT(m_hLibrary != NULL);
         ASSERT(m_pfFunction != NULL);
         return TRUE;
    }


protected:

    LPCSTR  m_lpszFunctionName;
    LPCTSTR m_lpszLibraryName;
    FARPROC m_pfFunction;
    HMODULE m_hLibrary;
};

//
// CDsSecDLL - Holds the wrapper for the ACL editor wrapper.
//

class CDsSecDLL : public CDynamicLibraryBase {

public:

    CDsSecDLL() {
        m_lpszLibraryName = _T("dssec.dll");
        m_lpszFunctionName = "DSCreateISecurityInfoObject";
    }

    HRESULT DSCreateISecurityInfoObject( LPCWSTR pwszObjectPath,              // in
                                         LPCWSTR pwszObjectClass,             // in
                                         DWORD   dwFlags,                     // in
                                         LPSECURITYINFO* ppISecurityInfo,     // out
                                         PFNREADOBJECTSECURITY pfnReadSd,     // in
                                         PFNWRITEOBJECTSECURITY pfnWriteSd,   // in
                                         LPARAM lpContext );                  // in
};

HRESULT
CDsSecDLL::DSCreateISecurityInfoObject( LPCWSTR pwszObjectPath,           // in
                                        LPCWSTR pwszObjectClass,          // in
                                        DWORD   dwFlags,                  // in
                                        LPSECURITYINFO* ppISecurityInfo,  // out
                                        PFNREADOBJECTSECURITY pfnReadSd,  // in
                                        PFNWRITEOBJECTSECURITY pfnWriteSd,// in
                                        LPARAM lpContext                  // in
) {

    //
    // Call the function of the same name.
    //

    ASSERT(m_hLibrary != NULL);
    ASSERT(m_pfFunction != NULL);
    return ((PFNDSCREATEISECINFO)m_pfFunction)(
                                                 pwszObjectPath,
                                                 pwszObjectClass,
                                                 dwFlags,
                                                 ppISecurityInfo,
                                                 pfnReadSd,
                                                 pfnWriteSd,
                                                 lpContext );
}

//
// CAclUiDLL - Where the UI Actually Lives.
//

class CAclUiDLL : public CDynamicLibraryBase {

public:

    CAclUiDLL() {
        m_lpszLibraryName = _T("aclui.dll");
        m_lpszFunctionName = "CreateSecurityPage";
    }

    HPROPSHEETPAGE CreateSecurityPage( LPSECURITYINFO psi );
};

HPROPSHEETPAGE CAclUiDLL::CreateSecurityPage( LPSECURITYINFO psi ) {
    ASSERT(m_hLibrary != NULL);
    ASSERT(m_pfFunction != NULL);
    return ((ACLUICREATESECURITYPAGEPROC)m_pfFunction) (psi);
}

//
// CISecurityInformationWrapper - The wrapper for the routine that gets
// sent to CreateSecurityPage().
//

class CISecurityInformationWrapper : public ISecurityInformation {

public:

    CISecurityInformationWrapper( CAclEditorPage* pAclEditorPage ) {
        m_dwRefCount = 0;
        ASSERT(pAclEditorPage != NULL);
        m_pAclEditorPage = pAclEditorPage;
        m_pISecInfo = NULL;
    }

    ~CISecurityInformationWrapper() {
        ASSERT(m_dwRefCount == 0);
        if (m_pISecInfo != NULL)
            m_pISecInfo->Release();
    }

public:

    //
    // *** IUnknown methods ***
    // Call through to the to actual SecurityInformation interface.
    //

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj) {
        return m_pISecInfo->QueryInterface(riid, ppvObj);
    }

    STDMETHOD_(ULONG,AddRef) () {
        m_dwRefCount++;
        return m_pISecInfo->AddRef();
    }

    STDMETHOD_(ULONG,Release) () {

        m_dwRefCount--;

        ISecurityInformation* pISecInfo = m_pISecInfo;

        return pISecInfo->Release();
    }

    //
    // *** ISecurityInformation methods ***
    // These are also call through.
    //

    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) {
		HRESULT hr = m_pISecInfo->GetObjectInformation(pObjectInfo);
		if (m_szPageTitle.IsEmpty())
		{
			m_szPageTitle.LoadString(IDS_DEFAULT_SECURITY);
		}
		pObjectInfo->dwFlags |= SI_PAGE_TITLE;
		pObjectInfo->pszPageTitle = (PWSTR)(PCWSTR)m_szPageTitle;
        return hr;
    }

    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess ) {
        return m_pISecInfo->GetAccessRights(pguidObjectType,
                                            dwFlags,
                                            ppAccess,
                                            pcAccesses,
                                            piDefaultAccess);
    }

    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask) {
        return m_pISecInfo->MapGeneric(pguidObjectType,
                                       pAceFlags,
                                       pMask);
    }

    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes ) {
        return m_pISecInfo->GetInheritTypes(ppInheritTypes,
                                            pcInheritTypes);
    }

    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage ) {
        return m_pISecInfo->PropertySheetPageCallback(hwnd, uMsg, uPage);
    }

    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault) {
        return m_pISecInfo->GetSecurity( RequestedInformation,
                                         ppSecurityDescriptor,
                                         fDefault );
    }

    STDMETHOD(SetSecurity) (SECURITY_INFORMATION securityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) {

        return m_pISecInfo->SetSecurity( securityInformation,
                                         pSecurityDescriptor );
    }

private:

    DWORD m_dwRefCount;
    ISecurityInformation* m_pISecInfo;      // interface pointer to the wrapped interface
    CAclEditorPage* m_pAclEditorPage;       // back pointer
	CString m_szPageTitle;
    friend class CAclEditorPage;
};


//
// Static instances of the dynamically loaded DLLs.
//

CDsSecDLL g_DsSecDLL;
CAclUiDLL g_AclUiDLL;

//
// CAclEditorPage Routines.
//

HRESULT
CAclEditorPage::CreateInstance(
    CAclEditorPage ** ppAclPage,
    LPCTSTR lpszLDAPPath,
    LPCTSTR lpszObjectClass
) {

    HRESULT         hr  = S_OK;

    CAclEditorPage* pAclEditorPage = new CAclEditorPage;

    if (pAclEditorPage != NULL) {
        
        hr = pAclEditorPage->Initialize( lpszLDAPPath, lpszObjectClass );
        
        if ( SUCCEEDED(hr) )
        {
            *ppAclPage = pAclEditorPage;
        }
        else
        {
            delete pAclEditorPage;
            pAclEditorPage = NULL;
        }
    }
    else
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );

    return hr;
}

CAclEditorPage::CAclEditorPage() {
    m_pISecInfoWrap = new CISecurityInformationWrapper(this);
}

CAclEditorPage::~CAclEditorPage() {
    delete m_pISecInfoWrap;
}

HRESULT
ReadSecurity( LPCWSTR lpszLdapPath,
              SECURITY_INFORMATION RequestedInformation,
              PSECURITY_DESCRIPTOR *ppSecDesc,
              LPARAM lpContext );

HRESULT
WriteSecurity( LPCWSTR lpszLdapPath,
               SECURITY_INFORMATION securityInformation,
               PSECURITY_DESCRIPTOR pSecDesc,
               LPARAM lpContext );

HRESULT
GetObjectSecurityDescriptor( LPCWSTR                 lpszLdapPath,
                             PSECURITY_DESCRIPTOR  * ppSecDesc,
                             IADs                 ** ppIADsObject = NULL );


    
HRESULT
CAclEditorPage::Initialize(
    LPCTSTR lpszLDAPPath,
    LPCTSTR lpszObjectClass
) {

    //
    // Get ISecurityInfo* for this object from DSSEC.DLL
    //

    if (!g_DsSecDLL.Load())
        return E_INVALIDARG;

    ASSERT(m_pISecInfoWrap->m_pISecInfo == NULL);

    return g_DsSecDLL.DSCreateISecurityInfoObject( lpszLDAPPath,
                                                   lpszObjectClass,
                                                   DSSI_NO_ACCESS_CHECK | DSSI_NO_EDIT_OWNER |
                                                     ( IsReadOnly(lpszLDAPPath) ? DSSI_READ_ONLY : 0 ),
                                                   &(m_pISecInfoWrap->m_pISecInfo),
                                                   ReadSecurity,
                                                   WriteSecurity,
                                                   0 );
}

HPROPSHEETPAGE CAclEditorPage::CreatePage() {

    ASSERT(m_pISecInfoWrap->m_pISecInfo != NULL);

    if (!g_AclUiDLL.Load())
        return NULL;

    //
    // Call into ACLUI.DLL to create the page
    // passing the wrapper interface.
    //

    return g_AclUiDLL.CreateSecurityPage(m_pISecInfoWrap);
}



HRESULT
ReadSecurity(
   LPCWSTR                 lpszLdapPath,
   SECURITY_INFORMATION    /*RequestedInformation*/,    // ignoring...
   PSECURITY_DESCRIPTOR*   ppSecDesc,
   LPARAM                  /*lpContext*/)
{
    return GetObjectSecurityDescriptor( lpszLdapPath,
                                        ppSecDesc );
}



#define BREAK_ON_FAILED_BOOL(fResult)                             \
   if ( !fResult )                                                \
   {                                                              \
      ASSERT( FALSE );                                            \
      break;                                                      \
   }


const SECURITY_INFORMATION ALL_SECURITY_INFORMATION  =  OWNER_SECURITY_INFORMATION |
                                                        GROUP_SECURITY_INFORMATION |
                                                        DACL_SECURITY_INFORMATION |
                                                        SACL_SECURITY_INFORMATION;

HRESULT
WriteSecurity(
              LPCWSTR              lpszLdapPath,
              SECURITY_INFORMATION securityInformation,
              PSECURITY_DESCRIPTOR pModificationDescriptor,
              LPARAM               /*lpContext*/)
{
    HRESULT                 hr          = S_OK;
    BOOL                    fResult     = TRUE;
    IADs                  * pIADsObject = NULL;
    PSECURITY_DESCRIPTOR    pSecDesc    = NULL;
    LPWSTR                  pstrSecDesc = NULL;

    
    const UINT cAbsoluteSecDescSize = 5;
    
    struct
    {
        PVOID   pData;
        DWORD   dwDataSize;

    } absSecDesc[cAbsoluteSecDescSize];

    const PSECURITY_DESCRIPTOR  & pAbsSecDesc = (PSECURITY_DESCRIPTOR) absSecDesc[0].pData;

    ZeroMemory( absSecDesc, sizeof(absSecDesc) );

    // we only support changes in DACL & SACL
    ASSERT( securityInformation & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION) );
    ASSERT( IsValidSecurityDescriptor(pModificationDescriptor) );

    do
    {
        hr = GetObjectSecurityDescriptor( lpszLdapPath,
                                          &pSecDesc,
                                          &pIADsObject );
        BREAK_ON_FAILED_HRESULT(hr);
        ASSERT(pIADsObject);

        
        fResult = MakeAbsoluteSD( pSecDesc,
                    (PSECURITY_DESCRIPTOR) absSecDesc[0].pData, &absSecDesc[0].dwDataSize,
                    (PACL) absSecDesc[1].pData, &absSecDesc[1].dwDataSize,
                    (PACL) absSecDesc[2].pData, &absSecDesc[2].dwDataSize,
                    (PSID) absSecDesc[3].pData, &absSecDesc[3].dwDataSize,
                    (PSID) absSecDesc[4].pData, &absSecDesc[4].dwDataSize );

        ASSERT( !fResult );     // the call must fail the first time
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if( ERROR_INSUFFICIENT_BUFFER != HRESULT_CODE(hr) )
            BREAK_ON_FAILED_HRESULT(hr);

        fResult = TRUE;
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );

        // allocate memory for the security descriptor
        for( UINT i = 0;  i < cAbsoluteSecDescSize;  i++ )
            if( absSecDesc[i].dwDataSize > 0 )
                if( NULL == (absSecDesc[i].pData = new BYTE[ absSecDesc[i].dwDataSize ]) )
                    break;// NTRAID#NTBUG9-540268-2002/02/13-dantra Out of memory condition masked when building the SECURITY_DESCRIPTOR
                    
        hr = S_OK;

        fResult = MakeAbsoluteSD( pSecDesc,
                    (PSECURITY_DESCRIPTOR) absSecDesc[0].pData, &absSecDesc[0].dwDataSize,
                    (PACL) absSecDesc[1].pData, &absSecDesc[1].dwDataSize,
                    (PACL) absSecDesc[2].pData, &absSecDesc[2].dwDataSize,
                    (PSID) absSecDesc[3].pData, &absSecDesc[3].dwDataSize,
                    (PSID) absSecDesc[4].pData, &absSecDesc[4].dwDataSize );

        BREAK_ON_FAILED_BOOL( fResult );


        // for convinience, have another reference.
        ASSERT( absSecDesc[0].pData == pAbsSecDesc );
        ASSERT( IsValidSecurityDescriptor(pAbsSecDesc) );
       

        // Apply DACL changes
        if( securityInformation & DACL_SECURITY_INFORMATION )
        {
            BOOL                        bDaclPresent    = FALSE;
            PACL                        pDacl           = NULL;
            BOOL                        bDaclDefaulted  = FALSE;
            SECURITY_DESCRIPTOR_CONTROL control         = 0;
            DWORD                       dwRevision      = 0;

            fResult = GetSecurityDescriptorDacl( pModificationDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorDacl( pAbsSecDesc, bDaclPresent, pDacl, bDaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = GetSecurityDescriptorControl( pModificationDescriptor, &control, &dwRevision );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorControl( pAbsSecDesc, SE_DACL_PROTECTED, control & SE_DACL_PROTECTED );
            BREAK_ON_FAILED_BOOL( fResult );
        }
        

        // Apply SACL changes
        if( securityInformation & SACL_SECURITY_INFORMATION )
        {
            BOOL                        bSaclPresent    = FALSE;
            PACL                        pSacl           = NULL;
            BOOL                        bSaclDefaulted  = FALSE;
            SECURITY_DESCRIPTOR_CONTROL control         = 0;
            DWORD                       dwRevision      = 0;

            fResult = GetSecurityDescriptorSacl( pModificationDescriptor, &bSaclPresent, &pSacl, &bSaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorSacl( pAbsSecDesc, bSaclPresent, pSacl, bSaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = GetSecurityDescriptorControl( pModificationDescriptor, &control, &dwRevision );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorControl( pAbsSecDesc, SE_SACL_PROTECTED, control & SE_SACL_PROTECTED );
            BREAK_ON_FAILED_BOOL( fResult );
        }
        
        
        // Convert Security Descriptor to string format
        fResult = ConvertSecurityDescriptorToStringSecurityDescriptor(
            pAbsSecDesc,
            SDDL_REVISION,
            ALL_SECURITY_INFORMATION,
            &pstrSecDesc,
            NULL );
        BREAK_ON_FAILED_BOOL( fResult );
        ASSERT(pstrSecDesc);

        CComVariant v(pstrSecDesc);
        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Put( CComBSTR(g_DefaultAcl), v);
        BREAK_ON_FAILED_HRESULT(hr);
        
        hr = pIADsObject->SetInfo( );
    }
    while (0);
    
    if( !fResult )
        hr = HRESULT_FROM_WIN32(::GetLastError());

    if( pIADsObject )
        pIADsObject->Release();

    if( pstrSecDesc )
        LocalFree( pstrSecDesc );
    
    for( UINT i = 0;  i < cAbsoluteSecDescSize;  i++ )
        if( absSecDesc[i].pData )
            delete absSecDesc[i].pData;

    return hr;
}



HRESULT
GetObjectSecurityDescriptor(
    LPCWSTR                 lpszLdapPath,
    PSECURITY_DESCRIPTOR  * ppSecDesc,
    IADs                 ** ppIADsObject /* = NULL */)  // returns pIADsObject for future use.
{
    HRESULT      hr          = S_OK;
    IADs       * pIADsObject = NULL;
    CComVariant  AdsResult;
    PSID pDomainSid = NULL;

    
    *ppSecDesc   = NULL;
    
    do
    {
        hr = SchemaOpenObject( const_cast<LPWSTR>((LPCWSTR) lpszLdapPath),
                             IID_IADs,
                             (void **) &pIADsObject );

        BREAK_ON_FAILED_HRESULT(hr);
        ASSERT(pIADsObject);
        
        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( CComBSTR(g_DefaultAcl),&AdsResult);
        if (hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            hr = S_OK;
            PSECURITY_DESCRIPTOR 
                pSecDescTmp =  (PSECURITY_DESCRIPTOR)LocalAlloc
                               (
                                    LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH
                               );
            if(pSecDescTmp==NULL) {hr=E_OUTOFMEMORY;break;}
            do
            {
                if(!InitializeSecurityDescriptor(pSecDescTmp, 
                                            SECURITY_DESCRIPTOR_REVISION))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    ASSERT(FAILED(hr));
                    break;
                }

                DWORD size=0;
                BOOL fResult = MakeSelfRelativeSD(pSecDescTmp,*ppSecDesc,&size);
                ASSERT(!fResult); //ERROR_INSUFFICIENT_BUFFER is expected at first.
                hr = HRESULT_FROM_WIN32(::GetLastError());
                if( HRESULT_CODE(hr) != ERROR_INSUFFICIENT_BUFFER)  
                    BREAK_ON_FAILED_HRESULT(hr);
                hr = S_OK;
                *ppSecDesc=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,size);
                if(*ppSecDesc==NULL) {hr=E_OUTOFMEMORY;break;}
                fResult = MakeSelfRelativeSD(pSecDescTmp,*ppSecDesc,&size);
                if(!fResult)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    ASSERT(FAILED(hr));
                    // NTRAID#NTBUG9-542445-2002/03/04-dantra-Memory Leak in Error path of aclpage.cpp::GetObjectSecurityDescriptor
                    LocalFree(*ppSecDesc);
                    *ppSecDesc=NULL;
                    break;
                }
            } while(0);
            LocalFree(pSecDescTmp);
            BREAK_ON_FAILED_HRESULT(hr);
        }
        else if(FAILED(hr)) break;
        else
        {
            pDomainSid = NULL;
            GetDomainSid(lpszLdapPath, &pDomainSid);
            if(pDomainSid)
            {
                if(!ConvertStringSDToSDDomain(pDomainSid,
                                              NULL,
                                              V_BSTR(&AdsResult),
                                              SDDL_REVISION,
                                              ppSecDesc,
                                              NULL )) 
                {
                    ASSERT( FALSE );
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                }
            }
            else if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                V_BSTR(&AdsResult),
                SDDL_REVISION,
                ppSecDesc,
                NULL ) )
            {
                ASSERT( FALSE );
                hr = HRESULT_FROM_WIN32(::GetLastError());
                break;
            }
        }

        ASSERT( IsValidSecurityDescriptor(*ppSecDesc) );
    }
    while (0);
    
    if( pIADsObject )
    {
        ASSERT( SUCCEEDED(hr) );
        
        if( !ppIADsObject )     // if caller doesn't need pIADsObject
        {
            pIADsObject->Release();         // release it
        }
        else
        {
            *ppIADsObject = pIADsObject;    // otherwise, return it
        }
    }            
         
    if(pDomainSid)
        LocalFree(pDomainSid);            
    return hr;
}


BOOL CAclEditorPage::IsReadOnly( LPCTSTR lpszLDAPPath )
{
    ASSERT( lpszLDAPPath );

    HRESULT         hr      = S_OK;
    BOOL            fFound  = FALSE;
    CComPtr<IADs>   ipADs;
    CStringList     strlist;

    do
    {
       //
        // Open the schema container.
        //
        hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)lpszLDAPPath,
                           IID_IADs,
                           (void **)&ipADs );
        BREAK_ON_FAILED_HRESULT(hr);

        // extract the list of allowed classes
        hr = GetStringListElement( ipADs, &g_allowedAttributesEffective, strlist );
        BREAK_ON_FAILED_HRESULT(hr);

        // search for needed attributes
        for( POSITION pos = strlist.GetHeadPosition(); !fFound && pos != NULL; )
        {
            CString * pstr = &strlist.GetNext( pos );
            
            fFound = !pstr->CompareNoCase( g_DefaultAcl );
        }

    } while( FALSE );

    return !fFound;     // in case something fails, make read-only.
}


LSA_HANDLE
GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired)
{
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;

    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;

    if (pszServer &&
        *pszServer &&
        RtlCreateUnicodeString(&uszServer, pszServer))
    {
        puszServer = &uszServer;
    }

    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);

    if (puszServer)
        RtlFreeUnicodeString(puszServer);

    return hPolicy;
}

HRESULT
GetDomainSid(LPCWSTR pszLdapPath, PSID *ppSid)
{
    HRESULT hr = S_OK;
    NTSTATUS nts = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;
    LSA_HANDLE hLSA = 0;
    if(!pszLdapPath || !ppSid)
        return E_INVALIDARG;

    *ppSid = NULL;

    IADsPathname *pPath = NULL;
    BSTR bstrServer = NULL;

    CoCreateInstance(CLSID_Pathname,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IADsPathname,
                     (LPVOID*)&pPath);

    if(pPath)
    {
        if(SUCCEEDED(pPath->Set((BSTR)pszLdapPath,ADS_SETTYPE_FULL)))
        {
            if(SUCCEEDED(pPath->Retrieve(ADS_FORMAT_SERVER, &bstrServer)))
            {
                hLSA = GetLSAConnection(bstrServer, POLICY_VIEW_LOCAL_INFORMATION);
                if (!hLSA)
                {
                    hr = E_FAIL;
                    goto exit_gracefully;
                }

    
                nts = LsaQueryInformationPolicy(hLSA,
                                                PolicyAccountDomainInformation,
                                                (PVOID*)&pDomainInfo);
                if(nts != STATUS_SUCCESS)
                {
                    hr = E_FAIL;
                    goto exit_gracefully;
                }

                if (pDomainInfo && pDomainInfo->DomainSid)
                {
                    ULONG cbSid = GetLengthSid(pDomainInfo->DomainSid);

                    *ppSid = (PSID) LocalAlloc(LPTR, cbSid);

                    if (!*ppSid)
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit_gracefully;
                    }

                    // NOTE: Safe use of CopyMemory
                    CopyMemory(*ppSid, pDomainInfo->DomainSid, cbSid);
                }
            }
        }
    }

exit_gracefully:
    if(pDomainInfo)
        LsaFreeMemory(pDomainInfo);          
    if(hLSA)
        LsaClose(hLSA);
    if(bstrServer)
        SysFreeString(bstrServer);
    if(pPath)
        pPath->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\advui.cpp ===
/****

AdvUi.Cpp
CoryWest@Microsoft.Com

The UI code for the Advanced dialog box and its associated dialogs.

Copyright September 1997, Microsoft Corporation

****/



#include "stdafx.h"

//#include "macros.h"
//USE_HANDLE_MACROS("SCHMMGMT(advui.cpp)")

#include "schmutil.h"
#include "resource.h"
#include "advui.h"

//////////////////////////////////////////////////////////////////
// CMoreInfoMessageBox

class CMoreInfoMessageBox : public CDialog
{
public:
  CMoreInfoMessageBox(HWND hWndParent, IDisplayHelp* pIDisplayHelp) 
    : CDialog(IDD_MSGBOX_OK_MOREINFO, CWnd::FromHandle(hWndParent)),
    m_spIDisplayHelp(pIDisplayHelp)
  {
  }

  void SetURL(LPCWSTR lpszURL) { m_szURL = lpszURL;}
  void SetMessage(LPCWSTR lpsz)
  {
    m_szMessage = lpsz;
  }

	// message handlers and MFC overrides
	virtual BOOL OnInitDialog()
  {
    SetDlgItemText(IDC_STATIC_MESSAGE, m_szMessage);
    return TRUE;
  }

	afx_msg void OnMoreInfo()
  {
    TRACE(L"ShowTopic(%s)\n", (LPCWSTR)m_szURL);
    m_spIDisplayHelp->ShowTopic((LPWSTR)(LPCWSTR)m_szURL);
  }

  DECLARE_MESSAGE_MAP()
private:
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szMessage;
  CString m_szURL;
};

BEGIN_MESSAGE_MAP(CMoreInfoMessageBox, CDialog)
	ON_BN_CLICKED(ID_BUTTON_MORE_INFO, OnMoreInfo)
END_MESSAGE_MAP()



///////////////////////////////////////////////////////////////////////
// CChangeDCDialog

BEGIN_MESSAGE_MAP(CChangeDCDialog, CDialog)
   ON_BN_CLICKED(IDC_RADIO_ANY, OnChangeRadio)
   ON_BN_CLICKED(IDC_RADIO_SPECIFY, OnChangeRadio)
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
END_MESSAGE_MAP()


const DWORD CChangeDCDialog::help_map[] =
{
  IDC_EDIT_CURRENT_DC, IDH_EDIT_CURRENT_DC2,
  IDC_RADIO_ANY,       IDH_RADIO_ANY,       
  IDC_RADIO_SPECIFY,   IDH_RADIO_SPECIFY,   
  IDC_EDIT_DC,         IDH_EDIT_DC,         
  0,0                 
};


CChangeDCDialog::CChangeDCDialog(MyBasePathsInfo* pInfo, HWND hWndParent) :
  CDialog(IDD_CHANGE_DC, CWnd::FromHandle(hWndParent)) 
{
  m_pInfo = pInfo;
}


BOOL CChangeDCDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

  SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pInfo->GetServerName());

  // set the default radiobutton
  CButton* pCheck = (CButton*)GetDlgItem(IDC_RADIO_ANY);
  pCheck->SetCheck(TRUE);
  pCheck->SetFocus();
  OnChangeRadio();

  return FALSE; // we are setting the focus
}

void CChangeDCDialog::OnChangeRadio()
{
  CWnd* pEdit = GetDlgItem(IDC_EDIT_DC);

  BOOL bAny = IsDlgButtonChecked(IDC_RADIO_ANY);
  pEdit->EnableWindow(!bAny);
  if (bAny)
  {
    SetDlgItemText(IDC_EDIT_DC, NULL);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_DC, m_pInfo->GetServerName());
  }
}


void CChangeDCDialog::OnOK()
{
  // NTRAID#NTBUG9-562426-2002/03/04-dantra-GetDlgItemText Result being ignored
  GetDlgItemText(IDC_EDIT_DC, m_szNewDCName);
  m_szNewDCName.TrimLeft();
  m_szNewDCName.TrimRight();

  CDialog::OnOK();
}



///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog


BEGIN_MESSAGE_MAP(CEditFsmoDialog, CDialog)
   ON_BN_CLICKED(IDC_CHANGE_FSMO, OnChange)
   ON_BN_CLICKED(IDCLOSE, OnClose)
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
END_MESSAGE_MAP()

CEditFsmoDialog::CEditFsmoDialog(MyBasePathsInfo* pInfo, 
                                 HWND hWndParent, 
                                 IDisplayHelp* pIDisplayHelp,
                                 BOOL fAllowFSMOChange ) :
  CDialog(IDD_EDIT_FSMO, CWnd::FromHandle(hWndParent)) 
{
  m_pInfo = pInfo;
  m_spIDisplayHelp = pIDisplayHelp;
  m_fFSMOChangeAllowed = fAllowFSMOChange;
}


const DWORD CEditFsmoDialog::help_map[] =
{
  IDC_EDIT_CURRENT_DC,      IDH_EDIT_CURRENT_DC3,
  IDC_STATIC_FSMO_NOTE,     NO_HELP,
  IDC_STATIC_FSMO_STATUS,   NO_HELP,
  IDC_EDIT_CURRENT_FSMO_DC, IDH_EDIT_CURRENT_FSMO_DC2,
  IDC_CHANGE_FSMO,          IDH_CHANGE_FSMO2,
  0,0
};



BOOL CEditFsmoDialog::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    ASSERT( GetDlgItem(IDC_CHANGE_FSMO) );
    ASSERT( ::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS) );
    
    // init the status (online/offline) control)
    m_fsmoServerState.Init(::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS));
    
    SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pInfo->GetServerName());
    
    MyBasePathsInfo fsmoOwnerInfo;
    PWSTR pszFsmoOwner = 0;
    HRESULT hr = FindFsmoOwner(m_pInfo, SCHEMA_FSMO, &fsmoOwnerInfo, &pszFsmoOwner);
    
    if(pszFsmoOwner)
    {
      m_szFsmoOwnerServerName = pszFsmoOwner;
      delete[] pszFsmoOwner;
      pszFsmoOwner = 0;
    }
    _SetFsmoServerStatus(SUCCEEDED(hr));
    
    if( m_fFSMOChangeAllowed )
    {
        // set the focus on change button
        GetDlgItem(IDC_CHANGE_FSMO)->SetFocus();
    }
    else
    {
        GetDlgItem(IDC_CHANGE_FSMO)->EnableWindow( FALSE );
    }
    
    return FALSE; 
}

void CEditFsmoDialog::OnClose()
{
  EndDialog(IDCLOSE);
}

void CEditFsmoDialog::OnChange()
{
  CThemeContextActivator activator;

  // verify we have different servers
  if (m_szFsmoOwnerServerName.CompareNoCase(m_pInfo->GetServerName()) == 0)
  {
    AfxMessageBox(IDS_WARNING_CHANGE_FOCUS, MB_OK);
    return;
  }

  // make sure the user wants to do it
  if (AfxMessageBox(IDS_CHANGE_FSMO_CONFIRMATION, MB_YESNO|MB_DEFBUTTON2) != IDYES)
    return;

  HRESULT hr = GracefulFsmoOwnerTransfer(m_pInfo, SCHEMA_FSMO);
  if (FAILED(hr))
  {
    CString szFmt, szMsg;
    PWSTR pszError = 0;
    StringErrorFromHr(hr, &pszError);

    szFmt.LoadString(IDS_ERROR_CHANGE_FSMO_OWNER);
    szMsg.Format(szFmt, pszError);

    delete[] pszError;
    pszError = 0;

    CMoreInfoMessageBox dlg(m_hWnd, m_spIDisplayHelp);
    dlg.SetMessage(szMsg);
    dlg.SetURL(L"ADconcepts.chm::/FSMO_SCHEMA_ForcefulSeizure.htm");
    dlg.DoModal();
  }
  else
  {
    m_szFsmoOwnerServerName = m_pInfo->GetServerName();
    _SetFsmoServerStatus(TRUE);
    AfxMessageBox(IDS_CHANGE_FSMO_SUCCESS, MB_OK);
  }
}


void CEditFsmoDialog::_SetFsmoServerStatus(BOOL bOnLine)
{
  // set the FSMO owner server name
  if (m_szFsmoOwnerServerName.IsEmpty())
  {
    CString szError;
    szError.LoadString(IDS_FSMO_SERVER_ERROR);
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, szError);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, m_szFsmoOwnerServerName);
  }

  // set the status of the FSMO owner server
  m_fsmoServerState.SetToggleState(bOnLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\advui.h ===
/****

AdvUi.h
CoryWest@Microsoft.Com

The UI code for the Advanced dialog box and its associated dialogs.

Copyright September 1997, Microsoft Corporation

****/

#ifndef __ADVUI_H_INCLUDED__
#define __ADVUI_H_INCLUDED__



///////////////////////////////////////////////////////////////////////
// CChangeDCDialog

class CChangeDCDialog : public CDialog
{
public:
  CChangeDCDialog(MyBasePathsInfo* pInfo, HWND hWndParent);

  LPCWSTR GetNewDCName() { return m_szNewDCName;}
private:

        virtual BOOL OnInitDialog();
        virtual void OnOK();

        afx_msg void OnChangeRadio();

        BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
        BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


  static const DWORD help_map[];

  CString m_szNewDCName;
  MyBasePathsInfo* m_pInfo;

  DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog

class CEditFsmoDialog : public CDialog
{
public:
  CEditFsmoDialog(MyBasePathsInfo* pInfo, HWND hWndParent, IDisplayHelp* pIDisplayHelp, BOOL fAllowFSMOChange );

private:

  virtual BOOL OnInitDialog();
  virtual void OnClose();

  afx_msg void OnChange();

  void _SetFsmoServerStatus(BOOL bOnLine);

  MyBasePathsInfo* m_pInfo;        // info about the current focus
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szFsmoOwnerServerName;
  CToggleTextControlHelper m_fsmoServerState;

  BOOL m_fFSMOChangeAllowed;

  static const DWORD help_map[];


  BOOL OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
  BOOL OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


  DECLARE_MESSAGE_MAP()
};



#endif // __ADVUI_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\attrgen.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "cmponent.h"
#include "attrgen.hpp"
#include "resource.h"
#include "dataobj.h"




const TCHAR szUserClass[]               = USER_CLASS_NAME ;

// disable User Copy for the following list of attributes 
const TCHAR * rgszExclClass[]           = { _T("cn"),				_T("displayName"),
                                            _T("sAMAccountName"),	_T("userAccountControl"),
                                            _T("userParameters"),	_T("userPrincipalName"),    
                                            NULL };

//
// The following table is copied from dirsync\ldifds\ldifldap\samrestrict.h
//
// CLASS_USER, SampUserObjectType (ldapdisplayname: user)
//
PCWSTR rgszExclClass2[] = { // user[] = {
    L"memberOf",                // SAMP_USER_GROUPS, ATT_MEMBER
    L"dBCSPwd",                 // SAMP_USER_DBCS_PWD, ATT_DBCS_PWD
    L"ntPwdHistory",            // SAMP_USER_NT_PWD_HISTORY, ATT_NT_PWD_HISTORY
    L"lmPwdHistory",            // SAMP_USER_LM_PWD_HISTORY, ATT_LM_PWD_HISTORY
    L"lastLogon",               // SAMP_FIXED_USER_LAST_LOGON, ATT_LAST_LOGON
    L"lastLogoff",              // SAMP_FIXED_USER_LAST_LOGOFF, ATT_LAST_LOGOFF
    L"badPasswordTime",         // SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME, 
                                // ATT_BAD_PASSWORD_TIME
    L"rid",                     // SAMP_FIXED_USER_USERID, ATT_RID
    L"badPwdCount",             // SAMP_FIXED_USER_BAD_PWD_COUNT, 
                                // ATT_BAD_PWD_COUNT
    L"logonCount",              // SAMP_FIXED_USER_LOGON_COUNT, ATT_LOGON_COUNT
    L"sAMAccountType",          // SAMP_USER_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"supplementalCredentials", // SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                                // ATT_SUPPLEMENTAL_CREDENTIALS
    L"objectSid",               // not in mappings.c, but still required!, 
                                // ATT_OBJECT_SID
    L"pwdLastSet",
    NULL
};



const TCHAR szTopClass[]				= _T("Top");


const CDialogControlsInfo ctrls[] =
{
    { IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT,  g_Description,       TRUE },
    { IDC_ATTRIB_GENERAL_MIN_EDIT,          g_RangeLower,        TRUE }, 
    { IDC_ATTRIB_GENERAL_MAX_EDIT,          g_RangeUpper,        TRUE }, 
    { IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK, g_ShowInAdvViewOnly, FALSE },
    { IDC_ATTRIB_GENERAL_DEACTIVATE,        g_isDefunct,           FALSE },
    { IDC_ATTRIB_GENERAL_INDEX_CHECK,       g_IndexFlag,         FALSE },
    { IDC_ATTRIB_GENERAL_REPLICATED,        g_GCReplicated,      FALSE },
    { IDC_ATTRIB_GENERAL_CPYATTR_CHECK,     g_IndexFlag,         FALSE },
    { IDC_ATTRIB_GENERAL_ANR_CHECK,         g_IndexFlag,         FALSE },
    { IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK, g_IndexFlag, FALSE},
} ;


const DWORD AttributeGeneralPage::help_map[] =
{
  IDI_ATTRIBUTE,                        NO_HELP,
  IDC_ATTRIB_GENERAL_NAME_STATIC,       NO_HELP,
  IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT,  IDH_ATTRIB_GENERAL_DESCRIPTION_EDIT, 
  IDC_ATTRIB_GENERAL_LDN,               IDH_ATTRIB_GENERAL_LDN,               
  IDC_ATTRIB_GENERAL_OID_EDIT,          IDH_ATTRIB_GENERAL_OID_EDIT,         
  IDC_ATTRIB_GENERAL_VALUE_STATIC,      NO_HELP,
  IDC_ATTRIB_GENERAL_SYNTAX_EDIT,       IDH_ATTRIB_GENERAL_SYNTAX_EDIT,      
  IDC_ATTRIB_GENERAL_MIN_EDIT,          IDH_ATTRIB_GENERAL_MIN_EDIT,         
  IDC_ATTRIB_GENERAL_MAX_EDIT,          IDH_ATTRIB_GENERAL_MAX_EDIT,         
  IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK, IDH_ATTRIB_GENERAL_DISPLAYABLE_CHECK,
  IDC_ATTRIB_GENERAL_DEACTIVATE,        IDH_ATTRIB_DEACTIVATE,               
  IDC_ATTRIB_GENERAL_INDEX_CHECK,       IDH_ATTRIB_GENERAL_INDEX_CHECK,   
  IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK, IDH_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK,
  IDC_ATTRIB_GENERAL_ANR_CHECK,         IDH_ATTRIB_GENERAL_ANR_CHECK,
  IDC_ATTRIB_GENERAL_REPLICATED,        IDH_REPLICATED,                      
  IDC_ATTRIB_GENERAL_CPYATTR_CHECK,     IDH_ATTRIB_GENERAL_CPYATTR_CHECK,
  IDC_ATTRIB_GENERAL_SYSCLASS_STATIC,   NO_HELP,
  0,                                    0                                    
};



// returns state of bit n

inline
bool
getbit(const DWORD& bits, int n)
{
   return (bits & (1 << n)) ? true : false;
}


// sets bit n to 1

inline
void
setbit(DWORD& bits, int n)
{
   bits |= (1 << n);
}



// sets bit n to 0

inline
void
clearbit(DWORD& bits, int n)
{
   bits &= ~(1 << n);
}



//
// Attribute property sheet routines.
//



BEGIN_MESSAGE_MAP( AttributeGeneralPage, CDialog )
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
   ON_BN_CLICKED(IDC_ATTRIB_GENERAL_INDEX_CHECK, OnIndexClick)
   ON_BN_CLICKED(IDC_ATTRIB_GENERAL_DEACTIVATE, OnDeactivateClick)
END_MESSAGE_MAP()



AttributeGeneralPage::AttributeGeneralPage(
   Component*  pResultControl,
   LPDATAOBJECT         lpDataObject)
   :
   CPropertyPageAutoDelete( IDD_ATTRIB_GENERAL ),
   pCookie( NULL ),
   pIADsObject( NULL ),
   pObject( NULL),
   lpResultDataObject( lpDataObject ),
   pComponent( pResultControl ),
   fDataLoaded( FALSE ),
   Displayable( TRUE ),
   DDXDisplayable( TRUE ),
   search_flags(0),
   DDXIndexed( FALSE ),
   DDXANR( FALSE ),
   DDXCopyOnDuplicate( FALSE ),
   Defunct( FALSE ),
   DDXDefunct( FALSE ),
   ReplicatedToGC( FALSE ),
   DDXReplicatedToGC( FALSE ),
   DDXContainerIndexed( FALSE ),   
   m_editLowerRange( CParsedEdit::EDIT_TYPE_UINT32 ),
   m_editUpperRange( CParsedEdit::EDIT_TYPE_UINT32 )
{
}



BOOL
AttributeGeneralPage::OnSetActive()
{
      // If pIADsObject is NULL, close dialog box
   if( CPropertyPage::OnSetActive() )
   {
      if ( !pIADsObject )
      {
         return FALSE;
      }
      else
      {
         // always enable the Apply button 
         SetModified(TRUE);

         return TRUE;
      }
   }
   else
      return FALSE;
}


AttributeGeneralPage::~AttributeGeneralPage(
)
{

    ComponentData& Scope = pComponent->QueryComponentDataRef();

    //
    // Always make sure we free the IADs object.
    //

    if ( pIADsObject ) {
        pIADsObject->Release();
        pIADsObject = NULL;
    }

    //
    // And release the cache.
    //

    if ( pObject ) {
        Scope.g_SchemaCache.ReleaseRef( pObject );
    }
}



BOOL
AttributeGeneralPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT) );

    ( static_cast<CEdit *>( GetDlgItem(IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT) ) )
        -> LimitText( 1024 ) ;

    m_editLowerRange.SubclassEdit(IDC_ATTRIB_GENERAL_MIN_EDIT, this, cchMinMaxRange);
    m_editUpperRange.SubclassEdit(IDC_ATTRIB_GENERAL_MAX_EDIT, this, cchMinMaxRange);

    // NTRAID#NTBUG9-460503,460511-2001/09/10-lucios
    // Replaced SysClass Computation by Making the window visible in OnInitDialog
    if(pIADsObject != NULL) 
    {   // DoDataExchange has gotten a good pIADsObject or the dialog 
        // will be closed in OnSetActive

        VARIANT	AdsResult;
        VariantInit( &AdsResult );

		// NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        HRESULT hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {
            ASSERT( AdsResult.vt == VT_BOOL );
            if ( AdsResult.boolVal ) {
                ASSERT(GetDlgItem( IDC_ATTRIB_GENERAL_SYSCLASS_STATIC ) != NULL);
                GetDlgItem( IDC_ATTRIB_GENERAL_SYSCLASS_STATIC )->ShowWindow( SW_SHOW );
            } 
            VariantClear( &AdsResult );
        }
    }


    return TRUE;
}



void
AttributeGeneralPage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.  Everything
    // else gets loaded when the page is displayed.
    //

    pCookie = &CookieRef;
    return;
}



BOOL
AttributeGeneralPage::OnApply(
    VOID
) {

    HRESULT hr;

    VARIANT AdsValue;
    BOOL fChangesMade = FALSE;
    BOOL fRangeChange = FALSE;
    BOOL fApplyAbort  = FALSE;  // stop later saves
    BOOL fApplyFailed = FALSE;  // should not close the box

    DWORD dwRange;
    
    // Enable hourglass
    CWaitCursor wait;
   
    //
    // We have to flush the IADS property cache if we
    // have a failure so later operations won't fail because
    // of a bad cached attribute.
    //

    IADsPropertyList *pPropertyList;

    hr = pIADsObject->QueryInterface( IID_IADsPropertyList,
                                      reinterpret_cast<void**>(&pPropertyList) );
    if ( FAILED( hr ) ) {
        pPropertyList = NULL;
        fApplyAbort   = TRUE;
    }

    //
    // Check to see if something we cared about changed.
    // We care about Description, Min, Max, Indexed,
    // Defunct, ReplicatedToGC, and Displayable.
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    VariantInit( &AdsValue );

    //
    // Defunct -- in case it was deactivated, activate the object first
    //
    // NTRAID#NTBUG9-477290-2001/10/10-lucios
    // && !DDXDefunct was taken out and fChangesMade=TRUE added
    if( !fApplyAbort && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
        if (FAILED(hr)) fApplyAbort = TRUE;
        else fChangesMade = TRUE;
    }

    
    //
    // Description
    //

    if ( !fApplyAbort && DDXDescription != Description ) {

        V_VT(&AdsValue) = VT_BSTR;
		// NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        V_BSTR(&AdsValue) = const_cast<BSTR>((LPCTSTR)DDXDescription);

        if ( DDXDescription.IsEmpty() ) {

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
                                     const_cast<BSTR>((LPCTSTR)g_Description),
                                     AdsValue );

        } else {

       		// NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_Description),
                                   AdsValue );
        }

        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if ( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

        if ( SUCCEEDED( hr ) ) {

            pObject->description = DDXDescription;
            fChangesMade = TRUE;
			Description = DDXDescription;

        } else {

            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DESC );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }

        }

        VariantInit( &AdsValue );
    }

    //
    // Displayable
    //

    if ( !fApplyAbort && DDXDisplayable != Displayable ) {

        V_VT(&AdsValue) = VT_BOOL;

        if ( DDXDisplayable ) {
            V_BOOL(&AdsValue) = 0;
        } else {
            V_BOOL(&AdsValue) = -1;
        }

        hr = pIADsObject->Put( CComBSTR(g_ShowInAdvViewOnly), AdsValue);
        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if ( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();

            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DISPLAYABLE );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			Displayable = DDXDisplayable;
		}

        VariantInit( &AdsValue );
    }

    //
    // ReplicatedToGC
    //

    if ( !fApplyAbort && DDXReplicatedToGC != ReplicatedToGC ) {

        V_VT(&AdsValue) = VT_BOOL;

        if ( DDXReplicatedToGC ) {
            V_BOOL(&AdsValue) = -1;
        } else {
            V_BOOL(&AdsValue) = 0;
        }

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_GCReplicated),
                               AdsValue );
        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if ( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_GC );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			ReplicatedToGC = DDXReplicatedToGC;
		}

        VariantInit( &AdsValue );
    }

    //
    // Indexed
    //

   // make sure ANR is not set when Indexed is unchecked
   if( !DDXIndexed )
	   DDXANR = FALSE;

   if( !fApplyAbort && 
       (getbit(search_flags, INDEX_BIT_ATTINDEX) != (DDXIndexed ? 1 : 0)
      || getbit(search_flags, INDEX_BIT_ANR) != (DDXANR ? 1 : 0)
      || getbit(search_flags, INDEX_BIT_COPYONDUPLICATE) != (DDXCopyOnDuplicate ? 1 : 0)
      || getbit(search_flags, INDEX_BIT_PDNTATTINDEX) != (DDXContainerIndexed ? 1 : 0)) )
   {
      DWORD DDXsearch_flags = search_flags;

      V_VT(&AdsValue) = VT_I4;

      if (DDXIndexed)
         setbit(DDXsearch_flags, INDEX_BIT_ATTINDEX);
      else
         clearbit(DDXsearch_flags, INDEX_BIT_ATTINDEX);

      ASSERT( DDXIndexed || !DDXANR );
      if (DDXANR)
         setbit(DDXsearch_flags, INDEX_BIT_ANR);
      else
         clearbit(DDXsearch_flags, INDEX_BIT_ANR);

      if (DDXCopyOnDuplicate)
         setbit(DDXsearch_flags, INDEX_BIT_COPYONDUPLICATE);
      else
         clearbit(DDXsearch_flags, INDEX_BIT_COPYONDUPLICATE);

      if (DDXContainerIndexed)
        setbit(DDXsearch_flags, INDEX_BIT_PDNTATTINDEX);
      else
        clearbit(DDXsearch_flags, INDEX_BIT_PDNTATTINDEX);

      V_I4(&AdsValue) = DDXsearch_flags;
      // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
      hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_IndexFlag),
                            AdsValue );
      // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
      if ( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

      if ( FAILED( hr ) ) {
         pPropertyList->PurgePropertyList();
         if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
         {
             fApplyFailed = TRUE;
             DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_INDEXED );
         }
         else
         {
             fApplyAbort = TRUE; 
             DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
         }
      }
      else
      {
          search_flags = DDXsearch_flags;
      }

      VariantInit( &AdsValue );
   }

    //
    // RangeUpper and RangeLower
    // These have to be set together so the server
    // range validation works correctly.
    //

    if ( !fApplyAbort && RangeUpper != DDXRangeUpper ) {

        if ( DDXRangeUpper.IsEmpty() ) {

            //
            // Clear the value.
            //

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
                                     const_cast<BSTR>((LPCTSTR)g_RangeUpper),
                                     AdsValue );
        } else {

            //
            // Store the new value.
            //
	        ASSERT(pObject);

			hr = GetSafeSignedDWORDFromString( this, dwRange, DDXRangeUpper,
					g_Syntax[ pObject->SyntaxOrdinal ].m_fIsSigned );

			ASSERT( S_OK == hr );	// validation should have taken care of min/max stuff

            V_VT( &AdsValue ) = VT_I4;
            V_I4( &AdsValue ) = dwRange;

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_RangeUpper),
                                   AdsValue );
        }

		fRangeChange = TRUE;
        VariantInit( &AdsValue );
    }

    if ( !fApplyAbort && RangeLower != DDXRangeLower ) {

        if ( DDXRangeLower.IsEmpty() ) {

            //
            // Clear the value.
            //

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
                                     const_cast<BSTR>((LPCTSTR)g_RangeLower),
                                     AdsValue );
        } else {

            //
            // Store the new value.
            //

	        ASSERT(pObject);

			hr = GetSafeSignedDWORDFromString( this, dwRange, DDXRangeLower,
					g_Syntax[ pObject->SyntaxOrdinal ].m_fIsSigned );

			ASSERT( S_OK == hr );	// validation should have taken care of min/max stuff

            V_VT( &AdsValue ) = VT_I4;
            V_I4( &AdsValue ) = dwRange;

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_RangeLower),
                                   AdsValue );
       }

        fRangeChange = TRUE;
        VariantInit( &AdsValue );
    }

    //
    // Actually commit the changes.
    //

    if ( !fApplyAbort && fRangeChange ) {

        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CREATE_MINMAX );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
        else
        {
            RangeLower = DDXRangeLower;
            RangeUpper = DDXRangeUpper;
        }
    }


    //
    // Defunct -- in case it was active, deactivate the object after we are done update
    //
    if( !fApplyAbort && DDXDefunct && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
    }

    
    //
    // If there are visible changes, update the views.
    //

    if ( ( fChangesMade ) &&
         ( pComponent )     &&
         ( lpResultDataObject ) ) {

        CCookie* pBaseCookie;
        Cookie* pCookie;

        hr = ExtractData( lpResultDataObject,
                          CSchmMgmtDataObject::m_CFRawCookie,
                          OUT reinterpret_cast<PBYTE>(&pBaseCookie),
                          sizeof(pBaseCookie) );
        ASSERT( SUCCEEDED(hr) );

        pCookie = pComponent->ActiveCookie(pBaseCookie);
        ASSERT( NULL != pCookie );

        hr = pComponent->m_pResultData->UpdateItem( pCookie->hResultId );
        ASSERT( SUCCEEDED(hr) );
    }

    if ( pPropertyList ) {
        pPropertyList->Release();
    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}



void
AttributeGeneralPage::DoDataExchange(
    CDataExchange *pDX
) {

    HRESULT	hr;
    CString	szAdsPath;
    VARIANT	AdsResult;
    UINT	SyntaxOrdinal		= SCHEMA_SYNTAX_UNKNOWN;

    ComponentData& Scope = pComponent->QueryComponentDataRef();

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CThemeContextActivator activator;

    // Enable hourglass
    CWaitCursor wait;
    
    CPropertyPage::DoDataExchange( pDX );

    VariantInit( &AdsResult );

    // We still want to do the DDX exchange at the bottom
    // even if the data is already loaded so make it part
    // of this if statement instead of short circuiting 
    // from within

    if ( !pDX->m_bSaveAndValidate &&
         !fDataLoaded) {

        //
        // Get the schema cache object and the actual ADS object.
        // Keep the ADS object around while the page is loaded.
        //

        ASSERT( !pObject );		// Must be NULL initially

        pObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                      pCookie->strSchemaObject,
                      SCHMMGMT_ATTRIBUTE );

        if ( pObject ) {

          Scope.GetSchemaObjectPath( pObject->commonName, szAdsPath );

          if ( !szAdsPath.IsEmpty() ) {

              hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)szAdsPath,
                                 IID_IADs,
                                 (void **)&pIADsObject );

              if( SUCCEEDED(hr) )
			  {
			      BOOL fIsConstructed = FALSE;

			      // Igrnore error code
			      IsConstructedObject( pIADsObject, fIsConstructed );
			      
				  // Enable check box if ths attribute is not in the excluded
				  // list and available for the User Class
				  GetDlgItem(IDC_ATTRIB_GENERAL_CPYATTR_CHECK)->EnableWindow(
								!fIsConstructed &&
								!IsInList( rgszExclClass, pObject->ldapDisplayName )  &&
								!IsInList( rgszExclClass2, pObject->ldapDisplayName )  &&
								IsAttributeInUserClass( pObject->ldapDisplayName ) );
			  }
          }
        }

        //
        // If we have no ADS object, we should error out!
        //

        if ( !pIADsObject )
        {
          DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );

          // Because there is no pIADsObject, OnSetActive() will close dialog box

          return;
        }

        //
        // ObjectName - Use the ldapDisplayName to be consistent
        // with the other admin components.
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BSTR );
          ObjectName = AdsResult.bstrVal;
          VariantClear( &AdsResult );
        }

        //
        // Description
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_Description),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BSTR );
          Description = AdsResult.bstrVal;
          DDXDescription = AdsResult.bstrVal;
          VariantClear( &AdsResult );
        }

        //
        // CommonName
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_CN),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BSTR );
          DisplayName = AdsResult.bstrVal;
          VariantClear( &AdsResult );
        }



        // NTRAID#NTBUG9-460503,460511-2001/09/10-lucios
        // Replaced SysClass Computation by Making the window visible in OnInitDialog

 
        //
        // Syntax
        //
		// No need to reload from schema -- syntax never changes
		//
        ASSERT(pObject);
        if( pObject )
            SyntaxOrdinal = pObject->SyntaxOrdinal;
        
        SyntaxString = g_Syntax[ SyntaxOrdinal ].m_strSyntaxName;


        //
        // Syntax min and max values.
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_RangeLower),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

            ASSERT( V_VT( &AdsResult ) == VT_I4 );

            RangeLower.Format( g_Syntax[ SyntaxOrdinal ].m_fIsSigned ?
									g_INT32_FORMAT : g_UINT32_FORMAT,
                               V_I4( &AdsResult ) );

			ASSERT( RangeLower.GetLength() <= cchMinMaxRange );
            DDXRangeLower = RangeLower;

            VariantClear( &AdsResult );
        }

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_RangeUpper),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

            ASSERT( V_VT( &AdsResult ) == VT_I4 );

            RangeUpper.Format( g_Syntax[ SyntaxOrdinal ].m_fIsSigned ?
									g_INT32_FORMAT : g_UINT32_FORMAT,
                               V_I4( &AdsResult ) );

			ASSERT( RangeUpper.GetLength() <= cchMinMaxRange );
            DDXRangeUpper = RangeUpper;

            VariantClear( &AdsResult );
        }

        //
        // Multi-Valued
        //


        MultiValued.LoadString( IDS_ATTRIBUTE_MULTI );

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_IsSingleValued),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               MultiValued.Empty();
               MultiValued.LoadString( IDS_ATTRIBUTE_SINGLE );
           }

           VariantClear( &AdsResult );

        }

        //
        // Displayable
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( CComBSTR(g_ShowInAdvViewOnly), &AdsResult);

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               Displayable = FALSE;
               DDXDisplayable = FALSE;
           }

           VariantClear( &AdsResult );

        }

        //
        // Defunct
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               Defunct = TRUE;
               DDXDefunct = TRUE;
           }

           VariantClear( &AdsResult );

        }

        //
        // ReplicatedToGC
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_GCReplicated),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               ReplicatedToGC = TRUE;
               DDXReplicatedToGC = TRUE;
           }

           VariantClear( &AdsResult );

        }

        //
        // OID
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_GlobalAttributeID),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BSTR );
           OidString = AdsResult.bstrVal;
           VariantClear( &AdsResult );
        }

        //
        // Indexed, ANR, & Copy on duplicate
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
      hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_IndexFlag),
                            &AdsResult );

      if (SUCCEEDED(hr))
      {
         ASSERT(AdsResult.vt == VT_I4);

         search_flags = V_I4(&AdsResult);
         
		 // Index this attribute in the Active Directory
		 DDXIndexed = getbit( search_flags, INDEX_BIT_ATTINDEX );
		 
		 // Ambiguous Name Resolution (ANR)
		 // checkbox must exist
		 ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_ANR_CHECK) );

		 // if not indexed, or not allowed, disable the checkbox
		 GetDlgItem(IDC_ATTRIB_GENERAL_ANR_CHECK)->EnableWindow(
					g_Syntax[ SyntaxOrdinal ].m_fIsANRCapable ? DDXIndexed : FALSE );

		 if( DDXIndexed )
			 DDXANR = getbit( search_flags, INDEX_BIT_ANR );
		 else
		 {
			 DDXANR = FALSE;

			 // if not indexed, ANR in DS should not be set
			 ASSERT( !getbit( search_flags, INDEX_BIT_ANR ) );
		 }

		 // Attribute is copied when duplicating a user
		 DDXCopyOnDuplicate = getbit( search_flags, INDEX_BIT_COPYONDUPLICATE );

         VariantClear( &AdsResult );
      }

      // Containerized index
      DDXContainerIndexed = getbit( search_flags, INDEX_BIT_PDNTATTINDEX );

      // Determine if this is a category 1 object & disable read-only fields
      BOOL  fIsSystemObject = FALSE;

      hr = IsCategory1Object( pIADsObject, fIsSystemObject );
      if( SUCCEEDED(hr) && fIsSystemObject )
      {
         ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_MIN_EDIT) );
         ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_MAX_EDIT) );
         ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE) );
         
         reinterpret_cast<CEdit *>( GetDlgItem(IDC_ATTRIB_GENERAL_MIN_EDIT) )->SetReadOnly();
         reinterpret_cast<CEdit *>( GetDlgItem(IDC_ATTRIB_GENERAL_MAX_EDIT) )->SetReadOnly();
         GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE)->EnableWindow( FALSE );
      }

      hr = DissableReadOnlyAttributes( this, pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
      hr = S_OK;
      // NTRAID#NTBUG9-503619-2002/05/15-lucios
      // We are deliberatelly ignoring the error here. This function is called to make extra attributes
      // read only or disabled if they don't belong to allollklk
      // If it fails for any reason, we are not making those attributes read only, but writing them
      // will fail and will return an appropriate error message.
      


      // warn the user if this is a read/write defunct object
      ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE) );
      
      if( DDXDefunct &&
          GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE)->IsWindowEnabled() )
      {
          AfxMessageBox( IDS_WARNING_DEFUNCT, MB_OK | MB_ICONINFORMATION );
      }


      //
      // Remember that the data is loaded.
      //

      fDataLoaded = TRUE;

      m_editLowerRange.SetSigned( g_Syntax[ SyntaxOrdinal ].m_fIsSigned );
      m_editUpperRange.SetSigned( g_Syntax[ SyntaxOrdinal ].m_fIsSigned );
    }


    //
    // Set up the dialog data exchange.
    //

    DDX_Text( pDX, IDC_ATTRIB_GENERAL_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_SYNTAX_EDIT, SyntaxString );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_OID_EDIT, OidString );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_VALUE_STATIC, MultiValued );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_LDN, DisplayName );
	DDX_Text( pDX, IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT, DDXDescription );

    DDXV_VerifyAttribRange( pDX, g_Syntax[ pObject->SyntaxOrdinal ].m_fIsSigned,
							IDC_ATTRIB_GENERAL_MIN_EDIT, DDXRangeLower,
							IDC_ATTRIB_GENERAL_MAX_EDIT, DDXRangeUpper );
		
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK, DDXDisplayable );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_INDEX_CHECK, DDXIndexed );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_ANR_CHECK, DDXANR );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_CPYATTR_CHECK, DDXCopyOnDuplicate );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_REPLICATED, DDXReplicatedToGC );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK, DDXContainerIndexed );

    // Since we want the checkbox label to be positive
    // the value is actually the opposite of defunct

    int checkValue = !Defunct;
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_DEACTIVATE, checkValue );
    DDXDefunct = !checkValue;

    return;
}


void
AttributeGeneralPage::OnIndexClick()
{
	ASSERT( pObject );
	if( pObject && g_Syntax[ pObject->SyntaxOrdinal ].m_fIsANRCapable )
	{
		GetDlgItem(IDC_ATTRIB_GENERAL_ANR_CHECK)->
			EnableWindow(  IsDlgButtonChecked(IDC_ATTRIB_GENERAL_INDEX_CHECK)  );
	}
}


void
AttributeGeneralPage::OnDeactivateClick()
{
   CThemeContextActivator activator;
 
	if( !IsDlgButtonChecked(IDC_ATTRIB_GENERAL_DEACTIVATE) )
    {
        if(IDYES !=  AfxMessageBox
                     ( 
                        IDS_WARNING_DEFUNCT_SET, 
                        MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING 
                     )
          )
        {
            CheckDlgButton( IDC_ATTRIB_GENERAL_DEACTIVATE, BST_CHECKED );
        }
	}
}


//  Search User class & aux classes for the specified attribute
BOOL
AttributeGeneralPage::IsAttributeInUserClass( const CString & strAttribDN )
{
    BOOL            fFound  = FALSE;
    ComponentData & Scope   = pComponent->QueryComponentDataRef();

    SchemaObject  * pObject = Scope.g_SchemaCache.LookupSchemaObject(
                                CString( szUserClass ),
                                SCHMMGMT_CLASS );
    //
    // Call the attribute check routine.  This routine
    // will call itself recursively to search the
    // inheritance structure of the class User.
    //
    if ( pObject ) {

		fFound = RecursiveIsAttributeInUserClass( strAttribDN, pObject );
        Scope.g_SchemaCache.ReleaseRef( pObject );
    }

    return fFound ;
}


//    Search the user class & subclasses
BOOL
AttributeGeneralPage::RecursiveIsAttributeInUserClass(
   const CString &  strAttribDN,
   SchemaObject *   pObject )
{
    BOOL     fFound  = FALSE;
    
    //
    // Don't process "top" here since everyone inherits from it.
    //
    
    // i don't think we ever get "top" here?
    ASSERT( pObject->ldapDisplayName.CompareNoCase( szTopClass ) );

    if ( !pObject->ldapDisplayName.CompareNoCase(szTopClass) )
        return fFound;

    DebugTrace( L"RecursiveIsAttributeInUserClass: %ls\n",
                const_cast<LPWSTR>((LPCTSTR)pObject->ldapDisplayName) );

    // Check every list
    if( !SearchResultList( strAttribDN, pObject->systemMayContain)  &&
        !SearchResultList( strAttribDN, pObject->mayContain)        &&
        !SearchResultList( strAttribDN, pObject->systemMustContain) &&
        !SearchResultList( strAttribDN, pObject->mustContain) )
    {
        //
        //  The attribute was not found in the given class, diging deeper...
        //  Check each auxiliary class...
        //

        fFound = TraverseAuxiliaryClassList( strAttribDN,
                                             pObject->systemAuxiliaryClass );

        if( !fFound )
        {
            fFound = TraverseAuxiliaryClassList( strAttribDN,
                                                 pObject->auxiliaryClass );
        }
    }
    else
    {
        fFound = TRUE;
    }

    return fFound ;
}


// Linear search of the linked list for the string strAttribDN

BOOL
AttributeGeneralPage::SearchResultList(
    const CString   & strAttribDN,
    ListEntry       * pList )
{
    // Traverse the list
    while ( pList )
    {
        // Searching for the existance of the attribute
        if( !pList->Attribute.CompareNoCase( strAttribDN ) )
            return TRUE;

        pList = pList->pNext;
	}

    return FALSE;
}


// Traverse each auxiliary class by recursivly
// calling RecursiveIsAttributeInUserClass()
BOOL
AttributeGeneralPage::TraverseAuxiliaryClassList(
                const CString   & strAttribDN,
                ListEntry       * pList )
{
    SchemaObject  * pInheritFrom    = NULL;
    ComponentData & Scope           = pComponent->QueryComponentDataRef();
    BOOL            fFound          = FALSE;

    while ( !fFound && pList ) {

        pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pList->Attribute,
                                                               SCHMMGMT_CLASS );
        if ( pInheritFrom )
        {
            // recursive call
            fFound = RecursiveIsAttributeInUserClass( strAttribDN, pInheritFrom );

            Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
        }

        pList = pList->pNext;
    }

    return fFound ;
}


HRESULT
AttributeGeneralPage::ChangeDefunctState( BOOL               DDXDefunct,
                                          BOOL             & Defunct,
                                          IADsPropertyList * pPropertyList,
                                          BOOL             & fApplyAbort,
                                          BOOL             & fApplyFailed )
{
    ASSERT( !fApplyAbort && DDXDefunct != Defunct );

    VARIANT AdsValue;
    HRESULT hr = S_OK;
    
    VariantInit( &AdsValue );
    V_VT(&AdsValue) = VT_BOOL;

    if ( DDXDefunct ) {
        V_BOOL(&AdsValue) = -1;
    } else {
        V_BOOL(&AdsValue) = 0;
    }

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                           AdsValue );
    // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
    if( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

    if ( FAILED( hr ) ) {

        pPropertyList->PurgePropertyList();

        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(),
                         TRUE,
                         DDXDefunct ? IDS_ERR_EDIT_DEFUNCT_SET : IDS_ERR_EDIT_DEFUNCT_REMOVE );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }

    } else {

        pObject->isDefunct = DDXDefunct;
		Defunct = DDXDefunct;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\attrgen.hpp ===
#ifndef ATTRGEN_HPP_INCLUDED
#define ATTRGEN_HPP_INCLUDED


//
// Index Field bits
//
const DWORD INDEX_BIT_ATTINDEX			= 0;
const DWORD INDEX_BIT_PDNTATTINDEX		= 1;
// NOTE, to get ANR behaviour, set both
// INDEX_BIT_ANR and INDEX_BIT_ATTINDEX.
const DWORD INDEX_BIT_ANR				= 2;
const DWORD INDEX_BIT_PRESERVEONDELETE	= 3;
const DWORD INDEX_BIT_COPYONDUPLICATE	= 4;

// CN of the class "User"
extern const TCHAR szUserClass[];

// disable User Copy for the following list of attributes 
extern const TCHAR * rgszExclClass[];

#include "CPropertyPageAutoDelete.hpp"


class AttributeGeneralPage : public CPropertyPageAutoDelete
{
   public:

   AttributeGeneralPage( Component *pResultControl,
                              LPDATAOBJECT lpDataObject );

   ~AttributeGeneralPage();

   //
   // The schema object that this property page is for.
   //

   void Load( Cookie& CookieRef );
   Cookie *pCookie;

   //
   // The things we need for UpdateAllViews().
   //

   LPDATAOBJECT lpResultDataObject;
   Component *pComponent;

   //
   // Data members for property fields.
   //

   IADs *pIADsObject;
   SchemaObject *pObject;
   BOOL fDataLoaded;

   CString ObjectName;

   CString Description;
   CString DDXDescription;

   CString DisplayName;

   CString MultiValued;
   CString SyntaxString;

   CString RangeUpper;
   CString DDXRangeUpper;

   CString RangeLower;
   CString DDXRangeLower;

   CString OidString;

   DWORD search_flags; // low order bit => indexed
   BOOL DDXIndexed;
   BOOL	DDXANR;
   BOOL	DDXCopyOnDuplicate;
   BOOL DDXContainerIndexed;

   BOOL Displayable;
   BOOL DDXDisplayable;

   BOOL Defunct;
   BOOL DDXDefunct;

   BOOL ReplicatedToGC;
   BOOL DDXReplicatedToGC;

private:
    CParsedEdit m_editLowerRange;
    CParsedEdit m_editUpperRange;

protected:
    // Helper functions

    //    Search User class & aux classes for the specified attribute
    BOOL IsAttributeInUserClass( const CString & strAttribDN );

    //    Search the user class & subclasses
    BOOL RecursiveIsAttributeInUserClass( const CString & strAttribDN,
                                          SchemaObject  * pObject );

    // Linear search of the linked list for the string strAttribDN
    BOOL SearchResultList( const CString  & strAttribDN,
                           ListEntry      * pList );

    // Traverse each auxiliary class by recursivly
    // calling RecursiveIsAttributeInUserClass()
    BOOL TraverseAuxiliaryClassList( const CString   & strAttribDN,
                                     ListEntry       * pList );

    HRESULT ChangeDefunctState( BOOL               DDXDefunct,
                                BOOL             & Defunct,
                                IADsPropertyList * pPropertyList,
                                BOOL             & fApplyAbort,
                                BOOL             & fApplyFailed );


public:
   
   //
   // Required property sheet routines.
   //

   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();
   virtual void DoDataExchange( CDataExchange *pDX );


   static const DWORD help_map[];

   BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   void	   OnIndexClick();
   void	   OnDeactivateClick();

   DECLARE_MESSAGE_MAP()
};



#endif   // ATTRGEN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\attrpage.h ===
//
// attrpage.h : Declaration of ClassAttributePage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//
// templated from relation.h JonN 8/8/97
//

#ifndef __ATTRPAGE_H_INCLUDED__
#define __ATTRPAGE_H_INCLUDED__

#include "cookie.h"     // Cookie
#include "resource.h"   // IDD_CLASS_MEMBERSHIP


#include "CPropertyPageAutoDelete.hpp"

class ClassAttributePage : public CPropertyPageAutoDelete
{
   public:

   ClassAttributePage(ComponentData *pScope, LPDATAOBJECT lpDataObject);

   ~ClassAttributePage();

   void Load( Cookie& CookieRef );

   //
   // The schema object that this property page is for.
   //

   CStringList strlistMandatory;
   CStringList strlistSystemMandatory;
   CStringList strlistOptional;
   CStringList strlistSystemOptional;

   Cookie *m_pCookie;
   CString m_szAdsPath;

   ComponentData *pScopeControl;
   LPDATAOBJECT lpScopeDataObj;

   //
   // The ADSI object that this property page is for
   //

   IADs*         m_pIADsObject;
   SchemaObject* m_pSchemaObject;


   // Dialog Data

   enum { IDD = IDD_CLASS_ATTRIBUTES};

   CListBox              m_listboxMandatory;            
   CSchemaObjectsListBox m_listboxOptional;             

   CString  ObjectName;                    
   BOOL     fSystemClass;                  

   virtual BOOL OnApply();


   protected:

   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support


   static const DWORD help_map[];

   BOOL     OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL     OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


   afx_msg void OnButtonOptionalAttributeAdd();
   afx_msg void OnButtonOptionalAttributeRemove();
   afx_msg void OnOptionalSelChange();

   DECLARE_MESSAGE_MAP()
};



#endif // __ATTRPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cache.cpp ===
/****

Cache.cpp

The schema caching routines to improve browsing performance.

Locking Note:

This schema cache design allows for rudimentary multi-thread
protection via the lookup routines and the ReleaseRef routines.
To date, we have not needed this type of protection, so it is
not implemented.  All locking rules should be obeyed, however,
in case this protection is later needed.

****/

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(cache.cpp)")

#include "resource.h"
#include "cache.h"
#include "schmutil.h"
#include "compdata.h"

//
// The Schema Object.
//

SchemaObject::SchemaObject() {

    //
    // Initialize the list heads to NULL.
    //

    pNext                = NULL;
    pSortedListFlink     = NULL;
    pSortedListBlink     = NULL;

    isDefunct            = FALSE;
    dwClassType          = (DWORD) -1;  // invalid number

    systemMayContain     = NULL;
    mayContain           = NULL;

    systemMustContain    = NULL;
    mustContain          = NULL;

    systemAuxiliaryClass = NULL;
    auxiliaryClass       = NULL;

    SyntaxOrdinal        = UINT_MAX;    // invalid number
}

SchemaObject::~SchemaObject() {

    ListEntry *pEntry, *pNextEntry;

    //
    // Empty any non-zero lists.
    //

    pEntry = systemMayContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }

    pEntry = mayContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = systemMustContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = mustContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = systemAuxiliaryClass;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = auxiliaryClass;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }

    //
    // Done (the CStrings will clean themselves up).
    //

    return;
}

//
// The Schema Object cache.
//

SchemaObjectCache::SchemaObjectCache() {

    pScopeControl = NULL;

    //
    // Initialize the hash table.
    //

    buckets = HASH_TABLE_SIZE;
    hash_table = (SchemaObject**) LocalAlloc( LMEM_ZEROINIT,
                                              sizeof( SchemaObject* ) * buckets );

    if (hash_table != NULL)
    {
      //NOTE: Safe use of memset re; sizeof (SchemObject *) * buckets in call to LocalAlloc
      memset(
          hash_table,
          0,
          sizeof( SchemaObject* ) * buckets );
    }
    pSortedClasses = NULL;
    pSortedAttribs = NULL;

    fInitialized = FALSE;

}

SchemaObjectCache::~SchemaObjectCache() {

    //
    // Clear the hash table.
    //

    FreeAll();
    LocalFree( hash_table );
    hash_table = NULL;
}

VOID
SchemaObjectCache::FreeAll() {

    SchemaObject *current, *next;

    DebugTrace( L"SchemaObjectCache::FreeAll()\n" );

    for ( UINT i = 0 ; i < buckets ; i++ ) {

        current = hash_table[i];

        while ( current ) {
            next = current->pNext;
            delete current;
            current = next;
        }
    }

    // NOTE: Safe use of memset re; sizeof (SchemObject *) * buckets in call to LocalAlloc
    memset(
        &(hash_table[0]),
        0,
        sizeof( SchemaObject* ) * buckets );

    pSortedClasses = NULL;
    pSortedAttribs = NULL;

    fInitialized = FALSE;

    return;
}

UINT
SchemaObjectCache::CalculateHashKey(
    CString HashKey
) {

    int len = HashKey.GetLength();
    LPCTSTR current = (LPCTSTR)HashKey;
    int hash = 0;

    for ( int i = 0 ; i < len ; i++ ) {
        hash += (i+1) * ( (TCHAR) CharLower((LPTSTR) current[i]) );
    }

    hash %= buckets;

    DebugTrace( L"SchemaObjectCache::CalculateHashKey %ls (len %li) == %li\n",
                const_cast<LPWSTR>((LPCTSTR)HashKey),
                len,
                hash );

    return hash;
}

HRESULT
SchemaObjectCache::InsertSchemaObject(
    SchemaObject* Object
) {

    SchemaObject* chain;
    int bucket = CalculateHashKey( Object->commonName );

    chain = hash_table[bucket];
    hash_table[bucket] = Object;
    Object->pNext = chain;

    DebugTrace( L"Insert: %ls, %ls, %ls, --> %li\n",
                const_cast<LPWSTR>((LPCTSTR)Object->ldapDisplayName),
                const_cast<LPWSTR>((LPCTSTR)Object->commonName),
                const_cast<LPWSTR>((LPCTSTR)Object->description),
                bucket );

    return S_OK;
}

HRESULT
SchemaObjectCache::InsertSortedSchemaObject(
    SchemaObject* Object
) {

    SchemaObject *pCurrent = NULL;
    SchemaObject *pHead = NULL;
    BOOLEAN ChangeHead = TRUE;

    if ( Object->schemaObjectType == SCHMMGMT_CLASS ) {
        pCurrent = pSortedClasses;
    } else {
        ASSERT( Object->schemaObjectType == SCHMMGMT_ATTRIBUTE );
        pCurrent = pSortedAttribs;
    }

    //
    // If we haven't built the sorted list yet, then we
    // don't need to insert this element into it.
    //

    if ( !pCurrent ) {
        return S_OK;
    }

    //
    // The sorted list is circular.
    //

    while ( ( 0 < ( Object->commonName.CompareNoCase(
                        pCurrent->commonName ) ) ) &&
            ( pCurrent != pHead ) ) {

        if ( ChangeHead ) {
            pHead = pCurrent;
            ChangeHead = FALSE;
        }

        pCurrent = pCurrent->pSortedListFlink;

    }

    pCurrent->pSortedListBlink->pSortedListFlink = Object;
    Object->pSortedListBlink = pCurrent->pSortedListBlink;
    Object->pSortedListFlink = pCurrent;
    pCurrent->pSortedListBlink = Object;

    if ( ChangeHead ) {

        if ( Object->schemaObjectType == SCHMMGMT_CLASS ) {
            pSortedClasses = Object;
        } else {
            pSortedAttribs = Object;
        }
    }

    return S_OK;
}


// This functions behavior has been modified to support schema delete.
// Previously this function would return the first match to the ldapDisplayName,
// Now it will return the first match to the ldapDisplayName that is not defunct
// In order to implement bug 465091 this function can also be used to lookDefunct.
SchemaObject*
SchemaObjectCache::LookupSchemaObject(
    CString ldapDisplayName,
    SchmMgmtObjectType ObjectType,
    bool lookDefunct /*=false*/
) {
    if ( !fInitialized ) {
        LoadCache();
    }

    SchemaObject  * pHead       = 0;
    if ( ObjectType == SCHMMGMT_ATTRIBUTE)
    {
       pHead = pSortedAttribs;
    }
    else
    {
       pHead = pSortedClasses;
    }

    SchemaObject  * pObject     = pHead;
    BOOL            fFound      = FALSE;

    ASSERT( pObject );

    do {
        if( ObjectType == pObject->schemaObjectType  &&
            (!pObject->isDefunct || lookDefunct) && 
            !pObject->ldapDisplayName.CompareNoCase(ldapDisplayName) )
        {
            fFound = TRUE;
            break;
        }
        
        pObject = pObject->pSortedListFlink;
        
    } while ( pObject != pHead );

    if (!fFound)
    {
       pObject = 0;
    }

    return pObject;

/*
    int length = 0;
    int bucket = CalculateHashKey( ldapDisplayName );
    SchemaObject* chain = hash_table[bucket];

    if ( !fInitialized ) {
        LoadCache();
    }

    while ( chain ) {

        if ( ( ObjectType == chain->schemaObjectType ) &&
               !chain->isDefunct &&
            !ldapDisplayName.CompareNoCase( chain->ldapDisplayName ) ) {

            DebugTrace( L"SchemaObjectCache::LookupSchemaObject %ls, chain depth %li.\n",
                        const_cast<LPWSTR>((LPCTSTR)ldapDisplayName),
                        length );

            return chain;

        } else {

            chain = chain->pNext;
            length++;
        }
    }

    DebugTrace( L"SchemaObjectCache::LookupSchemaObject %ls (NO HIT), chain depth %li.\n",
                const_cast<LPWSTR>((LPCTSTR)ldapDisplayName),
                length );

    //
    // LOCKING NOTE: The simple ref counting and locking is not
    // currently implemented.  See note at the head of the file.
    //
    return NULL;
*/
}


//
// sequential search of the entire cache for an object with the given CN
//
// objectType is given to slightly speed-up the process.
//
SchemaObject*
SchemaObjectCache::LookupSchemaObjectByCN( LPCTSTR             pszCN,
                                           SchmMgmtObjectType  objectType )
{
    if ( !fInitialized ) {
        LoadCache();
    }

    SchemaObject  * pHead       = 0;
    if ( objectType == SCHMMGMT_ATTRIBUTE)
    {
       pHead = pSortedAttribs;
    }
    else
    {
       pHead = pSortedClasses;
    }

    SchemaObject  * pObject     = pHead;
    BOOL            fFound      = FALSE;

    ASSERT( pObject );

    do {
        if( objectType == pObject->schemaObjectType  &&
            !pObject->commonName.CompareNoCase(pszCN) )
        {
            fFound = TRUE;
            break;
        }
        
        pObject = pObject->pSortedListFlink;
        
    } while ( pObject != pHead );
    
    //
    // LOCKING NOTE: The simple ref counting and locking is not
    // currently implemented.  See note at the head of the file.
    //

    return fFound ? pObject : NULL;
}


VOID
SchemaObjectCache::ReleaseRef(
    SchemaObject*
) {

    //
    // E_NOTIMPL
    // See the note at the head of the file.
    //

}

HRESULT
SchemaObjectCache::LoadCache(
    VOID
)
/***

    This routine executes a couple of DS searches to read the
    relevant items out of the schema along with some attributes
    of those items.

    This information is cached.

***/
{
    if ( fInitialized ) {
        return S_OK;
    }

    LPWSTR Attributes[] = {
               g_DisplayName,
               g_CN,
               g_Description,
               g_MayContain,
               g_MustContain,
               g_SystemMayContain,
               g_SystemMustContain,
               g_AuxiliaryClass,
               g_SystemAuxiliaryClass,
               g_SubclassOf,
               g_ObjectClassCategory,
               g_AttributeSyntax,
               g_omSyntax,
               g_omObjectClass,
               g_isDefunct,
               g_GlobalClassID,  // must be last
    };
    const DWORD         AttributeCount = sizeof(Attributes) / sizeof(Attributes[0]);

    ADS_SEARCH_HANDLE   hSearchHandle   = NULL;
    HRESULT             hr              = S_OK;
    CComPtr<IADs>       ipADs;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //
    // Put up a wait cursor since
    // this could take a little while.  The cursor will
    // revert when the the CWaitCursor goes out of scope.
    //
    CWaitCursor wait;


    //
    // Get the schema container path.
    //

    if ( NULL == pScopeControl ) 
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    hr = pScopeControl->CheckSchemaPermissions( &ipADs );
    if ( !ipADs )
    {
        ASSERT( FAILED(hr) );
        
        if( E_FAIL == hr )
            DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        else
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );

        return hr;
    }
    else if( FAILED(hr) )
        hr = S_OK;          // ignore the error.  In case of an error, minimal permissions are assumed


    //
    // Open the schema container.
    //
    
    IDirectorySearch *pDSSearch = 0;
    hr = ipADs->QueryInterface( IID_IDirectorySearch,
                                (void **)&pDSSearch );

    if ( FAILED(hr) ) 
    {
        ASSERT(FALSE);
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        return hr;
    }

   //
   // Set up the search preferences
   //

   static const int SEARCH_PREF_COUNT = 3;
   ADS_SEARCHPREF_INFO prefs[SEARCH_PREF_COUNT];

   // server side sort preferences
   ADS_SORTKEY SortKey;
   SortKey.pszAttrType = g_DisplayName;
   SortKey.pszReserved = NULL;
   SortKey.fReverseorder = 0;

   prefs[0].dwSearchPref = ADS_SEARCHPREF_SORT_ON;
   prefs[0].vValue.dwType = ADSTYPE_PROV_SPECIFIC;
   prefs[0].vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY);
   prefs[0].vValue.ProviderSpecific.lpValue = (LPBYTE) &SortKey;

   // result page size
   prefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
   prefs[1].vValue.dwType = ADSTYPE_INTEGER;
   prefs[1].vValue.Integer = 300; // get a bunch in one hit

   // scope
   prefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
   prefs[2].vValue.dwType = ADSTYPE_INTEGER;
   prefs[2].vValue.Integer = ADS_SCOPE_ONELEVEL;  // one level

    //
    // Build the class search request.
    //

   hr = pDSSearch->SetSearchPreference(prefs, SEARCH_PREF_COUNT);
   // NTRAID#NTBUG9-565435-2002/03/05-dantra-Return value being ignored.
   ASSERT( SUCCEEDED( hr ) );

   hr =
      pDSSearch->ExecuteSearch(
         L"(objectCategory=classSchema)",
         Attributes,
         AttributeCount,
            &hSearchHandle );

    if ( FAILED(hr) ) 
    {
        ASSERT(FALSE);
        pDSSearch->Release();
        return hr;
    }

    //
    // Cache these entries.  We ignore error codes and try to
    // process the attributes regardless.
    //

    // NTRAID#NTBUG9-565435-2002/03/05-dantra-Return value being ignored.
    hr = ProcessSearchResults( pDSSearch, hSearchHandle, SCHMMGMT_CLASS);

    pDSSearch->CloseSearchHandle( hSearchHandle );

    hr = pDSSearch->SetSearchPreference(prefs, SEARCH_PREF_COUNT);
    // NTRAID#NTBUG9-565435-2002/03/05-dantra-Return value being ignored.
    ASSERT( SUCCEEDED( hr ) );

    //
    // This array index must match the array declared above!
    //

    Attributes[AttributeCount - 1] = g_GlobalAttributeID;

    hr =
      pDSSearch->ExecuteSearch(
         L"(objectCategory=attributeSchema)",
         Attributes,
         AttributeCount,
         &hSearchHandle );

    if ( FAILED(hr) ) 
    {
        ASSERT(FALSE);
        pDSSearch->Release();
        return hr;
    }

    //
    // Cache these entries.  Again, ignore the error code.
    //

    // NTRAID#NTBUG9-565435-2002/03/05-dantra-Return value being ignored.
    hr = ProcessSearchResults( pDSSearch, hSearchHandle, SCHMMGMT_ATTRIBUTE );

    pDSSearch->CloseSearchHandle( hSearchHandle );

    //
    // Release the schema container.
    //

    pDSSearch->Release();

    //
    // Mark the cache as open for business.
    //

    fInitialized = TRUE;

    return S_OK;
}


HRESULT
SchemaObjectCache::ProcessSearchResults(
    IDirectorySearch *pDSSearch,
    ADS_SEARCH_HANDLE hSearchHandle,
    SchmMgmtObjectType ObjectType
) {

    CThemeContextActivator activator;

    HRESULT hr = S_OK;
    SchemaObject *schemaObject;
    ADS_SEARCH_COLUMN Column;

    while ( TRUE ) {

        //
        // Get the next row set.  If there are no more rows, break.
        // If there was some other error, try to skip over the
        // troubled row.
        //

        hr = pDSSearch->GetNextRow( hSearchHandle );

        if ( hr == S_ADS_NOMORE_ROWS ) {
            break;
        }

        if ( hr != S_OK ) {
            ASSERT( FALSE );
            continue;
        }

        //
        // Allocate a new schema object.  If one could not be
        // allocated, stop loading the schema since we're in a
        // low memory condition.
        //

        schemaObject = new SchemaObject;
        if ( !schemaObject ) {
            AfxMessageBox(IDS_SCHEMA_NOT_FULLY_LOADED, MB_OK);
            ASSERT( FALSE );
            return E_OUTOFMEMORY;
        }

        //
        // Set the object type.
        //

        schemaObject->schemaObjectType = ObjectType;

        //
        // Get the common name column.
        //

        hr = pDSSearch->GetColumn( hSearchHandle, g_CN, &Column );

        if ( SUCCEEDED(hr) ) {
            schemaObject->commonName = (Column.pADsValues)->CaseIgnoreString;
            pDSSearch->FreeColumn( &Column );
        }

        //
        // Get the ldap display name.
        //

        hr = pDSSearch->GetColumn( hSearchHandle, g_DisplayName, &Column );

        if ( SUCCEEDED(hr) ) {
            schemaObject->ldapDisplayName = (Column.pADsValues)->CaseIgnoreString;
            pDSSearch->FreeColumn( &Column );
        }

        //
        // Get the description.
        //

        hr = pDSSearch->GetColumn( hSearchHandle, g_Description, &Column );

        if ( SUCCEEDED(hr) ) {
            schemaObject->description = (Column.pADsValues)->CaseIgnoreString;
            pDSSearch->FreeColumn( &Column );
        }

        //
        // Is this object current active?
        //

        schemaObject->isDefunct = FALSE;

        hr = pDSSearch->GetColumn( hSearchHandle, g_isDefunct, &Column );

        if ( SUCCEEDED(hr) ) {

            if ( (Column.pADsValues)->Boolean ) {
                schemaObject->isDefunct = TRUE;
            }

            pDSSearch->FreeColumn( &Column );
        }

        //
        // Get the class specific data.
        //

        if ( ObjectType == SCHMMGMT_CLASS ) {

            //
            // Get the attributes and auxiliary classes for this class.
            //

            hr = pDSSearch->GetColumn( hSearchHandle, g_SystemMustContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->systemMustContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_SystemMayContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->systemMayContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_MustContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->mustContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_MayContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->mayContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_SystemAuxiliaryClass, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->systemAuxiliaryClass = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_AuxiliaryClass, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->auxiliaryClass = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_ObjectClassCategory, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->dwClassType = (Column.pADsValues)->Integer;
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_SubclassOf, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->subClassOf = (Column.pADsValues)->CaseIgnoreString;
                pDSSearch->FreeColumn( &Column );
            }

            //
            // Get the oid.
            //

            hr = pDSSearch->GetColumn( hSearchHandle, g_GlobalClassID, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->oid = (Column.pADsValues)->CaseIgnoreString;
                pDSSearch->FreeColumn( &Column );
            }

        }

        //
        // Get the attribute specific data.
        //

        if ( ObjectType == SCHMMGMT_ATTRIBUTE ) {

           //
           // Select a syntax string for the attribute.
           //

           CString            strAttributeSyntax;
           ADS_OCTET_STRING   OmObjectClass;
           UINT               omSyntax = 0;

           schemaObject->SyntaxOrdinal = SCHEMA_SYNTAX_UNKNOWN;
           OmObjectClass.dwLength      = 0;
           OmObjectClass.lpValue       = NULL;
 
           hr = pDSSearch->GetColumn( hSearchHandle, g_AttributeSyntax, &Column );
 
           if ( SUCCEEDED(hr) ) {
 
               strAttributeSyntax = (Column.pADsValues)->CaseIgnoreString;
               pDSSearch->FreeColumn( &Column );
 
               hr = pDSSearch->GetColumn( hSearchHandle, g_omSyntax, &Column );
 
               if ( SUCCEEDED(hr) ) {
                  omSyntax = (Column.pADsValues)->Integer;
                  pDSSearch->FreeColumn( &Column );
               }
 
               hr = pDSSearch->GetColumn( hSearchHandle, g_omObjectClass, &Column );
 
               if ( SUCCEEDED(hr) ) {
                  OmObjectClass = (Column.pADsValues)->OctetString;
               }
         
               schemaObject->SyntaxOrdinal = GetSyntaxOrdinal(
                                    strAttributeSyntax, omSyntax, &OmObjectClass );
 
               // OmObjectClass has a pointer which becomes invalid after FreeColumn()
               if ( SUCCEEDED(hr) ) {
                  pDSSearch->FreeColumn( &Column );
                  OmObjectClass.dwLength = 0;
                  OmObjectClass.lpValue  = NULL;
               }
		   }
		   else
			   ASSERT( FALSE );

           //
           // Get the oid.
           //

           hr = pDSSearch->GetColumn( hSearchHandle, g_GlobalAttributeID, &Column );

           if ( SUCCEEDED(hr) ) {
               schemaObject->oid = (Column.pADsValues)->CaseIgnoreString;
               pDSSearch->FreeColumn( &Column );
           }

        }

        //
        // Insert this into the sorted item list.
        //

        InsertSortedTail( schemaObject );

        //
        // Insert this schema object into the cache.
        //

        InsertSchemaObject( schemaObject );
        schemaObject = NULL;

    }

    return S_OK;

}

VOID
SchemaObjectCache::InsertSortedTail(
    SchemaObject* pObject
) {

    SchemaObject **sorted_list;
    SchemaObject *pHead;

    //
    // Find the correct list.
    //

    if ( pObject->schemaObjectType == SCHMMGMT_CLASS ) {
        sorted_list = &pSortedClasses;
    } else {
        sorted_list = &pSortedAttribs;
    }

    //
    // Actually insert the element.
    //

    if ( *sorted_list == NULL ) {

        //
        // This is the first element.
        //

        *sorted_list = pObject;
        pObject->pSortedListFlink = pObject;
        pObject->pSortedListBlink = pObject;

    } else {

        //
        // This is not the first element;
        //

        pHead = *sorted_list;

        pObject->pSortedListBlink = pHead->pSortedListBlink;
        pHead->pSortedListBlink->pSortedListFlink = pObject;
        pHead->pSortedListBlink = pObject;
        pObject->pSortedListFlink = pHead;

    }

}

ListEntry*
SchemaObjectCache::MakeColumnList(
    PADS_SEARCH_COLUMN pColumn
) {

    ListEntry *pHead = NULL, *pLast = NULL, *pCurrent = NULL;

    for ( DWORD i = 0 ; i < pColumn->dwNumValues ; i++ ) {

        pCurrent = new ListEntry;

        //
        // If we run out of memory, return what we made so far.
        //

        if ( !pCurrent ) {
            break;
        }

        //
        // If there's no head, remember this as the first.
        // Otherwise, stick this on the end of the list
        // and update the last pointer.
        //

        if ( !pHead ) {
            pHead = pCurrent;
            pLast = pCurrent;
        } else {
            pLast->pNext = pCurrent;
            pLast = pCurrent;
        }

        //
        // Record the value.
        //

        pCurrent->Attribute = pColumn->pADsValues[i].CaseIgnoreString;
        DebugTrace( L"MakeColumnList recorded %ls.\n",
                    pColumn->pADsValues[i].CaseIgnoreString );

        //
        // That's it.
        //
    }

    return pHead;
}

VOID
SchemaObjectCache::FreeColumnList(
    ListEntry *pListHead
) {

    //
    // Delete the linked list.
    //

    ListEntry *pNext, *pCurrent;

    if ( !pListHead ) {
        return;
    }

    pCurrent = pListHead;

    do {

        pNext = pCurrent->pNext;
        delete pCurrent;

        pCurrent = pNext;

    } while ( pCurrent );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\attrpage.cpp ===
//
// attrpage.cpp : Implementation of ClassAttributePage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//
// templated from relation.cpp JonN 8/8/97
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(attrpage.cpp)")

#include "compdata.h"
#include "schmutil.h"
#include "select.h"
#include "attrpage.h"


const CDialogControlsInfo ctrls[] =
{
//    { IDC_CLASS_MMB_MANDATORY_ATTRIBUTES,   g_MustContain,  FALSE },
//    { IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES,    g_MayContain,   FALSE },
    { IDC_CLASS_MMB_OPTIONAL_ADD,           g_MayContain,   FALSE },
    { IDC_CLASS_MMB_OPTIONAL_REMOVE,        g_MayContain,   FALSE },
} ;


const DWORD ClassAttributePage::help_map[] =
{
    IDI_CLASS,                          NO_HELP,
    IDC_CLASS_MMB_NAME_STATIC,          NO_HELP,
    IDC_CLASS_MMB_MANDATORY_ATTRIBUTES, IDH_CLASS_MMB_MANDATORY_ATTRIBUTES,
    IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES,  IDH_CLASS_MMB_OPTIONAL_ATTRIBUTES,
    IDC_CLASS_MMB_SYSCLASS_STATIC,      NO_HELP,
    IDC_CLASS_MMB_OPTIONAL_ADD,         IDH_CLASS_MMB_OPTIONAL_ADD,
    IDC_CLASS_MMB_OPTIONAL_REMOVE,      IDH_CLASS_MMB_OPTIONAL_REMOVE,
    0,0
};


ClassAttributePage::ClassAttributePage(
   ComponentData *pScope,
   LPDATAOBJECT lpDataObject )
   :
   CPropertyPageAutoDelete(ClassAttributePage::IDD),
   m_pIADsObject( NULL ),
   fSystemClass( FALSE ),
   m_pSchemaObject( NULL ),
   pScopeControl( pScope ),
   lpScopeDataObj( lpDataObject )
{
   ASSERT(pScopeControl);
   ASSERT(lpDataObject);
}



ClassAttributePage::~ClassAttributePage()
{
   if (NULL != m_pIADsObject)
   {
      m_pIADsObject->Release();
   }

   if (NULL != m_pSchemaObject)
   {
      pScopeControl->g_SchemaCache.ReleaseRef( m_pSchemaObject );
   }
}



void
ClassAttributePage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.
    //

    m_pCookie = &CookieRef;
    return;

}

BOOL
ClassAttributePage::OnSetActive()
{
   // always enable the Apply button
   SetModified(TRUE);

   return TRUE;
}



BOOL
ClassAttributePage::OnInitDialog()
{
    HRESULT hr = S_OK;
    ASSERT( NULL == m_pIADsObject && m_szAdsPath.IsEmpty() );

    //
    // Get the schema cache object and the actual ADS object.
    //

    m_pSchemaObject = pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                      (PCWSTR)m_pCookie->strSchemaObject,
                      SCHMMGMT_CLASS );

    if ( m_pSchemaObject ) {

        pScopeControl->GetSchemaObjectPath( m_pSchemaObject->commonName, m_szAdsPath );

        if ( !m_szAdsPath.IsEmpty() ) {

           hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)m_szAdsPath,
                              IID_IADs,
                              (void **)&m_pIADsObject );

           ASSERT( SUCCEEDED(hr) );
        }

    }

    //
    // If we have no ADS object, we should error out!
    //

    if ( !m_pIADsObject ) {
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );

        ASSERT(FALSE);
        return TRUE;
    }

    //
    // get the current values.
    //

    VARIANT AdsResult;
    VariantInit( &AdsResult );

    //
    // ObjectName
    //

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                          &AdsResult );
   if ( SUCCEEDED( hr ) ) {
      ASSERT( AdsResult.vt == VT_BSTR );
      ObjectName = AdsResult.bstrVal;
      VariantClear( &AdsResult );
    }


    // NTRAID#NTBUG9-460503,460511-2001/09/10-lucios
    // Replaced SysClass Computation by Making the window visible

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                           &AdsResult );

    if ( SUCCEEDED( hr ) ) {
        ASSERT( AdsResult.vt == VT_BOOL );
        fSystemClass = AdsResult.boolVal;
        if ( fSystemClass ) {
            ASSERT(GetDlgItem( IDC_CLASS_MMB_SYSCLASS_STATIC ) != NULL);
            GetDlgItem( IDC_CLASS_MMB_SYSCLASS_STATIC )->ShowWindow( SW_SHOW );
        } 
        VariantClear( &AdsResult );
    }

    //
    // Determine the mandatory attributes
    //

    VARIANT varAttributes;
    VariantInit( &varAttributes );

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_MustContain), &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistMandatory );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_SystemMustContain), &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistSystemMandatory );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    //
    // Determine the optional attributes
    //

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_MayContain), &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistOptional );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_SystemMayContain), &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistSystemOptional );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    
    hr = DissableReadOnlyAttributes( this, m_pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
    // NTRAID#NTBUG9-503619-2002/05/15-lucios
    hr = S_OK;
    
    


    // This call must be done before DDX binding
    m_listboxOptional.InitType( pScopeControl,
                                SELECT_ATTRIBUTES,
                                IDC_CLASS_MMB_OPTIONAL_REMOVE,
                                &strlistSystemOptional
                              );
    
    CPropertyPage::OnInitDialog();

    return TRUE;
}



void
ClassAttributePage::DoDataExchange(
    CDataExchange *pDX
) {

    HRESULT hr = S_OK;

    CPropertyPage::DoDataExchange( pDX );

    //{{AFX_DATA_MAP(ClassAttributePage)
    DDX_Control(pDX, IDC_CLASS_MMB_MANDATORY_ATTRIBUTES, m_listboxMandatory);
    DDX_Control(pDX, IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES, m_listboxOptional);
    DDX_Text( pDX, IDC_CLASS_MMB_NAME_STATIC, ObjectName );
    //}}AFX_DATA_MAP

    if ( !pDX->m_bSaveAndValidate )
    {
        //
        // Fill the mandatory attributes list box.
        //

        m_listboxMandatory.ResetContent();
        hr = InsertEditItems( m_listboxMandatory, strlistMandatory );
        ASSERT( SUCCEEDED(hr) );

        hr = InsertEditItems( m_listboxMandatory, strlistSystemMandatory );
        ASSERT( SUCCEEDED(hr) );

        //
        // Fill the possible optionals list box.
        //

        m_listboxOptional.ResetContent();
        hr = InsertEditItems( m_listboxOptional, strlistOptional );
        ASSERT( SUCCEEDED(hr) );

        hr = InsertEditItems( m_listboxOptional, strlistSystemOptional );
        ASSERT( SUCCEEDED(hr) );

        m_listboxOptional.OnSelChange();
    }
    else
    {
        //
        // All changes that we save are tied to button control routines.
        //

        strlistMandatory.RemoveAll();
        hr = RetrieveEditItemsWithExclusions(
                m_listboxMandatory,
                strlistMandatory,
                &strlistSystemMandatory
                );
        ASSERT( SUCCEEDED(hr) );

        strlistOptional.RemoveAll();
        hr = RetrieveEditItemsWithExclusions(
                m_listboxOptional,
                strlistOptional,
                &strlistSystemOptional
                );
        ASSERT( SUCCEEDED(hr) );
    }
}



BEGIN_MESSAGE_MAP(ClassAttributePage, CPropertyPage)
   ON_BN_CLICKED(IDC_CLASS_MMB_OPTIONAL_ADD,           OnButtonOptionalAttributeAdd)   
   ON_BN_CLICKED(IDC_CLASS_MMB_OPTIONAL_REMOVE,        OnButtonOptionalAttributeRemove)
   ON_LBN_SELCHANGE(IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES, OnOptionalSelChange)            
   ON_MESSAGE(WM_HELP,                                 OnHelp)                         
   ON_MESSAGE(WM_CONTEXTMENU,                          OnContextHelp)
END_MESSAGE_MAP()



BOOL
ClassAttributePage::OnApply()
{

    ASSERT( NULL != m_pIADsObject);
    ASSERT( NULL != m_pSchemaObject);

    HRESULT hr = S_OK;
    BOOL    fApplyAbort    = FALSE;  // stop later saves
    BOOL    fApplyFailed   = FALSE;  // should not close the box

    ListEntry *pNewList;

    if ( m_listboxOptional.IsModified() )
    {
        //
        // Update the optional attributes
        //

        VARIANT AdsValue;
        VariantInit( &AdsValue );

        hr = StringListToVariant( AdsValue, strlistOptional );
        // NTRAID#NTBUG9-543624-2002/02/15-dantra-Result of StringListToVariant being ignored resulting in call to IADs::PutEx with incorrect data

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        if( SUCCEEDED( hr ) ) hr = m_pIADsObject->PutEx( ADS_PROPERTY_UPDATE, CComBSTR(g_MayContain), AdsValue );
        VariantClear( &AdsValue );
        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if( SUCCEEDED( hr ) ) hr = m_pIADsObject->SetInfo();

        if ( SUCCEEDED( hr )) {

            //
            // Update the cached data.
            //

            hr = StringListToColumnList( pScopeControl,
                                         strlistOptional,
                                         &pNewList );

            if ( SUCCEEDED( hr )) {

                pScopeControl->g_SchemaCache.FreeColumnList( m_pSchemaObject->mayContain );
                m_pSchemaObject->mayContain = pNewList;

            }

            //
            // Continue with the directory operation even if
            // we couldn't update the cache.
            //

            hr = S_OK;

        }
    }

    if ( hr == ADS_EXTENDED_ERROR ) {
        DoExtErrMsgBox();
    }
    else if ( FAILED(hr) )
    {
        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CHANGE_REJECT );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }
    }
    else
    {
        m_listboxOptional.SetModified( FALSE );

        SetModified( FALSE );

        //
        // Refresh the display!
        //

        pScopeControl->QueryConsole()->UpdateAllViews(
            lpScopeDataObj, SCHMMGMT_CLASS, SCHMMGMT_UPDATEVIEW_REFRESH );

    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}



void ClassAttributePage::OnOptionalSelChange()
{
    m_listboxOptional.OnSelChange();
}



void ClassAttributePage::OnButtonOptionalAttributeRemove()
{
    if( m_listboxOptional.RemoveListBoxItem() )
        SetModified( TRUE );
}



void
ClassAttributePage::OnButtonOptionalAttributeAdd()
{
    if( m_listboxOptional.AddNewObjectToList() )
        SetModified( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\classgen.hpp ===
#ifndef CLASSGEN_HPP_INCLUDED
#define CLASSGEN_HPP_INCLUDED

#include "CPropertyPageAutoDelete.hpp"

class ClassGeneralPage : public CPropertyPageAutoDelete
{
public:

   ClassGeneralPage( ComponentData *pScope );

   ~ClassGeneralPage();

   void Load( Cookie& CookieRef );

   //
   // The schema object that this property page is for.
   //

   ComponentData *pScopeControl;

   Cookie *pCookie;
   SchemaObject *pObject;
   IADs *pIADsObject;
   BOOL fDataLoaded;

   //
   // Data members for property fields.
   //

   CString ObjectName;
   CString DisplayName;
   CString Description;
   CString OidString;
   CString ClassType;
   CString Category;
   BOOL    Displayable;
   BOOL    Defunct;

   //
   // DDX Associated variables that we care about.
   //

   CString DDXDescription;
   CString DDXCategory;
   BOOL    DDXDisplayable;
   BOOL    DDXDefunct;

   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   virtual void DoDataExchange( CDataExchange *pDX );
   virtual BOOL OnSetActive();


   BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   void	   OnDeactivateClick();

protected:

   static const DWORD help_map[];

   afx_msg void OnButtonCategoryChange();

   HRESULT ChangeDefunctState( BOOL               DDXDefunct,
                               BOOL             & Defunct,
                               IADsPropertyList * pPropertyList,
                               BOOL             & fApplyAbort,
                               BOOL             & fApplyFailed );


private:

   DECLARE_MESSAGE_MAP()
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cache.h ===
/****

Cache.h
CoryWest@Microsoft.Com

The schema caching routines to improve browsing performance.

Copyright July 1997, Microsoft Corporation

****/

#include "nodetype.h"

#ifndef __CACHE_H_INCLUDED__
#define __CACHE_H_INCLUDED__

//
// The schema class objects.
//

#define HASH_TABLE_SIZE 1000

class SchemaObject;
class ListEntry;

class SchemaObjectCache {

    //
    // We let certain routines walk the hash table
    // to populate the list views.
    //

    friend class Component;
    friend class ComponentData;
    friend class CSchmMgmtSelect;
    friend class ClassGeneralPage;

    friend HRESULT StringListToColumnList(
                       ComponentData* pScopeControl,
                       CStringList& refstringlist,
                       ListEntry **ppNewList );

private:

    //
    // A rudimentary hash table with no resizing.
    //

    BOOLEAN fInitialized;
    UINT buckets;
    SchemaObject** hash_table;

    UINT CalculateHashKey( CString HashKey );

    //
    // The server sorted lists of elements.
    //

    SchemaObject* pSortedClasses;
    SchemaObject* pSortedAttribs;

public:

    //
    // Initialize and cleanup the cache.
    //

    SchemaObjectCache();
    ~SchemaObjectCache();

    //
    // Access routines.  ReleaseRef() must be called after every
    // LookupSchemaObject when the caller is done with the the
    // SchemaObject pointer.
    //
    // LookupSchemaObject takes an object type because there
    // may be a class and an attribute with the same ldapDisplayName.
    //

    HRESULT InsertSchemaObject( SchemaObject* Object );
    HRESULT InsertSortedSchemaObject( SchemaObject *Object );

    SchemaObject* LookupSchemaObject( CString ldapDisplayName,
                                      SchmMgmtObjectType ObjectType,
                                      bool lookDefunct = false);
    SchemaObject* LookupSchemaObjectByCN( LPCTSTR pszCN,
                                          SchmMgmtObjectType objectType );

    VOID ReleaseRef( SchemaObject* pObject );

    //
    // Load and reload.
    //

    HRESULT LoadCache( VOID );

    HRESULT ProcessSearchResults( IDirectorySearch *pDSSearch,
                                  ADS_SEARCH_HANDLE hSearchHandle,
                                  SchmMgmtObjectType ObjectType );
    VOID InsertSortedTail( SchemaObject* pObject );

    ListEntry* MakeColumnList( PADS_SEARCH_COLUMN pColumn );
    VOID FreeColumnList( ListEntry *pListHead );

    VOID FreeAll( );

    //
    // The scope control that this is the cache for.
    //

    VOID SetScopeControl( ComponentData *pScope ) {
        pScopeControl = pScope;
    }

    //
    // Has the schema been loaded
    //
    BOOLEAN IsSchemaLoaded() { return fInitialized; }

    ComponentData *pScopeControl;
};



class SchemaObject {

private:
public:

    //
    // The hash chain variable.
    //

    SchemaObject* pNext;

    SchemaObject* pSortedListFlink;
    SchemaObject* pSortedListBlink;

    //
    // Constructors.
    //

    SchemaObject();
    ~SchemaObject();

    //
    // The common object information.
    // The ldap display name is the hash key.
    //

    CString ldapDisplayName;
    CString commonName;
    CString description;

    //
    // If this is an object that we have added, it
    // will have an oid here and we should refer to
    // the object by its oid since that is the only
    // way we can guarantee that the ds will know
    // the object.
    //

    CString oid;

    //
    // If this object is defunct, do not show it in the
    // classes or attributes select box!
    //

    BOOL isDefunct;

    SchmMgmtObjectType schemaObjectType;

    //
    // Class object specific data for the cache.
    //

    DWORD dwClassType;

    ListEntry *systemMayContain;
    ListEntry *mayContain;

    ListEntry *systemMustContain;
    ListEntry *mustContain;

    ListEntry *systemAuxiliaryClass;
    ListEntry *auxiliaryClass;

    CString subClassOf;

    //
    // Attribute object specific data for the cache.
    //

    UINT SyntaxOrdinal;

};

class ListEntry {

private:
public:

    ListEntry *pNext;
    CString Attribute;

    ListEntry() { pNext = NULL; }
    ~ListEntry() { ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\classgen.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "select.h"
#include "classgen.hpp"




/////////////////////////////////////////////////////////////////
// ClassGeneralPage


const CDialogControlsInfo ctrls[] =    
{
    { IDC_CLASS_GENERAL_DESCRIPTION_EDIT,   g_Description,       TRUE },
    { IDC_CATEGORY_CHANGE,                  g_DefaultCategory,   FALSE },
    { IDC_CLASS_GENERAL_DISPLAYABLE_CHECK,  g_ShowInAdvViewOnly, FALSE },
    { IDC_CLASS_DEACTIVATE,                 g_isDefunct,           FALSE }
};

const DWORD ClassGeneralPage::help_map[] =
{
    IDI_CLASS,                           NO_HELP,
    IDC_CLASS_GENERAL_NAME_STATIC,       NO_HELP,
    IDC_CLASS_GENERAL_DESCRIPTION_EDIT,  IDH_CLASS_GENERAL_DESCRIPTION_EDIT,
    IDC_CLASS_GENERAL_LDN,               IDH_CLASS_GENERAL_LDN,
    IDC_CLASS_GENERAL_OID_EDIT,          IDH_CLASS_GENERAL_OID_EDIT,
    IDC_CLASS_GENERAL_CATEGORY_COMBO,    IDH_CLASS_GENERAL_CATEGORY_COMBO,
    IDC_CATEGORY_EDIT,                   IDH_CATEGORY_EDIT,
    IDC_CATEGORY_CHANGE,                 IDH_CATEGORY_CHANGE,
    IDC_CLASS_GENERAL_DISPLAYABLE_CHECK, IDH_CLASS_GENERAL_DISPLAYABLE_CHECK,
    IDC_CLASS_DEACTIVATE,                IDH_CLASS_DEACTIVATE,
    IDC_CLASS_GENERAL_SYSCLASS_STATIC,   NO_HELP,
    0,                                   0
};

//
// The MFC Message Map.
//

BEGIN_MESSAGE_MAP( ClassGeneralPage, CDialog )
    ON_BN_CLICKED( IDC_CATEGORY_CHANGE,  OnButtonCategoryChange  )
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
    ON_BN_CLICKED(IDC_CLASS_DEACTIVATE, OnDeactivateClick)
END_MESSAGE_MAP()

//
// Class dialog box routines.
//



ClassGeneralPage::ClassGeneralPage( ComponentData *pScope ) :
    CPropertyPageAutoDelete( IDD_CLASS_GENERAL ),
    fDataLoaded( FALSE ),
    pIADsObject( NULL ),
    pObject( NULL ),
    pScopeControl( pScope )
{ ; }

ClassGeneralPage::~ClassGeneralPage() {

    //
    // Always make sure we free the IADs object.
    //

    if ( pIADsObject ) {
        pIADsObject->Release();
        pIADsObject = NULL;
    }

    //
    // And release the cache!
    //

    if ( pObject ) {
        pScopeControl->g_SchemaCache.ReleaseRef( pObject );
    }

}



BOOL
ClassGeneralPage::OnInitDialog()
{
   CPropertyPage::OnInitDialog();

   CWnd* wnd = GetDlgItem(IDC_CLASS_GENERAL_DESCRIPTION_EDIT);
   ASSERT(wnd);
   if (wnd)
   {
      wnd->SendMessage(EM_SETLIMITTEXT, (WPARAM) 1024, 0);
   }

    // NTRAID#NTBUG9-460503,460511-2001/09/10-lucios
    // Replaced SysClass Computation by Making the window visible in OnInitDialog
    if(pIADsObject != NULL) 
    {   // DoDataExchange has gotten a good pIADsObject or the dialog 
        // will be closed in OnSetActive

        VARIANT	AdsResult;
        VariantInit( &AdsResult );

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        HRESULT hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {
            ASSERT( AdsResult.vt == VT_BOOL );
            if ( AdsResult.boolVal ) {
                ASSERT(GetDlgItem( IDC_CLASS_GENERAL_SYSCLASS_STATIC ) != NULL);
                GetDlgItem( IDC_CLASS_GENERAL_SYSCLASS_STATIC )->ShowWindow( SW_SHOW );
            } 
            VariantClear( &AdsResult );
        }
    }

    return TRUE;
}




BOOL
ClassGeneralPage::OnSetActive()
{
   // If pIADsObject is NULL, close dialog box
   if( CPropertyPage::OnSetActive() )
   {
      if ( !pIADsObject )
      {
         return FALSE;
      }
      else
      {
         // always enable the Apply button 
         SetModified(TRUE);

         return TRUE;
      }
   }
   else
      return FALSE;
}


void
ClassGeneralPage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.  Everything
    // else gets loaded when the page is displayed.
    //

    pCookie = &CookieRef;
    return;

}

void
ClassGeneralPage::DoDataExchange(
    CDataExchange *pDX
)
/***

    This routine picks up the object name out of the
    cookie and then looks up the ADSI path name out of
    the schema object cache.  It then drives the dialog
    box directly from the ADS object.

***/
{
    CThemeContextActivator activator;

    HRESULT hr;
    CString szAdsPath;
    VARIANT AdsResult;
    DWORD dwClassType;

    CPropertyPage::DoDataExchange( pDX );

    VariantInit( &AdsResult );

    if ( !pDX->m_bSaveAndValidate ) {


        //
        // If this is not the initial load and is not
        // the save, just use the data that we've loaded.
        //

        if ( !fDataLoaded ) {

            CWaitCursor wait;

            //
            // Get the schema cache object and the actual ADS object.
            // Keep both around while the page is loaded.
            //
        
            pObject = pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                          pCookie->strSchemaObject,
                          SCHMMGMT_CLASS );

            if ( pObject ) {

                pScopeControl->GetSchemaObjectPath( pObject->commonName, szAdsPath );

                if ( !szAdsPath.IsEmpty() ) {

                    hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)szAdsPath,
                                       IID_IADs,
                                       (void **)&pIADsObject );
                }
            }

            //
            // If we have no ADS object, we should error out!
            //

            if ( !pIADsObject ) {
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );

				// Because there is no pIADsObject, OnSetActive() will close dialog box
                return;
            }

            //
            // ObjectName - Use the ldapDisplayName to be consistent with
            // the other admin components.
            //

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                ObjectName = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            //
            // CommonName
            //

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_CN),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                DisplayName = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            // Description
            //

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_Description),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                Description = AdsResult.bstrVal;
                DDXDescription = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            // OID
            //

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_GlobalClassID),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                OidString = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            // Displayable
            //

            Displayable = TRUE;
            DDXDisplayable = TRUE;

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get(CComBSTR(g_ShowInAdvViewOnly), &AdsResult);

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BOOL );

                if ( AdsResult.boolVal == -1 ) {
                    Displayable = FALSE;
                    DDXDisplayable = FALSE;
                }

                VariantClear( &AdsResult );

            }

            //
            // Defunct
            //

            Defunct = FALSE;
            DDXDefunct = FALSE;

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BOOL );

                if ( AdsResult.boolVal == -1 ) {
                    Defunct = TRUE;
                    DDXDefunct = TRUE;
                }

                VariantClear( &AdsResult );

            }

            // NTRAID#NTBUG9-460503,460511-2001/09/10-lucios
            // Replaced SysClass Computation by Making the window visible in OnInitDialog

            //
            // ClassType
            //

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_ObjectClassCategory),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_I4 );
                dwClassType = V_I4( &AdsResult );
                VariantClear( &AdsResult );

                switch ( dwClassType ) {
                case 0:

                    ClassType = g_88Class;
                    break;

                case 1:

                    ClassType = g_StructuralClass;
                    break;

                case 2:

                    ClassType = g_AbstractClass;
                    break;

                case 3:

                    ClassType = g_AuxClass;
                    break;

                default:

                    ClassType = g_Unknown;
                    break;

                }
            }

            //
            // Category
            //

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( V_VT(&AdsResult) == VT_BSTR );

                CString strCN;

                if( SUCCEEDED( pScopeControl->GetLeafObjectFromDN( V_BSTR(&AdsResult), strCN ) ))
                {
                    //
                    // Look up the ldapDisplayName.
                    //
                    SchemaObject * pCategory =
                        pScopeControl->g_SchemaCache.LookupSchemaObjectByCN( strCN, SCHMMGMT_CLASS );

                    if ( pCategory )
                    {
                        Category = DDXCategory = pCategory->ldapDisplayName;
                        pScopeControl->g_SchemaCache.ReleaseRef( pCategory );
                    }
                    else
                    {
                        Category = DDXCategory = strCN;
                    }
                }

                VariantClear( &AdsResult );
            }

            
            // Determine if this is a category 1 object & disable read-only fields
            BOOL  fIsSystemObject = FALSE;

            hr = IsCategory1Object( pIADsObject, fIsSystemObject );
            if( SUCCEEDED(hr) && fIsSystemObject )
            {
                ASSERT( GetDlgItem(IDC_CATEGORY_CHANGE) );
                ASSERT( GetDlgItem(IDC_CLASS_DEACTIVATE) );

                GetDlgItem(IDC_CATEGORY_CHANGE)->EnableWindow( FALSE );
                GetDlgItem(IDC_CLASS_DEACTIVATE)->EnableWindow( FALSE );
            }

            hr = DissableReadOnlyAttributes( this, pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
            // NTRAID#NTBUG9-503619-2002/05/15-lucios
            hr = S_OK;
            

            // warn the user if this is a read/write defunct object
            ASSERT( GetDlgItem(IDC_CLASS_DEACTIVATE) );
            
            if( DDXDefunct &&
                GetDlgItem(IDC_CLASS_DEACTIVATE)->IsWindowEnabled() )
            {
                AfxMessageBox( IDS_WARNING_DEFUNCT, MB_OK | MB_ICONINFORMATION );
            }

            //
            // Remember that the data is loaded.
            //

            fDataLoaded = TRUE;

        }
    }

    //
    // Set up the dialog data exchange.
    //

    DDX_Text( pDX, IDC_CLASS_GENERAL_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_CLASS_GENERAL_CATEGORY_COMBO, ClassType );
    DDX_Text( pDX, IDC_CLASS_GENERAL_DESCRIPTION_EDIT, DDXDescription );
    DDX_Text( pDX, IDC_CLASS_GENERAL_LDN, DisplayName );
    DDX_Text( pDX, IDC_CLASS_GENERAL_OID_EDIT, OidString );
    DDX_Text( pDX, IDC_CATEGORY_EDIT, DDXCategory );
    DDX_Check( pDX, IDC_CLASS_GENERAL_DISPLAYABLE_CHECK, DDXDisplayable );

    // Since we want the checkbox label to be positive
    // the value is actually the opposite of defunct

    int checkValue = !Defunct;
    DDX_Check( pDX, IDC_CLASS_DEACTIVATE, checkValue );
    DDXDefunct = !checkValue;

    return;
}

BOOL
ClassGeneralPage::OnApply(
    VOID
) {

    HRESULT hr;
    VARIANT AdsValue;
    BOOL fChangesMade = FALSE;
    BOOL fApplyAbort  = FALSE;  // stop later saves
    BOOL fApplyFailed = FALSE;  // should not close the box

    if ( !UpdateData(TRUE) ) {
        return FALSE;
    }

    //
    // We have to flush the IADS property cache if we
    // have a failure so later operations won't fail because
    // of a bad cached attribute.
    //

    IADsPropertyList *pPropertyList;

    hr = pIADsObject->QueryInterface( IID_IADsPropertyList,
                                      reinterpret_cast<void**>(&pPropertyList) );
    if ( FAILED( hr ) ) {
        pPropertyList = NULL;
        fApplyAbort = TRUE;
    }

    //
    // We only care if the description, class type, or
    // displayable attributes changed.
    //

    VariantInit( &AdsValue );

    //
    // Defunct -- in case it was deactivated, activate the object first
    //
    // NTRAID#NTBUG9-477292-2001/10/10-lucios
    // && !DDXDefunct was taken out and fChangesMade=TRUE added
    if( !fApplyAbort && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
        if (FAILED(hr)) fApplyAbort = TRUE;
        else fChangesMade = TRUE;
    }


    
    if ( !fApplyAbort && DDXDescription != Description ) {

        V_VT(&AdsValue) = VT_BSTR;
        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        V_BSTR(&AdsValue) = const_cast<BSTR>((LPCTSTR)DDXDescription);

        if ( DDXDescription.IsEmpty() ) {

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
                                     const_cast<BSTR>((LPCTSTR)g_Description),
                                     AdsValue );
        } else {

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_Description),
                                   AdsValue );
        }

        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

        if ( SUCCEEDED( hr ) ) {

            pObject->description = DDXDescription;
            fChangesMade = TRUE;
			Description = DDXDescription;

        } else {

            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DESC );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }

        VariantInit( &AdsValue );
    }


    if ( !fApplyAbort && DDXDisplayable != Displayable ) {

        V_VT(&AdsValue) = VT_BOOL;

        if ( DDXDisplayable ) {
            V_BOOL(&AdsValue) = 0;
        } else {
            V_BOOL(&AdsValue) = -1;
        }

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Put( CComBSTR(g_ShowInAdvViewOnly), AdsValue);

        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DISPLAYABLE );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			Displayable = DDXDisplayable;
		}

        VariantInit( &AdsValue );
    }

    if ( !fApplyAbort && DDXCategory != Category ) {

        SchemaObject *pCategoryObject;
        CString DistName;

        hr = E_FAIL;

        V_VT(&AdsValue) = VT_BSTR;

        //
        // Map the commonName to the distinguished name.
        //

        pCategoryObject = pScopeControl->g_SchemaCache.LookupSchemaObject(
                              DDXCategory,
                              SCHMMGMT_CLASS );

        if ( pCategoryObject ) {

            pScopeControl->GetSchemaObjectPath(pCategoryObject->commonName, DistName, ADS_FORMAT_X500_DN );

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            V_BSTR(&AdsValue) = const_cast<BSTR>((LPCTSTR)DistName);

            // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                                   AdsValue );
            if( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();
        }

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_CATEGORY );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			Category = DDXCategory;
		}

        VariantInit( &AdsValue );
    }

    //
    // Defunct -- in case it was active, deactivate the object after we are done update
    //
    if( !fApplyAbort && DDXDefunct && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
    }

    
    if ( !fApplyAbort && fChangesMade ) {

        //
        // Call SetItem() so this gets refreshed.
        //

        SCOPEDATAITEM ScopeItem;
        CCookieListEntry *pEntry;
        BOOLEAN fFoundId = FALSE;

        if ( pScopeControl->g_ClassCookieList.pHead ) {

           pEntry = pScopeControl->g_ClassCookieList.pHead;

           if ( (pScopeControl->g_ClassCookieList.pHead)->pCookie == pCookie ) {

               fFoundId = TRUE;

           } else {

               while ( pEntry->pNext != pScopeControl->g_ClassCookieList.pHead ) {

                   if ( pEntry->pCookie == pCookie ) {
                       fFoundId = TRUE;
                       break;
                   }

                   pEntry = pEntry->pNext;
               }

           }

           if ( fFoundId ) {

              // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
              // the definition of ScopeItem to SCOPEDATAITEM ScopeItem = {0} and removing the ZeroMemory call.
              ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
              ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_PARENT;
              ScopeItem.displayname = MMC_CALLBACK;
              ScopeItem.relativeID = pScopeControl->g_ClassCookieList.hParentScopeItem;
              ScopeItem.nState = 0;
              ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pCookie);
              ScopeItem.nImage = pScopeControl->QueryImage( *pCookie, FALSE );
              ScopeItem.nOpenImage = pScopeControl->QueryImage( *pCookie, TRUE );
              ScopeItem.ID = pEntry->hScopeItem;

              hr = pScopeControl->m_pConsoleNameSpace->SetItem( &ScopeItem );
              ASSERT( SUCCEEDED( hr ));
           }

        }

    }

    if ( pPropertyList ) {
        pPropertyList->Release();
    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}

VOID
ClassGeneralPage::OnButtonCategoryChange(
) {

    SchemaObject *pClass = NULL;
    INT_PTR DlgResult;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;


    //
    // Update any changes the user has made.
    //

    UpdateData( TRUE );

    //
    // Start the common select dialog box.
    //

    CSchmMgmtSelect dlgSelect( pScopeControl,
                                   SELECT_CLASSES,
                                   &pClass );

	DlgResult = dlgSelect.DoModal();

	//
	// When this returns, the class schema object
	// pointer will be filled into pClass.
	//

	if ( ( DlgResult == IDOK ) &&
		 ( pClass != NULL ) ) {

		DDXCategory = pClass->ldapDisplayName;

		//
		// Push this back out to the UI.
		//

		UpdateData( FALSE );

	}

    return;
}


void
ClassGeneralPage::OnDeactivateClick()
{
   CThemeContextActivator activator;

   if( !IsDlgButtonChecked(IDC_CLASS_DEACTIVATE) )
   {
      if
      (  IDYES != AfxMessageBox
                  ( 
                     IDS_WARNING_DEFUNCT_SET, 
                     MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING 
                  )
      )
      {
         CheckDlgButton( IDC_CLASS_DEACTIVATE, BST_CHECKED );
      }
   }
}


HRESULT
ClassGeneralPage::ChangeDefunctState( BOOL               DDXDefunct,
                                      BOOL             & Defunct,
                                      IADsPropertyList * pPropertyList,
                                      BOOL             & fApplyAbort,
                                      BOOL             & fApplyFailed )
{
    ASSERT( !fApplyAbort && DDXDefunct != Defunct );

    VARIANT AdsValue;
    HRESULT hr = S_OK;

    VariantInit( &AdsValue );
    V_VT(&AdsValue) = VT_BOOL;

    if ( DDXDefunct ) {
        V_BOOL(&AdsValue) = -1;
    } else {
        V_BOOL(&AdsValue) = 0;
    }

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                           AdsValue );
    // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
    if( SUCCEEDED( hr ) ) hr = pIADsObject->SetInfo();

    if ( FAILED( hr ) ) {

        pPropertyList->PurgePropertyList();

        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(),
                         TRUE,
                         DDXDefunct ? IDS_ERR_EDIT_DEFUNCT_SET : IDS_ERR_EDIT_DEFUNCT_REMOVE );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }

    } else {

        pObject->isDefunct = DDXDefunct;
		Defunct = DDXDefunct;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cmponent.cpp ===
//
// cmponent.cpp : Declaration of Component.
//
// This COM object is primarily concerned with
// the result pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(cmponent.cpp)")

#include "dataobj.h"
#include "cmponent.h" // Component
#include "compdata.h" // ComponentData
#include "schmutil.h"
#include "attrgen.hpp"


#include "stdcmpnt.cpp" // CComponent



//
// These arrays describe the result pane layout for when
// any particular object is selected.
//

UINT
g_aColumns0[5] = {

    IDS_COLUMN_NAME,
    IDS_COLUMN_TYPE,
    IDS_COLUMN_STATUS,
    IDS_COLUMN_DESCRIPTION,
    0
};

UINT
g_aColumns1[5] = {

    IDS_COLUMN_NAME,
    IDS_COLUMN_SYNTAX,
    IDS_COLUMN_STATUS,
    IDS_COLUMN_DESCRIPTION,
    0
};

UINT
g_aColumns2[6] = {

    IDS_COLUMN_NAME,
    IDS_COLUMN_TYPE,
    IDS_COLUMN_SYSTEM,
    IDS_COLUMN_DESCRIPTION,
    IDS_COLUMN_PARENT,
    0
};

UINT
g_aColumns3[2] =
{
   IDS_COLUMN_NAME,
   0
};
      
UINT*
g_Columns[SCHMMGMT_NUMTYPES] = {

    g_aColumns3,         // SCHMMGMT_SCHMMGMT
    g_aColumns0,         // SCHMMGMT_CLASSES
    g_aColumns1,         // SCHMMGMT_ATTRIBUTES
    g_aColumns2,         // SCHMMGMT_CLASS
    g_aColumns0,         // SCHMMGMT_ATTRIBUTE     // @@ Is this used?
};

UINT** g_aColumns = g_Columns;

//
// These control the column widths, which I will not change.
//

int g_aColumnWidths0[4] = {150,150,75,150};
int g_aColumnWidths1[5] = {150,75,75,150,150};
int g_aColumnWidths2[1] = {150};

int* g_ColumnWidths[SCHMMGMT_NUMTYPES] = {

    g_aColumnWidths2,       // SCHMMGMT_SCHMMGMT
    g_aColumnWidths0,       // SCHMMGMT_CLASSES
    g_aColumnWidths0,       // SCHMMGMT_ATTRIBUTES
    g_aColumnWidths1,       // SCHMMGMT_CLASS
    g_aColumnWidths0,       // SCHMMGMT_ATTRIBUTE
};

int** g_aColumnWidths = g_ColumnWidths;

//
// Constructors and destructors.
//

Component::Component()
:       m_pSvcMgmtToolbar( NULL ),
        m_pSchmMgmtToolbar( NULL ),
        m_pControlbar( NULL ),
        m_bDirty(false)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    m_pViewedCookie = NULL;
}

Component::~Component()
{
    TRACE_METHOD(Component,Destructor);
    VERIFY( SUCCEEDED(ReleaseAll()) );
}

HRESULT Component::ReleaseAll()
{
    MFC_TRY;

    TRACE_METHOD(Component,ReleaseAll);

    SAFE_RELEASE(m_pSvcMgmtToolbar);
    SAFE_RELEASE(m_pSchmMgmtToolbar);
    SAFE_RELEASE(m_pControlbar);

    return CComponent::ReleaseAll();

    MFC_CATCH;
}

//
// Support routines in ISchmMgmtComponent.
//


HRESULT
Component::LoadColumns(
    Cookie* pcookie
) {

    TEST_NONNULL_PTR_PARAM(pcookie);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return LoadColumnsFromArrays( (INT)(pcookie->m_objecttype) );
}

HRESULT
Component::OnViewChange(
    LPDATAOBJECT,
    LPARAM data,
    LPARAM function
)
/***

    This is called when IConsole->UpdateAllViews() is called.
    The data is a schema object type as follows:


    if function == 0 (SCHMMGMT_UPDATEVIEW_REFRESH)

        SCHMMGMT_ATTIBUTES - We need to refresh the attributes
            folder displays.
        SCHMMGMT_CLASS - We need to refresh _ALL_ class attribute
            displays.  We don't try and trace the inheritance
            graphs and do a selective refresh, that's too complicated.
        SCHMMGMT_SCHMMGMT - Refresh EVERYTHING because we reloaded
            the schema cache.

    else if function == 1 (SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM)

        data is the Cookie pointer
***/
{
    //
    // Refresh this result view.
    //
    if ( function == SCHMMGMT_UPDATEVIEW_REFRESH )
    {
       if ( m_pViewedCookie ) {

           if ( ( data == m_pViewedCookie->m_objecttype ) ||
                ( data == SCHMMGMT_SCHMMGMT ) ) {

               m_pResultData->DeleteAllRsltItems();
               PopulateListbox( m_pViewedCookie );

           }
       }
    }
    else if ( function == SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM )
    {
       HRESULTITEM item;
       // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
       // the definition of item to HRESULTITEM item = {0}; and removing the ZeroMemory call.
       ZeroMemory( &item, sizeof(HRESULTITEM) );

       HRESULT hr = m_pResultData->FindItemByLParam( data, &item );
       if ( SUCCEEDED(hr) )
       {
          hr = m_pResultData->DeleteItem( item, 0 );
          ASSERT( SUCCEEDED(hr) );

       }
    }

    return S_OK;
}


HRESULT
Component::OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL )
/***

        This called in response to MMCN_SELECT.
        This routine will set the default verb and enable the toolbar buttons.

***/
{
    CCookie* pBaseParentCookie = NULL;
    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              OUT reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );

    ASSERT( SUCCEEDED(hr) );
    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH,ENABLED,TRUE);

    switch ( pParentCookie->m_objecttype ) {

    case SCHMMGMT_CLASSES:
    case SCHMMGMT_ATTRIBUTES:

        break;

    case SCHMMGMT_CLASS:
       {
           //
           // Set the default verb to display the properties of the selected object.
           //

           m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
           m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

           // if the schema class is defunct and the forest version is Whistler or higher
           // then allow delete
/* Feature was removed for Whistler
           ComponentData& Scope = QueryComponentDataRef();
           if ( Scope.GetBasePathsInfo()->GetForestBehaviorVersion() >= 2)
           {
              SchemaObject *pSchemaObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                                              pParentCookie->strSchemaObject,
                                              SCHMMGMT_CLASS );

              if ( pSchemaObject &&
                   pSchemaObject->isDefunct )
              {
                  m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
              }
           }
           */
       }
       break;

    case SCHMMGMT_ATTRIBUTE:

        if ( ( pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE ) &&
             ( pParentCookie->pParentCookie ) &&
             ( pParentCookie->pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTES ) ) {

            //
            // Set the default verb to display the properties of the selected object.
            //

            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

            // if the schema class is defunct and the forest version is Whistler or higher
            // then allow delete
/* Feature was removed for Whistler

            ComponentData& Scope = QueryComponentDataRef();
            if ( Scope.GetBasePathsInfo()->GetForestBehaviorVersion() >= 2)
            {
               SchemaObject *pSchemaObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                                                pParentCookie->strSchemaObject,
                                                SCHMMGMT_ATTRIBUTE );

               if ( pSchemaObject &&
                    pSchemaObject->isDefunct )
               {
                   m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
               }
            }
*/
        } else {

            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        }

        break;

    default:

        //
        // Otherwise set the default verb to open/expand the folder.
        //

        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
        break;
    }

    return S_OK;
}


HRESULT
Component::Show(
    CCookie* pcookie,
    LPARAM arg,
	HSCOPEITEM hScopeItem
)
/***

    This is called in response to MMCN_SHOW.

***/
{
    TEST_NONNULL_PTR_PARAM(pcookie);
    
    HRESULT hr = S_OK;

    do
    {
        if ( TRUE == arg )      // showing...
        {
            if( QueryComponentDataRef().IsSetDelayedRefreshOnShow() )
            {
                HSCOPEITEM  hItem = QueryComponentDataRef().GetDelayedRefreshOnShowItem();
                ASSERT( hItem == hScopeItem ); 

                QueryComponentDataRef().SetDelayedRefreshOnShow( NULL );

                hr = m_pConsole->SelectScopeItem( hItem );      // will call GetResultViewType & Show
                ASSERT_BREAK_ON_FAILED_HRESULT(hr);
            }
            else if( QueryComponentDataRef().IsErrorSet() )
            {
                CComPtr<IUnknown>     pUnknown;
                CComPtr<IMessageView> pMessageView;
    
                hr = m_pConsole->QueryResultView(&pUnknown);
                ASSERT_BREAK_ON_FAILED_HRESULT(hr);

                hr = pUnknown->QueryInterface(IID_IMessageView, (PVOID*)&pMessageView);
                ASSERT_BREAK_ON_FAILED_HRESULT(hr);

                pMessageView->SetTitleText( CComBSTR( QueryComponentDataRef().GetErrorTitle() ) );
                pMessageView->SetBodyText( CComBSTR( QueryComponentDataRef().GetErrorText() ) );
                pMessageView->SetIcon(Icon_Error);
            }
            else
            {
                m_pViewedCookie = (Cookie*)pcookie;
                LoadColumns( m_pViewedCookie );
            
                hr = PopulateListbox( m_pViewedCookie );
            }
        }
        else    // hiding...
        {
            if( !QueryComponentDataRef().IsErrorSet() )
            {
                if ( NULL == m_pResultData )
                {
                    ASSERT( FALSE );
                    hr = E_UNEXPECTED;
                    break;
                }

                m_pViewedCookie = NULL;
            }
        }

    } while( FALSE );

    return hr;
}

HRESULT
Component::OnNotifyAddImages(
    LPDATAOBJECT,
    LPIMAGELIST lpImageList,
    HSCOPEITEM
)
/***

    This routine is called in response to MMCN_ADD_IMAGES.  Here's
    what mmc.idl says about this:

    Sent to IComponent to add images for the result pane. The
    primary snapin should add images for both folders and leaf items.

    arg = ptr to result panes IImageList.
    param = HSCOPEITEM of selected/deselected item

***/
{
    return QueryComponentDataRef().LoadIcons(lpImageList,TRUE);
}


HRESULT 
Component::OnNotifyDelete(
    LPDATAOBJECT lpDataObject)
{
    CThemeContextActivator activator;

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    UINT promptID = 0;
    LPARAM updateType = SCHMMGMT_CLASS;

    if (pParentCookie->m_objecttype == SCHMMGMT_CLASS)
    {
        promptID = IDS_DELETE_CLASS_PROMPT;
        updateType = SCHMMGMT_CLASS;
    }
    else if (pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE)
    {
        promptID = IDS_DELETE_ATTR_PROMPT;
        updateType = SCHMMGMT_ATTRIBUTES;
    }
    else
    {
        // We should never get called to delete anything but
        // class and attribute nodes

        ASSERT(FALSE);
        return E_FAIL;
    }

    if( IDYES == AfxMessageBox( promptID, MB_YESNO | MB_ICONWARNING ))
    {
       hr = DeleteAttribute(pParentCookie);
       if ( SUCCEEDED(hr) )
       {
         // Remove the node from the UI

         hr = m_pConsole->UpdateAllViews( lpDataObject,
                                          (LPARAM)pParentCookie,
                                          SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM );
         ASSERT( SUCCEEDED(hr) );
       }
       else
       {
          CString szDeleteError;
          szDeleteError.Format(IDS_ERRMSG_DELETE_FAILED_ATTRIBUTE, GetErrorMessage(hr, TRUE));
          
          DoErrMsgBox( ::GetActiveWindow(), TRUE, szDeleteError );
       }
    }

    return hr;
}

HRESULT
Component::DeleteAttribute(
    Cookie* pcookie
)
/***

    This deletes an attribute from the schema

***/
{
   HRESULT hr = S_OK;

   do
   {
      if ( !pcookie )
      {
         hr = E_INVALIDARG;
         break;
      }

      ComponentData& Scope = QueryComponentDataRef();

      SchemaObject* pObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                                pcookie->strSchemaObject,
                                SCHMMGMT_ATTRIBUTE );

      if ( !pObject )
      {
         hr = E_FAIL;
         break;
      }

      CString szAdsPath;
      Scope.GetSchemaObjectPath( pObject->commonName, szAdsPath );

      hr = DeleteObject( szAdsPath, pcookie, g_AttributeFilter );
   } while (false);

   return hr;
}

HRESULT
Component::PopulateListbox(
    Cookie* pcookie
)
/***

    This populates the result pane when the result pane
    contains data that is not directly derived from the
    data in the scope pane.

***/
{
    switch ( pcookie->m_objecttype ) {

    case SCHMMGMT_SCHMMGMT:
    case SCHMMGMT_CLASSES:

        //
        // We don't care about these - the result
        // pane contains only scope items.
        //

        break;

    case SCHMMGMT_ATTRIBUTES:

        //
        // List the specified items in the result pane
        // with some informational data.
        //

        return FastInsertAttributeResultCookies(
                   pcookie );

        break;

    case SCHMMGMT_CLASS:

        //
        // This results in the attributes used in this
        // class and other class data being displayed.
        //

        return FastInsertClassAttributesResults( pcookie );
        break;


    case SCHMMGMT_ATTRIBUTE:

        //
        // This is not a scope pane item and can have no
        // corresponding result pane data!!
        //

        ASSERT(FALSE);
        break;

    }

    return S_OK;
}

HRESULT
Component::FastInsertAttributeResultCookies(
    Cookie* pParentCookie
)
/***

    When the "Attributes" folder is selected, this puts
    the attributes in the result pane.

    pParentCookie is the cookie for the parent object.

    This routine is similar to
    ComponentData::FastInsertClassScopeCookies.

****/
{

    HRESULT hr;
    SchemaObject *pObject, *pHead;
    Cookie *pNewCookie;
    RESULTDATAITEM ResultItem;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();
    ComponentData& Scope = QueryComponentDataRef();

    //
    // Initialize the result item.
    //


    // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
    // the definition RESULTDATAITEM ResultItem = {0} and removing the ZeroMemory call.
    ::ZeroMemory( &ResultItem, sizeof( ResultItem ) );
    ResultItem.nCol = 0;
    ResultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    ResultItem.str = MMC_CALLBACK;
    ResultItem.nImage = iIconAttribute;
    //
    // Rather than having a clean class interface to the cache, we
    // walk the cache data structures ourselves.  This isn't super
    // clean, but it's simple.
    //
    // Since we do this, we have to make sure that the cache is loaded.
    //

    Scope.g_SchemaCache.LoadCache();

    pObject = Scope.g_SchemaCache.pSortedAttribs;

    //
    // If there's no sorted list, we can't insert anything!!!!
    //

    if ( !pObject ) {
        ASSERT( FALSE );
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        return S_OK;
    }

    //
    // Delete whatever was in the view before
    // and do the insert.
    //

    pHead = pObject;

    do {

       if ( Scope.m_fViewDefunct || !pObject->isDefunct ) 
       {
         //
         // Insert this result.
         //

         pNewCookie= new Cookie( SCHMMGMT_ATTRIBUTE,
                                          lpcszMachineName );

         if ( pNewCookie ) {

            pNewCookie->pParentCookie = pParentCookie;
            pNewCookie->strSchemaObject = pObject->commonName;

            pParentCookie->m_listScopeCookieBlocks.AddHead(
                  (CBaseCookieBlock*)pNewCookie
            );

            ResultItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
            hr = m_pResultData->InsertItem( &ResultItem );

            if ( SUCCEEDED(hr) ) {

                  pNewCookie->SetResultHandle( ResultItem.itemID );

            } else {

                  delete pNewCookie;
            }

         }
       }

       pObject = pObject->pSortedListFlink;

    } while ( pObject != pHead );

    return S_OK;
}

HRESULT
Component::FastInsertClassAttributesResults(
    Cookie* pClassCookie
)
/***

    This routine displays all the attributes for a class.

***/
{
    HRESULT hr = S_OK;
    SchemaObject *pObject, *pTop;
    CString top = L"top";
    ComponentData& Scope = QueryComponentDataRef();

    //
    // Call the attribute display routine.  This routine
    // will call itself recursively to display the
    // inheritance structure of the class.
    //

    pObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                  pClassCookie->strSchemaObject,
                  SCHMMGMT_CLASS );

    if ( pObject ) {

        CStringList szProcessedList;
        hr = RecursiveDisplayClassAttributesResults(
                 pClassCookie,
                 pObject,
                 szProcessedList);

        Scope.g_SchemaCache.ReleaseRef( pObject );
    }

    //
    // Process "top" just once.
    //

    pTop = Scope.g_SchemaCache.LookupSchemaObject( top, SCHMMGMT_CLASS );

    if ( pTop ) {

        ProcessResultList( pClassCookie, pTop->systemMayContain, TRUE, TRUE, pTop );
        ProcessResultList( pClassCookie, pTop->mayContain, TRUE, FALSE, pTop );
        ProcessResultList( pClassCookie, pTop->systemMustContain, FALSE, TRUE, pTop );
        ProcessResultList( pClassCookie, pTop->mustContain, FALSE, FALSE, pTop );

        Scope.g_SchemaCache.ReleaseRef( pTop );
    }

    return hr;

}

HRESULT
Component::RecursiveDisplayClassAttributesResults(
    Cookie *pParentCookie,
    SchemaObject* pObject,
    CStringList& szProcessedList
)
/***

    Display all the attributes for this class.

***/
{

    ListEntry *pList;
    SchemaObject *pInheritFrom;
    ComponentData& Scope = QueryComponentDataRef();

    //
    // Don't process "top" here since everyone inherits from it.
    //

    if ( pObject->ldapDisplayName == L"top" ) {
        return S_OK;
    }

    DebugTrace( L"RecursiveDisplayClassAttributesResults: %ls\n",
                const_cast<LPWSTR>((LPCTSTR)pObject->ldapDisplayName) );

    //
    // Insert all the attributes for this class.
    // The second parameter dictates whether these
    // are optional or not.  The third parameter
    // is the source of the attribute.
    //

    ProcessResultList( pParentCookie, pObject->systemMayContain, TRUE, TRUE, pObject );
    ProcessResultList( pParentCookie, pObject->mayContain, TRUE, FALSE, pObject );
    ProcessResultList( pParentCookie, pObject->systemMustContain, FALSE, TRUE, pObject );
    ProcessResultList( pParentCookie, pObject->mustContain, FALSE, FALSE, pObject );

    //
    // For each auxiliary class, insert those attributes.
    //

    pList = pObject->systemAuxiliaryClass;

    while ( pList ) {

        pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pList->Attribute,
                                                               SCHMMGMT_CLASS ,
                                                               Scope.m_fViewDefunct);
        //
        // Don't recursively process the item if we already processed it
        //
        if ( pInheritFrom && szProcessedList.Find(pList->Attribute) == NULL) {
            RecursiveDisplayClassAttributesResults( pParentCookie, pInheritFrom, szProcessedList );
            szProcessedList.AddTail(pList->Attribute);
            Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
        }

        pList = pList->pNext;
    }

    pList = pObject->auxiliaryClass;

    while ( pList ) {

        pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pList->Attribute,
                                                               SCHMMGMT_CLASS,
                                                               Scope.m_fViewDefunct);
        //
        // Don't recursively process the item if we already processed it
        //
        if ( pInheritFrom && szProcessedList.Find(pList->Attribute) == NULL ) {
            RecursiveDisplayClassAttributesResults( pParentCookie, pInheritFrom, szProcessedList );
            szProcessedList.AddTail(pList->Attribute);
            Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
        }

        pList = pList->pNext;
    }

    //
    // If this is an inherited class, insert those attributes.
    //

    pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pObject->subClassOf,
                                                           SCHMMGMT_CLASS,
                                                           Scope.m_fViewDefunct);
    if ( pInheritFrom ) {
        RecursiveDisplayClassAttributesResults( pParentCookie, pInheritFrom, szProcessedList );
        Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
    }

    return S_OK;

}

HRESULT
Component::ProcessResultList(
    Cookie *pParentCookie,
    ListEntry *pList,
    BOOLEAN fOptional,
    BOOLEAN fSystem,
    SchemaObject* pSrcObject
) 
{

   HRESULT hr;
   Cookie *pNewCookie;
   RESULTDATAITEM ResultItem;
   LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();
   ListEntry *pCurrent = NULL;
   SchemaObject *pAttribute=NULL;

   ComponentData& Scope = QueryComponentDataRef();
   //
   // Initialize the result item.
   //

   // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
   // the definition RESULTDATAITEM ResultItem = {0} and removing the ZeroMemory call.
   ::ZeroMemory( &ResultItem, sizeof( ResultItem ) );
   ResultItem.nCol = 0;
   ResultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
   ResultItem.str = MMC_CALLBACK;
   ResultItem.nImage = iIconAttribute;

   for (pCurrent = pList ; pCurrent != NULL; pCurrent = pCurrent->pNext) 
   {

      //
      // Point to the actual attribute.
      //
      pAttribute = Scope.g_SchemaCache.LookupSchemaObject(
                        pCurrent->Attribute,
                        SCHMMGMT_ATTRIBUTE,
                        Scope.m_fViewDefunct);



      if(pAttribute==NULL)
      {
         ASSERT(pAttribute!=NULL); // All attributes should be in the cache
         continue;
      }


      //
      // Make a new cookie.
      //

      pNewCookie = new Cookie( SCHMMGMT_ATTRIBUTE,
                                          lpcszMachineName );

      if ( pNewCookie ) 
      {
         //
         // Record the optional status and the source.
         //

         if ( fOptional ) {
            pNewCookie->Mandatory = FALSE;
         } else {
            pNewCookie->Mandatory = TRUE;
         }

         if ( fSystem ) {
            pNewCookie->System = TRUE;
         } else {
            pNewCookie->System = FALSE;
         }

         pNewCookie->strSrcSchemaObject = pSrcObject->commonName;
         pNewCookie->pParentCookie = pParentCookie;

         pNewCookie->strSchemaObject = pAttribute->commonName;
         Scope.g_SchemaCache.ReleaseRef( pAttribute );

         //
         // Insert the result pane item.
         //

         pParentCookie->m_listScopeCookieBlocks.AddHead(
            (CBaseCookieBlock*)pNewCookie
         );

         ResultItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
         hr = m_pResultData->InsertItem( &ResultItem );

         if ( SUCCEEDED(hr) ) 
         {
            pNewCookie->SetResultHandle( ResultItem.itemID );
         }
         else 
         {
            delete pNewCookie;
         }
      }
   }

   return S_OK;
}


STDMETHODIMP
Component::AddMenuItems(
    LPDATAOBJECT,
    LPCONTEXTMENUCALLBACK piCallback,
    long* pInsertionsAllowed
) 
{
   HRESULT hr = S_OK;
   if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_VIEW)
   {
      ComponentData& Scope = QueryComponentDataRef();
      hr=_InsertMenuHelper
      (
         piCallback,
         CCM_INSERTIONPOINTID_PRIMARY_VIEW,
         VIEW_DEFUNCT_OBJECTS,
         TRUE,
         Scope.m_fViewDefunct
      );
      ASSERT(SUCCEEDED(hr));
   }
   return hr;
}

STDMETHODIMP
Component::Command(
    long lCommandID,
    LPDATAOBJECT obj
) 
{
   switch ( lCommandID )
   {
      case VIEW_DEFUNCT_OBJECTS:
         ComponentData& Scope = QueryComponentDataRef();
         Scope.m_fViewDefunct=!Scope.m_fViewDefunct;
         OnNotifyRefresh(obj);
         CCookie* pBaseParentCookie = NULL;
         HRESULT hr = ExtractData( obj,
                     CSchmMgmtDataObject::m_CFRawCookie,
                     reinterpret_cast<PBYTE>(&pBaseParentCookie),
                     sizeof(pBaseParentCookie) );
         if( SUCCEEDED(hr) && pBaseParentCookie )
         {
            this->m_pConsole->SelectScopeItem(pBaseParentCookie->m_hScopeItem);
         }

         // The only real info we save is the menu state
         // so let's flag that a save might be required
         m_bDirty=true;

      break;
   }
   return S_OK;

}

  
HRESULT Component::OnNotifyRefresh(LPDATAOBJECT obj)
{
   ComponentData& Scope = QueryComponentDataRef();
   
   Scope.RefreshScopeView();
   m_pConsole->UpdateAllViews(
      obj,
      SCHMMGMT_SCHMMGMT,
      SCHMMGMT_UPDATEVIEW_REFRESH);
   

   return S_OK;
}

HRESULT Component::OnNotifySnapinHelp (LPDATAOBJECT)
{
//	return ShowHelpTopic( L"sag_adschema.htm" );

   CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spDisplayHelp = m_pConsole;
   if ( !spDisplayHelp )
   {
      ASSERT(FALSE);
      return E_UNEXPECTED;
   }

   CString strHelpTopic = L"ADConcepts.chm::/sag_adschema.htm";
   HRESULT hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) strHelpTopic));
   ASSERT (SUCCEEDED (hr));

   return hr;
}



HRESULT Component::OnNotifyContextHelp (LPDATAOBJECT)
{
//	return ShowHelpTopic( L"schmmgmt_top.htm" );

   CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spDisplayHelp = m_pConsole;
   if ( !spDisplayHelp )
   {
      ASSERT(FALSE);
      return E_UNEXPECTED;
   }

   CString strHelpTopic = L"ADConcepts.chm::/schmmgmt_top.htm";
   HRESULT hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) strHelpTopic));
   ASSERT (SUCCEEDED (hr));

   return hr;
}



STDMETHODIMP
Component::QueryPagesFor(
    LPDATAOBJECT pDataObject )
{

    MFC_TRY;

    if ( NULL == pDataObject ) {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr;

    CCookie* pBaseParentCookie = NULL;

    hr = ExtractData( pDataObject,
                     CSchmMgmtDataObject::m_CFRawCookie,
                     reinterpret_cast<PBYTE>(&pBaseParentCookie),
                     sizeof(pBaseParentCookie) );

    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    if ( ( pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE ) &&
         ( pParentCookie->pParentCookie ) &&
         ( pParentCookie->pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTES ) ) {
        return S_OK;
    }

    return S_FALSE;

    MFC_CATCH;
}

//
// This adds pages to the property sheet if appropriate.
// The handle parameter must be saved in the property page
// object to notify the parent when modified.
//

STDMETHODIMP
Component::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR,
    LPDATAOBJECT pDataObject )
{

    MFC_TRY;
    CWaitCursor wait;

    //
    // Validate the parameters.
    //

    if ( ( NULL == pCallBack ) ||
        ( NULL == pDataObject ) ) {

        ASSERT(FALSE);
        return E_POINTER;
    }

    //
    // Make sure this is a class object that we are calling up.
    //

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( pDataObject,
                             CSchmMgmtDataObject::m_CFRawCookie,
                             reinterpret_cast<PBYTE>(&pBaseParentCookie),
                             sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );
    ASSERT( pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE );

    //
    // Create the page.
    //

    HPROPSHEETPAGE hPage;
    AttributeGeneralPage *pGeneralPage =
        new AttributeGeneralPage( this, pDataObject );

    if ( pGeneralPage )
    {
        pGeneralPage->Load( *pParentCookie );
                MMCPropPageCallback( &pGeneralPage->m_psp );
        hPage= MyCreatePropertySheetPage( &pGeneralPage->m_psp );
        hr = pCallBack->AddPage( hPage );
    }

    return S_OK;

    MFC_CATCH;
}



HRESULT __stdcall
Component::Compare(
   LPARAM,
   MMC_COOKIE cookieA,  
   MMC_COOKIE cookieB,  
   int*       result)
{
   if (!result)
   {
      return E_INVALIDARG;
   }

   if (!m_pViewedCookie)
   {
      ASSERT(false);
      *result = 0;
      return S_OK;
   }

   Cookie* c1 =
      (Cookie*) ActiveBaseCookie(reinterpret_cast<CCookie*>(cookieA));

   Cookie* c2 =
      (Cookie*) ActiveBaseCookie(reinterpret_cast<CCookie*>(cookieB));

   PWSTR t1 = QueryBaseComponentDataRef().QueryResultColumnText(*c1, *result);
   PWSTR t2 = QueryBaseComponentDataRef().QueryResultColumnText(*c2, *result);

   // All columns use a case-insensitive comparison, as many columns contain
   // display names from the directory (which are case-insensitive).  That we
   // also use a case insensitive compare for the other columns is harmless.

   // another trick:  we are inverting the results from the compare.  This is
   // because we initially insert the items in the list in sorted order.  So
   // the first sort request from the user really is intended to reverse-sort
   // the list.

   *result = -(_wcsicmp(t1, t2));

   return S_OK;
}


STDMETHODIMP Component::GetResultViewType(MMC_COOKIE cookie,
										   BSTR* ppViewType,
										   long* pViewOptions)
{
	MFC_TRY;
    if( QueryComponentDataRef().IsErrorSet() )
    {
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

		LPOLESTR psz = NULL;
		StringFromCLSID(CLSID_MessageView, &psz);

		USES_CONVERSION;

		if (psz != NULL)
		{
			*ppViewType = psz;
			return S_OK;
		}
		else
        {
			return S_FALSE;
        }
    }
    else
    {
		return CComponent::GetResultViewType( cookie, ppViewType, pViewOptions );
    }

	MFC_CATCH;
}


HRESULT SaveDWordHelper(IStream* pStm, DWORD dw)
{
	ULONG nBytesWritten;
	HRESULT hr = pStm->Write((void*)&dw, sizeof(DWORD),&nBytesWritten);
	if (nBytesWritten < sizeof(DWORD))
		hr = STG_E_CANTSAVE;
	return hr;
}

HRESULT LoadDWordHelper(IStream* pStm, DWORD* pdw)
{
	ULONG nBytesRead;
	HRESULT hr = pStm->Read((void*)pdw,sizeof(DWORD), &nBytesRead);
	ASSERT(nBytesRead == sizeof(DWORD));
	return hr;
}
///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members


STDMETHODIMP Component::GetClassID(CLSID *pClassID)
{
   ASSERT(pClassID != NULL);

   // Copy the CLSID for this snapin
   *pClassID=CLSID_SchmMgmt;
    return S_OK;
}



STDMETHODIMP Component::IsDirty()
{
  return m_bDirty ? S_OK : S_FALSE;
}


// IMPORTANT NOTICE: this value has to be bumped up EVERY time
// a change is made to the stream format
#define DS_STREAM_VERSION ((DWORD)0x01)

STDMETHODIMP Component::Load(IStream *pStm)
{
  ASSERT(pStm);

  // read the version ##
  DWORD dwVersion;
  HRESULT hr = LoadDWordHelper(pStm, &dwVersion);
  if ( FAILED(hr) ||(dwVersion != DS_STREAM_VERSION) ) return E_FAIL;

  // read m_fViewDefunct
  DWORD auxView;
  hr = LoadDWordHelper(pStm, &auxView);
  if (FAILED(hr)) return hr;

  ComponentData& Scope = QueryComponentDataRef();
  Scope.m_fViewDefunct = (bool)auxView;

  
  return hr;

}

STDMETHODIMP Component::Save(IStream *pStm, BOOL fClearDirty)
{
  ASSERT(pStm);

  // write the version ##
  HRESULT hr = SaveDWordHelper(pStm, DS_STREAM_VERSION);
  if (FAILED(hr)) return hr;

  ComponentData& Scope = QueryComponentDataRef();
  hr = SaveDWordHelper(pStm, Scope.m_fViewDefunct);
  if (FAILED(hr)) return hr;


  if(fClearDirty) m_bDirty=false;

  return hr;
}

STDMETHODIMP Component::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
  ASSERT(pcbSize);
  ASSERT(FALSE);

  //
  // Arbitrary values but I don't think we ever get called
  //
  pcbSize->LowPart = 0xffff; 
  pcbSize->HighPart= 0x0;
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cmponent.h ===
//
// cmponent.h : Declaration of Component.
//
// This COM object is primarily concerned with
// the result pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "stdcmpnt.h" // CComponent
#include "cookie.h"   // Cookie


class ComponentData;
class AttributeGeneralPage;

class Component
   :
   public CComponent,
   public IExtendPropertySheet,
   public IExtendContextMenu,
   public IResultDataCompare,
   public IPersistStream
{

public:

    friend class AttributeGeneralPage;

    Component();
    virtual ~Component();

    BEGIN_COM_MAP(Component)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IResultDataCompare)
        COM_INTERFACE_ENTRY(IPersistStream)
        COM_INTERFACE_ENTRY_CHAIN(CComponent)
    END_COM_MAP()

#if DBG==1

    ULONG InternalAddRef( ) {
        return CComObjectRoot::InternalAddRef();
    }

    ULONG InternalRelease( ) {
        return CComObjectRoot::InternalRelease();
    }

    int dbg_InstID;

#endif

    inline
    Cookie* ActiveCookie( CCookie* pBaseCookie ) {
        return ( Cookie*)ActiveBaseCookie( pBaseCookie );
    }

    //
    // Support methods for IComponent.
    //

	// For Error handling, overide GetResultViewType()
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);

    virtual HRESULT ReleaseAll();
    virtual HRESULT OnViewChange( LPDATAOBJECT lpDataObject, LPARAM data, LPARAM hint );
    virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
    virtual HRESULT OnNotifyRefresh(LPDATAOBJECT lpDataObject);
    virtual HRESULT Show( CCookie* pcookie,
                          LPARAM arg,
						  HSCOPEITEM hScopeItem);
    virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject,
                                       LPIMAGELIST lpImageList,
                                       HSCOPEITEM hSelectedItem );
    virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject);

    HRESULT PopulateListbox( Cookie* pcookie );
    HRESULT EnumerateScopeChildren( Cookie* pParentCookie,
                                    HSCOPEITEM hParent );


    HRESULT LoadColumns( Cookie* pcookie );

    ComponentData& QueryComponentDataRef( ) {
        return ( ComponentData& )QueryBaseComponentDataRef();
    }

    //
    // IExtendPropertySheet
    //

    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK pCall,
                                    LONG_PTR handle,
                                    LPDATAOBJECT pDataObject );

    STDMETHOD(QueryPagesFor)( LPDATAOBJECT pDataObject );

    //
    // IExtendContextMenu
    //

    STDMETHOD(AddMenuItems)( LPDATAOBJECT piDataObject,
                             LPCONTEXTMENUCALLBACK piCallback,
                             long *pInsertionAllowed );

    STDMETHOD(Command)( long lCommandID,
                        LPDATAOBJECT piDataObject );

   //
   // IResultDataCompare
   //

   virtual
   HRESULT __stdcall
   Compare(
      LPARAM     userParam,
      MMC_COOKIE cookieA,  
      MMC_COOKIE cookieB,  
      int*       result);

    //
    // Creates result items for the Attributes folder.
    //

    HRESULT
    FastInsertAttributeResultCookies(
        Cookie* pParentCookie
    );

    //
    // Creates result items for a particular class.
    //

    HRESULT
    Component::FastInsertClassAttributesResults(
        Cookie* pClassCookie
    );

    HRESULT
    Component::RecursiveDisplayClassAttributesResults(
        Cookie *pParentCookie,
        SchemaObject* pObject,
        CStringList& szProcessedList
    );

    HRESULT
    Component::ProcessResultList(
        Cookie *pParentCookie,
        ListEntry *pList,
        BOOLEAN fOptional,
        BOOLEAN fSystem,
        SchemaObject* pSrcObject
    );

	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
   virtual HRESULT OnNotifyContextHelp (LPDATAOBJECT pDataObject);

  // IPersistStream interface members
  STDMETHOD(GetClassID)(CLSID *pClassID);
  STDMETHOD(IsDirty)();
  STDMETHOD(Load)(IStream *pStm);
  STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
  STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);


private:

   HRESULT DeleteAttribute(Cookie* pcookie);

    //
    // These should use smart pointers.
    //

    LPCONTROLBAR        m_pControlbar;
    LPTOOLBAR           m_pSvcMgmtToolbar;
    LPTOOLBAR           m_pSchmMgmtToolbar;
    Cookie*    m_pViewedCookie;
    static const GUID   m_ObjectTypeGUIDs[SCHMMGMT_NUMTYPES];
    static const BSTR   m_ObjectTypeStrings[SCHMMGMT_NUMTYPES];
    bool m_bDirty;

};

//
// Enumeration for the icons used.  The icons are loaded into
// MMC via ComponentData::LoadIcons.
//

enum {
    iIconGeneric = 0,
    iIconFolder,
    iIconClass,
    iIconAttribute,
    iIconDisplaySpecifier,
    iIconLast
};

//
// These enums give us readable names for the column ordinals
// of the columns in various result views.
//

typedef enum _COLNUM_CLASS {
    COLNUM_CLASS_NAME=0,
    COLNUM_CLASS_TYPE,
    COLNUM_CLASS_STATUS,
    COLNUM_CLASS_DESCRIPTION
} COLNUM_CLASS;

typedef enum _COLNUM_ATTRIBUTE {
    COLNUM_ATTRIBUTE_NAME=0,
    COLNUM_ATTRIBUTE_TYPE,
    COLNUM_ATTRIBUTE_STATUS,
    COLNUM_ATTRIBUTE_SYSTEM,
    COLNUM_ATTRIBUTE_DESCRIPTION,
    COLNUM_ATTRIBUTE_PARENT
} COLNUM_ATTRIBUTE;

typedef enum _COLNUM_CLASS_ATTRIBUTE {
    COLNUM_CLASS_ATTRIBUTE_NAME=0,
    COLNUM_CLASS_ATTRIBUTE_TYPE,
    COLNUM_CLASS_ATTRIBUTE_SYSTEM,
    COLNUM_CLASS_ATTRIBUTE_DESCRIPTION,
    COLNUM_CLASS_ATTRIBUTE_PARENT
} COLNUM_CLASS_ATTRIBUTE;

typedef enum _COLNUM_ROOT {
        COLNUM_SCHEMA_NAME = 0
} COLNUM_ROOT;

HRESULT LoadIconsIntoImageList(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\compdata.cpp ===
//
// compdata.cpp : Implementation of ComponentData
//
// This COM object is primarily concerned with
// the scope pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(compdata.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "cookie.h"
#include "snapmgr.h"
#include "schmutil.h"
#include "cache.h"
#include "relation.h"
#include "attrpage.h"
#include "advui.h"
#include "aclpage.h"
#include "select.h"
#include "classgen.hpp"
#include "newclass.hpp"
#include "newattr.hpp"


//
// CComponentData implementation.
//

#include "stdcdata.cpp"

//
// ComponentData
//
ComponentData::ComponentData()
   :
   m_pRootCookie( NULL ),
   m_pPathname( NULL ),
   m_hItem( NULL ),
   m_fViewDefunct( false )
{
    //
    // We must refcount the root cookie, since a dataobject for it
    // might outlive the IComponentData.  JonN 9/2/97
    //
    m_pRootCookie = new Cookie( SCHMMGMT_SCHMMGMT );
    ASSERT(NULL != m_pRootCookie);

    m_pRootCookie->AddRef();

    g_SchemaCache.SetScopeControl( this );
    SetHtmlHelpFileName (L"schmmgmt.chm");

    SetCanChangeOperationsMaster( );
    SetCanCreateClass( );
    SetCanCreateAttribute( );
}



ComponentData::~ComponentData()
{
    SAFE_RELEASE(m_pRootCookie);
    SAFE_RELEASE(m_pPathname);
}



DEFINE_FORWARDS_MACHINE_NAME( ComponentData, m_pRootCookie )



CCookie&
ComponentData::QueryBaseRootCookie()
{
    ASSERT(NULL != m_pRootCookie);
    return (CCookie&)*m_pRootCookie;
}



STDMETHODIMP
ComponentData::Initialize( LPUNKNOWN pUnknown )
{
    HRESULT hr = CComponentData::Initialize( pUnknown );

    if( SUCCEEDED(hr) )
    {
        ASSERT( !m_pPathname );

        // create Pathname Object
        if( FAILED( CoCreateInstance(CLSID_Pathname,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IADsPathname,
                                      (void**)&m_pPathname) ) )
        {
            // in case of an error, ignore and later provide no escaping.
            ASSERT( FALSE );
            SAFE_RELEASE( m_pPathname );
        }
    }

    return hr;
}


STDMETHODIMP
ComponentData::CreateComponent( LPCOMPONENT* ppComponent )
{

    MFC_TRY;

    ASSERT(ppComponent != NULL);

    
    CComObject<Component>* pObject;
    CComObject<Component>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    pObject->SetComponentDataPtr( (ComponentData*)this );

    return pObject->QueryInterface( IID_IComponent,
                                    reinterpret_cast<void**>(ppComponent) );

    MFC_CATCH;
}



HRESULT
ComponentData::LoadIcons(
    LPIMAGELIST pImageList,
    BOOL
)
/***

     This routine loads the icon resources that MMC will use.
     We use the image list member ImageListSetIcon to make these
     resources available to MMC.

 ***/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HICON hIcon;
    HRESULT hr = S_OK;

    if( !IsErrorSet() )
    {
        //
        // Set the generic and the last icon in case they are used.
        //

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_GENERIC));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconGeneric);
        ASSERT(SUCCEEDED(hr));
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconLast);
        ASSERT(SUCCEEDED(hr));

        //
        // Set the closed folder icon.
        //

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_FOLDER_CLOSED));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconFolder);
        ASSERT(SUCCEEDED(hr));

        //
        // Set the class, attribute, and display specifier icon.
        //

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_CLASS));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconClass);
        ASSERT(SUCCEEDED(hr));

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_ATTRIBUTE));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconAttribute);
        ASSERT(SUCCEEDED(hr));
    }

    return S_OK;
}

HRESULT
ComponentData::OnNotifyExpand(
    LPDATAOBJECT lpDataObject,
    BOOL bExpanding,
    HSCOPEITEM hParent
)
/***

    This routine is called in response to IComponentData:Notify with
    the MMCN_EXPAND notification.  The argument bExpanding tells us
    whether the node is expanding or contracting.

***/
{

    ASSERT( NULL != lpDataObject &&
            NULL != hParent &&
            NULL != m_pConsoleNameSpace );

    //
    // Do nothing on a contraction - we will get notifications to
    // destroy the disappearing nodes.
    //

    if ( !bExpanding )
        return S_OK;

    //
    // This code will not work if SchmMgmt becomes an extension
    // since the RawCookie format will not be available.
    //

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    //
    // If this node already has children then this expansion is a
    // re-expansion.  We should complain, but not do anything.
    //

    if ( !((pParentCookie->m_listScopeCookieBlocks).IsEmpty()) ) {
        ASSERT(FALSE);
        return S_OK;
    }

    switch ( pParentCookie->m_objecttype ) {

    case SCHMMGMT_SCHMMGMT:
      // expanding the root, need to bind
      hr = _InitBasePaths();
      if( SUCCEEDED(hr) )
      {
            CheckSchemaPermissions( );      // ignoring errors
      }
      else
      {
            SetError( IDS_ERR_ERROR, IDS_ERR_NO_SCHEMA_PATH );

            SetDelayedRefreshOnShow( hParent );

            return S_OK;
      }

      InitializeRootTree( hParent, pParentCookie );

      break;

    case SCHMMGMT_CLASSES:

        return FastInsertClassScopeCookies(
                   pParentCookie,
                   hParent );

        break;

    //
    // These node types have no scope children.
    //

    case SCHMMGMT_CLASS:
    case SCHMMGMT_ATTRIBUTE:
    case SCHMMGMT_ATTRIBUTES:
        return S_OK;

    //
    // We received an unknown node type.
    //

    default:

        TRACE( "ComponentData::EnumerateScopeChildren bad parent type.\n" );
        ASSERT( FALSE );
        return S_OK;

    }

    return S_OK;
}

HRESULT
ComponentData::OnNotifyRelease(
    LPDATAOBJECT,
    HSCOPEITEM
) {

    //
    // Since we are not a valid extension snap in,
    // we don't need to do anything here.
    //

    return S_OK;
}


HRESULT 
ComponentData::OnNotifyDelete(
    LPDATAOBJECT lpDataObject)
{
    CThemeContextActivator activator;

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    UINT promptID = 0;
    LPARAM updateType = SCHMMGMT_CLASS;

    if (pParentCookie->m_objecttype == SCHMMGMT_CLASS)
    {
        promptID = IDS_DELETE_CLASS_PROMPT;
        updateType = SCHMMGMT_CLASS;
    }
    else if (pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE)
    {
        promptID = IDS_DELETE_ATTR_PROMPT;
        updateType = SCHMMGMT_ATTRIBUTES;
    }
    else
    {
        // We should never get called to delete anything but
        // class and attribute nodes

        ASSERT(FALSE);
        return E_FAIL;
    }

    if( IDYES == AfxMessageBox( promptID, MB_YESNO | MB_ICONWARNING ))
    {

        hr = DeleteClass( pParentCookie );
        if ( SUCCEEDED(hr) )
        {
           // Remove the node from the UI

           m_pConsoleNameSpace->DeleteItem( pParentCookie->m_hScopeItem, TRUE );

           // Remove the node from the list

           bool result = g_ClassCookieList.DeleteCookie(pParentCookie);
           ASSERT(result);
        }
        else
        {
           CString szDeleteError;
           szDeleteError.Format(IDS_ERRMSG_DELETE_FAILED_CLASS, GetErrorMessage(hr, TRUE));
          
           DoErrMsgBox( ::GetActiveWindow(), TRUE, szDeleteError );
        }
    }

    return hr;
}

HRESULT
ComponentData::DeleteClass(
    Cookie* pcookie
)
/***

    This deletes an attribute from the schema

***/
{
   HRESULT hr = S_OK;

   do
   {
      if ( !pcookie )
      {
         hr = E_INVALIDARG;
         break;
      }

      SchemaObject* pObject = g_SchemaCache.LookupSchemaObjectByCN(
                                pcookie->strSchemaObject,
                                SCHMMGMT_CLASS );

      if ( !pObject )
      {
         hr = E_FAIL;
         break;
      }

      CString szAdsPath;
      GetSchemaObjectPath( pObject->commonName, szAdsPath );

      hr = DeleteObject( szAdsPath, pcookie, g_ClassFilter );
   } while (false);

   return hr;
}

//
// This is where we store the string handed back to GetDisplayInfo().
//

// FUTURE-2002/02/13-dantra-Schema Manager:  Consider redefining the signature of QueryResultColumnText 
// to return LPCWSTR instead of BSTR since all callers of this method expect LPWSTR.  e.g., all the calls
// to const_cast<BSTR> are misleading and unnecessary.

CString g_strResultColumnText;

BSTR
ComponentData::QueryResultColumnText(
    CCookie& basecookieref,
    int nCol
) {

#ifndef UNICODE
#error not ANSI-enabled
#endif

    BSTR strDisplayText = NULL;
    Cookie& cookieref = (Cookie&)basecookieref;
    SchemaObject *pSchemaObject = NULL;
    SchemaObject *pSrcSchemaObject = NULL;

    switch ( cookieref.m_objecttype ) {

    //
    // These only have first column textual data.
    //

    case SCHMMGMT_SCHMMGMT:

        if ( COLNUM_SCHEMA_NAME == nCol )
            strDisplayText = const_cast<BSTR>(((LPCTSTR)g_strSchmMgmt));
        break;

    case SCHMMGMT_CLASSES:

        if ( COLNUM_SCHEMA_NAME == nCol )
            strDisplayText = const_cast<BSTR>(((LPCTSTR)g_strClasses));
        break;

    case SCHMMGMT_ATTRIBUTES:

        if ( COLNUM_SCHEMA_NAME == nCol )
            strDisplayText = const_cast<BSTR>(((LPCTSTR)g_strAttributes));
        break;

    case SCHMMGMT_CLASS:

        //
        // These display names come out of the schema cache objects.
        //

        pSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                            cookieref.strSchemaObject,
                            SCHMMGMT_CLASS );

        //
        // If there is no cache object, we just have to return UNKNOWN.
        //

        if ( !pSchemaObject ) {
            ASSERT(FALSE);
            strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
            break;
        }

        //
        // Otherwise, return the appropriate text for the column.
        //

        if ( COLNUM_CLASS_NAME == nCol ) {

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->ldapDisplayName);

        } else if ( COLNUM_CLASS_TYPE == nCol ) {

            switch ( pSchemaObject->dwClassType ) {

            case 0:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_88Class));
               break;
            case 1:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_StructuralClass));
               break;
            case 2:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_AbstractClass));
               break;
            case 3:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_AuxClass));
               break;
            default:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_Unknown));
               break;
            }

        } else if ( COLNUM_CLASS_STATUS == nCol ) {
            if ( pSchemaObject->isDefunct ) {
               strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Defunct );
            } else {
               strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Active );
            }
        } else if ( COLNUM_CLASS_DESCRIPTION == nCol ) {

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);
        }

        break;

    case SCHMMGMT_ATTRIBUTE:

        pSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                           cookieref.strSchemaObject,
                           SCHMMGMT_ATTRIBUTE );

        //
        // If there is no cache object, we just have to return UNKNOWN.
        //

        if ( !pSchemaObject ) {
            ASSERT(FALSE);
            strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
            break;
        }

        //
        // Otherwise, return the appropriate text for the column.
        //

        if ( (cookieref.pParentCookie)->m_objecttype == SCHMMGMT_ATTRIBUTES )
        {
           if ( COLNUM_ATTRIBUTE_NAME == nCol ) {

               strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->ldapDisplayName);

           } else if ( COLNUM_ATTRIBUTE_TYPE == nCol ) {

               strDisplayText = const_cast<BSTR>(
                                    (LPCTSTR)g_Syntax[pSchemaObject->SyntaxOrdinal].m_strSyntaxName
                                    );

           } else if ( COLNUM_ATTRIBUTE_STATUS == nCol) {
               if ( pSchemaObject->isDefunct ) {
                  strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Defunct );
               } else {
                  strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Active );
               }
           } else if ( COLNUM_ATTRIBUTE_SYSTEM == nCol ) {

              strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);

           } else if ( COLNUM_ATTRIBUTE_DESCRIPTION == nCol ) {

               strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);

           } else if ( COLNUM_ATTRIBUTE_PARENT == nCol ) {

               pSrcSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                                      cookieref.strSrcSchemaObject,
                                      SCHMMGMT_CLASS );

               //
               // If there is no cache object, we just have to return UNKNOWN.
               //

               if ( !pSchemaObject ) {
                   ASSERT(FALSE);
                   strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
                   break;
               }

               //
               // Otherwise, return the appropriate text for the column.
               //

               strDisplayText = const_cast<BSTR>((LPCTSTR)pSrcSchemaObject->ldapDisplayName);
           }
        }
        else
        {
           if ( COLNUM_CLASS_ATTRIBUTE_NAME == nCol ) {

               strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->ldapDisplayName);

           } else if ( COLNUM_CLASS_ATTRIBUTE_TYPE == nCol ) {

                if ( cookieref.Mandatory ) {
                    strDisplayText = const_cast<BSTR>(((LPCTSTR)g_MandatoryAttribute));
                } else {
                    strDisplayText = const_cast<BSTR>(((LPCTSTR)g_OptionalAttribute));
                }

           } else if ( COLNUM_CLASS_ATTRIBUTE_SYSTEM == nCol ) {


               if ( cookieref.System ) {
                   strDisplayText = const_cast<BSTR>(((LPCTSTR)g_Yes));
               } else {
                   strDisplayText = const_cast<BSTR>(((LPCTSTR)g_No));
               }

           } else if ( COLNUM_CLASS_ATTRIBUTE_DESCRIPTION == nCol ) {

               strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);

           } else if ( COLNUM_CLASS_ATTRIBUTE_PARENT == nCol ) {

               pSrcSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                                      cookieref.strSrcSchemaObject,
                                      SCHMMGMT_CLASS );

               //
               // If there is no cache object, we just have to return UNKNOWN.
               //

               if ( !pSchemaObject ) {
                   ASSERT(FALSE);
                   strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
                   break;
               }

               //
               // Otherwise, return the appropriate text for the column.
               //

               strDisplayText = const_cast<BSTR>((LPCTSTR)pSrcSchemaObject->ldapDisplayName);
           }
        }

        break;

    default:

        TRACE( "ComponentData::QueryResultColumnText bad cookie.\n" );
        ASSERT( FALSE );
        break;

    }

    //
    // Release the schema cache references.
    //

    if ( pSchemaObject ) {
        g_SchemaCache.ReleaseRef( pSchemaObject );
    }

    if ( pSrcSchemaObject ) {
        g_SchemaCache.ReleaseRef( pSrcSchemaObject );
    }

    //
    // Return the appropriate display string.
    //

    if ( strDisplayText ) {
        return strDisplayText;
    }

    return L"";

}

//
// Given a cookie, this returns the icon to display for that cookie.
//

int
ComponentData::QueryImage(
    CCookie& basecookieref,
    BOOL )
{

    Cookie& cookieref = (Cookie&)basecookieref;

    switch ( cookieref.m_objecttype ) {

    case SCHMMGMT_SCHMMGMT:
    case SCHMMGMT_CLASSES:
    case SCHMMGMT_ATTRIBUTES:
        return iIconFolder;
        break;

    case SCHMMGMT_CLASS:
        return iIconClass;
        break;

    case SCHMMGMT_ATTRIBUTE:
        return iIconAttribute;
        break;

    default:

        TRACE( "ComponentData::QueryImage bad parent type.\n" );
        ASSERT( FALSE );
        break;
    }

    return iIconGeneric;

}

//
// This routines tells MMC whether or not there are
// property pages and menus for this item.
//



STDMETHODIMP
ComponentData::AddMenuItems(
    LPDATAOBJECT piDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long*)
{
   CCookie* pBaseParentCookie = NULL;

   HRESULT hr = ExtractData( piDataObject,
                           CSchmMgmtDataObject::m_CFRawCookie,
                           reinterpret_cast<PBYTE>(&pBaseParentCookie),
                           sizeof(pBaseParentCookie) );
   ASSERT( SUCCEEDED(hr) );

   Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
   ASSERT( NULL != pParentCookie );

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   LoadGlobalCookieStrings();
   
   switch (pParentCookie->m_objecttype)
   {
      case SCHMMGMT_SCHMMGMT: // Root Folder
      {
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_RETARGET)));
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_EDIT_FSMO,
                  !IsErrorSet() && IsSchemaLoaded())));
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_SECURITY,
                  !IsErrorSet() && IsSchemaLoaded())));
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_REFRESH,
                  !IsErrorSet() && IsSchemaLoaded())));
         break;
      }
      case SCHMMGMT_CLASSES: // classes folder
      {
         // 285448, 293449

         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  NEW_CLASS,
                  !IsErrorSet() && CanCreateClass())));

         if( !IsErrorSet() && CanCreateClass() )     // add only if enabsed
             VERIFY(
                SUCCEEDED(
                   _InsertMenuHelper(
                      piCallback,
                      CCM_INSERTIONPOINTID_PRIMARY_NEW,
                      CLASSES_CREATE_CLASS)));
         break;
      }
      case SCHMMGMT_ATTRIBUTES: // attributes folder
      {
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  NEW_ATTRIBUTE,
                  !IsErrorSet() && CanCreateAttribute())));

         if( !IsErrorSet() && CanCreateAttribute() )     // add only if enabsed
             VERIFY(
                SUCCEEDED(
                   _InsertMenuHelper(
                      piCallback,
                      CCM_INSERTIONPOINTID_PRIMARY_NEW,
                      ATTRIBUTES_CREATE_ATTRIBUTE)));
         break;
      }
      default:
      {
         // could be class or attribute item
      }

   } // switch

   return S_OK;
}



STDMETHODIMP
ComponentData::Command(long lCommandID, LPDATAOBJECT piDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

   switch ( lCommandID )
   {
      case NEW_ATTRIBUTE:
      case ATTRIBUTES_CREATE_ATTRIBUTE:
      {
         CDialog warn(IDD_CREATE_WARN);
         if (IDOK == warn.DoModal())
         {
            CreateAttributeDialog(this, piDataObject).DoModal();
         }
         break;
      }
      case NEW_CLASS:
      case CLASSES_CREATE_CLASS:
      {
         CDialog warn(IDD_CREATE_WARN);
         if (IDOK == warn.DoModal())
         {
            DoNewClassDialog(*this);
         }
         break;
      }

      case SCHEMA_RETARGET:
        _OnRetarget(piDataObject);
        break;

      case SCHEMA_EDIT_FSMO:
        _OnEditFSMO();
        break;

      case SCHEMA_REFRESH:
          HRESULT hr;
          hr=_OnRefresh(piDataObject);
          if(FAILED(hr))
          {
              if( E_FAIL == hr )
                  DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
              else
                  DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
          }
        break;

      case SCHEMA_SECURITY:
        _OnSecurity();
        break;

      default:

        break;
   }

   return S_OK;
}



STDMETHODIMP
ComponentData::QueryPagesFor(
    LPDATAOBJECT pDataObject )
{

    MFC_TRY;

    if ( NULL == pDataObject ) {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr;

    CCookie* pBaseParentCookie = NULL;

    hr = ExtractData( pDataObject,
                      CSchmMgmtDataObject::m_CFRawCookie,
                      reinterpret_cast<PBYTE>(&pBaseParentCookie),
                      sizeof(pBaseParentCookie) );

    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    if ( pParentCookie->m_objecttype == SCHMMGMT_CLASS ) {
        return S_OK;
    }

    return S_FALSE;

    MFC_CATCH;
}

//
// This adds pages to the property sheet if appropriate.
// The handle parameter must be saved in the property page
// object to notify the parent when modified.
//

STDMETHODIMP
ComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR,
    LPDATAOBJECT pDataObject )
{
    MFC_TRY;

    CWaitCursor wait;

    //
    // Validate the parameters.
    //

    if ( ( NULL == pCallBack ) ||
         ( NULL == pDataObject ) ) {

        ASSERT(FALSE);
        return E_POINTER;
    }

    //
    // Make sure this is a class object that we are calling up.
    //

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( pDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );
    hr = S_OK;

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );
    ASSERT( pParentCookie->m_objecttype == SCHMMGMT_CLASS );

    //
    // Create the page.
    //

    HPROPSHEETPAGE hPage;

    ClassGeneralPage *pGeneralPage = new ClassGeneralPage( this );
    ClassRelationshipPage *pRelationshipPage =
        new ClassRelationshipPage( this, pDataObject );
    ClassAttributePage *pAttributesPage =
        new ClassAttributePage( this, pDataObject );

    if ( pGeneralPage ) {

        pGeneralPage->Load( *pParentCookie );
        MMCPropPageCallback( &pGeneralPage->m_psp );
        hPage = MyCreatePropertySheetPage( &pGeneralPage->m_psp );
        pCallBack->AddPage(hPage);
    }

    if ( pRelationshipPage ) {

       pRelationshipPage->Load( *pParentCookie );
       MMCPropPageCallback( &pRelationshipPage->m_psp );
       hPage = MyCreatePropertySheetPage( &pRelationshipPage->m_psp );
       pCallBack->AddPage(hPage);
    }

    if ( pAttributesPage ) {

       pAttributesPage->Load( *pParentCookie );
       MMCPropPageCallback( &pAttributesPage->m_psp );
       hPage = MyCreatePropertySheetPage( &pAttributesPage->m_psp );
       pCallBack->AddPage(hPage);
    }

    //
    // Add the ACL editor page.
    //

    SchemaObject    * pObject   = NULL;
    CAclEditorPage  * pAclPage  = NULL;
    CString szAdsPath;

    pObject = g_SchemaCache.LookupSchemaObjectByCN(
                 pParentCookie->strSchemaObject,
                 SCHMMGMT_CLASS );

    if ( pObject ) {

       GetSchemaObjectPath( pObject->commonName, szAdsPath );

       if ( !szAdsPath.IsEmpty() ) {

           hr = CAclEditorPage::CreateInstance( &pAclPage, szAdsPath,
                                                pParentCookie->strSchemaObject );

           if ( SUCCEEDED(hr) )
           {
               ASSERT( pAclPage );
               pCallBack->AddPage( pAclPage->CreatePage() );
           }
           else
           {
               DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr) );
               hr = S_FALSE;    // tell mmc to cancel "show prop pages"
           }
       }
    }

    return hr;

    MFC_CATCH;
}

HRESULT
ComponentData::FastInsertClassScopeCookies(
    Cookie* pParentCookie,
    HSCOPEITEM hParentScopeItem
)
/***

    On an expand for the "Classes" node, this inserts the
    class scope items from the cache.

    pParentCookie is the cookie for the parent object.
    hParentScopeItem is the HSCOPEITEM for the parent.

****/
{
    HRESULT hr;
    SCOPEDATAITEM ScopeItem;
    Cookie* pNewCookie;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();
    SchemaObject *pObject, *pHead;

    //
    // Initialize the scope item.
    //

   // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
   // the definition SCOPEDATAITEM ScopeItem = {0} and removing the ZeroMemory call.
   ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
   ScopeItem.mask =
         SDI_STR
      |  SDI_IMAGE
      |  SDI_OPENIMAGE
      |  SDI_STATE
      |  SDI_PARAM
      |  SDI_PARENT
      |  SDI_CHILDREN;
   ScopeItem.displayname = MMC_CALLBACK;
   ScopeItem.relativeID = hParentScopeItem;
   ScopeItem.nState = TVIS_EXPANDED;
   ScopeItem.cChildren = 0;

    //
    // Remember the parent cookie and scope item; we
    // may need to insert later as a refresh.
    //

    g_ClassCookieList.pParentCookie = pParentCookie;
    g_ClassCookieList.hParentScopeItem = hParentScopeItem;

    //
    // Rather than having a clean class interface to the cache, we
    // walk the cache data structures ourselves.  This isn't super
    // clean, but it's simple.
    //
    // Since we do this, we have to make sure that the cache is loaded.
    //
    // This is just like in
    // Component::FastInsertAttributeResultCookies
    //

    g_SchemaCache.LoadCache();

    pObject = g_SchemaCache.pSortedClasses;

    //
    // If there's no sorted list, we can't insert anything!!!!
    // We must return an error or else the console will never
    // ask us again for scope items.
    //

    if ( !pObject ) {
        ASSERT( FALSE );

         // @@ spb: bad message, this could occur if the schema
         // queries were empty...
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        return E_FAIL;
    }

    //
    // Do the insert.
    //

    pHead = pObject;

    do {
       //
       // Insert this result.
       //
       if ( m_fViewDefunct || !pObject->isDefunct )
       {
         pNewCookie= new Cookie( SCHMMGMT_CLASS,
                                          lpcszMachineName );

         if ( pNewCookie ) {

            pNewCookie->pParentCookie = pParentCookie;
            pNewCookie->strSchemaObject = pObject->commonName;

            pParentCookie->m_listScopeCookieBlocks.AddHead(
                  (CBaseCookieBlock*)pNewCookie
            );

            ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
            ScopeItem.nImage = QueryImage( *pNewCookie, FALSE );
                     ScopeItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
            hr = m_pConsoleNameSpace->InsertItem(&ScopeItem);

            if ( SUCCEEDED(hr) ) {

                  pNewCookie->m_hScopeItem = ScopeItem.ID;
                  g_ClassCookieList.AddCookie( pNewCookie, ScopeItem.ID );

            } else {

                  delete pNewCookie;
            }

         }
       }

       pObject = pObject->pSortedListFlink;

    } while ( pObject != pHead );

    return S_OK;
}

//
// Refreshing the scope pane view.
//

VOID
ComponentData::RefreshScopeView(
    VOID
)
/***

    When we reload the schema cache and the "Classes"
    folder has been opened, this routine deletes all
    the scope items from view and re-inserts them.
    This makes new classes visible to the user.

***/
{

    HRESULT hr;
    CCookieListEntry *pHead = g_ClassCookieList.pHead;
    CCookieListEntry *pCurrent;

    if ( pHead != NULL ) {

        //
        // Remove all the scope pane items.
        //

        pCurrent = pHead;

        while ( pCurrent->pNext != pHead ) {

            hr = m_pConsoleNameSpace->DeleteItem( pCurrent->pNext->hScopeItem, TRUE );
            ASSERT( SUCCEEDED( hr ));

            //
            // This should cause the cookie to be deleted.
            //

            pCurrent->pNext->pCookie->Release();

            pCurrent = pCurrent->pNext;
        }

        //
        // Remove the head of the list.
        //

        hr = m_pConsoleNameSpace->DeleteItem( pHead->hScopeItem, TRUE );
        ASSERT( SUCCEEDED( hr ));

        pHead->pCookie->Release();

        //
        // Delete the class cookie list.
        //

        g_ClassCookieList.DeleteAll();
    }

    //
    // Re-insert them from the cache if this node has
    // been expanded at some point.  We have to do this
    // because the console doesn't ever seem to ask
    // again.
    //

    if ( g_ClassCookieList.pParentCookie ) {

        FastInsertClassScopeCookies(
            g_ClassCookieList.pParentCookie,
            g_ClassCookieList.hParentScopeItem
        );

    }

    return;
}


void ComponentData::_OnRetarget(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;
    
    MyBasePathsInfo    oldBasePathsInfo;
    MyBasePathsInfo    newBasePathsInfo;
    HRESULT             hr              = S_OK;
    HWND                hWndParent      = NULL;
    BOOL                fWasErrorSet    = IsErrorSet();


    m_pConsole->GetMainWindow(&hWndParent);
    
    CChangeDCDialog dlg(GetBasePathsInfo(), hWndParent);

    do
    {
        if (IDOK != dlg.DoModal())
            break;

        CWaitCursor wait;

        // save the old path just in case
        oldBasePathsInfo.InitFromInfo( GetBasePathsInfo() );

        // attempt to bind
        hr = newBasePathsInfo.InitFromName(dlg.GetNewDCName());
        BREAK_ON_FAILED_HRESULT(hr);

        // switch focus
        GetBasePathsInfo()->InitFromInfo(&newBasePathsInfo);
        
        // invalidate the whole tree
        hr = _OnRefresh(lpDataObject);
        BREAK_ON_FAILED_HRESULT(hr);

        SetError( 0, 0 );

        // Reset the ResultViewType
        if( IsErrorSet() != fWasErrorSet )
        {
            ASSERT( SCHMMGMT_SCHMMGMT == QueryRootCookie().m_objecttype );
            
            hr = m_pConsole->SelectScopeItem( QueryRootCookie().m_hScopeItem );
            ASSERT_BREAK_ON_FAILED_HRESULT(hr);
            
            //
            // Add children nodes if needed
            //
            if ( (QueryRootCookie().m_listScopeCookieBlocks).IsEmpty() )
            {
                InitializeRootTree( QueryRootCookie().m_hScopeItem, &QueryRootCookie() );
            }
        }

        // Update the root display name

        if (GetBasePathsInfo()->GetServerName())
        {
            CString strDisplayName;
            strDisplayName.LoadString(IDS_SCOPE_SCHMMGMT);
            strDisplayName += L" [";
            strDisplayName += GetBasePathsInfo()->GetServerName();
            strDisplayName += L"]";

            SCOPEDATAITEM RootItem;
            // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
            // the definition SCOPEDATAITEM RootItem = {0} and removing the ZeroMemory call.
            ::ZeroMemory( &RootItem, sizeof(RootItem));
            RootItem.mask = SDI_STR | SDI_PARAM;
            RootItem.displayname = const_cast<PWSTR>((PCWSTR)strDisplayName);
            RootItem.ID = QueryRootCookie().m_hScopeItem;

            hr = m_pConsoleNameSpace->SetItem(&RootItem);
            ASSERT(SUCCEEDED(hr));
        }


    } while( FALSE );


    if( FAILED(hr) )
    {
        DoErrMsgBox(::GetActiveWindow(), TRUE, IDS_ERR_CANT_RETARGET, hr);

        // restoring...
        GetBasePathsInfo()->InitFromInfo(&oldBasePathsInfo);
    }
}


void ComponentData::_OnEditFSMO()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CThemeContextActivator activator;

  HWND hWndParent;

  // Enable hourglass
  CWaitCursor wait;

  m_pConsole->GetMainWindow(&hWndParent);

  CComPtr<IDisplayHelp> spIDisplayHelp;
  m_pConsole->QueryInterface (IID_IDisplayHelp, (void **)&spIDisplayHelp);
  ASSERT(spIDisplayHelp != NULL);

  CEditFsmoDialog dlg(GetBasePathsInfo(), hWndParent, spIDisplayHelp, CanChangeOperationsMaster() );
  dlg.DoModal();
}

HRESULT ComponentData::_OnRefresh(LPDATAOBJECT lpDataObject)
{
    CWaitCursor wait;
    HRESULT     hr = S_OK;
    
    do
    {
        //
        // Force the ds to update the schema cache.
        //
        
        hr = ForceDsSchemaCacheUpdate();
        
        // S_FALSE here means Schema is read-only, cannot force refresh.  Ignoring...
        if(hr==S_FALSE) hr = S_OK;
        BREAK_ON_FAILED_HRESULT(hr);

        // nothing shuld fail after this point
        g_SchemaCache.FreeAll();
        g_SchemaCache.LoadCache();
        
        RefreshScopeView();
        m_pConsole->UpdateAllViews(
            lpDataObject,
            SCHMMGMT_SCHMMGMT,
            SCHMMGMT_UPDATEVIEW_REFRESH);

    } while( FALSE );

    return hr;
}


void ComponentData::_OnSecurity()
{
   HRESULT  hr          = S_OK;
   HWND     hWndParent  = NULL;
   CString	szSchemaPath;

   do
   {
      // Enable hourglass
      CWaitCursor wait;

      CComPtr<IADs> spSchemaContainer;

      GetBasePathsInfo()->GetSchemaPath(szSchemaPath);

      hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)szSchemaPath,
              IID_IADs,
              (void**) &spSchemaContainer);
      BREAK_ON_FAILED_HRESULT(hr);

      CComBSTR path;
      hr = spSchemaContainer->get_ADsPath(&path);
      BREAK_ON_FAILED_HRESULT(hr);

      CComBSTR classname;
      hr = spSchemaContainer->get_Class(&classname);
      BREAK_ON_FAILED_HRESULT(hr);

      m_pConsole->GetMainWindow(&hWndParent);
      
      
      // Determine if the registry is accessible & schema modifications are allowed
      PWSTR          pszFsmoOwnerServerName = 0;
      MyBasePathsInfo fsmoOwnerInfo;
      
      HRESULT hr2 = FindFsmoOwner(GetBasePathsInfo(), SCHEMA_FSMO, &fsmoOwnerInfo, &pszFsmoOwnerServerName);
      
      // If we have the server name, try to read the registry
      BOOL fMarkReadOnly = ( FAILED(hr2) || pszFsmoOwnerServerName == 0 || pszFsmoOwnerServerName[0] == 0);

      // Ignore hr code.

      hr2 =
         DSEditSecurity(
            hWndParent,
            path,
            classname,
            fMarkReadOnly ? DSSI_READ_ONLY : 0,
            NULL,
            NULL,
            NULL,
            0);
   }
   while (0);

   if (FAILED(hr))
   {
		m_pConsole->GetMainWindow(&hWndParent);

		if( szSchemaPath.IsEmpty() )
			DoErrMsgBox( hWndParent, TRUE, IDS_ERR_NO_SCHEMA_PATH );
		else
			DoErrMsgBox( hWndParent, TRUE, GetErrorMessage(hr,TRUE) );
   }
}


HRESULT ComponentData::_InitBasePaths()
{
  CWaitCursor wait;

  // try to get a bind to a generic DC
  HRESULT hr = GetBasePathsInfo()->InitFromName(NULL);
  if (FAILED(hr))
    return hr; // ADSI failed, cannot get any server

  // from the current server, try to bind to the schema FSMO owner
  MyBasePathsInfo fsmoBasePathsInfo;
  PWSTR pszFsmoOwnerServerName = 0;
  hr = FindFsmoOwner(GetBasePathsInfo(), SCHEMA_FSMO, &fsmoBasePathsInfo,
                            &pszFsmoOwnerServerName);

  delete[] pszFsmoOwnerServerName;
  pszFsmoOwnerServerName = 0;

  if (FAILED(hr))
    return S_OK; // still good keep what we have (even though not the FSMO owner)

  // got it, we switch focus
  return GetBasePathsInfo()->InitFromInfo(&fsmoBasePathsInfo);
}



STDMETHODIMP ComponentData::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
      return E_INVALIDARG;

  CString szHelpFilePath;

  
  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  // NTRAID#NTBUG9-565360-2002/03/05-dantra-not checking the result of GetSystemWindowsDirectory()
  if (nLen == 0)
    return E_FAIL;

  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\ADconcepts.chm";

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }

  return S_OK;
}



const WCHAR CN_EQUALS[]     = L"CN=";


HRESULT ComponentData::GetSchemaObjectPath( const CString & strCN,
                                            CString       & strPath,
                                            ADS_FORMAT_ENUM formatType /* = ADS_FORMAT_X500 */ )
{
    HRESULT hr = E_FAIL;
    
    do
    {
        if( !m_pPathname )
            break;

        CComBSTR    bstr;

        // Escape it
        hr = m_pPathname->GetEscapedElement( 0,
                                             CComBSTR( CString(CN_EQUALS) + strCN ),
                                             &bstr );
        BREAK_ON_FAILED_HRESULT(hr);


        // set the dn without the leaf node.
        hr = m_pPathname->Set(
                CComBSTR(
                    CString( GetBasePathsInfo()->GetProviderAndServerName())
                             + GetBasePathsInfo()->GetSchemaNamingContext() ),
                ADS_SETTYPE_FULL );
        BREAK_ON_FAILED_HRESULT(hr);
        

        // add new leaf element
        hr = m_pPathname->AddLeafElement( bstr );
        BREAK_ON_FAILED_HRESULT(hr);
        
        // the result should be property escaped
        hr = m_pPathname->put_EscapedMode( ADS_ESCAPEDMODE_DEFAULT );
        BREAK_ON_FAILED_HRESULT(hr);

        // the full thing is needed
        hr = m_pPathname->SetDisplayType( ADS_DISPLAY_FULL );
        BREAK_ON_FAILED_HRESULT(hr);

        // get the final result.
        hr = m_pPathname->Retrieve( formatType, &bstr );
        BREAK_ON_FAILED_HRESULT(hr);

        
        strPath = bstr;

    } while( FALSE );

    ASSERT( SUCCEEDED(hr) );

    return hr;
}


HRESULT ComponentData::GetLeafObjectFromDN( const BSTR  bstrDN,
                                            CString   & strCN )
{
    HRESULT hr = E_FAIL;
    
    do
    {
        if( !m_pPathname )
            break;
        
        // set the full DN.
        hr = m_pPathname->Set( bstrDN, ADS_SETTYPE_DN );
        BREAK_ON_FAILED_HRESULT(hr);
        
        // the result should not be escaped
        hr = m_pPathname->put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
        BREAK_ON_FAILED_HRESULT(hr);
        
        // just the value please
        hr = m_pPathname->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_ON_FAILED_HRESULT(hr);

        
        CComBSTR    bstrCN;

        // extract the leaf node
        hr = m_pPathname->Retrieve( ADS_FORMAT_LEAF, &bstrCN );
        BREAK_ON_FAILED_HRESULT(hr);

        strCN = bstrCN;

    } while( FALSE );

    ASSERT( SUCCEEDED(hr) );    // this function should never fail (in theory)

    return hr;
}


//
// Determine what operations are allowed.  Optionally returns IADs * to Schema Container
//   if the path is not present, the returned value is E_FAIL
//
HRESULT ComponentData::CheckSchemaPermissions( IADs ** ppADs /* = NULL */ )
{
    HRESULT         hr      = S_OK;
    CComPtr<IADs>   ipADs;
    CString         szSchemaContainerPath;
    CStringList     strlist;

    ASSERT( !ppADs || !(*ppADs) );   // if present, must point to NULL

    do
    {
        //
        // Disable new attrib/class menu items
        //
        SetCanCreateClass( FALSE );
        SetCanCreateAttribute( FALSE );
        SetCanChangeOperationsMaster( FALSE );

        //
        // Get the schema container path.
        //
        GetBasePathsInfo()->GetSchemaPath( szSchemaContainerPath );
        if( szSchemaContainerPath.IsEmpty() )
        {
            hr = E_FAIL;
            break;
        }

        //
        // Open the schema container.
        //
        hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)szSchemaContainerPath,
                           IID_IADs,
                           (void **)&ipADs );
        BREAK_ON_FAILED_HRESULT(hr);


        // extract the list of allowed attributes
        hr = GetStringListElement( ipADs, &g_allowedAttributesEffective, strlist );
        if( SUCCEEDED(hr) )
        {
            // search for needed attributes
            for( POSITION pos = strlist.GetHeadPosition(); pos != NULL; )
            {
                CString * pstr = &strlist.GetNext( pos );
            
                if( !pstr->CompareNoCase( g_fsmoRoleOwner ) )
                {
                    SetCanChangeOperationsMaster( TRUE );
                    break;
                }
            }
        }

        
        // extract the list of allowed classes
        hr = GetStringListElement( ipADs, &g_allowedChildClassesEffective, strlist );
        if( SUCCEEDED(hr) )
        {
            // search for needed attributes
            for( POSITION pos = strlist.GetHeadPosition(); pos != NULL; )
            {
                CString * pstr = &strlist.GetNext( pos );
            
                if( !pstr->CompareNoCase( g_AttributeFilter ) )
                {
                    SetCanCreateAttribute( TRUE );
                    if( CanCreateClass() )
                        break;
                }
                else if( !pstr->CompareNoCase( g_ClassFilter ) )
                {
                    SetCanCreateClass( TRUE );
                    if( CanCreateAttribute() )
                        break;
                }
            }
        }

    } while( FALSE );
    
    if( ppADs )
    {
        *ppADs = ipADs;
        if( *ppADs )
            (*ppADs)->AddRef();
    }

    return hr;
}


////////////////////////////////////////////////////////////////////
//
//  Error handling
//

// Set's error title & body text.  Call it with 0, 0 to remove
void ComponentData::SetError( UINT idsErrorTitle, UINT idsErrorText )
{
    if( idsErrorTitle )
        m_sErrorTitle.LoadString( idsErrorTitle );
    else
        m_sErrorTitle.Empty();

    if( idsErrorText )
        m_sErrorText.LoadString( idsErrorText );
    else
        m_sErrorText.Empty();
}


VOID ComponentData::InitializeRootTree( HSCOPEITEM hParent, Cookie * pParentCookie )
{
    //
    // This node has the two static nodes
    // for Classes and Attributes.
    //
    
    HRESULT hr               = S_OK;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();

    // Update the name of the root to contain the servername we are bound to

    if (GetBasePathsInfo()->GetServerName())
    {
       CString strDisplayName;
       strDisplayName.LoadString(IDS_SCOPE_SCHMMGMT);
       strDisplayName += L" [";
       strDisplayName += GetBasePathsInfo()->GetServerName();
       strDisplayName += L"]";

       SCOPEDATAITEM RootItem;
       // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
       // the definition SCOPEDATAITEM RootItem = {0} and removing the ZeroMemory call.
       ::ZeroMemory( &RootItem, sizeof(RootItem));
       RootItem.mask = SDI_STR | SDI_PARAM;
       RootItem.displayname = const_cast<PWSTR>((PCWSTR)strDisplayName);
       RootItem.ID = hParent;

       hr = m_pConsoleNameSpace->SetItem(&RootItem);
       ASSERT(SUCCEEDED(hr));
    }

    // Set the HSCOPEITEMID for the root because it may not be set if the user
    // just hit the + sign instead of clicking on the root

    QueryRootCookie().m_hScopeItem = hParent;

    SCOPEDATAITEM ScopeItem;
    // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
    // the definition SCOPEDATAITEM ScopeItem = {0} and removing the ZeroMemory call.
    ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
    ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
    ScopeItem.displayname = MMC_CALLBACK;
    ScopeItem.relativeID = hParent;
    ScopeItem.nState = 0;
    
    LoadGlobalCookieStrings();
    
    //
    // Create new cookies for the static scope items.
    // We're doing something funky with the cookie cast.
    //
    
    Cookie* pNewCookie;
    
    pNewCookie= new Cookie( SCHMMGMT_CLASSES,
        lpcszMachineName );
    pParentCookie->m_listScopeCookieBlocks.AddHead(
        (CBaseCookieBlock*)pNewCookie );
    ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
    ScopeItem.nImage = QueryImage( *pNewCookie, FALSE );
    ScopeItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
    hr = m_pConsoleNameSpace->InsertItem(&ScopeItem);
    ASSERT(SUCCEEDED(hr));
    pNewCookie->m_hScopeItem = ScopeItem.ID;

    pNewCookie = new Cookie( SCHMMGMT_ATTRIBUTES,
        lpcszMachineName );
    pParentCookie->m_listScopeCookieBlocks.AddHead(
        (CBaseCookieBlock*)pNewCookie );
    ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
    ScopeItem.nImage = QueryImage( *pNewCookie, FALSE );
    ScopeItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
    
    // turn of the + on the Attributes node
    ScopeItem.mask |= SDI_CHILDREN;
    ScopeItem.cChildren = 0;
    
    hr = m_pConsoleNameSpace->InsertItem(&ScopeItem);
    ASSERT(SUCCEEDED(hr));
    pNewCookie->m_hScopeItem = ScopeItem.ID;


    //
    // Force Cache load (if not done already)
    //
    g_SchemaCache.LoadCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cpropertypageautodelete.cpp ===
#include "stdafx.h"
#include <CPropertyPageAutoDelete.hpp>

UINT CALLBACK PropSheetPageProc
(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
)
{
    CPropertyPageAutoDelete* pPage = (CPropertyPageAutoDelete*)(ppsp->lParam);

    if( pPage == NULL )
    {
        return 0;
    }

    UINT nResult = (*(pPage->m_pfnOldPropCallback))(hwnd, uMsg, ppsp);

    if (uMsg == PSPCB_RELEASE)
    {
        delete pPage;
    }
    return nResult;
}

CPropertyPageAutoDelete::CPropertyPageAutoDelete    
(   
    UINT nIDTemplate
):CPropertyPage(nIDTemplate)
{
    m_pfnOldPropCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropSheetPageProc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cookie.h ===
//
// cookie.h : Declaration of Cookie and related classes.
// Cory West
//

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

//
// Instance handle of the DLL (initialized during
// Component::Initialize).
//

extern HINSTANCE g_hInstanceSave;

#include "nodetype.h"
#include "cache.h"
#include "stdcooki.h"



class Cookie:

    public CCookie,
    public CStoresMachineName,
    public CBaseCookieBlock

{

public:

    Cookie( SchmMgmtObjectType objecttype,
                     LPCTSTR lpcszMachineName = NULL )
        : CStoresMachineName( lpcszMachineName ),
          m_objecttype( objecttype ),
          hResultId( 0 )
    { ; }

    ~Cookie() { ; }

    //
    // Returns < 0, 0 or > 0.
    //

    virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie,
                                           int* pnResult );

    //
    // CBaseCookieBlock.
    //

    virtual CCookie* QueryBaseCookie(int i);
    virtual int QueryNumCookies();

    SchmMgmtObjectType m_objecttype;
    Cookie *pParentCookie;

    //
    // If this is a result item, here's the handle to it.
    //

    HRESULTITEM hResultId;
    inline void SetResultHandle( HRESULTITEM hri ) {
        hResultId = hri;
    };

    //
    // The name of the schema object that this
    // cookie refers to.  We have to refer to the
    // cache object by name so that if the cache
    // reloads, we won't be left holding a dangling
    // pointer.
    //

    CString strSchemaObject;

    //
    // If this is an attribute of a class
    // (pParentCookie->m_objecttype == SCHMMGMT_CLASS),
    // these variables give us display info.
    //

    VARIANT_BOOL Mandatory;
    BOOL System;

    //
    // If this is an attribute of a class, this is the
    // name of the class that the attribute is a member
    // of.
    //

    CString strSrcSchemaObject;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\compdata.h ===
//
// compdata.h : Declaration of ComponentData
//
// This COM object is primarily concerned with
// the scope pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "stdcdata.h"   // CComponentData
#include "persist.h"    // PersistStream
#include "cookie.h"     // Cookie
#include "resource.h"   // IDS_SCHMMGMT_DESC
#include "cmponent.h"   // LoadIconsIntoImageList
#include "schmutil.h"

// Messages used in UpdateAllViews
enum
{
   SCHMMGMT_UPDATEVIEW_REFRESH = 0,          // This MUST be zero
   SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM
};


///////////////////////////////////////////////////////////////////////////////
// ComponentData

class ComponentData
   :
   public CComponentData,
   public IExtendPropertySheet,
   public IExtendContextMenu,
   public PersistStream,
   public CHasMachineName,
   public CComCoClass< ComponentData, &CLSID_SchmMgmt >
{

public:

    friend class ClassGeneralPage;
    friend class CreateAttributeDialog;
    friend class CSchmMgmtAdvanced;
    friend class CSchmMgmtAttributeMembership;
    friend class CSchmMgmtClassRelationship;
    friend class CCookieList;

    //
    // Use DECLARE_AGGREGATABLE(ComponentData)
    // if you want your object to support aggregation,
    // though I don't know why you'd do this.
    //

    DECLARE_NOT_AGGREGATABLE( ComponentData )

    //
    // What is this?
    //

    DECLARE_REGISTRY( ComponentData,
                      _T("SCHMMGMT.SchemaObject.1"),
                      _T("SCHMMGMT.SchemaObject.1"),
                      IDS_SCHMMGMT_DESC,
                      THREADFLAGS_BOTH )

    ComponentData();
    ~ComponentData();

    BEGIN_COM_MAP( ComponentData )
        COM_INTERFACE_ENTRY( IExtendPropertySheet )
        COM_INTERFACE_ENTRY( IPersistStream )
        COM_INTERFACE_ENTRY( IExtendContextMenu )
        COM_INTERFACE_ENTRY_CHAIN( CComponentData )
    END_COM_MAP()

#if DBG==1

        ULONG InternalAddRef() {
            return CComObjectRoot::InternalAddRef();
        }

        ULONG InternalRelease() {
            return CComObjectRoot::InternalRelease();
        }

        int dbg_InstID;

#endif

    //
    // IComponentData
    //

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    STDMETHOD(CreateComponent)( LPCOMPONENT* ppComponent );

    STDMETHOD(QueryDataObject)( MMC_COOKIE cookie,
                                DATA_OBJECT_TYPES type,
                                LPDATAOBJECT* ppDataObject );

    //
    // IExtendPropertySheet
    //

    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK pCall,
                                    LONG_PTR handle,
                                    LPDATAOBJECT pDataObject );

    STDMETHOD(QueryPagesFor)( LPDATAOBJECT pDataObject );

    //
    // IPersistStream
    //

    HRESULT
    STDMETHODCALLTYPE GetClassID( CLSID __RPC_FAR *pClassID ) {
        *pClassID=CLSID_SchmMgmt;
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Load( IStream __RPC_FAR *pStg );
    HRESULT STDMETHODCALLTYPE Save( IStream __RPC_FAR *pStgSave,
                                    BOOL fSameAsLoad );

    //
    // IExtendContextMenu
    //

    STDMETHOD(AddMenuItems)( LPDATAOBJECT piDataObject,
                             LPCONTEXTMENUCALLBACK piCallback,
                             long *pInsertionAllowed );

    STDMETHOD(Command)( long lCommandID,
                        LPDATAOBJECT piDataObject );

   //
   // ISnapinHelp2
   //

    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

    //
    // Needed for Initialize().
    //

    virtual HRESULT LoadIcons( LPIMAGELIST pImageList,
                               BOOL fLoadLargeIcons );

    //
    // Needed for Notify().
    //

    virtual HRESULT OnNotifyExpand( LPDATAOBJECT lpDataObject,
                                    BOOL bExpanding,
                                    HSCOPEITEM hParent );

    virtual HRESULT OnNotifyRelease(
                        LPDATAOBJECT lpDataObject,
                        HSCOPEITEM hItem );

    virtual HRESULT OnNotifyDelete(
                        LPDATAOBJECT lpDataObject);

    //
    // Needed for GetDisplayInfo(), must be defined by subclass.
    //

    virtual BSTR QueryResultColumnText( CCookie& basecookieref,
                                        int nCol );

    virtual int QueryImage( CCookie& basecookieref,
                            BOOL fOpenImage );

    virtual CCookie& QueryBaseRootCookie( );

    inline
    Cookie* ActiveCookie( CCookie* pBaseCookie ) {
        return ( Cookie*)ActiveBaseCookie( pBaseCookie );
    }

    inline Cookie& QueryRootCookie() { return *m_pRootCookie; }

    //
    // CHasMachineName.  Used by the snapin framework to store, retrieve
    //                   and compare machine names
    //

    DECLARE_FORWARDS_MACHINE_NAME( m_pRootCookie )

    //
    // Ads handling routines for inserting dynamic nodes.
    //

    HRESULT
    FastInsertClassScopeCookies(
        Cookie* pParentCookie,
        HSCOPEITEM hParentScopeItem
    );

    VOID
    RefreshScopeView(
        VOID
    );

    VOID
    InitializeRootTree( HSCOPEITEM hParent, Cookie * pParentCookie );


private:
    // context manu item helpers
    HRESULT _OnRefresh(LPDATAOBJECT lpDataObject);
    void _OnRetarget(LPDATAOBJECT lpDataObject);
    void _OnEditFSMO();
    void _OnSecurity();

    // generic helpers
    HRESULT _InitBasePaths();

public:

    //
    // This is the per snap-in instance data.
    //
    
    //
    // This cookie lists contains the currently
    // visible scope data items.
    //
    
    CCookieList g_ClassCookieList;
    bool m_fViewDefunct;
    
    HRESULT DeleteClass( Cookie* pcookie );

    //
    // Error/Status Handling
    //
private:
    // both should be empty if everything is ok.
    CString		m_sErrorTitle;
    CString		m_sErrorText;
    CString     m_sStatusText;

    HSCOPEITEM  m_hItem;

public:
    // Set's error title & body text.  Call it with NULL, NULL to remove
    void SetError( UINT idsErrorTitle, UINT idsErrorText );

    const CString & GetErrorTitle() const    { return m_sErrorTitle; }
    const CString & GetErrorText() const     { return m_sErrorText; }

    BOOL IsErrorSet( void ) const            { return !GetErrorTitle().IsEmpty() || !GetErrorText().IsEmpty(); }

    void SetDelayedRefreshOnShow( HSCOPEITEM hItem )
                                             { m_hItem = hItem; }

    BOOL IsSetDelayedRefreshOnShow()         { return NULL != m_hItem; }
    HSCOPEITEM GetDelayedRefreshOnShowItem() { ASSERT(IsSetDelayedRefreshOnShow()); return m_hItem; }

    // Set/Clear Status Text
//    void SetStatusText( UINT idsStatusText = 0 );
//    void ClearStatusText( )                  { SetStatusText(); }


    //
    // Access permissions
    //
private:

    BOOL    m_fCanChangeOperationsMaster;
    BOOL    m_fCanCreateClass;
    BOOL    m_fCanCreateAttribute;

public:
    
    BOOL    CanChangeOperationsMaster()     { return m_fCanChangeOperationsMaster; }
    BOOL    CanCreateClass()                { return m_fCanCreateClass; }
    BOOL    CanCreateAttribute()            { return m_fCanCreateAttribute; }
    
    void    SetCanChangeOperationsMaster( BOOL fCanChangeOperationsMaster = FALSE )
                                            { m_fCanChangeOperationsMaster = fCanChangeOperationsMaster; }
    void    SetCanCreateClass( BOOL fCanCreateClass = FALSE )
                                            { m_fCanCreateClass            = fCanCreateClass; }
    void    SetCanCreateAttribute( BOOL fCanCreateAttribute = FALSE )
                                            { m_fCanCreateAttribute        = fCanCreateAttribute; }
    
    //
    // The schema cache.
    //
    
    SchemaObjectCache g_SchemaCache;

    BOOLEAN IsSchemaLoaded() { return g_SchemaCache.IsSchemaLoaded(); }
    
    HRESULT ForceDsSchemaCacheUpdate( VOID );
    BOOLEAN AsynchForceDsSchemaCacheUpdate( VOID );
    
    MyBasePathsInfo* GetBasePathsInfo() { return &m_basePathsInfo;}
    
    
    //
    // Function to add escape char to the special chars in CN
    //
    HRESULT GetSchemaObjectPath( const CString & strCN,
                                 CString       & strPath,
                                 ADS_FORMAT_ENUM formatType = ADS_FORMAT_X500 );

    HRESULT GetLeafObjectFromDN( const BSTR bstrDN, CString & strCN );

    // Determine what operations are allowed.  Optionally returns IADs * to Schema Container
    HRESULT CheckSchemaPermissions( IADs ** ppADs = NULL  );


private:

    MyBasePathsInfo    m_basePathsInfo;
    Cookie*             m_pRootCookie;
    IADsPathname      * m_pPathname;
};



#endif // __COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cookie.cpp ===
//
// Cookie.cpp : Implementation of Cookie and related classes.
// Cory West
//

#include "stdafx.h"
#include "cookie.h"

#include "atlimpl.cpp"

DECLARE_INFOLEVEL(SchmMgmtSnapin)

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(cookie.cpp)")
#include "stdcooki.cpp"
#include ".\uuids.h"

//
// This is used by the nodetype utility routines in
// stdutils.cpp, which matches the enum type node
// types to their guids.  This table must match the
// layout of guids in uuids.h.
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[SCHMMGMT_NUMTYPES] =
{

    //
    // The root node.
    //

    { // SCHMMGMT_SCHMMGMT
      structUuidNodetypeSchmMgmt,
      lstrUuidNodetypeSchmMgmt          },
    
    //
    // Static node types.
    //

    { // SCHMMGMT_CLASSES
      structUuidNodetypeClasses,
      lstrUuidNodetypeClasses           },
    { // SCHMGMT_ATTRIBUTES,
      structUuidNodetypeAttributes,
      lstrUuidNodetypeAttributes        },

    //
    // Dynamic node types.
    //

    { // SCHMMGMT_CLASS
      structUuidNodetypeClass,
      lstrUuidNodetypeClass             },
    { // SCHMMGMT_ATTRIBUTE
      structUuidNodetypeAttribute,
      lstrUuidNodetypeAttribute         },

};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = SCHMMGMT_NUMTYPES;

//
// Cookie
//

HRESULT
Cookie::CompareSimilarCookies(CCookie* pOtherCookie, int* pnResult)
{
   ASSERT(pOtherCookie);
   ASSERT(pnResult);

   Cookie* pcookie = (dynamic_cast<Cookie*>(pOtherCookie));
   ASSERT(pcookie);

   if (pcookie)
   {
      //
      // Arbitrary ordering...
      //

      if ( m_objecttype != pcookie->m_objecttype )
      {
         *pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype);
         return S_OK;
      }

      *pnResult = strSchemaObject.CompareNoCase(pcookie->strSchemaObject);
      return S_OK;
   }

   return E_FAIL;
}



CCookie*
Cookie::QueryBaseCookie(
    int i ) {

    ASSERT( i == 0 );
    return (CCookie*)this;
}

int 
Cookie::QueryNumCookies() {
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\cpropertypageautodelete.hpp ===
#ifndef CPROPERTYSHEETAUTODELETE_INCLUDED
#define CPROPERTYSHEETAUTODELETE_INCLUDED

#include "cookie.h"     // Cookie
#include "resource.h"   // IDD_CLASS_MEMBERSHIP

UINT CALLBACK PropSheetPageProc
(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
);

class CPropertyPageAutoDelete:public CPropertyPage
{
    public:

    CPropertyPageAutoDelete
    (   
        UINT nIDTemplate
    );

    friend UINT CALLBACK PropSheetPageProc
    (
        HWND hwnd,
        UINT uMsg,
        LPPROPSHEETPAGE ppsp
    );

    private:
        LPFNPSPCALLBACK m_pfnOldPropCallback;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\mybasepathsinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

class MyBasePathsInfo : public CDSBasePathsInfo
{
public:
  // Functions from the base class that are wrapped to take references to 
  // CStrings

  void ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext);

  void GetSchemaPath(CString& s);
  void GetConfigPath(CString& s);
  void GetDefaultRootPath(CString& s);
  void GetRootDSEPath(CString& s);
  void GetAbstractSchemaPath(CString& s);
  void GetPartitionsPath(CString& s);
  void GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s);
  void GetInfrastructureObjectPath(CString& s);
};

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\dataobj.h ===
//
// DataObj.h : Declaration of the data object classes
// Cory West
//

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__

#include "cookie.h"     // Cookie
#include "stddtobj.h"   // class DataObject

class CSchmMgmtDataObject : public CDataObject
{

    DECLARE_NOT_AGGREGATABLE(CSchmMgmtDataObject)

public:

#if DBG==1

    ULONG InternalAddRef() {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease() {
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;

#endif

    CSchmMgmtDataObject()
        : m_pcookie( NULL ),
          m_objecttype( SCHMMGMT_SCHMMGMT ),
          m_dataobjecttype( CCT_UNINITIALIZED )
    { ; }

    ~CSchmMgmtDataObject();

    virtual HRESULT Initialize( Cookie* pcookie, DATA_OBJECT_TYPES type );

    HRESULT STDMETHODCALLTYPE GetDataHere(
        FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium
    );

    HRESULT PutDisplayName( STGMEDIUM* pMedium );
    HRESULT PutServiceName( STGMEDIUM* pMedium );

protected:

    //
    // The CCookieBlock is AddRef'ed for the life of the DataObject.
    //

    Cookie* m_pcookie;
    SchmMgmtObjectType m_objecttype;
    DATA_OBJECT_TYPES m_dataobjecttype;

public:

    static CLIPFORMAT m_CFDisplayName;
    static CLIPFORMAT m_CFMachineName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\mybasepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"


void MyBasePathsInfo::ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext)
{
  int result = 0;
  szPath.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::ComposeADsIPath(&pszPath, lpszNamingContext);
  
  if (pszPath && result)
  {
     szPath = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetConfigPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetConfigPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetDefaultRootPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetDefaultRootPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetRootDSEPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetRootDSEPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetAbstractSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetAbstractSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetPartitionsPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetPartitionsPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaObjectPath(lpszObjClass, &pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetInfrastructureObjectPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetInfrastructureObjectPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk)
{
  PWSTR pszServer = 0;
  HRESULT hr = GetADSIServerName(&pszServer, pUnk);
  if (SUCCEEDED(hr) && pszServer)
  {
    szServer = pszServer;

    delete[] pszServer;
    pszServer = 0;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\dataobj.cpp ===
// DataObj.cpp : Implementation of data object classes

#include "stdafx.h"
#include "stdutils.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(dataobj.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "resource.h"

#include "stddtobj.cpp"

//
// IDataObject interface implementation.
//

HRESULT
CSchmMgmtDataObject::GetDataHere(
    FORMATETC __RPC_FAR *pFormatEtcIn,
    STGMEDIUM __RPC_FAR *pMedium
)
{
        MFC_TRY;

        const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
        if (cf == m_CFNodeType)
        {
                const GUID* pguid = GetObjectTypeGUID( m_pcookie->m_objecttype );
                stream_ptr s(pMedium);
                return s.Write(pguid, sizeof(GUID));
        }
        else if (cf == m_CFSnapInCLSID)
        {
                const GUID* pguid = &CLSID_SchmMgmt;
                stream_ptr s(pMedium);
                return s.Write(pguid, sizeof(GUID));
        }
        else if (cf == m_CFNodeTypeString)
        {
                const BSTR strGUID = GetObjectTypeString( m_pcookie->m_objecttype );
                stream_ptr s(pMedium);
                return s.Write(strGUID);
        }
        else if (cf == m_CFDisplayName)
        {
                return PutDisplayName(pMedium);
        }
        else if (cf == m_CFDataObjectType)
        {
                stream_ptr s(pMedium);
                return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
        }
        else if (cf == m_CFMachineName)
        {
                stream_ptr s(pMedium);
                return s.Write(m_pcookie->QueryNonNULLMachineName());
        }
        else if (cf == m_CFRawCookie)
        {
                stream_ptr s(pMedium);
                // CODEWORK This cast ensures that the data format is
                // always a CCookie*, even for derived subclasses
                CCookie* pcookie = (CCookie*)m_pcookie;
                return s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pcookie));
        }

        return DV_E_FORMATETC;

        MFC_CATCH;
}

HRESULT CSchmMgmtDataObject::Initialize( Cookie* pcookie, DATA_OBJECT_TYPES type )
{
        if (NULL == pcookie || NULL != m_pcookie)
        {
                ASSERT(FALSE);
                return E_UNEXPECTED;
        }
        m_dataobjecttype = type;
        m_pcookie = pcookie;
        ((CRefcountedObject*)m_pcookie)->AddRef();
        return S_OK;
}


CSchmMgmtDataObject::~CSchmMgmtDataObject()
{
        if (NULL != m_pcookie)
        {
                ((CRefcountedObject*)m_pcookie)->Release();
        }
        else
        {
                ASSERT(FALSE);
        }
}


HRESULT CSchmMgmtDataObject::PutDisplayName(STGMEDIUM* pMedium)
        // Writes the "friendly name" to the provided storage medium
        // Returns the result of the write operation
{
        CString strDisplayName;
        LPCTSTR pszTarget = m_pcookie->QueryTargetServer();
        if ( NULL != pszTarget )
        {
                if ( pszTarget[0] == _T('\\') && pszTarget[1] == _T('\\') )
                        pszTarget += 2;
                strDisplayName = pszTarget;
        }
        else
        {
                VERIFY( strDisplayName.LoadString(IDS_SCOPE_SCHMMGMT) );
        }
        stream_ptr s(pMedium);
        return s.Write(strDisplayName);
}

// Register the clipboard formats
CLIPFORMAT CSchmMgmtDataObject::m_CFDisplayName =
        (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CSchmMgmtDataObject::m_CFMachineName =
        (CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
        (CLIPFORMAT)RegisterClipboardFormat(L"MYCOMPUT_SNAPIN_RAW_COOKIE");


STDMETHODIMP ComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
   MFC_TRY;

   Cookie* pUseThisCookie =
      (Cookie*) ActiveBaseCookie(reinterpret_cast<CCookie*>(cookie));

   CComObject<CSchmMgmtDataObject>* pDataObject = NULL;
   HRESULT hRes = CComObject<CSchmMgmtDataObject>::CreateInstance(&pDataObject);
   if ( FAILED(hRes) )
          return hRes;

   HRESULT hr = pDataObject->Initialize( pUseThisCookie, type );
   if ( SUCCEEDED(hr) )
   {
      hr = pDataObject->QueryInterface(IID_IDataObject,
                                       reinterpret_cast<void**>(ppDataObject));
   }

   if ( FAILED(hr) )
   {
      delete pDataObject;
      return hr;
   }

   return hr;

   MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(SchmMgmtSnapin)
    #define DBG_COMP    SchmMgmtSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\helpids.h ===
#define IDH_ATTRIB_DEACTIVATE                100001016
#define IDH_ATTRIB_GENERAL_DESCRIPTION_EDIT  100001002
#define IDH_ATTRIB_GENERAL_DISPLAYABLE_CHECK 100001015
#define IDH_ATTRIB_GENERAL_INDEX_CHECK       100001017
#define IDH_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK 100001019
#define IDH_ATTRIB_GENERAL_LDN               100001004
#define IDH_ATTRIB_GENERAL_MAX_EDIT          100001013
#define IDH_ATTRIB_GENERAL_MIN_EDIT          100001011
#define IDH_ATTRIB_GENERAL_OID_EDIT          100001006
#define IDH_ATTRIB_GENERAL_SYNTAX_EDIT       100001009
#define IDH_CATEGORY_CHANGE                  100001311
#define IDH_CATEGORY_EDIT                    100001310
#define IDH_CHANGE_FSMO2                     100001707
#define IDH_CLASS_DEACTIVATE                 100001313
#define IDH_CLASS_GENERAL_CATEGORY_COMBO     100001308
#define IDH_CLASS_GENERAL_DESCRIPTION_EDIT   100001302
#define IDH_CLASS_GENERAL_DISPLAYABLE_CHECK  100001312
#define IDH_CLASS_GENERAL_LDN                100001304
#define IDH_CLASS_GENERAL_OID_EDIT           100001306
#define IDH_CLASS_MMB_MANDATORY_ADD          100001103
#define IDH_CLASS_MMB_MANDATORY_ATTRIBUTES   100001102
#define IDH_CLASS_MMB_MANDATORY_REMOVE       100001104
#define IDH_CLASS_MMB_OPTIONAL_ADD           100001108
#define IDH_CLASS_MMB_OPTIONAL_ATTRIBUTES    100001107
#define IDH_CLASS_MMB_OPTIONAL_REMOVE        100001109
#define IDH_CLASS_REL_AUX_ADD                100001405
#define IDH_CLASS_REL_AUX_CLASSES            100001404
#define IDH_CLASS_REL_AUX_REMOVE             100001406
#define IDH_CLASS_REL_PARENT_EDIT            100001402
#define IDH_CLASS_REL_SUPER_ADD              100001410
#define IDH_CLASS_REL_SUPER_CLASSES          100001409
#define IDH_CLASS_REL_SUPER_REMOVE           100001411
#define IDH_CREATE_ATTRIB_CN                 100001503
#define IDH_CREATE_ATTRIB_LDN                100001505
#define IDH_CREATE_ATTRIB_MAX                100001513
#define IDH_CREATE_ATTRIB_MIN                100001511
#define IDH_CREATE_ATTRIB_OID                100001506
#define IDH_CREATE_ATTRIB_SYNTAX             100001509
#define IDH_CREATE_ATTRIB_VALUED             100001514
#define IDH_CREATE_CLASS_CN                  100001603
#define IDH_CREATE_CLASS_LDN                 100001605
#define IDH_CREATE_CLASS_OID                 100001606
#define IDH_CREATE_CLASS_PARENT              100001609
#define IDH_CREATE_CLASS_TYPE                100001611
#define IDH_EDIT_CURRENT_DC2                 100001201
#define IDH_EDIT_CURRENT_DC3                 100001701
#define IDH_EDIT_CURRENT_FSMO_DC2            100001706
#define IDH_EDIT_DC                          100001205
#define IDH_RADIO_ANY                        100001203
#define IDH_RADIO_SPECIFY                    100001204
#define IDH_REPLICATED                       100001018
#define IDH_SCHEMA_LIST                      100001801
#define IDH_SERVER_MODIFY_CHECK              100001708
#define	IDH_ATTRIB_GENERAL_ANR_CHECK		 100001805
#define	IDH_ATTRIB_GENERAL_CPYATTR_CHECK	 100001810
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\ncattr.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "wizinfo.hpp"
#include "ncattr.hpp"
#include "select.h"



//
// defaultObjectCategory of the classes derived from the following should be set
// to defaultObjectCategory of the parent class.
//
// the first column contains class ldap names,
// the second contains their corresponding OIDs (in case the user specifies them)

const TCHAR * rgszSpecialClassesLdapNames[] =   {
                USER_CLASS_NAME,    
                GROUP_CLASS_NAME,   
                COMPUTER_CLASS_NAME,
                PRINTER_CLASS_NAME, 
                TEXT("volume"),     
                TEXT("contact"),    
                NULL
                                                };

// must match rgszSpecialClassesLdapNames[].
const TCHAR * rgszSpecialClassesOIDs[] =        {
                TEXT("1.2.840.113556.1.5.9"),  // USER_CLASS_NAME
                TEXT("1.2.840.113556.1.5.8"),  // GROUP_CLASS_NAME
                TEXT("1.2.840.113556.1.3.30"), // COMPUTER_CLASS_NAME
                TEXT("1.2.840.113556.1.5.23"), // PRINTER_CLASS_NAME
                TEXT("1.2.840.113556.1.5.36"), // TEXT("volume")
                TEXT("1.2.840.113556.1.5.15"), // TEXT("contact")
                NULL
                                                };


const DWORD NewClassAttributesPage::help_map[] =
{
    IDC_MANDATORY_LIST,     IDH_CLASS_MMB_MANDATORY_ATTRIBUTES,
    IDC_MANDATORY_ADD,      IDH_CLASS_MMB_MANDATORY_ADD,
    IDC_MANDATORY_REMOVE,   IDH_CLASS_MMB_MANDATORY_REMOVE,

    IDC_OPTIONAL_LIST,      IDH_CLASS_MMB_OPTIONAL_ATTRIBUTES,
    IDC_OPTIONAL_ADD,       IDH_CLASS_MMB_OPTIONAL_ADD,
    IDC_OPTIONAL_REMOVE,    IDH_CLASS_MMB_OPTIONAL_REMOVE,

    0,                      0
};


BEGIN_MESSAGE_MAP(NewClassAttributesPage, CPropertyPage)
   ON_BN_CLICKED(IDC_OPTIONAL_ADD,     OnButtonOptionalAdd)
   ON_BN_CLICKED(IDC_OPTIONAL_REMOVE,  OnButtonOptionalRemove)
   ON_BN_CLICKED(IDC_MANDATORY_ADD,    OnButtonMandatoryAdd)
   ON_BN_CLICKED(IDC_MANDATORY_REMOVE, OnButtonMandatoryRemove)
   ON_LBN_SELCHANGE(IDC_MANDATORY_LIST,OnMandatorySelChange)            
   ON_LBN_SELCHANGE(IDC_OPTIONAL_LIST, OnOptionalSelChange)            
   ON_MESSAGE(WM_HELP,                 OnHelp)                      
   ON_MESSAGE(WM_CONTEXTMENU,          OnContextHelp)
END_MESSAGE_MAP()



NewClassAttributesPage::NewClassAttributesPage(
   CreateClassWizardInfo* wi,
   ComponentData*         cd)
   :
   CPropertyPage(IDD_CREATE_CLASS_ATTRIBUTES),
   wiz_info(*wi),
   parent_ComponentData(*cd)
{
}


BOOL
NewClassAttributesPage::OnInitDialog() 
{
    // This calls must be done before DDX binding
    listbox_mandatory.InitType( &parent_ComponentData,
                                SELECT_ATTRIBUTES,
                                IDC_MANDATORY_REMOVE
                              );

    listbox_optional.InitType(  &parent_ComponentData,
                                SELECT_ATTRIBUTES,
                                IDC_OPTIONAL_REMOVE
                              );
 
    CPropertyPage::OnInitDialog();

    return FALSE;   // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}




void
NewClassAttributesPage::OnOK()
{
   CPropertyPage::OnOK();
}



BOOL
NewClassAttributesPage::OnKillActive()
{
   if (saveAndValidate())
   {
      // allow loss of focus
      return TRUE;
   }

   return FALSE;
}



bool
NewClassAttributesPage::saveAndValidate()
{
   // save settings 
   wiz_info.strlistMandatory.RemoveAll();
   HRESULT hr =
      RetrieveEditItemsWithExclusions(
         listbox_mandatory,
         wiz_info.strlistMandatory,
         0);
   ASSERT(SUCCEEDED(hr));

   wiz_info.strlistOptional.RemoveAll();
   hr =
      RetrieveEditItemsWithExclusions(
         listbox_optional,
         wiz_info.strlistOptional,
         0);
   ASSERT(SUCCEEDED(hr));
   
   // nothing to validate...

   return true;
}



BOOL
NewClassAttributesPage::OnSetActive()
{
   OnMandatorySelChange();
   OnOptionalSelChange();

   CPropertySheet* parent = (CPropertySheet*) GetParent();   
   parent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);

   return TRUE;
}



BOOL
NewClassAttributesPage::OnWizardFinish()
{
   if (!saveAndValidate())
   {
      return FALSE;
   }

   // Create the class object.  We do the create here (instead of at the point
   // where DoModal is invoked) because we want the wizard to remain if the
   // create fails for some reason.

   CThemeContextActivator activator;

   CWaitCursor wait;

   HRESULT       hr         = S_OK;
   SchemaObject* new_object = 0;   

   do
   {
      // bind to the schema container

      CString schema_path;
      parent_ComponentData.GetBasePathsInfo()->GetSchemaPath(schema_path);

      CComPtr<IADsContainer> schema_container;
      hr = SchemaOpenObject(
            
            // ADSI guys don't grok const. 
            const_cast<PWSTR>(static_cast<PCWSTR>(schema_path)),
            IID_IADsContainer,
            reinterpret_cast<void**>(&schema_container));
      BREAK_ON_FAILED_HRESULT(hr);

      // Get Relative Name
      CString strRelativeName;
      parent_ComponentData.GetSchemaObjectPath( wiz_info.cn, strRelativeName, ADS_FORMAT_LEAF );
      
      // create the class object
      CComPtr<IDispatch> dispatch;
      hr =
         schema_container->Create(
            CComBSTR(g_ClassFilter),
            CComBSTR(strRelativeName),
            &dispatch);
      BREAK_ON_FAILED_HRESULT(hr);

      CComPtr<IADs> iads;
      hr =
         dispatch->QueryInterface(IID_IADs, reinterpret_cast<void**>(&iads));
      BREAK_ON_FAILED_HRESULT(hr);

      //
      // populate the class object's properties
      //

      // OID
      {
         CComVariant value(CComBSTR(wiz_info.oid));
         hr = iads->Put(CComBSTR(g_GlobalClassID), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // class type
      {
         CComVariant value(wiz_info.type + 1);
         hr = iads->Put(CComBSTR(g_ObjectClassCategory), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // description
      if (!wiz_info.description.IsEmpty())
      {
        CComVariant value(CComBSTR(wiz_info.description));
        hr = iads->Put(CComBSTR(g_Description), value);
        BREAK_ON_FAILED_HRESULT(hr);
      }

      // default security descriptor
      {
         // authenticated users - full access
         // system - full control
         // domain admins - full control
         static const PWSTR defsd =
            L"D:(A;;RPWPCRCCDCLCLOLORCWOWDSDDTDTSW;;;DA)"
            L"(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPLCLORC;;;AU)";
         CComVariant value(defsd);
         hr = iads->Put(CComBSTR(g_DefaultAcl), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // LDAP display name 
      if (!wiz_info.ldapDisplayName.IsEmpty())
      {
         CComVariant value(wiz_info.ldapDisplayName);
         hr = iads->Put(CComBSTR(g_DisplayName), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // parent class
      if (!wiz_info.parentClass.IsEmpty())
      {
         PCWSTR         pstr            = NULL;
         SchemaObject * parent_class    =
            parent_ComponentData.g_SchemaCache.LookupSchemaObject(
               wiz_info.parentClass,
               SCHMMGMT_CLASS);


         if( parent_class )
         {
            pstr = parent_class->oid;
         }
         else
         {
            pstr = wiz_info.parentClass;
         }
         
         CComVariant value(pstr);
         hr = iads->Put(CComBSTR(g_SubclassOf), value);
         if( FAILED(hr) )
         {
            parent_ComponentData.g_SchemaCache.ReleaseRef(parent_class);
            break;
         }

         
         // check if parent is one of the magic classes whose defaultObjectCategory
         // should be the same as the parent.
         BOOL fIsSpecialParent = FALSE;
         ASSERT( sizeof(rgszSpecialClassesOIDs) == sizeof(rgszSpecialClassesLdapNames) );

         if( parent_class )
         {
            fIsSpecialParent = IsInList( rgszSpecialClassesLdapNames,
                                         parent_class->ldapDisplayName );
         }
         else
         {
            UINT uIndex = 0;

             // lookup by LDAP failed.  check if parent is specified by OID
            fIsSpecialParent = IsInList( rgszSpecialClassesOIDs,
                                         wiz_info.parentClass,
                                         &uIndex );
            if( fIsSpecialParent )
            {
                parent_class = parent_ComponentData.g_SchemaCache.LookupSchemaObject(
                                         rgszSpecialClassesLdapNames[uIndex],
                                         SCHMMGMT_CLASS);
                ASSERT( parent_class ); // the schema cache must contain well known classes.
            }
         }

         // if this is a special class, get parent's defaultObjectCategory.
         if( fIsSpecialParent && parent_class )
         {
             CString szParentPath;
             IADs *  pIADsParentObject   = NULL;
             VARIANT adsValue;
             
             VariantInit( &adsValue );

             do {    // one pass do-while loop to help with error handling
                     // if any errors occure, ignore them.

                 // Find out the defaultObjectCategory of the parent class & use it
                 parent_ComponentData.GetSchemaObjectPath( parent_class->commonName, szParentPath );

                 if( szParentPath.IsEmpty() )
                     break;

                 hr = SchemaOpenObject( const_cast<LPWSTR>((LPCWSTR)szParentPath),
                                            IID_IADs,
                                            (void **)&pIADsParentObject );
                 if ( !pIADsParentObject || FAILED(hr) )
                 {
                     DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr) );
                     hr = NULL;
                     break;
                 }

                 // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
                 hr = pIADsParentObject->Get( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                       &adsValue );

                 if( FAILED(hr) )
                 {
                     DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
                     hr = NULL;
                     break;
                 }

                 ASSERT( adsValue.vt == VT_BSTR );

                 // preserve hr so that save fails after this loop
                 // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
                 hr = iads->Put( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                        adsValue );

             } while (FALSE);

             VariantClear( &adsValue );
 
             parent_ComponentData.g_SchemaCache.ReleaseRef(parent_class);

             if( pIADsParentObject )
                 pIADsParentObject->Release();

             BREAK_ON_FAILED_HRESULT(hr);
         }
         else
         {
             parent_ComponentData.g_SchemaCache.ReleaseRef(parent_class);
         }
      }

      // optional attributes
      if (!wiz_info.strlistOptional.IsEmpty())
      {
         VARIANT value;
         ::VariantInit(&value);

         hr = StringListToVariant(value, wiz_info.strlistOptional);

         // NTRAID#NTBUG9-543624-2002/02/15-dantra-Result of StringListToVariant being ignored resulting in call to IADs::PutEx with incorrect data
         BREAK_ON_FAILED_HRESULT(hr);

         // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
         hr = iads->PutEx( ADS_PROPERTY_UPDATE, CComBSTR(g_MayContain), value);
         ::VariantClear(&value);

         BREAK_ON_FAILED_HRESULT(hr);
      }

      // mandatory attributes
      if (!wiz_info.strlistMandatory.IsEmpty())
      {
         VARIANT value;
         ::VariantInit(&value);

         hr = StringListToVariant(value, wiz_info.strlistMandatory);

         // don't break: plod onward.
         // NTRAID#NTBUG9-543624-2002/02/15-dantra-Result of StringListToVariant being ignored resulting in call to IADs::PutEx with incorrect data
         BREAK_ON_FAILED_HRESULT(hr);

         // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
         hr = iads->PutEx( ADS_PROPERTY_UPDATE, CComBSTR(g_MustContain), value);
         ::VariantClear(&value);

         BREAK_ON_FAILED_HRESULT(hr);
      }


      // commit the create
      hr = iads->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

      
      // if there was no ldap name, and it worked, cn was used as ldap name
      if( wiz_info.ldapDisplayName.IsEmpty() )
      {
         CComVariant value;
         hr = iads->Get(CComBSTR(g_DisplayName), &value);
         ASSERT( SUCCEEDED(hr) );   // should be there!!!

         if( SUCCEEDED(hr) )
         {
             ASSERT( value.vt == VT_BSTR );
             wiz_info.ldapDisplayName = value.bstrVal;
         }
      }

      // create a cache entry for the new class object
      new_object = new SchemaObject;
      new_object->schemaObjectType = SCHMMGMT_CLASS;
      new_object->commonName = wiz_info.cn;
      new_object->ldapDisplayName = wiz_info.ldapDisplayName;
      new_object->oid = wiz_info.oid;
      new_object->dwClassType = wiz_info.type + 1;
      new_object->subClassOf = wiz_info.parentClass;

      ListEntry* new_list = 0;
      hr =
         StringListToColumnList(
            &parent_ComponentData,
            wiz_info.strlistOptional,
            &new_list);
      BREAK_ON_FAILED_HRESULT(hr);

      new_object->mayContain = new_list;

      new_list = 0;
      hr =
         StringListToColumnList(
            &parent_ComponentData,
            wiz_info.strlistMandatory,
            &new_list);
      BREAK_ON_FAILED_HRESULT(hr);

      new_object->mustContain = new_list;

      // stuff the new cache entry into the cache
      hr =
         parent_ComponentData.g_SchemaCache.InsertSchemaObject(new_object);
      BREAK_ON_FAILED_HRESULT(hr);
      hr =
         parent_ComponentData.g_SchemaCache.InsertSortedSchemaObject(new_object);
      BREAK_ON_FAILED_HRESULT(hr);

      // insert the new cache object into the snapin ui   
      parent_ComponentData.g_ClassCookieList.InsertSortedDisplay(
         &parent_ComponentData,
         new_object);
   }
   while (0);

   if (FAILED(hr))
   {
      delete new_object;

      if (hr == ADS_EXTENDED_ERROR)
      {
         DoExtErrMsgBox();
      }
      else
      {
         CString title;
         title.LoadString(AFX_IDS_APP_TITLE);
         CString error_text;
         CString name;

         HRESULT last_ads_hr = GetLastADsError(hr, error_text, name);
         if (HRESULT_CODE(last_ads_hr) == ERROR_DS_INVALID_LDAP_DISPLAY_NAME)
         {
           error_text.LoadString(IDS_LDAPDISPLAYNAME_FORMAT_ERROR);
         }
         else
         {
            error_text = GetErrorMessage(hr,TRUE);
         }

         ::MessageBox(
            m_hWnd,
            error_text,
            title,
            MB_OK | MB_ICONSTOP);
      }

      return FALSE;
   }
         
   // end the wizard
   // @@ call base::OnWizardFinish()?
   return TRUE;
}



void
NewClassAttributesPage::OnButtonOptionalAdd()
{
    listbox_optional.AddNewObjectToList();
}



void
NewClassAttributesPage::OnButtonMandatoryAdd()
{
    listbox_mandatory.AddNewObjectToList();
}



void
NewClassAttributesPage::OnButtonOptionalRemove()
{
    listbox_optional.RemoveListBoxItem();
}



void
NewClassAttributesPage::OnButtonMandatoryRemove()
{
    listbox_mandatory.RemoveListBoxItem();
}



void
NewClassAttributesPage::OnMandatorySelChange()
{
    listbox_mandatory.OnSelChange();
}    



void
NewClassAttributesPage::OnOptionalSelChange()
{
    listbox_optional.OnSelChange();
}    



void
NewClassAttributesPage::DoDataExchange(CDataExchange *pDX)
{
   CPropertyPage::DoDataExchange(pDX);

   DDX_Control(pDX, IDC_MANDATORY_LIST, listbox_mandatory);
   DDX_Control(pDX, IDC_OPTIONAL_LIST, listbox_optional);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\ncattr.hpp ===
#ifndef NCATTR_HPP_INCLUDED
#define NCATTR_HPP_INCLUDED



class NewClassAttributesPage : public CPropertyPage
{
   public:

   NewClassAttributesPage(
      CreateClassWizardInfo* wi,
      ComponentData*         cd);

//   ~NewClassAttributesPage();

   protected:

   virtual
   void
   DoDataExchange(CDataExchange *pDX);

   virtual
   BOOL
   OnInitDialog();


   static const DWORD help_map[];

   BOOL OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


   virtual
   BOOL
   OnKillActive();

   virtual
   void
   OnOK();

   virtual
   BOOL
   OnSetActive();

   virtual
   BOOL
   OnWizardFinish();

   DECLARE_MESSAGE_MAP()

   afx_msg void OnButtonOptionalAdd();
   afx_msg void OnButtonOptionalRemove();
   afx_msg void OnButtonMandatoryAdd();
   afx_msg void OnButtonMandatoryRemove();
   afx_msg void OnMandatorySelChange();
   afx_msg void OnOptionalSelChange();

   private:

   bool
   saveAndValidate();

   CreateClassWizardInfo& wiz_info;            
   ComponentData&         parent_ComponentData;
   CSchemaObjectsListBox  listbox_mandatory;   
   CSchemaObjectsListBox  listbox_optional;    
};



#endif   // NCATTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\newattr.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "newattr.hpp"



// The default syntax for new attributes
const UINT  uDefaultSyntax = 0;



//
// The create new attribute dialog box.
//

CreateAttributeDialog::CreateAttributeDialog(
    ComponentData *pScope,
    LPDATAOBJECT lpDataObject
) :
    CDialog(IDD_CREATE_ATTRIBUTE, NULL),
    fDialogLoaded( FALSE ),
    MultiValued( FALSE ),
    pScopeControl( pScope ),
    lpScopeDataObj( lpDataObject ),
	  SyntaxOrdinal( uDefaultSyntax ),
    m_editOID( CParsedEdit::EDIT_TYPE_OID ),
    m_editLowerRange( CParsedEdit::EDIT_TYPE_UINT32 ),
    m_editUpperRange( CParsedEdit::EDIT_TYPE_UINT32 )


{
	ASSERT( uDefaultSyntax < SCHEMA_SYNTAX_UNKNOWN );
}



CreateAttributeDialog::~CreateAttributeDialog()
{ ; }


BOOL
CreateAttributeDialog::OnInitDialog()
{
    CComboBox * pwndSyntaxCombo	= NULL;
    
    CDialog::OnInitDialog();
    
    //
    // Set Limits on Range controls
    //
    
    ASSERT( GetDlgItem(IDC_CREATE_ATTRIB_MIN) );
    ASSERT( GetDlgItem(IDC_CREATE_ATTRIB_MAX) );
    
    m_editOID.SubclassEdit( IDC_CREATE_ATTRIB_OID, this, cchMaxOID );
    m_editLowerRange.SubclassEdit(IDC_CREATE_ATTRIB_MIN, this, cchMinMaxRange);
    m_editUpperRange.SubclassEdit(IDC_CREATE_ATTRIB_MAX, this, cchMinMaxRange);
    
    //
    // Turn off IME support on the min/max edit boxes
    //
    ImmAssociateContext(m_editLowerRange.GetSafeHwnd(), NULL);
    ImmAssociateContext(m_editUpperRange.GetSafeHwnd(), NULL);

    //
    // Load the syntax combo box.
    //
    
    ASSERT( GetDlgItem( IDC_CREATE_ATTRIB_SYNTAX ) );
    pwndSyntaxCombo = static_cast<CComboBox *>(GetDlgItem(IDC_CREATE_ATTRIB_SYNTAX));
    VERIFY( pwndSyntaxCombo );
    
    pwndSyntaxCombo->ResetContent() ;
    
    for ( UINT iSyntaxOrdinal = 0 ;
    	  iSyntaxOrdinal < SCHEMA_SYNTAX_UNKNOWN ;
          iSyntaxOrdinal++ )
    {
        pwndSyntaxCombo->AddString( g_Syntax[iSyntaxOrdinal].m_strSyntaxName );
    }

    pwndSyntaxCombo->SetCurSel( SyntaxOrdinal );
    OnSelchangeSyntax();

    return TRUE;
}


void
CreateAttributeDialog::DoDataExchange(
    CDataExchange *pDX
) {

    CDialog::DoDataExchange( pDX );

    DDX_Text( pDX, IDC_CREATE_ATTRIB_CN, CommonName );
    DDV_MaxChars( pDX, CommonName, 64 );

    DDX_Text( pDX, IDC_CREATE_ATTRIB_LDN, LdapDisplayName );
    DDV_MaxChars( pDX, LdapDisplayName, 256 );

    DDX_Text( pDX, IDC_CREATE_ATTRIB_OID, OID );

    DDX_Text( pDX, IDC_DESCRIPTION_EDIT, Description );

    DDX_Check( pDX, IDC_CREATE_ATTRIB_VALUED, MultiValued );

    ASSERT( !pDX->m_bSaveAndValidate || SyntaxOrdinal == (UINT)
			static_cast<CComboBox *>(GetDlgItem(IDC_CREATE_ATTRIB_SYNTAX))->GetCurSel() );

    DDXV_VerifyAttribRange( pDX, g_Syntax[ SyntaxOrdinal ].m_fIsSigned,
							IDC_CREATE_ATTRIB_MIN, Min,
							IDC_CREATE_ATTRIB_MAX, Max );
    return;

}

inline void RemoveAttributeInfoLine( ADS_ATTR_INFO * attrInfo, DWORD dwLine, DWORD & dwArraySize )
{
	dwArraySize--;

	for( ; dwLine < dwArraySize; dwLine++ )
		attrInfo[ dwLine ] = attrInfo[ dwLine + 1 ];
}


void
CreateAttributeDialog::OnOK(
    void
) {

	HRESULT				hr					= S_OK;
    SchemaObject *		pNewSchemaObject	= NULL;
	DWORD				dwValue				= 0;

	IDirectoryObject *	pDirObject			= NULL;
	IDispatch *			pDisp				= NULL;
    
	CString				strSchemaPath;
    CString				strDecoratedName;

	ADSVALUE			adsvClassValue,
						adsvLDAPDisplayName,
            adsvDescription,
						adsvAttributeID,
						adsvAttributeSyntax,
						adsvOmSyntax,
						adsvOmObjectClass,
						adsvIsSingleValued,
						adsvLowerRange,
						adsvUpperRange;


    //
    // Update parameters from the Dialog
    //

    if ( !UpdateData(TRUE) ) {
        return;
    }

    CWaitCursor wait;

    //
    // Validate the parameters.
    //

    //
    // Check for valid OID
    //
    int errorTypeStrID = 0;
    if (!OIDHasValidFormat(OID, errorTypeStrID))
    {
      CString errorType;
      CString text;

      VERIFY (errorType.LoadString(errorTypeStrID));
      text.FormatMessage(IDS_OID_FORMAT_INVALID, OID, errorType);

      DoErrMsgBox( ::GetActiveWindow(), TRUE, text );
      return;
    }

    if ( ( CommonName.IsEmpty() )       ||
         ( SyntaxOrdinal >= SCHEMA_SYNTAX_UNKNOWN ) ) {

        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CREATE_INVALID_PARAM );
        return;
    }

    //
    // Allocate a new schema cache object for this object.
    //

    pNewSchemaObject = new SchemaObject();

    if ( !pNewSchemaObject ) {
       DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_MEM );
       return;
    }

    pNewSchemaObject->schemaObjectType	= SCHMMGMT_ATTRIBUTE;
    pNewSchemaObject->commonName		= CommonName;
    pNewSchemaObject->description = Description;

    //
    // Get the schema container.
    //

    pScopeControl->GetBasePathsInfo()->GetSchemaPath(strSchemaPath);

    hr = SchemaOpenObject(
             (LPWSTR)(LPCWSTR)strSchemaPath,
             IID_IDirectoryObject,
             (void **)&pDirObject );

    if ( FAILED(hr) )
	{
		if ( hr == ADS_EXTENDED_ERROR )
			DoExtErrMsgBox();
		else
			DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
    }
	else
	{
		// During the attrib creation, some of the lines may need to be skipped.  Use RemoveAttributeInfoLine()
		// for this.  Removal should be done top to bottom of this array, because all the consts are relative to
		// the end of the array.
		ADS_ATTR_INFO  attrInfo[] =
		{
			{g_ObjectClass,			ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING, &adsvClassValue,		1},
			{g_GlobalAttributeID,	ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING,	&adsvAttributeID,		1},
			{g_IsSingleValued,		ADS_ATTR_UPDATE,	ADSTYPE_BOOLEAN,			&adsvIsSingleValued,	1},
			{g_AttributeSyntax,		ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING,	&adsvAttributeSyntax,	1},
			{g_omSyntax,			ADS_ATTR_UPDATE,	ADSTYPE_INTEGER,			&adsvOmSyntax,			1},

				// make sure the following five attribute's indexes match with constants!!!
      {g_Description,     ADS_ATTR_UPDATE,  ADSTYPE_CASE_IGNORE_STRING, &adsvDescription, 1},
			{g_DisplayName,			ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING,	&adsvLDAPDisplayName,	1},
			{g_omObjectClass,		ADS_ATTR_UPDATE,	ADSTYPE_OCTET_STRING,		&adsvOmObjectClass,		1},
			{g_RangeLower,			ADS_ATTR_UPDATE,	ADSTYPE_INTEGER,			&adsvLowerRange,		1},
			{g_RangeUpper,			ADS_ATTR_UPDATE,	ADSTYPE_INTEGER,			&adsvUpperRange,		1},
		};
		
		DWORD dwAttrs				= sizeof(attrInfo) / sizeof(attrInfo[0]);

		// relative constants.  Describe the location of the attributes relative to the end of the list
    const DWORD dwAttrsDescription = 4; // fifth to last in the array
		const DWORD dwAttrsLdapName     = 3;	// fourth to last in the array
		const DWORD dwAttrsObjectClass	= 2;	// third to last in the array
		const DWORD dwAttrsRangeLower	= 1;	// second to last in the array
		const DWORD dwAttrsRangeUpper	= 0;	// last in the array

	
		// Object's Class -- "attributeSchema"
		adsvClassValue.dwType					= ADSTYPE_CASE_IGNORE_STRING;
		adsvClassValue.CaseIgnoreString			= const_cast<LPWSTR>( g_AttributeFilter );

		// OID
		adsvAttributeID.dwType					= ADSTYPE_CASE_IGNORE_STRING;
		adsvAttributeID.CaseIgnoreString		= const_cast<LPWSTR>( (LPCWSTR) OID );
		pNewSchemaObject->oid					= OID;

		// Is this a single valued attribute?
		adsvIsSingleValued.dwType				= ADSTYPE_BOOLEAN;
		adsvIsSingleValued.Boolean				= !MultiValued;
		
		// Attribute Syntax (3 parts)
		ASSERT( g_Syntax[SyntaxOrdinal].m_pszAttributeSyntax );
		adsvAttributeSyntax.dwType				= ADSTYPE_CASE_IGNORE_STRING;
		adsvAttributeSyntax.CaseIgnoreString	= const_cast<LPWSTR>( g_Syntax[SyntaxOrdinal].m_pszAttributeSyntax );

		ASSERT( g_Syntax[SyntaxOrdinal].m_nOmSyntax );
		adsvOmSyntax.dwType						= ADSTYPE_INTEGER;
		adsvOmSyntax.Integer					= g_Syntax[SyntaxOrdinal].m_nOmSyntax;

    //
    // Skip the Description if not needed
    //
    if (Description.IsEmpty())
    {
      RemoveAttributeInfoLine(attrInfo, dwAttrs - dwAttrsDescription - 1, dwAttrs);
    }
    else
    {
      adsvDescription.dwType = ADSTYPE_CASE_IGNORE_STRING;
      adsvDescription.CaseIgnoreString = const_cast<LPWSTR>( (LPCWSTR) Description );
    }

    //		skip Ldap Name if not needed
		if( LdapDisplayName.IsEmpty() )
		{
			RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsLdapName - 1, dwAttrs );
		}
		else
		{
            adsvLDAPDisplayName.dwType				= ADSTYPE_CASE_IGNORE_STRING;
            adsvLDAPDisplayName.CaseIgnoreString	= const_cast<LPWSTR>( (LPCWSTR) LdapDisplayName );
            pNewSchemaObject->ldapDisplayName		= LdapDisplayName;
		}
        
        
        //		skip OM-Object-Class if not needed
		if( 0 == g_Syntax[SyntaxOrdinal].m_octstrOmObjectClass.dwLength )
		{
			RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsObjectClass - 1, dwAttrs );
		}
		else
		{
			adsvOmObjectClass.dwType			= ADSTYPE_OCTET_STRING;
			adsvOmObjectClass.OctetString		= g_Syntax[SyntaxOrdinal].m_octstrOmObjectClass;
		}

		pNewSchemaObject->SyntaxOrdinal			= SyntaxOrdinal;
		
		hr = S_OK;

		// Lower Range
		if( Min.IsEmpty() )
		{
			RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsRangeLower - 1, dwAttrs );
		}
		else
		{
			// if the function call fails, no attrib creation is performed
			hr						= GetSafeSignedDWORDFromString( this, dwValue, Min,
										g_Syntax[SyntaxOrdinal].m_fIsSigned, GETSAFEINT_ALLOW_CANCEL );

			adsvLowerRange.dwType	= ADSTYPE_INTEGER;
			adsvLowerRange.Integer	= dwValue;
		}
		
		// Upper Range
		if( SUCCEEDED(hr) )
		{
			if( Max.IsEmpty() )
			{
				RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsRangeUpper - 1, dwAttrs );
			}
			else
			{
				// if function call fails, no attrib creation is performed
				hr						= GetSafeSignedDWORDFromString( this, dwValue, Max,
											g_Syntax[SyntaxOrdinal].m_fIsSigned, GETSAFEINT_ALLOW_CANCEL );

				adsvUpperRange.dwType	= ADSTYPE_INTEGER;
				adsvUpperRange.Integer	= dwValue;
			}
		}
		

		//
		// Create the schema object.
		//

		if( SUCCEEDED(hr) )
		{
            pScopeControl->GetSchemaObjectPath( CommonName, strDecoratedName, ADS_FORMAT_LEAF );

			hr = pDirObject->CreateDSObject( const_cast<LPWSTR>( (LPCWSTR) strDecoratedName ),
												attrInfo, dwAttrs, &pDisp );

			if ( SUCCEEDED( hr ) )
      {
        // if there was no ldap name, and it worked, cn was used as ldap name
        if( LdapDisplayName.IsEmpty() )
        {
          ASSERT( pDisp );

          CComVariant                 value;
          CComQIPtr<IADs, &IID_IADs>  iads(pDisp);

          if( !iads )
          {
            ASSERT( FALSE );
          }
          else
          {
            hr = iads->Get(CComBSTR(g_DisplayName), &value);
            ASSERT( SUCCEEDED(hr) );   // should be there!!!
        
            if( SUCCEEDED(hr) )
            {
              ASSERT( value.vt == VT_BSTR );
              pNewSchemaObject->ldapDisplayName = value.bstrVal;
            }
          }
        }

				//
				// Insert this object into the display cache.
				//

				hr = pScopeControl->g_SchemaCache.InsertSchemaObject( pNewSchemaObject );
				ASSERT( SUCCEEDED( hr ) );

				hr = pScopeControl->g_SchemaCache.InsertSortedSchemaObject( pNewSchemaObject );
				ASSERT( SUCCEEDED( hr ) );

				hr = pScopeControl->m_pConsole->UpdateAllViews( lpScopeDataObj,
																SCHMMGMT_ATTRIBUTES,
																SCHMMGMT_UPDATEVIEW_REFRESH );
				ASSERT( SUCCEEDED( hr ) );

				EndDialog( IDOK );
			}
			else	// attribute creation failed
			{
				if ( hr == ADS_EXTENDED_ERROR )
        {
          DoExtErrMsgBox();
        }
				else
        {
           CString error_text;
           CString name;

           HRESULT last_ads_hr = GetLastADsError(hr, error_text, name);
           if (HRESULT_CODE(last_ads_hr) == ERROR_DS_INVALID_LDAP_DISPLAY_NAME)
           {
             error_text.LoadString(IDS_LDAPDISPLAYNAME_FORMAT_ERROR);
           }
           else
           {
              error_text = GetErrorMessage(hr,TRUE);
           }

 					 DoErrMsgBox( ::GetActiveWindow(), TRUE, error_text );
        }
			}

			if( pDisp )
				pDisp->Release();
		}
	}
	
	if( pDirObject )
		pDirObject->Release();
}


BEGIN_MESSAGE_MAP( CreateAttributeDialog, CDialog )
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	ON_CBN_SELCHANGE(IDC_CREATE_ATTRIB_SYNTAX, OnSelchangeSyntax)
END_MESSAGE_MAP()


const DWORD CreateAttributeDialog::help_map[] =
{
    IDI_ATTRIBUTE,                      NO_HELP,
    IDC_CREATE_ATTRIBUTE_PROMPT_STATIC, NO_HELP,
    IDC_CREATE_ATTRIB_CN,               IDH_CREATE_ATTRIB_CN,
    IDC_CREATE_ATTRIB_LDN,              IDH_CREATE_ATTRIB_LDN,
    IDC_CREATE_ATTRIB_OID,              IDH_CREATE_ATTRIB_OID,
    IDC_DESCRIPTION_EDIT,               IDH_ATTRIB_GENERAL_DESCRIPTION_EDIT,
    IDC_CREATE_ATTRIB_SYNTAX,           IDH_CREATE_ATTRIB_SYNTAX,
    IDC_CREATE_ATTRIB_MIN,              IDH_CREATE_ATTRIB_MIN,
    IDC_CREATE_ATTRIB_MAX,              IDH_CREATE_ATTRIB_MAX,
    IDC_CREATE_ATTRIB_VALUED,           IDH_CREATE_ATTRIB_VALUED,
    0,0
};


void CreateAttributeDialog::OnSelchangeSyntax() 
{
	DWORD		dw				= 0;		// temporary variable
	BOOL		fIsSigned		= FALSE;
	CComboBox * pwndSyntaxCombo	= NULL;
	UINT		nOldSyntax		= SyntaxOrdinal;
	HRESULT		hr				= S_OK;

	ASSERT( GetDlgItem( IDC_CREATE_ATTRIB_SYNTAX ) );
  pwndSyntaxCombo = static_cast<CComboBox *>(GetDlgItem(IDC_CREATE_ATTRIB_SYNTAX));
  VERIFY( pwndSyntaxCombo );

	ASSERT( CB_ERR != pwndSyntaxCombo->GetCurSel() );

	SyntaxOrdinal = (UINT) pwndSyntaxCombo->GetCurSel();
	if( SyntaxOrdinal >= SCHEMA_SYNTAX_UNKNOWN )
	{
		ASSERT( FALSE );
		pwndSyntaxCombo->SetCurSel( SyntaxOrdinal = uDefaultSyntax );
	}

	fIsSigned	= g_Syntax[ SyntaxOrdinal ].m_fIsSigned;

	if( GetDlgItemText( IDC_CREATE_ATTRIB_MIN, Min ) )
	{
		hr = GetSafeSignedDWORDFromString( this, dw, Min, fIsSigned, GETSAFEINT_ALLOW_CANCEL ) ;
		if( S_VALUE_MODIFIED == hr )
			SetDlgItemText( IDC_CREATE_ATTRIB_MIN, Min );
	}

	if( SUCCEEDED( hr ) && GetDlgItemText( IDC_CREATE_ATTRIB_MAX, Max ) )
	{
		hr = GetSafeSignedDWORDFromString( this, dw, Max, fIsSigned, GETSAFEINT_ALLOW_CANCEL );
		if( S_VALUE_MODIFIED == hr )
			SetDlgItemText( IDC_CREATE_ATTRIB_MAX, Max );
	}

	if( SUCCEEDED( hr ) )
	{
		m_editLowerRange.SetSigned( fIsSigned );
		m_editUpperRange.SetSigned( fIsSigned );
	}
	else
	{
		SyntaxOrdinal	= nOldSyntax;
		pwndSyntaxCombo->SetCurSel( SyntaxOrdinal );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\newattr.hpp ===
#ifndef NEWATTR_HPP_INCLUDED
#define NEWATTR_HPP_INCLUDED


class CreateAttributeDialog : public CDialog
{
   public:

   CreateAttributeDialog( ComponentData *pScope,
                           LPDATAOBJECT lpDataObject );

   ~CreateAttributeDialog();

   BOOL fDialogLoaded;

   BOOL MultiValued;
   UINT SyntaxOrdinal;
   CString CommonName;
   CString OID;
   CString LdapDisplayName;
   CString Description;

   CString Min;
   CString Max;

   ComponentData *pScopeControl;
   LPDATAOBJECT lpScopeDataObj;

   CParsedEdit	m_editOID;
   CParsedEdit	m_editLowerRange;
   CParsedEdit	m_editUpperRange;

   virtual void OnOK();
   virtual void DoDataExchange( CDataExchange *pDX );
   virtual BOOL OnInitDialog();

   BOOL OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   void	OnSelchangeSyntax();

   DECLARE_MESSAGE_MAP()

private:

   static const DWORD help_map[];
};




#endif   // NEWATTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\ncgen.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "wizinfo.hpp"
#include "ncgen.hpp"

// FUTURE-2002-03/94/2002-dantra-This class has virtually no documentation.

const DWORD NewClassGeneralPage::help_map[] =
{
  IDC_CREATE_CLASS_CN,     IDH_CREATE_CLASS_CN,
  IDC_CREATE_CLASS_LDN,    IDH_CREATE_CLASS_LDN,
  IDC_CREATE_CLASS_OID,    IDH_CREATE_CLASS_OID,
  IDC_DESCRIPTION_EDIT,    IDH_CLASS_GENERAL_DESCRIPTION_EDIT,
  IDC_CREATE_CLASS_PARENT, IDH_CREATE_CLASS_PARENT,
  IDC_CREATE_CLASS_TYPE,   IDH_CREATE_CLASS_TYPE,
  0,0
};



BEGIN_MESSAGE_MAP(NewClassGeneralPage, CPropertyPage)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
END_MESSAGE_MAP()



NewClassGeneralPage::NewClassGeneralPage(CreateClassWizardInfo* pWi)
   :
   CPropertyPage(IDD_CREATE_CLASS_GENERAL),
   m_editOID( CParsedEdit::EDIT_TYPE_OID )
{
    ASSERT( pWi );
    pWiz_info   = pWi;
}



BOOL
NewClassGeneralPage::OnInitDialog() 
{
   CPropertyPage::OnInitDialog();
   
   // load the combo box

   HWND combo = ::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_TYPE);
   ASSERT( combo );

   ComboBox_AddString(combo, g_StructuralClass);
   ComboBox_AddString(combo, g_AbstractClass);
   ComboBox_AddString(combo, g_AuxClass);
   ComboBox_SetCurSel(combo, 0);

   // set boundaries

   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_CN),     64); 
   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_LDN),    256);
   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_PARENT), 256);
   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_DESCRIPTION_EDIT),    256);
   
   m_editOID.SubclassEdit( IDC_CREATE_CLASS_OID, this, cchMaxOID );

   return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL
NewClassGeneralPage::OnSetActive()
{
   CPropertySheet* parent = (CPropertySheet*) GetParent();   
   parent->SetWizardButtons(PSWIZB_NEXT);

   return TRUE;
}



void
Gripe(HWND parent, CEdit* edit, unsigned messageResID)
{
   ASSERT(edit);

   DoErrMsgBox(parent, TRUE, messageResID);
   edit->SetFocus();
   edit->SetSel(0, -1);
}



BOOL
NewClassGeneralPage::OnKillActive()
{
  // NTRAID#NTBUG9-562426-2002/03/04-dantra-GetDlgItemText Result being ignored
  // save the settings
  GetDlgItemText(IDC_CREATE_CLASS_CN,     pWiz_info->cn);             
  GetDlgItemText(IDC_CREATE_CLASS_LDN,    pWiz_info->ldapDisplayName);
  GetDlgItemText(IDC_CREATE_CLASS_OID,    pWiz_info->oid);  
  GetDlgItemText(IDC_DESCRIPTION_EDIT,    pWiz_info->description);
  GetDlgItemText(IDC_CREATE_CLASS_PARENT, pWiz_info->parentClass);    
  pWiz_info->type = ComboBox_GetCurSel(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_TYPE));

  // validate

  // do cn first, as it appears at the top of the page
  if (pWiz_info->cn.IsEmpty())
  {
    Gripe(m_hWnd, (CEdit*) GetDlgItem(IDC_CREATE_CLASS_CN), IDS_MUST_ENTER_CN);
    return FALSE;
  }
    //
    // Check for valid OID
    //
    int errorTypeStrID = 0;
    if (!OIDHasValidFormat(pWiz_info->oid, errorTypeStrID))
    {
      CString errorType;
      CString text;

      VERIFY (errorType.LoadString(errorTypeStrID));
      text.FormatMessage(IDS_OID_FORMAT_INVALID, pWiz_info->oid, errorType);

      DoErrMsgBox( ::GetActiveWindow(), TRUE, text );
      return FALSE;
    }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\ncgen.hpp ===
#ifndef NCGEN_HPP_INCLUDED
#define NCGEN_HPP_INCLUDED



class NewClassGeneralPage : public CPropertyPage
{
   public:

   NewClassGeneralPage(CreateClassWizardInfo* wi);

//   ~NewClassGeneralPage();

   protected:

   static const DWORD help_map[];

   BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   virtual
   BOOL
   OnInitDialog();

   virtual
   BOOL
   OnKillActive();

   virtual
   BOOL
   OnSetActive();

   DECLARE_MESSAGE_MAP()

   private:

   CParsedEdit	           m_editOID;
   CreateClassWizardInfo * pWiz_info;
};



#endif   // NCGEN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\newclass.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "newclass.hpp"
#include "wizinfo.hpp"
#include "ncgen.hpp"
#include "ncattr.hpp"



void
DoNewClassDialog(ComponentData& cd)
{
   CThemeContextActivator activator;

   CPropertySheet         prop_sheet(IDS_NEW_CLASS_PROP_SHEET_TITLE);
   CreateClassWizardInfo  info;                                      
   NewClassGeneralPage    general_page(&info);                       
   NewClassAttributesPage attr_page(&info, &cd);                          

   prop_sheet.AddPage(&general_page);
   prop_sheet.AddPage(&attr_page);

   prop_sheet.SetWizardMode();
   prop_sheet.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\newclass.hpp ===
#ifndef NEWCLASS_HPP_INCLUDED
#define NEWCLASS_HPP_INCLUDED



void
DoNewClassDialog(ComponentData& cd);



#endif   // NEWCLASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\nodetype.h ===
// nodetype.h : Declaration of SchmMgmtObjectType

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

//
// These are the enum types for node types that we use in cookies.
// These types are mapped to guids that are in uuids.h.
//
// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL
// string resources must be kept in sync with these values, and in
// the appropriate order.
//
// The global variable in cookie.cpp aColumns[][] must be kept in sync.
//

typedef enum _SchmMgmtObjectType {

        //
        // The root node.
        //

        SCHMMGMT_SCHMMGMT = 0,

        //
        // The two top level nodes.
        //

        SCHMMGMT_CLASSES,
        SCHMMGMT_ATTRIBUTES,

        //
        // Class may be a leaf node beneath
        // the classes node only.
        //

        SCHMMGMT_CLASS,

        //
        // Attribute is a result item beneath
        // the Attributes folder scope item.
        //

        SCHMMGMT_ATTRIBUTE,

        //
        // This must come last.
        //

        SCHMMGMT_NUMTYPES

} SchmMgmtObjectType, *PSchmMgmtObjectType;

inline BOOL IsValidObjectType( SchmMgmtObjectType objecttype )
        { return (objecttype >= SCHMMGMT_SCHMMGMT && objecttype < SCHMMGMT_NUMTYPES); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\persist.cpp ===
// Persist.cpp : Implementation of persistence

#include "stdafx.h"
#include "compdata.h"
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(persist.cpp)")

STDMETHODIMP ComponentData::Load(IStream __RPC_FAR *pIStream)
{
        MFC_TRY;

#ifndef DONT_PERSIST
        ASSERT( NULL != pIStream );
        XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

        // read server name from stream
        DWORD dwLen = 0;
        HRESULT hr = pIStream->Read( &dwLen, 4, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
        ASSERT( dwLen <= MAX_PATH*sizeof(WCHAR) );
        LPCWSTR lpwcszMachineName = (LPCWSTR)alloca( dwLen );
        // allocated from stack, we don't need to free
        if (NULL == lpwcszMachineName)
        {
                AfxThrowMemoryException();
                return E_OUTOFMEMORY;
        }
        hr = pIStream->Read( (PVOID)lpwcszMachineName, dwLen, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
        QueryRootCookie().SetMachineName( lpwcszMachineName );

#endif
        return S_OK;

        MFC_CATCH;
}

STDMETHODIMP ComponentData::Save(IStream __RPC_FAR *pIStream, BOOL)
{
        MFC_TRY;

#ifndef DONT_PERSIST
        ASSERT( NULL != pIStream );
        XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

        LPCWSTR lpwcszMachineName = QueryRootCookie().QueryNonNULLMachineName();

        DWORD dwLen = static_cast<DWORD>((::wcslen(lpwcszMachineName)+1)*sizeof(WCHAR));
        ASSERT( 4 == sizeof(DWORD) );
        HRESULT hr = pIStream->Write( &dwLen, 4, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
        hr = pIStream->Write( lpwcszMachineName, dwLen, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
#endif
        return S_OK;

        MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\schmmgmt.h ===
#ifndef _SCHMMGMT_H
#define _SCHMMGMT_H

extern const GUID CLSID_SchmMgmt;
extern const GUID CLSID_SchemaManagementAbout;


#endif // _SCHMMGMT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define ID_BUTTON_MORE_INFO             3
#define IDS_FSMO_SERVER_ERROR           14
#define IDS_SNAPINABOUT_DESCRIPTION     92
#define IDS_DEFUNCT                     93
#define IDS_ACTIVE                      94
#define IDS_ERRMSG_DELETE_FAILED_ATTRIBUTE 95
#define IDS_ERRMSG_DELETE_FAILED_CLASS  96
#define IDS_SCHMMGMT_DESC               101
#define IDS_SCOPE_CLASSES               105
#define IDS_SCOPE_ATTRIBUTES            106
#define IDD_CLASS_GENERAL               107
#define IDS_COLUMN_NAME                 108
#define IDS_COLUMN_TYPE                 109
#define IDS_COLUMN_DESCRIPTION          110
#define IDS_SCOPE_SCHMMGMT              111
#define IDS_COLUMN_PARENT               112
#define IDS_CLASS_STRUCTURAL            113
#define IDS_CLASS_ABSTRACT              114
#define IDS_CLASS_AUXILIARY             115
#define IDS_ATTRIBUTE_MANDATORY         116
#define IDS_ATTRIBUTE_OPTIONAL          117
#define IDS_COLUMN_STATUS               118
#define IDS_ERR_NO_NAME                 120
#define IDS_ERR_NO_DESCRIPTION          122
#define IDS_ERR_ERROR                   123
#define IDS_ERR_WARNING                 124
#define IDS_ERR_NO_SCHEMA_PATH          125
#define IDS_COLUMN_SYNTAX               126
#define IDS_ERR_NO_SCHEMA_OBJECT        127
#define IDS_CLASS_SYSTEM                128
#define IDS_SYNTAX_I5_STR               129
#define IDS_SYNTAX_DN                   130
#define IDS_SYNTAX_OID                  131
#define IDS_SYNTAX_NOCASE_STR           133
#define IDS_SYNTAX_PRCS_STR             134
#define IDS_SYNTAX_NUMSTR               135
#define IDS_SYNTAX_OR_NAME              136
#define IDS_SYNTAX_BOOLEAN              137
#define IDS_SYNTAX_INTEGER              138
#define IDS_SYNTAX_OCTET                139
#define IDS_SYNTAX_UTC                  140
#define IDS_SYNTAX_UNICODE              141
#define IDS_SYNTAX_ADDRESS              142
#define IDS_SYNTAX_DNSTRING             143
#define IDS_SYNTAX_SEC_DESC             144
#define IDS_SYNTAX_LINT                 145
#define IDS_SYNTAX_SID                  146
#define IDS_SYNTAX_UNKNOWN              147
#define IDS_ATTRIBUTE_MULTI             148
#define IDS_ATTRIBUTE_SINGLE            149
#define IDS_ERR_EDIT_DESC               150
#define IDS_ERR_INT_OVERFLOW            151
#define IDS_ERR_NUM_IS_ILLIGAL          152
#define IDS_ERR_EDIT_DISPLAYABLE        153
#define IDS_ERR_EDIT_INDEXED            154
#define IDS_SYNTAX_DN_BINARY            155
#define IDS_MENU_CLASS                  156
#define IDS_ATTR_SYSTEM                 157
#define IDS_MENU_ATTRIBUTE              160
#define IDS_STATUS_CREATE_CLASS         163
#define IDS_STATUS_CREATE_ATTRIBUTE     167
#define IDS_COLUMN_SYSTEM               172
#define IDS_YES                         173
#define IDS_NO                          174
#define IDS_SYNTAX_ENUMERATION          175
#define IDS_ERR_CREATE_INVALID_PARAM    182
#define IDS_ERR_CREATE_INVALID_OID      183
#define IDS_UNKNOWN                     187
#define IDS_MENU_REFRESH                188
#define IDS_STATUS_REFRESH              189
#define IDS_ERR_NO_UPDATE               190
#define IDS_ERR_NO_MEM                  191
#define IDS_SYNTAX_REPLICA_LINK         192
#define IDS_SYNTAX_GEN_TIME             193
#define IDS_ERR_CHANGE_REJECT           194
#define IDS_CLASS_88                    195
#define IDS_REGSERV_NAME                196
#define IDS_REGSERV_MICROSOFT           197
#define IDS_REGSERV_ABOUT               198
#define IDS_REGSERV_PROVIDER            199
#define IDS_REGSERV_VERSION             200
#define IDC_CLASS_GENERAL_DESCRIPTION_EDIT 201
#define IDS_SYNTAX_ACCESS_POINT         201
#define IDC_CLASS_GENERAL_NAME_STATIC   202
#define IDS_ERR_EDIT_MINMAX             202
#define IDC_CLASS_GENERAL_CATEGORY_COMBO 203
#define IDC_EDIT_CURRENT_DC             203
#define IDS_WARNING_DEFUNCT_SET         203
#define IDC_CLASS_GENERAL_DISPLAYABLE_CHECK 204
#define IDS_ERR_EDIT_GC                 204
#define IDC_RADIO_ANY                   204
#define IDC_CLASS_GENERAL_SYSCLASS_STATIC 205
#define IDS_ERR_CREATE_MINMAX           205
#define IDC_RADIO_SPECIFY               205
#define IDC_CLASS_REL_NAME_STATIC       206
#define IDS_ERR_EDIT_CATEGORY           206
#define IDC_EDIT_DC                     206
#define IDC_CLASS_REL_SYSCLASS_STATIC   207
#define IDS_MENU_RETARGET               207
#define IDC_EDIT_CURRENT_FSMO_DC        207
#define IDS_STATUS_RETARGET             208
#define IDC_CHANGE_FSMO                 208
#define IDC_ATTRIB_GENERAL_NAME_STATIC  209
#define IDS_MENU_EDIT_FSMO              209
#define IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT 210
#define IDS_STATUS_EDIT_FSMO            210
#define IDC_STATIC_FSMO_STATUS          210
#define IDS_WARNING_CHANGE_FOCUS        211
#define IDS_CHANGE_FSMO_CONFIRMATION    212
#define IDS_CHANGE_FSMO_SUCCESS         214
#define IDC_ATTRIB_GENERAL_SYSCLASS_STATIC 215
#define IDS_ERROR_CHANGE_FSMO_OWNER     215
#define IDD_CHANGE_DC                   216
#define IDS_MENU_SECURITY               216
#define IDD_EDIT_FSMO                   217
#define IDS_STATUS_SECURITY             217
#define IDC_ATTRIB_GENERAL_VALUE_STATIC 218
#define IDS_ERR_EDIT_DEFUNCT_SET        219
#define IDS_ERR_EDIT_DEFUNCT_REMOVE     220
#define IDI_ATTRIBUTE                   221
#define IDS_WARNING_DEFUNCT             221
#define IDC_ATTRIB_GENERAL_SYNTAX_EDIT  222
#define IDS_DEFAULT_SECURITY            222
#define IDC_ATTRIB_GENERAL_MIN_EDIT     223
#define IDS_DELETE_CLASS_PROMPT         223
#define IDI_CLASS                       224
#define IDS_DELETE_ATTR_PROMPT          224
#define IDC_ATTRIB_GENERAL_MAX_EDIT     225
#define IDI_GENERIC                     226
#define IDC_ATTRIB_GENERAL_OID_EDIT     226
#define IDC_CLASS_GENERAL_OID_EDIT      227
#define IDI_FOLDER_CLOSED               228
#define IDC_CREATE_ATTRIB_OID           228
#define IDC_CREATE_ATTRIB_CN            229
#define IDC_CREATE_ATTRIB_SYNTAX        230
#define IDB_CLASS                       231
#define IDD_CLASS_RELATIONSHIP          232
#define IDC_CREATE_ATTRIB_LDN           232
#define IDD_ATTRIB_GENERAL              233
#define IDC_CLASS_REL_PARENT_EDIT       233
#define IDC_CLASS_GENERAL_LDN           234
#define IDC_ATTRIB_GENERAL_LDN          235
#define IDD_CREATE_ATTRIBUTE            236
#define IDC_CREATE_ATTRIB_MIN           236
#define IDC_CREATE_ATTRIB_MAX           237
#define IDD_CREATE_CLASS_GENERAL        237
#define IDC_CREATE_CLASS_CN             238
#define IDC_CREATE_CLASS_LDN            239
#define IDC_CREATE_CLASS_OID            240
#define IDC_CREATE_CLASS_PARENT         241
#define IDC_CREATE_CLASS_TYPE           242
#define IDD_CLASS_ATTRIBUTES            243
#define IDB_CLASS_SMALL                 243
#define IDD_SCHEMA_SELECT               244
#define IDC_SCHEMA_LIST                 246
#define IDC_CATEGORY_EDIT               247
#define IDD_CREATE_WARN                 248
#define IDC_ATTRIB_GENERAL_REPLICATED   254
#define IDC_ATTRIB_GENERAL_ANR_CHECK    255
#define IDC_CATEGORY_CHANGE             256
#define IDC_ATTRIB_GENERAL_CPYATTR_CHECK 256
#define IDC_STATIC_MESSAGE              258
#define IDC_OPTIONAL_ADD                258
#define IDC_MANDATORY_LIST              259
#define IDC_OPTIONAL_LIST               260
#define IDC_MANDATORY_REMOVE            261
#define IDC_OPTIONAL_REMOVE             262
#define IDC_CREATE_ATTRIBUTE_PROMPT_STATIC 264
#define IDC_STATIC_FSMO_NOTE            265
#define IDC_DESCRIPTION_EDIT            266
#define IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK 272
#define IDD_MSGBOX_OK_MOREINFO          426
#define IDD_CREATE_CLASS_ATTRIBUTES     427
#define IDC_CLASS_REL_AUX_ADD           1009
#define IDC_CLASS_REL_AUX_REMOVE        1010
#define IDC_CLASS_REL_SUPER_ADD         1011
#define IDC_CLASS_REL_SUPER_REMOVE      1012
#define IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK 1012
#define IDC_CLASS_REL_SUPER_CLASSES     1024
#define IDC_CLASS_REL_AUX_CLASSES       1025
#define IDC_CREATE_ATTRIB_VALUED        1026
#define IDC_ATTRIB_GENERAL_DEACTIVATE   1026
#define IDC_CLASS_DEACTIVATE            1026
#define IDC_ATTRIB_GENERAL_INDEX_CHECK  1027
#define IDC_STATIC_SYSTEMONLY_AUXILIARY 1028
#define IDC_STATIC_SYSTEMONLY_SUPERIOR  1029
#define IDC_CLASS_MMB_OPTIONAL_ADD      1030
#define IDC_CLASS_MMB_OPTIONAL_REMOVE   1031
#define IDC_MANDATORY_ADD               1031
#define IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES 1034
#define IDC_CLASS_MMB_MANDATORY_ATTRIBUTES 1035
#define IDC_CLASS_MMB_SYSCLASS_STATIC   1038
#define IDC_CLASS_MMB_NAME_STATIC       1039
#define IDS_HTMLHELP_NAME               1040
#define IDS_MENU_NEW_CLASS              1041
#define IDS_MENU_NEW_ATTRIBUTE          1042
#define IDS_ERR_CANT_RETARGET           1043
#define IDS_MENU_VIEW_DEFUNCT_OBJECTS   1044
#define IDS_STATUS_VIEW_DEFUNCT_OBJECTS 1045
#define IDS_NEW_CLASS_PROP_SHEET_TITLE  1060
#define IDS_MUST_ENTER_OID              1062
#define IDS_MUST_ENTER_CN               1063
#define IDS_UNKNOWN_ERROR_MESSAGE       1064
#define IDS_SCHEMA_NOT_FULLY_LOADED     1100
#define IDS_OID_FORMAT_INVALID          2000
#define IDS_OID_CONTAINS_NON_DIGITS     2001
#define IDS_OID_CONTAINS_CONSECUTIVE_DOTS 2002
#define IDS_OID_MUST_START_WITH_0_1_2   2003
#define IDS_OID_0_1_MUST_BE_0_TO_39     2004
#define IDS_OID_MUST_HAVE_TWO_NUMBERS   2005
#define IDS_OID_CANNOT_END_WITH_DOT     2006
#define IDS_LDAPDISPLAYNAME_FORMAT_ERROR 2007
#define IDS_OID_MUST_NOT_BE_EMPTY        2008
#define IDI_CREATE_WARN                 32515
#define IDS_SYNTAX_CASE_STR             273


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        252
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         274
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\relation.cpp ===
//
// relation.cpp : Implementation of ClassRelationshipPage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(relation.cpp)")

#include "compdata.h"
#include "schmutil.h"

#include "relation.h"
#include "select.h"



const CDialogControlsInfo ctrls[] =
{
    { IDC_CLASS_REL_AUX_CLASSES,    g_AuxiliaryClass,   FALSE },
    { IDC_CLASS_REL_AUX_ADD,        g_AuxiliaryClass,   FALSE },
    { IDC_CLASS_REL_SUPER_CLASSES,  g_Superiors,        FALSE },
    { IDC_CLASS_REL_SUPER_ADD,      g_Superiors,        FALSE },
} ;


const DWORD ClassRelationshipPage::help_map[] =
{
    IDI_CLASS,                          NO_HELP,
    IDC_CLASS_REL_NAME_STATIC,          NO_HELP,
    IDC_CLASS_REL_PARENT_EDIT,          IDH_CLASS_REL_PARENT_EDIT,
    IDC_CLASS_REL_AUX_CLASSES,          IDH_CLASS_REL_AUX_CLASSES,
    IDC_STATIC_SYSTEMONLY_AUXILIARY,    NO_HELP,
    IDC_CLASS_REL_AUX_ADD,              IDH_CLASS_REL_AUX_ADD,
    IDC_CLASS_REL_AUX_REMOVE,           IDH_CLASS_REL_AUX_REMOVE,
    IDC_CLASS_REL_SUPER_CLASSES,        IDH_CLASS_REL_SUPER_CLASSES,
    IDC_STATIC_SYSTEMONLY_SUPERIOR,     NO_HELP,
    IDC_CLASS_REL_SUPER_ADD,            IDH_CLASS_REL_SUPER_ADD,
    IDC_CLASS_REL_SUPER_REMOVE,         IDH_CLASS_REL_SUPER_REMOVE,
    IDC_CLASS_REL_SYSCLASS_STATIC,      NO_HELP,
    0,0
};


ClassRelationshipPage::ClassRelationshipPage(
    ComponentData *pScope,
    LPDATAOBJECT lpDataObject ) :
        CPropertyPageAutoDelete(ClassRelationshipPage::IDD)
        , m_pIADsObject( NULL )
        , fSystemClass( FALSE )
        , m_pSchemaObject( NULL )
        , m_pScopeControl( pScope )
        , m_lpScopeDataObj( lpDataObject )
{
    ASSERT( NULL != m_pScopeControl );
    ASSERT( NULL != lpDataObject );
}

ClassRelationshipPage::~ClassRelationshipPage()
{
    if (NULL != m_pIADsObject)
            m_pIADsObject->Release();
    if (NULL != m_pSchemaObject) {
        m_pScopeControl->g_SchemaCache.ReleaseRef( m_pSchemaObject );
    }
}

void
ClassRelationshipPage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.
    //

    m_pCookie = &CookieRef;
    return;

}

BOOL
ClassRelationshipPage::OnInitDialog()
{
    HRESULT hr = S_OK;
    ASSERT( NULL == m_pIADsObject && m_szAdsPath.IsEmpty() );

    //
    // Get the schema cache object and the actual ADS object.
    //

    m_pSchemaObject = m_pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                        m_pCookie->strSchemaObject,
                        SCHMMGMT_CLASS );

    if ( m_pSchemaObject ) {

        m_pScopeControl->GetSchemaObjectPath( m_pSchemaObject->commonName, m_szAdsPath );

        if ( !m_szAdsPath.IsEmpty() ) {

           hr = SchemaOpenObject( (LPWSTR)(LPCWSTR)m_szAdsPath,
                              IID_IADs,
                              (void **)&m_pIADsObject );

           ASSERT( SUCCEEDED(hr) );
        }

    }

    //
    // If we have no ADS object, we should error out!
    //

    if ( !m_pIADsObject ) {
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );
                ASSERT(FALSE);
        return TRUE;
    }

    //
    // get the current values.
    //

    VARIANT AdsResult;
    VariantInit( &AdsResult );

    //
    // ObjectName
    //

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                          &AdsResult );

    if ( SUCCEEDED( hr ) ) {
      ASSERT( AdsResult.vt == VT_BSTR );
      ObjectName = AdsResult.bstrVal;
      VariantClear( &AdsResult );
    }

    //
    // Parent Class.
    //

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SubclassOf),
                          &AdsResult );

    if ( SUCCEEDED( hr ) ) {

      ASSERT( AdsResult.vt == VT_BSTR );
      ParentClass = AdsResult.bstrVal;
      VariantClear( &AdsResult );
    }

    // NTRAID#NTBUG9-460503,460511-2001/09/10-lucios
    // Replaced SysClass Computation by Making the window visible

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                           &AdsResult );

    if ( SUCCEEDED( hr ) ) {
        ASSERT( AdsResult.vt == VT_BOOL );
        fSystemClass = AdsResult.boolVal;
        if ( fSystemClass ) {
            ASSERT(GetDlgItem( IDC_CLASS_REL_SYSCLASS_STATIC ) != NULL);
            GetDlgItem( IDC_CLASS_REL_SYSCLASS_STATIC )->ShowWindow( SW_SHOW );
        } 
        VariantClear( &AdsResult );
    }

    //
    // Determine the auxiliary classes
    //

    VARIANT varClasses;
    VariantInit( &varClasses );

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_AuxiliaryClass), &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    if( SUCCEEDED(hr) )
    {
      hr = VariantToStringList( varClasses, strlistAuxiliary );
      ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );

    hr = m_pIADsObject->GetEx( CComBSTR(g_SystemAuxiliaryClass), &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    if( SUCCEEDED(hr) )
    {
      hr = VariantToStringList( varClasses, strlistSystemAuxiliary );
      ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );

    //
    // Determine the superior classes
    //

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_Superiors), &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    
    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varClasses, strlistSuperior );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );
    
    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = m_pIADsObject->GetEx( CComBSTR(g_SystemSuperiors), &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    
    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varClasses, strlistSystemSuperior );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );


    hr = DissableReadOnlyAttributes( this, m_pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
    // NTRAID#NTBUG9-503619-2002/05/15-lucios
    hr = S_OK;


    // This calls must be done before DDX binding
    m_listboxAuxiliary.InitType( m_pScopeControl,
                                 SELECT_AUX_CLASSES,
                                 IDC_CLASS_REL_AUX_REMOVE,
                                 &strlistSystemAuxiliary,
                                 IDC_STATIC_SYSTEMONLY_AUXILIARY
                               );

    m_listboxSuperior.InitType(  m_pScopeControl,
                                 SELECT_CLASSES,
                                 IDC_CLASS_REL_SUPER_REMOVE,
                                 &strlistSystemSuperior,
                                 IDC_STATIC_SYSTEMONLY_SUPERIOR
                              );

    CPropertyPage::OnInitDialog();

    return TRUE;
}



BOOL
ClassRelationshipPage::OnSetActive()
{
   // always enable the Apply button
   SetModified(TRUE);

   return TRUE;
}



void
ClassRelationshipPage::DoDataExchange(
    CDataExchange *pDX
) {

        HRESULT hr = S_OK;

    CPropertyPage::DoDataExchange( pDX );

        //{{AFX_DATA_MAP(ClassRelationshipPage)
        DDX_Control(pDX, IDC_CLASS_REL_PARENT_EDIT, m_staticParent );
        DDX_Control(pDX, IDC_CLASS_REL_AUX_CLASSES, m_listboxAuxiliary);
        DDX_Control(pDX, IDC_CLASS_REL_SUPER_CLASSES, m_listboxSuperior);
    DDX_Text( pDX, IDC_CLASS_REL_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_CLASS_REL_PARENT_EDIT, ParentClass );
        //}}AFX_DATA_MAP


    if ( !pDX->m_bSaveAndValidate ) {

        //
        // Fill the auxiliary classes list box.
        //

                m_listboxAuxiliary.ResetContent();
        hr = InsertEditItems( m_listboxAuxiliary, strlistAuxiliary );
                ASSERT( SUCCEEDED(hr) );
        hr = InsertEditItems( m_listboxAuxiliary, strlistSystemAuxiliary );
                ASSERT( SUCCEEDED(hr) );

        //
        // Fill the possible superiors list box.
        //

                m_listboxSuperior.ResetContent();
        hr = InsertEditItems( m_listboxSuperior, strlistSuperior );
                ASSERT( SUCCEEDED(hr) );
        hr = InsertEditItems( m_listboxSuperior, strlistSystemSuperior );
                ASSERT( SUCCEEDED(hr) );

        m_listboxAuxiliary.OnSelChange();
        m_listboxSuperior.OnSelChange();

    } else {

        //
        // All changes that we save are tied to button control routines.
        //

                strlistAuxiliary.RemoveAll();
                hr = RetrieveEditItemsWithExclusions(
                        m_listboxAuxiliary,
                        strlistAuxiliary,
                        &strlistSystemAuxiliary
                        );
                ASSERT( SUCCEEDED(hr) );

                strlistSuperior.RemoveAll();
                hr = RetrieveEditItemsWithExclusions(
                        m_listboxSuperior,
                        strlistSuperior,
                        &strlistSystemSuperior
                        );
                ASSERT( SUCCEEDED(hr) );
    }
}

BEGIN_MESSAGE_MAP(ClassRelationshipPage, CPropertyPage)
        ON_BN_CLICKED(IDC_CLASS_REL_AUX_ADD,       OnButtonAuxiliaryClassAdd)
        ON_BN_CLICKED(IDC_CLASS_REL_AUX_REMOVE,    OnButtonAuxiliaryClassRemove)
        ON_BN_CLICKED(IDC_CLASS_REL_SUPER_ADD,     OnButtonSuperiorClassAdd)
        ON_BN_CLICKED(IDC_CLASS_REL_SUPER_REMOVE,  OnButtonSuperiorClassRemove)
        ON_LBN_SELCHANGE(IDC_CLASS_REL_AUX_CLASSES, OnAuxiliarySelChange)
        ON_LBN_SELCHANGE(IDC_CLASS_REL_SUPER_CLASSES, OnSuperiorSelChange)
        ON_MESSAGE(WM_HELP,                        OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU,                 OnContextHelp)
END_MESSAGE_MAP()


BOOL
ClassRelationshipPage::OnApply(
)
//
// Revisions:
// CoryWest - 10/1/97 - Changes new additions to be listed by oid.
//                      Add cache freshening to improve performance.
//
{
    ASSERT( NULL != m_pIADsObject);

    HRESULT hr = S_OK;
    HRESULT flush_result;
    ListEntry *pNewList = NULL;
    BOOL fApplyAbort    = FALSE;  // stop later saves
    BOOL fApplyFailed   = FALSE;  // should not close the box

    if ( m_listboxAuxiliary.IsModified() )
    {
        //
        // Update the auxiliary classes
        //

        VARIANT AdsValue;
        VariantInit( &AdsValue );

        hr = StringListToVariant( AdsValue, strlistAuxiliary );
        // NTRAID#NTBUG9-543624-2002/02/15-dantra-Result of StringListToVariant being ignored resulting in call to IADs::PutEx with incorrect data

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        if( SUCCEEDED( hr ) ) hr = m_pIADsObject->PutEx( ADS_PROPERTY_UPDATE, CComBSTR(g_AuxiliaryClass), AdsValue