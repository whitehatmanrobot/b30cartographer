 is unknown.
// This is in posttransformed parent time.
STDMETHODIMP
CTIMENode::get_endParentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_endParentTime()",
              this));

    CHECK_RETURN_NULL(d);
    
    *d = GetEndParentTime();
    
    return S_OK;
}

// This is the current simple time of the node.
STDMETHODIMP
CTIMENode::get_currSimpleTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSimpleTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = CalcCurrSimpleTime();
    }
    
    return S_OK;
}

// This is the number of times the node has repeated
STDMETHODIMP
CTIMENode::get_currRepeatCount(LONG * l)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currRepeatCount()",
              this));

    CHECK_RETURN_NULL(l);

    *l = 0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *l = m_lCurrRepeatCount;
    }
    
    return S_OK;
}

// This is the current segment time of the node.
STDMETHODIMP
CTIMENode::get_currSegmentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSegmentTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = GetCurrSegmentTime();
    }

    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currActiveTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currActiveTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = CalcElapsedActiveTime();
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currSegmentDur(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSegmentDur()",
              this));

    CHECK_RETURN_NULL(d);

    *d = CalcCurrSegmentDur();
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currImplicitDur(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currImplicitDur()",
              this));

    CHECK_RETURN_NULL(d);

    *d = TIME_INFINITE;
    
    if (GetImplicitDur() != TE_UNDEFINED_VALUE)
    {
        *d = GetImplicitDur();
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currSimpleDur(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSimpleDur()",
              this));

    CHECK_RETURN_NULL(d);

    *d = CalcCurrSimpleDur();
    
    return S_OK;
}

STDMETHODIMP
CTIMENode::get_currProgress(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currProgress()",
              this));

    CHECK_RETURN_NULL(d);

    *d = 0.0;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *d = CalcCurrSimpleTime() / CalcCurrSimpleDur();
    }
    
    return S_OK;
}

// This returns the current speed
STDMETHODIMP
CTIMENode::get_currSpeed(float * speed)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currSpeed()",
              this));

    CHECK_RETURN_NULL(speed);
    float fltRet = GetCurrRate();
    
    if (TEIsBackward(CalcSimpleDirection()))
    {
        fltRet *= -1.0f;
    }
    
    *speed = fltRet;

    return S_OK;
}

// This is the total time during which the element is active.
// This does not include fill time which extends past the active
// duration.
STDMETHODIMP
CTIMENode::get_activeDur(double * dbl)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_activeDur()",
              this));

    CHECK_RETURN_NULL(dbl);

    *dbl = CalcEffectiveActiveDur();
    
    return S_OK;
}


// This is the parent's time when the last tick occurred (when it
// was currTime)
STDMETHODIMP
CTIMENode::get_currParentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_currParentTime()",
              this));

    CHECK_RETURN_NULL(d);
    *d = GetCurrParentTime();
    
    return S_OK;
}


// This will return whether the node is active.  This will be
// false if the node is in the fill period
STDMETHODIMP
CTIMENode::get_isActive(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isActive()",
              this));

    CHECK_RETURN_NULL(b);

    *b = VARIANT_FALSE;

    if (CalcIsActive() && !CalcIsDisabled())
    {
        *b = VARIANT_TRUE;
    }
    
    return S_OK;
}

// This will return true if the node is active or in the fill period
STDMETHODIMP
CTIMENode::get_isOn(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isOn()",
              this));

    CHECK_RETURN_NULL(b);
    *b = VARIANT_FALSE;

    if (CalcIsOn() && !CalcIsDisabled())
    {
        *b = VARIANT_TRUE;
    }
    
    return S_OK;
}


// This will return whether node itself has been paused explicitly
STDMETHODIMP
CTIMENode::get_isPaused(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isPaused()",
              this));

    CHECK_RETURN_NULL(b);

    *b = GetIsPaused()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return whether node itself has been paused explicitly
STDMETHODIMP
CTIMENode::get_isCurrPaused(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isCurrPaused()",
              this));

    CHECK_RETURN_NULL(b);

    *b = CalcIsPaused()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return whether node itself has been disabled explicitly
STDMETHODIMP
CTIMENode::get_isDisabled(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isDisabled()",
              this));

    CHECK_RETURN_NULL(b);

    *b = GetIsDisabled()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return whether node itself has been disabled explicitly
STDMETHODIMP
CTIMENode::get_isCurrDisabled(VARIANT_BOOL * b)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_isCurrDisabled()",
              this));

    CHECK_RETURN_NULL(b);

    *b = CalcIsDisabled()?VARIANT_TRUE:VARIANT_FALSE;
    
    return S_OK;
}

// This will return the detailed state flags
STDMETHODIMP
CTIMENode::get_stateFlags(TE_STATE * lFlags)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_stateFlags()",
              this));

    CHECK_RETURN_NULL(lFlags);

    if (!CalcIsActive() || CalcIsDisabled())
    {
        *lFlags = TE_STATE_INACTIVE;
    }
    else if (CalcIsPaused())
    {
        *lFlags = TE_STATE_PAUSED;
    }
    else
    {
        *lFlags = TE_STATE_ACTIVE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\tick.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: tick.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagTick, "TIME: Engine", "Tick");

//+-----------------------------------------------------------------------
//
//  Function:  CheckTickBounds
//
//  Overview:  Checks the bounds of the tick to see if we need to do
//             anything
//
//  Arguments: The time node and the new parent time
//
//  Returns:   true if we need to perform the tick or false otherwise
//
//------------------------------------------------------------------------

bool
CheckTickBounds(CTIMENode & tn,
                double & dblLastParentTime,
                double & dblNextParentTime,
                bool & bNeedBegin,
                bool & bNeedEnd)
{
    TraceTag((tagTick,
              "CheckTickBounds(%ls,%p,%g,%g)",
              tn.GetID(),
              &tn,
              dblLastParentTime,
              dblNextParentTime));

    bool bRet = true;
    double dblEndParentTime = tn.GetEndParentTime();
    double dblBeginParentTime = tn.GetBeginParentTime();
    bool bFirstTick = tn.IsFirstTick();
    bool bDeferredActive = tn.IsDeferredActive();
    
    bNeedBegin = bNeedEnd = false;
    
    if (tn.GetParentDirection() == TED_Forward)
    {
        Assert(dblLastParentTime <= dblNextParentTime);
        
        if (bDeferredActive &&
            bFirstTick &&
            dblNextParentTime == dblBeginParentTime)
        {
            bRet = false;
            goto done;
        }
        else if (dblLastParentTime >= dblEndParentTime ||
                 dblNextParentTime < dblBeginParentTime)
        {
            // Handle the case where the last tick was on the end
            // boundary point
            if (dblLastParentTime == dblEndParentTime)
            {
                // First handle the 0 active duration
                if (dblEndParentTime == dblBeginParentTime)
                {
                    if (bFirstTick || tn.IsActive())
                    {
                        bNeedBegin = bFirstTick;
                        bNeedEnd = true;

                        dblNextParentTime = dblEndParentTime;
                    }
                    else
                    {
                        bRet = false;
                    }
                }
                // Now handle where we started at the end point
                else if (bFirstTick &&
                         dblNextParentTime == dblEndParentTime)
                {
                    bNeedBegin = true;
                    bNeedEnd = true;
                }
                // In case we reached the end point during a recalc
                // (like seek)  Let's make sure we always fire the end.
                else if (tn.IsActive())
                {
                    bNeedEnd = true;
                    dblNextParentTime = dblEndParentTime;
                }
                else
                {
                    bRet = false;
                }
            }
            else
            {
                bRet = false;
            }
        }
        else
        {
            // Need to make sure we set the out params correctly
            if (dblLastParentTime < dblBeginParentTime)
            {
                dblLastParentTime = dblBeginParentTime;
                bNeedBegin = true;
            }

            if (dblNextParentTime >= dblEndParentTime)
            {
                dblNextParentTime = dblEndParentTime;
                bNeedEnd = true;
            }
        }
    }
    else
    {
        if (bDeferredActive &&
            bFirstTick &&
            dblNextParentTime == dblEndParentTime)
        {
            bRet = false;
            goto done;
        }
        else if (dblLastParentTime <= dblBeginParentTime ||
                 dblNextParentTime > dblEndParentTime)
        {
            if (dblLastParentTime == dblBeginParentTime)
            {
                // First handle the 0 active duration
                if (dblEndParentTime == dblBeginParentTime)
                {
                    if (bFirstTick || tn.IsActive())
                    {
                        bNeedBegin = bFirstTick;
                        bNeedEnd = true;

                        dblNextParentTime = dblBeginParentTime;
                    }
                    else
                    {
                        bRet = false;
                    }
                }
                // Now handle where we started at the end point
                else if (bFirstTick &&
                         dblNextParentTime == dblBeginParentTime)
                {
                    bNeedBegin = true;
                    bNeedEnd = true;
                }
                // In case we reached the end point during a recalc
                // (like seek)  Let's make sure we always fire the end.
                else if (tn.IsActive())
                {
                    bNeedEnd = true;
                    dblNextParentTime = dblBeginParentTime;
                }
                else
                {
                    bRet = false;
                }
            }
            else
            {
                bRet = false;
            }
        }
        else
        {
            // Need to make sure we set the out params correctly
            if (dblLastParentTime > dblEndParentTime)
            {
                dblLastParentTime = dblEndParentTime;
                bNeedBegin = true;
            }

            if (dblNextParentTime <= dblBeginParentTime)
            {
                dblNextParentTime = dblBeginParentTime;
                bNeedEnd = true;
            }
        }
    }

    if (bFirstTick)
    {
        bNeedBegin = true;
    }
    
  done:
    return bRet;
}

double
CalcNewTickActiveTime(CTIMENode & tn,
                      double dblLastParentTime,
                      double dblNewParentTime)
{
    TraceTag((tagTick,
              "CalcNewTickActiveTime(%ls,%p,%g,%g)",
              tn.GetID(),
              &tn,
              dblLastParentTime,
              dblNewParentTime));

    Assert(dblLastParentTime >= tn.GetBeginParentTime() &&
           dblLastParentTime <= tn.GetEndParentTime());
    Assert(dblNewParentTime >= tn.GetBeginParentTime() &&
           dblNewParentTime <= tn.GetEndParentTime());

    double dblDelta = dblNewParentTime - dblLastParentTime;

    // How figure out if we need to reverse it and change the sign
    if (tn.GetDirection() == TED_Backward)
    {
        dblDelta *= -1;
    }

    // Check to make sure we are moving in the correct direction
    Assert((tn.CalcActiveDirection() == TED_Forward) ||
           (dblDelta <= 0.0));
    Assert((tn.CalcActiveDirection() == TED_Backward) ||
           (dblDelta >= 0.0));
    
    double dblNewActiveTime;

    // Now get the elapsed local time
    dblNewActiveTime = tn.CalcElapsedLocalTime();
    
    // Add the delta
    dblNewActiveTime += dblDelta;

    // Now transform it back
    dblNewActiveTime = tn.ApplyActiveTimeTransform(dblNewActiveTime);

    // Now clamp it
    dblNewActiveTime = Clamp(0.0,
                             dblNewActiveTime,
                             tn.CalcEffectiveActiveDur());
    
    return dblNewActiveTime;
}

void
CTIMENode::UpdateNextTickBounds(CEventList * l,
                                double dblBeginTime,
                                double dblParentTime)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::UpdateTickBounds(%p, %g, %g)",
              this,
              l,
              dblBeginTime,
              dblParentTime));

    bool bPrevPaused = CalcIsPaused();

    // Update before we calcruntimestate
    m_bIsPaused = false;

    // See if we were paused but no longer are paused (we do not have
    // to worry about the other case since we can never transition to
    // paused when we are reset
    Assert(bPrevPaused || !CalcIsPaused());
    
    if (bPrevPaused && !CalcIsPaused())
    {
        TickEvent(l, TE_EVENT_RESUME, 0);
    }

    if (IsActive() && !m_bFirstTick)
    {
        TickEvent(l, TE_EVENT_END, 0);
    }
                
    // Before updating and propagating the begin point we need to
    // reset the end points to point to infinity.  This is done for
    // the case where an element begins and ends with us and so sees
    // the previous end and can cause trouble.  Infinity is as good an
    // indeterminate as we can get
    
    // Do not propagate the ends but just update them
    UpdateEndTime(l, TIME_INFINITE, false);
    UpdateEndSyncTime(TIME_INFINITE);
    UpdateLastEndSyncTime(l, TIME_INFINITE, false);

    // Now update the begin and propagate the change
    UpdateBeginTime(l, dblBeginTime, true);

    // Update before we calc the end
    
    m_bFirstTick = true;

    // We need to reset the end times so that the implicit duration
    // calcbacks do not look at the end times inclusively
    // This happens during the reset call and we used to use first
    // tick in the end calc but this messes up if we have a deferred
    // active tick and an endElement call comes in
    m_saEndList.Reset();

    double dblEnd;
    double dblEndSync;
        
    CalcEndTime(dblBeginTime,
                false,
                dblBeginTime,
                0.0,
                0,
                0.0,
                dblEnd,
                dblEndSync);
        
    UpdateEndTime(l, dblEnd, true);
    UpdateEndSyncTime(dblEndSync);

    double dblLastEndSyncTime;
    dblLastEndSyncTime = CalcLastEndSyncTime();
    
    UpdateLastEndSyncTime(l, dblLastEndSyncTime, true);

    CalcRuntimeState(l, dblParentTime, 0.0);

    // Now go through our children
    ResetChildren(l, true);
}

void
CTIMENode::Tick(CEventList * l,
                double dblNewParentTime,
                bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::Tick(lt:%g, ct:%g, dir:%s, ft:%d, nb:%d)",
              this,
              GetID(),
              m_dblCurrParentTime,
              dblNewParentTime,
              DirectionString(GetDirection()),
              m_bFirstTick,
              bNeedBegin));

    bool bNeedDefer = (IsSyncCueing() ||
                       GetContainer().ContainerIsDeferredActive());
    
    Assert(!IsDeferredActive() || IsFirstTick());
    
    if (m_bDeferredActive != bNeedDefer)
    {
        // If we have already fired a begin event do not attempt to
        // change to deferred
        if (!bNeedDefer || IsFirstTick())
        {
            PropNotify(l,
                       (TE_PROPERTY_TIME |
                        TE_PROPERTY_REPEATCOUNT |
                        TE_PROPERTY_PROGRESS |
                        TE_PROPERTY_ISACTIVE |
                        TE_PROPERTY_ISON |
                        TE_PROPERTY_STATEFLAGS));
            
            // Update the deferred cueing mechanism
            m_bDeferredActive = bNeedDefer;
        }
    }
    
    m_bInTick = true;
    
    while (true) //lint !e716
    {
        // The reason it is done like this (rather than a pure
        // if/then/else) is that TickInactive does not set the active
        // flag so the next time through the loop will not go to the
        // correct branch.  Since the only time we do not complete is
        // when we become active the fall through case works.
        //
        // With the TickActivePeriod, the active flag is set to
        // inactive during the call so we can simply loop w/o a
        // problem.  We could clean this up a bit more but the
        // solution would be too inefficient.
        
        if (!IsActive())
        {
            if (!TickInactivePeriod(l, dblNewParentTime))
            {
                break;
            }

            // We need to force a begin
            bNeedBegin = true;
        }

        if (!TickInstance(l,
                          dblNewParentTime,
                          bNeedBegin))
        {
            break;
        }

        // Make sure to reset the sync times
        ResetSyncTimes();
    }
    
    IGNORE_HR(m_nbList.DispatchTick());

    // Ensure we are completely updated
    m_dblCurrParentTime = dblNewParentTime;

  done:
    // Always reset these values
    
    ResetSyncTimes();
    if (!IsDeferredActive())
    {
        m_bFirstTick = false;
    }
    
    m_bInTick = false;
    
    return;
}

bool
CTIMENode::TickInactivePeriod(CEventList * l,
                              double dblNewParentTime)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickInactivePeriod(%p, %g)",
              this,
              GetID(),
              l,
              dblNewParentTime));

    bool bRet;

    Assert(!IsActive());
    
    TEDirection dir = CalcActiveDirection();
    double dblNextBoundaryTime = GetNextBoundaryParentTime();
    
    if (dblNextBoundaryTime == TIME_INFINITE ||
        (dir == TED_Forward && dblNewParentTime < dblNextBoundaryTime) ||
        (dir == TED_Backward && dblNewParentTime > dblNextBoundaryTime))
    {
        // Indicate we should not continue ticking and update the
        // current parent time to the new parent time
        bRet = false;
        m_dblCurrParentTime = dblNewParentTime;
        goto done;
    }

    // When we are going forward we need to update the boundaries to
    // the next period
    if (dir == TED_Forward)
    {
        double dblBegin;
        CalcNextBeginTime(dblNextBoundaryTime,
                          true,
                          dblBegin);
        
        // Something went wrong and we cannot move backwards
        Assert(dblBegin >= dblNextBoundaryTime);
            
        UpdateNextTickBounds(l,
                             dblBegin,
                             dblNextBoundaryTime);
        UpdateNextBoundaryTime(dblBegin);

        if (dblBegin > dblNextBoundaryTime)
        {
            dblNextBoundaryTime = min(dblBegin, dblNewParentTime);
        }
    }
    else
    {
        // The boundaries in this case have already been updated so we
        // do not need to do anything

        // Indicate we need a first tick
        m_bFirstTick = true;
    }
    
    // Update the current time to the boundary time
    m_dblCurrParentTime = dblNextBoundaryTime;
    
    // Indicate there is more to do
    bRet = true;
  done:
    return bRet;
}

bool
CTIMENode::TickInstance(CEventList * l,
                        double dblNewParentTime,
                        bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickInstance(%p, %g, %d)",
              this,
              GetID(),
              l,
              dblNewParentTime,
              bNeedBegin));

    bool bRet;
    
    double dblLastParentTime = GetCurrParentTime();
    TEDirection dir = CalcActiveDirection();
    bool bNeedShiftUpdate = false;
    
    // This is the time the clock source expects to be at
    double dblAdjustedParentTime;
    
    // Figure out the next parent time to use
    if (TIME_INFINITE != GetSyncNewParentTime())
    {
        dblAdjustedParentTime = GetSyncNewParentTime();

        // Do not reset the sync time yet.  We need to do this in
        // tickactive since we need to get the sync active time 
    }
    else if (GetIsPaused() || GetIsDisabled())
    {
        // Only check if we are paused explicitly.  If our parent has
        // been paused we expect them to handle all adjustments.  It
        // also may be the case that they still provide sync to the
        // clock source when paused so we need to handle all updates

        dblAdjustedParentTime = dblLastParentTime;

        RecalcEndTime(l,
                      dblLastParentTime,
                      dblNewParentTime,
                      true);
    }
    else
    {
        dblAdjustedParentTime = dblNewParentTime;
    }
    
    if (dblAdjustedParentTime != dblNewParentTime)
    {
        bNeedShiftUpdate = true;
    }
    
    if (!TickSingleInstance(l,
                            dblLastParentTime,
                            dblNewParentTime,
                            dblAdjustedParentTime,
                            bNeedBegin))
    {
        bRet = false;
        goto done;
    }
        
    Assert(!IsActive());
        
    // We should be at the end time of the instance
    Assert(GetCurrParentTime() == CalcActiveEndPoint());

    double dblBegin;

    if (GetRestart() != TE_RESTART_NEVER)
    {
        // Now see if there is another begin time to use
        CalcNextBeginTime(GetCurrParentTime(),
                          false,
                          dblBegin);
    }
    else
    {
        dblBegin = TIME_INFINITE;
    }
    
    if (dblBegin == TIME_INFINITE)
    {
        // Indicate that we are finished with all periods
        UpdateNextBoundaryTime(TIME_INFINITE);
        
        m_dblCurrParentTime = dblNewParentTime;
        
        bRet = false;
        goto done;
    }

    Assert((GetParentDirection() == TED_Forward && dblBegin >= GetCurrParentTime()) ||
           (GetParentDirection() == TED_Backward && dblBegin < GetCurrParentTime()));

    if (dir == TED_Forward)
    {
        // Indicate that the next boundary is the begin time
        UpdateNextBoundaryTime(dblBegin);
    }
    else
    {
        // Indicate a shift is not needed since we are causing the
        // update by changing the boundaries
        
        bNeedShiftUpdate = false;
        
        // Update the tick bounds passing the new begin time and the
        // current parent time
        UpdateNextTickBounds(l,
                             dblBegin,
                             GetCurrParentTime());

        // Indicate that the next tick bounds is the end time
        UpdateNextBoundaryTime(GetEndParentTime());
    }

    bRet = true;
  done:

    if (bNeedShiftUpdate)
    {
        // Fire a parent time shift event
        TickEventChildren(l, TE_EVENT_PARENT_TIMESHIFT, 0);
    }
    
    return bRet;
}

bool
CTIMENode::TickSingleInstance(CEventList * l,
                              double dblLastParentTime,
                              double dblNewParentTime,
                              double dblAdjustedParentTime,
                              bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickSingleInstance(%p, %g, %g, %g, %d)",
              this,
              GetID(),
              l,
              dblLastParentTime,
              dblNewParentTime,
              dblAdjustedParentTime,
              bNeedBegin));

    bool bRet = false;
    
    bool bTickNeedBegin;
    bool bTickNeedEnd;
    
    // This will check the bounds and ensure the bounds and flags are
    // set correctly
    // This takes the new parent time since the bounds are calculated
    // according to the true time
    if (!::CheckTickBounds(*this,
                           dblLastParentTime,
                           dblNewParentTime,
                           bTickNeedBegin,
                           bTickNeedEnd))
    {
        goto done;
    }

    Assert(dblLastParentTime >= GetBeginParentTime() &&
           dblLastParentTime <= GetEndParentTime());
    Assert(dblNewParentTime >= GetBeginParentTime() &&
           dblNewParentTime <= GetEndParentTime());

    // We need to clamp this since it may be outside our range and we
    // only clamped the new time in the CheckTickBounds call.
    
    dblAdjustedParentTime = Clamp(GetBeginParentTime(),
                                  dblAdjustedParentTime,
                                  GetEndParentTime());
                              
    // We need to calc the new active time
    // Start with the elapsed local time
    double dblNewActiveTime;

    if (TIME_INFINITE != GetSyncActiveTime())
    {
        Assert(TIME_INFINITE != GetSyncNewParentTime());
        
        dblNewActiveTime = GetSyncActiveTime();
    }
    else
    {
        // Need to use the next parent time so we calc the active time for
        // a clock source
        dblNewActiveTime = ::CalcNewTickActiveTime(*this,
                                                   dblLastParentTime,
                                                   dblAdjustedParentTime);
    }
    
    if (TickActive(l,
                   dblNewActiveTime,
                   bNeedBegin || bTickNeedBegin,
                   bTickNeedEnd))
    {
        bRet = true;
    }

    // Update to the new parent time
    m_dblCurrParentTime = dblNewParentTime;
    
    if (m_bNeedSegmentRecalc)
    {
        RecalcSegmentDurChange(l, false, true);

        Assert(!m_bNeedSegmentRecalc);
    }
    else if (bRet &&
             CalcActiveDirection() == TED_Forward &&
             dblNewParentTime != GetEndParentTime())
    {
        UpdateEndTime(l, dblNewParentTime, true);
        UpdateEndSyncTime(dblNewParentTime);

        double dblLastEndSyncTime;
        dblLastEndSyncTime = CalcLastEndSyncTime();
    
        UpdateLastEndSyncTime(l, dblLastEndSyncTime, true);
    }
    
  done:
    return bRet;
}

bool
CTIMENode::TickActive(CEventList * l,
                      double dblNewActiveTime,
                      bool bNeedBegin,
                      bool bNeedEnd)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickActive(lt:%g, nt%g, nb:%d, ne:%d, dir%s)",
              this,
              GetID(),
              CalcElapsedActiveTime(),
              dblNewActiveTime,
              bNeedBegin,
              bNeedEnd,
              DirectionString(CalcActiveDirection())));

    if (bNeedBegin)
    {
        // This means that we just entered

        EventNotify(l,
                    CalcElapsedActiveTime(),
                    TE_EVENT_BEGIN);
    }
        
    PropNotify(l, TE_PROPERTY_TIME | TE_PROPERTY_PROGRESS);

    if (CalcActiveDirection() == TED_Forward)
    {
        if (TickActiveForward(l, dblNewActiveTime, bNeedBegin))
        {
            bNeedEnd = true;
        }
    }
    else
    {
        if (TickActiveBackward(l, dblNewActiveTime, bNeedBegin))
        {
            bNeedEnd = true;
        }
    }

    if (bNeedEnd)
    {
        TickEvent(l,
                  TE_EVENT_END,
                  0);
    }
        
  done:
    return bNeedEnd;
}
    
bool
CTIMENode::TickActiveForward(CEventList * l,
                             double dblNewActiveTime,
                             bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickActiveForward(lt:%g, nt%g, nb:%d)",
              this,
              GetID(),
              CalcElapsedActiveTime(),
              dblNewActiveTime,
              bNeedBegin));
    
    bool bRet = false;

    double dblSegmentBeginTime = GetElapsedActiveRepeatTime();
    double dblActiveDur = CalcEffectiveActiveDur();
    double dblSyncSegmentTime = TIME_INFINITE;

    if (GetSyncSegmentTime() != TIME_INFINITE &&
        GetSyncRepeatCount() == GetCurrRepeatCount() &&
        GetSyncSegmentTime() >= GetCurrSegmentTime())
    {
        dblSyncSegmentTime = GetSyncSegmentTime();
    }
    
    // Now reset the times
    ResetSyncTimes();

    for(;;)
    {
        double dblNewSegmentTime;

        if (dblSyncSegmentTime != TIME_INFINITE)
        {
            dblNewSegmentTime = dblSyncSegmentTime;
            dblSyncSegmentTime = TIME_INFINITE;
        }
        else
        {
            dblNewSegmentTime = dblNewActiveTime - dblSegmentBeginTime;
        }
        
        bool bSegmentEnded;
        
        // This needs to update segment time
        bSegmentEnded = TickSegmentForward(l,
                                           dblSegmentBeginTime,
                                           GetCurrSegmentTime(),
                                           dblNewSegmentTime,
                                           bNeedBegin);

        // Update to the next segment begin time
        dblSegmentBeginTime += GetCurrSegmentTime();
        
        // If the segment did not end or we are at the end of the
        // active duration then break
        
        if (!bSegmentEnded)
        {
            break;
        }
        
        if (dblSegmentBeginTime >= dblActiveDur ||
            m_lCurrRepeatCount + 1 >= CalcRepeatCount())
        {
            bRet = true;
            break;
        }
        
        // Fire the stop event on our children

        TickEventChildren(l,
                          TE_EVENT_END,
                          0);

        m_lCurrRepeatCount++;
        m_dblElapsedActiveRepeatTime = dblSegmentBeginTime;
        m_dblCurrSegmentTime = 0.0;
        
        Assert(m_lCurrRepeatCount < CalcRepeatCount());
            
        PropNotify(l, TE_PROPERTY_REPEATCOUNT);
        
        // Indicate we have just repeated
        EventNotify(l, dblSegmentBeginTime, TE_EVENT_REPEAT, m_lCurrRepeatCount);

        ResetChildren(l, true);
    }
    
  done:
    return bRet;
}

bool
CTIMENode::TickActiveBackward(CEventList * l,
                              double dblNewActiveTime,
                              bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickActiveBackward(lt:%g, nt%g, nb:%d)",
              this,
              GetID(),
              CalcElapsedActiveTime(),
              dblNewActiveTime,
              bNeedBegin));
    
    bool bRet = false;
    
    Assert(dblNewActiveTime >= 0.0);
    
    double dblSegmentBeginTime = GetElapsedActiveRepeatTime();
    double dblSyncSegmentTime = TIME_INFINITE;

    if (GetSyncSegmentTime() != TIME_INFINITE &&
        GetSyncRepeatCount() == GetCurrRepeatCount() &&
        GetSyncSegmentTime() <= GetCurrSegmentTime())
    {
        dblSyncSegmentTime = GetSyncSegmentTime();
    }
    
    // Now reset the times
    ResetSyncTimes();

    for(;;)
    {
        double dblNewSegmentTime;

        if (dblSyncSegmentTime != TIME_INFINITE)
        {
            dblNewSegmentTime = dblSyncSegmentTime;
            dblSyncSegmentTime = TIME_INFINITE;
        }
        else
        {
            dblNewSegmentTime = dblNewActiveTime - dblSegmentBeginTime;
        }
        
        bool bSegmentEnded;
        
        // This needs to update elapsed time and segment time
        bSegmentEnded = TickSegmentBackward(l,
                                            dblSegmentBeginTime,
                                            GetCurrSegmentTime(),
                                            dblNewSegmentTime,
                                            bNeedBegin);
        if (!bSegmentEnded ||
            dblSegmentBeginTime == 0.0)
        {
            break;
        }
        
        // We have reach the end of our current period so all
        // children must be stopped.
        
        // First fire the end event so they can pass it on
        // to the parent
        
        TickEventChildren(l,
                          TE_EVENT_END,
                          0);

        double dblSegmentDur;
        dblSegmentDur = CalcCurrSegmentDur();
        
        if (dblSegmentDur == TIME_INFINITE)
        {
            dblSegmentDur = dblSegmentBeginTime;
        }
        
        m_dblElapsedActiveRepeatTime = dblSegmentBeginTime - dblSegmentDur;

        if (m_dblElapsedActiveRepeatTime < 0.0)
        {
            m_dblElapsedActiveRepeatTime = 0.0;
        }

        m_lCurrRepeatCount--;
        m_dblCurrSegmentTime = dblSegmentDur;
        
        Assert(m_lCurrRepeatCount >= 0);
            
        PropNotify(l, TE_PROPERTY_REPEATCOUNT);

        // Indicate we have just repeated
        EventNotify(l, dblSegmentBeginTime, TE_EVENT_REPEAT, m_lCurrRepeatCount);

        ResetChildren(l, true);

        // We do this late so we can use the correct time in the
        // EventNotify all above
        dblSegmentBeginTime = m_dblElapsedActiveRepeatTime;
    }

  done:
    return bRet;
}

//+-----------------------------------------------------------------------
//
//  Function:  TickSegmentForward
//
//  Overview:  This will tick the segment forward.  It must update
//  segment time
//
//  Arguments: The time node and the new parent time
//
//  Returns:   true if we need to perform the tick or false otherwise
//
//------------------------------------------------------------------------


bool
CTIMENode::TickSegmentForward(CEventList * l,
                              double dblActiveSegmentBound,
                              double dblLastSegmentTime,
                              double dblNewSegmentTime,
                              bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickSegmentForward(tsb:%g, lt:%g, ct:%g, np:%d)",
              this,
              GetID(),
              dblActiveSegmentBound,
              dblLastSegmentTime,
              dblNewSegmentTime,
              bNeedBegin));

    bool bRet = false;

    Assert(CalcActiveDirection() == TED_Forward);
    Assert(dblLastSegmentTime >= 0.0);
    Assert(dblLastSegmentTime <= GetSegmentDur());
    Assert(dblNewSegmentTime >= 0.0);
    Assert(dblNewSegmentTime >= dblLastSegmentTime);

    // Make sure the new time is less than the segment duration so our
    // calculations become easier
    
    if (dblNewSegmentTime > GetSegmentDur())
    {
        dblNewSegmentTime = GetSegmentDur();
    }
    
    if (dblLastSegmentTime < GetSimpleDur())
    {
        double dblNewSimpleTime = min(dblNewSegmentTime,
                                      GetSimpleDur()); //lint !e666
        
        TickChildren(l,
                     dblNewSimpleTime,
                     bNeedBegin);

        // We need to update the segment time so that the direction
        // flag is queried by our children correctly
        m_dblCurrSegmentTime = dblNewSimpleTime;
    }

    if (GetAutoReverse() &&
        dblNewSegmentTime >= GetSimpleDur())
    {
        Assert(GetSimpleDur() != TIME_INFINITE);
        Assert(GetSegmentDur() != TIME_INFINITE);
        Assert(GetCurrSegmentTime() >= GetSimpleDur());
        
        // True is we either passed the boundary point this time or if
        // we were on the boundary and had a needplay
        bool bOnBoundary = ((dblLastSegmentTime < GetSimpleDur()) ||
                            ((dblLastSegmentTime == GetSimpleDur()) &&
                             bNeedBegin));
        
        // If we did not pass the segment time last time then this
        // time we need to fire an autoreverse event
        if (bOnBoundary)
        {
            // Tell our children to stop
            TickEventChildren(l,
                              TE_EVENT_END,
                              0);

            // Indicate we have just repeated
            EventNotify(l,
                        dblActiveSegmentBound + GetSimpleDur(),
                        TE_EVENT_AUTOREVERSE);

            ResetChildren(l, true);
        }

        TickChildren(l,
                     GetSegmentDur() - dblNewSegmentTime,
                     bNeedBegin || bOnBoundary);
    }

    // Do this after the child tick so endsync will work correctly

    {
        double dblSegmentDur = CalcCurrSegmentDur();
        
        // Make sure the new time is less than the segment duration so our
        // calculations become easier
    
        if (dblNewSegmentTime >= dblSegmentDur)
        {
            dblNewSegmentTime = dblSegmentDur;
            bRet = true;
        }
    }
    
    // Update our segment time
    m_dblCurrSegmentTime = dblNewSegmentTime;

  done:
    return bRet;
}

//+-----------------------------------------------------------------------
//
//  Function:  TickSegmentBackward
//
//  Overview:  This will tick the segment backwards.  It must update
//  segment time
//
//  Arguments: The time node and the new parent time
//
//  Returns:   true if we need to perform the tick or false otherwise
//
//------------------------------------------------------------------------

bool
CTIMENode::TickSegmentBackward(CEventList * l,
                               double dblActiveSegmentBound,
                               double dblLastSegmentTime,
                               double dblNewSegmentTime,
                               bool bNeedBegin)
{
    TraceTag((tagTick,
              "CTIMENode(%p,%ls)::TickSegmentBackward(tsb:%g, lt:%g, ct:%g, np:%d)",
              this,
              GetID(),
              dblActiveSegmentBound,
              dblLastSegmentTime,
              dblNewSegmentTime,
              bNeedBegin));

    bool bRet = false;
    
    Assert(CalcActiveDirection() == TED_Backward);
    Assert(dblLastSegmentTime >= 0.0);
    Assert(dblLastSegmentTime <= GetSegmentDur());
    Assert(dblNewSegmentTime <= GetSegmentDur());
    Assert(dblNewSegmentTime <= dblLastSegmentTime);

    // Make sure the new time is greater than 0 so our calculations
    // become easier
    
    if (dblNewSegmentTime <= 0.0)
    {
        dblNewSegmentTime = 0.0;
        bRet = true;
    }
    
    if (GetAutoReverse() &&
        dblLastSegmentTime > GetSimpleDur())
    {
        Assert(GetSimpleDur() != TIME_INFINITE);
        Assert(GetSegmentDur() != TIME_INFINITE);
        
        double dblNewMaxSegmentTime = max(dblNewSegmentTime, GetSimpleDur()); //lint !e666
        
        TickChildren(l,
                     GetSegmentDur() - dblNewMaxSegmentTime,
                     bNeedBegin);

        // We need to update the segment time so that the direction
        // flag is queried by our children correctly
        m_dblCurrSegmentTime = dblNewMaxSegmentTime;
        
        if (dblNewSegmentTime <= GetSimpleDur())
        {
            // Tell our children to stop
            TickEventChildren(l,
                              TE_EVENT_END,
                              0);

            // Indicate we have just repeated
            EventNotify(l,
                        dblActiveSegmentBound + GetSimpleDur(),
                        TE_EVENT_AUTOREVERSE);

            ResetChildren(l, true);
        }
    }
                
    if (dblNewSegmentTime <= GetSimpleDur())
    {
        // This should have been updated
        Assert(GetCurrSegmentTime() <= GetSimpleDur());
        Assert(dblNewSegmentTime <= GetCurrSegmentTime());

        TickChildren(l,
                     dblNewSegmentTime,
                     bNeedBegin);
    }

    // Update our segment time
    m_dblCurrSegmentTime = dblNewSegmentTime;

  done:
    return bRet;
}

void
CTIMENode::TickChildren(CEventList * l,
                        double dblNewSegmentTime,
                        bool bNeedPlay)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\sync.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: sync.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "NodeMgr.h"
#include "container.h"

DeclareTag(tagClockSync, "TIME: Engine", "CTIMENode Sync");
DeclareTag(tagWatchClockSync, "TIME: Engine", "Watch Sync");

//
// This is different from CalcParentTimeFromGlobalTime because it
// takes into account when a parent has reach its end point
// inclusively and returns TIME_INFINITE to indicate that a parent is
// ending
//

double
CalcSyncParentTimeFromGlobalTime(CTIMENode & tn,
                                 double dblGlobalTime)
{
    TraceTag((tagClockSync,
              "CalcParentTimeFromGlobalTime(%p, %ls, %g)",
              &tn,
              tn.GetID(),
              dblGlobalTime));

    double dblRet = dblGlobalTime;

    if (tn.GetParent() != NULL)
    {
        dblRet = CalcSyncParentTimeFromGlobalTime(*tn.GetParent(),
                                                  dblRet);
        if (dblRet >= tn.GetParent()->GetEndParentTime())
        {
            dblRet = TIME_INFINITE;
            goto done;
        }
        
        dblRet = tn.GetParent()->CalcActiveTimeFromParentTime(dblRet);
        if (dblRet == TIME_INFINITE)
        {
            goto done;
        }
        
        dblRet = tn.GetParent()->CalcSegmentTimeFromActiveTime(dblRet,
                                                               true);
        dblRet = tn.GetParent()->SegmentTimeToSimpleTime(dblRet);
    }
    
  done:
    return dblRet;
}

HRESULT
CTIMENode::OnBvrCB(CEventList * l,
                   double dblNextGlobalTime)
{
    TraceTag((tagClockSync,
              "CTIMENode(%p, %ls)::OnBvrCB(%#l, %g)",
              this,
              GetID(),
              l,
              dblNextGlobalTime));

    HRESULT hr;

    double dblNewSegmentTime;
    long lNewRepeatCount;
    bool bCueing;

    Assert(IsSyncMaster());

    if (CalcIsDisabled())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(DispatchGetSyncTime(dblNewSegmentTime,
                                 lNewRepeatCount,
                                 bCueing));
    if (S_OK != hr)
    {
        goto done;
    }

    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::OnBvrCB(%g):DispatchSync: last(%g, %d) new(%g, %d)",
              this,
              GetID(),
              dblNextGlobalTime,
              m_dblCurrSegmentTime,
              m_lCurrRepeatCount,
              dblNewSegmentTime,
              lNewRepeatCount));
    
    if (!IsActive())
    {
        double dblNextParentTime = CalcSyncParentTimeFromGlobalTime(*this,
                                                                    dblNextGlobalTime);
        double dblLastParentTime = GetCurrParentTime();
        
        bool bTurningOn = false;
        
        // Need to detect if we are transitioning to being active this
        // tick
        // If not then do not respect the sync call
        if (TIME_INFINITE == dblNextParentTime)
        {
            bTurningOn = false;
        }
        else if (CalcActiveDirection() == TED_Forward)
        {
            bTurningOn = (dblNextParentTime >= GetBeginParentTime() &&
                          dblLastParentTime < GetBeginParentTime());
        }
        else
        {
            bTurningOn = (dblNextParentTime <= GetEndParentTime() &&
                          dblLastParentTime > GetEndParentTime());
        }

        if (!bTurningOn)
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = THR(SyncNode(l,
                      dblNextGlobalTime,
                      dblNewSegmentTime,
                      lNewRepeatCount,
                      bCueing));
    if (S_OK != hr)
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
} // OnBvrCB

HRESULT
CTIMENode::SyncNode(CEventList * l,
                    double dblNextGlobalTime,
                    double dblNewSegmentTime,
                    LONG lNewRepeatCount,
                    bool bCueing)
{
    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::SyncNode(%p, %g, %g, %ld, %d)",
              this,
              GetID(),
              l,
              dblNextGlobalTime,
              dblNewSegmentTime,
              lNewRepeatCount,
              bCueing));

    HRESULT hr;
    
    // Now we need to check the sync times for validity
    hr = THR(CheckSyncTimes(dblNewSegmentTime, lNewRepeatCount));
    if (S_OK != hr)
    {
        goto done;
    }
    
    Assert(dblNewSegmentTime != TIME_INFINITE);

    double dblNewActiveTime;
    dblNewActiveTime = CalcNewActiveTime(dblNewSegmentTime,
                                         lNewRepeatCount);
    
    double dblNewParentTime;
    dblNewParentTime = CalcParentTimeFromActiveTime(dblNewActiveTime);

    Assert(dblNewParentTime != TIME_INFINITE);

    // HACK HACK - This is to work around major precision problems
    // when walking up the time tree.  This will add a little fudge to
    // it to avoid truncation problems.
    
    {
        double dblTruncatedActiveTime = CalcActiveTimeFromParentTime(dblNewParentTime);
        if (dblTruncatedActiveTime < dblNewActiveTime)
        {
            dblNewParentTime += 1e-15;

            // This means we got here twice and we should add a little more
            if (dblNewParentTime == m_dblCurrParentTime)
            {
                dblNewParentTime += 1e-15;
            }
        }
    }
    
    double dblNextParentTime;

    if (IsLocked())
    {
        if (GetParent())
        {
            double dblParentSegmentTime;
            dblParentSegmentTime = GetParent()->SimpleTimeToSegmentTime(dblNewParentTime);

            hr = THR(GetParent()->SyncNode(l,
                                           dblNextGlobalTime,
                                           dblParentSegmentTime,
                                           TE_UNDEFINED_VALUE,
                                           bCueing));

            if (S_OK != hr)
            {
                goto done;
            }

            dblNextParentTime = dblNewParentTime;
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        dblNextParentTime = CalcSyncParentTimeFromGlobalTime(*this,
                                                             dblNextGlobalTime);
    }
    
    // If this is infinite then we are going to pass a repeat or
    // reverse boundary and no matter what we do it will not matter
    if (dblNextParentTime == TIME_INFINITE)
    {
        hr = S_FALSE;
        goto done;
    }
    
    hr = THR(SetSyncTimes(dblNewSegmentTime,
                          lNewRepeatCount,
                          dblNewActiveTime,
                          dblNewParentTime,
                          dblNextParentTime,
                          bCueing));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // We actually need to force a update to our children's time
    // sync since the global relationship changed
    RecalcCurrEndTime(l, true);
    
    hr = S_OK;
  done:
    RRETURN2(hr, S_FALSE, E_FAIL);
}

HRESULT
CTIMENode::CheckSyncTimes(double & dblNewSegmentTime,
                          LONG & lNewRepeatCount) const
{
    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::CTIMENode(%g,%d)",
              this,
              GetID(),
              dblNewSegmentTime,
              lNewRepeatCount));

    HRESULT hr;
    double dblSegmentDur = CalcCurrSegmentDur();

    if (dblNewSegmentTime == TIME_INFINITE ||
        dblNewSegmentTime == TE_UNDEFINED_VALUE)
    {
        // This means that we should have ended.  Ignore this and
        // assume that we will be told to stop using the end method
        
        // This also could have meant that the current repeat segment
        // ended and the repeat count is unknown - so again just
        // ignore this call
        
        hr = S_FALSE;
        goto done;
    }

    // Now update the repeat count - making sure to validate
    // everything
    
    if (lNewRepeatCount == TE_UNDEFINED_VALUE)
    {
        lNewRepeatCount = GetCurrRepeatCount();
    }
    else if (lNewRepeatCount != GetCurrRepeatCount())
    {
        if (CalcActiveDirection() == TED_Forward)
        {
            if (lNewRepeatCount < GetCurrRepeatCount())
            {
                lNewRepeatCount = GetCurrRepeatCount();
            }
            else if (lNewRepeatCount > long(CalcRepeatCount()))
            {
                lNewRepeatCount = long(CalcRepeatCount());
            }
        }
        else
        {
            if (lNewRepeatCount > GetCurrRepeatCount())
            {
                lNewRepeatCount = GetCurrRepeatCount();
            }
            else if (lNewRepeatCount < 0)
            {
                lNewRepeatCount = 0;
            }
        }
    }

    if (dblNewSegmentTime != GetCurrSegmentTime())
    {
        bool bNewRepeat = (lNewRepeatCount != GetCurrRepeatCount());

        if (bNewRepeat)
        {
            if (dblNewSegmentTime < 0.0)
            {
                dblNewSegmentTime = 0.0;
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                dblNewSegmentTime = dblSegmentDur;
            }
        }
        else if (CalcActiveDirection() == TED_Forward)
        {
            if (dblNewSegmentTime < GetCurrSegmentTime())
            {
                dblNewSegmentTime = GetCurrSegmentTime();
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                dblNewSegmentTime = dblSegmentDur;
            }
        }
        else
        {
            if (dblNewSegmentTime > GetCurrSegmentTime())
            {
                dblNewSegmentTime = GetCurrSegmentTime();
            }
            else if (dblNewSegmentTime < 0.0)
            {
                dblNewSegmentTime = 0.0;
            }
        }
    }
    
    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMENode::SetSyncTimes(double dblNewSegmentTime,
                        LONG lNewRepeatCount,
                        double dblNewActiveTime,
                        double dblNewParentTime,
                        double dblNextParentTime,
                        bool bCueing)
{
    TraceTag((tagWatchClockSync,
              "CTIMENode(%p, %ls)::SetSyncTimes(%g,%d,%g, %g,%g,%d)",
              this,
              GetID(),
              dblNewSegmentTime,
              lNewRepeatCount,
              dblNewActiveTime,
              dblNewParentTime,
              dblNextParentTime,
              bCueing));

    // Init to S_OK and if we find anything invalid return S_FALSE
    
    HRESULT hr = S_OK;
    double dblSegmentDur = CalcCurrSegmentDur();
    TEDirection ted = CalcActiveDirection();
    double dblActiveDur = CalcEffectiveActiveDur();
    
    m_bSyncCueing = bCueing;
    
    Assert(dblNewSegmentTime != TIME_INFINITE);
    Assert(dblNewSegmentTime != TE_UNDEFINED_VALUE);
    
    m_dblSyncParentTime = dblNextParentTime;
    m_dblSyncNewParentTime = dblNewParentTime;

    // Now update the repeat count - making sure to validate
    // everything
    
    // Init to current repeat count in case there is an invalidate
    // repeat count
    m_lSyncRepeatCount = GetCurrRepeatCount();

    if (lNewRepeatCount != TE_UNDEFINED_VALUE &&
        lNewRepeatCount != GetCurrRepeatCount())
    {
        if (ted == TED_Forward)
        {
            if (lNewRepeatCount < GetCurrRepeatCount())
            {
                hr = S_FALSE;
                Assert(m_lSyncRepeatCount == GetCurrRepeatCount());
            }
            else if (lNewRepeatCount > long(CalcRepeatCount()))
            {
                hr = S_FALSE;
                m_lSyncRepeatCount = long(CalcRepeatCount());
            }
            else
            {
                m_lSyncRepeatCount = lNewRepeatCount;
            }
        }
        else
        {
            if (lNewRepeatCount > GetCurrRepeatCount())
            {
                hr = S_FALSE;
                Assert(m_lSyncRepeatCount == GetCurrRepeatCount());
            }
            else if (lNewRepeatCount < 0)
            {
                hr = S_FALSE;
                m_lSyncRepeatCount = 0;
            }
            else
            {
                m_lSyncRepeatCount = lNewRepeatCount;
            }
        }
    }

    // Init to current segment time in case the new segment time is
    // invalid
    m_dblSyncSegmentTime = GetCurrSegmentTime();

    if (dblNewSegmentTime != GetCurrSegmentTime())
    {
        bool bNewRepeat = GetSyncRepeatCount() != GetCurrRepeatCount();

        if (bNewRepeat)
        {
            if (dblNewSegmentTime < 0.0)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = 0.0;
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = dblSegmentDur;
            }
            else
            {
                m_dblSyncSegmentTime = dblNewSegmentTime;
            }
        }
        else if (ted == TED_Forward)
        {
            if (dblNewSegmentTime < GetCurrSegmentTime())
            {
                hr = S_FALSE;
                Assert(m_dblSyncSegmentTime == GetCurrSegmentTime());
            }
            else if (dblNewSegmentTime > dblSegmentDur)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = dblSegmentDur;
            }
            else
            {
                m_dblSyncSegmentTime = dblNewSegmentTime;
            }
        }
        else
        {
            if (dblNewSegmentTime > GetCurrSegmentTime())
            {
                hr = S_FALSE;
                Assert(m_dblSyncSegmentTime == GetCurrSegmentTime());
            }
            else if (dblNewSegmentTime < 0.0)
            {
                hr = S_FALSE;
                m_dblSyncSegmentTime = 0.0;
            }
            else
            {
                m_dblSyncSegmentTime = dblNewSegmentTime;
            }
        }
    }
    
    // Init to current active time in case the new active time is
    // invalid
    m_dblSyncActiveTime = CalcElapsedActiveTime();

    if (dblNewActiveTime != m_dblSyncActiveTime)
    {
        if (ted == TED_Forward)
        {
            if (dblNewActiveTime < m_dblSyncActiveTime)
            {
                hr = S_FALSE;
                Assert(m_dblSyncActiveTime == CalcElapsedActiveTime());
            }
            else if (dblNewActiveTime > dblActiveDur)
            {
                hr = S_FALSE;
                m_dblSyncActiveTime = dblActiveDur;
            }
            else
            {
                m_dblSyncActiveTime = dblNewActiveTime;
            }
        }
        else
        {
            if (dblNewActiveTime > m_dblSyncActiveTime)
            {
                hr = S_FALSE;
                Assert(m_dblSyncActiveTime == CalcElapsedActiveTime());
            }
            else if (dblNewActiveTime < 0.0)
            {
                hr = S_FALSE;
                m_dblSyncActiveTime = 0.0;
            }
            else
            {
                m_dblSyncActiveTime = dblNewActiveTime;
            }
        }
    }
    
  done:
    RRETURN1(hr, S_FALSE);
}

void
CTIMENode::ResetSyncTimes()
{
    TraceTag((tagClockSync,
              "CTIMENode(%p, %ls)::ResetSyncTimes()",
              this,
              GetID()));

    m_dblSyncSegmentTime = TIME_INFINITE;
    m_lSyncRepeatCount = TE_UNDEFINED_VALUE;
    m_dblSyncActiveTime = TIME_INFINITE;
    m_dblSyncParentTime = TIME_INFINITE;
    m_dblSyncNewParentTime = TIME_INFINITE;
    m_bSyncCueing = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\timebase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timebase.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagTIMESink, "TIME: Engine", "TIMESink methods");

TimeSinkList::TimeSinkList()
{
}

TimeSinkList::~TimeSinkList()
{
    // The add does not do a addref so we do not need to clean up
    // anything

    Assert(m_sinkList.size() == 0);
}

HRESULT
TimeSinkList::Add(ITimeSink * sink)
{
    Assert(sink != NULL);
    // TODO: Handle out of memory
    m_sinkList.push_back(sink);
    return S_OK;
}

void
TimeSinkList::Remove(ITimeSink * sink)
{
    Assert(sink != NULL);
    m_sinkList.remove(sink);
}

void
TimeSinkList::Update(CEventList * l, DWORD dwFlags)
{
    for (ITimeSinkList::iterator i = m_sinkList.begin(); 
         i != m_sinkList.end(); 
         i++)
    {
        (*i)->Update(l, dwFlags);
    }
    
  done:
    return;
}

// =======================
// CTimeBase
// =======================

DeclareTag(tagTimeBase, "TIME: Engine", "CTimeBase methods");

CSyncArcTimeBase::CSyncArcTimeBase(CSyncArcList & tbl,
                                   CTIMENode & ptnBase,
                                   TE_TIMEPOINT tetpBase,
                                   double dblOffset)
: m_tbl(tbl),
  m_ptnBase(&ptnBase),
  m_tetpBase(tetpBase),
  m_dblOffset(dblOffset)
{
#if DBG
    m_bAttached = false;
#endif

    Assert(tetpBase == TE_TIMEPOINT_BEGIN ||
           tetpBase == TE_TIMEPOINT_END);
}
    
CSyncArcTimeBase::~CSyncArcTimeBase()
{
#if DBG
    Assert(!m_bAttached);
#endif
}

HRESULT
CSyncArcTimeBase::Attach()
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::Attach()",
              this));
    
    HRESULT hr;
    
    Assert(!m_bAttached);

    switch(m_tetpBase)
    {
      case TE_TIMEPOINT_BEGIN:
        hr = m_ptnBase->AddBeginTimeSink(this);
        if (FAILED(hr))
        {
            goto done;
        }

        break;
      case TE_TIMEPOINT_END:
        hr = m_ptnBase->AddEndTimeSink(this);
        if (FAILED(hr))
        {
            goto done;
        }

        break;
      default:
        AssertSz(false, "Invalid time point specified");
        break;
    }

#if DBG
    m_bAttached = true;
#endif
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    RRETURN(hr);
}

void
CSyncArcTimeBase::Detach()
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::Detach()",
              this));
    
    Assert(!m_bAttached || m_tbl.GetNode().IsReady());
    
    switch (m_tetpBase)
    {
      case TE_TIMEPOINT_BEGIN:
        m_ptnBase->RemoveBeginTimeSink(this);

        break;
      case TE_TIMEPOINT_END:
        m_ptnBase->RemoveEndTimeSink(this);

        break;
      default:
        AssertSz(false, "Invalid begin time point specified");
        break;
    }

#if DBG
    m_bAttached = false;
#endif

  done:
    return;
}

void
CSyncArcTimeBase::Update(CEventList * l, DWORD dwFlags)
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::Update(%p, %x)",
              this,
              l,
              dwFlags));
    
    // We better have been attached or we are in trouble
    Assert(m_bAttached);

    // We should not have been attached if the node is not ready
    Assert(m_tbl.GetNode().IsReady());
    
    // If this is a timeshift and we are not a long sync arc then
    // ignore the update
    if ((dwFlags & TS_TIMESHIFT) != 0 &&
        !IsLongSyncArc())
    {
        goto done;
    }
    
    m_tbl.Update(l, *this);
    
  done:
    return;
}

double
ConvertLongSyncArc(double dblTime,
                   CTIMENode & ptnFrom,
                   CTIMENode & ptnTo)
{
    TraceTag((tagTimeBase,
              "ConvertLongSyncArc(%g, %p, %p)",
              dblTime,
              &ptnFrom,
              &ptnTo));

    double dblRet = dblTime;

    dblRet = ptnFrom.CalcGlobalTimeFromParentTime(dblRet);

    if (dblRet == TIME_INFINITE)
    {
        goto done;
    }
    
    dblRet = ptnTo.CalcParentTimeFromGlobalTimeForSyncArc(dblRet);
    
  done:
    return dblRet;
}

double
CSyncArcTimeBase::GetCurrTimeBase() const
{
    TraceTag((tagTimeBase,
              "CSyncArcTimeBase(%p)::GetCurrTimeBase()",
              this));
    
    double dblTime = TIME_INFINITE;
    
    if (!m_tbl.GetNode().IsReady())
    {
        goto done;
    }
    
    switch (m_tetpBase)
    {
      case TE_TIMEPOINT_BEGIN:
        dblTime = m_ptnBase->GetBeginParentTime();

        break;
      case TE_TIMEPOINT_END:
        dblTime = m_ptnBase->GetEndParentTime();

        break;
      case TE_TIMEPOINT_NONE:
      default:
        AssertSz(false, "Invalid begin time point specified");
        break;
    }

    if (IsLongSyncArc())
    {
        dblTime = ConvertLongSyncArc(dblTime, *m_ptnBase, m_tbl.GetNode());
    }
    
    // Make sure we add the offset after the conversion since it is in
    // our local time space and not the syncarc's.
    
    dblTime += m_dblOffset;
    
  done:
    return dblTime;
}

bool
CSyncArcTimeBase::IsLongSyncArc() const
{
    Assert(m_tbl.GetNode().IsReady());
    Assert(m_ptnBase);
    
    return (m_ptnBase->GetParent() != m_tbl.GetNode().GetParent());
}



CSyncArcList::CSyncArcList(CTIMENode & tn,
                                     bool bBeginSink)
: m_tn(tn),
  m_bBeginSink(bBeginSink),
  m_lLastCookie(0),
  m_bAttached(false)
{
}
    
CSyncArcList::~CSyncArcList()
{
    Assert(!m_bAttached);

    Clear();
}

HRESULT
CSyncArcList::Attach()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Attach()",
              this));
    
    HRESULT hr;
    
    Assert(!m_bAttached);
    
    // If we are not ready then we need to delay doing this
    Assert(m_tn.IsReady());
    
    SyncArcList::iterator i;
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        hr = THR((*i).second->Attach());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        hr = THR((*i).second->Attach());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_bAttached = true;

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    RRETURN(hr);
}

void
CSyncArcList::Detach()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Detach()",
              this));
    
    SyncArcList::iterator i;
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        (*i).second->Detach();
    }
    
    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        (*i).second->Detach();
    }
    
    m_bAttached = false;

  done:
    return;
}

HRESULT
CSyncArcList::Add(ISyncArc & tb,
                  bool bOneShot,
                  long * plCookie)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Add(%p, %d)",
              this,
              &tb,
              bOneShot));

    HRESULT hr;
    bool bAdded;
    SyncArcList & salList = bOneShot?m_tbOneShotList:m_tbList;

    if (plCookie != NULL)
    {
        *plCookie = 0;
    }

    if (m_bAttached)
    {
        hr = THR(tb.Attach());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    // Pre-increment
    ++m_lLastCookie;
    
    // @@ ISSUE : Memory failure not detected

    bAdded = salList.insert(SyncArcList::value_type(m_lLastCookie, &tb)).second;

    if (!bAdded)
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (plCookie != NULL)
    {
        *plCookie = m_lLastCookie;
    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        tb.Detach();
    }
    
    RRETURN1(hr, E_FAIL);
}

bool
CSyncArcList::Remove(long lCookie, bool bDelete)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Remove(%#x, %d)",
              this,
              lCookie,
              bDelete));

    bool bRet = false;
    
    SyncArcList::iterator i;

    i = m_tbList.find(lCookie);

    if (i != m_tbList.end())
    {
        bRet = true;
        
        (*i).second->Detach();
        
        if (bDelete)
        {
            delete (*i).second;
        }

        m_tbList.erase(i);
    }
    else
    {
        i = m_tbOneShotList.find(lCookie);
        
        if (i != m_tbOneShotList.end())
        {
            bRet = true;
            
            (*i).second->Detach();
            
            if (bDelete)
            {
                delete (*i).second;
            }
            
            m_tbOneShotList.erase(i);
        }
    }

  done:
    return bRet;
}

ISyncArc *
CSyncArcList::Find(long lCookie)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Find(%#x)",
              this,
              lCookie));

    ISyncArc * ret = NULL;
    
    SyncArcList::iterator i;

    i = m_tbList.find(lCookie);

    if (i != m_tbList.end())
    {
        ret = (*i).second;
    }
    else
    {
        i = m_tbOneShotList.find(lCookie);

        if (i != m_tbOneShotList.end())
        {
            ret = (*i).second;
        }
    }

  done:
    return ret;
}

bool
CSyncArcList::Clear()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Clear()",
              this));

    SyncArcList::iterator i;
    
    if (m_tbList.size() == 0 && m_tbOneShotList.size() == 0)
    {
        return false;
    }
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        (*i).second->Detach();
        delete (*i).second;
    }
    
    m_tbList.clear();

    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        (*i).second->Detach();
        delete (*i).second;
    }
    
    m_tbOneShotList.clear();

    return true;
}

bool
CSyncArcList::Reset()
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Reset()",
              this));

    SyncArcList::iterator i;
    bool bRet = (m_tbOneShotList.size() > 0);

    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        (*i).second->Detach();
        delete (*i).second;
    }
    
    m_tbOneShotList.clear();

    return bRet;
}

void
CSyncArcList::Update(CEventList * l,
                     ISyncArc & tb)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::Update(%p, %p)",
              this,
              l,
              &tb));
    
    // We better have been attached or we are in trouble
    Assert(m_bAttached);

    // We should not have been attached if the node is not ready
    Assert(m_tn.IsReady());
    
    m_tn.SyncArcUpdate(l,
                       m_bBeginSink,
                       tb);
    
  done:
    return;
}

void
CSyncArcList::GetBounds(double dblTime,
                        bool bInclusive,
                        bool bStrict,
                        bool bIncludeOneShot,
                        bool bOneShotInclusive,
                        double * pdblLower,
                        double * pdblUpper) const
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::GetBounds(%g, %d, %d, %d, %d)",
              this,
              dblTime,
              bInclusive,
              bStrict,
              bIncludeOneShot,
              bOneShotInclusive));

    double l;
    double u;
    
    SyncArcList::iterator i;

    if (m_tbList.size() == 0 && (
        m_tbOneShotList.size() == 0 ||
        !bIncludeOneShot))
    {
        l = TIME_INFINITE;
        u = TIME_INFINITE;

        goto done;
    }

    l = TIME_INFINITE;
    u = -TIME_INFINITE;
    
    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        double t = (*i).second->GetCurrTimeBase();

        if (bInclusive && t == dblTime)
        {
            l = t;
            u = t;
            goto done;
        }
        
        if (l < dblTime)
        {
            if (t > l && t < dblTime)
            {
                l = t;
            }
        }
        else
        {
            if (t < l)
            {
                l = t;
            }
        }

        if (u > dblTime)
        {
            if (t < u && t > dblTime)
            {
                u = t;
            }
        }
        else
        {
            if (t > u)
            {
                u = t;
            }
        }
    }

    if (bIncludeOneShot)
    {
        for (i = m_tbOneShotList.begin();
             i != m_tbOneShotList.end();
             i++)
        {
            double t = (*i).second->GetCurrTimeBase();

            if (bOneShotInclusive && t == dblTime)
            {
                l = t;
                u = t;
                goto done;
            }
        
            if (l < dblTime)
            {
                if (t > l && t < dblTime)
                {
                    l = t;
                }
            }
            else
            {
                if (t < l)
                {
                    l = t;
                }
            }

            if (u > dblTime)
            {
                if (t < u && t > dblTime)
                {
                    u = t;
                }
            }
            else
            {
                if (t > u)
                {
                    u = t;
                }
            }
        }
    }
    
    if (bStrict)
    {
        if (l > dblTime || (l == dblTime && !bInclusive))
        {
            l = TIME_INFINITE;
        }

        if (u < dblTime || (u == dblTime && !bInclusive))
        {
            u = TIME_INFINITE;
        }
    }

    Assert(u != -TIME_INFINITE);
    
  done:
    if (NULL != pdblLower)
    {
        *pdblLower = l;
    }

    if (NULL != pdblUpper)
    {
        *pdblUpper = u;
    }
}

void
CSyncArcList::GetSortedSet(DoubleSet & ds,
                           bool bIncludeOneShot)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::GetSortedSet(%p, %d)",
              this,
              &ds,
              bIncludeOneShot));

    SyncArcList::iterator i;

    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        double t = (*i).second->GetCurrTimeBase();

        ds.insert(t);
    }
    
    if (bIncludeOneShot)
    {
        for (i = m_tbOneShotList.begin();
             i != m_tbOneShotList.end();
             i++)
        {
            double t = (*i).second->GetCurrTimeBase();
            
            ds.insert(t);
        }
    }
}

bool
CSyncArcList::UpdateFromLongSyncArcs(CEventList * l)
{
    TraceTag((tagTimeBase,
              "CSyncArcList(%p)::UpdateFromLongSyncArcs(%p)",
              this,
              l));

    bool bRet = false;
    
    SyncArcList::iterator i;

    for (i = m_tbList.begin();
         i != m_tbList.end();
         i++)
    {
        if ((*i).second->IsLongSyncArc())
        {
            bRet = true;
            Update(l, *(*i).second);
        }
    }
    
    // TODO: Currently these cannot be sync arcs so we could just not
    // make the call
    for (i = m_tbOneShotList.begin();
         i != m_tbOneShotList.end();
         i++)
    {
        if ((*i).second->IsLongSyncArc())
        {
            bRet = true;
            Update(l, *(*i).second);
        }
    }

  done:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\timebase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timebase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEBASE_H
#define _TIMEBASE_H

#pragma once

typedef std::set<double> DoubleSet;

class CEventList;

#define TS_TIMESHIFT 0x00000001

interface ITimeSink
{
    virtual void Update(CEventList * l, DWORD dwFlags) = 0;
};

class TimeSinkList
{
  public:
    TimeSinkList();
    ~TimeSinkList();

    HRESULT Add(ITimeSink *);
    void Remove(ITimeSink *);

    void Update(CEventList * l, DWORD dwFlags);
  protected:
    typedef std::list<ITimeSink *> ITimeSinkList;
    
    ITimeSinkList m_sinkList;
};

class ISyncArc
{
  public:
    virtual ~ISyncArc() {}
        
    virtual HRESULT Attach() = 0;
    virtual void Detach() = 0;

    virtual double GetCurrTimeBase() const = 0;
    virtual bool IsLongSyncArc() const = 0;
};

class CTIMENode;

typedef std::map<long, ISyncArc *> SyncArcList;

class CSyncArcList
{
  public:
    CSyncArcList(CTIMENode & tn, bool bBeginSink);
    ~CSyncArcList();

    HRESULT Add(ISyncArc & tb, bool bOneShot, long * plCookie);
    // Returns whether the cookie was found
    // If bDelete is set then the object is deleted and not just
    // removed
    bool Remove(long lCookie, bool bDelete);
    ISyncArc * Find(long lCookie);

    // This will reset all the one shot timers
    // Returns true if anything was cleared
    bool Reset();
    
    // Returns true if anything was cleared
    bool Clear();

    HRESULT Attach();
    void Detach();

    void Update(CEventList * l,
                ISyncArc & ptb);

    CTIMENode & GetNode() const { return m_tn; }

    double LowerBound(double dblTime,
                      bool bInclusive,
                      bool bStrict,
                      bool bIncludeOneShot,
                      bool bOneShotInclusive) const;
    double UpperBound(double dblTime,
                      bool bInclusive,
                      bool bStrict,
                      bool bIncludeOneShot,
                      bool bOneShotInclusive) const;
    void GetBounds(double dblTime,
                   bool bInclusive,
                   bool bStrict,
                   bool bIncludeOneShot,
                   bool bOneShotInclusive,
                   double * pdblLower,
                   double * pdblUpper) const;

    void GetSortedSet(DoubleSet & ds,
                      bool bIncludeOneShot);

    // Returns true if any were updated
    bool UpdateFromLongSyncArcs(CEventList * l);
  protected:
    CSyncArcList();
    
    CTIMENode &  m_tn;
    bool         m_bBeginSink;
    SyncArcList  m_tbList;
    SyncArcList  m_tbOneShotList;
    long         m_lLastCookie;
    bool         m_bAttached;
};

class CSyncArcOffset
    : public ISyncArc
{
  public:
    CSyncArcOffset(double dblOffset) : m_dblOffset(dblOffset) {}
    
    // ISyncArc
    
    HRESULT Attach() { return S_OK; }
    void Detach() {}
    double GetCurrTimeBase() const { return m_dblOffset; }
    bool IsLongSyncArc() const { return false; }

    double GetOffset() const { return m_dblOffset; }
  protected:
    CSyncArcOffset();
    double m_dblOffset;
};

class CSyncArcTimeBase
    : public ITimeSink,
      public ISyncArc
{
  public:
    CSyncArcTimeBase(CSyncArcList & tbl,
                     CTIMENode & ptnBase,
                     TE_TIMEPOINT tetpBase,
                     double dblOffset);
    ~CSyncArcTimeBase();
        
    // ITIMESink 
    void Update(CEventList * l, DWORD dwFlags);

    // ISyncArc
    HRESULT Attach();
    void Detach();
    double GetCurrTimeBase() const;
    bool IsLongSyncArc() const;

  protected:
    CSyncArcTimeBase();
    CSyncArcList &       m_tbl;
    DAComPtr<CTIMENode>  m_ptnBase;
    TE_TIMEPOINT         m_tetpBase;
    double               m_dblOffset;

#if DBG
    bool                 m_bAttached;
#endif
};

inline double
CSyncArcList::LowerBound(double dblTime,
                         bool bInclusive,
                         bool bStrict,
                         bool bIncludeOneShot,
                         bool bOneShotInclusive) const
{
    double dblLower;

    GetBounds(dblTime,
              bInclusive,
              bStrict,
              bIncludeOneShot,
              bOneShotInclusive,
              &dblLower,
              NULL);

    return dblLower;
}

inline double
CSyncArcList::UpperBound(double dblTime,
                         bool bInclusive,
                         bool bStrict,
                         bool bIncludeOneShot,
                         bool bOneShotInclusive) const
{
    double dblUpper;

    GetBounds(dblTime,
              bInclusive,
              bStrict,
              bIncludeOneShot,
              bOneShotInclusive,
              NULL,
              &dblUpper);

    return dblUpper;
}

#endif /* _TIMEBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\tickevent.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: tickevent.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagTickEvent, "TIME: Engine", "Tick Event")

void
CTIMENode::TickEvent(CEventList * l,
                     TE_EVENT_TYPE et,
                     DWORD dwFlags)
{
    TraceTag((tagTickEvent,
              "CTIMENode(%lx,%ls)::TickEvent(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));

    ResetSyncTimes();

    if (!TickEventPre(l, et, dwFlags))
    {
        goto done;
    }
    
    TickEventChildren(l, et, dwFlags);
    
    if (!TickEventPost(l, et, dwFlags))
    {
        goto done;
    }

  done:
    return;
}

// This is in our local time space
bool
CTIMENode::TickEventPre(CEventList * l,
                        TE_EVENT_TYPE et,
                        DWORD dwFlags)
{
    TraceTag((tagTickEvent,
              "CTIMENode(%lx,%ls)::TickEventPre(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));

    bool bRet;
    bool bFireEvent = false;
    
    switch(et)
    {
      case TE_EVENT_BEGIN:
        if (IsActive() && m_bFirstTick)
        {
            // If we are on the begin boundary delay until we are no
            // longer sync cueing
            // TODO: Consider adding a fudge factor to the ==
            // comparison since we may be a little off and still want
            // to hold as if we were on the begin boundary
            if ((IsSyncCueing() || IsDeferredActive()) &&
                GetCurrParentTime() == CalcActiveBeginPoint())
            {
                bRet = false;
                goto done;
            }
        
            Assert(GetCurrParentTime() != -TIME_INFINITE);
            bFireEvent = true;
        }
        
        break;
      case TE_EVENT_END:
        // If we are active and it is the first tick then we never
        // fired the begin so fire it now
        if (IsActive() && IsFirstTick())
        {
            // If we are not going to fire the begin then we should
            // not fire the end
            // Use the same logic we use for the begin above
            if ((IsSyncCueing() || IsDeferredActive()) &&
                GetCurrParentTime() == CalcActiveBeginPoint())
            {
                bRet = false;
                goto done;
            }
            
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_BEGIN);
        }
        
        break;
      case TE_EVENT_PAUSE:
        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        if (GetIsPaused())
        {
            bRet = false;
            goto done;
        }
        
        PropNotify(l, TE_PROPERTY_ISCURRPAUSED);

        bFireEvent = true;

        break;
      case TE_EVENT_RESUME:
        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        if (GetIsPaused())
        {
            bRet = false;
            goto done;
        }

        PropNotify(l, TE_PROPERTY_ISCURRPAUSED);

        break;
      case TE_EVENT_DISABLE:
        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        if (GetIsDisabled())
        {
            bRet = false;
            goto done;
        }
        
        PropNotify(l, TE_PROPERTY_ISCURRDISABLED);

        bFireEvent = true;

        break;
      case TE_EVENT_ENABLE:
        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        if (GetIsDisabled())
        {
            bRet = false;
            goto done;
        }

        PropNotify(l, TE_PROPERTY_ISCURRDISABLED);

        break;
      case TE_EVENT_SEEK:
        HandleSeekUpdate(l);
        bFireEvent = true;
        break;
      case TE_EVENT_PARENT_TIMESHIFT:
        HandleTimeShift(l);
        bFireEvent = true;
        break;
      default:
        break;
    }
    
    if (bFireEvent)
    {
        EventNotify(l, CalcElapsedActiveTime(), et);
    }

    bRet = true;
  done:
    return bRet;
}

// This is in our local time space
bool
CTIMENode::TickEventPost(CEventList * l,
                         TE_EVENT_TYPE et,
                         DWORD dwFlags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx,%ls)::TickEventPost(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));

    bool bRet;
    bool bFireEvent = false;
    
    switch(et)
    {
      case TE_EVENT_BEGIN:

        m_bFirstTick = false;

        break;
      case TE_EVENT_END:
        if (IsActive())
        {
            Assert(GetCurrParentTime() != -TIME_INFINITE);
            Assert(!IsFirstTick());
        
            if ((dwFlags & TE_EVENT_INCHILD) != 0)
            {
                m_bEndedByParent = true;
            }
            
            bFireEvent = true;
        }

        // This is dependent on our parent and so if our parent ends
        // then we need to reevaluate
        PropNotify(l, TE_PROPERTY_ISON);
        
        m_bFirstTick = false;
        
        break;
      case TE_EVENT_RESUME:
        bFireEvent = true;

        break;
      case TE_EVENT_ENABLE:
        bFireEvent = true;

        break;
      default:
        break;
    }
    
    if (bFireEvent)
    {
        EventNotify(l, CalcElapsedActiveTime(), et);
    }

    bRet = true;
  done:
    return bRet;
}

void
CTIMEContainer::TickEventChildren(CEventList * l,
                                  TE_EVENT_TYPE et,
                                  DWORD dwFlags)
{
    TraceTag((tagTickEvent,
              "CTIMEContainer(%lx,%ls)::TickEventChildren(%#x, %s, %#x)",
              this,
              GetID(),
              l,
              EventString(et),
              dwFlags));
    
    for (TIMENodeList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        (*i)->TickEvent(l,
                        et,
                        dwFlags | TE_EVENT_INCHILD);
    }
        
  done:
    return;
}

void
CTIMENode::TickEventChildren(CEventList * l,
                             TE_EVENT_TYPE et,
                             DWORD dwFlags)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timescal\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TimeScale.rc
//
#define IDS_PROJNAME                    100
#define IDR_SCALEPLAYER                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timescal\nstdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>


//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
DWORD g_dwFALSE = 0;
//
// end of misc stuff
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timescal\scaleplayer.cpp ===
// ScalePlayer.cpp : Implementation of CScalePlayer
#include "stdafx.h"
#include "TimeScale.h"
#include "ScalePlayer.h"
#include <math.h>
#include <shlwapi.h>

#define ID_TIMER 1
#define TIMER_INT 100

WCHAR gPauseStateString[] = L"State: Paused";
WCHAR gRunnigStateString[] = L"State: Running";
WCHAR gInactiveStateString[] = L"State: Not active";


/////////////////////////////////////////////////////////////////////////////
// CScalePlayer

CScalePlayer::CScalePlayer() :
    m_dwLastRefTime(0),
    m_dblTime(0.0),
    m_dblNaturalDur(5.0),
    m_fDoneDL(false),
    m_dblScaleFactor(1.0),
    m_fSuspended(false),
    m_fMediaReady(false),
    m_fRunning(false),
    m_bstrSrc(),
    m_fInPlaceActivated(false),
    m_pwndMsgWindow(NULL),
    m_dblMediaDur(HUGE_VAL),
    m_dwLastDLRefTime(0),
    m_dblDLTime(0.0),
    m_dblDLDur(2.0)

{
    double pdblCurrentTime;
    m_clrKey = RGB(0xff, 0x00, 0x00);
    m_rectSize.top = m_rectSize.left = 0;
    m_rectSize.bottom = m_rectSize.right= 400;
    m_fSuspended    = false;
    m_fRunning = true;
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = 0;
}

//
// ITIMEMediaPlayer
//
STDMETHODIMP CScalePlayer::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;

    if(m_pwndMsgWindow == NULL)
    {
        hr = CreateMessageWindow();
    }

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }
    InitPropSink();

done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::Detach(void)
{
    ::KillTimer(m_pwndMsgWindow, ID_TIMER);
    m_spOleClientSite.Release();
    m_spOleInPlaceSite.Release();
    m_spOleInPlaceSiteEx.Release();
    m_spOleInPlaceSiteWindowless.Release();
    m_spTIMEMediaPlayerSite.Release();
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    DeinitPropSink();

    return S_OK;
}

STDMETHODIMP CScalePlayer::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::begin(void)
{
    OutputDebugString(L"CScalePlayer::begin\n");
    float flTeSpeed = 0.0;
    HRESULT hr;

    hr = m_spTIMEState->get_speed(&flTeSpeed);
    if(FAILED(hr))
    {
        goto done;
    }
    if(flTeSpeed < 0)
    {
        goto done;
    }

    m_fSuspended    = false;
    m_fRunning = true;
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = 0;
    m_clrKey = RGB(0xff, 0x00, 0x00);

done:
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }
    return S_OK;
}

STDMETHODIMP CScalePlayer::end(void)
{
    OutputDebugString(L"CScalePlayer::end\n");
    m_fSuspended = true;
    m_fRunning = false;
    m_dblTime    = -HUGE_VAL;
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }

    return S_OK;
}

STDMETHODIMP CScalePlayer::resume(void)
{
    m_fSuspended    = false;
    m_dwLastRefTime = timeGetTime();

    m_clrKey = RGB(0xff, 0x00, 0x00);
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }
    return S_OK;
}

STDMETHODIMP CScalePlayer::pause(void)
{
    m_fSuspended = true;

    m_clrKey = RGB(0x00, 0x00, 0xff);
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }
    return S_OK;
}


STDMETHODIMP CScalePlayer::resumePlayer(void)
{
    return resume();
}

STDMETHODIMP CScalePlayer::pausePlayer(void)
{
    return pause();
}

STDMETHODIMP CScalePlayer::invalidate(void)
{
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }

    return S_OK;
}

STDMETHODIMP CScalePlayer::reset(void)
{
    OutputDebugString(L"CScalePlayer::reset\n");
    HRESULT hr = S_OK;
    VARIANT_BOOL bNeedActive;
    VARIANT_BOOL bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;

    if(!m_fInPlaceActivated)
    {
        goto done;
    }

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }
    hr = m_spTIMEState->get_isActive(&bNeedActive);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_isPaused(&bNeedPause);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_segmentTime(&dblSegTime);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_speed(&flTeSpeed);
    if(FAILED(hr))
    {
        goto done;
    }

    if( !bNeedActive) // see if we need to stop the media.
    {
        if( m_fRunning)
        {
            end();
        }
        goto done;
    }

    if (flTeSpeed <= 0.0)
    {
        hr = S_OK;
        pause();
        goto done;
    }
    if (m_dblScaleFactor != flTeSpeed)
    {
        put_scaleFactor((double)flTeSpeed);
    }


    if( !m_fRunning)
    {
        begin(); // add a seek after this

        seek(dblSegTime);
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        seek(dblSegTime);
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        pause();
    }
    else
    {
        resume();
    }
done:
    return hr;
}

STDMETHODIMP CScalePlayer::repeat(void)
{
    OutputDebugString(L"CScalePlayer::repeat\n");
    return begin();
}


STDMETHODIMP CScalePlayer::seek(double dblSeekTime)
{
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = dblSeekTime;
    if(m_spOleInPlaceSiteWindowless)
    {
        m_spOleInPlaceSiteWindowless->InvalidateRect(&m_rectSize,TRUE);
    }

    return S_OK;
}


STDMETHODIMP CScalePlayer::tick(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::put_CurrentTime(double   dblCurrentTime)
{
    m_dblTime = dblCurrentTime;
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    if(!m_fRunning)
    {
        *pdblCurrentTime = -HUGE_VAL;
        hr = S_FALSE;
        goto done;
    }

    computeTime(pdblCurrentTime);

    if(*pdblCurrentTime == m_dblNaturalDur)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

void
CScalePlayer::computeTime(double* pdblCurrentTime)
{
    updateDownloadTime();


    if(m_dblDLTime < m_dblDLDur)
    {
        m_dwLastRefTime = timeGetTime();
        m_dblTime = 0.0;
        goto done;
    }

    if (!m_fSuspended)
    {
        DWORD   dwNow;
        long    lDiff;

        dwNow   = timeGetTime();
        lDiff   = dwNow - m_dwLastRefTime;
        m_dwLastRefTime = dwNow;

        if (lDiff < 0)
        {
            lDiff = -lDiff;
        }

        m_dblTime += (lDiff / 1000.0) * m_dblScaleFactor;
        if(m_dblTime > m_dblNaturalDur)
        {
            m_dblTime = m_dblNaturalDur;
        }
    }
done:
    *pdblCurrentTime = m_dblTime;
}

void
CScalePlayer::initDownloadTime()
{
    m_dwLastDLRefTime = timeGetTime();
    m_dblDLTime = 0.0;
}

void
CScalePlayer::updateDownloadTime()
{
    DWORD dwCurrDLTime = timeGetTime();
    double dblNewDLTime;

    dblNewDLTime = (dwCurrDLTime - m_dwLastDLRefTime) / 1000.0;

    if( m_dblDLTime + dblNewDLTime > m_dblDLDur)
    {
        if(!m_fDoneDL)
        {
            m_fDoneDL = true;
            if(m_spOleInPlaceSite)
            {
                m_spOleInPlaceSite->OnPosRectChange(&m_rectSize);
            }
            NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
            m_dblDLTime = m_dblDLDur;
        }
        goto done;
    }

    m_dwLastDLRefTime = dwCurrDLTime;
    m_dblDLTime += dblNewDLTime;
done:
    return;
}

STDMETHODIMP CScalePlayer::put_src(BSTR   bstrURL)
{
    m_bstrSrc = bstrURL;
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_src(BSTR* pbstrURL)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pbstrURL, sizeof(BSTR)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pbstrURL = m_bstrSrc.Copy();
    if (NULL == *pbstrURL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_repeat(long   lTime)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_repeat(long* plTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(plTime, sizeof(long*)))
    {
        hr = E_POINTER;
        goto done;
    }

    *plTime = 1;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::cue(void)
{
    return E_NOTIMPL;
}


//
// ITIMEScalePlayer
//
STDMETHODIMP CScalePlayer::get_scaleFactor(double* pdblScaleFactor)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblScaleFactor, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pdblScaleFactor = m_dblScaleFactor;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_scaleFactor(double dblScaleFactor)
{
    double dblTime;
    HRESULT hr = S_OK;

    if(dblScaleFactor <= 0)
    {
        hr = S_FALSE;
        goto done;
    }

    computeTime(&dblTime);
    m_dblScaleFactor = dblScaleFactor;
done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_playDuration(double* pdblDuration)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblDuration, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pdblDuration = m_dblNaturalDur;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_playDuration(double dblDuration)
{
    double dblTime;
    HRESULT hr = S_OK;

    if(dblDuration <= 0)
    {
        hr = S_FALSE;
        goto done;
    }

    //NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
    m_dblNaturalDur = dblDuration;
done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_downLoadDuration(double* pdblDuration)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblDuration, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pdblDuration = m_dblDLDur;
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::put_downLoadDuration(double dblDuration)
{
    double dblTime;
    HRESULT hr = S_OK;

    if(dblDuration <= 0)
    {
        hr = S_FALSE;
        goto done;
    }

    //NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
    m_dblDLDur = dblDuration;
done:
    return S_OK;
}

STDMETHODIMP CScalePlayer::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_playerTime(double* pdblTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    if(!m_fRunning)
    {
        *pdblTime = -HUGE_VAL;
        hr = S_FALSE;
        goto done;
    }

    computeTime(pdblTime);

    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP CScalePlayer::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_FALSE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }

    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;
    if(pdbl == NULL)
    {
        goto done;
    }

    *pdbl = m_dblNaturalDur;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;
    if(pdbl == NULL)
    {
        goto done;
    }

    *pdbl = m_dblNaturalDur;

done:
    return hr;
}


STDMETHODIMP CScalePlayer::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }
    *pl = m_rectSize.bottom - m_rectSize.top;

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }

    *pl = m_rectSize.right - m_rectSize.left;
done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = S_OK;
    if(ppdisp == NULL)
    {
        goto done;
    }

    hr = this->QueryInterface(IID_IDispatch, (void **)ppdisp);

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    if(state == NULL)
    {
        goto done;
    }

done:
    return hr;
}

STDMETHODIMP CScalePlayer::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;
    if(plist == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CScalePlayer::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = QueryInterface(IID_IUnknown, (void **)control);

    return hr;
}

STDMETHODIMP CScalePlayer::GetRunningClass(LPCLSID lpClsid)
{
    HRESULT hr = E_UNEXPECTED;

    return hr;
}

STDMETHODIMP CScalePlayer::Run(LPBC lpbc)
{
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP_(BOOL)
CScalePlayer::IsRunning(void)
{
    return TRUE;
} // AddRef


STDMETHODIMP CScalePlayer::LockRunning(BOOL fLock, BOOL fLastUnlockCloses)
{
    HRESULT hr = E_UNEXPECTED;

    return hr;
}


STDMETHODIMP CScalePlayer::SetContainedObject(BOOL fContained)
{
    HRESULT hr = E_UNEXPECTED;

    return hr;
}


// If the client site is changed then an init call must ne made.
STDMETHODIMP CScalePlayer::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = S_OK;

    if(!pClientSite)
    {
        m_spOleClientSite.Release();
        m_spOleInPlaceSite.Release();
        m_spOleInPlaceSiteEx.Release();
        m_spOleInPlaceSiteWindowless.Release();
        m_spTIMEMediaPlayerSite.Release();
        m_spTIMEElement.Release();
        m_spTIMEState.Release();

        DeinitPropSink();
        goto done;
    }

    m_spOleClientSite = pClientSite;
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spOleInPlaceSite);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spOleInPlaceSiteEx);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spOleInPlaceSiteWindowless);
    if(FAILED(hr))
    {
        goto done;
    }
    
done:
    return hr;
}

STDMETHODIMP CScalePlayer::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    HRESULT hr = S_OK;

    m_rectSize.bottom = lprcPosRect->bottom;
    m_rectSize.top = lprcPosRect->top;
    m_rectSize.left = lprcPosRect->left;
    m_rectSize.right = lprcPosRect->right;

    return hr;
}

STDMETHODIMP CScalePlayer::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT hr = S_OK;
    BOOL fNoRedraw;

    if(iVerb != OLEIVERB_INPLACEACTIVATE)
    {
        hr = E_NOTIMPL;
        goto done;
    }

    if(m_spOleInPlaceSite != NULL)
    {
        if(!m_fInPlaceActivated)
        {
            if(m_spOleInPlaceSiteWindowless)
            {
                m_spOleInPlaceSiteWindowless->OnInPlaceActivateEx(&fNoRedraw, ACTIVATE_WINDOWLESS);
            }
            else
            {
                m_spOleInPlaceSite->OnInPlaceActivate();
            }
        }

        initDownloadTime();
    }
    m_fInPlaceActivated = true;


done:
    return hr;
}

HRESULT
CScalePlayer::Draw( 
            DWORD dwDrawAspect,
            LONG lindex,
            void *pvAspect,
            DVTARGETDEVICE *ptd,
            HDC hdcTargetDev,
            HDC hdcDraw,
            LPCRECTL lprcBounds,
            LPCRECTL lprcWBounds,
            BOOL ( * pfnContinue)(DWORD dwContinue),
            DWORD dwContinue)

{
    HRESULT hr = S_OK;
    HBRUSH hbr = ::CreateSolidBrush(m_clrKey);
    RECT rect;
    WCHAR buffer[50];
    int dec;
    unsigned short frac;
    double pdblCurrentTime;
    VARIANT var;
    SIZE txtSize;
    WCHAR *pStateString;

    VariantInit(&var);

    if(!m_fDoneDL)
    {
        goto done;
    }

    if(lprcBounds == NULL)
    {
        rect.bottom = m_rectSize.bottom;
        rect.top = m_rectSize.top;
        rect.left = m_rectSize.left;
        rect.right = m_rectSize.right;
    }
    else
    {
        rect.bottom = lprcBounds->bottom;
        rect.top = lprcBounds->top;
        rect.left = lprcBounds->left;
        rect.right = lprcBounds->right;
    }

    if (hbr)
    {

        ::FillRect(hdcDraw, &rect, hbr);
        ::DeleteObject(hbr);
    }

    var.vt = VT_R8;
    var.dblVal = m_dblTime;

    hr = VariantChangeType(&var, &var, 0, VT_BSTR);
    if(!GetTextExtentPoint32W( hdcDraw, var.bstrVal, wcslen(var.bstrVal), &txtSize))
    {
        goto done;
    }

    if( (txtSize.cx + 10 <= rect.right - rect.left) &&
        (txtSize.cy + 10 <= rect.bottom - rect.top))
    {
        TextOutW(hdcDraw, rect.left + 10, rect.top + 10, var.bstrVal, wcslen(var.bstrVal));
    }


    if(m_fRunning && !m_fSuspended)
    {
        pStateString = gRunnigStateString;
    }
    else if(m_fRunning && m_fSuspended)
    {
        pStateString = gPauseStateString;
    }
    else
    {
        pStateString = gInactiveStateString;
    }

    if(!GetTextExtentPoint32W( hdcDraw, pStateString, wcslen(pStateString), &txtSize))
    {
        goto done;
    }

    if( (txtSize.cx + 10 <= rect.right - rect.left) &&
        (txtSize.cy + 25 <= rect.bottom - rect.top))
    {
        TextOutW(hdcDraw, rect.left + 10, rect.top + 25, pStateString, wcslen(pStateString));
    }

done:

    VariantClear(&var);
    return hr;
}

HRESULT
CScalePlayer::CreateMessageWindow()
{
    static const TCHAR szClassName[] = TEXT("ScalePlayerWindow");
    HRESULT hr = S_OK;

    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);

    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpszClassName = szClassName;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = _Module.GetModuleInstance();

    (void)::RegisterClassEx(&wc);

    m_pwndMsgWindow = CreateWindow(
    szClassName,
    _T("VRCtlWindow"),
    0, 0, 0, 0, 0,
    (HWND)NULL, (HMENU)NULL,
    _Module.GetModuleInstance(),
    this);
    if ( m_pwndMsgWindow == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    ::SetTimer(m_pwndMsgWindow, ID_TIMER, TIMER_INT, NULL);
done:
    return hr;
}

LRESULT CALLBACK
CScalePlayer::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CScalePlayer *lpThis;
    double pdblCurrentTime;

    switch(uMsg)
    {
    case WM_CREATE:
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);

            //lpThis = (CScalePlayer *)lpcs->lpCreateParams;
            return 0;
        }
    case WM_TIMER:
        {
            //check GetWindowLongPtr for 64 bit comp.
            lpThis = (CScalePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (lpThis != NULL)
            {
                if(!(lpThis->m_fInPlaceActivated))
                {
                    return 0;
                }
                if(lpThis->m_spOleInPlaceSiteWindowless && !(lpThis->m_fSuspended) && (lpThis->m_fRunning))
                {
                    lpThis->computeTime(&pdblCurrentTime);
                    lpThis->m_spOleInPlaceSiteWindowless->InvalidateRect(&(lpThis->m_rectSize),TRUE);
                }
            }
            return 0;
        }
    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

HRESULT 
CScalePlayer::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


HRESULT
CScalePlayer::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

STDMETHODIMP
CScalePlayer::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CScalePlayer::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause();
                break;
            }
            if (m_dblScaleFactor != flTeSpeed)
            {
                put_scaleFactor((double)flTeSpeed);
            }
            break;
        default:
            break;
    }
done:
    return S_OK;
}

HRESULT
CScalePlayer::InitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

void
CScalePlayer::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\timeconv.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timeconv.cpp
//
//  Contents: implementation of CTIMENode time conversions
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Node.h"
#include "container.h"

DeclareTag(tagTIMENodeConv, "TIME: Engine", "CTIMENode time conversion methods");

double
CTIMENode::CalcNewActiveTime(double dblNewSegmentTime,
                             LONG lNewRepeatCount)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcNewActiveTime(%g, %ld)",
              this,
              dblNewSegmentTime,
              lNewRepeatCount));

    double dblRet = GetElapsedActiveRepeatTime();
    double dblSegmentDur = CalcCurrSegmentDur();
    long lRepeatDiff = lNewRepeatCount - GetCurrRepeatCount();
    
    Assert(dblNewSegmentTime <= dblSegmentDur);
    Assert(dblNewSegmentTime >= 0.0);
    Assert(lNewRepeatCount < CalcRepeatCount());
    Assert(lNewRepeatCount >= 0);
    
    // If we do not have a known duration then we cannot update
    // elapsed time
    if (dblSegmentDur != TIME_INFINITE)
    {
        dblRet += lRepeatDiff * dblSegmentDur;
    }

    dblRet += dblNewSegmentTime;

    dblRet = Clamp(0.0, dblRet, CalcEffectiveActiveDur());
    
    return dblRet;
}

void
CTIMENode::CalcActiveComponents(double dblActiveTime,
                                double & dblSegmentTime,
                                long & lRepeatCount)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveComponents(%g)",
              this,
              dblActiveTime));
    
    double dblSegmentDur = CalcCurrSegmentDur();
    
    dblActiveTime = Clamp(0.0,
                          dblActiveTime,
                          CalcCurrActiveDur());
                         
    if (dblSegmentDur == TIME_INFINITE)
    {
        lRepeatCount = 0;
        dblSegmentTime = dblActiveTime;
    }
    else
    {
        // First calc how many times we have repeated
        lRepeatCount = long(dblActiveTime / dblSegmentDur);
            
        if (lRepeatCount >= CalcRepeatCount())
        {
            lRepeatCount = ceil(CalcRepeatCount()) - 1;
        }
        
        dblSegmentTime = dblActiveTime - (lRepeatCount * dblSegmentDur);

        dblSegmentTime = Clamp(0.0,
                               dblSegmentTime,
                               dblSegmentDur);
    }
}

double
CTIMENode::CalcActiveTimeFromParentTimeNoBounds(double dblParentTime) const
{
    double dblCurrParentTime, dblRet;
    dblCurrParentTime = Clamp(GetBeginParentTime(),
                              GetCurrParentTime(),
                              GetEndParentTime());
    
    double dblDelta;
    dblDelta = dblParentTime - dblCurrParentTime;

    // How figure out if we need to reverse it and change the sign
    if (GetDirection() == TED_Backward)
    {
        dblDelta *= -1.0;
    }

    double dblNewActiveTime;

    // Now get the elapsed local time
    dblNewActiveTime = CalcElapsedLocalTime();
    
    // Add the delta
    dblNewActiveTime += dblDelta;

    // Now transform it back
    dblNewActiveTime = ApplyActiveTimeTransform(dblNewActiveTime);

    dblNewActiveTime = Clamp(0.0,
                             dblNewActiveTime,
                             CalcEffectiveActiveDur());
    
    dblRet = dblNewActiveTime;
  done:
    return dblRet;
}

double
CTIMENode::CalcActiveTimeFromParentTime(double dblParentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveTimeFromParentTime(%g)",
              this,
              dblParentTime));

    double dblRet = TIME_INFINITE;
    
    if (dblParentTime < GetBeginParentTime() ||
        dblParentTime > GetEndParentTime() ||
        GetCurrParentTime() == -TIME_INFINITE)
    {
        goto done;
    }

    dblRet = CalcActiveTimeFromParentTimeNoBounds(dblParentTime);
done:
    return dblRet;
}

double
CTIMENode::CalcActiveTimeFromParentTimeForSyncArc(double dblParentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveTimeFromParentTime(%g)",
              this,
              dblParentTime));

    double dblRet = TIME_INFINITE;
    
    if ((dblParentTime < GetBeginParentTime()) || (dblParentTime > GetEndParentTime()))
    {
        dblRet = dblParentTime - GetBeginParentTime();
        goto done;
    }
    
    dblRet = CalcActiveTimeFromParentTimeNoBounds(dblParentTime);
done:
    return dblRet;
}

double
CTIMENode::CalcParentTimeFromActiveTime(double dblActiveTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcParentTimeFromActiveTime(%g)",
              this,
              dblActiveTime));

    double dblRet = TIME_INFINITE;
    
    if (GetBeginParentTime() == TIME_INFINITE ||
        GetCurrParentTime() == -TIME_INFINITE)
    {
        goto done;
    }
    
    double dblDelta;
    dblDelta = Clamp(0.0,
                     dblActiveTime,
                     CalcEffectiveActiveDur());

    dblDelta = ReverseActiveTimeTransform(dblDelta);
    
    dblDelta -= CalcElapsedLocalTime();

    // How figure out if we need to reverse it and change the sign
    if (GetDirection() == TED_Backward)
    {
        dblDelta *= -1.0;
    }

    double dblNewParentTime;
    dblNewParentTime = Clamp(GetBeginParentTime(),
                             GetCurrParentTime(),
                             GetEndParentTime());
    
    // Add the delta
    dblNewParentTime += dblDelta;

    dblRet = dblNewParentTime;
  done:
    return dblRet;
}

double
CTIMENode::ActiveTimeToLocalTime(double dblActiveTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::ActiveTimeToLocalTime(%g)",
              this,
              dblActiveTime));

    double dblRet = Clamp(0.0,
                          dblActiveTime,
                          CalcEffectiveActiveDur());

    // First reverse the time transform
    dblRet = ReverseActiveTimeTransform(dblRet);
    
    // Now we need to deal with the direction
    // If we are moving backwards then we need to treat parent
    // movements the opposite way
    if (TEIsBackward(GetDirection()))
    {
        double dblLocalDur = CalcLocalDur();

        // For now just assume 0
        if (dblLocalDur == TIME_INFINITE)
        {
            dblRet = 0;
        }
        else
        {
            dblRet = dblLocalDur - dblRet;
        }
    }
    
    Assert(dblRet >= 0.0);
    Assert(dblRet <= CalcLocalDur());
    
    return dblRet;
}

double
CTIMENode::LocalTimeToActiveTime(double dblLocalTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::LocalTimeToActiveTime(%g)",
              this,
              dblLocalTime));

    double dblLocalDur = CalcLocalDur();
    double dblRet = Clamp(0.0,
                          dblLocalTime,
                          dblLocalDur);

    // Now we need to deal with the direction
    // If we are moving backwards then we need to treat parent
    // movements the opposite way
    if (TEIsBackward(GetDirection()))
    {
        // For now just assume 0
        if (dblLocalDur == TIME_INFINITE)
        {
            dblRet = 0;
        }
        else
        {
            dblRet = dblLocalDur - dblRet;
        }
    }
    
    // Now we need to apply the time transform
    dblRet = ApplyActiveTimeTransform(dblRet);
    
    dblRet = Clamp(0.0,
                   dblRet,
                   CalcEffectiveActiveDur());

    return dblRet;
}

double
CTIMENode::CalcActiveTimeFromSegmentTime(double dblSegmentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcActiveTimeFromSegmentTime(%g)",
              this,
              dblSegmentTime));

    double dblRet = Clamp(0.0,
                          dblSegmentTime,
                          CalcCurrSegmentDur());

    dblRet += GetElapsedActiveRepeatTime();

    dblRet = Clamp(0.0,
                   dblRet,
                   CalcEffectiveActiveDur());

    return dblRet;
}

double
CTIMENode::CalcSegmentTimeFromActiveTime(double dblActiveTime, bool bTruncate) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcSegmentTimeFromActiveTime(%g, %d)",
              this,
              dblActiveTime,
              bTruncate));

    double dblRet = Clamp(0.0,
                          dblActiveTime,
                          CalcEffectiveActiveDur());
    double dblSegmentDur = CalcCurrSegmentDur();
    
    if (dblSegmentDur == TIME_INFINITE)
    {
        if (dblRet >= GetElapsedActiveRepeatTime())
        {
            dblRet -= GetElapsedActiveRepeatTime();
        }
    }
    else
    {
        dblRet -= GetElapsedActiveRepeatTime();
        if (bTruncate)
        {
            dblRet = Clamp(0.0,
                           dblRet,
                           dblSegmentDur);
        }
        else
        {
            double dblTemp = dblRet;
            dblRet = dblRet - (long(dblRet / dblSegmentDur) * dblSegmentDur);

            if (dblRet < 0 || (dblRet == 0 && dblTemp == dblSegmentDur))
            {
                dblRet += dblSegmentDur;
            }
        }
    }
    
    Assert(dblRet <= CalcCurrSegmentDur());
    Assert(dblRet >= 0.0);
    
    dblRet = Clamp(0.0,
                   dblRet,
                   dblSegmentDur);
    
    return dblRet;
}

double
CTIMENode::SegmentTimeToSimpleTime(double segmentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::SegmentTimeToSimpleTime(%g)",
              this,
              segmentTime));

    double dblRet = segmentTime;
    
    Assert(dblRet <= CalcCurrSegmentDur());
    Assert(dblRet >= 0.0);
    
    if (IsAutoReversing(dblRet))
    {
        Assert(dblRet <= GetSegmentDur());
        dblRet = GetSegmentDur() - dblRet;
    }

    // if the speed is negative and the segment contains an 
    // autoreverse, then this transformation needs to be shifted
    // but the SimpleDuration to give the correct value.  
    if (GetSpeed() < 0.0 && GetAutoReverse())   
    {                                           
        dblRet = fabs(dblRet - GetSimpleDur()); 
    }                                           

    dblRet = ApplySimpleTimeTransform(dblRet);

    return dblRet;
}

double
CTIMENode::SimpleTimeToSegmentTime(double simpleTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::SimpleTimeToSegmentTime(%g)",
              this,
              simpleTime));

    double dblRet = simpleTime;

    dblRet = ReverseSimpleTimeTransform(dblRet);
    
    // See if the current segment was reversing and make sure we
    // adjust the simple time appropriately
    if (IsAutoReversing(GetCurrSegmentTime()))
    {
        dblRet = GetSegmentDur() - dblRet;
    }
    
    return dblRet;
}

double
CTIMENode::CalcGlobalTimeFromParentTime(double dblParentTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcGlobalTimeFromParentTime(%g)",
              this,
              dblParentTime));

    double dblRet = Clamp(GetBeginParentTime(),
                          dblParentTime,
                          GetEndParentTime());

    if (GetParent() != NULL)
    {
        dblRet = GetParent()->SimpleTimeToSegmentTime(dblRet);
        dblRet = GetParent()->CalcActiveTimeFromSegmentTime(dblRet);
        dblRet = GetParent()->CalcParentTimeFromActiveTime(dblRet);

        if (dblRet == TIME_INFINITE)
        {
            goto done;
        }
        
        dblRet = GetParent()->CalcGlobalTimeFromParentTime(dblRet);
    }
    
  done:
    return dblRet;
}

double
CTIMENode::CalcParentTimeFromGlobalTime(double dblGlobalTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcParentTimeFromGlobalTime(%g)",
              this,
              dblGlobalTime));

    double dblRet = dblGlobalTime;

    if (GetParent() != NULL)
    {
        dblRet = GetParent()->CalcParentTimeFromGlobalTime(dblRet);
        dblRet = GetParent()->CalcActiveTimeFromParentTime(dblRet);
        if (dblRet == TIME_INFINITE)
        {
            goto done;
        }
        
        dblRet = GetParent()->CalcSegmentTimeFromActiveTime(dblRet, false);
        dblRet = GetParent()->SegmentTimeToSimpleTime(dblRet);
    }
    
  done:
    return dblRet;
}

double
CTIMENode::CalcParentTimeFromGlobalTimeForSyncArc(double dblGlobalTime) const
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::CalcParentTimeFromGlobalTime(%g)",
              this,
              dblGlobalTime));

    double dblRet = dblGlobalTime;

    if (GetParent() != NULL)
    {
        dblRet = GetParent()->CalcParentTimeFromGlobalTime(dblRet);
        dblRet = GetParent()->CalcActiveTimeFromParentTimeForSyncArc(dblRet);

    }
    
  done:
    return dblRet;
}

// ---------------------------------------
// COM Methods
// ---------------------------------------

STDMETHODIMP
CTIMENode::parentTimeToActiveTime(double dblParentTime,
                                  double * pdblActiveTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::parentTimeToActiveTime(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    double dblRet = dblParentTime;

    CHECK_RETURN_NULL(pdblActiveTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcActiveTimeFromParentTime(dblRet);
    
    *pdblActiveTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::activeTimeToParentTime(double dblActiveTime,
                                  double * pdblParentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::activeTimeToParentTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;
    double dblRet = dblActiveTime;
    
    CHECK_RETURN_NULL(pdblParentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcParentTimeFromActiveTime(dblRet);
    
    *pdblParentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::parentTimeToDocumentTime(double dblParentTime,
                                  double * pdblDocumentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::parentTimeToDocumentTime(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    double dblRet = dblParentTime;

    CHECK_RETURN_NULL(pdblDocumentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcGlobalTimeFromParentTime(dblRet);
    
    *pdblDocumentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::documentTimeToParentTime(double dblDocumentTime,
                                  double * pdblParentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::documentTimeToParentTime(%g)",
              this,
              dblDocumentTime));

    HRESULT hr;
    double dblRet = dblDocumentTime;
    
    CHECK_RETURN_NULL(pdblParentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcParentTimeFromGlobalTime(dblRet);
    
    *pdblParentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::activeTimeToSegmentTime(double dblActiveTime,
                                   double * pdblSegmentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::activeTimeToSegmentTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;

    double dblRet = Clamp(0.0,
                          dblActiveTime,
                          CalcEffectiveActiveDur());
    
    CHECK_RETURN_NULL(pdblSegmentTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcSegmentTimeFromActiveTime(dblRet, false);
    
    *pdblSegmentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::segmentTimeToActiveTime(double dblSegmentTime,
                                   double * pdblActiveTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::segmentTimeToActiveTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;

    double dblRet = Clamp(0.0,
                          dblSegmentTime,
                          CalcCurrSegmentDur());
    
    CHECK_RETURN_NULL(pdblActiveTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = CalcActiveTimeFromSegmentTime(dblRet);
    
    *pdblActiveTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::simpleTimeToSegmentTime(double dblSimpleTime,
                                   double * pdblSegmentTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::simpleTimeToSegmentTime(%g)",
              this,
              dblSimpleTime));

    HRESULT hr;
    double dblRet = dblSimpleTime;

    CHECK_RETURN_NULL(pdblSegmentTime);
    
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = SimpleTimeToSegmentTime(dblRet);
    
    *pdblSegmentTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::segmentTimeToSimpleTime(double dblSegmentTime,
                                   double * pdblSimpleTime)
{
    TraceTag((tagTIMENodeConv,
              "CTIMENode(%lx)::segmentTimeToSimpleTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;
    double dblRet = dblSegmentTime;

    CHECK_RETURN_NULL(pdblSimpleTime);

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    dblRet = SegmentTimeToSimpleTime(dblRet);
    
    *pdblSimpleTime = dblRet;

    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timescal\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9C1E2F9E_ADFA_4630_82D9_4C72E294A91C__INCLUDED_)
#define AFX_STDAFX_H__9C1E2F9E_ADFA_4630_82D9_4C72E294A91C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "shlwrap.h"

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9C1E2F9E_ADFA_4630_82D9_4C72E294A91C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LCID_SCRIPTING,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) MemAlloc(Mt(Mem), size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    CComPtr<IOleContainer> pRoot;
    CComPtr<IHTMLDocument> pHTMLDoc;
    CComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    CComPtr<IDABehavior> event;
    CComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LCID_SCRIPTING,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LCID_SCRIPTING, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timescal\scaleplayer.h ===
#pragma once
#include "shlwrap.h"

#include "resource.h"       // main symbols
#include <mstime.h>


/////////////////////////////////////////////////////////////////////////////
// CScalePlayer
class ATL_NO_VTABLE CScalePlayer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CScalePlayer, &CLSID_ScalePlayer>,
    public CComControl<CScalePlayer>,
	public IDispatchImpl<ITIMEScalePlayer, &IID_ITIMEScalePlayer, &LIBID_TIMESCALELib>,
    public IOleObjectImpl<CScalePlayer>,
    public IOleInPlaceObjectWindowlessImpl<CScalePlayer>,
    public IViewObjectExImpl<CScalePlayer>,
    public IConnectionPointContainerImpl<CScalePlayer>,
    public IPropertyNotifySinkCP<CScalePlayer>,
    public IPropertyNotifySink,
    public IRunnableObject,
    public ITIMEMediaPlayerControl,
    public ITIMEMediaPlayer
{
protected:
    DWORD m_dwLastRefTime;
    double m_dblTime;
    double m_dblNaturalDur;
    DWORD m_dwLastDLRefTime;
    double m_dblDLTime;
    double m_dblDLDur;
    bool m_fDoneDL;
    double m_dblScaleFactor;
    bool m_fSuspended;
    bool m_fMediaReady;
    bool m_fRunning;
    double m_dblMediaDur;
    CComBSTR m_bstrSrc;
    HWND m_pwndMsgWindow;

    CComPtr<IOleClientSite> m_spOleClientSite;
    CComPtr<IOleInPlaceSite> m_spOleInPlaceSite;
    CComPtr<IOleInPlaceSiteEx> m_spOleInPlaceSiteEx;
    CComPtr<IOleInPlaceSiteWindowless> m_spOleInPlaceSiteWindowless;
    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    RECT m_rectSize;
    COLORREF m_clrKey;
    bool m_fInPlaceActivated;
    DWORD m_dwPropCookie;
    
public:
	CScalePlayer();

    //
    // ITIMEMediaPlayer
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;


    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_customObject)(IDispatch ** disp);

    STDMETHOD(tick)(void);


    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(get_src)(BSTR* pbstrURL);
    STDMETHOD(put_repeat)(long   lTime);
    STDMETHOD(get_repeat)(long* plTime);
    STDMETHOD(cue)(void);

    STDMETHOD(getControl)(IUnknown ** control);

    //
    // ITIMEScalePlayer
    //
    STDMETHOD(get_scaleFactor)(double* pdblScaleFactor);
    STDMETHOD(put_scaleFactor)(double dblScaleFactor);
    STDMETHOD(get_playerTime)(double* pdblTime);
    STDMETHOD(pausePlayer)();
    STDMETHOD(resumePlayer)();
    STDMETHOD(invalidate)();
    STDMETHOD(get_playDuration)(double* pdblDuration);
    STDMETHOD(put_playDuration)(double dblDuration);
    STDMETHOD(get_downLoadDuration)(double* pdblDuration);
    STDMETHOD(put_downLoadDuration)(double dblDuration);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    // IRunnableObject
    STDMETHOD(GetRunningClass)(LPCLSID lpClsid);
    STDMETHOD(Run)(LPBC lpbc);
    STDMETHOD_(BOOL, IsRunning)();
    STDMETHOD(LockRunning)(BOOL fLock, BOOL fLastUnlockCloses);
    STDMETHOD(SetContainedObject)(BOOL fContained);

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect, LPCRECT lprcClipRect);

    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
 
    HRESULT STDMETHODCALLTYPE Draw( 
            DWORD dwDrawAspect,
            LONG lindex,
            void *pvAspect,
            DVTARGETDEVICE *ptd,
            HDC hdcTargetDev,
            HDC hdcDraw,
            LPCRECTL lprcBounds,
            LPCRECTL lprcWBounds,
            BOOL ( * pfnContinue)(DWORD dwContinue),
            DWORD dwContinue);
 

DECLARE_REGISTRY_RESOURCEID(IDR_SCALEPLAYER)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CScalePlayer)
	COM_INTERFACE_ENTRY(ITIMEScalePlayer)
	COM_INTERFACE_ENTRY(IDispatch)
	//COM_INTERFACE_ENTRY(IViewObject2)
	//COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY2(IViewObject2, IViewObjectExImpl<CScalePlayer>)
    COM_INTERFACE_ENTRY2(IViewObject, IViewObjectExImpl<CScalePlayer>)
    COM_INTERFACE_ENTRY2(IOleInPlaceObject, IOleInPlaceObjectWindowlessImpl<CScalePlayer>)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
	COM_INTERFACE_ENTRY(IRunnableObject)
	COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
	COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CScalePlayer)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

BEGIN_MSG_MAP(CScalePlayer)
END_MSG_MAP()

private:

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();
    void DeinitPropSink();
    HRESULT CreateMessageWindow();
    void computeTime(double* pdblCurrentTime);
    void initDownloadTime();
    void updateDownloadTime();
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// IScalePlayer
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timescal\timescale.cpp ===
// TimeScale.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TimeScaleps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TimeScale.h"

#include "TimeScale_i.c"
#include "ScalePlayer.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ScalePlayer, CScalePlayer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transbase.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transbase.cpp
//
//  Abstract:   Implemntation of CTIMETransBase.
//
//  2000/10/02  mcalkins    Changed startPercent to startProgress.
//                          Changed endPercent to endProgress.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transbase.h"
#include "tokens.h"
#include "timeparser.h"

const LPWSTR    DEFAULT_M_TYPE          = NULL;
const LPWSTR    DEFAULT_M_SUBTYPE       = NULL;
const double    DEFAULT_M_DURATION      = 1.0;
const double    DEFAULT_M_STARTPROGRESS = 0.0;
const double    DEFAULT_M_ENDPROGRESS   = 1.0;
const LPWSTR    DEFAULT_M_DIRECTION     = NULL;
const double    DEFAULT_M_REPEAT        = 1.0;
const LPWSTR    DEFAULT_M_BEGIN         = NULL;
const LPWSTR    DEFAULT_M_END           = NULL;

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define CTB CTIMETransBase

                // Function Name // Class // Attr Accessor    // COM put_ fn  // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(CTB_Type,         CTB,    GetTypeAttr,         put_type,         get_type,            VARIANT);
TIME_PERSIST_FN(CTB_SubType,      CTB,    GetSubTypeAttr,      put_subType,      get_subType,         VARIANT);
TIME_PERSIST_FN(CTB_Duration,     CTB,    GetDurationAttr,     put_dur,          get_dur,             VARIANT);
TIME_PERSIST_FN(CTB_StartProgress,CTB,    GetStartProgressAttr,put_startProgress,get_startProgress,   VARIANT);
TIME_PERSIST_FN(CTB_EndProgress,  CTB,    GetEndProgressAttr,  put_endProgress,  get_endProgress,     VARIANT);
TIME_PERSIST_FN(CTB_Direction,    CTB,    GetDirectionAttr,    put_direction,    get_direction,       VARIANT);
TIME_PERSIST_FN(CTB_RepeatCount,  CTB,    GetRepeatCountAttr,  put_repeatCount,  get_repeatCount,     VARIANT);
TIME_PERSIST_FN(CTB_Begin,        CTB,    GetBeginAttr,        put_begin,        get_begin,           VARIANT);
TIME_PERSIST_FN(CTB_End,          CTB,    GetEndAttr,          put_end,          get_end,             VARIANT);

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMETransBase)
                           // Attr Name         // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,             CTB_Type )
    PERSISTENCE_MAP_ENTRY( WZ_SUBTYPE,          CTB_SubType )
    PERSISTENCE_MAP_ENTRY( WZ_DUR,              CTB_Duration )
    PERSISTENCE_MAP_ENTRY( WZ_STARTPROGRESS,    CTB_StartProgress )
    PERSISTENCE_MAP_ENTRY( WZ_ENDPROGRESS,      CTB_EndProgress )
    PERSISTENCE_MAP_ENTRY( WZ_DIRECTION,        CTB_Direction )
    PERSISTENCE_MAP_ENTRY( WZ_REPEATCOUNT,      CTB_RepeatCount )
    PERSISTENCE_MAP_ENTRY( WZ_BEGIN,            CTB_Begin )
    PERSISTENCE_MAP_ENTRY( WZ_END,              CTB_End )

END_TIME_PERSISTENCE_MAP()


//+-----------------------------------------------------------------------
//
//  Member: CTIMETransBase::CTIMETransBase
//
//------------------------------------------------------------------------
CTIMETransBase::CTIMETransBase() :
    m_SAType(DEFAULT_M_TYPE),
    m_SASubType(DEFAULT_M_SUBTYPE),
    m_DADuration(DEFAULT_M_DURATION),
    m_DAStartProgress(DEFAULT_M_STARTPROGRESS),
    m_DAEndProgress(DEFAULT_M_ENDPROGRESS),
    m_SADirection(DEFAULT_M_DIRECTION),
    m_DARepeatCount(DEFAULT_M_REPEAT),
    m_SABegin(DEFAULT_M_BEGIN),
    m_SAEnd(DEFAULT_M_END),
    m_fHavePopulated(false),
    m_fInLoad(false),
    m_fDirectionForward(true)
{
}
//  Member: CTIMETransBase::CTIMETransBase


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::~CTIMETransBase
//
//------------------------------------------------------------------------------
CTIMETransBase::~CTIMETransBase()
{
}
//  Member: CTIMETransBase::~CTIMETransBase


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::_ReadyToInit
//
//------------------------------------------------------------------------------
bool
CTIMETransBase::_ReadyToInit()
{
    bool bRet = false;

    if (m_spHTMLElement == NULL) 
    {
        goto done;
    }

    if (m_spHTMLElement2 == NULL)
    {
        goto done;
    }

    if (m_spHTMLTemplate == NULL)
    {
        goto done;
    }

    if (!m_fHavePopulated)
    {
        goto done;
    }

    bRet = true;

done:

    return bRet;
}
//  Member: CTIMETransBase::_ReadyToInit


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::Init
//
//  Overview:   Initializes protected m_spTransWorker with an ITransitionWorker.
//              Must be called during OnLoad.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::Init()
{
    HRESULT hr = S_OK;

    if (!_ReadyToInit())
    {
        hr = THR(E_FAIL);

        goto done;
    }

    hr = THR(_GetMediaSiteFromHTML());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::CreateTransitionWorker(&m_spTransWorker));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransWorker->put_transSite(this));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransWorker->InitFromTemplate());

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::Init


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransBase::Detach
//
//  Overview:  Detaches from ITransitionWorker, and releases all interfaces held
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::Detach()
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        m_spTransWorker->Detach();
    }

    m_spTransWorker.Release();
    m_spHTMLElement.Release();
    m_spHTMLElement2.Release();
    m_spHTMLTemplate.Release();

    m_spTransitionSite.Release();

done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransBase::PopulateFromTemplateElement
//
//  Overview:  Persistence in from the template
//
//  Arguments: void
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CTIMETransBase::PopulateFromTemplateElement()
{
    HRESULT hr = S_OK;

    Assert(m_spHTMLTemplate != NULL);
    Assert(!m_fHavePopulated);

    if (!::IsElementTransition(m_spHTMLTemplate))
    {
        hr = THR(E_FAIL);
        goto done;
    }

    m_fInLoad = true;

    hr = THR(::TimeElementLoad(this, CTIMETransBase::PersistenceMap, m_spHTMLTemplate));
    
    m_fInLoad = false;

    if (FAILED(hr))
    {
        goto done;
    }

    m_fHavePopulated = true;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::PopulateFromPropertyBag
//
//  Overview:  
//      Persistence in from property bag.
//
//  Arguments: 
//      pPropBag    property bag to read from.
//      pErrorLog   Where to write errors out to.
//             
//------------------------------------------------------------------------------
HRESULT
CTIMETransBase::PopulateFromPropertyBag(IPropertyBag2 * pPropBag, IErrorLog * pErrorLog)
{
    HRESULT hr = S_OK;

    Assert(!m_fHavePopulated);
    Assert(pPropBag);

    m_fInLoad = true;

    hr = THR(::TimeLoad(this, CTIMETransBase::PersistenceMap, pPropBag, pErrorLog));
    
    m_fInLoad = false;

    if (FAILED(hr))
    {
        goto done;
    }

    m_fHavePopulated = true;

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransBase::PopulateFromPropertyBag


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::_GetMediaSiteFromHTML
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::_GetMediaSiteFromHTML()
{
    HRESULT hr = S_OK;
    
    CComPtr<ITIMEElement> spTimeElem;
    hr = THR(::FindTIMEInterface(m_spHTMLElement, &spTimeElem));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spTimeElem->QueryInterface(IID_TO_PPV(ITIMETransitionSite, 
                                                   &m_spTransitionSite)));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::_GetMediaSiteFromHTML


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_htmlElement
//
//  Overview:  
//      Returns an addrefed pointer to the html element to apply the transition
//      to.
//
//  Arguments: 
//      ppHTMLElement   Where to store the pointer.
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_htmlElement(IHTMLElement ** ppHTMLElement)
{
    HRESULT hr = S_OK;

    Assert(ppHTMLElement);
    Assert(!*ppHTMLElement);

    if (NULL == ppHTMLElement)
    {
        hr = E_POINTER;

        goto done;
    }

    if (NULL != *ppHTMLElement)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (m_spHTMLElement)
    {
        *ppHTMLElement = m_spHTMLElement;

        (*ppHTMLElement)->AddRef();
    }
    else
    {
        hr = E_FAIL;

        goto done;
    }

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_htmlElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_template
//
//  Overview:  
//      Returns an addrefed pointer to the html element to read properties from.
//
//  Arguments: 
//      ppHTMLElement   Where to store the pointer.
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_template(IHTMLElement ** ppHTMLElement)
{
    HRESULT hr = S_OK;

    Assert(ppHTMLElement);
    Assert(!*ppHTMLElement);

    if (NULL == ppHTMLElement)
    {
        hr = E_POINTER;

        goto done;
    }

    if (NULL != *ppHTMLElement)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (m_spHTMLTemplate)
    {
        *ppHTMLElement = m_spHTMLTemplate;

        (*ppHTMLElement)->AddRef();
    }
    else
    {
        hr = E_FAIL;

        goto done;
    }
    
done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_template


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_type
//
//  Overview:  returns the type attribute set on the Transition
//
//  Arguments: type - where to store the type string
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_type(VARIANT * type)
{
    HRESULT hr = S_OK;

    if (NULL == type)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(type));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(type)      = VT_BSTR;
    V_BSTR(type)    = m_SAType.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_type, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_type, ITIMETransitionElement
//
//  Overview:  
//      Modifies the type attribute set on the transition.
//
//  Arguments: 
//      type    New type.
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_type(VARIANT type)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &type, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SAType.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_type, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_subType, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_subType(VARIANT * subtype)
{
    HRESULT hr = S_OK;

    Assert(subtype);

    if (NULL == subtype)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(subtype));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(subtype)   = VT_BSTR;
    V_BSTR(subtype) = m_SASubType.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_subType, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_subType, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_subType(VARIANT subtype)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &subtype, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SASubType.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_subType, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_dur, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_dur(VARIANT * dur)
{
    HRESULT hr = S_OK;

    if (NULL == dur)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(dur));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(dur) = VT_R8;
    V_R8(dur) = m_DADuration;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_dur, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_dur, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_dur(VARIANT dur)
{
    HRESULT     hr      = S_OK;
    double      dblTemp = DEFAULT_M_DURATION;

    CTIMEParser Parser(&dur);

    hr = THR(Parser.ParseDur(dblTemp));

    if (FAILED(hr))
    {
        goto done;
    }

    if (dblTemp < 0.0)
    {
        hr = E_INVALIDARG;

        goto done;
    }

        
    m_DADuration.SetValue(dblTemp);

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_dur, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_startProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_startProgress(VARIANT * startProgress)
{
    HRESULT hr = S_OK;

    if (NULL == startProgress)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(startProgress));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(startProgress) = VT_R8;
    V_R8(startProgress) = m_DAStartProgress;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_startProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_startProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_startProgress(VARIANT startProgress)
{
    HRESULT hr = S_OK;

    {
        CComVariant varStartProg;

        hr = THR(VariantChangeTypeEx(&varStartProg, &startProgress, LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE, VT_R8));

        if (FAILED(hr))
        {
            goto done;
        }

        m_DAStartProgress.SetValue(V_R8(&varStartProg));
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_startProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_endProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_endProgress(VARIANT * endProgress)
{
    HRESULT hr = S_OK;

    if (NULL == endProgress)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(endProgress));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(endProgress) = VT_R8;
    V_R8(endProgress) = m_DAEndProgress;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_endProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_endProgress, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_endProgress(VARIANT endProgress)
{
    HRESULT hr = S_OK;

    {
        CComVariant varEndProg;

        hr = THR(VariantChangeTypeEx(&varEndProg, &endProgress, LCID_SCRIPTING, 
                                     VARIANT_NOUSEROVERRIDE, VT_R8));

        if (FAILED(hr))
        {
            goto done;
        }

        m_DAEndProgress.SetValue(V_R8(&varEndProg));
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_endProgress, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_direction, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_direction(VARIANT * direction)
{
    HRESULT hr = S_OK;

    if (NULL == direction)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(direction));

    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(direction)     = VT_BSTR;
    V_BSTR(direction)   = m_SADirection.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_direction, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_direction, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_direction(VARIANT direction)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    // ##ISSUE - do we need to check for forward/reverse here?
    //           that is, is it ok to persist an invalid value back out?

    hr = THR(VariantChangeTypeEx(&var, &direction, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SADirection.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    if (0 == StrCmpIW(var.bstrVal, WZ_REVERSE))
    {
        m_fDirectionForward = false;
    }
    else if (0 == StrCmpIW(var.bstrVal, WZ_FORWARD))
    {
        m_fDirectionForward = true;
    }

    // Ask derived class if they would like to react to a change in direction.

    hr = THR(OnDirectionChanged());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::put_direction, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_repeatCount, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_repeatCount(VARIANT * repeatCount)
{
    HRESULT hr = S_OK;

    if (NULL == repeatCount)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(repeatCount));

    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(repeatCount) = VT_R8;
    V_R8(repeatCount) = m_DARepeatCount;

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_repeatCount


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_repeatCount, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_repeatCount(VARIANT repeatCount)
{
    HRESULT hr = S_OK;

    {
        CComVariant varRepCount;

        hr = THR(VariantChangeTypeEx(&varRepCount, &repeatCount, LCID_SCRIPTING, 
                                     VARIANT_NOUSEROVERRIDE, VT_R8));

        if (FAILED(hr))
        {
            goto done;
        }

        m_DARepeatCount.SetValue(V_R8(&varRepCount));
    }

    hr = S_OK;

done:

    RRETURN(S_OK);
}
//  Member: CTIMETransBase::put_repeatCount, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_begin, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_begin(VARIANT *begin)
{
    HRESULT hr = S_OK;

    if (NULL == begin)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(begin));

    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(begin)     = VT_BSTR;
    V_BSTR(begin)   = m_SABegin.GetValue();

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_begin, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_begin, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_begin(VARIANT begin)
{
    HRESULT     hr  = S_OK;
    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &begin, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SABegin.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(S_OK);
}
//  Member: CTIMETransBase::put_begin, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::get_end, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::get_end(VARIANT * end)
{
    HRESULT hr = S_OK;

    if (NULL == end)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = THR(VariantClear(end));

    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(end)   = VT_BSTR;
    V_BSTR(end) = m_SAEnd.GetValue();

    hr = S_OK;  

done:

    RRETURN(hr);
}
//  Member: CTIMETransBase::get_end, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::put_end, ITIMETransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransBase::put_end(VARIANT end)
{
    HRESULT hr = S_OK;

    CComVariant var;

    hr = THR(VariantChangeTypeEx(&var, &end, LCID_SCRIPTING, 
                                 VARIANT_NOUSEROVERRIDE, VT_BSTR));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SAEnd.SetValue(var.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(S_OK);
}
//  Member: CTIMETransBase::put_end, ITIMETransitionElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::OnBegin
//
//------------------------------------------------------------------------------
void
CTIMETransBase::OnBegin()
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        double dblProgress = 0.0;

        // Start progress must be less than or equal to end progress or else we
        // treat start and end progress as 0.0 and 1.0.

        if (m_DAStartProgress.GetValue() <= m_DAEndProgress.GetValue())
        {
            dblProgress = m_DAStartProgress;
        }

        IGNORE_HR(m_spTransWorker->OnBeginTransition());
        IGNORE_HR(m_spTransWorker->put_progress(dblProgress));
    }

    hr = S_OK;

done:

    return;
}
//  Member: CTIMETransBase::OnBegin


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransBase::OnEnd
//
//------------------------------------------------------------------------------
void
CTIMETransBase::OnEnd()
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        double dblProgress = 1.0;

        // Start progress must be less than or equal to end progress or else we
        // treat start and end progress as 0.0 and 1.0.

        if (m_DAStartProgress.GetValue() <= m_DAEndProgress.GetValue())
        {
            dblProgress = m_DAEndProgress;
        }

        IGNORE_HR(m_spTransWorker->put_progress(dblProgress));
        IGNORE_HR(m_spTransWorker->OnEndTransition());
    }

    hr = S_OK;

done:

    return;
}
//  Member: CTIMETransBase::OnEnd


void
CTIMETransBase::OnRepeat()
{
    HRESULT hr = S_OK;

    hr = THR(FireEvent(TE_ONTRANSITIONREPEAT));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return;
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransBase::FireEvent
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransBase::FireEvent(TIME_EVENT event)
{
    HRESULT hr = S_OK;

    if (m_spTransitionSite)
    {
        hr = THR(m_spTransitionSite->FireTransitionEvent(event));

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTIMETransBase::FireEvent


// the timing engine will not calculate progress without an explicit duration set on a timing node.
double
CTIMETransBase::CalcProgress(ITIMENode * pNode)
{
    double dblRet = 1.0;

    double dblActiveTime;
    double dblActiveEnd;
    double dblActiveBegin;

    if (NULL == pNode)
        goto done;
    
    IGNORE_HR(pNode->get_currActiveTime(&dblActiveTime));
    IGNORE_HR(pNode->get_endParentTime(&dblActiveEnd));
    IGNORE_HR(pNode->get_beginParentTime(&dblActiveBegin));

    // if dblActiveEnd is INFINITE, dblRet should be 0
    dblRet = dblActiveTime / (dblActiveEnd - dblActiveBegin);

done:
    return dblRet;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransBase::OnProgressChanged
//
//  Overview:  Event handler for progress changes
//
//  Arguments: dblProgress - new progress
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
void
CTIMETransBase::OnProgressChanged(double dblProgress)
{
    HRESULT hr = S_OK;

    if (m_spTransWorker)
    {
        hr = THR(m_spTransWorker->put_progress(dblProgress));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transbase.h ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transbase.h
//
//  Abstract:   Declaration of CTIMETransBase.
//
//  2000/10/02  mcalkins    Changed startPercent to startProgress.
//                          Changed endPercent to endProgress.
//
//------------------------------------------------------------------------------

#ifndef _TRANSBASE_H__
#define _TRANSBASE_H__

#pragma once

#include "trans.h"
#include "transworker.h"
#include "transsite.h"
#include "attr.h"
#include "eventmgr.h"

class 
ATL_NO_VTABLE
__declspec(uuid("3b2716d3-0cfb-4f2f-8ff1-9bc7cb2a3a66"))
CTIMETransBase :
    public ITransitionSite
{
    //
    // Flags.
    //

protected:

    unsigned                    m_fHavePopulated    : 1;
    unsigned                    m_fInLoad           : 1;
    unsigned                    m_fDirectionForward : 1;

    //
    // Member variables.
    //

protected:

    // Attributes.

    CAttrString     m_SAType;
    CAttrString     m_SASubType;
    CAttr<double>   m_DAStartProgress;
    CAttr<double>   m_DAEndProgress;
    CAttrString     m_SADirection;
    CAttr<double>   m_DADuration;
    CAttr<double>   m_DARepeatCount;
    CAttrString     m_SABegin;
    CAttrString     m_SAEnd;

    CComPtr<ITransitionWorker>  m_spTransWorker;
    CComPtr<IHTMLElement>       m_spHTMLElement;
    CComPtr<IHTMLElement2>      m_spHTMLElement2;
    CComPtr<IHTMLElement>       m_spHTMLTemplate;
    CComPtr<ITIMETransitionSite>    m_spTransitionSite;

    //
    // Methods.
    //

private:

    STDMETHOD(_GetMediaSiteFromHTML)();

    bool    _ReadyToInit();

protected:

    // Event handlers.

    STDMETHOD_(void, OnProgressChanged)(double dblProgress);
    STDMETHOD_(void, OnBegin)();
    STDMETHOD_(void, OnEnd)();
    STDMETHOD_(void, OnRepeat)();

    STDMETHOD(OnDirectionChanged)() PURE;

    STDMETHOD(FireEvent)(TIME_EVENT event);

    STDMETHOD(PopulateFromTemplateElement)();
    STDMETHOD(PopulateFromPropertyBag)(IPropertyBag2 *  pPropBag, 
                                       IErrorLog *      pErrorLog);

    static TIME_PERSISTENCE_MAP PersistenceMap[];

    double CalcProgress(ITIMENode * pNode);

public:

    CTIMETransBase();
    virtual ~CTIMETransBase();

    STDMETHOD(Init)();
    STDMETHOD(Detach)();

    // ITransitionSite methods.

    STDMETHOD(get_htmlElement)(IHTMLElement ** ppHTMLElement);
    STDMETHOD(get_template)(IHTMLElement ** ppHTMLElement);

    // ITIMETransitionElement properties.

    STDMETHOD(get_type)(VARIANT *type);        
    STDMETHOD(put_type)(VARIANT type);        
    STDMETHOD(get_subType)(VARIANT *subtype);        
    STDMETHOD(put_subType)(VARIANT subtype);        
    STDMETHOD(get_startProgress)(VARIANT * startProgress);
    STDMETHOD(put_startProgress)(VARIANT startProgress);
    STDMETHOD(get_endProgress)(VARIANT * endProgress);
    STDMETHOD(put_endProgress)(VARIANT endProgress);
    STDMETHOD(get_direction)(VARIANT *direction);
    STDMETHOD(put_direction)(VARIANT direction);
    STDMETHOD(get_begin)(VARIANT *begin);
    STDMETHOD(put_begin)(VARIANT begin);
    STDMETHOD(get_end)(VARIANT * end);
    STDMETHOD(put_end)(VARIANT end);
    STDMETHOD(get_repeatCount)(VARIANT * repeatCount);
    STDMETHOD(put_repeatCount)(VARIANT repeatCount);
    STDMETHOD(get_dur)(VARIANT * dur);
    STDMETHOD(put_dur)(VARIANT dur); 

    // Persistance value accessors

    CAttrString   & GetTypeAttr()           { return m_SAType; }
    CAttrString   & GetSubTypeAttr()        { return m_SASubType; }
    CAttr<double> & GetDurationAttr()       { return m_DADuration; }
    CAttr<double> & GetStartProgressAttr()  { return m_DAStartProgress; }
    CAttr<double> & GetEndProgressAttr()    { return m_DAEndProgress; }
    CAttrString   & GetDirectionAttr()      { return m_SADirection; }
    CAttr<double> & GetRepeatCountAttr()    { return m_DARepeatCount; }
    CAttrString   & GetBeginAttr()          { return m_SABegin; }
    CAttrString   & GetEndAttr()            { return m_SAEnd; }
};

#endif //_TRANSBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transmap.h ===
#ifndef _TRANSMAP_H__
#define _TRANSMAP_H__

#pragma once

HRESULT MapTypesToDXT(LPWSTR pszType, LPWSTR pszSubType, LPWSTR * ppszOut);


#endif // _TRANSMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transout.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transout.cpp
//
//  Abstract:   Implementation of CTIMETransOut
//
//  2000/09/15  mcalkins    Add explicit support for transitioning out.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "trans.h"
#include "transsink.h"

DeclareTag(tagTransitionOut, "TIME: Behavior", "CTIMETransOut methods")




class
ATL_NO_VTABLE
__declspec(uuid("6b2b104a-b13d-4b15-90be-1e8f6f7471da"))
CTIMETransOut :
    public CTIMETransSink
{
public:

    CTIMETransOut();

protected:

    // CTIMETransBase overrides.

    STDMETHOD(OnDirectionChanged)();

    STDMETHOD_(void, OnBegin)();
    STDMETHOD_(void, OnEnd)();

    // CTIMETransSink overrides.

    STDMETHOD(PopulateNode)(ITIMENode * pNode);
    STDMETHOD_(void, PreApply)();
    STDMETHOD_(void, PostApply)();
};


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransOut::CTIMETransOut
//
//------------------------------------------------------------------------------
CTIMETransOut::CTIMETransOut()
{
    // Base class member initialization. (CTIMETransSink)

    m_eDXTQuickApplyType = DXTQAT_TransitionOut;
}
//  Method: CTIMETransOut::CTIMETransOut


//+-----------------------------------------------------------------------
//
//  Function:  CreateTransOut
//
//  Overview:  Create a CTIMETransOut, and return a ITransitionElement pointer to it
//
//  Arguments: ppTransElement - where to stuff the pointer
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CreateTransOut(ITransitionElement ** ppTransElement)
{
    HRESULT hr;
    CComObject<CTIMETransOut> * sptransOut;

    hr = THR(CComObject<CTIMETransOut>::CreateInstance(&sptransOut));
    if (FAILED(hr))
    {
        goto done;
    }

    if (ppTransElement)
    {
        *ppTransElement = sptransOut;
        (*ppTransElement)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransOut::OnDirectionChanged, CTIMETransBase
//
//  Overview:
//      Although a "transout" always gives the visual impression of
//      transitioning the element from a visible state to a non-visible state,
//      when the direction is reversed we actually do a reverse "transin" to
//      give the impression that the direction has reversed.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransOut::OnDirectionChanged()
{
    if (m_fDirectionForward)
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionOut;
    }
    else
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionIn;
    }

    return S_OK;
}
//  Method: CTIMETransOut::OnDirectionChanged


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransOut::PopulateNode, CTIMETransSink
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransOut::PopulateNode(ITIMENode * pNode)
{
    HRESULT hr      = S_OK;
    LONG    lCookie = 0;

    hr = THR(CTIMETransSink::PopulateNode(pNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->addBeginSyncArc(GetMediaTimeNode(),
                                    TE_TIMEPOINT_END,
                                    -1.0 * GetDurationAttr() * GetRepeatCountAttr(),
                                    &lCookie));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTIMETransOut::PopulateNode, CTIMETransSink


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::PreApply
//
//  Overview:  Event handler for before apply is called on the transition
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransOut::PreApply()
{
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::PostApply
//
//  Overview:  Event handler for after apply is called on the transition
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransOut::PostApply()
{
    // TODO (mcalkins)  Move this to set the visibility of the element to
    //                  false _after_ the transition is complete.  Some
    //                  sort of similar adjustment needs to be made for
    //                  transin as well.

    // ::SetVisibility(m_spHTMLElement, false);
}


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::OnBegin
//
//+-----------------------------------------------------------------------
void
CTIMETransOut::OnBegin (void)
{
    CTIMETransSink::OnBegin();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONOUTBEGIN));
} // CTIMETransOut::OnBegin


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransOut::OnEnd
//
//+-----------------------------------------------------------------------
void
CTIMETransOut::OnEnd (void)
{
    CTIMETransSink::OnEnd();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONOUTEND));
} // CTIMETransOut::OnEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transsink.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transsink.cpp
//
//  Abstract:   Implementation of CTIMETransSink
//
//  2000/09/15  mcalkins    Add explicit support for transitioning in or out.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transsink.h"

DeclareTag(tagTransSink, "SMIL Transitions", "Transition sink methods");
DeclareTag(tagTransSinkEvents, "SMIL Transitions", "Transition sink events");

//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransSink::CTIMETransSink
//
//------------------------------------------------------------------------------
CTIMETransSink::CTIMETransSink() :
#ifdef DBG
    m_fHaveCalledInit(false),
#endif
    m_SATemplate(NULL),
    m_fHaveCalledApply(false),
    m_fInReset(false),
    m_fPreventDueToFill(false),
    m_eDXTQuickApplyType(DXTQAT_TransitionIn)
{
}
//  Member: CTIMETransSink::CTIMETransSink

    
//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransSink::ReadyToInit
//
//------------------------------------------------------------------------------
bool
CTIMETransSink::ReadyToInit()
{
    bool bRet = false;

    if (m_spTIMEElement == NULL)
    {
        goto done;
    }

    bRet = true;

done:

    return bRet;
}
//  Member: CTIMETransSink::ReadyToInit


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransSink::Init
//
//  Overview:  
//      Initialize connection to media element, populate template data.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::Init()
{
    HRESULT hr = S_OK;

    if (!ReadyToInit())
    {
        hr = THR(E_FAIL);
        goto done;
    }

    hr = THR(FindTemplateElement());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CTIMETransBase::PopulateFromTemplateElement());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CTIMETransBase::Init());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CreateTimeBehavior());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::Detach
//
//  Overview:  Detaches from media element, releases all pointers
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::Detach()
{
    CTIMETransBase::Detach();

    m_spTIMEElement.Release();

    // release timing nodes - remove node from parent - remove any begins and ends
    if (m_spParentContainer)
    {
        IGNORE_HR(m_spParentContainer->removeNode(m_spTimeNode));
    }
    
    if (m_spTimeNode)
    {
        IGNORE_HR(m_spTimeNode->removeBehavior(this));
        IGNORE_HR(m_spTimeNode->removeBegin(0));
        IGNORE_HR(m_spTimeNode->removeEnd(0));
    }

    m_spParentContainer.Release();
    m_spTimeParent.Release();
    m_spMediaNode.Release();
    m_spTimeNode.Release();

    RRETURN(S_OK);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::FindTemplateElement
//
//  Overview:  Populates m_spHTMLTemplate
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CTIMETransSink::FindTemplateElement()
{
    HRESULT hr = S_OK;
    CComBSTR bstrTemplate;

    bstrTemplate = m_SATemplate.GetValue();
    if (bstrTemplate == NULL)
    {
        hr = THR(E_OUTOFMEMORY);
        goto done;
    }

    hr = THR(::FindHTMLElement(bstrTemplate, m_spHTMLElement, &m_spHTMLTemplate));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_spHTMLTemplate != NULL);

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::put_template
//
//  Overview:  Stores the id for the template element to read Transition attributes from
//             call this exactly once before calling init
//
//  Arguments: pwzTemplate - template id
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::put_template(LPWSTR pwzTemplate)
{
    HRESULT hr = S_OK;

    Assert(pwzTemplate != NULL);
#ifdef DBG
    {
        CComBSTR bstr = m_SATemplate.GetValue();
        
        Assert(bstr == NULL);
    }
#endif //DBG

    // ##TODO - use the atom table for this - don't make extra copies
    hr = THR(m_SATemplate.SetValue(pwzTemplate));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::put_htmlElement
//
//  Overview:  stores the html element associated with this Transition
//             queries for an htmlelement2 pointer
//             call this exactly once before calling init
//
//  Arguments: pHTMLElement - html element to attach to
//             
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::put_htmlElement(IHTMLElement * pHTMLElement)
{
    HRESULT hr = S_OK;

    Assert(m_spHTMLElement == NULL);
    Assert(m_spHTMLElement2 == NULL);

    m_spHTMLElement = pHTMLElement;

    if (m_spHTMLElement)
    {
        hr = THR(m_spHTMLElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &m_spHTMLElement2)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::put_timeElement
//
//  Overview:  stores the html+time element associated with this Transition
//             queries for an CTIMEElementBase pointer
//             call this exactly once before calling init
//
//  Arguments: pTIMEElement - time element to attach to
//             
//------------------------------------------------------------------------
STDMETHODIMP
CTIMETransSink::put_timeElement(ITIMEElement * pTIMEElement)
{
    HRESULT hr = S_OK;

    Assert(NULL != pTIMEElement);
    Assert(m_spTIMEElement == NULL);

    m_spTIMEElement = pTIMEElement;

    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransSink::ApplyIfNeeded
//
//  Overview:  call apply on Transition worker if this is the first time in transition active
//
//  Arguments: void
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CTIMETransSink::ApplyIfNeeded()
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vb = VARIANT_FALSE;

    if (m_fHaveCalledApply || m_fInReset)
    {
        hr = S_OK;
        goto done;
    }

    if (!GetTimeNode())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(GetTimeNode()->get_isActive(&vb));
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_spTransWorker && VARIANT_TRUE == vb)
    {
        PreApply();       
        hr = m_spTransWorker->Apply(m_eDXTQuickApplyType);
        PostApply();
        
        if (FAILED(hr))
        {
            goto done;
        }
        m_fHaveCalledApply = true;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransSink::CreateTimeBehavior
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransSink::CreateTimeBehavior()
{
    HRESULT hr = S_OK;

    hr = THR(::TECreateBehavior(L"TransSink", &m_spTimeNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTimeNode->addBehavior(this));

    if (FAILED(hr))
    {
        goto done;
    }

    // ##ISSUE: (mcalkins) This assert is fine, but we should make sure that we
    //          disable the object from inside once we realize we haven't
    //          populated our media site so that this assert will never fire
    //          under any conditions.

    Assert(!!m_spTransitionSite);

    hr = THR(m_spTransitionSite->get_timeParentNode(&m_spTimeParent));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransitionSite->get_node(&m_spMediaNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTimeParent->QueryInterface(IID_TO_PPV(ITIMEContainer, &m_spParentContainer)));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_spParentContainer->addNode(m_spTimeNode));

    if (FAILED(hr))
    {
        goto done;
    }

    // virtual call - children handle this.

    hr = THR(PopulateNode(m_spTimeNode));

    if (FAILED(hr))
    {
        goto done;
    }

    m_fInReset = true;

    hr = THR(m_spTimeNode->reset());

    m_fInReset = false;

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTIMETransSink::CreateTimeBehavior


HRESULT
CTIMETransSink::PopulateNode(ITIMENode * pNode)
{
    HRESULT hr = S_OK;

    hr = THR(pNode->put_repeatCount(GetRepeatCountAttr()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->put_dur(GetDurationAttr()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->put_fill(TE_FILL_FREEZE));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->put_restart(TE_RESTART_WHEN_NOT_ACTIVE));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

void
CTIMETransSink::OnProgressChanged(double dblProgress)
{
    if (false == m_fPreventDueToFill)
    {
        IGNORE_HR(ApplyIfNeeded());
        CTIMETransBase::OnProgressChanged(dblProgress);
    }

    return;
}

STDMETHODIMP
CTIMETransSink::propNotify(DWORD tePropTypes)
{
    if (tePropTypes & TE_PROPERTY_PROGRESS)
    {
        double  dblProgressStart    = 0.0;
        double  dblProgressEnd      = 1.0;
        double  dblProgress         = 0.0;

        // Start progress must be less than or equal to end progress or else we
        // treat start and end progress as 0.0 and 1.0.

        if (m_DAStartProgress.GetValue() <= m_DAEndProgress.GetValue())
        {
            dblProgressStart    = m_DAStartProgress;
            dblProgressEnd      = m_DAEndProgress;
        }

        if (m_spTimeNode)
        {
            IGNORE_HR(m_spTimeNode->get_currProgress(&dblProgress));
        }

        dblProgress = ::InterpolateValues(dblProgressStart, 
                                          dblProgressEnd,
                                          dblProgress);

        if (!m_fDirectionForward)
        {
            dblProgress = 1.0 - dblProgress;
        }

        OnProgressChanged(dblProgress);
    }

    return S_OK;
}

STDMETHODIMP
CTIMETransSink::tick()
{
    return S_OK;
}

void
CTIMETransSink::OnBegin (void)
{
    HRESULT hr = S_OK;
    TE_FILL_FLAGS te_fill = TE_FILL_REMOVE;
    
    m_fPreventDueToFill = false;
    hr = m_spMediaNode->get_fill(&te_fill);
    if (FAILED(hr))
    {
        goto done;
    }

    if (TE_FILL_REMOVE == te_fill)
    {
        CTIMETransBase::OnBegin();
    }
    else
    {
        m_fPreventDueToFill = true;
    }

done :
    return;
} // CTIMETransSink::OnBegin

void
CTIMETransSink::OnEnd (void)
{
    if (false == m_fPreventDueToFill)
    {
        CTIMETransBase::OnEnd();
    }
    m_fPreventDueToFill = false;
} // CTIMETransSink::OnEnd

STDMETHODIMP
CTIMETransSink::eventNotify(double dblEventTime,
                            TE_EVENT_TYPE teEventType,
                            long lNewRepeatCount)
{
#ifdef DBG
    double dblParentTime, dblCurrTime;
    m_spTimeNode->get_currSimpleTime(&dblCurrTime);
    m_spTimeNode->activeTimeToParentTime(dblCurrTime, &dblParentTime);
#endif

    switch(teEventType)
    {
    case TE_EVENT_BEGIN:
        OnBegin();
        TraceTag((tagTransSinkEvents, 
                  "OnBegin parentTime = %g currentTime=%g repeatCount=%ld", 
                  dblParentTime, dblCurrTime, lNewRepeatCount));
        break;
    case TE_EVENT_END:
        OnEnd();
        TraceTag((tagTransSinkEvents,
                  "OnEnd parentTime = %g currentTime=%g repeatCount=%ld", 
                  dblParentTime, dblCurrTime, lNewRepeatCount));
        break;
    case TE_EVENT_REPEAT:
        OnRepeat();
        TraceTag((tagTransSinkEvents, 
                  "OnRepeat parentTime = %g currentTime=%g repeatCount=%ld", 
                  dblParentTime, dblCurrTime, lNewRepeatCount));
        break;
    default:
        break;
    }

    return S_OK;
}

STDMETHODIMP
CTIMETransSink::getSyncTime(double * dblNewSegmentTime,
                            LONG * lNewRepeatCount,
                            VARIANT_BOOL * bCueing)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transmap.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transmap.cpp
//
//  Abstract:   Tables and functions that map types and sub types to actual 
//              DXTransforms.
//
//  2000/09/15  mcalkins    Changed to optimized DXTransform progids.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transmap.h"




// An individual TRANSITION_MAP is used to map from type/subtype combinations to 
// dxtransform filter types
//
// the TRANSITION_MAP arrays defined here are structured in the following way:
//
// element 0 = type name, and prefix for output
// elements 1->n-1 = subtype name, and postfix for output
// element n-1 = double NULL for terminator flag

struct TRANSITION_MAP
{
    LPWSTR pszAttribute;    // subtype attribute from html
    LPWSTR pszTranslation;  // attribute for style
};


// Bar wipe translation.

static TRANSITION_MAP g_aBarWipeMap[] = {
    {L"barWipe",                L"progid:DXImageTransform.Microsoft.GradientWipe(GradientSize=0.00, "},

    {L"leftToRight",            L"wipeStyle=0)"},
    {L"topToBottom",            L"wipeStyle=1)"},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBoxWipeMap[] = {
    {L"boxWipe",                NULL},

    {L"topLeft",                NULL},
    {L"topRight",               NULL},
    {L"bottomRight",            NULL},
    {L"bottomLeft",             NULL},
    {L"topCenter",              NULL},
    {L"rightCenter",            NULL},
    {L"bottomCenter",           NULL},
    {L"leftCenter",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aFourBoxWipeMap[] = {
    {L"fourBoxWipe",            NULL},

    {L"cornersIn",              NULL},
    {L"cornersOut",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBarnDoorWipeMap[] = {
    {L"barnDoorWipe",           L"progid:DXImageTransform.Microsoft.Barn("},

    {L"vertical",               L"orientation='vertical')"},
    {L"horizontal",             L"orientation='horizontal')"},
    {L"diagonalBottomLeft",     NULL},
    {L"diagonalTopLeft",        NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aDiagonalWipeMap[] = {
    {L"diagonalWipe",           NULL},

    {L"topLeft",                NULL},
    {L"topRight",               NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBowTieWipeMap[] = {
    {L"bowTieWipe",             NULL},

    {L"vertical",               NULL},
    {L"horizontal",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aMiscDiagonalWipeMap[] = {
    {L"miscDiagonalWipe",       NULL},

    {L"doubleBarnDoor",         NULL},
    {L"doubleDiamond",          NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aVeeWipeMap[] = {
    {L"veeWipe",                NULL},

    {L"down",                   NULL},
    {L"left",                   NULL},
    {L"up",                     NULL},
    {L"right",                  NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBarnVeeWipeMap[] = {
    {L"barnVeeWipe",            NULL},

    {L"down",                   NULL},
    {L"left",                   NULL},
    {L"up",                     NULL},
    {L"right",                  NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aZigZagWipeMap[] = {
    {L"zigZagWipe",             NULL},

    {L"leftToRight",            NULL},
    {L"topToBottom",            NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBarnZigZagWipeMap[] = {
    {L"barnZigZagWipe",         NULL},

    {L"vertical",               NULL},
    {L"horizontal",             NULL},
    {NULL, NULL}
};


// Iris wipe translation.

static TRANSITION_MAP g_aIrisWipeMap[] = {
    {L"irisWipe",       L"progid:DXImageTransform.Microsoft.Iris("},

    {L"rectangle",      L"irisStyle=SQUARE)"},
    {L"diamond",        L"irisStyle=DIAMOND)"},
    {NULL, NULL}
};

static TRANSITION_MAP g_aTriangleWipeMap[] = {
    {L"triangleWipe",   NULL},

    {L"up",             NULL},
    {L"right",          NULL},
    {L"down",           NULL},
    {L"left",           NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aArrowHeadWipeMap[] = {
    {L"arrowHeadWipe",  NULL},

    {L"up",             NULL},
    {L"right",          NULL},
    {L"down",           NULL},
    {L"left",           NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aPentagonWipeMap[] = {
    {L"pentagonWipe",   NULL},

    {L"up",             NULL},
    {L"down",           NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aHexagonWipeMap[] = {
    {L"hexagonWipe",    NULL},

    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aEllipseWipeMap[] = {
    {L"ellipseWipe",    L"progid:DXImageTransform.Microsoft.Iris("},

    {L"circle",         L"irisStyle=CIRCLE)"},
    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aEyeWipeMap[] = {
    {L"eyeWipe",        NULL},

    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aRoundRectWipeMap[] = {
    {L"roundRectWipe",  NULL},

    {L"horizontal",     NULL},
    {L"vertical",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aStarWipeMap[] = {
    {L"starWipe",       L"progid:DXImageTransform.Microsoft.Iris("},

    {L"fourPoint",      NULL},
    {L"fivePoint",      L"irisStyle='star')"},
    {L"sixPoint",       NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aMiscShapeWipeMap[] = {
    {L"miscShapeWipe",  NULL},

    {L"heart",          NULL},
    {L"keyhole",        NULL},
    {NULL, NULL}
};



// Clock wipe translation.

static TRANSITION_MAP g_aClockWipeMap[] = {
    {L"clockWipe",             L"progid:DXImageTransform.Microsoft.RadialWipe("},

    {L"clockwiseTwelve",        L"wipeStyle=CLOCK)"},
    {L"clockwiseThree",         NULL},
    {L"clockwiseSix",           NULL},
    {L"clockwiseNine",          NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aPinWheelWipeMap[] = {
    {L"pinWheelWipe",           NULL},

    {L"towBladeVertical",       NULL},
    {L"twoBladeHorizontal",     NULL},
    {L"fourBlade",              NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aSingleSweepWipeMap[] = {
    {L"singleSweepWipe",            NULL},

    {L"clockwiseTop",               NULL},
    {L"clockwiseRight",             NULL},
    {L"clockwiseBottom",            NULL},
    {L"clockwiseLeft",              NULL},
    {L"clockwiseTopLeft",           NULL},
    {L"counterClockwiseBottomLeft", NULL},
    {L"clockwiseBottomRight",       NULL},
    {L"counterClockwiseTopRight",   NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aFanWipeMap[] = {
    {L"fanWipe",                L"progid:DXImageTransform.Microsoft.RadialWipe("},

    {L"centerTop",              L"wipeStyle=WEDGE)"},
    {L"centerRight",            NULL},
    {L"top",                    NULL},
    {L"right",                  NULL},
    {L"bottom",                 NULL},
    {L"left",                   NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aDoubleFanWipeMap[] = {
    {L"doubleFanWipe",          NULL},

    {L"fanOutVertical",         NULL},
    {L"fanOutHorizontal",       NULL},
    {L"fanInVertical",          NULL},
    {L"fanInHorizontal",        NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aDoubleSweepWipeMap[] = {
    {L"doubleSweepWipe",            NULL},

    {L"parallelVertical",           NULL},
    {L"parallelDiagonal",           NULL},
    {L"oppositeVertical",           NULL},
    {L"oppositeHorizontal",         NULL},
    {L"parallelDiagonalTopLeft",    NULL},
    {L"parallelDiagonalBottomLeft", NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aSaloonDoorWipeMap[] = {
    {L"saloonDoorWipe",         NULL},

    {L"top",                    NULL},
    {L"left",                   NULL},
    {L"bottom",                 NULL},
    {L"right",                  NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aWindshieldWipeMap[] = {
    {L"windshieldWipe",         NULL},

    {L"right",                  NULL},
    {L"up",                     NULL},
    {L"vertical",               NULL},
    {L"horizontal",             NULL},
    {NULL, NULL}
};


// Snake wipe translation.

static TRANSITION_MAP g_aSnakeWipeMap[] = {
    {L"snakeWipe",                      L"progid:DXImageTransform.Microsoft.ZigZag(GidSizeX=16,GridSizeY=8"},

    {L"topLeftHorizontal",              L")"},
    {L"topLeftVertical",                NULL},
    {L"topLeftDiagonal",                NULL},
    {L"topRightDiagonal",               NULL},
    {L"bottomRightDiagonal",            NULL},
    {L"bottomLeftDiagonal",             NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aSpiralWipeMap[] = {
    {L"spiralWipe",                     L"progid:DXImageTransform.Microsoft.Spiral(GidSizeX=16,GridSizeY=8"},

    {L"topLeftClockwise",               L")"},
    {L"topRightClockwise",              NULL},
    {L"bottomRightClockwise",           NULL},
    {L"bottomLeftClockwise",            NULL},
    {L"topLeftCounterClockwise",        NULL},
    {L"topRightCounterClockwise",       NULL},
    {L"bottomRightCounterClockwise",    NULL},
    {L"bottomLeftCounterClockwise",     NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aParallelSnakesWipeMap[] = {
    {L"parallelSnakesWipe",             NULL},

    {L"verticalTopSame",                NULL},
    {L"verticalBottomSame",             NULL},
    {L"verticalTopLeftOpposite",        NULL},
    {L"verticalBottomLeftOpposite",     NULL},
    {L"horizontalLeftSame",             NULL},
    {L"horizontalRightSame",            NULL},
    {L"horizontalTopLeftOpposite",      NULL},
    {L"horizontalTopRightOpposite",     NULL},
    {L"diagonalBottomLeftOpposite",     NULL},
    {L"diagonalTopLeftOpposite",        NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aBoxSnakesWipeMap[] = {
    {L"boxSnakesWipe",                  NULL},

    {L"twoBoxTop",                      NULL},
    {L"twoBoxBottom",                   NULL},
    {L"twoBoxLeft",                     NULL},
    {L"twoBoxRight",                    NULL},
    {L"fourBoxVertical",                NULL},
    {L"fourBoxHorizontal",              NULL},
    {NULL, NULL}
};

static TRANSITION_MAP g_aWaterfallWipeMap[] = {
    {L"waterfallWipe",                  NULL},

    {L"verticalLeft",                   NULL},
    {L"verticalRight",                  NULL},
    {L"horizontalLeft",                 NULL},
    {L"horizontalRight",                NULL},
    {NULL, NULL}
};


// Push wipe translation.

static TRANSITION_MAP g_aPushWipeMap[] = {
    {L"pushWipe",    L"progid:DXImageTransform.Microsoft.Slide(slideStyle=PUSH,bands=1"},

    {L"fromLeft",    L")"},
    {L"fromTop",     NULL},
    {L"fromRight",   NULL},
    {L"fromBottom",  NULL},
    {NULL, NULL}
};


// Slide wipe translation.

static TRANSITION_MAP g_aSlideWipeMap[] = {
    {L"slideWipe",   L"progid:DXImageTransform.Microsoft.Slide(slideStyle=HIDE"},

    {L"fromLeft",    L")"},
    {L"fromTop",     NULL},
    {L"fromRight",   NULL},
    {L"fromBottom",  NULL},
    {NULL, NULL}
};


// Fade translation.

static TRANSITION_MAP g_aFadeMap[] = {
    {L"fade", L"progid:DXImageTransform.Microsoft.Fade(Overlap=1.00"},

    {L"crossfade",      L")"},
    {L"fadeToColor",    NULL},
    {L"fadeFromColor",  NULL},
    {NULL, NULL}
};


// This array of transition maps used to find the correct subtype map for a
// type.
 
static TRANSITION_MAP * g_aTypeMap[] = {
    g_aBarWipeMap,
    g_aBoxWipeMap,
    g_aFourBoxWipeMap,
    g_aBarnDoorWipeMap,
    g_aDiagonalWipeMap,
    g_aBowTieWipeMap,
    g_aMiscDiagonalWipeMap,
    g_aVeeWipeMap,
    g_aBarnVeeWipeMap,
    g_aZigZagWipeMap,
    g_aBarnZigZagWipeMap,
    g_aIrisWipeMap,
    g_aTriangleWipeMap,
    g_aArrowHeadWipeMap,
    g_aPentagonWipeMap,
    g_aHexagonWipeMap,
    g_aEllipseWipeMap,
    g_aEyeWipeMap,
    g_aRoundRectWipeMap,
    g_aStarWipeMap,
    g_aMiscShapeWipeMap,

    g_aClockWipeMap,
    g_aPinWheelWipeMap,
    g_aSingleSweepWipeMap,
    g_aFanWipeMap,
    g_aDoubleFanWipeMap,
    g_aSaloonDoorWipeMap,
    g_aWindshieldWipeMap,
    g_aSnakeWipeMap,
    g_aSpiralWipeMap,
    g_aParallelSnakesWipeMap,
    g_aBoxSnakesWipeMap,
    g_aWaterfallWipeMap,

    g_aSnakeWipeMap, 
    g_aSpiralWipeMap,
    g_aParallelSnakesWipeMap,
    g_aBoxSnakesWipeMap,
    g_aWaterfallWipeMap,

    g_aPushWipeMap, 
    g_aSlideWipeMap, 
    g_aFadeMap,
    NULL
};


//+-----------------------------------------------------------------------------
//
//  Function: GetTransitionMap
//
//------------------------------------------------------------------------------
HRESULT
GetTransitionMap(LPWSTR pszType, TRANSITION_MAP** ppTransMap)
{
    HRESULT hr = S_OK;

    Assert(pszType && ppTransMap);

    *ppTransMap = NULL;

    for (int i = 0; g_aTypeMap[i]; i++)
    {
        if (0 == StrCmpIW(g_aTypeMap[i]->pszAttribute, pszType))
        {
            *ppTransMap = g_aTypeMap[i];

            goto done;
        }
    }

    // Could not find the type in the typeMap.

    hr = E_FAIL;

done:

    RRETURN(hr);
}
//  Function: GetTransitionMap


//+-----------------------------------------------------------------------------
//
//  Function: GetSubType
//
//  Parameters:
//
//      pstrSubType         The subtype attibute of the <transition> or 
//                          <transitionFilter> element.
//
//      pTransMap           The map for this specific type of transition.
//
//      ppstrParameters     ppstrParameters be set to point to a string
//                          containing any additional parameters to set this
//                          transition up correctly.
//
//                          If this specific subtype is implemented, it will be
//                          set to the string for this specific subtype.
//
//                          If the default subtype is implemented but this
//                          specific subtype is not, it will be set to point to
//                          the default subtype's string.
//
//                          If the default subtype is not implemented and
//                          neither is this specific subtype, it will be set 
//                          to NULL.
//------------------------------------------------------------------------------
HRESULT
GetSubType(const WCHAR *            pstrSubType, 
           const TRANSITION_MAP *   pTransMap, 
           const WCHAR ** const     ppstrParameters)
{
    Assert(pTransMap);
    Assert(ppstrParameters);

    // The default entry will be the next map entry.

    HRESULT                 hr          = S_OK;
    const TRANSITION_MAP *  pMapEntry   = &pTransMap[1];

    // Set ppstrParameters to point to the default parameters string (which may
    // be NULL.)

    *ppstrParameters = pMapEntry->pszTranslation;

    // If no subtype was provided, we're done.

    if (NULL == pstrSubType)
    {
        goto done;
    }

    while (pMapEntry->pszAttribute)
    {
        if (0 == StrCmpIW(pstrSubType, pMapEntry->pszAttribute))
        {
            // If we have found the subtype, and it has a parameter string
            // associated with it then have ppstrParameters point to that
            // string.  Otherwise, leave it pointing to the default string
            // (which may be NULL if the default case isn't implemented.)

            if (pMapEntry->pszTranslation)
            {
                *ppstrParameters = pMapEntry->pszTranslation;
            }

            goto done;
        }

        // Go to the next map entry.

        pMapEntry = &pMapEntry[1];
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Function: GetSubType


//+-----------------------------------------------------------------------------
//
//  Function: MapTypesToDXT
//
//  #ISSUE: 2000/10/10 (mcalkins) Since everything we do with strings generally
//          uses BSTRs we should make the last parameter a BSTR instead.
//
//------------------------------------------------------------------------------
HRESULT
MapTypesToDXT(LPWSTR pszType, LPWSTR pszSubType, LPWSTR * ppszOut)
{
    HRESULT             hr          = S_OK;
    
    // do not deallocate these - they are only pointers - not allocated
    const WCHAR *       pszFirst    = NULL;
    const WCHAR *       pszSecond   = NULL;
    TRANSITION_MAP *    pTransMap   = NULL;   

    if (NULL == pszType || NULL == ppszOut) // subtype can be null
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *ppszOut = NULL;

    hr = THR(GetTransitionMap(pszType, &pTransMap));

    if (FAILED(hr))
    {
        // type is unknown - assume it is a fully formed transition by itself

        hr          = S_OK;
        *ppszOut    = ::CopyString(pszType);

        if (NULL == *ppszOut)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        goto done;
    }

    // If pTransMap->pszTranslation is NULL it means we haven't written 
    // DXTransforms yet to implement this category of transitions. 

    if (NULL == pTransMap->pszTranslation)
    {
        hr = E_FAIL;

        goto done;
    }

    Assert(pTransMap);
    Assert(0 == StrCmpIW(pszType, pTransMap->pszAttribute));

    pszFirst = pTransMap->pszTranslation;

    hr = THR(GetSubType(pszSubType, pTransMap, &pszSecond));

    if (FAILED(hr))
    {
        goto done;
    }

    // If pszSecond wasn't set, neither the default subtype nor this specific
    // subtype for this transition is implemented and we return failure.

    if (NULL == pszSecond)
    {
        hr = E_FAIL;

        goto done;
    }

    {
        Assert(pszFirst && pszSecond);

        LPWSTR  pszOut  = NULL;
        int     len     = lstrlenW(pszFirst) + lstrlenW(pszSecond) + 1;

        pszOut = new WCHAR[len];

        if (NULL == pszOut)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        StrCpy(pszOut, pszFirst);
        StrCatBuff(pszOut, pszSecond, len);

        Assert((len - 1) == lstrlenW(pszOut));

        *ppszOut = pszOut;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Function: MapTypesToDXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transin.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transin.cpp
//
//  Abstract:   Implementation of CTIMETransIn
//
//  2000/09/15  mcalkins    Add explicit support for transitioning in.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "trans.h"
#include "transsink.h"

DeclareTag(tagTransitionIn, "TIME: Behavior", "CTIMETransIn methods")




class
ATL_NO_VTABLE
__declspec(uuid("ec3c8873-3bfc-473a-80c6-edc879d477cc"))
CTIMETransIn :
    public CTIMETransSink
{
public:

    CTIMETransIn();

protected:

    // CTIMETransBase overrides.

    STDMETHOD(OnDirectionChanged)();

    STDMETHOD_(void, OnBegin)();
    STDMETHOD_(void, OnEnd)();

    // CTIMETransSink overrides.

    STDMETHOD(PopulateNode)(ITIMENode * pNode);

    STDMETHOD_(void, PreApply)();
    STDMETHOD_(void, PostApply)();
};


//+-----------------------------------------------------------------------------
//
// Method:  CTIMETransIn::CTIMETransIn
//
//+-----------------------------------------------------------------------------
CTIMETransIn::CTIMETransIn()
{
    // Base class member initialization. (CTIMETransSink)

    m_eDXTQuickApplyType = DXTQAT_TransitionIn;
}
// Method:  CTIMETransIn::CTIMETransIn


//+-----------------------------------------------------------------------
//
//  Function:  CreateTransIn
//
//  Overview:  Create a CTIMETransIn, and pass back an ITransitionElement pointer
//
//  Arguments: ppTransElement - where to place the pointer
//             
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
CreateTransIn(ITransitionElement ** ppTransElement)
{
    HRESULT hr;
    CComObject<CTIMETransIn> * sptransIn;

    hr = THR(CComObject<CTIMETransIn>::CreateInstance(&sptransIn));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (ppTransElement)
    {
        *ppTransElement = sptransIn;
        (*ppTransElement)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMETransIn::OnDirectionChanged, CTIMETransBase
//
//  Overview:
//      Although a "transin" always gives the visual impression of
//      transitioning the element from a non-visible state to a visible state,
//      when the direction is reversed we actually do a reverse "transout" to 
//      give the impression that the direction has reversed.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransIn::OnDirectionChanged()
{
    if (m_fDirectionForward)
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionIn;
    }
    else
    {
        m_eDXTQuickApplyType = DXTQAT_TransitionOut;
    }

    return S_OK;
}
//  Method: CTIMETransIn::OnDirectionChanged


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransIn::PopulateNode
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransIn::PopulateNode(ITIMENode * pNode)
{
    HRESULT hr      = S_OK;
    LONG    lCookie = 0;

    hr = THR(CTIMETransSink::PopulateNode(pNode));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pNode->addBeginSyncArc(GetMediaTimeNode(), 
                                    TE_TIMEPOINT_BEGIN, 
                                    0, 
                                    &lCookie));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransIn::PopulateNode


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransIn::PreApply
//
//  Overview:  
//      Event handler for before apply is called on the transition.
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransIn::PreApply()
{
    // ##ISSUE: (mcalkins) We should verify that we'll never get here under
    //          any conditions unless this pointer is availble.

    Assert(!!m_spTransitionSite);

    if (m_spTransitionSite)
    {
        m_spTransitionSite->SetDrawFlag(VARIANT_FALSE);
    }
}
//  Member: CTIMETransIn::PreApply


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransIn::PostApply
//
//  Overview:  Event handler for after apply is called on the transition
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CTIMETransIn::PostApply()
{
    // ##ISSUE: (mcalkins) We should verify that we'll never get here under
    //          any conditions unless this pointer is availble.

    Assert(!!m_spTransitionSite);

    if (m_spTransitionSite)
    {
        m_spTransitionSite->SetDrawFlag(VARIANT_TRUE);
    }   
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransIn::OnBegin
//
//+-----------------------------------------------------------------------
void
CTIMETransIn::OnBegin (void)
{
    CTIMETransSink::OnBegin();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONINBEGIN));
} // CTIMETransIn::OnBegin


//+-----------------------------------------------------------------------
//
//  Member:    CTIMETransIn::OnEnd
//
//+-----------------------------------------------------------------------
void
CTIMETransIn::OnEnd (void)
{
    CTIMETransSink::OnEnd();
    IGNORE_HR(FireEvent(TE_ONTRANSITIONINEND));
} // CTIMETransIn::OnEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transsink.h ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transsink.h
//
//  Abstract:   Declaration of CTIMETransSink.
//
//  2000/09/15  mcalkins    Added m_eDXTQuickApplyType member variable.
//
//------------------------------------------------------------------------------

#ifndef _TRANSSINK_H__
#define _TRANSSINK_H__

#pragma once

#include "transbase.h"
#include "transsite.h"
#include "attr.h"




class
ATL_NO_VTABLE
__declspec(uuid("84f7bcfa-4bcf-4e70-9ecc-d97086e5cb9c"))
CTIMETransSink :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTIMETransSink, &__uuidof(CTIMETransSink)>,
    public CTIMETransBase,
    public ITransitionElement,
    public ITIMENodeBehavior
{
public:

    CTIMETransSink();

    // ITransitionElement methods.

    STDMETHOD(Init)();
    STDMETHOD(Detach)();
    STDMETHOD(put_template)(LPWSTR pwzTemplate);
    STDMETHOD(put_htmlElement)(IHTMLElement * pHTMLElement);
    STDMETHOD(put_timeElement)(ITIMEElement * pTIMEElement);

    // ITIMENodeBehavior methods.

    STDMETHOD(tick)();
    STDMETHOD(eventNotify)(double dblEventTime,
                           TE_EVENT_TYPE teEventType,
                           long lNewRepeatCount);
    STDMETHOD(getSyncTime)(double * dblNewSegmentTime,
                           LONG * lNewRepeatCount,
                           VARIANT_BOOL * bCueing);        
    STDMETHOD(propNotify)(DWORD tePropTypes);

    // QI implementation.

    BEGIN_COM_MAP(CTIMETransSink)
        COM_INTERFACE_ENTRY(ITIMENodeBehavior)
    END_COM_MAP();

protected:

    // Are we a transition in or a transition out?  This should be set
    // appropriately by a class that derives from this class.

    DXT_QUICK_APPLY_TYPE    m_eDXTQuickApplyType;

    // event handlers

    STDMETHOD_(void, OnBegin) (void);
    STDMETHOD_(void, OnEnd) (void);
    STDMETHOD_(void, OnProgressChanged)(double dblProgress);

    // setup

    STDMETHOD(PopulateNode)(ITIMENode * pNode);

    // subclasses must implement

    STDMETHOD_(void, PreApply)() PURE;
    STDMETHOD_(void, PostApply)() PURE;

    // accessors

    ITIMENode * GetParentTimeNode() { return m_spTimeParent; }
    ITIMENode * GetMediaTimeNode() { return m_spMediaNode; }
    ITIMENode * GetTimeNode() { return m_spTimeNode; }

private:

    // initialization

    HRESULT FindTemplateElement();

    // private methods

    HRESULT ApplyIfNeeded();
    bool    ReadyToInit();
    HRESULT CreateTimeBehavior();

    // private data

    CComPtr<ITIMEElement>       m_spTIMEElement;

    CComPtr<ITIMENode>          m_spTimeNode;
    CComPtr<ITIMENode>          m_spTimeParent;
    CComPtr<ITIMENode>          m_spMediaNode;
    CComPtr<ITIMEContainer>     m_spParentContainer;

    CAttrString                 m_SATemplate;

#ifdef DBG
    bool                        m_fHaveCalledInit;
#endif
    bool                        m_fHaveCalledApply;
    bool                        m_fInReset;
    bool                        m_fPreventDueToFill;
};

#endif // _TRANSSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\atomtable.cpp ===
//************************************************************
//
// FileName:        atomtbl.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Implementation of CAtomTable.
//************************************************************

#include "headers.h"
#include "atomtable.h"


// CAtomTable is used as a static object by CTIMEElementBase and needs to be 
// thread safe since we can have multiple trident threads in the same process
static CritSect g_AtomTableCriticalSection;

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        constructor
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CAtomTable::CAtomTable() :
    m_rgNames(NULL),
    m_lRefCount(0)
{
} // CAtomTable

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        destructor
//************************************************************

CAtomTable::~CAtomTable()
{
    if (m_rgNames)
    {
        // loop thru and release memory
        long lSize = m_rgNames->Size();
        for(long lIndex = 0; lIndex < lSize; lIndex++)
        {
            SysFreeString((*m_rgNames)[lIndex]);
        }

        delete m_rgNames;
        m_rgNames = NULL;
    }
} // ~CAtomTable

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    
//************************************************************

HRESULT
CAtomTable::AddNameToAtomTable(const WCHAR *pwszName, 
                               long        *plOffset)
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_AtomTableCriticalSection);

    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Invalid param"));
        return E_INVALIDARG;
    }
    
    *plOffset = 0;
    
    // check to see if array is initialized
    if (m_rgNames == NULL)
    {
        m_rgNames = NEW CPtrAry<BSTR>;
        if (m_rgNames == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    g_AtomTableCriticalSection.Release();
    HRESULT hr = GetAtomFromName(pwszName, plOffset);
    g_AtomTableCriticalSection.Grab();

    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        BSTR bstrName = SysAllocString(pwszName);
        if (bstrName == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for string"));
            return E_OUTOFMEMORY;
        }

        // add to table
        hr = m_rgNames->Append(bstrName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - unable to add string to table"));
            SysFreeString(bstrName);
            return hr;
        }

        // calc offset
        *plOffset = m_rgNames->Size() - 1;
    }

    // otherwise return the results of FindAtom
    return hr;
} // AddNameToAtomTable


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given a name, return the index
//************************************************************

HRESULT
CAtomTable::GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset)
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_AtomTableCriticalSection);

    // validate out param
    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::GetAtomFromName - Invalid param"));
        return E_INVALIDARG;
    }

    // init param
    *plOffset = 0;

    // loop thru table looking for a match
    long   lSize  = m_rgNames->Size();
    BSTR  *ppItem = *m_rgNames;

    for (long lIndex = 0; lIndex < lSize; lIndex++, ppItem++)
    {
        Assert(*ppItem);

        if (StrCmpW(pwszName, (*ppItem)) == 0)
        {
            *plOffset = lIndex;
            return S_OK;
        }
    }

    // not found
    return DISP_E_MEMBERNOTFOUND;
} // GetAtomFromName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, return the contents
//************************************************************

HRESULT 
CAtomTable::GetNameFromAtom(long lOffset, const WCHAR **ppwszName)
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_AtomTableCriticalSection);

    // validate out param
    if (ppwszName == NULL)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid param"));
        return E_INVALIDARG;
    }

    *ppwszName = NULL;

    // check for empty table
    if (m_rgNames->Size() == 0)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - table is empty"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // check to make sure we are in range
    if ((lOffset < 0) || 
        (lOffset >= m_rgNames->Size()))
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid index"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // set IDispatch
    *ppwszName = (*m_rgNames)[lOffset];
    return S_OK;
} // GetNameFromAtom

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\transitions\transworker.cpp ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transworker.cpp
//
//  Classes:    CTIMETransitionWorker
//
//  History:
//  2000/07/??  jeffwall    Created.
//  2000/09/07  mcalkins    Use IDXTFilterController interface instead of
//                          IDXTFilter.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "transworker.h"
#include "dxtransp.h"
#include "attr.h"
#include "tokens.h"
#include "transmap.h"
#include "..\timebvr\timeelmbase.h"
#include "..\timebvr\transdepend.h"

DeclareTag(tagTransitionWorkerTransformControl, "SMIL Transitions", "CTransitionWorker transform control")
DeclareTag(tagTransitionWorkerProgress, "SMIL Transitions", "CTransitionWorker progress")
DeclareTag(tagTransitionWorkerEvents, "SMIL Transitions", "CTransitionWorker events")

const LPWSTR    DEFAULT_M_TYPE          = NULL;
const LPWSTR    DEFAULT_M_SUBTYPE       = NULL;

class CTransitionDependencyManager;

class
ATL_NO_VTABLE
__declspec(uuid("aee68256-bd58-4fc5-a314-c43b40edb5fc"))
CTIMETransitionWorker :
  public CComObjectRootEx<CComSingleThreadModel>,
  public ITransitionWorker
{
public:

    CTIMETransitionWorker();
  
    // ITransitionWorker methods.

    STDMETHOD(InitFromTemplate)();
    STDMETHOD(InitStandalone)(VARIANT varType, VARIANT varSubtype);
    STDMETHOD(Detach)();
    STDMETHOD(put_transSite)(ITransitionSite * pTransElement);
    STDMETHOD(Apply)(DXT_QUICK_APPLY_TYPE eDXTQuickApplyType);
    STDMETHOD(put_progress)(double dblProgress);
    STDMETHOD(get_progress)(double * pdblProgress);
    STDMETHOD(OnBeginTransition) (void);
    STDMETHOD(OnEndTransition) (void);

    // For Persisitence.

    CAttr<LPWSTR> & GetTypeAttr()           { return m_SAType; }
    CAttr<LPWSTR> & GetSubTypeAttr()        { return m_SASubType; }
    STDMETHOD(get_type)(VARIANT *type);        
    STDMETHOD(put_type)(VARIANT type);        
    STDMETHOD(get_subType)(VARIANT *subtype);        
    STDMETHOD(put_subType)(VARIANT subtype);        

    // QI Implementation.

    BEGIN_COM_MAP(CTIMETransitionWorker)
    END_COM_MAP();

protected:

    // Setup / teardown methods.

    bool    ReadyToInit();

    HRESULT PopulateFromTemplateElement();

    HRESULT AttachFilter();
    HRESULT DetachFilter();

    HRESULT ResolveDependents (void);

private:

    CComPtr<IDXTFilterCollection>   m_spDXTFilterCollection;
    CComPtr<IDXTFilterController>   m_spDXTFilterController;
    CComPtr<ITransitionSite>        m_spTransSite;
    
    HFILTER                         m_hFilter;
    DWORD                           m_dwFilterType;
    double                          m_dblLastFilterProgress;
    CTransitionDependencyManager    m_cDependents;

    static const WCHAR * const      s_astrInvalidTags[];
    static const unsigned int       s_cInvalidTags;

    unsigned                        m_fHaveCalledApply  : 1;

#ifdef DBG
    unsigned                        m_fHaveCalledInit   : 1;
    unsigned                        m_fInLoad           : 1;
#endif // DBG

    // attributes

    CAttr<LPWSTR>   m_SAType;
    CAttr<LPWSTR>   m_SASubType;

    static TIME_PERSISTENCE_MAP PersistenceMap[];
};


//+-----------------------------------------------------------------------------
//
// Static member variables initialization.
//
//------------------------------------------------------------------------------

const WCHAR * const CTIMETransitionWorker::s_astrInvalidTags[] = { 
    // Note: keep alphabetical order.
    L"applet",
    L"embed",
    L"object",
    L"option",
    L"select",
    L"tbody",
    L"tfoot",
    L"thead",
    L"tr"
};

const unsigned int CTIMETransitionWorker::s_cInvalidTags 
                = sizeof(s_astrInvalidTags) / sizeof(s_astrInvalidTags[0]);

//+-----------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------

#define TTE CTIMETransitionWorker

                // Function Name // Class // Attr Accessor    // COM put_ fn  // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(TTE_Type,         TTE,    GetTypeAttr,         put_type,         get_type,            VARIANT);
TIME_PERSIST_FN(TTE_SubType,      TTE,    GetSubTypeAttr,      put_subType,      get_subType,         VARIANT);


//+-----------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMETransitionWorker)
                           // Attr Name     // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,             TTE_Type )
    PERSISTENCE_MAP_ENTRY( WZ_SUBTYPE,          TTE_SubType )

END_TIME_PERSISTENCE_MAP()


//+-----------------------------------------------------------------------------
//
//  Function: CreateTransitionWorker
//
//  Overview:  
//      Creates a CTIMETransitionWorker and returns a ITransitionWorker pointer
//
//  Arguments: 
//      ppTransWorker   where to put the pointer
//             
//------------------------------------------------------------------------------
HRESULT
CreateTransitionWorker(ITransitionWorker ** ppTransWorker)
{
    HRESULT hr;
    CComObject<CTIMETransitionWorker> * sptransWorker;

    hr = THR(CComObject<CTIMETransitionWorker>::CreateInstance(&sptransWorker));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (ppTransWorker)
    {
        *ppTransWorker = sptransWorker;
        (*ppTransWorker)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Function: CreateTransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::CTIMETransitionWorker
//
//  Overview:  
//      Initializes member variables
//
//------------------------------------------------------------------------------
CTIMETransitionWorker::CTIMETransitionWorker() :
    m_hFilter(NULL),
    m_dwFilterType(0),
    m_dblLastFilterProgress(0.0),
    m_fHaveCalledApply(false),
#ifdef DBG
    m_fHaveCalledInit(false),
    m_fInLoad(false),
#endif // DBG
    m_SAType(DEFAULT_M_TYPE),
    m_SASubType(DEFAULT_M_SUBTYPE)
{

}
//  Member: CTIMETransitionWorker::CTIMETransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_transSite
//
//  Arguments: 
//      pTransSite  TransitionSite Element to get data from
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_transSite(ITransitionSite * pTransSite)
{
    HRESULT hr = S_OK;

    Assert(false == m_fHaveCalledInit);
    Assert(m_spTransSite == NULL);

    m_spTransSite = pTransSite;

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_transSite


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::ReadyToInit
//
//  Overview:  
//      Determines wether or not init can be done now.
//
//  Returns:   
//      bool    true if ok to init, false otherwise
//
//------------------------------------------------------------------------------
bool
CTIMETransitionWorker::ReadyToInit()
{
    bool bReady = false;

    if (m_spTransSite == NULL)
        goto done;

    bReady = true;
done:
    return bReady;
}
//  Member: CTIMETransitionWorker::ReadyToInit

//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::InitStandalone
//
//  Overview:  
//      Initializes and sets up CTIMETransitionWorker - call once all of 
//      the properties have been set on ITransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::InitStandalone(VARIANT varType, VARIANT varSubtype)
{
    HRESULT hr = S_OK;

    Assert(false == m_fHaveCalledInit);

    if (!ReadyToInit())
    {
        hr = E_FAIL;
        goto done;
    }

    // Hook up type/subtype attributes.
    hr = THR(put_type(varType));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(put_subType(varSubtype));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(AttachFilter());
    if (FAILED(hr))
    {
        goto done;
    }

#ifdef DBG
    m_fHaveCalledInit = true;
#endif // DBG

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::InitStandalone

//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::InitFromTemplate
//
//  Overview:  
//      Initializes and sets up CTIMETransitionWorker - call once all of 
//      the properties have been set on ITransitionElement
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::InitFromTemplate()
{
    HRESULT hr = S_OK;

    Assert(false == m_fHaveCalledInit);

    if (!ReadyToInit())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(PopulateFromTemplateElement());
    if (FAILED(hr))
    {
        goto done;
    }
        
    hr = THR(AttachFilter());
    if (FAILED(hr))
    {
        goto done;
    }

#ifdef DBG
    m_fHaveCalledInit = true;
#endif // DBG

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::InitFromTemplate


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::Detach
//
//  Overview:  
//      Deinitializes CTIMETransitionWorker and detachs from extra interfaces
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::Detach()
{ 
    m_cDependents.ReleaseAllDependents();

    DetachFilter();

    m_spTransSite.Release();

    return S_OK;
}
//  Member: CTIMETransitionWorker::Detach


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::ResolveDependents
//
//  Overview:  
//      Retrieve the global list of pending transition dependents.  Evaluate 
//      each and determine whether they belong in our dependents list.  No item
//      will reside in both lists - either we assume responsibility 
//      for it, or we will leave it in the global list.
//
//------------------------------------------------------------------------------
HRESULT 
CTIMETransitionWorker::ResolveDependents()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> spHTMLElement;
    CComPtr<IHTMLElement> spHTMLBodyElement;
    CComPtr<ITIMEElement> spTIMEElement;
    CComPtr<ITIMETransitionDependencyMgr> spTIMETransitionDependencyMgr;

    Assert(true == m_fHaveCalledInit);

    if (m_spTransSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    // Get the target element

    hr = THR(m_spTransSite->get_htmlElement(&spHTMLElement));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = ::GetBodyElement(spHTMLElement, __uuidof(IHTMLElement), 
                          (void **)&spHTMLBodyElement);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = ::FindTIMEInterface(spHTMLBodyElement, &spTIMEElement);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spTIMEElement->QueryInterface(__uuidof(ITIMETransitionDependencyMgr), 
                                       (void **)&spTIMETransitionDependencyMgr);

    if (FAILED(hr))
    {
        goto done;
    }

    // Gather any new dependents from the global list.

    hr = spTIMETransitionDependencyMgr->EvaluateTransitionTarget(
                                        spHTMLElement,
                                        (void *)&m_cDependents);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
} 
//  Member: CTIMETransitionWorker::ResolveDependents


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::OnBeginTransition
//
//  Overview:  
//      Called when the transition owner believes the transition has 'begun'
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::OnBeginTransition(void)
{ 
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerEvents, 
              "CTIMETransitionWorker(%p)::OnBeginTransition()",
              this));

    IGNORE_HR(ResolveDependents());

    hr = THR(m_spDXTFilterController->SetEnabled(TRUE));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::OnBeginTransition


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::OnEndTransition
//
//  Overview:  
//      Called when the transition owner believes the transition has 'ended'
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::OnEndTransition(void)
{ 
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerEvents, 
              "CTIMETransitionWorker(%p)::OnEndTransition()",
              this));

    m_cDependents.NotifyAndReleaseDependents();

    hr = DetachFilter();

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::OnEndTransition


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::PopulateFromTemplateElement
//
//  Overview:  
//      Persistence in from the template
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransitionWorker::PopulateFromTemplateElement()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> spTemplate;

    hr = THR(m_spTransSite->get_template(&spTemplate));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(spTemplate != NULL);

#ifdef DBG
    m_fInLoad = true;
#endif // DBG

    hr = THR(::TimeElementLoad(this, CTIMETransitionWorker::PersistenceMap, spTemplate));

#ifdef DBG
    m_fInLoad = false;
#endif // DBG

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::PopulateFromTemplateElement


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::AttachFilter
//
//  Overview:  
//      Add the filter to the style of the html element and get back a pointer 
//      to the filter
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransitionWorker::AttachFilter()
{
    HRESULT         hr              = S_OK;
    HFILTER         hFilter         = NULL;
    BSTR            bstrType        = NULL;
    BSTR            bstrSubType     = NULL;
    BSTR            bstrFilter      = NULL;
    BSTR            bstrTagName     = NULL;
    WCHAR *         strFilter       = NULL;
    unsigned int    i               = 0;

    CComPtr<IHTMLElement>           spHTMLElement;
    CComPtr<IHTMLFiltersCollection> spFiltersCollection;   

    Assert(!m_spDXTFilterCollection);

    hr = THR(m_spTransSite->get_htmlElement(&spHTMLElement));

    if (FAILED(hr))
    {
        goto done;
    }

    // When filters are instantiated via CSS, the CSS code knows that certain
    // elements are not allowed to have filters on them.  Since we don't share
    // that code path with them we have to take on the same responsibility.
    // We ask for the tagname of the element so that we can refrain from
    // filtering element types that can't take filters.
    //
    // NOTE: (mcalkins) This is bad architecture, a new filters architecture
    // will have a central place for this info (or hopefully will just allow 
    // everything to be filtered), but for now be aware that this list may need
    // to be updated periodically.

    hr = THR(spHTMLElement->get_tagName(&bstrTagName));

    if (FAILED(hr))
    {
        goto done;
    }

    // Run through array of invalid tags to make sure we can instantiate this
    // behavior.
    
    for (i = 0; i < s_cInvalidTags; i++)
    {
        int n = StrCmpIW(s_astrInvalidTags[i], bstrTagName);

        if (0 == n)
        {
            // Our tag matches an invalid tag, don't instantiate behavior.

            hr = E_FAIL;

            goto done;
        }
        else if (n > 0)
        {
            // The invalid tag tested was higher than our tag so we've done
            // enough testing.

            break;
        }
    }
    
    hr = THR(spHTMLElement->get_filters(&spFiltersCollection));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(spFiltersCollection->QueryInterface(IID_TO_PPV(IDXTFilterCollection, 
                                                            &m_spDXTFilterCollection)));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_SAType.GetString(&bstrType));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_SASubType.GetString(&bstrSubType));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::MapTypesToDXT(bstrType, bstrSubType, &strFilter));

    if (FAILED(hr))
    {
        goto done;
    }

    bstrFilter = SysAllocString(strFilter);

    if (NULL == bstrFilter)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    hr = THR(m_spDXTFilterCollection->AddFilter(bstrFilter, DXTFTF_PRIVATE, 
                                                &m_dwFilterType, &m_hFilter));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spDXTFilterCollection->GetFilterController(
                                                    m_hFilter,
                                                    &m_spDXTFilterController));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spDXTFilterController->SetEnabled(FALSE));

    if (FAILED(hr))
    {
        goto done;
    }

    // Since we're not using the classic Apply/Play behavior, we don't want the
    // filter to attempt to control the visibility of the element in any way.

    hr = THR(m_spDXTFilterController->SetFilterControlsVisibility(FALSE));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:

    if (FAILED(hr))
    {
        DetachFilter();
    }

    delete [] strFilter;

    ::SysFreeString(bstrFilter);
    ::SysFreeString(bstrTagName);
    SysFreeString(bstrType);
    SysFreeString(bstrSubType);
    
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::AttachFilter


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::DetachFilter
//
//------------------------------------------------------------------------------
HRESULT
CTIMETransitionWorker::DetachFilter()
{
    HRESULT hr = S_OK;

    if (m_hFilter)
    {
        Assert(!!m_spDXTFilterCollection);

        hr = m_spDXTFilterCollection->RemoveFilter(m_hFilter);
    
        if (FAILED(hr))
        {
            goto done;
        }

        m_hFilter = 0;
    }

    hr = S_OK;

done:

    m_spDXTFilterController.Release();
    m_spDXTFilterCollection.Release();

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::DetachFilter


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::Apply, ITransitionWorker
//
//  Parameters:
//      eDXTQuickApplyType  Is this a transition in or a transition out?
//
//  Overview:  
//      Setup the Transition by taking a snapshot and adjusting visibility
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::Apply(DXT_QUICK_APPLY_TYPE eDXTQuickApplyType)
{
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerTransformControl, "CTIMETransitionWorker::Apply()"));

    Assert(!!m_spDXTFilterController);
    Assert(!m_fHaveCalledApply);

    if (m_fHaveCalledApply)
    {
        goto done;
    }

    hr = THR(m_spDXTFilterController->QuickApply(eDXTQuickApplyType, 
                                                 NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_fHaveCalledApply  = true;
    hr                  = S_OK;

done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::Apply, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_progress, ITransitionWorker
//
//  Overview:  
//      Handle progress changes by calculating filter progress and passing onto 
//      the dxfilter if needed.
//
//  Arguments: 
//      dblProgress = [0,1]
//             
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_progress(double dblProgress)
{
    HRESULT hr = S_OK;

    TraceTag((tagTransitionWorkerProgress, 
              "CTIMETransitionWorker::put_progress(%g)", dblProgress));

    // If the transition has ended, we will have released the filter controller
    // and can safely ignore this progress notification.

    if (!m_spDXTFilterController)
    {
        goto done;
    }

    if (   m_fHaveCalledApply
        && (m_dblLastFilterProgress != dblProgress))
    {
        hr = m_spDXTFilterController->SetProgress(
                                            static_cast<float>(dblProgress));

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
done:

    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_progress, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::get_progress, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::get_progress(double * pdblProgress)
{
    HRESULT hr = S_OK;

    if (NULL == pdblProgress)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    TraceTag((tagTransitionWorkerProgress, 
              "CTIMETransitionWorker::get_progress(%g)", m_dblLastFilterProgress));

    *pdblProgress = m_dblLastFilterProgress;

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::get_progress, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::get_type, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::get_type(VARIANT *type)
{
    return E_NOTIMPL;
}
//  Member: CTIMETransitionWorker::get_type, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_type, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_type(VARIANT type)
{
    HRESULT hr = S_OK;

    Assert(VT_BSTR == type.vt);

    hr = THR(m_SAType.SetString(type.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_type, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::get_subType, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::get_subType(VARIANT *subtype)
{
    return E_NOTIMPL;
}
//  Member: CTIMETransitionWorker::get_subType, ITransitionWorker


//+-----------------------------------------------------------------------------
//
//  Member: CTIMETransitionWorker::put_subType, ITransitionWorker
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMETransitionWorker::put_subType(VARIANT subtype)
{
    HRESULT hr = S_OK;

    Assert(VT_BSTR == subtype.vt);

    hr = THR(m_SASubType.SetString(subtype.bstrVal));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
//  Member: CTIMETransitionWorker::put_subType, ITransitionWorker
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\attr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: attr.cpp
//
//  Contents: persistable attribute classes and utilities
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "attr.h"


//+-------------------------------------------------------------------------------------
//
// CAttrBase
//
//--------------------------------------------------------------------------------------

CAttrBase::CAttrBase() :
    m_pstrAttr(NULL),
    m_fSet(false)
{
    // do nothing
}

void 
CAttrBase::ClearString()
{
    delete [] m_pstrAttr;
    m_pstrAttr = NULL;
}

CAttrBase::~CAttrBase()
{
    ClearString();
} //lint !e1740

    
// This is for setting the persisted string
HRESULT
CAttrBase::SetString(BSTR bstrAttr)
{
    if (NULL == bstrAttr)
    {
        ClearString();
    }
    else
    {
        LPWSTR pstrTemp = CopyString(bstrAttr);
        if (NULL == pstrTemp)
        {
            return E_OUTOFMEMORY;
        }
        delete [] m_pstrAttr;
        m_pstrAttr = pstrTemp;
    }

    return S_OK;
}

// This is for getting the persisted string
// returns null if string not available
HRESULT
CAttrBase::GetString(BSTR * pbstrAttr)
{
    if (NULL == pbstrAttr)
    {
        return E_INVALIDARG;
    }

    if (NULL == m_pstrAttr)
    {
        *pbstrAttr = NULL;
    }
    else
    {
        *pbstrAttr = SysAllocString(m_pstrAttr);
        if (NULL == *pbstrAttr)
        {
            return E_OUTOFMEMORY;
        }
    }
    
    return S_OK;
}

// This is for use of persistence macros only! Uses the storage passed in (does not allocate).
void 
CAttrBase::SetStringFromPersistenceMacro(LPWSTR pstrAttr)
{
    delete [] m_pstrAttr;
    m_pstrAttr = pstrAttr;
}

CAttrString::CAttrString(LPWSTR val) : 
  m_pszVal(NULL)
{
    IGNORE_HR(SetValue(val));
}

CAttrString::~CAttrString()
{
    delete [] m_pszVal;
    m_pszVal = NULL;
}

HRESULT
CAttrString::SetValue(LPWSTR val)
{
    delete [] m_pszVal;
    m_pszVal = NULL;

    if (val)
    {
        m_pszVal = ::CopyString(val);
        if (NULL == m_pszVal)
        {
            TraceTag((tagError, "Out of memory!"));
            return E_OUTOFMEMORY;
        }
        MarkAsSet();
    }
    return S_OK;
}

BSTR
CAttrString::GetValue()
{
    if (m_pszVal)
    {
        return ::SysAllocString(m_pszVal);
    }
    return NULL;
}

void
CAttrString::MarkAsSet()
{
    ClearString();
    SetFlag(true);
}


//+-------------------------------------------------------------------------------------
//
// Persistence helpers
//
//--------------------------------------------------------------------------------------


HRESULT
TimeLoad(void *                 pvObj, 
         TIME_PERSISTENCE_MAP   PersistenceMap[], 
         IPropertyBag2 *        pPropBag,
         IErrorLog *            pErrorLog)
{
    HRESULT hr;
    HRESULT hrres = S_OK;
    int i;
    PROPBAG2 propbag;
    VARIANT var;

    CHECK_RETURN_NULL(pPropBag);
    CHECK_RETURN_NULL(pvObj);
    CHECK_RETURN_NULL(PersistenceMap);
    propbag.vt = VT_BSTR;

    for (i = 0; NULL != PersistenceMap[i].pstrName; i++)
    {
        VariantInit(&var);
        // read one attr at a time
        propbag.pstrName = PersistenceMap[i].pstrName;
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            // ensure it is a BSTR
            hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
            if (SUCCEEDED(hr))
            {
                // use the global persistence funtion to set the attribute on the OM
                hr = (PersistenceMap[i].pfnPersist)(pvObj, &var, true);
                //
                // dilipk: do we need to log errors here?
                //
            }
            VariantClear(&var);
        }
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
TimeSave(void *                 pvObj, 
         TIME_PERSISTENCE_MAP   PersistenceMap[], 
         IPropertyBag2 *        pPropBag, 
         BOOL                   fClearDirty, 
         BOOL                   fSaveAllProperties)
{
    HRESULT hr;
    PROPBAG2 propbag;
    CComVariant var;
    int i;

    CHECK_RETURN_NULL(pPropBag);
    CHECK_RETURN_NULL(pvObj);
    CHECK_RETURN_NULL(PersistenceMap);

    //
    // dilipk: Need to support fClearDirty. Currently, IsDirty() always returns S_OK.
    //

    propbag.vt = VT_BSTR;
    for (i = 0; NULL != PersistenceMap[i].pstrName; i++)
    {
        // Get the string value
        hr = THR((PersistenceMap[i].pfnPersist)(pvObj, &var, false));
        if (SUCCEEDED(hr) && (VT_NULL != V_VT(&var)))
        {
            // Write the attribute
            propbag.pstrName = PersistenceMap[i].pstrName;
            hr = THR(pPropBag->Write(1, &propbag, &var));
        }
        var.Clear();
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
TimeElementLoad(void *                 pvObj, 
                TIME_PERSISTENCE_MAP   PersistenceMap[], 
                IHTMLElement *         pElement)
{
    HRESULT hr;
    int i;
    VARIANT var;

    CHECK_RETURN_NULL(pElement);
    CHECK_RETURN_NULL(pvObj);
    CHECK_RETURN_NULL(PersistenceMap);

    for (i = 0; NULL != PersistenceMap[i].pstrName; i++)
    {
        VariantInit(&var);
        CComBSTR bstrName(PersistenceMap[i].pstrName);

        hr = pElement->getAttribute(bstrName, 0, &var);

        if (SUCCEEDED(hr) && VT_NULL != var.vt)
        {
            // ensure it is a BSTR
            hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
            if (SUCCEEDED(hr))
            {
                // use the global persistence funtion to set the attribute on the OM
                hr = (PersistenceMap[i].pfnPersist)(pvObj, &var, true);
            }
            VariantClear(&var);
        }
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\basebvr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\basebvr.cpp
//
//  Contents: DHTML Behavior base class
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "basebvr.h"

DeclareTag(tagBaseBvr, "TIME: Behavior", "CBaseBvr methods")

CBaseBvr::CBaseBvr() :
    m_clsid(GUID_NULL),
    m_fPropertiesDirty(true),
    m_fIsIE4(false)
{

    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::CBaseBvr()",
              this));
}

CBaseBvr::~CBaseBvr()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::~CBaseBvr()",
              this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehavior
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CBaseBvr::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr = S_OK; 
    CComPtr<IDispatch> pIDispatch;

    if (pBehaviorSite == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    hr = THR(pBehaviorSite->GetElement(&m_pHTMLEle));
    if (FAILED(hr))
    {
        goto done;
    }

    // First thing we do is see if this behavior was already added

    if (IsBehaviorAttached())
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    m_pBvrSite = pBehaviorSite;

    hr = m_pBvrSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **) &m_pBvrSiteOM);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pBvrSiteOM->RegisterUrn((LPWSTR) GetBehaviorURN());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pBvrSiteOM->RegisterName((LPWSTR) GetBehaviorName());
    if (FAILED(hr))
    {
        goto done;
    }

    {
        CComPtr<IHTMLElement2> spElement2;
        hr = THR(m_pHTMLEle->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2)));
        if (FAILED(hr))
        {
            // IE4 path
            m_fIsIE4 = true;
        }
    }
  
    hr = THR(m_pBvrSite->QueryInterface(IID_IServiceProvider, (void **)&m_pSp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pHTMLEle->get_document(&pIDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pIDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&m_pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // Do not set the init flag since it will be set by the first
    // notify which we want to skip
    
  done:
    if (S_OK != hr)
    {
        // release all
        m_pBvrSite.Release();
        m_pBvrSiteOM.Release();
        m_pHTMLEle.Release();
        m_pHTMLDoc.Release();
        m_pSp.Release();
    }
    
    return hr;
} // Init
   
STDMETHODIMP
CBaseBvr::Notify(LONG, VARIANT *)
{
    return S_OK;
}

STDMETHODIMP
CBaseBvr::Detach()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Detach()",
              this));

    m_pBvrSite.Release();
    m_pBvrSiteOM.Release();
    m_pHTMLEle.Release();
    m_pHTMLDoc.Release();
    m_pSp.Release();
    
    return S_OK;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::GetClassID, IPersistPropertyBag2
//
//  Synopsis:   Returns the CLSID of the object
//
//  Arguments:  pclsid      output variable
//
//  Returns:    S_OK        if pclsid is valid
//              E_POINTER   if pclsid is not valid
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::GetClassID(CLSID* pclsid)
{
    if (NULL == pclsid)
    {
        return E_POINTER;
    }
    *pclsid = m_clsid;
    return S_OK;
} 

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::InitNew, IPersistPropertyBag2
//
//  Synopsis:   See Docs for IPersistPropertyBag2
//
//  Arguments:  None
//
//  Returns:    S_OK        Always
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::InitNew(void)
{
    return S_OK;
} 

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::IsDirty, IPersistPropertyBag2
//
//  Synopsis:   See Docs for IPersistPropertyBag2
//
//  Arguments:  None
//
//  Returns:    S_OK        Always
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::IsDirty(void)
{
    return S_OK;
} 

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::Load, IPersistPropertyBag2
//
//  Synopsis:   Loads the behavior specific attributes from Trident
//
//  Arguments:  See Docs for IPersistPropertyBag2
//
//  Returns:    Failure     when a fatal error error has occured (i.e. behavior cannot run)
//              S_OK        All other cases
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    // allow derived class to do something after we have successfully loaded
    IGNORE_HR(OnPropertiesLoaded());
    return S_OK;
} // Load

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::Save, IPersistPropertyBag2
//
//  Synopsis:   Saves the behavior specific attributes to Trident
//
//  Arguments:  See Docs for IPersistPropertyBag2
//
//  Returns:    Failure     when a fatal error (behavior cannot run) has occured
//              S_OK        All other cases
//
//------------------------------------------------------------------------------------

STDMETHODIMP 
CBaseBvr::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    if (fClearDirty)
    {
        m_fPropertiesDirty = false;
    }
    return S_OK;
} // Save


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Notification Helpers
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------------------
//
//  Member:     CBaseBvr::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    void
//
//------------------------------------------------------------------------------------

void
CBaseBvr::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IEnumConnections> pEnum;

    {
        CComPtr<IConnectionPoint> pICP;

        m_fPropertiesDirty = true;
        hr = THR(GetConnectionPoint(IID_IPropertyNotifySink, &pICP));
        if (FAILED(hr) || !pICP)
        {
            goto done;
        }
        
        hr = THR(pICP->EnumConnections(&pEnum));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    CONNECTDATA cdata;
    hr = THR(pEnum->Next(1, &cdata, NULL));
    while (hr == S_OK)
    {
        // check cdata for the object we need
        CComPtr<IPropertyNotifySink> pNotify;
        hr = THR(cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify)));
        cdata.pUnk->Release();
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pNotify->OnChanged(dispid));
        if (FAILED(hr))
        {
            goto done;
        }

        // and get the next enumeration
        hr = THR(pEnum->Next(1, &cdata, NULL));
    }

  done:
    return;
} // NotifyPropertyChanged

//
// IServiceProvider interfaces
//
STDMETHODIMP
CBaseBvr::QueryService(REFGUID guidService,
                       REFIID riid,
                       void** ppv)
{
    if (InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        CComPtr<IHTMLWindow2> wnd;

        if (SUCCEEDED(THR(m_pHTMLDoc->get_parentWindow(&wnd))))
        {
            if (wnd)
            {
                if (SUCCEEDED(wnd->QueryInterface(riid, ppv)))
                {
                    return S_OK;
                }
            }
        }
    }

    // Just delegate to our service provider

    return m_pSp->QueryService(guidService,
                               riid,
                               ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\clock.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "clock.h"

static LPCTSTR s_rgtchStarvationWindowClassName = _T("StarveTimer");
static LPCTSTR s_rgtchStarvationWindowName = _T("");

static const ULONG s_ulStarveCallbackInterval = 100;
static const ULONG s_ulStarvationThreshold = 150;
static const ULONG s_ulOptimalThreshold = 90;
static const ULONG s_ulStarvationBackoffConstant = 2;
static const ULONG s_ulStarvationIncreaseConstant = 1;


DeclareTag(tagClock, "TIME: Clock", "Clock methods")
DeclareTag(tagClockStarvation, "TIME: Clock", "Clock starvation")

Clock::Clock()
: m_ulRefs(1),
  m_cookie(0),
  m_lastTime(0.0),
  m_curTime(0.0),
  m_ulLastStarvationCallback(0),
  m_uStarveTimerID(0),
  m_hWndStarveTimer(NULL),
  m_lConsectiveStarvedTicks(0),
  m_fAllowOnTimer(true),
  m_fAllowStarvationCallback(true),
  m_state(CS_STOPPED),
  m_pClockSink(NULL),
  m_interval(0)
{
    TraceTag((tagClock,
              "Clock(%lx)::Clock()",
              this));
}

Clock::~Clock()
{
    TraceTag((tagClock,
              "Clock(%lx)::~Clock()",
              this));

    Stop();

    if (NULL != m_hWndStarveTimer)
    {
        ::DestroyWindow(m_hWndStarveTimer);
    }

    m_pClockSink = NULL;
    m_hWndStarveTimer = NULL;
}

STDMETHODIMP
Clock::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_POINTER;

    if (ppv != NULL)
    {
        hr = E_NOINTERFACE;
        
        if (::IsEqualIID(riid, IID_ITimerSink) ||
            ::IsEqualIID(riid, IID_IUnknown))
        {
            *ppv = (ITimerSink *)this;
            AddRef();
            hr  = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG)
Clock::AddRef(void)
{
    return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
Clock::Release(void)
{
    if (--m_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return m_ulRefs;
}

ULONG
Clock::GetNextInterval (void)
{
    ULONG ulInterval = m_interval;

    // If this is our first time through, 
    // we'll use the interval without question
    if (0 != m_ulLastStarvationCallback)
    {
        // How long since our last starvation callback?
        Assert(m_timer != NULL);

        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));

            if (SUCCEEDED(hr))
            {
                // Have we hit the starvation threshold?  Also allow for the unlikely clock rollover.
                ULONG ulTimeSinceLastStarvationCallback = V_UI4(&v) - m_ulLastStarvationCallback;

                if ((m_ulLastStarvationCallback > V_UI4(&v)) ||
                    (ulTimeSinceLastStarvationCallback > s_ulStarvationThreshold))
                {
                    if (m_lConsectiveStarvedTicks < 0)
                    {
                        m_lConsectiveStarvedTicks = 0;
                    }
                    m_lConsectiveStarvedTicks++;
                    if (m_lConsectiveStarvedTicks > 5)
                    {
                        ulInterval = min(100, ulInterval + s_ulStarvationBackoffConstant);
                        m_lConsectiveStarvedTicks = 0;
                        TraceTag((tagClockStarvation,
                                  "Clock(%p)::Clock(starvation detected, increased interval = %ul)",
                                  this, ulInterval));
                    }
                }
                // Make sure to clear the starved tick count.
                else if ((ulTimeSinceLastStarvationCallback < s_ulOptimalThreshold))
                {
                    if (m_lConsectiveStarvedTicks > 0)
                    {
                        m_lConsectiveStarvedTicks = 0;
                    }
                    m_lConsectiveStarvedTicks--;
                    if (m_lConsectiveStarvedTicks < -5)
                    {
                        ulInterval = max (10, ulInterval - s_ulStarvationIncreaseConstant);
                        m_lConsectiveStarvedTicks = 0;
                        TraceTag((tagClockStarvation,
                                  "Clock(%p)::Clock(no starvation, decreased interval = %ul)",
                                  this, ulInterval));
                    }
                }
                else
                {
                    m_lConsectiveStarvedTicks = 0;
                }
            }
        }
    }

    m_interval = ulInterval;
    return ulInterval;
} // GetNextInterval

STDMETHODIMP
Clock::OnTimer(VARIANT timeAdvise)
{
    HRESULT hr = S_OK;

    // default to 5 milliseconds for next interval
    ULONG ulNextInterval = 5;

    // We have to protect ourselves against 
    // advise sink reentrancy.
    if (m_fAllowOnTimer)
    {
        m_fAllowOnTimer = false;
        // The 'cookie' expires as soon as this
        // callback occurs.
        m_cookie = 0;
        ProcessCB(GetITimerTime());
        // Adjust the new interval based on 
        // current load.
        ulNextInterval = GetNextInterval();
        m_fAllowOnTimer = true;
    }

    hr = THR(SetNextTimerInterval(ulNextInterval));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
Clock::SetITimer(IServiceProvider * serviceProvider, ULONG interval)
{
    HRESULT hr;

    CComPtr<ITimerService> pTimerService;

    if (m_timer)
    {
        m_timer.Release();
    }

    m_interval = interval;
    
    if (!serviceProvider)
    {
        return E_FAIL;
    }
    
    hr = serviceProvider->QueryService(SID_STimerService,
                                       IID_ITimerService,
                                       (void**)&pTimerService);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_timer);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

double
Clock::GetITimerTime()
{
    Assert(m_timer != NULL);

    CComVariant v;
    
    HRESULT hr = S_OK;
    
    if (m_timer)
    {
        hr = THR(m_timer->GetTime(&v));
    }
    else
    {
        return 0.0;
    }

    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return 0.0;
    }

    hr = THR(v.ChangeType(VT_R8));
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return 0.0;
    }

    return (V_R8(&v) / 1000.0);
}

void
Clock::CreateStarveTimerWindow (void)
{
    Assert(NULL == m_hWndStarveTimer);
    if (NULL == m_hWndStarveTimer)
    {
        WNDCLASS wndclass;
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = Clock::StarveWndProc;
        wndclass.hInstance     = _Module.GetModuleInstance();
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = NULL;
        wndclass.lpszClassName = s_rgtchStarvationWindowClassName;
        ::RegisterClass(&wndclass);
        
        m_hWndStarveTimer = ::CreateWindowEx(
            WS_EX_TOOLWINDOW,
            s_rgtchStarvationWindowClassName,
            s_rgtchStarvationWindowName,
            WS_POPUP,
            0, 0, 0, 0,
            NULL,
            NULL,
            wndclass.hInstance,
            (LPVOID)NULL);
        if (NULL != m_hWndStarveTimer)
        {
            ::SetWindowLongPtr(m_hWndStarveTimer, GWLP_USERDATA, (LONG_PTR)this);
        }
    }
} // CreateStarveTimerWindow

void
Clock::SetStarveTimer (void)
{
    // Create the window on demand.
    if (NULL == m_hWndStarveTimer)
    {
        CreateStarveTimerWindow();
    }

    Assert(NULL != m_hWndStarveTimer);
    if (NULL != m_hWndStarveTimer)
    {
        // Make sure to roll past zero.
        if (0 == (++m_uStarveTimerID))
        {
            ++m_uStarveTimerID;
        }
        UINT uRes = ::SetTimer(m_hWndStarveTimer, m_uStarveTimerID, s_ulStarveCallbackInterval, NULL);
        Assert(0 != uRes);
    } //lint !e529
} // SetStarveTimer

HRESULT
Clock::StartITimer()
{
    // This initializes starvation timer as well 
    // as the last-callback-time data, giving us a baseline 
    // from which to judge starvation at startup.
    StarvationCallback();

    return SetNextTimerInterval(m_interval);
} // StartITimer

HRESULT
Clock::SetNextTimerInterval (ULONG ulNextInterval)
{
    HRESULT hr = S_OK;
    
    // Next, get the current time and with the interval set
    // the timer to advise us again.
    VARIANT vtimeMin, vtimeMax, vtimeInt;

    VariantInit( &vtimeMin );
    VariantInit( &vtimeMax );
    VariantInit( &vtimeInt );
    V_VT(&vtimeMin) = VT_UI4;
    V_VT(&vtimeMax) = VT_UI4;
    V_VT(&vtimeInt) = VT_UI4;
    V_UI4(&vtimeMax) = 0;
    V_UI4(&vtimeInt) = 0;

    if (m_timer)
    {
        hr = THR(m_timer->GetTime(&vtimeMin));
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (FAILED(hr))
    {
        goto done;
    }

    V_UI4(&vtimeMin) += ulNextInterval;

    if (m_timer)
    {
        hr = THR(m_timer->Advise(vtimeMin,
                                 vtimeMax,
                                 vtimeInt,
                                 0,
                                 this,
                                 &m_cookie));
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_cookie)
    {
        TraceTag((tagError,
                  "Clock::ITimer::Advise failed with bad cookie"));
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
    
  done:
    return hr;
} // SetNextTimerInterval

HRESULT
Clock::StopITimer()
{
    HRESULT hr = S_OK;
    
    if (m_timer && m_cookie)
    {
        hr = THR(m_timer->Unadvise(m_cookie));

        m_cookie = 0;
    }

    // Stop the starvation timer and 
    // reset the last starvation callback time.
    if (0 != m_uStarveTimerID)
    {
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        m_uStarveTimerID = 0;
    }
    m_ulLastStarvationCallback = 0;

    return hr;
}

HRESULT
Clock::Start()
{
    HRESULT hr;
    
    Stop();

    if (!m_timer)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }

    m_curTime = 0.0;
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
Clock::Pause()
{
    HRESULT hr;

    if (m_state == CS_PAUSED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STARTED)
    {
        hr = THR(StopITimer());

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_state = CS_PAUSED;
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Resume()
{
    HRESULT hr;

    if (m_state == CS_STARTED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STOPPED)
    {
        hr = THR(Start());
        goto done;
    }
    
    Assert(m_state == CS_PAUSED);

    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }
    
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Stop()
{
    THR(StopITimer());
    m_state = CS_STOPPED;
    return S_OK;
}

void
Clock::ProcessCB(double time)
{
    if (m_state == CS_STARTED)
    {
        if (time > m_lastTime)
        {
            m_curTime += (time - m_lastTime);
            m_lastTime = time;

            if (m_pClockSink)
            {
                m_pClockSink->OnTimer(m_curTime);
            }
        }
    }
}

void WINAPI
Clock::StarvationCallback (void)
{
    if (m_fAllowStarvationCallback)
    {
        m_fAllowStarvationCallback = false;
        Assert(m_timer != NULL);

        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));
            if (SUCCEEDED(hr))
            {
                m_ulLastStarvationCallback = V_UI4(&v);
            }
        }
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        SetStarveTimer();
        m_fAllowStarvationCallback = true;
    }
} // StarvationCallback 

LRESULT __stdcall 
Clock::StarveWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    if (uiMessage == WM_TIMER)
    {
        Clock *pThis = reinterpret_cast<Clock *>(::GetWindowLongPtr(hWnd, GWLP_USERDATA));

        if (NULL != pThis)
        {
            pThis->StarvationCallback();
        }
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
} // StarveWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\array.cpp ===
//************************************************************
//
// FileName:        array.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//************************************************************

#include "headers.h"

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//************************************************************
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CImplAry::~CImplAry()
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }
    }

    m_pv = NULL;
    m_c  = 0;
} // ~CImplAry

//************************************************************
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is m_cStack*cb if
//              we're still using the stack-allocated array.
//
//************************************************************

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }

    if(PData()==NULL)
        return 0;
    else return GlobalSize(GlobalPtrHandle(PData()));
} // GetAlloced

//************************************************************
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::EnsureSize(size_t cb, long c)
{
    unsigned long cbAlloc;

    // check to see if we need to do anything
    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        return S_OK;

    Assert(c >= 0);

    cbAlloc = ((c + 7) & ~7) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((m_c + 7) & ~7)) && cbAlloc > (PData()==NULL?0:GlobalSize(GlobalPtrHandle(PData())))))
    {
        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            void *pbDataOld = PData();

            PData() = GlobalAllocPtr(GHND, cbAlloc);
            if (PData() ==  NULL)
            {
                TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                PData() = pbDataOld;
                return E_OUTOFMEMORY;
            }

            if(pbDataOld!=NULL) {
                  int cbOld  = GetAlloced(cb);
                  memcpy(PData(), pbDataOld, cbOld);
            }
        }
        else
        {
            // if we already have a pointer, realloc
            if (PData())
            {
                void *pTemp = GlobalReAllocPtr(PData(), cbAlloc, GHND); //lint !e666 !e522
                if (pTemp == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to realloc memory"));
                    return E_OUTOFMEMORY;
                }

                PData() = pTemp;
            }
            else
            {
                PData() = GlobalAllocPtr(GHND, cbAlloc);
                if (PData() == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                    return E_OUTOFMEMORY;
                }
            }

        }

        m_fDontFree = false;
    }

    return S_OK;
} // EnsureSize

//************************************************************
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::Grow - EnsureSize() failed"));
        return hr;
    }

    // ISSUE - This is a very bad design.  This is too dangerous.
    //          Consider the case where c < m_c.
    // bug #14220, ie6 
    SetSize(c);

    return S_OK;
} // Grow

//************************************************************
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//************************************************************

HRESULT
CImplAry::AppendIndirect(size_t cb, void *pv, void **ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::AppendIndirect - EnsureSize() failed!"));
        return(hr);
    }

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, m_c);
    }

    if (pv == NULL)
    {
        memset(Deref(cb, m_c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, m_c), pv, cb);
    }

    // increment the count
    m_c++;

    return NOERROR;
} // AppendIndirect

//************************************************************
//
//  Member: CImplAry::DeleteItem
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//************************************************************

void
CImplAry::DeleteItem(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)m_c);

    // slide bottom data up one
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (m_c - i - 1) * cb);

    // decrement the count
    m_c--;
} // DeleteItem

//************************************************************
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//************************************************************

bool
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        DeleteItem(cb, i);
        return true;
    }
    
    return false;
} // DeleteByValueIndirect

//************************************************************
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//************************************************************

void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)m_c) && (end < (int)m_c));
    Assert(end >= start);

    if ((unsigned)end < (m_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (m_c - end - 1) * cb);
    }

    m_c -= (end - start) + 1;
} // DeleteMultiple

//************************************************************
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//************************************************************

void
CImplAry::DeleteAll(void)
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }

        if (m_fStack)
        {
            PData() = GetStackPtr();
            m_fDontFree = true;
        }
        else
        {
            PData() = NULL;
        }
    }

    m_c = 0;
} // DeleteAll

//************************************************************
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//************************************************************

HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::InsertIndirect - EnsureSize() failed!"));
        return(hr);
    }

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (m_c - i) * cb);

    if (pv == NULL)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }

    // increment the count
    m_c++;
    return NOERROR;

} // InsertIndirect

//************************************************************
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//************************************************************

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = m_c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return m_c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
} // FindIndirect

//************************************************************
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//************************************************************

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, bool fAddRef)
{
    return(CopyIndirect(cb, ary.m_c, ((CImplAry *)&ary)->PData(), fAddRef));
} // Copy

//************************************************************
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void *pv, bool fAddRef)
{
    if ((pv == NULL) || (cb < 1) || (c < 1))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - invalid param"));
        return E_INVALIDARG;
    }

    // if we point to ourselves, da!
    if (pv == PData())
        return S_OK;

    // clear data out
    DeleteAll();

    // ensure size we now want
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - EnsureSize() failed"));
        return hr;
    }

    // copy data over (blindly)
    memcpy(PData(), pv, c * cb);

    // set element count
    m_c = c;

    if (fAddRef)
    {
        for (IUnknown **ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
} // CopyIndirect

//************************************************************
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//************************************************************

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
} // EnsureSize

//************************************************************

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
} // Grow

//************************************************************

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
} // Append

//************************************************************

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
} // Insert

//************************************************************

int
CImplPtrAry::Find(void * pv)
{
    int    i;
    void **ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < m_c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
} // Find

//************************************************************

void
CImplPtrAry::DeleteItem(int i)
{
    CImplAry::DeleteItem(sizeof(void *), i);
}

//************************************************************

bool
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::DeleteItem(sizeof(void *), i);
        return true;
    }

    return false;
} // DeleteByValue

//************************************************************

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
} // DeleteMultiple

//************************************************************

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown *pUnk;

    Assert(idx <= (int)m_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        ReleaseInterface(pUnk);

    DeleteItem(idx);
} // ReleaseAndDelete

//************************************************************

void
CImplPtrAry::ReleaseAll(void)
{
    int        i;
    IUnknown **ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < m_c; i++, ppUnk++)
    {
        if (*ppUnk)
            ReleaseInterface(*ppUnk);
    }

    DeleteAll();
} // ReleaseAll

//************************************************************

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, bool fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
} // CopyIndirect

//************************************************************

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, bool fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
} // Copy

//************************************************************

HRESULT
CImplPtrAry::EnumElements(REFIID   iid,
                          void   **ppv,
                          bool     fAddRef,
                          bool     fCopy,
                          bool     fDelete)
{
    return CImplAry::EnumElements(sizeof(void *),
                                  iid,
                                  ppv,
                                  fAddRef,
                                  fCopy,
                                  fDelete);
} // EnumElements

//************************************************************

HRESULT
CImplPtrAry::EnumVARIANT(VARTYPE        vt,
                         IEnumVARIANT **ppenum,
                         bool           fCopy,
                         bool           fDelete)
{
    return CImplAry::EnumVARIANT(sizeof(void *),
                                 vt,
                                 ppenum,
                                 fCopy,
                                 fDelete);
} // EnumVARIANT

//************************************************************

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//************************************************************
//
//  CBaseEnum Implementation
//
//************************************************************

//************************************************************
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [rgItems] -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//************************************************************

HRESULT
CBaseEnum::Init(CImplAry *rgItems, bool fCopy)
{
    HRESULT   hr = S_OK;
    CImplAry *rgCopy = NULL;     // copied array

    if (rgItems == NULL)
    {
        TraceTag((tagError, "CBaseEnum::Init - invalid param"));
        return E_INVALIDARG;
    }

    // Copy array if necessary.
    if (fCopy)
    {
        rgCopy = NEW CImplAry;
        if (rgCopy == NULL)
        {
            TraceTag((tagError, "CBaseEnum::Init - unable to alloc memory for new array class"));
            return E_OUTOFMEMORY;
        }

        hr = rgCopy->Copy(m_cb, *rgItems, m_fAddRef);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CBaseEnum::Init - Copy() failed"));
            delete rgCopy;
            return hr;
        }

        rgItems = rgCopy;
    }

    m_rgItems = rgItems;

    return hr;
} // Init

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete)
{
    m_ulRefs     = 1;

    m_cb         = cb;
    m_rgItems    = NULL;
    m_piid       = &iid;
    m_i          = 0;
    m_fAddRef    = fAddRef;
    m_fDelete    = fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//************************************************************

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{ //lint !e1538
    m_ulRefs     = 1;

    m_cb         = benum.m_cb;
    m_piid       = benum.m_piid;
    m_rgItems    = benum.m_rgItems;
    m_i          = benum.m_i;
    m_fAddRef    = benum.m_fAddRef;
    m_fDelete    = benum.m_fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//************************************************************

CBaseEnum::~CBaseEnum(void)
{
    IUnknown **ppUnk;
    int        i;

    if (m_rgItems && m_fDelete)
    {
        if (m_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < m_rgItems->Size();
                 i++, ppUnk++)
            {
                ReleaseInterface(*ppUnk);
            }
        }

        delete m_rgItems;
    }
    m_piid = NULL;
} // ~CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//************************************************************

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *m_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Skip

//************************************************************
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Reset(void)
{
    m_i = 0;
    return S_OK;
} // Reset

//************************************************************
//
//  CEnumGeneric Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumGeneric : public CBaseEnum
{
public:
    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    //
    //  CEnumGeneric methods
    //
    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          REFIID          iid,
                          bool            fAddRef,
                          bool            fCopy,
                          bool            fDelete,
                          CEnumGeneric  **ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
    CEnumGeneric();
}; // class CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumGeneric::Create(size_t          cb,
                     CImplAry       *rgItems,
                     REFIID          iid,
                     bool            fAddRef,
                     bool            fCopy,
                     bool            fDelete,
                     CEnumGeneric  **ppenum)
{
    HRESULT         hr = S_OK;
    CEnumGeneric   *penum;

    Assert(rgItems);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    
    *ppenum = NULL;
    
    penum = NEW CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (penum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Create - unable to alloc memory for CEnumGeneric"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete) :
    CBaseEnum(cb, iid, fAddRef, fDelete)
{
} // CEnumGeneric (size_t, REFIID, bool, bool)

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
} // CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    int        c;
    int        i;
    IUnknown **ppUnk;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumGeneric::Next - invalid params"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    if (m_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(m_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    memcpy(reelt, (BYTE *) Deref(m_i), c * m_cb);
    
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;

    hr = m_rgItems->EnumElements(m_cb, *m_piid, (void **) ppenum, m_fAddRef);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumGeneric::Clone - EnumElements() failed"));
        return hr;
    }
    
    (**(CEnumGeneric **)ppenum).m_i = m_i;
    
    return S_OK;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumElements(size_t   cb,
                       REFIID   iid,
                       void   **ppv,
                       bool     fAddRef,
                       bool     fCopy,
                       bool     fDelete)
{
    Assert(ppv);
    return CEnumGeneric::Create(cb,
                                this,
                                iid,
                                fAddRef,
                                fCopy,
                                fDelete,
                                (CEnumGeneric **) ppv);
} // EnumElements

//************************************************************
//
//  CEnumVARIANT Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumVARIANT : public CBaseEnum
{
public:
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          VARTYPE         vt,
                          bool            fCopy,
                          bool            fDelete,
                          IEnumVARIANT  **ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);
    CEnumVARIANT();

    VARTYPE     m_vt;                    // type of element enumerated
}; // class CEnumVARIANT

//************************************************************
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumVARIANT::Create(size_t          cb,
                     CImplAry       *rgItems,
                     VARTYPE         vt,
                     bool            fCopy,
                     bool            fDelete,
                     IEnumVARIANT  **ppenum)
{
    HRESULT hr = S_OK;

    Assert(rgItems);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));

    *ppenum = NULL;

    CEnumVARIANT *penum = NEW CEnumVARIANT(cb, vt, fDelete);
    if (penum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Create - unable to alloc mem for CEnumVARIANT"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Create - Init() failed"));
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = (IEnumVARIANT *) (void *) penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete) :
    CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    m_vt = vt;
} // CEnumVARIANT (size_t, VARTYPE, bool)

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    m_vt = enumv.m_vt;
} // CEnumVARIANT(const CEnumVARIANT&)

//************************************************************
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE       *pb;
    VARIANT    *pvar;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumVARIANT::Next - invalid param"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    for (i = 0, pb = (BYTE *) Deref(m_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += m_cb, pvar++)
    {
        V_VT(pvar) = m_vt;
        switch (m_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == m_cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == m_cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == m_cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == m_cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == m_cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == m_cb);
            hr = (*(IUnknown **) pb)->QueryInterface(IID_TO_PPV(IDispatch, &V_DISPATCH(pvar)));
            if (FAILED(hr))
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ReleaseInterface(((IDispatch **) reelt)[j]);
                }

                return hr;
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    m_i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum **ppenum)
{
    HRESULT hr = S_OK;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;
   
    hr = m_rgItems->EnumVARIANT(m_cb, m_vt, (IEnumVARIANT **)ppenum);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - EnumVARIANT() failed"));
        return hr;
    }

    (**(CEnumVARIANT **)ppenum).m_i = m_i;
    
    return hr;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumVARIANT(size_t         cb,
                      VARTYPE        vt,
                      IEnumVARIANT **ppenum,
                      bool           fCopy,
                      bool           fDelete)
{
    Assert(ppenum);
    return CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
} // EnumVARIANT

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\comutil.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: comutil.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "comutil.h"

/////////////////////////////////////////////////////////////////////////////
// CTIMEComTypeInfoHolder

void CTIMEComTypeInfoHolder::AddRef()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        m_dwRef++;
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CTIMEComTypeInfoHolder::Release()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (--m_dwRef == 0)
        {
                if (m_pInfo != NULL)
                        m_pInfo->Release();
                m_pInfo = NULL;
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CTIMEComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
    //If this assert occurs then most likely didn't initialize properly
    _ASSERTE(m_pguid != NULL);
    _ASSERTE(ppInfo != NULL);
    USES_CONVERSION; //lint !e522
    *ppInfo = NULL;

    HRESULT hRes = E_FAIL;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (m_pInfo == NULL)
    {
        TCHAR szModule[MAX_PATH];

        GetModuleFileName(_Module.m_hInstTypeLib, szModule, MAX_PATH);

        if (m_ptszIndex != NULL)
        {
            PathAppend(szModule, m_ptszIndex);
        }
            
        ITypeLib* pTypeLib;
        LPOLESTR lpszModule = T2OLE(szModule);
        hRes = LoadTypeLib(lpszModule, &pTypeLib);

        if (SUCCEEDED(hRes))
        {
            ITypeInfo* pTypeInfo;
            hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
            if (SUCCEEDED(hRes))
            {
                m_pInfo = pTypeInfo;
            }
            pTypeLib->Release();
        }
    }
    *ppInfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hRes = S_OK;
    }

    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    return hRes;
} //lint !e550

HRESULT CTIMEComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
        ITypeInfo** pptinfo)
{
        HRESULT hRes = E_POINTER;
        if (pptinfo != NULL)
                hRes = GetTI(lcid, pptinfo);
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
        UINT cNames, LCID lcid, DISPID* rgdispid)
{
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                pInfo->Release();
        }
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        SetErrorInfo(0, NULL);
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                pInfo->Release();
        }
        return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\dlldatax.c ===
// wrapper for dlldata.c

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400     //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY      //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "mstimepdlldata.c"
#include "mstimep_p.c"

#undef DllMain
#undef DllRegisterServer
#undef DllUnRegisterServer
#undef DllGetClassObject
#undef DllCanUnloadNow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\eventmgr.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1999 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//    Manages all event interaction between TIME behaviors
//    and the Trident object model.
//
///////////////////////////////////////////////////////////////


#include "headers.h"
#include <string.h>
#include "EventMgr.h"
#include "mshtmdid.h"
#include "dispex.h"
#include "tokens.h"

static struct {
    TIME_EVENT event;
    wchar_t * wsz_name;
} g_FiredEvents[] =
{
    { TE_ONTIMEERROR,        L"ontimeerror"        },
    { TE_ONBEGIN,            L"onbegin"            },
    { TE_ONPAUSE,            L"onpause"            },
    { TE_ONRESUME,           L"onresume"           },
    { TE_ONEND,              L"onend"              },
    { TE_ONRESYNC,           L"onresync"           },
    { TE_ONREPEAT,           L"onrepeat"           },
    { TE_ONREVERSE,          L"onreverse"          },
    { TE_ONMEDIACOMPLETE,    L"onmediacomplete"    },
    { TE_ONOUTOFSYNC,        L"onoutofsync"        },
    { TE_ONSYNCRESTORED,     L"onsyncrestored"     },
    { TE_ONMEDIAERROR,       L"onmediaerror"       },
    { TE_ONRESET,            L"onreset"            },
    { TE_ONSCRIPTCOMMAND,    L"onscriptcommand"    },
    { TE_ONMEDIABARTARGET,   L"onmediabartarget"   },
    { TE_ONURLFLIP,          L"onurlflip"          },
    { TE_ONTRACKCHANGE,      L"ontrackchange"      },
    { TE_GENERIC,            NULL                  },
    { TE_ONSEEK,             L"onseek"             },
    { TE_ONMEDIAINSERTED,    L"onmediainserted"    },
    { TE_ONMEDIAREMOVED,     L"onmediaremoved"     },
    { TE_ONTRANSITIONINBEGIN,L"ontransitioninbegin"  },
    { TE_ONTRANSITIONINEND,  L"ontransitioninend"    },
    { TE_ONTRANSITIONOUTBEGIN, L"ontransitionoutbegin"  },
    { TE_ONTRANSITIONOUTEND, L"ontransitionoutend"    },
    { TE_ONTRANSITIONREPEAT, L"ontransitionrepeat" },
    { TE_ONUPDATE,           NULL                  },
    { TE_ONCODECERROR,       L"oncodecerror"       },
    { TE_MAX,                NULL                  },
};


static struct {
    TIME_EVENT_NOTIFY event;
    wchar_t * wsz_name;
} g_NotifiedEvents[] =
{
    { TEN_LOAD,             NULL                }, // this is null because there is no event to attach to,
    { TEN_UNLOAD,           NULL                }, // these are events that are automatically hooked up 
    { TEN_STOP,             NULL                }, // when attaching to the document's event
    { TEN_READYSTATECHANGE, NULL                }, // through the connection point interfaces.
    { TEN_MOUSE_DOWN,       L"onmousedown"      },
    { TEN_MOUSE_UP,         L"onmouseup"        },
    { TEN_MOUSE_CLICK,      L"onclick"          },
    { TEN_MOUSE_DBLCLICK,   L"ondblclick"       },
    { TEN_MOUSE_OVER,       L"onmouseover"      },
    { TEN_MOUSE_OUT,        L"onmouseout"       },
    { TEN_MOUSE_MOVE,       L"onmousemove"      },
    { TEN_KEY_DOWN,         L"onkeydown"        },
    { TEN_KEY_UP,           L"onkeyup"          },
    { TEN_FOCUS,            L"onfocus"          },
    { TEN_RESIZE,           L"onresize"         },
    { TEN_BLUR,             L"onblur"           },
};

static OLECHAR *g_szSysTime = L"time";
#define GENERIC_PARAM 0                //this is used to get the name from the parameter list of a dynamic event

DeclareTag(tagEventMgr, "TIME: Events", "Event Manager methods")

CEventMgr::CEventMgr()
:   m_dwWindowEventConPtCookie(0),
    m_dwDocumentEventConPtCookie(0),
    m_pEventSite(NULL),
    m_bInited(false),
    m_fLastEventTime(0),
    m_pBvrSiteOM(NULL),
    m_bAttached(false),
    m_bUnLoaded(false),
    m_pElement(NULL),
    m_pEndEvents(NULL),
    m_pBeginEvents(NULL),
    m_lRefs(0),
    m_bDeInited(false),
    m_bReady(false),
    m_bEndAttached(false),
    m_lEventRecursionCount(0)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::EventMgr",
              this));

    memset(m_bRegisterEvents, 0, sizeof(bool) * TE_MAX);
    memset(m_bNotifyEvents, 0, sizeof(bool) * TEN_MAX);
    memset(m_cookies, 0, sizeof(bool) * TE_MAX);
};


    
CEventMgr::~CEventMgr()
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::~EventMgr",
              this));

    
    delete [] m_pBeginEvents;
    m_pBeginEvents = NULL;
    delete [] m_pEndEvents;
    m_pEndEvents = NULL;
    
    if (m_pEventSite)
    {
        CTIMEEventSite *pEventSite = m_pEventSite;
        m_pEventSite = NULL;
        pEventSite->Release();
    }

    if (m_pBvrSiteOM)
    {
        m_pBvrSiteOM->Release();
        m_pBvrSiteOM = NULL;
    }
};


///////////////////////////////////////////////////////////////////////////
// _InitEventMgrNotify
//
// Summary:
//     This needs to be called during initialization to set the
//     CTIMEEventSite class.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::_InitEventMgrNotify(CTIMEEventSite *pEventSite)
{
    
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_InitEventMgrNotify(%lx)",
              this, pEventSite));
   
    HRESULT hr = S_OK;
    Assert(pEventSite);
    if (!pEventSite)
    {
        hr = E_FAIL;
    }
    else
    {
        m_pEventSite = pEventSite;
        m_pEventSite->AddRef();
    }
    return hr;
};

///////////////////////////////////////////////////////////////////////////
// _RegisterEventNotification
//
// Summary:
//     Sets a flag that tells the event manager to notify the CTIMEEventSite
//     class that a specific event has occured. This may only be called before
//     the onLoad event is fired.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::_RegisterEventNotification(TIME_EVENT_NOTIFY event_id)
{
    
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_RegisterEventNotification(%l)",
              this, event_id));

    HRESULT hr = S_OK;
    Assert(event_id >= 0 && event_id < TEN_MAX);

    if(m_bInited == true)
    {
        hr = E_FAIL;
    }
    else
    {
        m_bNotifyEvents[event_id] = true;
    }
    return hr;

};

///////////////////////////////////////////////////////////////////////////
// _RegisterEvent
//
// Summary:
//     Sets a flag that tells the event manager to register a specific event 
//     that the time class can fire.  This can only be called before the 
//     onLoad event is fired.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::_RegisterEvent(TIME_EVENT event_id)
{
    
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_RegisterEvent(%l)",
              this, event_id));

    HRESULT hr = S_OK;
    Assert(event_id >= 0 && event_id < TE_MAX);

    if(m_bInited == true)
    {
        hr = E_FAIL;
    }
    else
    {
        m_bRegisterEvents[event_id] = true;
    }
    return hr;
};

///////////////////////////////////////////////////////////////
//  Name: _SetTimeEvent
// 
//  Abstract: New Syntax
///////////////////////////////////////////////////////////////
HRESULT 
CEventMgr::_SetTimeEvent(int type, TimeValueList & tvList)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_SetTimeEvent()",
              this));
    
    HRESULT hr = S_OK;

    IGNORE_HR(DetachEvents());
    
    //delete the old list of events
    if (type == TEM_BEGINEVENT)
    {
        hr = THR(SetNewEventStruct(tvList, &m_pBeginEvents));
    }
    else if (type == TEM_ENDEVENT)
    {
        hr = THR(SetNewEventStruct(tvList, &m_pEndEvents));
    }
    
    if (SUCCEEDED(hr))
    {
        hr = AttachEvents();  //attach to all events in all lists.
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: _SetTimeEvent
// 
//  Abstract:  This is to support old syntax and is string based
///////////////////////////////////////////////////////////////
HRESULT 
CEventMgr::_SetTimeEvent(int type, LPOLESTR lpstrEvents)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_SetTimeEvent(%ls)",
              this, lpstrEvents));
    
    HRESULT hr = S_OK;

    IGNORE_HR(DetachEvents());
    
    //delete the old list of events
    if (type == TEM_BEGINEVENT)
    {
        hr = THR(SetNewEventList(lpstrEvents, &m_pBeginEvents));
    }
    else if (type == TEM_ENDEVENT)
    {
        hr = THR(SetNewEventList(lpstrEvents, &m_pEndEvents));
    }
    
    if (SUCCEEDED(hr))
    {
        hr = AttachEvents();  //attach to all events in all lists.
    }

    return hr;
};



HRESULT CEventMgr::_Init(IHTMLElement *pEle, IElementBehaviorSite *pEleBehaviorSite)
{
    TraceTag((tagEventMgr,
          "EventMgr(%lx)::_Init(%lx)",
          this, pEle));
    
    HRESULT hr = S_OK;

    if (!pEle)
    {
        hr = E_FAIL;
        goto done;
    }
    else
    {
        m_pElement = pEle;
    }

    if (!pEleBehaviorSite)
    {   
        hr = E_FAIL;
        goto done;
    }
    else
    {
        hr = THR(pEleBehaviorSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **)&m_pBvrSiteOM));
        if (FAILED(hr))
        {
            goto done;
        }
        Assert(m_pBvrSiteOM);
    }

    hr = THR(ConnectToContainerConnectionPoint());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(RegisterEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    // We need to do this here since dynamically added objects do not
    // always fire the readystatechange event
    UpdateReadyState();
  done:
    if (FAILED(hr))
    {
        if (m_pBvrSiteOM != NULL)
        {
            m_pBvrSiteOM->Release();
            m_pBvrSiteOM = NULL;
        }
    }
    return hr;
};

HRESULT CEventMgr::_Deinit()
{
    TraceTag((tagEventMgr,
      "EventMgr(%lx)::_Deinit()",
      this));
    

    //clean up the event lists.
    IGNORE_HR(SetNewEventList(NULL, &m_pBeginEvents));
    IGNORE_HR(SetNewEventList(NULL, &m_pEndEvents));

    //release the document and window connection points
    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
        m_dwWindowEventConPtCookie = 0;
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
        m_dwDocumentEventConPtCookie = 0;
    }

    //release the behavior site
    if (m_pBvrSiteOM != NULL)
    {
        m_pBvrSiteOM->Release();
        m_pBvrSiteOM = NULL;
    }

    //cleanup memory
    if (m_lRefs == 0 && m_pEventSite)
    {        
        CTIMEEventSite *pEventSite = m_pEventSite;
        m_pEventSite = NULL;
        pEventSite->Release();
    }
    m_bDeInited = true;
    return S_OK;
};


///////////////////////////////////////////////////////////////
//  Name: _FireEvent
// 
//  Abstract:
//    This is invoked by the FIRE_EVENT macro to allow
//    the controlling class to fire standard TIME events.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::_FireEvent(TIME_EVENT TimeEvent, 
                               long lCount, 
                               LPWSTR szParamNames[], 
                               VARIANT varParams[], 
                               float fTime)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::_FireEvent()",
              this));
    
    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj> pEventObj;
    CComPtr <IHTMLEventObj2> pEventObj2;
    int i = 0;
    VARIANT vEventTime;
    
    m_lEventRecursionCount++;
    if (m_lEventRecursionCount >= 100)
    {
        goto done;
    }

    if (m_pEventSite == NULL || m_pEventSite->IsThumbnail() == true)
    {
        goto done;
    }

    if (!m_pBvrSiteOM)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_bUnLoaded)
    {
        goto done;
    }

    if (TimeEvent < 0 || TimeEvent >= TE_MAX)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_bRegisterEvents[TimeEvent] == false)
    {
        //this event is not registered, fail
        hr = E_FAIL;
        goto done;
    }

    //create the event object
    hr = THR(m_pBvrSiteOM->CreateEventObject(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    if (pEventObj != NULL)
    {
        hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
        if (FAILED(hr))
        {
            goto done;
        }

        IGNORE_HR(pEventObj2->put_type(g_FiredEvents[TimeEvent].wsz_name + 2));

        //set the event time on the event object
        VariantInit(&vEventTime);
        V_VT(&vEventTime) = VT_R8;
        V_R8(&vEventTime) = fTime;
        
        {
            hr = THR(pEventObj2->setAttribute(g_szSysTime, vEventTime, VARIANT_FALSE)); 
            if (FAILED(hr))
            {
                goto done;
            }
        }
        
        VariantClear(&vEventTime);
        
        //unpack the parameter list and add it to the event object
        for (i = 0; i < lCount; i++)
        {
            hr = THR(pEventObj2->setAttribute(szParamNames[i], varParams[i], VARIANT_FALSE));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    //fire the event
    hr = THR(m_pBvrSiteOM->FireEvent(m_cookies[TimeEvent], pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    //if a dynamic event needs to be fired, call FireDynanicEvent
    if (TE_ONSCRIPTCOMMAND == TimeEvent)
    {
        hr = THR(FireDynamicEvent(TE_GENERIC, lCount, szParamNames, varParams, fTime));
    }

  done:

    m_lEventRecursionCount--;
    return hr;

};

///////////////////////////////////////////////////////////////
//  Name: FireDynamicEvent
// 
//  Abstract:
//    Handles the registration and firing of dynamic events
//    that come across on media streams.  This should only
//    be called from _FireEvent in the case of OnScriptCommand 
//    events.  
//
//    NOTE: This code is very similar to _FireEvent.  It is 
//          currently here to keep the implementation cleaner
//          At some point this could possible be compressed into
//          a single FireEvent routine.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::FireDynamicEvent(TIME_EVENT TimeEvent, 
                                     long lCount, 
                                     LPWSTR szParamNames[], 
                                     VARIANT varParams[],
                                     float fTime)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::FireDynamicEvent()",
              this));

    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj> pEventObj;
    CComPtr <IHTMLEventObj2> pEventObj2;
    WCHAR *pwszGenericName = NULL;
    long lCookie = 0;
    BSTR bstrType = NULL;
    int i = 0;
    VARIANT vEventTime;

    Assert (TimeEvent == TE_GENERIC); //This current only handles TE_GENERIC events.

    //register the event.
    if (varParams[GENERIC_PARAM].bstrVal == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // build string name - "on" + Param + NULL
    pwszGenericName = NEW WCHAR[lstrlenW(varParams[GENERIC_PARAM].bstrVal)+(2*sizeof(WCHAR))+sizeof(WCHAR)];
    if (pwszGenericName == NULL)
    {
        TraceTag((tagError, "CEventMgr::FireDynamicEvent - unable to alloc mem for string"));
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ocscpy(pwszGenericName, L"on");
    lstrcatW(pwszGenericName, varParams[GENERIC_PARAM].bstrVal);

    hr = THR(m_pBvrSiteOM->GetEventCookie(pwszGenericName, &lCookie));
    if (FAILED(hr))
    {
        hr = THR(m_pBvrSiteOM->RegisterEvent(pwszGenericName, 0, &lCookie));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //create the event object
    hr = THR(m_pBvrSiteOM->CreateEventObject(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    //set event object type parameter
    bstrType = SysAllocString(pwszGenericName);
    if (bstrType != NULL)
    {
        IGNORE_HR(pEventObj2->put_type(bstrType));
        SysFreeString(bstrType);
        bstrType = NULL;
    }
    else 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    //unpack the parameter list and add it to the event object
    for (i = 0; i < lCount; i++)
    {
        BSTR bstrParamName = SysAllocString(szParamNames[i]);
        if (bstrParamName != NULL)
        {
            hr = THR(pEventObj2->setAttribute(bstrParamName, varParams[i], VARIANT_FALSE));
            SysFreeString (bstrParamName);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
    //set the event time on the event object
    VariantInit(&vEventTime);
    V_VT(&vEventTime) = VT_R8;
    V_R8(&vEventTime) = fTime;
    {
        BSTR bstrEventTime = SysAllocString(g_szSysTime);
        if (bstrEventTime != NULL)
        {
            hr = THR(pEventObj2->setAttribute(bstrEventTime, vEventTime, VARIANT_FALSE)); 
            SysFreeString(bstrEventTime);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    VariantClear(&vEventTime);
    
    //fire the event
    hr = THR(m_pBvrSiteOM->FireEvent(lCookie, pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

  done:

    if (pwszGenericName)
    {
        delete [] pwszGenericName;
        pwszGenericName = NULL;
    }

    return hr;

}

HRESULT CEventMgr::_RegisterDynamicEvents(LPOLESTR lpstrEvents)  //unsure how this will be handled or used.
{

    //TODO
    
    return S_OK;
};



///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch) || InlineIsEqualGUID(riid, DIID_HTMLWindowEvents))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::AddRef(void)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::AddRef()",
              this));

    long i = 0;
    m_lRefs++;
    if (m_pEventSite)
    {
        i = m_pEventSite->AddRef();
    }
    return i;
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::Release(void)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::Release()",
              this));
    long i = 0;
    m_lRefs--;
    if (m_pEventSite)
    {
        i = m_pEventSite->Release();
    }
    if (m_lRefs == 0 && m_bDeInited == true)
    {
        // release the controlling behavior
        if (m_pEventSite)
        {
            CTIMEEventSite *pEventSite = m_pEventSite;
            m_pEventSite = NULL;
            pEventSite->Release();
            
        }
    }
    return i;
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    HRESULT hr = S_OK;
    int i = 0;
    bool bEndZeroOffset = false;
    bool bBeginZeroOffset = false;
    
    float fTime = valueNotSet;

    // Bail if we are deinited
    if (m_bDeInited)
    {
        goto done;
    }

    if (dispIdMember != 0)  //no need to check dispid's if this is an attached event.
    {
        if (m_pBeginEvents != NULL)
        {
            for (i = 0; i < m_pBeginEvents->lEventCount; i++)
            {
                if (dispIdMember == m_pBeginEvents->pEventDispids[i])
                {
                    if (m_pBeginEvents->pEventList[i].offset != 0.0f)
                    {
                        m_pEventSite->onBeginEndEvent(true, fTime, m_pBeginEvents->pEventList[i].offset, false, 0.0f, 0.0f);
                    }
                    else
                    {
                        bBeginZeroOffset = true;
                    }
                }
            }
        }   
        if (m_pEndEvents != NULL)
        {     
            for (i = 0; i < m_pEndEvents->lEventCount; i++)
            {
                if (dispIdMember == m_pEndEvents->pEventDispids[i])
                {
                    if (m_pEndEvents->pEventList[i].offset != 0.0f)
                    {
                        if (m_bEndAttached == true)
                        {
                            m_pEventSite->onBeginEndEvent(false, 0.0f, 0.0f, true, fTime, m_pEndEvents->pEventList[i].offset);
                        }
                    }
                    else
                    {
                        bEndZeroOffset = true;
                    }
                }
            }
        }
    }
    
    switch (dispIdMember)
    {
      case 0: //this is the case for events that have been hooked using attachEvent
        {
            BSTR bstrEvent;
            CComPtr <IHTMLEventObj> pEventObj;
            CComPtr <IHTMLEventObj2> pEventObj2;
                
            if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
                (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
            {
                hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                Assert(0 && "Unexpected dispparam values passed to CEventMgr::Invoke(dispid = 0)");
                hr = E_UNEXPECTED;
                goto done;
            }
            
            hr = THR(pEventObj->get_type(&bstrEvent));
            //track if this is a click event so the following document.onclick may be ignored.

            hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
            if (SUCCEEDED(hr))
            {
                VARIANT vTime;
                VariantInit(&vTime);
                hr = THR(pEventObj2->getAttribute(g_szSysTime, 0, &vTime));
                if (FAILED(hr))
                {
                    fTime = valueNotSet;
                }
                else
                {
                    hr = VariantChangeTypeEx(&vTime, &vTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
                    if (FAILED(hr))
                    {
                        fTime = valueNotSet;
                    }
                    else
                    {
                        fTime = (float)V_R8(&vTime);
                    }
                }

                VariantClear(&vTime);
            }

            EventMatch(pEventObj, m_pBeginEvents, bstrEvent, TETYPE_BEGIN, fTime, &bBeginZeroOffset);
            if (m_bEndAttached == true)
            {
                EventMatch(pEventObj, m_pEndEvents, bstrEvent, TETYPE_END, fTime, &bEndZeroOffset);
            }

            SysFreeString(bstrEvent);
            bstrEvent = NULL;
            EventNotifyMatch(pEventObj);
        }
        break;
        
      case DISPID_EVPROP_ONPROPERTYCHANGE:
      case DISPID_EVMETH_ONPROPERTYCHANGE:
        break;

      case DISPID_EVPROP_ONLOAD:
      case DISPID_EVMETH_ONLOAD:
        if (m_bNotifyEvents[TEN_LOAD] == true)
        {
            m_pEventSite->onLoadEvent();
        }
          
        break;

      case DISPID_EVPROP_ONUNLOAD:
      case DISPID_EVMETH_ONUNLOAD:
        //detach from all events
        IGNORE_HR(DetachEvents());
        DetachNotifyEvents();

        if (m_bNotifyEvents[TEN_UNLOAD] == true)
        {            
            m_pEventSite->onUnloadEvent();
        }
        m_bUnLoaded = true;
        break;

      case DISPID_EVPROP_ONSTOP:
      case DISPID_EVMETH_ONSTOP:
        if (m_bNotifyEvents[TEN_STOP] == true)
        {
            float fStopTime = m_pEventSite->GetGlobalTime();
            m_pEventSite->onStopEvent(fStopTime);
        }
        break;

      case DISPID_EVPROP_ONREADYSTATECHANGE:
      case DISPID_EVMETH_ONREADYSTATECHANGE:
        if (!m_bUnLoaded)
        {
            UpdateReadyState();
        }
        break;
      default:
        {
            //for lint compatibility
        }
         
    }

    if (bBeginZeroOffset || bEndZeroOffset)
    {
        m_pEventSite->onBeginEndEvent(bBeginZeroOffset, fTime, 0.0f, bEndZeroOffset, fTime, 0.0f);
    }

  done:
    return S_OK;
};


HRESULT CEventMgr::RegisterEvents()
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::RegisterEvents",
              this));
    int i = 0;

    HRESULT hr = S_OK;

    Assert(m_pBvrSiteOM);
    
    if (m_pBvrSiteOM == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    for (i = 0; i < TE_MAX; i++)
    {
        if (g_FiredEvents[i].wsz_name != NULL && m_bRegisterEvents[i] == true)
        {
            hr = THR(m_pBvrSiteOM->RegisterEvent(g_FiredEvents[i].wsz_name, 0, (long *) &m_cookies[i]));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: Attach
// 
//  Abstract:
//      Attaches to the events in a single event list.
//
///////////////////////////////////////////////////////////////

HRESULT CEventMgr::Attach(Event *pEvent)
{
    TraceTag((tagEventMgr,
      "EventMgr(%lx)::Attach()",
      this));

    int i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess = FALSE;

    if (pEvent == NULL)
    {
        goto done;
    }

    for (i = 0; i < pEvent->lEventCount; i++)
    {
        CComPtr <IHTMLElement> pEle;
        CComPtr <IHTMLElement2> pSrcEle;
        CComPtr <IHTMLDocument2> pDoc2;
        CComPtr <IHTMLElementCollection> pEleCol;
        CComPtr <IDispatch> pSrcDisp;
        CComPtr <IDispatch> pDocDisp;
        CComPtr <IDispatchEx> pDispEx;

        pEvent->pEventDispids[i] = INVALID_DISPID; //invalid dispid

        //get the document
        hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pEle));
        if (FAILED(hr))
        {
            continue;
        }

        hr = THR(pEle->get_document(&pDocDisp));
        if (FAILED(hr))
        {
            continue;
        }

        hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2));
        if (FAILED(hr))
        {
            continue;
        }
        if (StrCmpIW(pEvent->pEventList[i].pElementName, L"document") == 0)
        {

            DISPID dispid;
            CComPtr <ITypeLib> pTypeLib;
            CComPtr <ITypeInfo> pTypeInfo;
            CComPtr <ITypeInfo> pTypeInfoEvents;
            CComPtr <IDispatch> pDispatch;
            BSTR bstrEvent;
            unsigned int index = 0;

            //This code loads the typelib for the IHTMLDocument2 interface,
            //and gets the ID for the event from the type info for the
            //HTMLDocumentEvents dispinterface.
            hr = THR(pDoc2->QueryInterface(IID_IDispatch, (void**)&pDispatch));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pDispatch->GetTypeInfo(0, LCID_SCRIPTING, &pTypeInfo));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pTypeInfo->GetContainingTypeLib(&pTypeLib, &index));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pTypeLib->GetTypeInfoOfGuid(DIID_HTMLDocumentEvents, &pTypeInfoEvents));
            if (FAILED(hr))
            {
                continue;
            }

            bstrEvent = SysAllocString(pEvent->pEventList[i].pEventName);
            if (bstrEvent != NULL)
            {
                hr = THR(pTypeInfoEvents->GetIDsOfNames(&bstrEvent, 1, &dispid));
                SysFreeString(bstrEvent);
                bstrEvent = NULL;
                if (FAILED(hr))
                {
                    continue;
                }
                pEvent->pEventDispids[i] = dispid;
            }
            else
            {
                continue;
            }

            continue; 
        }

        {
            VARIANT vName;
            VARIANT vIndex;

            //get all elements in the document
            hr = THR(pDoc2->get_all(&pEleCol));
            if (FAILED(hr))
            {
                continue;
            }

            //find the element with the correct name
            VariantInit(&vName);
            vName.vt = VT_BSTR;
            vName.bstrVal = SysAllocString(pEvent->pEventList[i].pElementName);

            VariantInit(&vIndex);
            vIndex.vt = VT_I2;
            vIndex.iVal = 0;

            hr = THR(pEleCol->item(vName, vIndex, &pSrcDisp));
            
            VariantClear(&vName);
            VariantClear(&vIndex);
            if (FAILED(hr))
            {
                continue;
            }
            if (!pSrcDisp) //will be NULL if the vName is invalid element.
            {
                pEvent->pEventElements[i] = NULL;
                continue;
            }

            hr = THR(pSrcDisp->QueryInterface(IID_IHTMLElement2, (void**)&pSrcEle));
            if (FAILED(hr))
            {
                continue;
            }

            //cache the IHTMLElement2 pointer for use on detach
            pEvent->pEventElements[i] = pSrcEle;
            pEvent->pEventElements[i]->AddRef();

            hr = THR(pSrcDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
            if (SUCCEEDED(hr))
            {
                //determine if this is a valid event
                BSTR bstrEventName;
                DISPID tempDispID;

                bstrEventName = SysAllocString(pEvent->pEventList[i].pEventName);
                if (bstrEventName != NULL)
                {
                    //check for the case insensitive name
                    hr = THR(pDispEx->GetDispID(bstrEventName, fdexNameCaseInsensitive, &tempDispID));
                    if (pEvent->pbDynamicEvents[i] == false && SUCCEEDED(pDispEx->GetDispID(bstrEventName, fdexNameCaseInsensitive, &tempDispID)))
                    {
                        int iIndex = isTimeEvent(bstrEventName);
                        //need to get the correct case sensitive name
                        SysFreeString (bstrEventName);
                        bstrEventName = NULL;
                        if (iIndex == -1)
                        {
                            hr = THR(pDispEx->GetMemberName(tempDispID, &bstrEventName));
                        }
                        else
                        {
                            //need to convert the event to all lowercase.
                            bstrEventName = SysAllocString(g_FiredEvents[iIndex].wsz_name);
                            if (!bstrEventName)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            pEvent->pbDynamicEvents[i] = false;
                            if (pEvent->pEventList[i].bAttach == true)  //only want to attach if this is not a duplicate event.
                            {
                                hr = THR(pSrcEle->attachEvent(bstrEventName, (IDispatch *)this, &bSuccess));
                            }
                        }
                    }
                    else //this is not currently a valid event, but it could be a custom event.
                    {    //so TIME needs to attach to the onScriptCommand event to be able to catch custom events.
                        pEvent->pbDynamicEvents[i] = true;
                        BSTR ScriptEvent = SysAllocString(g_FiredEvents[TE_ONSCRIPTCOMMAND].wsz_name);
                        if (ScriptEvent != NULL)
                        {
                            if (pEvent->pEventList[i].bAttach == true)  //only want to attach if this is not a duplicate event.
                            {
                                IGNORE_HR(pSrcEle->attachEvent(ScriptEvent, (IDispatch *)this, &bSuccess));
                            }
                        }
                        SysFreeString (ScriptEvent);
                        ScriptEvent = NULL;
                    }
                }
                SysFreeString(bstrEventName);
                bstrEventName = NULL;
            }
        }
    }

  done:
    return S_OK;
};

///////////////////////////////////////////////////////////////
//  Name: ConnectToContainerConnectionPoint
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::ConnectToContainerConnectionPoint()
{
    TraceTag((tagEventMgr,
      "EventMgr(%lx)::ConnectToContainerConnectionPoint()",
      this));

    // Get a connection point to the container
    CComPtr<IConnectionPointContainer> pWndCPC;
    CComPtr<IConnectionPointContainer> pDocCPC; 
    CComPtr<IHTMLDocument> pDoc; 
    CComPtr<IDispatch> pDocDispatch;
    CComPtr<IDispatch> pScriptDispatch;
    CComPtr<IHTMLElement> pEle;

    HRESULT hr;

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pEle));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pEle->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

  done:
    if (FAILED(hr))
    {
        if (m_pDocConPt)
        {
            if (m_dwDocumentEventConPtCookie != 0)
            {
                IGNORE_HR(m_pDocConPt->Unadvise(m_dwDocumentEventConPtCookie));
            }
            m_pDocConPt.Release();
        }
        if (m_pWndConPt)
        {
            if (m_dwWindowEventConPtCookie != 0)
            {
                IGNORE_HR(m_pWndConPt->Unadvise(m_dwWindowEventConPtCookie));
            }
            m_pWndConPt.Release();
        }
        m_dwWindowEventConPtCookie = 0;
        m_dwDocumentEventConPtCookie = 0;
    }
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: GetEventCount
// 
//  Abstract:
//    Counts the number of events in an EventString where events
//    are separated by ';' or NULL terminated.
//
///////////////////////////////////////////////////////////////
long CEventMgr::GetEventCount(LPOLESTR lpstrEvents)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::GetEventCount(%ls)",
              this, lpstrEvents));

    long curCount = 0;
    OLECHAR *curChar = NULL;
    OLECHAR *szEvent = NULL;
    OLECHAR *szCurEvent = NULL;
    int iCurLoc = 0;
    UINT strLen = 0;

    if (lpstrEvents == NULL)
    {
        curCount = 0;
        goto done;
    }
    strLen = wcslen(lpstrEvents);
    szEvent = NEW OLECHAR [strLen + 1];
    if (szEvent == NULL)
    {
        curCount = 0;
        goto done;
    }

    szCurEvent = NEW OLECHAR [strLen + 1];
    if (szCurEvent == NULL)
    {
        curCount = 0;
        goto done;
    }

    curChar = lpstrEvents;

    //strip out ' '
    while (*curChar != '\0' && curCount < (int)strLen)
    {
        if (*curChar != ' ')
        {
            szEvent[curCount] = *curChar;
            curCount++;
        }
        curChar++;
    }
    szEvent[curCount] = '\0';

    curCount = 0;
    curChar = szEvent;
    iCurLoc = -1;
    while (*curChar != '\0')
    {
        iCurLoc++;
        szCurEvent[iCurLoc] = *curChar;
        if (*curChar == '.')  //reset after a '.'
        {
            iCurLoc = -1;
            ZeroMemory(szCurEvent, sizeof(OLECHAR) * lstrlenW(szCurEvent));
        }
        curChar++;
        if ((*curChar == ';') || ((*curChar == '\0') && ((*curChar - 1) != ';')))
        {
            iCurLoc = -1;
            if (lstrlenW(szCurEvent) > 2 && StrCmpNIW(szCurEvent, L"on", 2) != 0)
            {
               curCount++; //add an extra event for each that does not start with "on" 
            }
            ZeroMemory(szCurEvent, sizeof(OLECHAR) * lstrlenW(szCurEvent));
            curCount++;
        }
        
    }
    delete [] szCurEvent;
    szCurEvent = NULL;
    //determine if the end character was a ';'.
    if (*(curChar - 1) == ';')
    {
        curCount--;
    }   

  done:
    delete [] szEvent;
    return curCount;
}

///////////////////////////////////////////////////////////////
//  Name: EventMatch
// 
//  Abstract:
//    Determines if the event described by the event object
//    matches one of the events in the event list.  Returns 
//    true if a match exists.
//
//    if bCustom is true then the event notification is sent
//    directly to the m_pEventSite interface, otherwise a true
//    or false is returned.
///////////////////////////////////////////////////////////////
void CEventMgr::EventMatch(IHTMLEventObj *pEventObj, Event *pEvent, BSTR bstrEvent, TIME_EVENT_TYPE evType, float fTime, bool *bZeroOffsetMatch)
{
        
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::EventMatch",
              this));

    BSTR bstrElement = NULL;
    CComPtr<IHTMLEventObj2> pEventObj2;
    IHTMLElement *pSrcEle = NULL;
    HRESULT hr = S_OK;
    int i = 0;
    
    if (pEvent == NULL || m_bDeInited)
    {
        goto done;
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    //get the element name
    hr = THR(pEventObj->get_srcElement(&pSrcEle));
    if (FAILED(hr))
    {
        goto done;
    }    

    //Loop until the src element and all of it's container elements have been checked.
    while ((pSrcEle != NULL))
    {
        IHTMLElement *pParentEle = NULL;

        hr = THR(pSrcEle->get_id(&bstrElement));
        if (FAILED(hr))
        {
            goto done;
        }    

        for (i = 0; i < pEvent->lEventCount; i++)
        {
            BSTR bstrDynamicName = NULL;
            CComPtr <IHTMLElement> pEle;

            if (pEvent->pEventElements[i] == NULL)
            {
                continue;
            }   

            hr = THR(pEvent->pEventElements[i]->QueryInterface(IID_IHTMLElement, (void**)&pEle)) ;
            
            if (ValidateEvent(bstrEvent, pEventObj2, pEle) == false)
            {
                //this is not a valid event at this time.
                goto done;
            }

            if ((StrCmpIW(g_FiredEvents[TE_ONSCRIPTCOMMAND].wsz_name + 2, bstrEvent) == 0) && 
                (pEvent->pbDynamicEvents[i] == true))
            {
                //if this is a script command event and the script command event is attached by default
                //then reset the event name to match the value of the "Param" parameter.
                VARIANT vTemp;
                VariantInit(&vTemp);
                pEventObj2->getAttribute(L"Param", 0, &vTemp);
                bstrDynamicName  = SysAllocString(vTemp.bstrVal);
                VariantClear(&vTemp);            
            }
            else
            {
                bstrDynamicName = SysAllocString(bstrEvent);
            }

            //is this a match? Need to check m_bDeInited again here (104003)
            if (pEvent == NULL || pEvent->pEventList == NULL || m_bDeInited)
            {
                goto done;
            }
            if ((bstrDynamicName && 
                ((StrCmpIW(pEvent->pEventList[i].pEventName + 2, bstrDynamicName) == 0) ||
                (StrCmpIW(pEvent->pEventList[i].pEventName, bstrDynamicName) == 0))) &&
                (StrCmpIW(pEvent->pEventList[i].pElementName, bstrElement) == 0))
            {
                //this is a match, exit.
                if (evType == TETYPE_BEGIN || evType == TETYPE_END)  //this is either beginEvent or an endEvent
                {
                    SysFreeString(bstrDynamicName);
                    bstrDynamicName = NULL;
                    

                    if (evType == TETYPE_BEGIN)
                    {
                        if (pEvent->pEventList[i].offset != 0.0f)
                        {
                            m_pEventSite->onBeginEndEvent(true, fTime, pEvent->pEventList[i].offset, false, 0.0f, 0.0f);    
                        }
                        else
                        {
                            if (bZeroOffsetMatch)
                            {
                                *bZeroOffsetMatch = true;
                            }
                        }
                    }
                    else
                    {
                        
                        if (pEvent->pEventList[i].offset != 0.0f)
                        {
                            m_pEventSite->onBeginEndEvent(false, 0.0f, 0.0f, true, fTime, pEvent->pEventList[i].offset);    
                        }
                        else
                        {
                            if (bZeroOffsetMatch)
                            {
                                *bZeroOffsetMatch = true;
                            }
                        }
                    }

                    hr = S_OK;
                    goto done;
                }
            }
            SysFreeString(bstrDynamicName);
            bstrDynamicName = NULL;
        }

        //if no match, check the parent element name to handle event bubbling.
        hr = THR(pSrcEle->get_parentElement(&pParentEle));
        if (FAILED(hr))
        {
            goto done;
        }

        if (bstrElement)
        {
            SysFreeString(bstrElement);
            bstrElement = NULL;
        }
        pSrcEle->Release();
        pSrcEle = pParentEle;
        pParentEle = NULL;
    }
    //else check for event bubbling
    //if match, return true

  done:
    if (bstrElement)
    {
        SysFreeString(bstrElement);
        bstrElement = NULL;
    }
    if (pSrcEle != NULL)
    {
        pSrcEle->Release();
        pSrcEle = NULL;
    }

    return;
};

///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Handles the attaching to all events in all event lists.
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::AttachEvents()
{

    TraceTag((tagEventMgr,
              "EventMgr(%lx)::AttachEvents",
              this));
    HRESULT hr = S_OK;

    if (m_bUnLoaded || m_bAttached || !m_bReady) //if this is already unloaded, already attached, or not ready, don't attach
    {
        hr = E_FAIL;
        goto done;
    }
    //Readystate must be "complete" attach to the events.
    m_bAttached = true;
    
    FindDuplicateEvents();  // Determines which events are duplicates so that events are only attached to once.

    IGNORE_HR(Attach(m_pBeginEvents));
    
  done:
    return hr;
};

///////////////////////////////////////////////////////////////
//  Name: FindDuplicateEvents
// 
//  Abstract:
//    Searches the lists of events to determine if there are
//    any duplicates in the lists.  This step is needed to 
//    prevent attaching to the same event more than once.  This
//    would cause multiple notifications of the same event.
//
///////////////////////////////////////////////////////////////
void CEventMgr::FindDuplicateEvents()
{

    //Check each list against itself for duplicates
    MarkSelfDups(m_pBeginEvents);
    MarkSelfDups(m_pEndEvents);

    //Check the lists against each other for duplicates
    MarkDups(m_pBeginEvents, m_pEndEvents);

    return;
}



///////////////////////////////////////////////////////////////
//  Name: MarkSelfDups
// 
//  Abstract:
//    Searches a list and flags any duplicate events within
//    the list.
//
///////////////////////////////////////////////////////////////
void CEventMgr::MarkSelfDups(Event *pEvents)
{
    int i = 0, j = 0;

    if (pEvents == NULL)
    {
        goto done;
    }

    for (i = 0; i < pEvents->lEventCount; i++)
    {
        for (j = i+1; j < pEvents->lEventCount; j++)
        {
            if ((StrCmpIW(pEvents->pEventList[i].pEventName, pEvents->pEventList[j].pEventName) == 0) &&
                (StrCmpIW(pEvents->pEventList[i].pElementName, pEvents->pEventList[j].pElementName) == 0))
            {
                pEvents->pEventList[j].bAttach = false;
            }

        }

    }
  done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: MarkDups
// 
//  Abstract:
//    Searches 2 lists and flags any duplicate events that occur
//    in the second list.
//
///////////////////////////////////////////////////////////////
void CEventMgr::MarkDups(Event *pSrcEvents, Event *pDestEvents)
{
    int i = 0, j = 0;

    if (pSrcEvents == NULL || pDestEvents == NULL)
    {
        goto done;
    }

    for (i = 0; i < pSrcEvents->lEventCount; i++)
    {
        for (j = 0; j < pDestEvents->lEventCount; j++)
        {
           if ((StrCmpIW(pSrcEvents->pEventList[i].pEventName, pDestEvents->pEventList[j].pEventName) == 0) &&
                (StrCmpIW(pSrcEvents->pEventList[i].pElementName, pDestEvents->pEventList[j].pElementName) == 0))
            {
            
                pDestEvents->pEventList[j].bAttach = false;
            }
        }

    }
  done:
    return;
}


///////////////////////////////////////////////////////////////
//  Name: Detach
// 
//  Abstract:
//    Handles the detaching from events in a single event list
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Detach(Event *pEvents)
{
    HRESULT hr = S_OK;
    int i = 0;

    if (pEvents == NULL)
    {
        goto done;
    }

    for (i = 0; i < pEvents->lEventCount; i++)
    {
        if (pEvents->pEventElements[i] && pEvents->pEventList[i].bAttach == true)
        {
            CComPtr <IDispatchEx> pDispEx;

            hr = THR(pEvents->pEventElements[i]->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
            if (SUCCEEDED(hr))
            {
                //determine if this is a valid event
                DISPID temp;
                if (pEvents->pbDynamicEvents[i] == true)
                {
                    BSTR ScriptEvent = SysAllocString(g_FiredEvents[TE_ONSCRIPTCOMMAND].wsz_name);
                    IGNORE_HR(pEvents->pEventElements[i]->detachEvent(ScriptEvent, (IDispatch *)this));
                    SysFreeString(ScriptEvent);
                    ScriptEvent = NULL;
                }
                else
                {
                    BSTR bstrEventName;
                    bstrEventName = SysAllocString(pEvents->pEventList[i].pEventName);
                    hr = THR(pDispEx->GetDispID(bstrEventName, fdexNameCaseSensitive, &temp));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(pEvents->pEventElements[i]->detachEvent(bstrEventName, (IDispatch *)this));
                    }
                    SysFreeString(bstrEventName);
                    bstrEventName = NULL;
                }
            }
            pEvents->pEventElements[i]->Release();
            pEvents->pEventElements[i] = NULL;
        }
        pEvents->pEventDispids[i] = INVALID_DISPID;
    }
  done:
    return S_OK;
}


///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Handles the detaching from all events in all event lists.
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::DetachEvents()
{
    if (m_bAttached == true)
    {
        IGNORE_HR(Detach(m_pBeginEvents));
        if (m_bEndAttached == true)
        {
            IGNORE_HR(Detach(m_pEndEvents));
        }
        m_bAttached = false;
    }

    return S_OK;
};


///////////////////////////////////////////////////////////////////////////
// SetNewEventList
//
// Summary:
//     This manages the cleanup of the old event list and the construction 
//     of the new event list.  Passing NULL into bstrEvents causing an 
//     clears the old list and creates an empty new list.  This function
//     should return an empty list on failure.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::SetNewEventStruct(TimeValueList & tvList, Event **ppEvents)
{
    HRESULT hr = S_OK;
    long lCount = 0;
    int i = 0;
    long lCurElement = 0;
    TimeValueSTLList & l = tvList.GetList();
    
    //clean up the old list
    if (*ppEvents != NULL)
    {
        for (i = 0; i < (*ppEvents)->lEventCount; i++)
        {
            if ((*ppEvents)->pEventElements[i] != NULL)
            {
                (*ppEvents)->pEventElements[i] ->Release();
                (*ppEvents)->pEventElements[i]  = NULL;
            }
            if ((*ppEvents)->pEventList[i].pEventName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pEventName;
            }
            if ((*ppEvents)->pEventList[i].pElementName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pElementName;
            }
        }
        delete [] (*ppEvents)->pbDynamicEvents;
        delete [] (*ppEvents)->pEventDispids;
        delete [] (*ppEvents)->pEventElements;
        delete [] (*ppEvents)->pEventList;        
        (*ppEvents)->lEventCount = 0;
        (*ppEvents)->pEventList = NULL;
        (*ppEvents)->pEventDispids = NULL;
        (*ppEvents)->pEventElements = NULL;
        (*ppEvents)->pbDynamicEvents = NULL;
                    
        delete [] *ppEvents;
        *ppEvents = NULL;
    }
    //Create a new Event object
    *ppEvents = NEW Event;
    if (*ppEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    lCount = GetEventCount(tvList);
    if (lCount == 0)
    {
        ZeroMemory(*ppEvents, sizeof(Event));
        goto done;
    }
    
    //allocate the new event list
    (*ppEvents)->pEventList = NEW EventItem[lCount];
    if (NULL == (*ppEvents)->pEventList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
    (*ppEvents)->pEventDispids = NEW DISPID[lCount];
    (*ppEvents)->pEventElements = NEW IHTMLElement2* [lCount];
    (*ppEvents)->pbDynamicEvents = NEW bool[lCount];
    (*ppEvents)->lEventCount = lCount;

    if ((*ppEvents)->pEventList == NULL ||
        (*ppEvents)->pEventDispids == NULL ||
        (*ppEvents)->pEventElements == NULL ||
        (*ppEvents)->pbDynamicEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
        delete [] (*ppEvents)->pbDynamicEvents;
        delete [] (*ppEvents)->pEventDispids;
        delete [] (*ppEvents)->pEventElements;
        delete [] (*ppEvents)->pEventList;
        (*ppEvents)->lEventCount = 0;
        (*ppEvents)->pEventList = NULL;
        (*ppEvents)->pEventDispids = NULL;
        (*ppEvents)->pEventElements = NULL;
        (*ppEvents)->pbDynamicEvents = NULL;
        goto done;
    }

    ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
    ZeroMemory((*ppEvents)->pEventDispids, sizeof(DISPID) * lCount);
    ZeroMemory((*ppEvents)->pEventElements, sizeof(IHTMLElement2 *) * lCount);
    ZeroMemory((*ppEvents)->pbDynamicEvents, sizeof(bool) * lCount);

    lCurElement = 0;

    {
        for (TimeValueSTLList::iterator iter = l.begin();
             iter != l.end();
             iter++)
        {
            TimeValue *p = (*iter);
            
            if (p->GetEvent() != NULL &&
                StrCmpIW(p->GetEvent(), WZ_TIMEBASE_BEGIN) != 0 && //remove all non events from the count
                StrCmpIW(p->GetEvent(), WZ_TIMEBASE_END) != 0 &&
                StrCmpIW(p->GetEvent(), WZ_INDEFINITE) != 0 )
            {
                (*ppEvents)->pEventList[lCurElement].pEventName = CopyString(p->GetEvent());
                if (p->GetElement() == NULL)
                {
                    (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(L"this");
                }
                else
                {
                    (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(p->GetElement());
                }
                (*ppEvents)->pEventList[lCurElement].offset = (float)p->GetOffset();
                (*ppEvents)->pEventList[lCurElement].bAttach = true;

                if ((*ppEvents)->pEventList[lCurElement].pElementName == NULL ||
                    (*ppEvents)->pEventList[lCurElement].pEventName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
                lCurElement += 1;

                if (lstrlenW(p->GetEvent()) > 2 && StrCmpNIW(p->GetEvent(), L"on", 2) != 0)
                {
                    CComBSTR bstrEvent = L"on";
                    bstrEvent.Append(p->GetEvent());
                    (*ppEvents)->pEventList[lCurElement].pEventName = CopyString(bstrEvent);
                    if (p->GetElement() == NULL)
                    {
                        (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(L"this");
                    }
                    else
                    {
                        (*ppEvents)->pEventList[lCurElement].pElementName = CopyString(p->GetElement());
                    }
                    (*ppEvents)->pEventList[lCurElement].offset = (float)p->GetOffset();
                    (*ppEvents)->pEventList[lCurElement].bAttach = true;

                    if ((*ppEvents)->pEventList[lCurElement].pElementName == NULL ||
                        (*ppEvents)->pEventList[lCurElement].pEventName == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }

                    lCurElement += 1;
                }
            }

        }
    }

    (*ppEvents)->lEventCount = lCurElement;

    hr = S_OK;
    
  done:
    
    if (FAILED(hr) &&
        *ppEvents != NULL)  //need to clean up the event list.
    {
        if ((*ppEvents)->pEventList != NULL)
        {
            for (i = 0; i < (*ppEvents)->lEventCount; i++)
            {
                if ((*ppEvents)->pEventList[i].pEventName != NULL)
                {
                    delete [] (*ppEvents)->pEventList[i].pEventName;
                }
                if ((*ppEvents)->pEventList[i].pElementName != NULL)
                {
                    delete [] (*ppEvents)->pEventList[i].pElementName;
                }
            }
            delete [] (*ppEvents)->pbDynamicEvents;
            delete [] (*ppEvents)->pEventDispids;
            delete [] (*ppEvents)->pEventElements;
            delete [] (*ppEvents)->pEventList;
            
            (*ppEvents)->pbDynamicEvents = NULL;
            (*ppEvents)->pEventDispids = NULL;
            (*ppEvents)->pEventElements = NULL;
            (*ppEvents)->pEventList = NULL;
            (*ppEvents)->lEventCount = 0;
        }
        delete [] *ppEvents;
        *ppEvents = NULL;
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////
// SetNewEventList
//
// Summary:
//     This manages the cleanup of the old event list and the construction 
//     of the new event list.  Passing NULL into bstrEvents causing an 
//     clears the old list and creates an empty new list.  This function
//     should return an empty list on failure.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::SetNewEventList(LPOLESTR lpstrEvents, Event **ppEvents)
{
    HRESULT hr = S_OK;
    long lCount = 0;
    int i = 0;

    if (*ppEvents != NULL)
    {
        for (i = 0; i < (*ppEvents)->lEventCount; i++)
        {
            if ((*ppEvents)->pEventElements[i] != NULL)
            {
                (*ppEvents)->pEventElements[i]->Release();
                (*ppEvents)->pEventElements[i]  = NULL;
            }
            if ((*ppEvents)->pEventList[i].pEventName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pEventName;
            }
            if ((*ppEvents)->pEventList[i].pElementName != NULL)
            {
                delete [] (*ppEvents)->pEventList[i].pElementName;
            }
        }
        delete [] (*ppEvents)->pbDynamicEvents;
        delete [] (*ppEvents)->pEventDispids;
        delete [] (*ppEvents)->pEventElements;
        delete [] (*ppEvents)->pEventList;        
        (*ppEvents)->lEventCount = 0;
        (*ppEvents)->pEventList = NULL;
        (*ppEvents)->pEventDispids = NULL;
        (*ppEvents)->pEventElements = NULL;
        (*ppEvents)->pbDynamicEvents = NULL;

        delete [] *ppEvents;
        *ppEvents = NULL;
    }
    
    //count the new number of events
    if (lpstrEvents != NULL)
    {
        lCount = GetEventCount(lpstrEvents);

        //Create a new Event object
        *ppEvents = NEW Event;    
        if (*ppEvents == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        //allocate the new event list
        (*ppEvents)->pEventList = NEW EventItem[lCount];
        if (NULL == (*ppEvents)->pEventList)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
        (*ppEvents)->pEventDispids = NEW DISPID[lCount];
        (*ppEvents)->pEventElements = NEW IHTMLElement2* [lCount];
        (*ppEvents)->pbDynamicEvents = NEW bool[lCount];
        (*ppEvents)->lEventCount = lCount;

        if ((*ppEvents)->pEventList == NULL ||
            (*ppEvents)->pEventDispids == NULL ||
            (*ppEvents)->pEventElements == NULL ||
            (*ppEvents)->pbDynamicEvents == NULL)
        {
            hr = E_OUTOFMEMORY;
            delete [] (*ppEvents)->pbDynamicEvents;
            delete [] (*ppEvents)->pEventDispids;
            delete [] (*ppEvents)->pEventElements;
            delete [] (*ppEvents)->pEventList;
            (*ppEvents)->lEventCount = 0;
            (*ppEvents)->pbDynamicEvents = NULL;
            (*ppEvents)->pEventDispids = NULL;
            (*ppEvents)->pEventElements = NULL;
            (*ppEvents)->pEventList = NULL;
            goto done;
        }

        ZeroMemory((*ppEvents)->pEventList, sizeof(EventItem) * lCount);
        ZeroMemory((*ppEvents)->pEventDispids, sizeof(DISPID) * lCount);
        ZeroMemory((*ppEvents)->pEventElements, sizeof(IHTMLElement2 *) * lCount);
        ZeroMemory((*ppEvents)->pbDynamicEvents, sizeof(bool) * lCount);

        //initialize the bAttach variable to true
        for (i = 0; i < lCount; i++)
        {
            (*ppEvents)->pEventList[i].bAttach = true;
            (*ppEvents)->pEventList[i].offset = 0;
        }
    
        //put the new events into the event list
        hr = THR(GetEvents(lpstrEvents, (*ppEvents)->pEventList, (*ppEvents)->lEventCount));
        if (FAILED(hr))  //need to clean up the event list.
        {
            if ((*ppEvents)->pEventList != NULL)
            {
                for (i = 0; i < (*ppEvents)->lEventCount; i++)
                {
                    if ((*ppEvents)->pEventList[i].pEventName != NULL)
                    {
                        delete [] (*ppEvents)->pEventList[i].pEventName;
                    }
                    if ((*ppEvents)->pEventList[i].pElementName != NULL)
                    {
                        delete [] (*ppEvents)->pEventList[i].pElementName;
                    }
                }
                delete [] (*ppEvents)->pbDynamicEvents;
                delete [] (*ppEvents)->pEventDispids;
                delete [] (*ppEvents)->pEventElements;
                delete [] (*ppEvents)->pEventList;
                
                (*ppEvents)->pbDynamicEvents = NULL;
                (*ppEvents)->pEventDispids = NULL;
                (*ppEvents)->pEventElements = NULL;
                (*ppEvents)->pEventList = NULL;
                (*ppEvents)->lEventCount = 0;
            }
            goto done;
        }
    }

    hr = S_OK;
    
  done:
    if (FAILED(hr) &&
        *ppEvents != NULL)  //need to clean up the event list.
    {
        delete [] *ppEvents;
        *ppEvents = NULL;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////
// GetEvents
//
// Summary:
//     Parses the event string and puts the data into the event list.
///////////////////////////////////////////////////////////////////////////
HRESULT CEventMgr::GetEvents(LPOLESTR bstrEvents, EventItem *pEvents, long lEventCount)
{
    HRESULT hr = S_OK;
    
    UINT iLen = 0;
    UINT iCurLen = 0;
    OLECHAR *curChar;
    int i = 0, j = 0;
    OLECHAR *sTemp = NULL;
    
    iLen = lstrlenW(bstrEvents);
    
    if (iLen == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    sTemp = NEW OLECHAR [iLen + 1];
    if (sTemp == NULL)
    {
        hr = E_FAIL;
        goto done;
    }


    curChar = bstrEvents;
    for (j = 0; j < lEventCount; j++)
    {
        //get the element name
        ZeroMemory(sTemp, sizeof(OLECHAR) * iLen);
        
        i = 0;
        //step through the bstr looking for \0 or the '.' or ';'
        while (i < (int)(iLen - 1) && *curChar != '\0' && *curChar != '.' && *curChar != ';')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
                i++;
            }
            curChar++;
        }
        
        if (*curChar != '.')
        {
            hr = E_FAIL;
            goto done;
        }
        

        //check to see if the name is "this".
        if (StrCmpIW(sTemp, L"this") == 0)
        {
            //if it is, chang it to the name of the current element.
            CComPtr <IHTMLElement> pEle;
            BSTR bstrElement;

            hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pEle));
            if (FAILED(hr))
             {
                goto done;
            }
            
            hr = THR(pEle->get_id(&bstrElement));

            if (FAILED(hr))
            {
                goto done;
            }
            iCurLen = SysStringLen(bstrElement);
            pEvents[j].pElementName = NEW OLECHAR [iCurLen + 1];
            if (pEvents[j].pElementName == NULL)
            {
                SysFreeString(bstrElement);
                bstrElement = NULL;
                hr = E_OUTOFMEMORY;
                goto done;
            }

            ZeroMemory(pEvents[j].pElementName, sizeof(OLECHAR) * (iCurLen + 1));
            ocscpy(pEvents[j].pElementName, bstrElement);
        }
        else
        {        
            //else copy it into the event list.
            iCurLen = ocslen(sTemp);
            pEvents[j].pElementName = NEW OLECHAR [iCurLen + 1];
            if (pEvents[j].pElementName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            ZeroMemory(pEvents[j].pElementName, sizeof(OLECHAR) * (iCurLen + 1));
            ocscpy(pEvents[j].pElementName, sTemp);
        }

        //get the event name
        ZeroMemory(sTemp, sizeof(OLECHAR) * iLen);

        curChar++;
        i = 0;
        //step through the bstr looking for \0 or the ';'
        while (i < (int)(iLen - 1) && *curChar != ';' && *curChar != '\0')
        {
            sTemp[i] = *curChar;
            i++;
            curChar++;
        }
        
        //strip out trailing spaces
        i--;
        while (sTemp[i] == ' ' && i > 0)
        {
            sTemp[i] = '\0';
            i--;
        }

        //set the event name in the event list
        iCurLen = ocslen(sTemp);
        pEvents[j].pEventName = NEW OLECHAR [iCurLen + 1];
        if (pEvents[j].pEventName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        else
        {
            ocscpy(pEvents[j].pEventName, sTemp);
        }

        if (lstrlenW(pEvents[j].pEventName) > 2 && StrCmpNIW(pEvents[j].pEventName, L"on", 2) != 0)
        {
            j++;
            if (pEvents[j-1].pElementName)
            {
                pEvents[j].pElementName = CopyString(pEvents[j-1].pElementName);
            }
            if (pEvents[j-1].pEventName)
            {
                CComBSTR bstrEvent = L"on";
                bstrEvent.Append(pEvents[j-1].pEventName);
                pEvents[j].pEventName = CopyString(bstrEvent);
            }
        }
        //advance curChar to the next element or the end of the string
        if (j < lEventCount - 1)
        {
            while (*curChar != ';' && *curChar != '\0')
            {
                curChar++;
            }
            if (*curChar == ';') 
            {
                curChar++;
            }
            if (*curChar == '\0')
            {
                goto done;
            }
        }
    }

done:

    if (sTemp != NULL)
    {
        delete [] sTemp;
    }
    return hr;

}

///////////////////////////////////////////////////////////////
//  Name: EventNotifyMatch
// 
//  Abstract:
///////////////////////////////////////////////////////////////
void CEventMgr::EventNotifyMatch(IHTMLEventObj *pEventObj)
{
    BSTR bstrEleName = NULL, bstrSrcEleName = NULL, bstrEvent = NULL;
    CComPtr<IHTMLElement> pSrcEle;
    CComPtr<IHTMLElement> pAttachedEle;
    CComPtr<IHTMLEventObj2> pEventObj2;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    //get the element name
    hr = THR(pEventObj->get_srcElement(&pSrcEle));
    if (FAILED(hr) || pSrcEle == NULL)
    {
        goto done;
    }    

    //get this attached elements name
    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement, (void **)&pAttachedEle));
    if (FAILED(hr))
    {
        goto done;
    }   

    hr = THR(pAttachedEle->get_id(&bstrEleName));
    if (FAILED(hr))
    {
        goto done;
    }   

    //get the name of the event source
    hr = THR(pSrcEle->get_id(&bstrSrcEleName));
    if (FAILED(hr))
    {
        goto done;
    }    

    if (StrCmpIW(bstrEleName, bstrSrcEleName) == 0)
    {
        //get the event name
        hr = THR(pEventObj->get_type(&bstrEvent));
        if (FAILED(hr))
        {
            goto done;
        }   

        if (ValidateEvent(bstrEvent, pEventObj2, m_pElement) == false)
        {
            //this is not a valid event at this time.
            goto done;
        }

        for (int i = TEN_MOUSE_DOWN; i < TEN_MAX; i++)
        {
            if (StrCmpIW(bstrEvent, g_NotifiedEvents[i].wsz_name) == 0)
            {
                m_pEventSite->EventNotify(g_NotifiedEvents[i].event);
            }
        }
    }

  done:
    if (bstrEleName)
    {
        SysFreeString(bstrEleName);
        bstrEleName = NULL;
    }
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
        bstrEvent = NULL;
    }
    if (bstrSrcEleName)
    {
        SysFreeString(bstrSrcEleName);
        bstrSrcEleName = NULL;
    }
    return;
}

///////////////////////////////////////////////////////////////
//  Name: AttachNotifyEvents
// 
//  Abstract:
///////////////////////////////////////////////////////////////
void
CEventMgr::AttachNotifyEvents()
{
    HRESULT hr;
    VARIANT_BOOL bSuccess = FALSE;

    CComPtr<IHTMLElement2> spElement2;
    hr = m_pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
    if (FAILED(hr))
    {
        return;
    }

    for (int i = TEN_MOUSE_DOWN; i < TEN_MAX; i++)
    {
        if (m_bNotifyEvents[i] == true)
        {
            BSTR bstrEventName = SysAllocString(g_NotifiedEvents[i].wsz_name);
            IGNORE_HR(spElement2->attachEvent(bstrEventName, (IDispatch *)this, &bSuccess));
            SysFreeString(bstrEventName);
            bstrEventName = NULL;
        }
    }

  done:

    return;
}

///////////////////////////////////////////////////////////////
//  Name: DetachNotifyEvents
// 
//  Abstract:
///////////////////////////////////////////////////////////////
void
CEventMgr::DetachNotifyEvents()
{
    HRESULT hr;
    CComPtr<IHTMLElement2> spElement2;
    hr = m_pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
    if (FAILED(hr))
    {
        return;
    }

    for (int i = TEN_MOUSE_DOWN; i < TEN_MAX; i++)
    {
        if (m_bNotifyEvents[i] == true)
        {
            BSTR bstrEventName = SysAllocString(g_NotifiedEvents[i].wsz_name);
            IGNORE_HR(spElement2->detachEvent(bstrEventName, (IDispatch *)this));
            SysFreeString(bstrEventName);
            bstrEventName = NULL;
        }
    }

  done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: ValidateEvent
// 
//  Parameters:
//    BSTR bstrEventName        The cached event name (e.g. "mouseover")
//    IHTMLEventObj *pEventObj  A pointer to the event object
//    IHTMLElement  *pElement   The element on which the event is occurring
//
//  Abstract:
//    Determines if the event is valid - used to filter out mouseover and mouseout events
//    happening on child elements, if the appropriate flag is set.
///////////////////////////////////////////////////////////////

bool CEventMgr::ValidateEvent(LPOLESTR lpszEventName, IHTMLEventObj2 *pEventObj, IHTMLElement *pElement)
{
    HRESULT hr;
    bool bReturn = false;
    VARIANT vValidate;
    CComBSTR bstrFilter = WZ_FILTER_MOUSE_EVENTS;
    VariantInit(&vValidate);
    if (pElement == NULL)
    {
        bReturn = true;
        goto done;
    }

    hr = pElement->getAttribute(bstrFilter, 0, &vValidate);
    if (FAILED(hr) || vValidate.vt == VT_EMPTY)
    {
        bReturn = true;
        goto done;
    }
    
    if (vValidate.vt != VT_BOOL)
    {
        hr = VariantChangeTypeEx(&vValidate, &vValidate, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BOOL);
        if (FAILED(hr))
        {
            bReturn = true;
            goto done;
        }
    }

    if (vValidate.boolVal == VARIANT_FALSE)
    {
        bReturn = false;
        goto done;
    }

    if (StrCmpIW(lpszEventName, L"mouseout") == 0)
    {
        // Check that event.toElement is NOT contained in pElement
        CComPtr <IHTMLElement> pToElement;
        
        hr = pEventObj->get_toElement(&pToElement);

        if (SUCCEEDED(hr) && pToElement)
        {
            VARIANT_BOOL varContained;
            hr = pElement->contains(pToElement, &varContained);

            if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
            {
                bReturn = false;
                goto done;
            }
        }
    }
    else if (StrCmpIW(lpszEventName, L"mouseover") == 0)
    {
        // Check that event.fromElement is NOT contained in pElement
        CComPtr <IHTMLElement> pFromElement;
        hr = pEventObj->get_fromElement(&pFromElement);
        if (SUCCEEDED(hr) && pFromElement)
        {
            VARIANT_BOOL varContained;
            hr = pElement->contains(pFromElement, &varContained);

            if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
            {
                bReturn = false;
                goto done;
            }
        }
    }

    bReturn = true;

  done:
    VariantClear(&vValidate);
    return bReturn;
}

//returns -1 if this is not a time event or the index of the time event if it is.
int 
CEventMgr::isTimeEvent(LPOLESTR lpszEventName)
{
    int i = 0;
    int iReturn = -1;
    if (lpszEventName == NULL)
    {
        goto done;
    }
    for (i = 0; i < TE_MAX; i++)
    {
        if (g_FiredEvents[i].wsz_name == NULL)
        {
            continue;
        }
        if (StrCmpIW(g_FiredEvents[i].wsz_name, lpszEventName) == 0)
        {
            iReturn = i;
            goto done;
        }
    }
  done:

    return iReturn;
}

long 
CEventMgr::GetEventCount(TimeValueList & tvList)
{
    long lCount = 0;
    TimeValueSTLList & l = tvList.GetList();

    for (TimeValueSTLList::iterator iter = l.begin();
             iter != l.end();
             iter++)
    {
        TimeValue *p = (*iter);
        lCount++;
        LPOLESTR szEvent = p->GetEvent();
        if (szEvent == NULL)
        {
            continue;
        }

        if (lstrlenW(szEvent) > 2)
        {
            if (StrCmpNIW(szEvent, L"on", 2) != 0)
            {  //if this event starts with "on" add an extra event so the same event can be attached to with the "on"
                lCount++;
            }   
        }
    }

    return lCount;
}

void
CEventMgr::UpdateReadyState()
{
    HRESULT hr;
    BSTR bstrReadyState = NULL;
       
    hr = THR(::GetReadyState(m_pElement,
                             &bstrReadyState));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_bNotifyEvents[TEN_READYSTATECHANGE] == true)
    {   
        m_pEventSite->onReadyStateChangeEvent(bstrReadyState);
    }
                
    if (bstrReadyState != NULL &&
        StrCmpIW(L"complete",bstrReadyState) == 0)
    {
        if (!m_bReady)
        {
            m_bReady = true;
            AttachNotifyEvents();
            IGNORE_HR(AttachEvents());
        }
    }

  done:
    SysFreeString(bstrReadyState);
    return;
}


HRESULT 
CEventMgr::_ToggleEndEvent(bool bOn)
{
    HRESULT hr = S_OK;

    if (bOn == m_bEndAttached)
    {
        goto done;
    }

    if (bOn == true)
    {
        m_bEndAttached = true;
        if (m_pEndEvents)
        {
            IGNORE_HR(Attach(m_pEndEvents));
        }
    }
    else 
    {
        m_bEndAttached = false;
        if (m_pEndEvents)
        {
            IGNORE_HR(Detach(m_pEndEvents));
        }
    }
    hr = S_OK;
  done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\importman.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\importman.cpp
//
//  Contents: implementation of CImportManager and CImportManagerList
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "importman.h"

DeclareTag(tagSyncDownload, "TIME: Import", "Use synchronous imports");
DeclareTag(tagTIMEImportManager, "TIME: ImportManager", "Import manager messages");

//
// Initialization
//

static CImportManager* g_pImportManager = NULL;
static CAtomTable * g_pAtomTable = NULL;

static const TCHAR pchHandleName[] = _T("CImportManager Thread Started OK event");


// thread startup function
unsigned long static _stdcall ThreadStartFunc(void * pvoidList); //lint !e10

//+-----------------------------------------------------------------------
//
//  Function:  InitializeModule_ImportManager
//
//  Overview:  Creates and initializes import manager class.  
//              Expected to be called exactly once per COM instantion
//
//  Arguments: void
//             
//  Returns:   true if created, otherwise false
//
//------------------------------------------------------------------------
bool
InitializeModule_ImportManager(void)
{
    HRESULT hr = S_OK;

    Assert(NULL == g_pImportManager);

    g_pAtomTable = new CAtomTable;
    if (NULL == g_pAtomTable)
    {
        return false;
    }
    g_pAtomTable->AddRef();

    g_pImportManager = new CImportManager;
    if (NULL == g_pImportManager)
    {
        return false;
    }
    
    hr = THR(g_pImportManager->Init());
    if (FAILED(hr))
    {
        IGNORE_HR(g_pImportManager->Detach());
        delete g_pImportManager;
        g_pImportManager = NULL;
        return false;
    }

    return true;
}

//+-----------------------------------------------------------------------
//
//  Function:  DeInitializeModule_ImportManager
//
//  Overview:  Deinializes and destroys import manager
//
//  Arguments: bShutdown    whether or not this is a shutdown, not used
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
DeinitializeModule_ImportManager(bool bShutdown)
{
    if (NULL != g_pImportManager)
    {
        IGNORE_HR(g_pImportManager->Detach());
    }

    if (NULL != g_pAtomTable)
    {
        g_pAtomTable->Release();
        g_pAtomTable = NULL;
    }

    delete g_pImportManager;
    g_pImportManager = NULL;
}


//+-----------------------------------------------------------------------
//
//  Function:  GetImportManager
//
//  Overview:  Controlled method for accessing global import manager
//
//  Arguments: void
//             
//
//  Returns:   pointer to import manager
//
//------------------------------------------------------------------------
CImportManager* GetImportManager(void)
{
    Assert(NULL != g_pImportManager);
    return g_pImportManager;
}

//+-----------------------------------------------------------------------
//
//  Member:    CImportManager::CImportManager
//
//  Overview:  Constructor
//
//  Arguments: void
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImportManager::CImportManager() :   
    m_pList(NULL),
    m_lThreadsStarted(0)
{
    memset(m_handleThread, NULL, sizeof(m_handleThread));
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CImportManager
//
//  Overview:  Destructor
//
//  Arguments: void
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImportManager::~CImportManager()
{
    ReleaseInterface(m_pList);
}

//+-----------------------------------------------------------------------
//
//  Member:    Init
//
//  Overview:  Creates and initializes threadsafelist class
//
//  Arguments: void
//             
//
//  Returns:   S_OK is ok, otherwise E_OUTOFMEMORY, or error from init
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Init()
{
    HRESULT hr = S_OK;

    m_pList = new CImportManagerList;
    if (NULL == m_pList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    m_pList->AddRef();

    hr = THR(m_pList->Init());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:  CreateOneThread
//
//  Overview:  Creates exactly one thread and returns the handle to it.
//
//  Arguments: pHandle, where to store thread handle
//             pList, pointer to list to pass to thread
//
//  Returns:   S_OK if thread is created
//
//------------------------------------------------------------------------
HRESULT
CreateOneThread(HANDLE * pHandle, CImportManagerList * pList)
{
    Assert(NULL != pHandle);
    Assert(NULL != pList);
    
    HRESULT hr = S_OK;
    DWORD dwThreadID = 0;
    HANDLE handleThreadStartedEvent = NULL;
    HANDLE handleThread = NULL;

    *pHandle = NULL;
    
    handleThreadStartedEvent = CreateEvent(NULL, FALSE, FALSE, pchHandleName);
    if (NULL == handleThreadStartedEvent)
    {
        hr = E_FAIL;
        goto done;
    }

    handleThread = CreateThread(NULL, 0, ThreadStartFunc, reinterpret_cast<void*>(pList), 0, &dwThreadID); //lint !e40
    if (NULL == handleThread)
    {
        hr = E_FAIL;
        goto done; // is this correct?  need to clean up threads / or (destuctor / detach) handles it?
    }
    
    {            
        HANDLE handleArray[] = { handleThread, handleThreadStartedEvent};
        DWORD dwSignaledObject = NULL;

        // don't msgwaitformultiple here -- this code is not reentrant.
        dwSignaledObject = WaitForMultipleObjectsEx(ARRAY_SIZE(handleArray), handleArray, FALSE, TIMEOUT, FALSE);

        if (-1 == dwSignaledObject)
        {
            hr = E_FAIL;
            goto done;
        }
            
        if (WAIT_TIMEOUT == dwSignaledObject)
        {
            // 30 seconds timed out waiting for a thread to start!
            hr = E_FAIL;
            Assert(false);
            goto done;
        }                

        dwSignaledObject -= WAIT_OBJECT_0;
        if (0 == dwSignaledObject)
        {
            // the thread died before the event was signalled.
            hr = E_FAIL;
            goto done;
        }
    }
    
    *pHandle = handleThread;

    hr = S_OK;
done:
    CloseHandle(handleThreadStartedEvent);

    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    StartThreads
//
//  Overview:  Starts threads for import manager.  If no threads are needed
//              for the current download load, none are created.
//
//  Arguments: void
//
//  Returns:   S_OK if ok, otherwise an appropriate error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::StartThreads()
{
    HRESULT hr = S_OK;

    Assert(m_lThreadsStarted < NUMBER_THREADS_TO_SPAWN);

    LONG lWaiting = m_pList->GetThreadsWaiting();

    // if no threads are currently waiting, then another thread is needed for a download
    if (0 == lWaiting)
    {
        hr = CreateOneThread(&(m_handleThread[m_lThreadsStarted]), m_pList);
        if (FAILED(hr))
        {
            goto done;
        }

        m_lThreadsStarted++;
    }
    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Detach
//
//  Overview:  Deinitialization of object
//
//  Arguments: void
//             
//
//  Returns:   S_OK, or error code from list->Detach
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Detach()
{
    HRESULT hr = S_OK;
    int i = 0;

    for(i = 0; i < NUMBER_THREADS_TO_SPAWN; i++)
    {
        if (NULL != m_handleThread[i])
        {
            CloseHandle(m_handleThread[i]);
            m_handleThread[i] = NULL;
        }
    }
    
    if (NULL != m_pList)
    {
        hr = THR(m_pList->Detach());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    ReleaseInterface(m_pList);

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Add
//
//  Overview:  Add an ITIMEImportMedia to the scheduler
//
//  Arguments: pImportMedia, media to be scheduled
//             
//
//  Returns:   S_OK if ok, otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Add(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr;

#if DBG
    if (IsTagEnabled(tagSyncDownload))
    {
        TraceTag((tagSyncDownload,
                  "CImportManager::Add: Using synchronous call"));
        CComPtr<ITIMEMediaDownloader> spMediaDownloader;

        hr = THR(pImportMedia->GetMediaDownloader(&spMediaDownloader));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = THR(spMediaDownloader->CueMedia());
        if (FAILED(hr))
        {
            goto done;
        }
        hr = S_OK;
        goto done;
    }
#endif
    
    if (m_lThreadsStarted < NUMBER_THREADS_TO_SPAWN)
    {
        hr = THR(StartThreads());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_pList->Add(pImportMedia));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Remove
//
//  Overview:  Remove ITIMEImportMedia from scheduler list
//              calls CThreadSafeList::Remove 
//
//  Arguments: pImportMedia, element to be removed from scheduler
//             
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::Remove(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    hr = m_pList->Remove(pImportMedia);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;

}

//+-----------------------------------------------------------------------
//
//  Member:    DataAvailable
//
//  Overview:  Signals any waiting threads that data is now available
//              calls CThreadSafeList::DataAvailable
//
//  Arguments: void
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::DataAvailable()
{
    HRESULT hr = S_OK;

    hr = m_pList->DataAvailable();
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    RePrioritize
//
//  Overview:  RePrioritize ITIMEImportMedia in scheduler list
//              calls CThreadSafeList::RePrioritize
//
//  Arguments: pImportMedia, element to be reprioritized in scheduler
//             
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
HRESULT
CImportManager::RePrioritize(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    hr = m_pList->RePrioritize(pImportMedia);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:    ThreadStartFunc
//
//  Overview:  Thread function, used for downloading
//              Takes a reference on this library, to prevent unloading until completion finishes
//              Calls list->GetNextElementToDownload, until NULL is returned, then exits thread
//              For each element returned, calls CueMedia on unmarshalled interface
//
//  Arguments: pvoidList, pointer to threadsafelist
//             
//
//  Returns:   0
//
//------------------------------------------------------------------------
unsigned long 
ThreadStartFunc(void *pvoidList) 
{ 
    HRESULT hr = S_OK;
    CImportManagerList * pList = NULL;
    BOOL bSucceeded;
    ITIMEImportMedia * pImportMedia = NULL;
    TCHAR szModuleName[_MAX_PATH];
    DWORD dwCharCopied;
    HINSTANCE hInst = NULL;
    HANDLE handleThreadStartedEvent;

    pList = reinterpret_cast<CImportManagerList*>(pvoidList);
    if (NULL == pList)
    {
        goto done;
    }
    
    pList->AddRef();

    dwCharCopied = GetModuleFileName(g_hInst, szModuleName, _MAX_PATH);
    if (0 == dwCharCopied)
    {
        // need to be able to get the file name!
        goto done;
    }

    hInst = LoadLibrary(szModuleName);
    if (NULL == hInst)
    {
        // need to be able to take a reference on this library
        goto done;
    }

    handleThreadStartedEvent = CreateEvent(NULL, FALSE, FALSE, pchHandleName);
    if (NULL == handleThreadStartedEvent)
    {
        // need to create the event to signal
        goto done;
    }
    
    bSucceeded = SetEvent(handleThreadStartedEvent);
    CloseHandle(handleThreadStartedEvent);
    if (FALSE == bSucceeded)
    {
        // calling thread won't unblock unless we exit now!
        hr = THR(E_FAIL);
        goto done;
    }

    // this must be apartment threaded.
    hr = THR(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED ));
    if (FAILED(hr))
    {
        // no recovery available
        goto done;
    }

    hr = THR(pList->GetNextElement(&pImportMedia));
    if (FAILED(hr))
    {
        goto done;
    }

    while(pImportMedia != NULL)
    {
        hr = THR(pImportMedia->CueMedia());
        if (FAILED(hr))
        {
            // what to do?  just keep on Processing
        }    
        

        hr = THR(pList->ReturnElement(pImportMedia));
        pImportMedia->Release();
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pList->GetNextElement(&pImportMedia));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    TraceTag((tagTIMEImportManager, "TIME: ImportManager, thread shutting down"));

    hr = S_OK;
done:
    CoUninitialize();

    ReleaseInterface(pList);
    
    FreeLibraryAndExitThread(hInst, 0);
    return 0;
}


CImportManagerList::CImportManagerList()
{
    ;
}

CImportManagerList::~CImportManagerList()
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    Add
//
//  Overview:  Tries to match given media to media downloader already in list.
//              if successful, reprioritizes downloader
//              otherwise, if media downloader, adds media downloader to list
//              otherwise, adds importmedia directly to list, by calling up inheritance chain
//             
//  Arguments: pImportMedia, pointer to media to add
//             
//  Returns:   S_OK if added, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CImportManagerList::Add(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    bool fExisted = false;
    
    CComPtr<ITIMEMediaDownloader> spMediaDownloader;

    hr = THR(FindMediaDownloader(pImportMedia, &spMediaDownloader, &fExisted));
    if (FAILED(hr))
    {
        goto done;
    }

    if (fExisted)
    {
        double dblNewPriority = INFINITE;
        double dblOldPriority = INFINITE;

        hr = pImportMedia->GetPriority(&dblNewPriority);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMediaDownloader->GetPriority(&dblOldPriority);
        if (FAILED(hr))
        {
            goto done;
        }

        if ( dblNewPriority < dblOldPriority )
        {
            hr = RePrioritize(spMediaDownloader);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    {
        if (spMediaDownloader)
        {
            hr = CThreadSafeList::Add(spMediaDownloader);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            hr = CThreadSafeList::Add(pImportMedia);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetNode
//
//  Overview:  Walks list looking for UniqueID equal to given ID, 
//              if found, QI's for downloader into outgoing interface
//             
//  Arguments: listToCheck - list to check
//             lID - AtomTable ID to find in list
//             pfExisted - [out] if mediadownloader existed or not
//             ppMediaDownloader - [out] pointer to outgoing matched downloader
//             
//  Returns:   S_OK if no error, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CImportManagerList::GetNode(std::list<CThreadSafeListNode*> &listToCheck, const long lID, bool * pfExisted, ITIMEMediaDownloader ** ppMediaDownloader)
{
    HRESULT hr = S_OK;
    
    std::list<CThreadSafeListNode * >::iterator iter;

    *pfExisted = false;
    *ppMediaDownloader = NULL;
    
    CComPtr<ITIMEImportMedia> spImportMedia;

    iter = listToCheck.begin();
    while (iter != listToCheck.end())
    {
        long lNodeID;
        
        hr = (*iter)->GetElement()->GetUniqueID(&lNodeID);
        if (FAILED(hr))
        {
            goto done;
        }

        if (ATOM_TABLE_VALUE_UNITIALIZED != lID)
        {
            if (lID == lNodeID)
            {
                spImportMedia = (*iter)->GetElement();
                break;
            }
        }

        iter++;
    }

    if (spImportMedia != NULL)
    {
        hr = spImportMedia->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, ppMediaDownloader));
        if (SUCCEEDED(hr))
        {
            *pfExisted = true;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    FindMediaDownloader
//
//  Overview:  checks CThreadSafeList lists against GetNode looking for downloader.
//             
//  Arguments: pImportMedia, pointer to media to add
//             [out] ppMediaDownloader, where to store downloader interface
//             [out] pfExisted, whether or not downloader was found
//             
//  Returns:   S_OK if no error, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CImportManagerList::FindMediaDownloader(ITIMEImportMedia * pImportMedia, ITIMEMediaDownloader ** ppMediaDownloader, bool * pfExisted)
{
    HRESULT hr = S_OK;

    CritSectGrabber cs(m_CriticalSection);

    CComPtr<ITIMEMediaDownloader> spMediaDownloader;

    long lID = ATOM_TABLE_VALUE_UNITIALIZED;

    if (NULL == pfExisted || NULL == ppMediaDownloader)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *ppMediaDownloader = NULL;
    *pfExisted = false;
    
    hr = pImportMedia->GetUniqueID(&lID);
    if (FAILED(hr))
    {
        goto done;
    }

    // is the id in any lists?
    hr = GetNode(m_listToDoDownload, lID, pfExisted, &spMediaDownloader);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!(*pfExisted))
    {
        hr = GetNode(m_listCurrentDownload, lID, pfExisted, &spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    if (!(*pfExisted))
    {
        hr = GetNode(m_listDoneDownload, lID, pfExisted, &spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if ((*pfExisted))
    {
        hr = pImportMedia->PutMediaDownloader(spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spMediaDownloader->AddImportMedia(pImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = pImportMedia->GetMediaDownloader(&spMediaDownloader);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (spMediaDownloader)
    {
        hr = spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, ppMediaDownloader));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\threadsafelist.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\threadsafelist.cpp
//
//  Contents: definitions for CThreadSafeList, and CThreadSafeListNode
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "threadsafelist.h"


//+-----------------------------------------------------------------------
//
//  Function:  PumpMessagesWhileWaiting
//
//  Overview:  Calls WaitForMultipleObjects, and pumps windows message while it is waiting
//
//  Arguments: pHandleArray array of handle to pass to WaitForMultipleObjects
//             iHandleCount count of objects in array
//             dwTimeOut    timeout time
//
//  Returns:   DWORD, object that was signalled
//
//------------------------------------------------------------------------
DWORD 
PumpMessagesWhileWaiting(HANDLE * pHandleArray, UINT iHandleCount, DWORD dwTimeOut)
{
    DWORD dwSignaledObject = 0;

    do
    {
        dwSignaledObject = MsgWaitForMultipleObjects(iHandleCount, pHandleArray, FALSE, dwTimeOut, QS_ALLINPUT);
        
        if (WAIT_OBJECT_0 + iHandleCount == dwSignaledObject)
        {
            MSG msg;
            BOOL bMessageAvailable;
            bMessageAvailable = PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE);
            if (bMessageAvailable)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            
        }
    } while (WAIT_OBJECT_0 + iHandleCount == dwSignaledObject);
    
    return dwSignaledObject;
}

//+-----------------------------------------------------------------------
//
//  Member:    CThreadSafeList
//
//  Overview:  Constructor
//
//  Arguments: void
//             
//
//  Returns:   void
//
//------------------------------------------------------------------------
CThreadSafeList::CThreadSafeList() :
    m_lThreadsWaiting(0),
    m_hDataAvailable(NULL),
    m_hDataRecieved(NULL),
    m_hShutdown(NULL),
    m_lRefCount(0)
{ 
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CThreadSafeList
//
//  Overview:  destructor, closes handles and destroys critical section
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
CThreadSafeList::~CThreadSafeList()
{
    CloseHandle(m_hDataAvailable);
    m_hDataAvailable = NULL;
    CloseHandle(m_hDataRecieved);
    m_hDataRecieved = NULL;
    CloseHandle(m_hShutdown);
    m_hShutdown = NULL;

    Assert(m_listCurrentDownload.empty());
    Assert(m_listToDoDownload.empty());
    Assert(m_listDoneDownload.empty());
}

//+---------------------------------------------------------------------------
//
//  Member:     QueryInterface, IUnknown
//
//  Synopsis:   COM casting method
//
//  Arguments:  riid, requested interface
//
//  Returns:    S_OK if interface is known, otherwise, NOINTERFACE, or POINTER error
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CThreadSafeList::QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL == ppvObject)
    {
        return E_POINTER;
    }

    *ppvObject = NULL;

    if ( IsEqualGUID(riid, IID_IUnknown) )
    {
        *ppvObject = this;
    }

    if ( NULL != *ppvObject )
    {
        ((LPUNKNOWN)*ppvObject)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}
        
//+---------------------------------------------------------------------------
//
//  Member:     AddRef, IUnknown
//
//  Synopsis:   Increment reference count of this object
//
//  Arguments:  void
//
//  Returns:    new reference count
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CThreadSafeList::AddRef( void)
{
    return InterlockedIncrement(&m_lRefCount);
}
//+---------------------------------------------------------------------------
//
//  Member:     Release, IUnknown
//
//  Synopsis:   Decrement reference count, delete this when at zero
//
//  Arguments:  void
//
//  Returns:    new reference count
//
//----------------------------------------------------------------------------        
STDMETHODIMP_(ULONG)
CThreadSafeList::Release( void)
{
    ULONG l = InterlockedDecrement(&m_lRefCount);
    if (l == 0)
        delete this;
    return l;
}

//+-----------------------------------------------------------------------
//
//  Member:    Init
//
//  Overview:  Initialize object, create events, destroy events if previously exist
//
//  Arguments: void
//             
//
//  Returns:   S_OK if events all created, otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::Init()
{
    HRESULT hr = S_OK;

    if (m_hDataAvailable)
    {
        CloseHandle(m_hDataAvailable);
    }
    m_hDataAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hDataAvailable)
    {
        hr = THR(E_FAIL);
        goto done;
    }

    if (m_hDataRecieved)
    {
        CloseHandle(m_hDataRecieved);
    }
    m_hDataRecieved = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hDataRecieved)
    {
        hr = THR(E_FAIL);
        goto done;
    }

    if (m_hShutdown)
    {
        CloseHandle(m_hShutdown);
    }
    m_hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hShutdown)
    {
        hr = THR(E_FAIL);
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Detach
//
//  Overview:  Deinitialize object, don't destroy events
//
//  Arguments: void
//             
//
//  Returns:   S_OK if ok, otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CThreadSafeList::Detach()
{
    HRESULT hr = S_OK;
    BOOL bSucceeded = TRUE;

    CritSectGrabber cs(m_CriticalSection);

    IGNORE_HR(ClearList(m_listToDoDownload));
    IGNORE_HR(ClearList(m_listDoneDownload));
    
    if (m_hShutdown)
    {
        bSucceeded = SetEvent(m_hShutdown);
        if (FALSE == bSucceeded)
        {
            // #14221, ie 6
            // jeffwall 8/30/99 we could add 2 null media events into the list here
            // we're dead.  The threads won't get stopped.
            hr = THR(E_FAIL);
            Assert(false);
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CThreadSafeList::ClearList(std::list<CThreadSafeListNode*> &listToClear)
{
    HRESULT hr = S_OK;
    
    // empty out the list
    std::list<CThreadSafeListNode * >::iterator iter = listToClear.begin();
    while (iter != listToClear.end())
    {
        delete (*iter);
        std::list<CThreadSafeListNode * >::iterator olditer = iter;
        iter++;
        listToClear.erase(olditer);
    }
    listToClear.clear();

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetThreadsWaiting
//
//  Overview:  returns instantaneous number of threads waiting
//
//  Arguments: 
//
//  Returns:   number of threads waiting
//
//------------------------------------------------------------------------
LONG
CThreadSafeList::GetThreadsWaiting()
{
    CritSectGrabber cs(m_CriticalSection);

    return m_lThreadsWaiting;
}

//+-----------------------------------------------------------------------
//
//  Member:    Add
//
//  Overview:  Create a new list element, add to todo list
//
//  Arguments: pImportMedia,    unmarshalled interface
//             lPriority,       where to place in list
//
//  Returns:   S_OK, or appropriate error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::Add(ITIMEImportMedia* pImportMedia)
{
    HRESULT hr = S_OK;
    
    CThreadSafeListNode * pNode = NULL;
    
    bool fInserted = false;
    
    std::list<CThreadSafeListNode * >::iterator iter;
    
    CritSectGrabber cs(m_CriticalSection);
    
    double dblPriority = 0.0;

    hr = pImportMedia->GetPriority(&dblPriority);
    if (FAILED(hr))
    {
        goto done;
    }
    
    pNode = new CThreadSafeListNode(pImportMedia);
    if (NULL == pNode)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // sort the classes based on priority -- make this a binary search eventually
    iter = m_listToDoDownload.begin();
    while (iter != m_listToDoDownload.end())
    {                
        double dblIterPriority = 0.0;
        hr = (*iter)->GetElement()->GetPriority(&dblIterPriority);
        if (FAILED(hr))
        {
            goto done;
        }

        if (dblPriority < dblIterPriority)
        {
            // insert before
            m_listToDoDownload.insert(iter, pNode);
            fInserted = true;
            break;
        }
        iter++;
    }
    
    if (!fInserted)
    {
        // place at end
        m_listToDoDownload.insert(iter, pNode);
    }    

    m_CriticalSection.Release();

    hr = DataAvailable();
    m_CriticalSection.Grab();

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr; //lint !e429 // the newed element is stored in the list
} 

//+-----------------------------------------------------------------------
//
//  Member:    DataAvailable()
//
//  Overview  If threads are waiting for insertion, signal DataAvailable object,
//            then wait for DataRecieved event
//
//  Arguments: void
//
//  Returns:   S_OK, or appropriate error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::DataAvailable()
{
    HRESULT hr = S_OK;
    
    CritSectGrabber cs(m_CriticalSection);
    
    if (0 != m_lThreadsWaiting)
    {
        BOOL bSucceeded = FALSE;
        DWORD dwWaitReturn = 0;
        
        bSucceeded = SetEvent(m_hDataAvailable);
        if (FALSE == bSucceeded)
        {
            hr = THR(E_FAIL);
            goto done;
        }
        
        {
            m_CriticalSection.Release();
            
            // wait for a thread to pick this up
            dwWaitReturn = WaitForSingleObjectEx(m_hDataRecieved, TIMEOUT, FALSE);
            
            m_CriticalSection.Grab();
        }
        
        if (WAIT_TIMEOUT == dwWaitReturn)
        {
            // either no thread was waiting (error)
            Assert(m_lThreadsWaiting > 0);
            // or there is a problem with the system
            hr = THR(E_FAIL);
            goto done;
        }
        if (-1 == dwWaitReturn)
        {
            hr = THR(E_FAIL);
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Remove
//
//  Overview:  Remove element from lists, check current list, then todo list
//              if element is in the current download list, wait until it is returned.
//
//             Only a TIME thread can be in this method, 
//              therefore only 1 thread at a time can be in this method.
//              therefore the remove event does not need back notification that it has been recieved
//
//             If more than one thread is ever in this method, there will be bugs aplenty.  
//              Because there is no back notification, the wrong thread could be notified 
//              of the remove, and all download processing would stop.  
//
//  Arguments: pImportMedia, element to remove
//             
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::Remove(ITIMEImportMedia* pImportMedia)
{
    HRESULT hr = S_OK;

    std::list<CThreadSafeListNode *>::iterator iter;

    CritSectGrabber cs(m_CriticalSection);

    // look for element in todo list
    iter = m_listToDoDownload.begin();
    while (iter != m_listToDoDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            delete (*iter);
            m_listToDoDownload.erase(iter);

            hr = S_OK;
            goto done;
        }
        iter++;
    }

    iter = m_listDoneDownload.begin();
    while (iter != m_listDoneDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            delete (*iter);
            m_listDoneDownload.erase(iter);

            hr = S_OK;
            goto done;
        }
        iter++;
    }

    iter = m_listCurrentDownload.begin();
    while (iter != m_listCurrentDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            (*iter)->RemoveWhenDone();

            hr = S_OK;
            goto done;
        }
        iter++;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ReturnElement
//
//  Overview:  Move returned media to done list, 
//              unless shutting down, or media has been removed, delete then.
//
//  Arguments: pOldMedia, previous media thread was using
//
//  Returns:   S_OK, or error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::ReturnElement(ITIMEImportMedia * pOldMedia)
{
    HRESULT hr = S_OK;
    
    std::list<CThreadSafeListNode *>::iterator iter;

    CritSectGrabber cs(m_CriticalSection);

    // remove old media from "out" list
    iter = m_listCurrentDownload.begin();
    while (iter != m_listCurrentDownload.end())
    {
        if ( MatchElements((*iter)->GetElement(), pOldMedia) )
        {
            if ((*iter)->GetRemoveWhenDone() || WAIT_OBJECT_0 == WaitForSingleObjectEx(m_hShutdown, 0, FALSE))
            {
                delete (*iter);
                m_listCurrentDownload.erase(iter);
            }
            else
            {
                m_listDoneDownload.push_back(*iter);
                m_listCurrentDownload.erase(iter);
            }

            break;
        }
        iter++;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetNextElement
//
//  Overview:  
//              wait for data to come available, if needed, wait for dataavailable event, then fire datarecieved
//              then pop front of list into current download list, and set pNewMedia to media element
//
//  Arguments: pOldMedia, previous media thread was using
//             pNewMedia, [out] pointer to new Media
//
//  Returns:   S_OK, or error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::GetNextElement(ITIMEImportMedia** pNewMedia, bool fBlockThread /* = true */)
{
    HRESULT hr = S_OK;
    
    BOOL bSucceeded = TRUE;
    
    DWORD dwSignaledObject = 0;

    std::list<CThreadSafeListNode *>::iterator iter;

    CThreadSafeListNode * pNextCueNode = NULL;
    
    CritSectGrabber cs(m_CriticalSection);

    if (NULL == pNewMedia)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    *pNewMedia = NULL;

    // make sure that it isn't time to shutdown
    dwSignaledObject = WaitForSingleObjectEx(m_hShutdown, 0, FALSE);
    if (-1 == dwSignaledObject)
    {
        // failure
        hr = THR(E_FAIL);
        Assert(false && _T("WaitForSingleObjectEx failed!"));
        goto done;
    }
    if (WAIT_OBJECT_0 == dwSignaledObject)
    {
        // time to shutdown
        *pNewMedia = NULL;
        hr = S_OK;
        goto done;
    }

    pNextCueNode = GetNextMediaToCue();
    
    if (fBlockThread)
    {
        // make sure there is something to download
        while (NULL == pNextCueNode)
        {
            HANDLE handleArray[] = { m_hShutdown, m_hDataAvailable };
            
            {
                m_lThreadsWaiting++;
                m_CriticalSection.Release();
                
                dwSignaledObject = PumpMessagesWhileWaiting(handleArray, ARRAY_SIZE(handleArray), INFINITE);
                
                m_CriticalSection.Grab();
                m_lThreadsWaiting--;        
            }
            
            if (-1 == dwSignaledObject)
            {
                // failure
                hr = THR(E_FAIL);
                goto done;
            }
            
            dwSignaledObject -= WAIT_OBJECT_0;
            if (0 == dwSignaledObject)
            {
                // the exit event was set.
                *pNewMedia = NULL;
                hr = S_OK;
                goto done;
            }

            if (WAIT_TIMEOUT != dwSignaledObject)
            {
                // we really got a dataAvailable Event
                bSucceeded = SetEvent(m_hDataRecieved);
                if (FALSE == bSucceeded)
                {
                    hr = THR(E_FAIL);
                    goto done;
                }
            }

            pNextCueNode = GetNextMediaToCue();
        } // while
    }
    else if (NULL == pNextCueNode)
    {
        hr = S_FALSE;
        goto done;
    }

    Assert(NULL != pNextCueNode); 

    // copy structure to "out" list
    m_listCurrentDownload.push_back(pNextCueNode); 

    // return media in new pointer
    *pNewMedia = pNextCueNode->GetElement();
    
    // always addref an outgoing interface
    if (NULL != (*pNewMedia))
    {
        (*pNewMedia)->AddRef();
    }
    else
    {
        Assert(false && "Got a NULL Media pointer from the list");
    }
    
    hr = S_OK;
done:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    GetNextMediaToCue
//
//  Overview:  Check the ToDo list to see is any media returns true 
//             from CanBeCued. If any media can be cued, it is removed 
//             from the ToDo list and returned to the caller.
//
//  Arguments: void
//
//  Returns:   NULL if nothing can be cued now, or
//             iterator to the first element that can be cued now.
//
//------------------------------------------------------------------------
CThreadSafeListNode*
CThreadSafeList::GetNextMediaToCue()
{
    std::list<CThreadSafeListNode *>::iterator iter;
    
    iter = m_listToDoDownload.begin();
    while ( iter != m_listToDoDownload.end() )
    {
        ITIMEImportMedia * pImportMedia = (*iter)->GetElement();
        
        if (NULL != pImportMedia)
        {
            VARIANT_BOOL vb;
            
            IGNORE_HR(pImportMedia->CanBeCued(&vb));
            if (VARIANT_FALSE != vb)
            {
                CThreadSafeListNode * pRet = (*iter);
                m_listToDoDownload.erase(iter);
                return pRet;
            }
        }
        iter++;
    }
    
    return NULL;
}

//+-----------------------------------------------------------------------
//
//  Member:    RePrioritize
//
//  Overview:  caller believes that priority has changed, therefore
//              if media has yet to be downloaded (is in todo list)
//              remove from todo list, call add to reinsert.
//
//  Arguments: pImportMedia - media to reprioritize
//
//  Returns:   S_OK, or error code
//
//------------------------------------------------------------------------
HRESULT
CThreadSafeList::RePrioritize(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    CritSectGrabber cs(m_CriticalSection);

    std::list<CThreadSafeListNode *>::iterator iter;

    bool bFound = false;

    // look for element in todo list
    iter = m_listToDoDownload.begin();
    while (iter != m_listToDoDownload.end())
    {
        if ( MatchElements(pImportMedia, (*iter)->GetElement()) )
        {
            delete (*iter);
            m_listToDoDownload.erase(iter);
            
            bFound = true;

            break;
        }
        iter++;
    }

    if (bFound)
    {
        hr = CThreadSafeList::Add(pImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\timeparser.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timeparser.cpp
 *
 * Abstract:  Each parse function in this class assumes that the tokenizer's
 *            current token is first token that should be analyzed.
 *
 *******************************************************************************/
#include "headers.h"
#include "timeparser.h"
#include "playlist.h"

#define SECPERMINUTE 60   //seconds per minute
#define SECPERHOUR   3600 //seconds per hour
#define CLSIDLENGTH   38

static const ParentList
g_parentTable[] = 
{
    {MOREINFO_TOKEN, 4, {ASX_TOKEN, ENTRY_TOKEN, BANNER_TOKEN, INVALID_TOKEN}},
    {ENTRYREF_TOKEN, 4, {ASX_TOKEN, EVENT_TOKEN, REPEAT_TOKEN, INVALID_TOKEN}},
    {REF_TOKEN, 2, {ENTRY_TOKEN, INVALID_TOKEN}},
    {BASE_TOKEN, 3, {ASX_TOKEN, ENTRY_TOKEN, INVALID_TOKEN}},
    {LOGO_TOKEN, 3, {ASX_TOKEN, ENTRY_TOKEN, INVALID_TOKEN}},
    {PARAM_TOKEN, 3, {ASX_TOKEN, ENTRY_TOKEN, INVALID_TOKEN}},
    {PREVIEWDURATION_TOKEN, 4, {ASX_TOKEN, ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {STARTTIME_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {ENDTIME_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {STARTMARKER_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {ENDMARKER_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {DURATION_TOKEN, 3, {ENTRY_TOKEN, REF_TOKEN, INVALID_TOKEN}},
    {BANNER_TOKEN, 3, {ENTRY_TOKEN, ASX_TOKEN, INVALID_TOKEN}},
    {NULL, 0, {0}},
};

static const TOKEN
g_AsxTags[] =
{
    TITLE_TOKEN, AUTHOR_TOKEN, REF_TOKEN, COPYRIGHT_TOKEN,
    ABSTRACT_TOKEN, ENTRYREF_TOKEN, MOREINFO_TOKEN, ENTRY_TOKEN,
    BASE_TOKEN, LOGO_TOKEN, PARAM_TOKEN, PREVIEWDURATION_TOKEN,
    STARTTIME_TOKEN, STARTMARKER_TOKEN, ENDTIME_TOKEN, ENDMARKER_TOKEN,
    DURATION_TOKEN, BANNER_TOKEN, REPEAT_TOKEN, NULL
};

DeclareTag(tagTimeParser, "API", "CTIMEPlayerNative methods");

void
CTIMEParser::CreateParser(CTIMETokenizer *tokenizer, bool bSingleChar)
{
    m_Tokenizer = tokenizer;
    m_fDeleteTokenizer = false;
    //initializes the tokenizer to point to the first token in the stream
    if (m_Tokenizer)
    {
        if (bSingleChar)
        {
            m_Tokenizer->SetSingleCharMode(bSingleChar);
        }
        m_Tokenizer->NextToken();
        m_hrLoadError = S_OK;
    }
    else
    {
        m_hrLoadError = E_POINTER;
    }
}

void
CTIMEParser::CreateParser(LPOLESTR tokenStream, bool bSingleChar)
{
    HRESULT hr = S_OK;

    m_fDeleteTokenizer = true;
    m_Tokenizer = NULL;

    if (tokenStream == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    m_Tokenizer = NEW CTIMETokenizer();//lint !e1733 !e1732
    if (m_Tokenizer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = m_Tokenizer->Init(tokenStream, wcslen(tokenStream));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (bSingleChar)
    {
        m_Tokenizer->SetSingleCharMode(bSingleChar);
    }
    m_Tokenizer->NextToken();

  done:

    //store any errors here.
    m_hrLoadError = hr;

}//lint !e1541

void 
CTIMEParser::CreateParser(VARIANT *tokenStream, bool bSingleChar)
{
    CComVariant vTemp;
    HRESULT hr = S_OK;

    m_fDeleteTokenizer = true;
    m_Tokenizer = NULL; //lint !e672

    if (tokenStream == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    VariantInit (&vTemp);
    hr = VariantChangeTypeEx(&vTemp, tokenStream, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
    if (FAILED(hr))
    {
        goto done;
    }

    m_Tokenizer = NEW CTIMETokenizer();
    if (m_Tokenizer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = m_Tokenizer->Init(vTemp.bstrVal, SysStringLen(vTemp.bstrVal));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (bSingleChar)
    {
        m_Tokenizer->SetSingleCharMode(bSingleChar);
    }
    m_Tokenizer->NextToken();

  done:

    //store any errors here.
    m_hrLoadError = hr;

}//lint !e1541

CTIMEParser::~CTIMEParser()
{
    if (m_fDeleteTokenizer)
    {
        if (m_Tokenizer)
        {
            delete m_Tokenizer;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a double value of the percent found in the string.
//  Returns E_FAIL and 0 if the next token is not a percent value.
//
//  percentVal =        '+' unsignedPercent || '-' unsignedPercent
//  unsignedPercent =   number || number '%' || number ';' || number '%' ';'
//  number =            double
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePercent(double & percentVal)
{
    HRESULT hr = E_FAIL;

    TIME_TOKEN_TYPE curToken = TT_Unknown;
    bool bPositive = true;
    double curVal = 0.0;
    bool bOldSyntax = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bOldSyntax = m_Tokenizer->GetTightChecking();
    curToken = m_Tokenizer->TokenType();
    m_Tokenizer->SetTightChecking(true);

    //handle +,- 
    if (curToken == TT_Plus)
    { 
        curToken = m_Tokenizer->NextToken();
    }
    else if (curToken == TT_Minus)
    {
        bPositive = false;
        curToken = m_Tokenizer->NextToken();
    }

    if (curToken != TT_Number)
    {
        goto done;
    }
    curVal = m_Tokenizer->GetTokenNumber();
    curToken = m_Tokenizer->NextToken();
    
    //step over the percent sign.
    if (curToken == TT_Percent || curToken == TT_Semi)
    {
        curToken = m_Tokenizer->NextToken();
    }

    if (curToken != TT_EOF)
    {
        curVal = 0;
        goto done;
    }
      
    hr = S_OK;

  done:

    percentVal = curVal * ((bPositive)? 1 : -1);

    if (m_hrLoadError == S_OK)
    {
        m_Tokenizer->SetTightChecking(bOldSyntax);
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a bool value if the next token is a bool
//  Returns E_FAIL and false if the next token is not a bool value.
//
//  boolVal =   "true" || "false"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseBoolean(bool & boolVal)
{
    HRESULT hr = E_FAIL;
    bool bTemp = false;
    LPOLESTR pszToken = NULL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }
    curToken = m_Tokenizer->TokenType();
    if (curToken != TT_Identifier)
    {
        goto done;
    }

    pszToken = m_Tokenizer->GetTokenValue();
    if (pszToken == NULL)
    {
        goto done;
    }
    if (StrCmpIW(pszToken, WZ_TRUE) == 0) //if it is true
    {
        bTemp = true;
    }
    else if (StrCmpIW(pszToken, WZ_FALSE) != 0) //else if it is not false
    {
        goto done;
    }

    curToken = m_Tokenizer->NextToken();

    if (curToken != TT_EOF)
    {
        goto done;
    }

    hr = S_OK;

  done:
    if (pszToken)
    {
        delete [] pszToken;
    }
    boolVal = bTemp;
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a double value of the total number of seconds
//  Returns E_FAIL and false if the next token is not a clockvalue value.
//
//  clockVal =      '+' clock || '-' clock || "indefinite"
//  clock    =      HH ':' MM ':' SS || MM ':' SS || DD || DD 's' || DD 'm' || DD 'h'
//  HH       =      integer ( > 0 )
//  MM       =      integer (0 to 60)
//  SS       =      double (0 to 60)
//  DD       =      double
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseClockValue(double & time)
{
    HRESULT hr = E_FAIL;
    double fltTemp = 0.0;
    double fltHour = 0.0, fltMinute = 0.0, fltSecond = 0.0;
    LPOLESTR pszToken = NULL;
    long lColonCount = 0;
    bool bPositive = true, bFirstLoop = true;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    bool bOldSyntaxFlag = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bOldSyntaxFlag = m_Tokenizer->GetTightChecking();

    m_Tokenizer->SetTightChecking(true);
    curToken = m_Tokenizer->TokenType();
    
    //if this is a '+' or a '-' determine which and goto next token.
    if (curToken == TT_Minus || curToken == TT_Plus)
    {
        bPositive = (curToken != TT_Minus); 
        curToken = m_Tokenizer->NextToken();
    }
    
    if (curToken == TT_Identifier)
    {
        pszToken = m_Tokenizer->GetTokenValue();
        if (NULL == pszToken)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        if (IsIndefinite(pszToken))
        {
            hr = S_OK;
            fltTemp = INDEFINITE;
        }

        if (IsWallClock(pszToken))
        {
            m_Tokenizer->NextToken();
            hr = ParseWallClock(fltTemp);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        goto done;
    }
    else if (curToken == TT_Number)
    {
        fltSecond = m_Tokenizer->GetTokenNumber();
        curToken = m_Tokenizer->NextToken();
    }
    
    while (curToken != TT_EOF && curToken != TT_Semi)
    {
        //next can be either a ":", an identifier, or eof.
        switch (curToken)
        {
            case TT_Identifier:
            {
                //this is only valid the first time through the loop
                if (bFirstLoop)
                {
                    double fltMultiplier = 0.0;
                    if (pszToken)
                    {
                        delete [] pszToken;
                        pszToken = NULL;
                    }
                    pszToken = m_Tokenizer->GetTokenValue();
                    fltMultiplier = GetModifier(pszToken);
                    if (fltMultiplier == -1)
                    {
                        goto done;
                    }
                    else
                    {
                        fltTemp = fltSecond * fltMultiplier;
                    }
                }
                else 
                {
                    goto done;
                }
                hr = S_OK;
                m_Tokenizer->NextToken();
                goto done;

            }
            case TT_Colon:
            {   
                lColonCount++;
                if (lColonCount > 2)
                {
                    goto done;
                }

                //next case must be a number
                curToken = m_Tokenizer->NextToken();
                if (curToken != TT_Number)
                {
                    goto done;
                }
                fltHour = fltMinute;
                fltMinute = fltSecond;
                fltSecond = m_Tokenizer->GetTokenNumber();
                break;
            }
            default:
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }
        curToken = m_Tokenizer->NextToken();
        bFirstLoop = false;
    } 

    if ((fltHour < 0.0) || 
        (fltMinute < 0.0 || fltMinute > 60.0) ||
        ((fltHour != 0 || fltMinute != 0) && fltSecond > 60))
    {
        goto done;
    }
    else
    {
        fltTemp = (fltHour * SECPERHOUR) + (fltMinute * SECPERMINUTE) + fltSecond; 
    }
  

    hr = S_OK;

  done:
  
    if (FAILED(hr))
    {
        time = 0.0;
    }
    else
    {
        time = fltTemp;
        if (!bPositive)
        {
            time *= -1;
        }
    }

    delete [] pszToken;

    if (m_hrLoadError == S_OK)
    {
        //restore the old syntax checking state
        m_Tokenizer->SetTightChecking(bOldSyntaxFlag);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Returns S_OK and a double value of the total number of seconds
//  Returns S_FALSE if string is empty
//  Returns E_FAIL if the string is not a clockvalue value or has more than one value.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseRepeatDur(double & time)
{
    HRESULT hr;
    double dblRet;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    // If this is an empty string, error out 
    if (IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(ParseClockValue(dblRet));
    if (FAILED(hr))
    {
        goto done;
    }

    // Advance to the next token
    m_Tokenizer->NextToken();

    if (!IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    time = dblRet;
    
    hr = S_OK;

  done:

    return hr;
} // ParseRepeatDur


///////////////////////////////////////////////////////////////////////////////
//
//  Returns S_OK and a double value of the total number of seconds
//  Returns S_FALSE if string is empty
//  Returns E_FAIL if the string is not a clockvalue value or has more than one value.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseDur(double & time)
{
    HRESULT hr;
    double dblRet;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    // If this is an empty string, error out 
    if (IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(ParseClockValue(dblRet));
    if (FAILED(hr))
    {
        goto done;
    }

    // Advance to the next token
    m_Tokenizer->NextToken();

    if (!IsEmpty())
    {
        hr = E_INVALIDARG;
        goto done;
    }

    time = dblRet;
    
    hr = S_OK;

  done:

    return hr;
} // ParseDur


///////////////////////////////////////////////////////////////////////////////
//
// Check if there are only spaces including and after the current token. 
//
///////////////////////////////////////////////////////////////////////////////
bool 
CTIMEParser::IsEmpty()
{
    if (m_hrLoadError != S_OK)
    {
        return true;
    }

    TIME_TOKEN_TYPE curToken = m_Tokenizer->TokenType();

    while (TT_Space == curToken)
    {
        curToken = m_Tokenizer->NextToken();
    }

    // Check the current token for EOF or space
    if (TT_EOF == curToken)
    {
        return true;
    }
    else
    {
        return false;
    }

} // IsEmpty


long 
CTIMEParser::CountPath()
{
    HRESULT hr = E_FAIL;
    LPOLESTR tokenStream = NULL;
    CTIMETokenizer *pTokenizer = NULL;
    long lCurCount = 0;
    long lPointCount = 0;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    LPOLESTR pszTemp = NULL;
    PathType lastPathType = PathNotSet;
    bool bUseParen = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    //setup a new tokenizer
    pTokenizer = NEW CTIMETokenizer();
    if (pTokenizer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    tokenStream = m_Tokenizer->GetRawString(0, m_Tokenizer->GetStreamLength());

    if (tokenStream == NULL)
    {
        lCurCount = 0;
        goto done;
    }

    hr = pTokenizer->Init(tokenStream, wcslen(tokenStream));
    if (FAILED(hr))
    {
        goto done;
    }

    pTokenizer->SetSingleCharMode(true);
    pTokenizer->NextToken(); 

    //parse the path without saving anything.
    while (curToken != TT_EOF)
    {
        long lCurPoint = 0;
        if (pszTemp)
        {
            delete pszTemp;
            pszTemp = NULL;
        }
        if (   (lCurCount > 0)
            && (    (curToken == TT_Number)
                ||  (curToken == TT_Minus)
                ||  (curToken == TT_Plus)))
        {
            if (lastPathType == PathNotSet)
            {
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        else
        {
            pszTemp = pTokenizer->GetTokenValue();
            if (pszTemp == NULL)
            {
                goto done;
            }
            if (lstrlenW(pszTemp) != 1 && lastPathType != PathNotSet)  
            {
                hr = E_INVALIDARG;
                goto done;
            }
            switch (pszTemp[0])
            {
              case 'M': case 'm': 
                lPointCount = 1;
                lastPathType = PathMoveTo;
                break;
              case 'L': case 'l': 
                lPointCount = 1;
                lastPathType = PathLineTo;
                break;
              case 'H': case 'h': 
                lPointCount = 1;
                lastPathType = PathHorizontalLineTo;
                break;
              case 'V': case 'v': 
                lastPathType = PathVerticalLineTo;
                lPointCount = 1;
                break;
              case 'Z': case 'z': 
                lPointCount = 0;
                lastPathType = PathClosePath;
                break;
              case 'C': case 'c': 
                lPointCount = 3;
                lastPathType = PathBezier;
                break;
              default:
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        
        //check the hr falling out of the switch.
        if (FAILED(hr))
        {
            goto done;
        }

        //get the number of points specified.
        if (    (curToken != TT_Number)
            &&  (curToken != TT_Minus)
            &&  (curToken != TT_Plus))
        {
            curToken = pTokenizer->NextToken();
        }
        
        bUseParen = false;
        if (curToken == TT_LParen)
        {
            bUseParen = true;
            curToken = pTokenizer->NextToken();
        }

        while (lCurPoint < lPointCount &&  curToken != TT_EOF)
        {
            if (curToken != TT_Number)
            {
                if (    (curToken == TT_Minus)
                    ||  (curToken == TT_Plus))
                {
                    curToken = pTokenizer->NextToken();
                    if (curToken != TT_Number)
                    {
                        hr = E_INVALIDARG;
                        goto done;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                    goto done;
                }
            }
            if (lastPathType != PathVerticalLineTo && 
                lastPathType != PathHorizontalLineTo)
            {
                curToken = pTokenizer->NextToken();                
                if (curToken != TT_Number)
                {
                    if (    (curToken == TT_Minus)
                        ||  (curToken == TT_Plus))
                    {
                        curToken = pTokenizer->NextToken();
                        if (curToken != TT_Number)
                        {
                            hr = E_INVALIDARG;
                            goto done;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        goto done;
                    }
                }

            }
            lCurPoint++;
            
            curToken = pTokenizer->NextToken();
        }

        if (bUseParen)
        {
            if (curToken == TT_RParen)
            {
                curToken = pTokenizer->NextToken();
            }
            else
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }

        if (lCurPoint != lPointCount)
        {
            hr = E_INVALIDARG;
            goto done;
        }
        lCurCount++;
    }

    hr = S_OK;

  done:

    if (pszTemp)
    {
        delete pszTemp;
        pszTemp = NULL;
    }

    if (pTokenizer)
    {
        delete pTokenizer;
        pTokenizer = NULL;
    }

    if (tokenStream)
    {
        delete [] tokenStream;
        tokenStream = NULL;
    }

    if (FAILED(hr))
    {
        lCurCount = 0;
    }
    return lCurCount;
}

///////////////////////////////////////////////////////////////////////////////
//  Returns an array of path constructs
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePath(long & count, long & moveCount, CTIMEPath ***pppPath)
{
    HRESULT hr = E_FAIL;
    long lPathCount = 0;
    long lCurCount = 0;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    long lPointCount = 0;
    LPOLESTR pszTemp = NULL;
    PathType lastPathType = PathNotSet;
    CTIMEPath **pTempPathArray = NULL;
    bool bUseParen = false;
    POINTF ptPrev = {0.0, 0.0};
    bool fLastAbsolute = true;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    moveCount= 0;

    if (pppPath == NULL)
    {
        goto done;
    }

    lPathCount = CountPath();

    if (lPathCount == 0)
    {
        goto done;
    }

    //should be initialized to true now
    //m_Tokenizer->SetSingleCharMode(true);
    
    pTempPathArray = NEW CTIMEPath* [lPathCount];
    if (pTempPathArray == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();
    //loop through each and parse the current pathitem.
    while (curToken != TT_EOF && lCurCount < lPathCount)
    {
        long lCurPoint = 0;

        pTempPathArray[lCurCount] = NEW CTIMEPath;

        if (pszTemp)
        {
            delete pszTemp;
            pszTemp = NULL;
        }

        if (   (lCurCount > 0)
            && (    (curToken == TT_Number)
                ||  (curToken == TT_Minus)
                ||  (curToken == TT_Plus)))
        {
            if (lastPathType != PathNotSet)
            {
                if (lastPathType == PathMoveTo)
                {
                    // "If a moveto is followed by multiple pairs of coordinates, the subsequent 
                    // pairs are treated as implicit lineto commands."
                    hr = THR(pTempPathArray[lCurCount]->SetType(PathLineTo));
                }
                else
                {
                    hr = THR(pTempPathArray[lCurCount]->SetType(lastPathType));
                }
                //set the mode to the same as the last mode
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(fLastAbsolute));
                //lPointCount should be preserved from the last time around.
            }
            else
            {
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        else
        {
            pszTemp = m_Tokenizer->GetTokenValue();
            if (pszTemp == NULL)
            {
                goto done;
            }

            if (lstrlenW(pszTemp) != 1 && lastPathType != PathNotSet)  //Can only take one character here.
            {
                hr = E_INVALIDARG;
                goto done;
            }

            switch (pszTemp[0])
            {
              case 'M': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true)); 
              case 'm':  //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathMoveTo));
                lastPathType = PathMoveTo;
                lPointCount = 1;
                moveCount++;
                break;
          
              case 'L': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'l': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathLineTo));
                lastPathType = PathLineTo;
                lPointCount = 1;
                break;
          
              case 'H': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'h': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathHorizontalLineTo));
                lastPathType = PathHorizontalLineTo;
                lPointCount = 1;
                break;
          
              case 'V': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'v': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathVerticalLineTo));
                lastPathType = PathVerticalLineTo;
                lPointCount = 1;
                break;
          
              case 'Z': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'z': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathClosePath));
                lastPathType = PathClosePath;
                lPointCount = 0;
                break;
          
              case 'C': 
                IGNORE_HR(pTempPathArray[lCurCount]->SetAbsolute(true));
              case 'c': //lint !e616
                hr = THR(pTempPathArray[lCurCount]->SetType(PathBezier));
                lastPathType = PathBezier;
                lPointCount = 3;
                break;

              default:
                hr = E_INVALIDARG;
                lPointCount = 0;
            }
        }
        
        //check the hr falling out of the switch.
        if (FAILED(hr))
        {
            goto done;
        }

        //get the number of points specified.
        if (    (curToken != TT_Number)
            &&  (curToken != TT_Minus)
            &&  (curToken != TT_Plus))
        {
            curToken = m_Tokenizer->NextToken();
        }

        bUseParen = false;
        if (curToken == TT_LParen)
        {
            bUseParen = true;
            curToken = m_Tokenizer->NextToken();
        }

        {
            //
            // in this scope we parse the points and convert them to absolute values
            //

            POINTF tempPoint = {0.0, 0.0};

            while (lCurPoint < lPointCount &&  curToken != TT_EOF)
            {
                double fCurNum1 = 0.0, fCurNum2 = 0.0;
                bool fAbsolute;
                
                tempPoint.x = tempPoint.y = 0.0;
                fAbsolute = pTempPathArray[lCurCount]->GetAbsolute();

                hr = ParseNumber(fCurNum1, false);
                if (FAILED(hr))
                {
                    goto done;
                }

                if (lastPathType == PathVerticalLineTo)
                {
                    if (fAbsolute)
                    {
                        tempPoint.y = (float)fCurNum1;
                    }
                    else
                    {
                        tempPoint.y = (float)(fCurNum1 + ptPrev.y);
                    }
                    tempPoint.x = ptPrev.x;
                }
                else if (lastPathType == PathHorizontalLineTo)
                {
                    if (fAbsolute)
                    {
                        tempPoint.x = (float)fCurNum1;
                    }
                    else
                    {
                        tempPoint.x = (float)(fCurNum1 + ptPrev.x);
                    }
                    tempPoint.y = ptPrev.y;
                }
                else
                {  
                    hr = ParseNumber(fCurNum2, false);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
               
                    if (fAbsolute)
                    {
                        tempPoint.x = (float)fCurNum1;
                        tempPoint.y = (float)fCurNum2;
                    }
                    else
                    {
                        tempPoint.x = (float)(fCurNum1 + ptPrev.x);
                        tempPoint.y = (float)(fCurNum2 + ptPrev.y);
                    }
                }

                hr = THR(pTempPathArray[lCurCount]->SetPoints(lCurPoint, tempPoint));
                if (FAILED(hr))
                {
                    goto done;
                }

                lCurPoint++;

                curToken = m_Tokenizer->TokenType();
            }

            // after conversion, mark point as absolute
            fLastAbsolute = pTempPathArray[lCurCount]->GetAbsolute();
            pTempPathArray[lCurCount]->SetAbsolute(true);

            // cache the last absolute point
            ptPrev = tempPoint;     
        }

        if (bUseParen)
        {
            if (curToken == TT_RParen)
            {
                curToken = m_Tokenizer->NextToken();
            }
            else
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }

        if (lCurPoint != lPointCount)
        {
            goto done;
        }
        
        lCurCount++;
    }

    count = lCurCount ;

    hr = S_OK;

  done:

    if (m_hrLoadError == S_OK)
    {
        m_Tokenizer->SetSingleCharMode(false);
    }

    delete pszTemp;
    pszTemp = NULL;

    if (SUCCEEDED(hr) && pppPath)
    {
        // Bail if move-to is not the first command
        bool fInvalidPath = ((lCurCount > 0) && (PathMoveTo != pTempPathArray[0]->GetType()));

        if (fInvalidPath)
        {
            hr = E_FAIL;
        }
        else
        {
            // copy the path into the out param
            *pppPath = NEW CTIMEPath* [lCurCount];
            if (*pppPath == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                // copy the points
                memcpy(*pppPath, pTempPathArray, sizeof(CTIMEPath *) * lCurCount);  //lint !e668
            }
        }
    }

    if (FAILED(hr))
    {
        count = 0;
        moveCount = 0;
        if (pTempPathArray != NULL)
        {
            for (int i = 0; i < lPathCount; i++)
            {
                delete pTempPathArray[i];
            }
        } 
        if (pppPath)
        {
            *pppPath = NULL;
        }
    }
    delete [] pTempPathArray;
  
    return hr;

}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a double value if the next token is a valid number
//  Returns E_FAIL and false if the next token is not a number.
//
//  Number      = '+' doubleVal || '-' doubleVal || "indefinite"
//  doubleVal    =  double || '.' integer
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseNumber(double & doubleVal, bool bValidate /* = true */)
{
    HRESULT hr = E_FAIL;
    bool bPositive = true;
    double fltTemp = 0.0;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    LPOLESTR pszTemp = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    //if this is a '+' or a '-' determine which and goto next token.
    if (curToken == TT_Minus || curToken == TT_Plus)
    {
        bPositive = (curToken != TT_Minus); 
        curToken = m_Tokenizer->NextToken();
    }
    
    switch (curToken)
    {
      case TT_Number:
        {
            fltTemp = m_Tokenizer->GetTokenNumber();
            break;
        }
      case TT_Identifier:
        {
            pszTemp = m_Tokenizer->GetTokenValue();
            if (pszTemp == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            if (!IsIndefinite(pszTemp))
            {
                hr = E_INVALIDARG;
                goto done;
            }

            fltTemp = INDEFINITE;

            break;
        }
      default:
        {   //failure case
            hr = E_INVALIDARG;
            goto done;
        }
    }

    // Advance to the next token
    m_Tokenizer->NextToken();

    if (bValidate)
    {
        // only spaces allowed after this
        if (!IsEmpty())
        {
            fltTemp = 0.0;
            hr = E_INVALIDARG;
            goto done;
        }
    }
    hr = S_OK;

  done:

    doubleVal = fltTemp * ((bPositive)? 1 : -1);

    delete [] pszTemp;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  syncbase =  (id)("." "begin" || "." "end")("+" clockvalue)?
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseSyncBase(LPOLESTR & ElementID, LPOLESTR & syncEvent, double & time)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    LPOLESTR pszElement = NULL, pszEvent = NULL;
    double clockTime = 0.0;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }
    //get the element id
    pszElement = m_Tokenizer->GetTokenValue();

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Dot)
    {
        goto done;
    }

    //get the event name
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Identifier)
    {
        goto done;
    }
    
    pszEvent = m_Tokenizer->GetTokenValue();
    curToken = m_Tokenizer->NextToken();

    if (curToken == TT_Plus || curToken == TT_Minus) //get the clock value for this
    {
        hr = ParseClockValue(clockTime);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (curToken == TT_Semi)
    {
        curToken = m_Tokenizer->NextToken();
        goto done;
    }

    if (curToken != TT_EOF)
    {
        goto done;
    }

    hr = S_OK;

  done:
    if (FAILED(hr))
    {
        if (pszElement)
        {
            delete [] pszElement;
            pszElement = NULL;
        }
        if (pszEvent)
        {
            delete [] pszEvent;
            pszEvent = NULL;
        }
        clockTime = 0.0;
    }

    ElementID = pszElement;
    syncEvent = pszEvent;
    time = clockTime;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  
//  Begin       =   clockvalue || syncBase || eventvalue || "indefinite"
//  clockValue  =   clockValue //call parseClockValue
//  EventValue  =   EventList  //call parseEvent  //NOT CURRENTLY HANDLED
//  syncBase    =   SyncBase   //call parseSyncBase
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseTimeValueList(TimeValueList & tvList, bool * bWallClock, SYSTEMTIME * sysTime)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    double curOffsetTime = 0.0;
    LPOLESTR pszElement = NULL;
    LPOLESTR pszEvent = NULL;
    bool bOldSyntaxFlag = false;
    bool bNeg = false;

    if (bWallClock)
    {
        *bWallClock = false;
    }

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bOldSyntaxFlag = m_Tokenizer->GetTightChecking();
    tvList.Clear();
    
    curToken = m_Tokenizer->TokenType();

    m_Tokenizer->SetTightChecking(true);
        
    while (curToken != TT_EOF)  //loop until eof
    {
        Assert(curOffsetTime == 0.0);
        Assert(pszElement == NULL);
        Assert(pszEvent == NULL);

        switch (curToken)
        {
            case (TT_Plus):
            case (TT_Minus):
            case (TT_Number): //handle the case of a clock value
            {
                hr = THR(ParseClockValue(curOffsetTime));
                if (FAILED(hr))
                {
                    goto done;
                }
                curToken = m_Tokenizer->TokenType();
                break;
            }
            case (TT_Identifier): //handle the case of an event value
            {  // (element .)? event (+ offset)?
                pszEvent = m_Tokenizer->GetTokenValue();
                if (pszEvent == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                if (IsIndefinite(pszEvent))
                {
                    delete [] pszEvent;
                    pszEvent = NULL;
                    curOffsetTime = (double)TIME_INFINITE;
                    curToken = m_Tokenizer->NextToken();
                    break;
                }

                if (IsWallClock(pszEvent))
                {
                    m_Tokenizer->NextToken();
                    if (bWallClock)
                    {
                        *bWallClock = true;
                    }
                    hr = ParseWallClock(curOffsetTime, sysTime);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    delete [] pszEvent;
                    pszEvent = NULL;
                    break;
                }

                curToken = m_Tokenizer->NextToken();
                switch (curToken)
                {
                    case TT_Dot:
                    {
                        pszElement = pszEvent; //move the event in the element holder
                        pszEvent = NULL;
                        curToken = m_Tokenizer->NextToken();
                        if (curToken == TT_Identifier)
                        {
                            pszEvent = m_Tokenizer->GetTokenValue();
                            if (pszEvent == NULL)
                            {
                                hr = E_INVALIDARG;
                                goto done;
                            }
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                            goto done;
                        }
                        
                        do  //white space is valid here.
                        {
                            curToken = m_Tokenizer->NextToken();
                        } while (curToken == TT_Space);
                        
                        if (curToken == TT_Minus)
                        {
                            bNeg = true;
                        }

                        if (curToken == TT_Plus || curToken == TT_Minus)
                        {
                            do  //white space is valid here.
                            {
                                curToken = m_Tokenizer->NextToken();
                            } while (curToken == TT_Space);
                            if (curToken == TT_EOF || curToken == TT_Semi)
                            {
                                hr = E_FAIL;
                                goto done;
                            }
                            hr = THR(ParseClockValue(curOffsetTime));
                            if (FAILED(hr))
                            {
                                goto done;
                            }
                            if (bNeg == true)
                            {
                                bNeg = false;
                                curOffsetTime *= -1;
                            }
                            curToken = m_Tokenizer->TokenType();
                        }
                        else if (curToken == TT_Semi)
                        {
                            curToken = m_Tokenizer->NextToken();
                        }
                        else if (curToken != TT_EOF)
                        { //handle all cases other than EOF
                            hr = E_INVALIDARG;
                            goto done;
                        }
                        break;
                    }
                    case TT_Plus:
                    case TT_Minus:
                    {
                        hr = THR(ParseClockValue(curOffsetTime));
                        if (FAILED(hr))
                        {
                            goto done;
                        }
                        curToken = m_Tokenizer->NextToken();
                        break;
                    }
                    case TT_Semi:
                    case TT_EOF:
                    {
                        curOffsetTime = 0.0;
                        break;
                    }
                    default:
                    {   
                        hr = E_INVALIDARG;
                        goto done;
                    }

                }
                break; 
            }
            default:
            {
                //this is an error case
                hr = E_INVALIDARG;
                goto done;
            }
        }

        while (curToken == TT_Semi || curToken == TT_Space) //skip past all ';'s
        {
            curToken = m_Tokenizer->NextToken();
        }
        
        TimeValue *tv;

        tv = new TimeValue(pszElement,
                           pszEvent,
                           curOffsetTime);

        if (tv == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        // @@ ISSUE : Need to detect memory failure
        tvList.GetList().push_back(tv);

        curOffsetTime = 0.0;
        pszElement = NULL;
        pszEvent = NULL;
    }  //lint !e429

    Assert(curToken == TT_EOF);

    hr = S_OK;
  done:

    delete [] pszElement;
    delete [] pszEvent;
    
    if (FAILED(hr))
    {
        tvList.Clear();
    }

    if (m_hrLoadError == S_OK)
    {
        //restore the old syntax checking state
        m_Tokenizer->SetTightChecking(bOldSyntaxFlag);
    }

    return hr;
}

bool
CTIMEParser::IsWallClock(OLECHAR *szWallclock)
{
    bool bResult = FALSE;
    
    if (StrCmpIW(szWallclock, L"wallclock") == 0)
    {
        bResult = TRUE;
    }

  done:
    return bResult;
}

HRESULT 
CTIMEParser::ParseWallClock(double & curOffsetTime, SYSTEMTIME * sysTime)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    bool bOldSyntax = false;
    int nDay = 0, nMonth = 0, nYear = 0;
    double fHours = 0.0, fMinutes = 0.0, fSec = 0.0;
    SYSTEMTIME curTime, wallTime;
    LPOLESTR pszTemp = NULL;
    bool bUseDate = false;
    bool bUseLocalTime = false;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    //initialize the time variables.
    ZeroMemory(&wallTime, sizeof(wallTime));
    ZeroMemory(&curTime, sizeof(curTime));

    m_Tokenizer->SetSingleCharMode(true);

    curToken = m_Tokenizer->TokenType();
    bOldSyntax = m_Tokenizer->GetTightChecking();
    m_Tokenizer->SetTightChecking(true);

    if (curToken != TT_LParen)
    {
        goto done;
    }
    curToken = m_Tokenizer->NextToken();

    //white space is valid here.
    while (curToken == TT_Space)
    {
        curToken = m_Tokenizer->NextToken();
    }
    
    if (curToken != TT_Number)
    {
        goto done;
    }

    if (m_Tokenizer->PeekNextNonSpaceChar() == '-')
    {
        bool bNeedEnd = false;
        bUseDate = true;
        hr = ParseDate(nYear, nMonth, nDay);
        if (FAILED(hr))
        {
            goto done;
        }
        wallTime.wYear = (WORD)nYear;
        wallTime.wMonth = (WORD)nMonth;
        wallTime.wDay = (WORD)nDay;
        curToken = m_Tokenizer->TokenType();
        if (curToken == TT_Space)
        {
            bNeedEnd = true;
            while (curToken == TT_Space)
            {
                curToken = m_Tokenizer->NextToken();
            }
        }
        if (curToken == TT_RParen)
        {
            bUseLocalTime = true;
        }
        else if (bNeedEnd == true)
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else if (m_Tokenizer->PeekNextNonSpaceChar() == ':')
    {
        //init the walltime structure to be today.
        wallTime.wYear = 0;
        wallTime.wMonth = 0;
        wallTime.wDay = 0;

        hr = ParseOffset(fHours, fMinutes, fSec, bUseLocalTime);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    curToken = m_Tokenizer->TokenType();
    if (curToken == TT_Identifier)
    {
        pszTemp = m_Tokenizer->GetTokenValue();
        if (StrCmpW(pszTemp, L"Z") == 0)
        {
            m_Tokenizer->NextToken();
        }
        else if (StrCmpW(pszTemp, L"T") == 0)
        {
            curToken = m_Tokenizer->NextToken();        
    
            hr = ParseOffset(fHours, fMinutes, fSec, bUseLocalTime);
            if (FAILED(hr))
            {
                goto done;
            }   
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }
    }
    
    curToken = m_Tokenizer->TokenType();
    //white space is valid here.
    while (curToken == TT_Space)
    {
        curToken = m_Tokenizer->NextToken();
    } 
    
    if (curToken != TT_RParen)
    {
        hr = E_FAIL;
        goto done;
    }

    if (bUseLocalTime == true)
    {
        if (sysTime == NULL)
        {
            GetLocalTime(&curTime);
        }
        else
        {
            curTime = *sysTime;
        }
    }
    else
    {
        TIME_ZONE_INFORMATION tzInfo;
        DWORD dwRet = GetTimeZoneInformation(&tzInfo);
        GetSystemTime(&curTime);
        if (dwRet & TIME_ZONE_ID_DAYLIGHT && tzInfo.DaylightBias == -60)
        {
            curTime.wHour += 1;
        }
    }

    if (wallTime.wYear == 0 && wallTime.wDay == 0 && wallTime.wMonth == 0)
    {
        wallTime.wYear = curTime.wYear;
        wallTime.wMonth = curTime.wMonth;
        wallTime.wDay = curTime.wDay;
    }
    wallTime.wHour = (WORD)fHours;
    wallTime.wMinute = (WORD)fMinutes;
    wallTime.wSecond = (WORD)fSec;

    
    //need to figure out the time difference here.
    hr = ComputeTime(&curTime, &wallTime, curOffsetTime, bUseDate);
    if (FAILED(hr))
    {   
        goto done;
    }
    hr = S_OK;

  done:

    if(m_hrLoadError == S_OK)
    {
        m_Tokenizer->SetSingleCharMode(false);
        m_Tokenizer->SetTightChecking(bOldSyntax);
    }

    if (FAILED(hr))
    {
        curOffsetTime = 0.0;
    }

    if (pszTemp)
    {
        delete pszTemp;
        pszTemp = NULL;
    }

    return hr;
}

void 
CTIMEParser::CheckTime(SYSTEMTIME *wallTime, bool bUseDate)
{
    int DayPerMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31 };    

    while (wallTime->wSecond >= 60)
    {
        wallTime->wMinute++;
        wallTime->wSecond -= 60;
    }
    while (wallTime->wMinute >= 60)
    {
        wallTime->wHour++;
        wallTime->wMinute -= 60;
    }
    while (wallTime->wHour >= 24)
    {
        if (bUseDate == true)
        {
            wallTime->wDay++;
        }
        wallTime->wHour -= 24;
    }
    while (wallTime->wDay > DayPerMonth[wallTime->wMonth - 1])
    {
        wallTime->wDay = (WORD)(wallTime->wDay - DayPerMonth[wallTime->wMonth - 1]);
        wallTime->wMonth++;
        if (wallTime->wMonth > 12)
        {
            wallTime->wMonth = 1;
            wallTime->wYear++;
        }
    }

    return;
}

HRESULT 
CTIMEParser::ComputeTime(SYSTEMTIME *curTime, SYSTEMTIME *wallTime, double & curOffsetTime, bool bUseDate)
{
    HRESULT hr = E_FAIL;
    FILETIME fileCurTime, fileWallTime;
    LARGE_INTEGER lnCurTime, lnWallTime;
    BOOL bError = FALSE;
    hr = S_OK;

    CheckTime(curTime, bUseDate);
    bError = SystemTimeToFileTime(curTime, &fileCurTime);
    if (!bError)
    {
        goto done;
    }   

    CheckTime(wallTime, bUseDate);
    bError = SystemTimeToFileTime(wallTime, &fileWallTime);
    if (!bError)
    {
        goto done;
    }   

    memcpy (&lnCurTime, &fileCurTime, sizeof(lnCurTime));
    memcpy (&lnWallTime, &fileWallTime, sizeof(lnWallTime));

    lnWallTime.QuadPart -= lnCurTime.QuadPart;
    //number is to convert from 100 nanosecond intervals to seconds 
    curOffsetTime = lnWallTime.QuadPart / 10000000;  //lint !e653

    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        curOffsetTime = 0.0;
    }

    return hr;
}


HRESULT 
CTIMEParser::ParseSystemLanguages(long & lLangCount, LPWSTR **ppszLang)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    long lCount = 0;
    LPWSTR *pszLangArray = NULL;
    LPWSTR pszLang = NULL;
    bool bDone = false;
    
    lLangCount = 0;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    lCount = m_Tokenizer->GetAlphaCount(',');
    lCount += 1; 
    pszLangArray = NEW LPWSTR [lCount];
    if (pszLangArray == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();
    while (!bDone && lLangCount <= lCount)
    {
        CComBSTR bstrLang;
        switch (curToken)
        {
        case TT_Identifier:
            pszLang = m_Tokenizer->GetTokenValue();
            bstrLang.Append(pszLang);
            delete [] pszLang;
            pszLang = NULL;
            curToken = m_Tokenizer->NextToken();
            if (curToken == TT_Minus)
            {
                bstrLang.Append(L"-");
            
                curToken = m_Tokenizer->NextToken();
                if (curToken == TT_Identifier)
                {
                    pszLang = m_Tokenizer->GetTokenValue();
                    bstrLang.Append(pszLang);
                    delete [] pszLang;
                    pszLang = NULL;
                }
                else
                {
                    hr = E_INVALIDARG; 
                    goto done;
                }
                curToken = m_Tokenizer->NextToken();
            }

            if (curToken == TT_Comma)
            {
                curToken = m_Tokenizer->NextToken();
            }

            pszLang = CopyString(bstrLang);
            pszLangArray[lLangCount] = pszLang;
            pszLang = NULL;
            lLangCount++;
            break;
        case TT_EOF:
            bDone = true;
            break;
        default:
            hr = E_INVALIDARG;
            goto done;
        }
    }

    hr = S_OK;

  done:
    if (SUCCEEDED(hr))
    {
        *ppszLang = NEW LPWSTR[lLangCount];
        if ((*ppszLang) == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            if (pszLangArray != NULL)
            {
                memcpy(*ppszLang, pszLangArray, sizeof(LPWSTR*) * lLangCount);
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszLangArray)
        {
            for (int i = 0; i < lLangCount; i++)
            {
                delete [] pszLangArray[i];
            }
        }
        lLangCount = 0;
        ppszLang = NULL;
    }

    if (pszLangArray != NULL)
    {
        delete [] pszLangArray;
    }  
    
    return hr;
}

HRESULT 
CTIMEParser::ParseDate(int & nYear, int & nMonth, int & nDay)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    double fTemp = 0.0;
    int DayPerMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31 };    

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();
    if (curToken != TT_Number)
    {
        goto done;
    }
    
    // get the year value
    fTemp = m_Tokenizer->GetTokenNumber();
    if (fTemp < 0.0 || fTemp != floor(fTemp))
    {
        goto done;
    }
    nYear = (int)fTemp;

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Minus)
    {
        goto done;
    }

    //get the month value
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Number)
    {
        goto done;
    }
    
    fTemp = m_Tokenizer->GetTokenNumber();
    if (fTemp < 0.0 || fTemp > 12.0 || fTemp != floor(fTemp))
    {
        goto done;
    }
    nMonth = (int)fTemp;

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Minus)
    {
        goto done;
    }


    //get the day value
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Number)
    {
        goto done;
    }
    
    fTemp = m_Tokenizer->GetTokenNumber();
    if (fTemp != floor(fTemp))
    {
        goto done;
    }
    nDay = (int)fTemp;

    
    if (nDay < 0 || nDay > DayPerMonth[nMonth - 1])
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if ((nMonth == 2) && (nDay == 29) &&
        !((nYear%4 == 0 ) && ((nYear%100 != 0) || (nYear%400 == 0))))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();

    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        nYear = 0;
        nMonth = 0;
        nDay = 0;
    }

    return hr;
}

HRESULT 
CTIMEParser::ParseOffset(double & fHours, double & fMinutes, double & fSec, bool &bUseLocalTime)
{
    HRESULT hr = E_FAIL;

    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    double fltSecond = 0.0, fltMinute = 0.0, fltHour = 0.0, fltTotalTime = 0.0;
    long lColonCount = 0;
    bool bNeg = false;
    hr = S_OK;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    bUseLocalTime = false;
    curToken = m_Tokenizer->TokenType();
    if (curToken != TT_Number)
    {
        goto done;
    }

    fltHour = m_Tokenizer->GetTokenNumber();
    curToken = m_Tokenizer->NextToken();
    
    while (curToken != TT_EOF && 
           curToken != TT_Identifier && 
           curToken != TT_RParen &&
           curToken != TT_Plus &&
           curToken != TT_Minus)
    {
        switch (curToken)
        {
          case TT_Colon:
            {   
                lColonCount++;
                if (lColonCount > 2)
                {
                    goto done;
                }

                //next case must be a number
                curToken = m_Tokenizer->NextToken();
                if (curToken != TT_Number)
                {
                    goto done;
                }
                if (lColonCount == 1)
                {
                    fltMinute = m_Tokenizer->GetTokenNumber();
                }
                else
                {
                    fltSecond = m_Tokenizer->GetTokenNumber();
                }
                break;
            }
          default:
            {
                hr = E_INVALIDARG;
                goto done;
            }
        }
        curToken = m_Tokenizer->NextToken();
    } 

    if (lColonCount == 0)
    {
        goto done;
    }

    if ((fltHour < 0.0) ||  fltHour > 24.0 ||
        (fltMinute < 0.0 || fltMinute > 60.0) ||
        ((fltHour != 0 || fltMinute != 0) && fltSecond > 60) ||
        ((floor(fltHour) != fltHour) ||
         (floor(fltMinute) != fltMinute)))
    {
        hr = E_FAIL;
        goto done;
    }

    if (curToken == TT_Plus)
    {
        bNeg = true;
    }

    fHours = fltHour;
    fMinutes = fltMinute;
    fSec = fltSecond;
    
    if (curToken == TT_Plus || curToken == TT_Minus)
    {
        bool bIgnoreThis;
        m_Tokenizer->NextToken();
        hr = ParseOffset(fltHour, fltMinute, fltSecond, bIgnoreThis);
        if (FAILED(hr))
        {
            goto done;
        }

        fltTotalTime = ((((fltHour * 60) + fltMinute) * 60) + fltSecond);
        if (bNeg)
        {
            fltTotalTime *= -1;
        }

        fltTotalTime = ((((fHours * 60) + fMinutes) * 60) + fSec) + fltTotalTime;
        fHours = floor(fltTotalTime / 3600);
        fltTotalTime -= fHours * 3600;
        fMinutes = floor(fltTotalTime / 60);
        fltTotalTime -= fMinutes * 60;
        fSec = fltTotalTime;

        curToken = m_Tokenizer->TokenType();
    }
    else if (curToken == TT_Identifier)
    {
        LPOLESTR pszTemp = NULL;
        pszTemp = m_Tokenizer->GetTokenValue();
        if (StrCmpW(pszTemp, L"Z") == 0)
        {
            delete pszTemp;
            pszTemp = NULL;
        }
        else
        {
            hr = E_FAIL;            
            delete pszTemp;
            pszTemp = NULL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();
    }
    else
    {
        bUseLocalTime = true;
    }

    while (curToken == TT_Space)
    {
        curToken = m_Tokenizer->NextToken();
    }

    if (curToken != TT_RParen)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;

  done:


    if (FAILED(hr))
    {
        fHours = 0;
        fMinutes = 0;
        fSec = 0;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a token value if the next token is a valid fill value
//  Returns E_FAIL and false if the next token is not a valid fill value.
//
//  fill    =   'remove' || 'freeze' || 'hold' || 'transition'
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseFill(TOKEN &FillTok)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != REMOVE_TOKEN && 
        tempToken != FREEZE_TOKEN && 
        tempToken != HOLD_TOKEN &&
        tempToken != TRANSITION_TOKEN
       ) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
  
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    FillTok = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid RestartParam
//  Returns E_FAIL and NULL if the next token is not a valid Restart Val.
//
//  Restart     =   "always" || "never" || "whenNotActive"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseRestart(TOKEN & TokRestart)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != ALWAYS_TOKEN && 
        tempToken != NEVER_TOKEN && 
        tempToken != WHENNOTACTIVE_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }


    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    TokRestart = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid Sync paramenter
//  Returns E_FAIL and NULL if the next token is not a valid Sync value.
//
//  SyncVal     =   "canSlip" || "locked"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseSyncBehavior(TOKEN & SyncVal)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != CANSLIP_TOKEN && 
        tempToken != LOCKED_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    SyncVal = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid TimeAction
//  Returns E_FAIL and NULL if the next token is not a valid TimeAction
//
//  TimeAction     =    "class"     ||
//                      "display"   ||
//                      "none"      ||
//                      "onOff"     ||
//                      "style"     ||
//                      "visibility" 
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseTimeAction(TOKEN & timeAction)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != CLASS_TOKEN && 
        tempToken != DISPLAY_TOKEN &&
        tempToken != NONE_TOKEN &&
        tempToken != ONOFF_PROPERTY_TOKEN &&
        tempToken != STYLE_TOKEN &&
        tempToken != VISIBILITY_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    timeAction = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid timeline
//  Returns E_FAIL and NULL if the next token is not a valid timeline
//
//  TimeLine    =   "par"   ||
//                  "seq"   ||
//                  "excl"  ||
//                  "none" 
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseTimeLine(TimelineType & timeline)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != SEQ_TOKEN && 
        tempToken != PAR_TOKEN &&
        tempToken != NONE_TOKEN &&
        tempToken != EXCL_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    
    if (tempToken == SEQ_TOKEN)
    {
        timeline = ttSeq;
    }
    else if (tempToken == EXCL_TOKEN)
    {
        timeline = ttExcl;
    }
    else if (tempToken == PAR_TOKEN)
    {
        timeline = ttPar;
    }
    else
    {
        timeline = ttNone;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        timeline = ttNone;
        goto done;
    }

    hr = S_OK;

  done:

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid update value
//  Returns E_FAIL and NULL if the next token is not a valid update value
//
//  Update    =   "auto"     ||
//                "manual"   ||
//                "reset"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseUpdateMode(TOKEN & update)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();


    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != AUTO_TOKEN && 
        tempToken != MANUAL_TOKEN &&
        tempToken != RESET_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    update = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and either a token representing the player device or a clsid.
//      In the case of a valid classid, the token returned will be NULL.
//  Returns E_FAIL and if the next token is not a valid Player.
//
//  Player =    "dshow"         ||
//              "dvd"           ||
//              CLSID
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePlayer(TOKEN & player, CLSID & clsid)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken == TT_Identifier)
    {
        hr = ParseToken(&tempToken);
        if (FAILED(hr))
        {
            goto done;
        }
        if (tempToken != DVD_TOKEN &&
#if DBG // 94850
            tempToken != DSHOW_TOKEN &&
#endif
            tempToken != DMUSIC_TOKEN &&
            tempToken != CD_TOKEN) //validates that this is the correct token.
        {
            tempToken = NULL;
            hr = E_FAIL;
            goto done;
        }
    }
    else if (curToken == TT_LCurly)
    {
        hr = ParseCLSID(clsid);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (curToken == TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:

    player = tempToken;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a CLSID value if the next token is a valid CLSID
//  Returns E_FAIL and if the next token is not a valid CLSID.
//
//  CLSID = '{' GUID '}' 
//  GUID = id '-' id '-' id '-' id
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseCLSID(CLSID & clsid)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    CComBSTR bstrCLSID;
    LPOLESTR pszTemp = NULL;
    long curLoc = 0;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_LCurly)
    {
        goto done;
    }
    
    curLoc = m_Tokenizer->CurrTokenOffset();
    pszTemp = m_Tokenizer->GetRawString(curLoc, curLoc + CLSIDLENGTH);
    if (NULL == pszTemp)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    bstrCLSID.Append (L"{");   
    bstrCLSID.Append (pszTemp);   

    //advance to the end of the clsid
    while (curToken != TT_RCurly && curToken != TT_EOF)
    {
        curToken = m_Tokenizer->NextToken();
    }
    //move to the next token
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

  done:

    if (pszTemp)
    {
        delete [] pszTemp;
        pszTemp = NULL;
    }

    //if this is successful then create a clsid from the bstr.
    if (SUCCEEDED(hr))
    {
        hr = THR(CLSIDFromString(bstrCLSID, &clsid));
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid calcMode
//  Returns E_FAIL and NULL if the next token is not a valid calcMode
//
//  CalcMode    =   "discrete"  ||
//                  "linear"    ||
//                  "paced"     
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseCalcMode(TOKEN & calcMode)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != DISCRETE_TOKEN && 
        tempToken != LINEAR_TOKEN &&
        tempToken != PACED_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    
    curToken =m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    hr = S_OK;

  done:
    calcMode = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a string identifier from the next token
//  Returns E_FAIL and false if the next token is not a string.
//
//  ID = string
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseIdentifier(LPOLESTR & id)
{   
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    LPOLESTR pszTemp = NULL;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }
    
    pszTemp = m_Tokenizer->GetTokenValue();

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        delete pszTemp;
        pszTemp = NULL;
        goto done;
    }

    hr = S_OK;

  done:

    id = pszTemp;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and a TOKEN value if the next token is a valid priorityClass attribute
//  Returns E_FAIL and NULL if the next token is not a valid priorityClass
//
//  priorityClass    =   "stop" || "pause" || "defer" || "never"
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParsePriorityClass(TOKEN & priorityClass)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    if (IsEmpty())
    {
        hr = E_FAIL;
        goto done;
    }
    
    curToken = m_Tokenizer->TokenType();

    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }
    if (tempToken != STOP_TOKEN &&
        tempToken != PAUSE_TOKEN &&
        tempToken != DEFER_TOKEN &&
        tempToken != NEVER_TOKEN) //validates that this is the correct token.
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();
    if (!IsEmpty())    
    {
        tempToken = NULL;
        goto done;
    }
    hr = S_OK;

  done:
    priorityClass = tempToken;
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK and either a TOKEN value or and identifier if the next token is a valid EndSync
//      In the case of a valid token, the ID param will be NULL, in the case of a valid ID, then
//      token will be NULL;
//  Returns E_FAIL and NULL in both params if the next token is invalid.
//
//  EndSync    =   "first"  ||
//                 "last"   ||
//                 "none"   ||
//                 Identifier
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseEndSync(TOKEN & endSync, LPOLESTR & ID)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp = NULL;
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();


    if (curToken != TT_Identifier)
    {
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (SUCCEEDED(hr))
    {
        if (tempToken == FIRST_TOKEN ||
            tempToken == LAST_TOKEN ||
            tempToken == NONE_TOKEN) //validates that this is the correct token.
        {
            endSync = tempToken;
            hr = S_OK;
            goto done;
        }
        else
        {
            tempToken = NULL;
        }
    }
    pszTemp = m_Tokenizer->GetTokenValue();
    if (pszTemp == NULL)
    {
        goto done;
    }
    
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_EOF)
    {
        delete pszTemp;
        pszTemp = NULL;
        goto done;
    }

    hr = S_OK;

  done:

    ID = pszTemp;
    endSync = tempToken;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  Returns S_OK if the current token is EOF, returns E_FAIL otherwise.
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEParser::ParseEOF()
{
    HRESULT hr = S_OK;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    if (m_Tokenizer->TokenType() != TT_EOF)
    {
        hr = E_FAIL;   
    }

  done:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Converts a number to a decimal value i.e. 5.24 to 0.524.
//  This is used to convert '.' number values from the tokenizer
//  because the it does not recognize 'dot' 5 as .5, but 
//  as two separate tokens, a dot token and a number token.
///////////////////////////////////////////////////////////////////////////////
double 
CTIMEParser::DoubleToDecimal(double val, long lCount)
{
    for (int i = 0; i < lCount; i++)
    {
        val /= 10.0;
    }

    return val;
}

/////////////////////////////////////////////////////////////////////////////////
// Creates a TOKEN out of the current TIME_TOKEN value.  There is no type checking
// done here.  The type coming in must bu TT_Identifier and that must be validated
// by the caller.
/////////////////////////////////////////////////////////////////////////////////
HRESULT
CTIMEParser::ParseToken(TOKEN *pToken)
{
    HRESULT hr = E_FAIL;
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp = NULL;
    
    *pToken = NULL;

    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    pszTemp = m_Tokenizer->GetTokenValue();
    if (NULL == pszTemp)
    {
        goto done;
    }

    tempToken = StringToToken(pszTemp);  

    *pToken = tempToken;
    hr = S_OK;

done:
    
    if (pszTemp)
    {
        delete [] pszTemp;
    }
    return hr;

}

//determines the time multiple to apply based on the string type passed in.
// returns:     -1 if invalid
//              
double 
CTIMEParser::GetModifier(OLECHAR *szToken)
{

    if (StrCmpIW(szToken, L"s") == 0)
    {
        return 1;
    }
    else if (StrCmpIW(szToken, L"m") == 0)
    {
        return SECPERMINUTE;
    }
    else if (StrCmpIW(szToken, L"h") == 0)
    {
        return SECPERHOUR;
    }
    else if (StrCmpIW(szToken, L"ms") == 0)
    {
        return (double)0.001; // seconds/millisecond
    }
    
    return -1; //invalid value
}


////////////////////////////////////////////////////////////////////////
//  Path Struct
////////////////////////////////////////////////////////////////////////
CTIMEPath::CTIMEPath() :
    m_pPoints(NULL),
    m_pathType(PathNotSet),
    m_bAbsoluteMode(false),
    m_lPointCount(0)
{
    //do nothing
}

CTIMEPath::~CTIMEPath()
{
    delete [] m_pPoints;
}

HRESULT  
CTIMEPath::SetType(PathType type)
{
    HRESULT hr = E_FAIL;
    m_pathType = type;

    if (m_pathType == PathMoveTo || 
        m_pathType == PathLineTo || 
        m_pathType == PathHorizontalLineTo || 
        m_pathType == PathVerticalLineTo)
    {
        m_lPointCount = 1;
    }
    else if (m_pathType == PathClosePath)
    {
        m_lPointCount = 0;
    }
    else if (m_pathType == PathBezier)
    {
        m_lPointCount = 3;
    }
    else
    {
        hr = E_INVALIDARG;
        m_lPointCount = 0;
        goto done;
    }

    if (m_pPoints)
    {   
        delete m_pPoints;
        m_pPoints = NULL;
    }   

    if (m_lPointCount > 0)
    {
        m_pPoints = NEW POINTF [m_lPointCount];

        if (m_pPoints == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        ZeroMemory(m_pPoints, sizeof(POINTF) * m_lPointCount);
    }
    
    hr = S_OK;

  done:

    return hr;
}

HRESULT   
CTIMEPath::SetAbsolute(bool bMode)
{
    m_bAbsoluteMode = bMode;
    return S_OK;
}

HRESULT   
CTIMEPath::SetPoints (long index, POINTF point)
{
    HRESULT hr = E_FAIL;

    if (index < 0 || 
        index > m_lPointCount - 1)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_pPoints == NULL)
    {
        goto done;
    }

    m_pPoints[index].x = point.x;
    m_pPoints[index].y = point.y;
    
    hr = S_OK;

  done:

    return hr;
}

POINTF *
CTIMEPath::GetPoints()
{
    POINTF *pTemp = NULL;
  
    if (m_lPointCount == 0)
    {
        goto done;
    }

    pTemp = NEW POINTF [m_lPointCount];
    
    if (pTemp == NULL)
    {
        goto done;
    }

    if (m_pPoints != NULL)
    {
        memcpy(pTemp, m_pPoints, sizeof(POINTF) * m_lPointCount);
    }

  done:
    return pTemp;
}

HRESULT 
CTIMEParser::ParsePlayList(CPlayList *pPlayList, bool fOnlyHeader, std::list<LPOLESTR> *asxList)
{
    HRESULT hr = E_FAIL;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL, curTag = NULL;
    LPOLESTR pszTemp = NULL, pTagStr = NULL;
    bool fHeader = true;
    bool fEntry = false;
    bool fGetTagString = false;
    bool fTokenFound;
    TokenList tokenList;
    CComPtr<CPlayItem> pPlayItem;
    bool fCanSkip = true;

    TokenList vtokenList;
    StringList valueList;
    bool fClosed = false;

    if (pPlayList)
    {
        pPlayList->AddRef();
    }
    
    if (m_hrLoadError != S_OK)
    {
        hr = m_hrLoadError;
        goto done;
    }

    curToken = m_Tokenizer->TokenType();

    while( curToken == TT_Space) //Get rid off leading spaces
    {
        m_Tokenizer->NextToken();
        curToken = m_Tokenizer->TokenType();
    }

    if (curToken != TT_Less)
    {
        hr = E_FAIL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        goto done;
    }

    if (tempToken != ASX_TOKEN)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    while(((curToken = m_Tokenizer->NextToken()) != TT_EOF) && curToken != TT_Greater);
    if(curToken == EOF)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    
    if(curToken != TT_Greater)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    if(fOnlyHeader)
    {
        goto done;
    }

    tokenList.push_front(tempToken);

    for(;;)
    {
        FreeStrings(valueList);
        valueList.clear();
        vtokenList.clear();

        if(!fGetTagString)
        {
            curToken = m_Tokenizer->NextToken();
        }
        else
        {
            //if(!m_Tokenizer->FetchStringToChar(_T('<')))
            if(!m_Tokenizer->FetchStringToString(L"</"))
            {
                hr = E_FAIL;
                tempToken = NULL;
                goto done;
            }
            if(pTagStr)
            {
                delete [] pTagStr;
                pTagStr = NULL;
            }

            pTagStr = m_Tokenizer->GetTokenValue();

            fGetTagString = false;
            continue;
        }
        if(curToken == TT_EOF)
        {
            if(tokenList.empty())
            {
                hr = S_OK;
                goto done;
            }
            hr = E_FAIL;
            goto done;
        }

        if(curToken == TT_Less)
        {
            //open tag
            curToken = m_Tokenizer->NextToken();

            if(curToken == TT_ForwardSlash)
            {
                //close tag
                curToken = m_Tokenizer->NextToken();
                if(curToken != TT_Identifier)
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }

                hr = ParseToken(&tempToken);
                if (FAILED(hr))
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }

                if(tokenList.empty() || (tempToken != tokenList.front()))
                {
                    hr = E_FAIL;
                    tempToken = tokenList.front();
                    goto done;
                }

                tokenList.pop_front();

                curToken = m_Tokenizer->NextToken();
                if(curToken != TT_Greater)
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
                TraceTag((tagTimeParser, "Closing <%S>", (TCHAR *)tempToken));

                if(tempToken == ENTRY_TOKEN)
                {
                    fEntry = false;
                    pPlayItem.Release();
                }
                else
                {
                    if(fEntry)
                    {
                        ProcessTag(tempToken, pTagStr, pPlayItem);
                    }
                    if(pTagStr != NULL)
                    {
                        delete [] pTagStr;
                        pTagStr = NULL;
                    }
                }

                //Process the tag.
                continue;
            }

            if(curToken != TT_Bang)
            {
                if(curToken != TT_Identifier)
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
    
                hr = ParseToken(&tempToken);
                if (FAILED(hr))
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
            }
            else
            {
                hr = IgnoreValueTag();
                if(FAILED(hr))
                {
                    hr = E_FAIL;
                    goto done;
                }
                continue;
            }

            curTag = tempToken;
            TraceTag((tagTimeParser, "Opening <%S>", (TCHAR *)curTag));

            hr = ProcessValueTag(tempToken, pPlayItem, tokenList.front(), fTokenFound, asxList, &tokenList);
            if(FAILED(hr))
            {
                goto done;
            }
            if(fTokenFound)
            {
                continue;
            }

            IGNORE_HR(GetTagParams(&vtokenList, &valueList, fClosed));

            if(curTag == ENTRY_TOKEN)
            {
                pTagStr = FindTokenValue(CLIENTSKIP_TOKEN, vtokenList, valueList);
                if(pTagStr != NULL)
                {
                    if(StrCmpIW(pTagStr, L"No") == 0)
                    {
                        fCanSkip = false;
                    }
                }

                //create new play item
                if(fEntry) // do not allow nested entries.
                {
                    hr = E_FAIL;
                    tempToken = NULL;
                    goto done;
                }
                tokenList.push_front(curTag);
                fEntry = true;
                hr = THR(pPlayList->CreatePlayItem(&pPlayItem));
                if (FAILED(hr))
                {
                    goto done; //can't create playitems.
                }
                IGNORE_HR(pPlayList->Add(pPlayItem, -1));
                pPlayItem->PutCanSkip(fCanSkip);
                fCanSkip = true;
                continue;
            }

            if(curTag == REPEAT_TOKEN)
            {
                tokenList.push_front(curTag);
                continue;
            }

            if((curTag == AUTHOR_TOKEN) ||
               (curTag == TITLE_TOKEN) ||
               (curTag == ABSTRACT_TOKEN) ||
               (curTag == COPYRIGHT_TOKEN) ||
               (curTag == BANNER_TOKEN) ||
               (curTag == TITLE_TOKEN) ||
               (curTag == INVALID_TOKEN))
            {
                //create new play item
                tokenList.push_front(curTag);
                if(curTag != INVALID_TOKEN)
                {
                    fGetTagString = true;
                }
                continue;
            }

        }

        if(curToken == TT_Identifier || curToken == TT_String)
        {
                pszTemp = m_Tokenizer->GetTokenValue();

                delete [] pszTemp;
        }

        if(curToken == TT_Number)
        {
                pszTemp = m_Tokenizer->GetNumberTokenValue();

                delete [] pszTemp;
        }
    }

done:
    if (pPlayList)
    {
        pPlayList->Release();
    }

    return hr;
}

HRESULT
CTIMEParser::GetTagParams(TokenList *tokenList, StringList *valueList, bool &fClosed)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown;
    TOKEN tempToken = NULL;
    unsigned char  iPos = 1;
    bool fdone = false;
    bool fKeepString = false;
    LPOLESTR pTagStr = NULL;
    
    while(!fdone)
    {
        curToken = m_Tokenizer->NextToken();
        hr = ParseToken(&tempToken);
        if (FAILED(hr))
        {
            goto done;
        }

        if(iPos == 4)
        {
            if(curToken == TT_Identifier)
            {
                iPos = 1;
            }
        }
        switch(iPos)
        {
            case 1:
            {
                // State 1 checks for the identifiier
                if(curToken == TT_ForwardSlash)
                {
                    iPos = 5;
                    break;
                }
                if(curToken == TT_Greater)
                {
                    goto done;
                }

                if(curToken == TT_Identifier)
                {
                    if(tempToken != INVALID_TOKEN)
                    {
                        tokenList->push_back(tempToken);
                        fKeepString = true;
                    }
                    iPos++;
                    break;
                }

                hr = E_FAIL;
                fdone = true;
                break;
            }
            case 2:
            {
                // After identifier we have either another identifier or an equal
                if(curToken == TT_Identifier)
                {
                    if(fKeepString)
                    {
                        valueList->push_back(NULL);
                        fKeepString = false;
                    }
                    if(tempToken != INVALID_TOKEN)
                    {
                        tokenList->push_back(tempToken);
                        fKeepString = true;
                    }
                    iPos = 2;
                    break;
                }

                if(curToken != TT_Equal)
                {
                    hr = E_FAIL;
                    fdone = true; 
                    break;
                }
                iPos++;
                break;
            }
            case 3:
            {
                // After an equal we should find a string
                if(curToken != TT_String)
                {
                    hr = E_FAIL;
                    fdone = true;
                    break;
                }

                if(fKeepString)
                {
                    pTagStr = m_Tokenizer->GetTokenValue();
                    valueList->push_back(pTagStr);
                    fKeepString = false;
                }

                iPos++;
                break;
            }
            case 4:
            {
                // Check for correct prameter list termination
                if(curToken == TT_Greater)
                {
                    hr = S_OK;
                    fdone = true;
                    fClosed = false;
                    break;
                }
                else if(curToken == TT_ForwardSlash)
                {
                    iPos++;
                    break;
                }

                hr = E_FAIL;
                fdone = true;
            }
            case 5:
            {
                if(curToken == TT_Greater)
                {
                    hr = S_OK;
                    fClosed = true;
                }
                else
                {
                    hr = E_FAIL;
                }
                fdone = true;
            }
        }
    }
done:
    return hr;
}

HRESULT 
CTIMEParser::ProcessTag(TOKEN tempToken, LPOLESTR pszTemp, CPlayItem *pPlayItem)
{
    HRESULT hr = S_OK;

    if (pPlayItem == NULL)
    {
        goto done;
    }

    if(pszTemp == NULL)
    {
        goto done;
    }

    if(tempToken == AUTHOR_TOKEN)
    {
        TraceTag((tagTimeParser, "  Author:<%S>", pszTemp));
        pPlayItem->PutAuthor(pszTemp);
        goto done;
    }

    if(tempToken == TITLE_TOKEN)
    {
        TraceTag((tagTimeParser, "  Title:<%S>", pszTemp));
        pPlayItem->PutTitle(pszTemp);
        goto done;
    }
    
    if(tempToken == ABSTRACT_TOKEN)
    {
        TraceTag((tagTimeParser, "  Abstract:<%S>", pszTemp));
        pPlayItem->PutAbstract(pszTemp);
        goto done;
    }
    
    if(tempToken == COPYRIGHT_TOKEN)
    {
        TraceTag((tagTimeParser, "  Copyright:<%S>", pszTemp));
        pPlayItem->PutCopyright(pszTemp);
        goto done;
    }

    if(tempToken == HREF_TOKEN)
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEParser::IgnoreValueTag()
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 

    while(((curToken = m_Tokenizer->NextToken()) != TT_EOF) && curToken != TT_Greater);
    if(curToken == EOF)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

void
CTIMEParser::TestForValueTag(TOKEN token, TOKEN parentToken, bool &ffound, bool &fparentOk)
{
    int i, j;
    ffound = false;
    fparentOk = false;

    for( i = 0; (g_parentTable[ i].tagToken != NULL) && !fparentOk; i++)
    {
        if(token != g_parentTable[ i].tagToken)
        {
            continue;
        }
        ffound = true;

        for( j = 0; (j < g_parentTable[ i].listLen) && !fparentOk; j++)
        {
            if(g_parentTable[ i].allowedParents[ j] == parentToken)
            {
                fparentOk = true;
            }
        }
    }

}

bool
CTIMEParser::IsAsxTagToken(TOKEN token)
{
    bool fIsAsxTag = false;
    int i = 0;

    for(i = 0; (g_AsxTags[i] != NULL) && !fIsAsxTag; i++)
    {
        if(g_AsxTags[i] == token)
        {
            fIsAsxTag = true;
        }
    }

    return fIsAsxTag;
}

HRESULT
CTIMEParser::ProcessValueTag(TOKEN token, CPlayItem *pPlayItem, TOKEN parentToken, bool &ffound, std::list<LPOLESTR> *asxList, TokenList *ptokenList)
{
    HRESULT hr = S_OK;
    bool fparentOk = false;
    TokenList tokenList;
    StringList valueList;
    bool fClosed = false;
    bool fIsAsx = true;

    TestForValueTag(token, parentToken, ffound, fparentOk);
    if(!ffound)
    {
        fIsAsx = IsAsxTagToken(token);
        if(!fIsAsx)
        {
            hr = GetTagParams(&tokenList, &valueList, fClosed);
            FreeStrings(valueList);
            if(FAILED(hr))
            {
                goto done;
            }

            if(!fClosed)
            {
                ptokenList->push_front(token);
            }
            ffound = true;
        }
        goto done;
    }

    if(!fparentOk)
    {
        hr = E_FAIL;
        goto done;
    }

    if(token == REF_TOKEN)
    {
        hr = ProcessRefTag(pPlayItem);
    }
    else if(token == ENTRYREF_TOKEN)
    {
        hr = ProcessEntryRefTag(asxList);
    }
    else if(token == BANNER_TOKEN)
    {
        hr = ProcessBannerTag(pPlayItem);
    }
    else if(token == MOREINFO_TOKEN)
    {
        hr = GetTagParams(&tokenList, &valueList, fClosed);
        if(FAILED(hr))
        {
            goto done;
        }
        FreeStrings(valueList);
        if(!fClosed)
        {
            hr = IgnoreValueTag();
        }
    }
    else if(token == BASE_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == LOGO_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == PARAM_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == PREVIEWDURATION_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == STARTTIME_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == STARTMARKER_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == ENDTIME_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == ENDMARKER_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else if(token == DURATION_TOKEN)
    {
        hr = IgnoreValueTag();
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

HRESULT
CTIMEParser::ProcessRefTag(CPlayItem *pPlayItem)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL, curTag = NULL;
    LPOLESTR pszTemp =NULL;
    LPOLESTR pszModified = NULL;

    TokenList tokenList;
    StringList valueList;
    bool fClosed = false;

    hr = GetTagParams(&tokenList, &valueList, fClosed);

    pszTemp = FindTokenValue(HREF_TOKEN, tokenList, valueList);
    FreeStrings(valueList);

    if(pszTemp == NULL)
    {
        goto done;
    }

    TraceTag((tagTimeParser, "  HREF:<%S>", pszTemp));
    pPlayItem->PutSrc(pszTemp);

done:
    delete [] pszTemp;

    return hr;
}

HRESULT
CTIMEParser::ProcessBannerTag(CPlayItem *pPlayItem)
{
    bool bClosed = false;
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;    
    LPOLESTR pszBanner = NULL;
    LPOLESTR pszAbstract = NULL;
    LPOLESTR pszMoreInfo = NULL;
    LPOLESTR pszModified = NULL;
    TokenList tokenList;
    StringList valueList;

    hr = GetTagParams(&tokenList, &valueList, bClosed);
    if(FAILED(hr))
    {
        goto done;
    }

    pszBanner = FindTokenValue(HREF_TOKEN, tokenList, valueList);
    FreeStrings(valueList);

    if(pszBanner == NULL)
    {
        goto done;
    }

    //handle other tags inside banner.
    while (!bClosed)
    {
        curToken = m_Tokenizer->NextToken();
        if (curToken != TT_Less)
        {
            hr = E_FAIL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();

        if (curToken == TT_ForwardSlash)
        {
            curToken = m_Tokenizer->NextToken();
            if (curToken != TT_Identifier)
            {
                hr = E_FAIL;
                goto done;
            }
            hr = ParseToken(&tempToken);
            if (tempToken != BANNER_TOKEN)
            {
                hr = E_FAIL;
                goto done;
            }
            curToken = m_Tokenizer->NextToken();
            if (curToken != TT_Greater)
            {
                hr = E_FAIL;
                goto done;
            }
            bClosed = true;
        }
        else
        {
            hr = ParseToken(&tempToken);
            if (FAILED(hr))
            {
                goto done;
            }

            if (tempToken == MOREINFO_TOKEN)
            {
                pszMoreInfo = ProcessMoreInfoTag();
            }
            else if (tempToken == ABSTRACT_TOKEN)
            {
                pszAbstract = ProcessAbstractTag();    
            }
            else
            {
                hr = E_FAIL;
                goto done;
            }
        }
    }

    TraceTag((tagTimeParser, "  Banner:<%S>", pszBanner));
    if (bClosed && (pPlayItem != NULL))
    {
        hr = S_OK;
        pPlayItem->PutBanner(pszBanner, pszAbstract, pszMoreInfo);
        goto done;
    }

done:

    delete [] pszBanner;
    delete [] pszAbstract;
    delete [] pszMoreInfo;
    pszBanner = NULL;
    pszAbstract = NULL;
    pszMoreInfo = NULL;

    return hr;
}

LPOLESTR 
CTIMEParser::ProcessMoreInfoTag()
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp =NULL;
    LPOLESTR pszModified = NULL;
    TokenList tokenList;
    StringList valueList;
    bool fClosed = false;

    hr = GetTagParams(&tokenList, &valueList, fClosed);

    pszTemp = FindTokenValue(HREF_TOKEN, tokenList, valueList);
    FreeStrings(valueList);

    if(pszTemp == NULL)
    {
        goto done;
    }

done:

    return pszTemp;
}

LPOLESTR
CTIMEParser::FindTokenValue(TOKEN token, TokenList &tokenList, StringList &valueList)
{
    TokenList::iterator iToken;
    StringList::iterator iString;
    LPOLESTR pRetStr = NULL;

    if(tokenList.size() != valueList.size())
    {
        return NULL;
    }
    for(iToken = tokenList.begin(), iString = valueList.begin();
        iToken != tokenList.end(); iToken++, iString++)
        {
            if((*iToken) == token)
            {
                pRetStr = new TCHAR[lstrlen((*iString)) + 1];
                StrCpyW(pRetStr, (*iString));
                break;
            }
        }

    return pRetStr;
}

void
CTIMEParser::FreeStrings(StringList &valueList)
{
    StringList::iterator iString;

    for(iString = valueList.begin(); iString != valueList.end(); iString++)
    {
        if((*iString) != NULL)
        {
            delete [] (*iString);
            (*iString) = NULL;
        }
    }
}

HRESULT
CTIMEParser::ProcessHREF(LPOLESTR *pszTemp)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;

    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Identifier)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }
    if(tempToken != HREF_TOKEN)
    {
        hr = E_FAIL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Equal)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_String)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    *pszTemp = m_Tokenizer->GetTokenValue();

  done:

    return hr;

}

LPOLESTR 
CTIMEParser::ProcessAbstractTag()
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp = NULL;
    LPOLESTR pszModified = NULL;

    curToken = m_Tokenizer->NextToken();

    if (curToken != TT_Greater)
    {
        hr = E_FAIL;
        goto done;
    }

    if(!m_Tokenizer->FetchStringToString(L"</"))
    {
        hr = E_FAIL;
        goto done;
    }

    pszTemp = m_Tokenizer->GetTokenValue();

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Less)
    {
        hr = E_FAIL;
        goto done;
    }
    
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_ForwardSlash)
    {
        hr = E_FAIL;
        goto done;
    }

    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Identifier)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    if(tempToken != ABSTRACT_TOKEN)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    
    curToken = m_Tokenizer->NextToken();
    if (curToken != TT_Greater)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        delete [] pszTemp;
        pszTemp = NULL;
    }
    return pszTemp;
}

HRESULT
CTIMEParser::ProcessEntryRefTag(std::list<LPOLESTR> *asxList)
{
    HRESULT hr = S_OK;
    TIME_TOKEN_TYPE curToken = TT_Unknown; 
    TOKEN tempToken = NULL;
    LPOLESTR pszTemp =NULL;
    LPOLESTR pszModified = NULL;
    bool fBind = false;
    LPOLESTR pTagStr = NULL;

    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Identifier)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    hr = ParseToken(&tempToken);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    if(tempToken != HREF_TOKEN)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Equal)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_String)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    pszTemp = m_Tokenizer->GetTokenValue();
    // This is the play item source

    curToken = m_Tokenizer->NextToken();

    if(curToken == TT_Identifier)
    {
        hr = ParseToken(&tempToken);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        if(tempToken != CLIENTBIND_TOKEN)
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();
        if(curToken != TT_Equal)
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        curToken = m_Tokenizer->NextToken();
        if(curToken != TT_String)
        {
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }
        pTagStr = m_Tokenizer->GetTokenValue();

        if(StrCmpIW(pTagStr, L"Yes") == 0)
        {
            fBind = true;
        }
        else if(StrCmpIW(pTagStr, L"No") == 0)
        {
            fBind = false;
        }
        else
        {
            delete [] pTagStr;
            pTagStr = NULL;
            hr = E_FAIL;
            tempToken = NULL;
            goto done;
        }

        delete [] pTagStr;
        pTagStr = NULL;

        curToken = m_Tokenizer->NextToken();
    }


    if(curToken != TT_ForwardSlash)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }
    curToken = m_Tokenizer->NextToken();
    if(curToken != TT_Greater)
    {
        hr = E_FAIL;
        tempToken = NULL;
        goto done;
    }

    TraceTag((tagTimeParser, "  HREF:<%S>", pszTemp));
    if(asxList != NULL)
    {
        asxList->push_front(pszTemp);
    }

done:

    return hr;
}


HRESULT 
CTIMEParser::ParseTransitionTypeAndSubtype (VARIANT *pvarType, VARIANT *pvarSubtype)
{
    HRESULT hr = S_OK;

    if ((NULL == pvarType) || (NULL == pvarSubtype))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    {
        // Expected format is "typename:subtypename"
        LPOLESTR wzValue = m_Tokenizer->GetTokenValue();
        TIME_TOKEN_TYPE curToken = m_Tokenizer->NextToken();

        ::VariantClear(pvarType);
        ::VariantClear(pvarSubtype);

        if (NULL != wzValue)
        {
            V_VT(pvarType) = VT_BSTR;
            V_BSTR(pvarType) = ::SysAllocString(wzValue);
            delete [] wzValue;
            wzValue = NULL;
        }

        Assert(TT_Colon == curToken);
        curToken = m_Tokenizer->NextToken();

        if (TT_EOF != curToken)
        {
            wzValue = m_Tokenizer->GetTokenValue();
            if (NULL != wzValue)
            {
                V_VT(pvarSubtype) = VT_BSTR;
                V_BSTR(pvarSubtype) = ::SysAllocString(wzValue);
                delete [] wzValue;
                wzValue = NULL;
            }
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // ParseTransitionTypeAndSubtype
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\timevalue.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timevalue.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------



#include "headers.h"
#include "timevalue.h"

DeclareTag(tagTimeValue, "TIME: Time Value", "TimeValue methods");

TimeValue::TimeValue(LPWSTR Element,
                     LPWSTR Event,
                     double Offset)
: m_pwszElm(Element),
  m_pwszEv(Event),
  m_dblOffset(Offset)
{
}

TimeValue::TimeValue()
: m_pwszElm(NULL),
  m_pwszEv(NULL),
  m_dblOffset(0.0)
{
}

TimeValue::TimeValue(const TimeValue & tv)
: m_pwszElm(NULL),
  m_pwszEv(NULL),
  m_dblOffset(0.0)
{
    Copy(tv);
}
    
TimeValue::~TimeValue()
{
    Clear();
}

void
TimeValue::Clear()
{
    delete [] m_pwszElm;
    m_pwszElm = NULL;
    
    delete [] m_pwszEv;
    m_pwszEv = NULL;

    m_dblOffset = 0.0;
}
    
HRESULT
TimeValue::Copy(const TimeValue & tv)
{
    return Set(tv.GetElement(),
               tv.GetEvent(),
               tv.GetOffset());
}

HRESULT
TimeValue::Set(LPWSTR Element,
               LPWSTR Event,
               double Offset)
{
    Clear();

    m_pwszElm = Element?CopyString(Element):NULL;
    m_pwszEv = Event?CopyString(Event):Event;
    m_dblOffset = Offset;

    return S_OK;
}

TimeValueList::TimeValueList()
{
}

TimeValueList::~TimeValueList()
{
    Clear();
}

void
TimeValueList::Clear()
{
    for (TimeValueSTLList::iterator i = m_tvlList.begin();
         i != m_tvlList.end();
         i++)
    {
        delete (*i);
    }

    m_tvlList.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\loader.cpp ===
// loader.cpp 
//
// (c) 1999 Microsoft Corporation.
//
#include "headers.h"
#include <objbase.h>
#include <initguid.h>
#include "loader.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "wininet.h"

// Need this #define because global headers use some of the deprecated functions. Without this
// #define, we can't build unless we touch code everywhere.
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"
#undef STRSAFE_NO_DEPRECATE

extern CComPtr<IBindStatusCallback> g_spLoaderBindStatusCallback;

//  NEED_GM_SET causes the default GM set to be loaded by the CLoader.Init() call.
DeclareTag(tagDMLoader, "TIME: DMLoader", "DMLoader methods");

#define NEED_GM_SET

#define AUDIOVBSCRIPT_TEXT L"AudioVBScript"
#define AUDIOVBSCRIPT_LEN (sizeof(AUDIOVBSCRIPT_TEXT)/sizeof(wchar_t))

bool IsAudioVBScriptFile( IStream *pStream )
{
    bool fResult = false;

    // Validate pStream
    if (pStream == NULL)
    {
        return false;
    }

    // Clone pStream
    IStream *pStreamClone = NULL;
    if (SUCCEEDED( pStream->Clone( &pStreamClone ) ) && pStreamClone)
    {
        // Read in the RIFF header to verify that this is a script file and to get the length of the main RIFF chunk
        ULONG lScriptLength = 0;
        DWORD dwHeader[3];
        DWORD dwRead = 0;
        if (SUCCEEDED( pStreamClone->Read( dwHeader, sizeof(DWORD) * 3, &dwRead ) )
        &&  (dwRead == sizeof(DWORD) * 3)
        &&  (dwHeader[0] == FOURCC_RIFF) // RIFF header
        &&  (dwHeader[1] >= sizeof(DWORD)) // Size is valid
        &&  (dwHeader[2] == DMUS_FOURCC_SCRIPT_FORM)) // Script form
        {
            // Store the script chunk's length
            // Need to subtract off the DMUS_FOURCC_SCRIPT_FORM data, since it's considered part of the RIFF chunk
            lScriptLength = dwHeader[1] - sizeof(DWORD);
            WCHAR wcstr[AUDIOVBSCRIPT_LEN];
    
            // Now, search for the DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK chunk

            // Continue while there is enough data in the chunk to read another chunk header
            while (lScriptLength > sizeof(DWORD) * 2)
            {
                DWORD dwHeader[2];
                DWORD dwRead = 0;
                if (FAILED( pStreamClone->Read( dwHeader, sizeof(DWORD) * 2, &dwRead ) )
                ||  (dwRead != sizeof(DWORD) * 2)
                ||  ((lScriptLength - sizeof(DWORD) * 2) < dwHeader[1]))
                {
                    break;
                }
                else
                {
                    // Subtract off the size of this chunk
                    lScriptLength -= sizeof(DWORD) * 2 + dwHeader[1];

                    // Check if this is the language chunk
                    if (dwHeader[0] == DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK)
                    {
                        // Chunk must be exactly the length of "AudioVBScript" plus a NULL
                        if (dwHeader[1] != sizeof(WCHAR) * AUDIOVBSCRIPT_LEN)
                        {
                            break;
                        }
                        else
                        {
                            // Read the string
                            if (FAILED( pStreamClone->Read( wcstr, sizeof(WCHAR) * AUDIOVBSCRIPT_LEN, &dwRead ) )
                            ||  (dwRead != dwHeader[1]))
                            {
                                break;
                            }
                            else
                            {
                                // Compare the strings
                                if (memcmp( wcstr, AUDIOVBSCRIPT_TEXT, sizeof(WCHAR) * AUDIOVBSCRIPT_LEN ) != 0)
                                {
                                    // Not Audio VBScript - fail
                                    break;
                                }
                                else
                                {
                                    // Is Audio VBScript - succeed
                                    fResult = true;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Not the language chunk - skip it
                        LARGE_INTEGER li;
                        li.QuadPart = dwHeader[1];
                        if (FAILED( pStreamClone->Seek( li, STREAM_SEEK_CUR, NULL ) ))
                        {
                            break;
                        }
                    }
                }
            }
        }

        pStreamClone->Release();
    }

    return fResult;
}

CFileStream::CFileStream( CLoader *pLoader)

{
    m_cRef = 1;         // Start with one reference for caller.
    m_pFile = INVALID_HANDLE_VALUE;       // No file yet.
    m_pLoader = pLoader; // Link to loader, so loader can be found from stream.
    if (pLoader)
    {
        pLoader->AddRefP(); // Addref the private counter to avoid cyclic references.
    }
}

CFileStream::~CFileStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
        m_pLoader = NULL;
    }
    Close();
}

HRESULT CFileStream::Open(WCHAR * lpFileName,DWORD dwDesiredAccess)

{
    Close();

    // Store the filename
    HRESULT hr = StringCbCopy(m_wszFileName, sizeof(m_wszFileName), lpFileName);

    // Don't open the file if we had to truncate the name, or we will open a different
    // file than the one we were asked to open. In that case, m_pFile doesn't need
    // to be cleared because the call to Close() above takes care of that
    if(SUCCEEDED(hr))
    {
        if( dwDesiredAccess == GENERIC_READ )
        {
            m_pFile = CreateFileW(lpFileName, 
                                    GENERIC_READ, 
                                    FILE_SHARE_READ, 
                                    NULL, 
                                    OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);
        }
        else if( dwDesiredAccess == GENERIC_WRITE )
        {
            m_pFile = CreateFileW(lpFileName, 
                                    GENERIC_WRITE, 
                                    0, 
                                    NULL, 
                                    CREATE_ALWAYS, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);
        }
    }

    if (m_pFile == INVALID_HANDLE_VALUE)
    {
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
} //lint !e550

HRESULT CFileStream::Close()

{
    if (m_pFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_pFile);
        m_pFile = INVALID_HANDLE_VALUE;
    }
    return S_OK;
}

STDMETHODIMP CFileStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/*  The GetLoader interface is used to find the loader from the IStream.
    When an object is loading data from the IStream via the object's
    IPersistStream interface, it may come across a reference chunk that
    references another object that also needs to be loaded. It QI's the
    IStream for the IDirectMusicGetLoader interface. It then uses this
    interface to call GetLoader and get the actual loader. Then, it can
    call GetObject on the loader to load the referenced object.
*/

STDMETHODIMP CFileStream::GetLoader(
    IDirectMusicLoader ** ppLoader) // Returns an AddRef'd pointer to the loader.

{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CFileStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    DWORD dw;
    BOOL bRead = false;
    HRESULT hr = E_FAIL;

    bRead = ReadFile(m_pFile, pv, cb, &dw, NULL);
    //dw = fread( pv, sizeof(char), cb, m_pFile );
    //if ( cb == dw )
    if (bRead)
    {
        if( pcbRead != NULL )
        {
            *pcbRead = dw;
        }
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        hr = E_FAIL;
    }
    return hr ;
}

STDMETHODIMP CFileStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    DWORD dw = 0;
    BOOL bWrite = false;
    HRESULT hr = STG_E_MEDIUMFULL;

    //if( cb == fwrite( pv, sizeof(char), cb, m_pFile ))
    bWrite = WriteFile (m_pFile, pv, cb, &dw, NULL);
    if (bWrite && cb == dw) 
    {
        if( pcbWritten != NULL )
        {
            *pcbWritten = cb;
        }
        hr = S_OK;
    }
    if (FAILED(hr))
    {
        hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CFileStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // fseek can't handle a LARGE_INTEGER seek...
    DWORD dwReturn = 0;
    DWORD dwMoveMethod = 0;
    HRESULT hr = E_FAIL;

    //convert the incoming parameter to the correct value
    if (dwOrigin == SEEK_SET)
    {
        dwMoveMethod = FILE_BEGIN;
    }
    else if (dwOrigin == SEEK_CUR)
    {
        dwMoveMethod = FILE_CURRENT;
    }
    else if (dwOrigin == SEEK_END)
    {
        dwMoveMethod = FILE_END;
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    //int i = fseek( m_pFile, lOffset, dwOrigin );
    //if( i ) 
    //{
    //  return E_FAIL;
    //}

    dwReturn = SetFilePointer(m_pFile, dlibMove.LowPart, &dlibMove.HighPart, dwMoveMethod);
    if (dwReturn == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
    {
        hr = E_FAIL;
        goto done;
    }

    if( plibNewPosition != NULL )
    {
        plibNewPosition->LowPart = dwReturn;
        plibNewPosition->HighPart = dlibMove.HighPart;
    }

    hr = S_OK;

    done:
    if (FAILED(hr))
    {
        hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CFileStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Clone( IStream** ppstm )
{ 
    // Create a new CFileStream
    HRESULT hr = E_OUTOFMEMORY;
    CFileStream *pNewStream = new CFileStream( m_pLoader );
    if (pNewStream)
    {
        // Try and open the file again
        hr = pNewStream->Open(m_wszFileName,GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            // Get our current position 
            LARGE_INTEGER   dlibMove;
            dlibMove.QuadPart = 0;
            ULARGE_INTEGER  libNewPosition;
            hr = Seek( dlibMove, STREAM_SEEK_CUR, &libNewPosition );
            if (SUCCEEDED(hr))
            {
                // Seek to the same position in the new pNewStream
                dlibMove.QuadPart = libNewPosition.QuadPart;
                hr = pNewStream->Seek(dlibMove,STREAM_SEEK_SET,NULL);
                if (SUCCEEDED(hr))
                {
                    // Finally, assign the new file stream to ppstm
                    *ppstm = pNewStream;
                }
            }
        }

        if( FAILED(hr) )
        {
            pNewStream->Release();
            pNewStream = NULL; //lint !e423  This is no leak because the Release handles the delete
        }
    }
	return hr; 
}


CMemStream::CMemStream( CLoader *pLoader)

{
    m_cRef = 1;
    m_pbData = NULL;
    m_llLength = 0;
    m_llPosition = 0;
    m_pLoader = pLoader;
    if (pLoader)
    {
        pLoader->AddRefP();
    }
}

CMemStream::~CMemStream() 

{ 
    if (m_pLoader)
    {
        m_pLoader->ReleaseP();
    }
    m_pbData = NULL;
    m_pLoader = NULL;
        
    Close();
}

HRESULT CMemStream::Open(BYTE *pbData, LONGLONG llLength)

{
    Close();
    m_pbData = pbData;
    m_llLength = llLength;
    m_llPosition = 0;
    if ((pbData == NULL) || (llLength == 0))
    {
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    if (IsBadReadPtr(pbData, (DWORD) llLength))
    {
        m_pbData = NULL;
        m_llLength = 0;
        return DMUS_E_LOADER_FAILEDOPEN;
    }
    return S_OK;
}

HRESULT CMemStream::Close()

{
    m_pbData = NULL;
    m_llLength = 0;
    return S_OK;
}

STDMETHODIMP CMemStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP CMemStream::GetLoader(
    IDirectMusicLoader ** ppLoader) 

{
    if (m_pLoader)
    {
        return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
    }
    *ppLoader = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMemStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMemStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CMemStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    if ((cb + m_llPosition) <= m_llLength)
    {
        memcpy(pv,&m_pbData[m_llPosition],cb);
        m_llPosition += cb;
        if( pcbRead != NULL )
        {
            *pcbRead = cb;
        }
        return S_OK;
    }
    return E_FAIL ;
}

STDMETHODIMP CMemStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // Since we only parse RIFF data, we can't have a file over 
    // DWORD in length, so disregard high part of LARGE_INTEGER.

    LONGLONG llOffset;

    llOffset = dlibMove.QuadPart;
    if (dwOrigin == STREAM_SEEK_CUR)
    {
        llOffset += m_llPosition;
    } 
    else if (dwOrigin == STREAM_SEEK_END)
    {
        llOffset += m_llLength;
    }
    if ((llOffset >= 0) && (llOffset <= m_llLength))
    {
        m_llPosition = llOffset;
    }
    else return E_FAIL;

    if( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = m_llPosition;
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Revert()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Clone( IStream** ppstm )
{ 
    // Create a new CMemStream
    HRESULT hr = E_OUTOFMEMORY;
    CMemStream *pMemStream = new CMemStream( m_pLoader );
    if (pMemStream)
    {
        // Open the same memory location
        hr = pMemStream->Open( m_pbData, m_llLength );
        if (SUCCEEDED(hr))
        {
            // Set the new stream to the same position
            pMemStream->m_llPosition = m_llPosition;
            *ppstm = pMemStream;
            hr = S_OK;
        }

        if (FAILED(hr))
        {
            pMemStream->Release();
            pMemStream = NULL; //lint !e423  This is no leak because the Release handles the delete
        }
    }
    return hr; 
}


CLoader::CLoader()

{
    InitializeCriticalSection(&m_CriticalSection);
    m_cRef = 1;
    m_cPRef = 0;
    m_pObjectList = NULL;
    m_bstrSrc = NULL;
}

CLoader::~CLoader()

{
    CLoader::ClearCache(GUID_DirectMusicAllTypes);
    if (m_bstrSrc)
    {
        SysFreeString(m_bstrSrc);
        m_bstrSrc = NULL;
    }
    
    DeleteCriticalSection(&m_CriticalSection);
    m_pObjectList = NULL;
}


HRESULT CLoader::Init()

{
    HRESULT hr = S_OK;

    // If support for the GM set is desired, create a direct music loader
    // and get the GM dls collection from it, then release that loader.
#ifdef NEED_GM_SET
    IDirectMusicLoader *pLoader;
    hr = CoCreateInstance(            
        CLSID_DirectMusicLoader,
        NULL,            
        CLSCTX_INPROC,             
        IID_IDirectMusicLoader,
        (void**)&pLoader); 
    if (SUCCEEDED(hr))
    {
        DMUS_OBJECTDESC ObjDesc;     
        IDirectMusicObject* pGMSet = NULL; 
        ObjDesc.guidClass = CLSID_DirectMusicCollection;
        ObjDesc.guidObject = GUID_DefaultGMCollection;
        ObjDesc.dwSize = sizeof(DMUS_OBJECTDESC);
        ObjDesc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT;
        hr = pLoader->GetObject( &ObjDesc,
                IID_IDirectMusicObject, (void**) &pGMSet );
        if (SUCCEEDED(hr))
        {
            CObjectRef *pRef = new CObjectRef();
            if (pRef)
            {
                pRef->m_guidObject = GUID_DefaultGMCollection;
                pRef->m_pNext = m_pObjectList;
                m_pObjectList = pRef;
                pRef->m_pObject = pGMSet;
                pGMSet->AddRef();
            }
            pGMSet->Release();
        }
        pLoader->Release();
    }
#endif
    return hr;
}

HRESULT
CLoader::GetSegment(BSTR bstrSrc, IDirectMusicSegment **ppSeg)
{
    if (m_bstrSrc)
    {
        SysFreeString(m_bstrSrc);
        m_bstrSrc = NULL;
    }
    m_bstrSrc = SysAllocString(bstrSrc);
    if (!m_bstrSrc)
    {
        return E_OUTOFMEMORY;
    }

    DMUS_OBJECTDESC ObjDesc;
    ObjDesc.guidClass = CLSID_DirectMusicSegment;
    ObjDesc.dwSize = sizeof(DMUS_OBJECTDESC);
    ObjDesc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;

    // find the filename
    const WCHAR *pwszSlash = NULL;
    for (const WCHAR *pwsz = m_bstrSrc; *pwsz; ++pwsz)
    {
        if (*pwsz == L'\\' || *pwsz == L'/')
        {
            pwszSlash = pwsz;
        }
    }

    if (!pwszSlash || wcslen(pwszSlash + 1) >= DMUS_MAX_NAME)
    {
        return E_INVALIDARG;
    }
    StringCbCopy(ObjDesc.wszFileName, sizeof(ObjDesc.wszFileName), pwszSlash + 1);

    return GetObject(&ObjDesc, IID_IDirectMusicSegment, reinterpret_cast<void**>(ppSeg));
}

// CLoader::QueryInterface
//
STDMETHODIMP
CLoader::QueryInterface(const IID &iid,
                                   void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicLoader) 
    {
        *ppv = static_cast<IDirectMusicLoader*>(this);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CLoader::AddRef
//
STDMETHODIMP_(ULONG)
CLoader::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CLoader::AddRefP()
{
    return InterlockedIncrement(&m_cPRef);
}

// CLoader::Release
//
STDMETHODIMP_(ULONG)
CLoader::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        InterlockedIncrement(&m_cRef);      // Keep streams from deleting loader.
        ClearCache(GUID_DirectMusicAllTypes);
        if (!InterlockedDecrement(&m_cRef))
        {
            if (!m_cPRef)
            {
                delete this;
                return 0;
            }
        }
    }
    return m_cRef;
}

ULONG CLoader::ReleaseP()
{
    if (!InterlockedDecrement(&m_cPRef)) 
    {
        if (!m_cRef)
        {
            delete this;
            return 0;
        }
    }
    return m_cPRef;
}

STDMETHODIMP CLoader::GetObject(
    LPDMUS_OBJECTDESC pDESC,    // Description of the requested object in <t DMUS_OBJECTDESC> structure.
    REFIID riid,                // The interface type to return in <p ppv>
    LPVOID FAR *ppv)            // Receives the interface on success.

{
    HRESULT hr = E_NOTIMPL;

    EnterCriticalSection(&m_CriticalSection);
    IDirectMusicObject * pIObject = NULL;

    // At this point, the loader should check with all the objects it already
    // has loaded. It should look for file name, object guid, and name.
    // In this case, we are being cheap and looking for only the object's
    // guid and its filename.  The GUID is guaranteed to be unique when
    // the file was created with DirectMusic Producer.  However, the same file
    // could be referenced on a web page multiple times by only its filename.
    // (Nobody would manually type a GUID into their HTML.)  Also there is a
    // problem with DirectX 6.1 and 7.0 that causes DLS collections not to
    // report their GUIDs.  So we also look for an object with matching filename.

    // If it sees that the object is already loaded, it should
    // return a pointer to that one and increment the reference.
    // It is very important to keep the previously loaded objects
    // "cached" in this way. Otherwise, objects, like DLS collections, will get loaded
    // multiple times with a very great expense in memory and efficiency!
    // This is primarily an issue when object reference each other. For
    // example, segments reference style and collection objects.

    CObjectRef * pObject = NULL;
    for (pObject = m_pObjectList;pObject;pObject = pObject->m_pNext)
    {
        if (pDESC->dwValidData & DMUS_OBJ_OBJECT && pObject->m_guidObject != GUID_NULL)
        {
            // We have the GUIDs of both objects so compare by GUID, which is most precise.
            // (If different objects have the same filename then GUIDs will be used to tell them apart.)
            if (pDESC->guidObject == pObject->m_guidObject)
                break;
        }
        else
        {
            // Compare the filenames.
            if ((pDESC->dwValidData & DMUS_OBJ_FILENAME || pDESC->dwValidData & DMUS_OBJ_FULLPATH) && 0 == _wcsicmp(pDESC->wszFileName, pObject->m_wszFileName))
                break;
        }
    }

    // If we found an object, and it has been loaded
    if (pObject && pObject->m_pObject)
    {
        // QI the object for the requested interface
        hr = pObject->m_pObject->QueryInterface( riid, ppv );
        LeaveCriticalSection(&m_CriticalSection);
        return hr;
    }

    // If we found an object, and it has not been loaded, it must have a valid IStream pointer in it
    // or have a valid filename
    if( pObject && (pObject->m_pStream == NULL) )
    {
        // Not supposed to happen
        LeaveCriticalSection(&m_CriticalSection);
        return E_FAIL;
    }

    // Try and create the requested object
    hr = CoCreateInstance(pDESC->guidClass,
    NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
    (void **) &pIObject);
    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CriticalSection);
        return hr;
    }

    // By default, flag that we created pObject
    bool fCreatedpObject = true;

    if( pObject )
    {
        // If we already found the object, just keep a pointer to the object
        pObject->m_pObject = pIObject;
        pIObject->AddRef();

        // Flag that we didn't create pObject
        fCreatedpObject = false;
    }
    else
    {
        // Create a new object to store in the list
        pObject = new CObjectRef;
        if (pObject)
        {
            // Get the filename from the descriptor that was used to load the object.  This assures that
            // the file can be found in the cache with just a filename.  For example, a second player that
            // requests the same segment won't have its GUID so must find it by filename.
            if (pDESC->dwValidData & DMUS_OBJ_FILENAME || pDESC->dwValidData & DMUS_OBJ_FULLPATH)
                StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), pDESC->wszFileName);

            // Now, add the object to our list
            pObject->m_pNext = m_pObjectList;
            m_pObjectList = pObject;

            // If we succeeded in creating the DirectMusic object,
            // keep a pointer to it and addref it
            pObject->m_pObject = pIObject;
            pIObject->AddRef();
        }
        else
        {
            // Couldn't create list item - release the object and return
            pIObject->Release();
            LeaveCriticalSection(&m_CriticalSection);
            return E_OUTOFMEMORY;
        }
    }

    // If we found an object (i.e., didn't create one), try and load it from its IStream pointer
    // or filename
    // This only happens if fCreatedpObject is false (meaning 
    if( !fCreatedpObject )
    {
        if( pObject->m_pStream )
        {
            // If the object has a stream pointer, load from the stream
            // This is the case if the object is embedded within a container
            hr = LoadFromStream(pObject->m_guidClass, pObject->m_pStream, pIObject);
        }
        else
        {
            hr = DMUS_E_LOADER_NOFILENAME;
        }
    }
    // Otherwise, load the object from whatever is valid
    else if (pDESC->dwValidData & DMUS_OBJ_FILENAME)
    {
        hr = LoadFromFile(pDESC,pIObject);
    }
    else if (pDESC->dwValidData & DMUS_OBJ_MEMORY)
    {
        hr = LoadFromMemory(pDESC,pIObject);
    }
    else if( pDESC->dwValidData & DMUS_OBJ_STREAM)
    {
        hr = LoadFromStream(pDESC->guidClass, pDESC->pStream, pIObject);
    }
    else
    {
        hr = DMUS_E_LOADER_NOFILENAME;
    }

    // If load succeeded
    if (SUCCEEDED(hr))
    {
        // Keep the guid and filename for finding it next time.

        // Get the object descriptor
        DMUS_OBJECTDESC DESC;
        memset((void *)&DESC,0,sizeof(DESC));
        DESC.dwSize = sizeof (DMUS_OBJECTDESC); 
        hr = pIObject->GetDescriptor(&DESC);
        if( SUCCEEDED( hr ) )
        {
            // Save the GUID from the object.
            if (DESC.dwValidData & DMUS_OBJ_OBJECT)
                pObject->m_guidObject = DESC.guidObject;

            // If filename for this object is not set, but DESC has it,
            // then copy the filename into our list item
            if (pObject->m_wszFileName[0] == 0 && (DESC.dwValidData & DMUS_OBJ_FILENAME || DESC.dwValidData & DMUS_OBJ_FULLPATH))
                StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), DESC.wszFileName);


        }

        // Finally, QI for the interface requested by the calling method
        hr = pIObject->QueryInterface( riid, ppv );
    }
    else
    {
        // Remove pObject's pointer to the DirectMusic object
        pObject->m_pObject->Release();
        pObject->m_pObject = NULL;

        // If we created pObject
        if( fCreatedpObject )
        {
            // Remove object from list

            // If object is at head of list
            if( m_pObjectList == pObject )
            {
                m_pObjectList = m_pObjectList->m_pNext;
            }
            else
            {
                // Object not at the head of the list - probably tried to load
                // a container, which then loaded other objects

                // Find object
                CObjectRef *pPrevRef = m_pObjectList;
                CObjectRef *pTmpRef = pPrevRef->m_pNext;
                while( pTmpRef && pTmpRef != pObject )
                {
                    pPrevRef = pTmpRef;
                    pTmpRef = pTmpRef->m_pNext;
                }

                // If we found the object (we should have)
                if( pTmpRef == pObject )
                {
                    // Make the list skip the object
                    pPrevRef->m_pNext = pObject->m_pNext;
                }
            }

            // Clear the list object's next pointer
            pObject->m_pNext = NULL;

            // Delete pObject
            if( pObject->m_pStream )
            {
                pObject->m_pStream->Release();
                pObject->m_pStream = NULL;
            }
            delete pObject;
            pObject = NULL;
        }
    }
    // In all cases, release pIObject
    pIObject->Release();

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CLoader::LoadFromFile(LPDMUS_OBJECTDESC pDesc,IDirectMusicObject * pIObject)

{
    HRESULT hr = S_OK;

    if ((pDesc->dwValidData & DMUS_OBJ_FULLPATH) || !(pDesc->dwValidData & DMUS_OBJ_FILENAME))
    {
        return E_INVALIDARG; // only accept relative paths
    }

    // Resolve relative to m_bstrSrc
    WCHAR wszURL[MAX_PATH + 1] = L"";
    DWORD dwLength = MAX_PATH;
    if (!InternetCombineUrlW(m_bstrSrc, pDesc->wszFileName, wszURL, &dwLength, 0))
    {
        return E_INVALIDARG;
    }

    TraceTag((tagDMLoader, "CLoader::LoadFromFile downloading  %S", wszURL));

    // Download the URL
    WCHAR wszFilename[MAX_PATH + 1] = L"";
    hr = URLDownloadToCacheFileW(NULL, wszURL, wszFilename, MAX_PATH, 0, g_spLoaderBindStatusCallback);
    if (FAILED(hr))
    {
        return hr;
    }

    pDesc->dwValidData &= ~DMUS_OBJ_FILENAME;
    pDesc->dwValidData |= DMUS_OBJ_FULLPATH;

    CFileStream *pStream = new CFileStream ( this );
    if (pStream)
    {
        if (!(pDesc->dwValidData & DMUS_OBJ_FULLPATH))
        {
            pStream->Release();
            pStream = NULL; //lint !e423  This is no leak because the Release handles the delete
            return E_INVALIDARG;
        }

        TraceTag((tagDMLoader, "CLoader::LoadFromFile loading object from %S", wszFilename));

        hr = pStream->Open(wszFilename, GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            // If Script, make sure this is a valid script file and that it only uses AudioVBScript
            if (CLSID_DirectMusicScript == pDesc->guidClass) 
            {
                if (!IsAudioVBScriptFile( pStream ))
                {
                    hr = DMUS_E_LOADER_FAILEDCREATE;
                }
            }

            if (SUCCEEDED(hr))
            {
                IPersistStream* pIPS = NULL;
                hr = (pIObject)->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                if (SUCCEEDED(hr))
                {
                    // Now that we have the IPersistStream interface from the object, we can ask it to load from our stream!
                    hr = pIPS->Load( pStream );
                    pIPS->Release();
                }
            }
        }
        pStream->Release();
        pStream = NULL; //lint !e423  This is no leak because the Release handles the delete
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CLoader::LoadFromMemory(LPDMUS_OBJECTDESC pDesc,IDirectMusicObject * pIObject)

{
    HRESULT hr;
    CMemStream *pStream = new CMemStream ( this );
    if (pStream)
    {
        hr = pStream->Open(pDesc->pbMemData,pDesc->llMemLength);
        if (SUCCEEDED(hr))
        {
            // If Script, make sure this is a valid script file and that it only uses AudioVBScript
            if (CLSID_DirectMusicScript == pDesc->guidClass) 
            {
                if (!IsAudioVBScriptFile( pStream ))
                {
                    hr = DMUS_E_LOADER_FAILEDCREATE;
                }
            }

            if (SUCCEEDED(hr))
            {
                IPersistStream* pIPS;
                hr = (pIObject)->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                if (SUCCEEDED(hr))
                {
                    // Now that we have the IPersistStream interface from the object, we can ask it to load from our stream!
                    hr = pIPS->Load( pStream );
                    pIPS->Release();
                }
            }
        }
        pStream->Release(); 
        pStream = NULL; //lint !e423  This is no leak because the Release handles the delete
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CLoader::LoadFromStream(REFGUID rguidClass, IStream *pStream,IDirectMusicObject * pIObject)

{
    HRESULT hr;
    if (pStream)
    {
        // Need to load from a clone of the given IStream, so we don't move its position
        IStream *pStreamClone;
        hr = pStream->Clone( &pStreamClone );
        if (SUCCEEDED(hr))
        {
            // If Script, make sure this is a valid script file and that it only uses AudioVBScript
            if (CLSID_DirectMusicScript == rguidClass) 
            {
                if (!IsAudioVBScriptFile( pStreamClone ))
                {
                    hr = DMUS_E_LOADER_FAILEDCREATE;
                }
            }

            if (SUCCEEDED(hr))
            {
                IPersistStream* pIPS;
                hr = (pIObject)->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                if (SUCCEEDED(hr))
                {
                    // Now that we have the IPersistStream interface from the object, we can ask it to load from our stream!
                    hr = pIPS->Load( pStreamClone );
                    pIPS->Release();
                }
            }

            pStreamClone->Release(); 
       }
    }
    else
    {
        hr = E_POINTER;
    }
    return hr;
}


STDMETHODIMP CLoader::SetObject(
    LPDMUS_OBJECTDESC pDESC)

{
    HRESULT hr = E_FAIL;
    EnterCriticalSection(&m_CriticalSection);

    // Search for the given object descriptor
    CObjectRef * pObject = NULL;
    for (pObject = m_pObjectList;pObject;pObject = pObject->m_pNext)
    {
        if (pDESC->dwValidData & DMUS_OBJ_OBJECT && pObject->m_guidObject != GUID_NULL)
        {
            // We have the GUIDs of both objects so compare by GUID, which is most precise.
            // (If different objects have the same filename then GUIDs will be used to tell them apart.)
            if (pDESC->guidObject == pObject->m_guidObject)
                break;
        }
        else
        {
            // Comare the filenames.
            if ((pDESC->dwValidData & DMUS_OBJ_FILENAME || pDESC->dwValidData & DMUS_OBJ_FULLPATH) && 0 == _wcsicmp(pDESC->wszFileName, pObject->m_wszFileName))
                break;
        }
    }

    if (pObject)
    {
        // Don't support merging data with existing objects
        LeaveCriticalSection(&m_CriticalSection);
        return E_INVALIDARG;
    }

    // Ensure that the object's stream and class is set
    if( !(pDESC->dwValidData & DMUS_OBJ_STREAM) || !(pDESC->dwValidData & DMUS_OBJ_CLASS) )
    {
        // Don't support merging data with existing objects
        LeaveCriticalSection(&m_CriticalSection);
        return E_INVALIDARG;
    }

    // Otherwise, create a new object
    pObject = new CObjectRef();
    if (pObject)
    {
        hr = S_OK;

        // Set the object's fields
        if (pDESC->dwValidData & DMUS_OBJ_OBJECT)
        {
            pObject->m_guidObject = pDESC->guidObject;
        }
        if (pDESC->dwValidData & DMUS_OBJ_FILENAME)
        {
            hr = StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), pDESC->wszFileName);
        }

        if (SUCCEEDED(hr))
        {
            // Copy the object's class
            pObject->m_guidClass = pDESC->guidClass;

            // Clone and parse the object's stream
            if( pObject->m_pStream )
            {
                pObject->m_pStream->Release();
                pObject->m_pStream = NULL;
            }
            if( pDESC->pStream )
            {
                hr = pDESC->pStream->Clone( &pObject->m_pStream );

                // If Clone succeeded and we don't have the object's GUID,
                // parse the object from the stream
                if( SUCCEEDED( hr )
                &&  !(pObject->m_guidObject != GUID_NULL) )
                {
                    // Make another clone of the stream
                    IStream *pStreamClone;
                    if( SUCCEEDED( pObject->m_pStream->Clone( &pStreamClone ) ) )
                    {
                        // Create the object, and ask for the IDirectMusicObject interface
                        IDirectMusicObject *pIObject;
                        hr = CoCreateInstance(pDESC->guidClass,
                            NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
                            (void **) &pIObject);
                        if (SUCCEEDED(hr))
                        {
                            // Initialize the object descriptor
                            DMUS_OBJECTDESC tmpObjDesc;
                            memset((void *)&tmpObjDesc,0,sizeof(tmpObjDesc));
                            tmpObjDesc.dwSize = sizeof (DMUS_OBJECTDESC);

                            // Fill in the descriptor
                            hr = pIObject->ParseDescriptor(pStreamClone,&tmpObjDesc);
                            if (SUCCEEDED(hr))
                            {
                                // Finally, fill in the object's GUID and filename
                                if( tmpObjDesc.dwValidData & DMUS_OBJ_OBJECT )
                                {
                                    pObject->m_guidObject = tmpObjDesc.guidObject;
                                }
                                if (tmpObjDesc.dwValidData & DMUS_OBJ_FILENAME)
                                {
                                    StringCbCopy(pObject->m_wszFileName, sizeof(pObject->m_wszFileName), tmpObjDesc.wszFileName);
                                }
                            }
                            pIObject->Release();
                        }

                        pStreamClone->Release();
                    }
                }
            }
        }

        // Add the object to the list, if we succeeded and found a valid GUID for the object
        if( SUCCEEDED(hr)
        &&  (pObject->m_guidObject != GUID_NULL) )
        {
            pObject->m_pNext = m_pObjectList;
            m_pObjectList = pObject;
        }
        else
        {
            // Otherwise, clean up and delete the object
            if (pObject->m_pObject)
            {
                pObject->m_pObject->Release();
            }
            if( pObject->m_pStream )
            {
                pObject->m_pStream->Release();
            }
            delete pObject;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CLoader::SetSearchDirectory(
    REFCLSID rguidClass,    // Class id identifies which clas of objects this pertains to.
                            // Optionally, GUID_DirectMusicAllTypes specifies all classes. 
    WCHAR *pwzPath,         // File path for directory. Must be a valid directory and
                            // must be less than MAX_PATH in length.
    BOOL fClear)            // If TRUE, clears all information about objects
                            // prior to setting directory. 
                            // This helps avoid accessing objects from the
                            // previous directory that may have the same name.
                            // However, this will not remove cached objects.
                                        
{
    // This loader doesn't use search directories.  You can only load by URL via GetSegment.
    return E_NOTIMPL;
}

STDMETHODIMP CLoader::ScanDirectory(
    REFCLSID rguidClass,    // Class id identifies which class of objects this pertains to.
    WCHAR *pszFileExtension,// File extension for type of file to look for. 
                            // For example, L"sty" for style files. L"*" will look in all
                            // files. L"" or NULL will look for files without an
                            // extension.
    WCHAR *pszCacheFileName // Optional storage file to store and retrieve
                            // cached file information. This file is created by 
                            // the first call to <om IDirectMusicLoader::ScanDirectory>
                            // and used by subsequant calls. NULL if cache file
                            // not desired.
)

{
    return E_NOTIMPL;
}


STDMETHODIMP CLoader::CacheObject(
    IDirectMusicObject * pObject)   // Object to cache.

{
    return E_NOTIMPL;
}


STDMETHODIMP CLoader::ReleaseObject(
    IDirectMusicObject * pObject)   // Object to release.

{
    return E_NOTIMPL;
}

STDMETHODIMP CLoader::ClearCache(
    REFCLSID rguidClass)    // Class id identifies which class of objects to clear.
                            // Optionally, GUID_DirectMusicAllTypes specifies all types. 

{
    if (rguidClass != GUID_DirectMusicAllTypes)
        return E_NOTIMPL;

    while (m_pObjectList)
    {
        CObjectRef * pObject = m_pObjectList;
        m_pObjectList = pObject->m_pNext;
        if (pObject->m_pObject)
        {
            pObject->m_pObject->Release();
        }
        if( pObject->m_pStream )
        {
            pObject->m_pStream->Release();
        }
        delete pObject;
    }
    return S_OK;
}

STDMETHODIMP CLoader::EnableCache(
    REFCLSID rguidClass,    // Class id identifies which class of objects to cache.
                            // Optionally, GUID_DirectMusicAllTypes specifies all types. 
    BOOL fEnable)           // TRUE to enable caching, FALSE to clear and disable.
{
    return E_NOTIMPL;
}

STDMETHODIMP CLoader::EnumObject(
    REFCLSID rguidClass,    // Class ID for class of objects to view. 
    DWORD dwIndex,          // Index into list. Typically, starts with 0 and increments.
    LPDMUS_OBJECTDESC pDESC)// DMUS_OBJECTDESC structure to be filled with data about object.
                                       
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\tokens.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: token.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "tokens.h"

// timeAction values
TOKEN NONE_TOKEN                    = L"none";
TOKEN STYLE_TOKEN                   = L"style";
TOKEN VISIBILITY_TOKEN              = L"visibility";
TOKEN DISPLAY_TOKEN                 = L"display";
TOKEN INVALID_TOKEN                 = L"";

// If this should change, nCLASS_TOKEN_LENGTH should be changed as well
TOKEN     CLASS_TOKEN               = L"class";
const int nCLASS_TOKEN_LENGTH       = 5;
// If this should change, nSEPARATOR_LENGTH should be changed as well
TOKEN     SEPARATOR_TOKEN           = L":";
const int nSEPARATOR_TOKEN_LENGTH   = 1;

TOKEN ONOFF_PROPERTY_TOKEN         = L"on";

TOKEN TRUE_TOKEN   = L"true";
TOKEN FALSE_TOKEN  = L"false";
TOKEN HIDDEN_TOKEN  = L"hidden";

TOKEN READYSTATE_COMPLETE_TOKEN = L"complete";

TOKEN CANSLIP_TOKEN  = L"canSlip";
TOKEN LOCKED_TOKEN   = L"locked";

TOKEN STOP_TOKEN = L"stop";
TOKEN PAUSE_TOKEN = L"pause";
TOKEN DEFER_TOKEN = L"defer";
TOKEN NEVER_TOKEN = L"never";

TOKEN REMOVE_TOKEN = L"remove";
TOKEN FREEZE_TOKEN = L"freeze";
TOKEN HOLD_TOKEN = L"hold";
TOKEN TRANSITION_TOKEN = L"transition";

TOKEN ALWAYS_TOKEN = L"always";
TOKEN WHENNOTACTIVE_TOKEN = L"whenNotActive";

TOKEN SEQ_TOKEN = L"seq";
TOKEN PAR_TOKEN = L"par";
TOKEN EXCL_TOKEN = L"excl";

TOKEN AUTO_TOKEN = L"auto"; 
TOKEN MANUAL_TOKEN = L"manual";
TOKEN RESET_TOKEN = L"reset";

#if DBG // 94850
TOKEN DSHOW_TOKEN = L"dshow";
#endif
TOKEN DVD_TOKEN = L"dvd";
TOKEN DMUSIC_TOKEN = L"dmusic";
TOKEN CD_TOKEN = L"cd";

TOKEN DISCRETE_TOKEN = L"discrete";
TOKEN LINEAR_TOKEN = L"linear";
TOKEN PACED_TOKEN = L"paced";

TOKEN CLOCKWISE_TOKEN = L"clockwise";
TOKEN COUNTERCLOCKWISE_TOKEN = L"counterclockwise";

//ASX TOKENS
TOKEN ENTRY_TOKEN = L"entry";
TOKEN TITLE_TOKEN = L"title";
TOKEN COPYRIGHT_TOKEN = L"copyright";
TOKEN AUTHOR_TOKEN = L"author";
TOKEN ABSTRACT_TOKEN = L"abstract";
TOKEN REF_TOKEN = L"ref";
TOKEN ENTRYREF_TOKEN = L"entryref";
TOKEN ASX_TOKEN = L"asx";
TOKEN HREF_TOKEN = L"href";
TOKEN REPEAT_TOKEN = L"repeat";
TOKEN EVENT_TOKEN = L"event";
TOKEN MOREINFO_TOKEN = L"moreinfo";
TOKEN BASE_TOKEN = L"base";
TOKEN LOGO_TOKEN = L"logo";
TOKEN PARAM_TOKEN = L"param";
TOKEN PREVIEWDURATION_TOKEN = L"previewduration";
TOKEN STARTTIME_TOKEN = L"starttime";
TOKEN STARTMARKER_TOKEN = L"startmarker";
TOKEN ENDTIME_TOKEN = L"endtime";
TOKEN ENDMARKER_TOKEN = L"endmarker";
TOKEN DURATION_TOKEN = L"duration";
TOKEN BANNER_TOKEN = L"banner";
TOKEN CLIENTSKIP_TOKEN = L"clientskip";
TOKEN CLIENTBIND_TOKEN = L"clientbind";
TOKEN COUNT_TOKEN = L"count";


//END ASX TOKENS

TOKEN FIRST_TOKEN = L"first";
TOKEN LAST_TOKEN = L"last";

TOKEN INDEFINITE_TOKEN = L"indefinite";

// TODO: Need to make this much faster

// This array should never contain INVALID_TOKEN
static TOKEN tokenArray[] =
{
    NONE_TOKEN,
    STYLE_TOKEN,
    VISIBILITY_TOKEN,
    DISPLAY_TOKEN,
    CLASS_TOKEN,
    READYSTATE_COMPLETE_TOKEN,
    CANSLIP_TOKEN,
    LOCKED_TOKEN,
    STOP_TOKEN,
    PAUSE_TOKEN,
    DEFER_TOKEN,
    NEVER_TOKEN,
    REMOVE_TOKEN,
    FREEZE_TOKEN,
    HOLD_TOKEN,
    TRANSITION_TOKEN,
    ALWAYS_TOKEN,
//    NEVER_TOKEN, // also above
    WHENNOTACTIVE_TOKEN,  
    SEQ_TOKEN,
    PAR_TOKEN,
    EXCL_TOKEN,
    AUTO_TOKEN, 
    MANUAL_TOKEN,
    RESET_TOKEN,
#if DBG // 94850
    DSHOW_TOKEN,
#endif
    DVD_TOKEN,
    CD_TOKEN,
    DISCRETE_TOKEN,
    LINEAR_TOKEN,
    PACED_TOKEN,
    CLOCKWISE_TOKEN,
    COUNTERCLOCKWISE_TOKEN,
    FIRST_TOKEN,
    LAST_TOKEN,
    INDEFINITE_TOKEN,
    DMUSIC_TOKEN,
    ENTRY_TOKEN,
    TITLE_TOKEN,
    COPYRIGHT_TOKEN,
    REF_TOKEN,
    ASX_TOKEN,
    ABSTRACT_TOKEN,
    AUTHOR_TOKEN,
    HREF_TOKEN,
    ENTRYREF_TOKEN,
    REPEAT_TOKEN,
    EVENT_TOKEN,
    MOREINFO_TOKEN,
    BASE_TOKEN,
    LOGO_TOKEN,
    PARAM_TOKEN,
    PREVIEWDURATION_TOKEN,
    STARTTIME_TOKEN,
    STARTMARKER_TOKEN,
    ENDTIME_TOKEN,
    ENDMARKER_TOKEN,
    DURATION_TOKEN,
    BANNER_TOKEN,
    CLIENTSKIP_TOKEN,
    CLIENTBIND_TOKEN,
    COUNT_TOKEN,
    NULL
};

TOKEN
StringToToken(wchar_t * str)
{
    for (unsigned int i = 0; i < ARRAY_SIZE(tokenArray); i++)
    {
        if (StrCmpIW(str, (wchar_t *) tokenArray[i]) == 0)
            return tokenArray[i];
    }

    return INVALID_TOKEN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\timetoken.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timetoken.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timetoken.h"

CTIMETokenizer::CTIMETokenizer () :
    _pCharacterStream(NULL),
    _cCharacterStream(0),
    _currChar ('\0'),
    _currToken (TT_Unknown),
    _currTokOffset(0),
    _nextTokOffset(0),
    _pStartOffset(0),
    _pEndOffset(0),
    _pStartTokenValueOffset(0),
    _pEndTokenValueOffset(0),
    _bTightSyntaxCheck(false),
    _bSingleCharMode(false)
{
}

CTIMETokenizer::~CTIMETokenizer()
{
    if (_pCharacterStream)
    {
        delete [] _pCharacterStream;
        _pCharacterStream = NULL;
    }
    _pStartOffset = NULL;
    _pEndOffset = NULL;
    _pStartTokenValueOffset = NULL;
    _pEndTokenValueOffset = NULL;
}
    
ULONG 
CTIMETokenizer::GetCharCount (OLECHAR token)
{
    ULONG count = 0;
    OLECHAR *curChar = _pCharacterStream;

    if (!_pCharacterStream)
    {
        goto done;
    }

    while (*curChar != '\0')
    {
        if (*curChar == token)
        {
            count++;
        }        
        curChar++;
    }
  done:
    
    return count;
}


ULONG 
CTIMETokenizer::GetAlphaCount(char cCount)
{
    ULONG count = 0;
    OLECHAR *curChar = _pCharacterStream;

    if (!_pCharacterStream)
    {
        goto done;
    }

    while (*curChar != '\0')
    {
        if (*curChar == cCount)
        {
            count++;
        }        
        curChar++;
    }
  done:
    
    return count;
}

void 
CTIMETokenizer::SetSingleCharMode(bool bSingle)
{ 
    _bSingleCharMode = bSingle; 
}

TIME_TOKEN_TYPE
CTIMETokenizer::NextToken()
{
    TIME_TOKEN_TYPE tt = TT_Unknown;

    if (CurrentChar())
    {
        if (_bSingleCharMode && _nextTokOffset == 1 && _pStartOffset != 0)
        {
            _pStartOffset = _pCharacterStream + _nextTokOffset;
        }
        else
        {
            _pStartOffset = _pCharacterStream + _nextTokOffset - 1;
        }
        
        if (CurrentChar() == CHAR_BACKSLASH)
        {
            tt = TT_Backslash;
        }
        // Identifier?
        else if ((CurrentChar() >= 'a' && CurrentChar() <= 'z') ||
                 (CurrentChar() >= 'A' && CurrentChar() <= 'Z') ||
                 (CurrentChar() == CHAR_ESCAPE))
        {
            // Fetch the rest of the identifier.
            tt = FetchIdentifier();
            goto Done;
        }

        else if ((CurrentChar() >= '0' && CurrentChar() <= '9') ||
                 (CurrentChar() == CHAR_DOT && PeekNextChar(0) >= '0' && PeekNextChar(0) <= '9' ))
        {
            tt = FetchNumber();
            goto Done;
        }

        else
        {
            switch (CurrentChar())
            {
            case CHAR_HASH : 
                tt = TT_Hash;
                NextChar();
                break;

            case CHAR_AT : 
                tt = TT_At;
                NextChar();
                break;

            case CHAR_SINGLE : 
            case CHAR_DOUBLE : 
                {
                    // TODO: Need to handle escaped character as first character.
                    // Probably best to do in CurrentChar
                    OLECHAR chStrDelim = CurrentChar();

                    NextChar();

                    // Don't include the beginning quote in string value.
                    _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

                    FetchString(chStrDelim);
                    NextChar();
                    tt = TT_String;
                    break;
                }

            case CHAR_EQUAL : 
                tt = TT_Equal;
                NextChar();
                break;
            
            case CHAR_COLON : 
                tt = TT_Colon;
                NextChar();
                break;

            case CHAR_FORWARDSLASH : 
                tt = TT_ForwardSlash;
                NextChar();
                break;

            case CHAR_LEFT_CURLY : 
                tt = TT_LCurly;
                NextChar();
                break;

            case CHAR_RIGHT_CURLY : 
                tt = TT_RCurly;
                NextChar();
                break;

            case CHAR_SEMI : 
                tt = TT_Semi;
                NextChar();
                break;

            case CHAR_DOT : 
                tt = TT_Dot;
                NextChar();
                break;

            case CHAR_COMMA : 
                tt = TT_Comma;
                NextChar();
                break;

            case CHAR_ASTERISK : 
                tt = TT_Asterisk;
                NextChar();
                break;

            case CHAR_LEFT_PAREN : 
                tt = TT_LParen;
                NextChar();
                break;

            case CHAR_RIGHT_PAREN : 
                tt = TT_RParen;
                NextChar();
                break;

            case CHAR_BANG : 
                tt = TT_Bang;
                NextChar();
                break;
            case CHAR_PERCENT :
                tt = TT_Percent;
                NextChar();
                break;
            case CHAR_PLUS :
                tt = TT_Plus;
                NextChar();
                break;
            case CHAR_MINUS :
                tt = TT_Minus;
                NextChar();
                break;
            case CHAR_SPACE:
                tt = TT_Space;
                if (!_bTightSyntaxCheck)
                {
                    while (CurrentChar() != 0 && isspace(CurrentChar()))
                    {
                        NextChar();
                    }
                    tt = NextToken();
                }
                else
                {
                    NextChar();
                }
                break;
            case CHAR_LESS:
                tt = TT_Less;
                NextChar();
                break;
            case CHAR_GREATER:
                tt = TT_Greater;
                NextChar();
                break;
            default: 
                // <!-- ?
                if (CDOToken())
                {
                    // find and return comment token.
                    tt = TT_Comment;
                }
                else
                    tt = TT_Unknown;
                NextChar();
                break;
            }
        }
    }
    else    // Done parsing EOF hit.
    {
        tt = TT_EOF;
    }

    _currTokOffset = _nextTokOffset - 1;

Done:
    NextNonSpaceChar();
    _currToken = tt;

    return tt;
}


TIME_TOKEN_TYPE
CTIMETokenizer::FetchIdentifier()
{
    if (!_bSingleCharMode)
    {
        while ((CurrentChar() >= 'a' && CurrentChar() <= 'z') ||
               (CurrentChar() >= 'A' && CurrentChar() <= 'Z') ||
               (CurrentChar() >= '0' && CurrentChar() <= '9') ||
               (CurrentChar() == CHAR_UNDERLINE || CurrentChar() == CHAR_ESCAPE)) 
        {
            if (CurrentChar() == CHAR_ESCAPE)
                break;

            NextChar();
        }
    }
    else
    {
        NextChar(); //only fetch a single character.
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return TT_Identifier;
}

BOOL
CTIMETokenizer::FetchStringToChar(OLECHAR chStrDelim)
{
    _pStartOffset++;

    return FetchString(chStrDelim);
}

BOOL
CTIMETokenizer::FetchStringToString(LPOLESTR pstrDelim)
{
    _pStartOffset++;

    return FetchString(pstrDelim);
}


TIME_TOKEN_TYPE
CTIMETokenizer::FetchNumber()
{
    // digit = 0..9
    // number = digit* | [digit + '.' [+ digit*]]

    while (CurrentChar() >= '0' && CurrentChar() <= '9') 
    {
        NextChar();
    }

    if (CurrentChar() == CHAR_DOT)
    {
        NextChar();
        if (CurrentChar() >= '0' && CurrentChar() <= '9')
        {
            while (CurrentChar() >= '0' && CurrentChar() <= '9')
                NextChar();
        }
        else
        {
            return TT_Unknown;
        }
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;
    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return TT_Number;
}


// Looking for /* and 
BOOL
CTIMETokenizer::CDOToken()
{
    if (CurrentChar() == CHAR_FORWARDSLASH &&
        PeekNextChar(0) == CHAR_ASTERISK)
    {
        // skip the /*
        NextChar();
        NextChar();

        while (CurrentChar() &&
               (CurrentChar() != CHAR_ASTERISK ||
                PeekNextChar(0) != CHAR_FORWARDSLASH))
        {
            NextChar();
        }

        // skip the */
        if (CurrentChar())
        {
            // Only advance one char here as there will be one more in NextToken(), after this.
            NextChar();
        }

        _pEndOffset = _pCharacterStream + _nextTokOffset;

        return TRUE;
    }

    return FALSE;
}


BOOL
CTIMETokenizer::FetchString(OLECHAR chDelim)
{
    BOOL   fResult;

    while (CurrentChar() && CurrentChar() != chDelim)
    {
        NextChar();
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    // Was end string delimiter found ' or " depending on how the string started?
    fResult = !!CurrentChar();

    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return fResult;
}

BOOL
CTIMETokenizer::FetchString(LPOLESTR strDelim)
{
    BOOL fResult = FALSE;
    int i = 0, iLen, j, iOffsetLen;
    LPOLESTR pcmpStr = NULL;

    if(strDelim == NULL)
    {
        goto done;
    }

    iLen = lstrlenW(strDelim);

    iOffsetLen = lstrlenW(_pStartOffset);
    if(iOffsetLen < iLen)
    {
        fResult = FALSE;
        goto done;
    }

    pcmpStr = new TCHAR[lstrlenW(strDelim) + 1];

    while (((iOffsetLen - i) > iLen) && (fResult != TRUE))
    {
        for(j = 0; j < iLen; j++)
        {
            //pcmpStr[j] = *(_pStartOffset + i + j);
            pcmpStr[j] = *(_pCharacterStream + _nextTokOffset + j - 1);
        }
        pcmpStr[iLen] = 0;

        if(StrCmpIW(pcmpStr, strDelim) == 0)
        {
            fResult = TRUE;
            break;
        }
        NextChar();
        i++;
    }
    delete [] pcmpStr;

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

done:
    return fResult;
}

HRESULT CTIMETokenizer::Init (OLECHAR *pData, ULONG ulLen)
{
    HRESULT hr = S_OK;

    if (_pCharacterStream)
    {
        delete [] _pCharacterStream;
        _pCharacterStream = NULL;
    }
    _pCharacterStream = CopyString(pData);
    if (NULL == _pCharacterStream)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    _cCharacterStream = ulLen;
    //need to reset all of the values

    _currChar = '\0';
    _currToken = TT_Unknown;
    _currTokOffset = 0;
    _nextTokOffset = 0;
    _pStartOffset = 0;
    _pEndOffset = 0;
    _pStartTokenValueOffset = 0;
    _pEndTokenValueOffset = 0;

    NextChar();             // Prime the tokenizer.
    NextNonSpaceChar();     // Find first real character to be tokenized.

    hr = S_OK;
done:
    RRETURN(hr);
}

OLECHAR CTIMETokenizer::NextChar()
{
    if (_nextTokOffset < _cCharacterStream)
        _currChar = *(_pCharacterStream + _nextTokOffset++);
    else if (_currChar)
    {
        _nextTokOffset = _cCharacterStream + 1;
        _currChar = _T('\0');
    }

    return _currChar;
}


OLECHAR CTIMETokenizer::NextNonSpaceChar()
{
    if (!_bTightSyntaxCheck)
    {
        while (CurrentChar() != 0 && isspace(CurrentChar()))
            NextChar();
    }

    return CurrentChar();    // if 0 return then EOF hit.
}

BOOL CTIMETokenizer::isIdentifier (OLECHAR *szMatch)
{
    if (_currToken == TT_Identifier)
    {
        return StrCmpIW(szMatch, GetTokenValue()) == 0;
    }

    return FALSE;
}

double CTIMETokenizer::GetTokenNumber()
{
    ULONG len = 0;
    double dblTokenValue = 0.0;
    OLECHAR *szTokenValue = NULL;
 
    if (_currToken != TT_Number)
    {
        goto done;        
    }

    if (_pStartTokenValueOffset && _pEndTokenValueOffset)
    {
        HRESULT hr = S_OK;
        VARIANT vNum;
        
        len = GetTokenLength();
        szTokenValue = NEW OLECHAR [len + 1];
        
        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, _pStartTokenValueOffset, sizeof(OLECHAR) *(len));
        szTokenValue[len] = _T('\0');

        //convert the token to a number
        VariantInit(&vNum);
        vNum.vt = VT_BSTR;
        vNum.bstrVal = SysAllocString(szTokenValue);

        hr = THR(VariantChangeTypeEx(&vNum, &vNum, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8));
        if (SUCCEEDED(hr))
        {
            dblTokenValue = V_R8(&vNum);
        }

        delete [] szTokenValue;
        szTokenValue = NULL;

        VariantClear(&vNum);
    }
    

  done:
    return dblTokenValue;
}

OLECHAR *CTIMETokenizer::GetTokenValue ()
{
    ULONG len = 0;
    OLECHAR *szTokenValue = NULL;

    if (_currToken == TT_Number)
    {
        goto done;        
    }

    len = GetTokenLength();
    if (_bSingleCharMode && len > 1)
    {
        _pEndTokenValueOffset = _pStartTokenValueOffset + 1;
        _nextTokOffset = _pEndTokenValueOffset - _pStartTokenValueOffset;
        len = GetTokenLength();
    }

    if (_pStartTokenValueOffset && _pEndTokenValueOffset)
    {
        szTokenValue = NEW OLECHAR [len + 1];
        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, _pStartTokenValueOffset, sizeof(OLECHAR) *(len));
        szTokenValue[len] = _T('\0');
    }

  done:
    return szTokenValue;
}


OLECHAR *CTIMETokenizer::GetNumberTokenValue ()
{
    ULONG len = 0;
    OLECHAR *szTokenValue = NULL;

    len = GetTokenLength();
    if (_bSingleCharMode && len > 1)
    {
        _pEndTokenValueOffset = _pStartTokenValueOffset + 1;
        _nextTokOffset = _pEndTokenValueOffset - _pStartTokenValueOffset;
        len = GetTokenLength();
    }

    if (_pStartTokenValueOffset && _pEndTokenValueOffset)
    {
        szTokenValue = NEW OLECHAR [len + 1];
        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, _pStartTokenValueOffset, sizeof(OLECHAR) *(len));
        szTokenValue[len] = _T('\0');
    }

  done:
    return szTokenValue;
}

OLECHAR *CTIMETokenizer::GetRawString (ULONG uStartOffset, ULONG uEndOffset)
{
    int i = 0;
    OLECHAR *szTokenValue = NULL;

    if (uEndOffset && uEndOffset > uStartOffset)
    {

        szTokenValue = NEW OLECHAR [(uEndOffset-uStartOffset) + 1];

        if (szTokenValue == NULL)
        {
            goto done;
        }

        memcpy(szTokenValue, (_pCharacterStream + uStartOffset), sizeof(OLECHAR)*(uEndOffset-uStartOffset));
        szTokenValue[uEndOffset-uStartOffset] = '\0';
        //trim off trailing spaces
        i = uEndOffset-uStartOffset;
        while (szTokenValue[i] == ' ' && i >= 0)
        {
            szTokenValue[i] = _T('\0');
            i--;
        }
    }

  done:
    return szTokenValue;
}

// Look ahead to next non-space character w/o messing with current tokenizing state.
OLECHAR CTIMETokenizer::PeekNextNonSpaceChar()
{
    ULONG   peekTokOfset = _nextTokOffset;
    OLECHAR   peekCurrentChar = _currChar;

    while (peekCurrentChar != 0 && isspace(peekCurrentChar))
        peekCurrentChar = (peekTokOfset < _cCharacterStream) ? *(_pCharacterStream + peekTokOfset++) : '\0';

    return peekCurrentChar;    // if 0 return then EOF hit.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\base.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// BASE.H - 
//


#ifndef _BASE_H_
#define _BASE_H_


class CBase
{

public:
    LPECB   lpEcb;
    LPSTR   lpszOut;                    // HTML output
    LPSTR   lpszDebug;                  // Debug output

    LPDUMPTABLE lpDT;                   // Parser commented hex dump table

    CBase( LPECB lpEcb, LPSTR *lpszOut, LPSTR *lppszDebug, LPDUMPTABLE lpDT );
    virtual ~CBase( );

private:

}; // CBase


#endif // _BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\base.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// BASE.CPP - Base class methods
//


#include "pch.h"

// Constructors / Destructors
CBase::CBase( 
        LPECB lpEcb, 
        LPSTR *lppszOut,
        LPSTR *lppszDebug, 
        LPDUMPTABLE lpDT )
{

    this->lpEcb     = lpEcb;

    this->lpszOut   = NULL;
    this->lpszDebug = NULL;
    this->lpDT      = lpDT;

    if ( lppszOut )
    {
        *lppszOut = (LPSTR) GlobalAlloc( GMEM_FIXED, 65336 );
        if ( *lppszOut )
        {
            this->lpszOut      = *lppszOut;
            this->lpszOut[ 0 ] = 0; // start empty;
        }
    }

    if ( lppszDebug )
    {
        *lppszDebug = (LPSTR) GlobalAlloc( GMEM_FIXED, 8196 );
        if ( *lppszDebug )
        {
            this->lpszDebug      = *lppszDebug;
            this->lpszDebug[ 0 ] = 0; // start empty;
        }
    }

} // CBase( )

CBase::~CBase( )
{
    GlobalFree( lpszDebug );
    GlobalFree( lpszOut );
} // ~CBase( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\debug.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// DEBUG.H - Debugging header
//

#ifndef _DEBUG_H_
#define _DEBUG_H_

// structures
typedef struct {
    LPBYTE lpAddr;      // Address
    DWORD  dwColor;     // Color to use
    LPSTR  lpszComment; // Comment to show
} DUMPTABLE, *LPDUMPTABLE;

#pragma warning(disable:4200)
typedef struct {
    DWORD dwCount;
    struct {
        DWORD dwCode;
        LPSTR lpDesc;
    } ids[];
} CODETOSTR, *LPCODETOSTR;
#pragma warning(default:4200)

// globals
extern const char g_szTrue[];
extern const char g_szFalse[];
extern CODETOSTR HRtoStr;
extern CODETOSTR HSEtoStr;
extern CODETOSTR ErrtoStr;

// macros
#define BOOLTOSTRING( _f ) ( _f ? g_szTrue : g_szFalse )

// constants
// Maximum number of dump table entries
#define MAX_DT  400

// debug flags
#define TF_ALWAYS   0xFFFFffff
#define TF_FUNC     0x80000000  // Trace with function calls
#define TF_DLL      0x00000001  // DLL entry points
#define TF_RESPONSE 0x00000002  // Responses
#define TF_READDATA 0x00000004  // Data reading functions
#define TF_PARSE    0x00000008  // Parsing
#define TF_SERVER   0x00000010  // Call to server callbacks
#define TF_LEX      0x00000020  // Lex 

#ifdef DEBUG

// Globals
extern DWORD g_dwTraceFlag;

// macros
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg;
#define Assert(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && AssertMsg(0, szFile, __LINE__, TEXT(#f) )) \
            DEBUG_BREAK;       \
    }

// functions
BOOL CDECL AssertMsg(
    BOOL fShouldBeTrue,
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszStatement );

void CDECL TraceMsg( 
    DWORD mask, 
    LPCSTR pszMsg, 
    ... );
void CDECL TraceMsgResult( 
    DWORD mask, 
    LPCODETOSTR lpCodeToStr,
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... );


#else // DEBUG

#define DEBUG_BREAK
#define AssertMsg           1 ? (void)0 : (void)
#define TraceMsg            1 ? (void)0 : (void)
#define TraceMsgResult      1 ? (void)0 : (void)

#endif // DEBUG

// HTML output debugging messages
void CDECL DebugMsg( 
    LPSTR lpszOut,
    LPCSTR pszMsg, 
    ... );
void CDECL DebugMsgResult( 
    LPSTR lpszOut,
    LPCODETOSTR lpCodeToStr,
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... );
//
// These are for users of BOTH RETAIL and DEBUG. They only echo to the
// logfile and to the debug output (if process attached to IIS).
//
void CDECL LogMsgResult( 
    LPSTR lpszLog, 
    LPSTR lpStr,
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... );
void CDECL LogMsg( 
    LPSTR lpszLog,
    LPSTR lpStr, 
    LPCSTR pszMsg, 
    ... );

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\dllmain.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// DLLMAIN.CPP - DLL entry points
//

#include "pch.h"

// Globals
HANDLE g_hInst;

//
// What:    DllMain
//
// Desc:    Dll initialization entry point.
//
BOOL WINAPI DllMain (
    HANDLE hInst, 
    ULONG ulReason,
    LPVOID lpReserved )
{
    TraceMsg( TF_FUNC | TF_DLL, "DllMain( )" );

#if 0
    DebugBreak( );  // stop so we can get a chance to enable break points
#endif

    switch( ulReason ) 
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInst;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
    
} // DllMain( )

//
// What:    DllRegisterServer
//
// Desc:    Register our ISAPI with IIS
//
STDAPI DllRegisterServer( void )
{
    HRESULT hr = S_OK;

    TraceMsg( TF_FUNC | TF_DLL, "DllRegisterServer( )" );

    TraceMsgResult( TF_DLL, &HRtoStr, hr, "DllRegisterServer( ) Exit" );
    return hr;

} // DllRegisterServer( )

//
// What:    GetExtensionVersion
//
// Desc:    ISAPI entry point
//
BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO  *pVer )
{
    TraceMsg( TF_FUNC | TF_DLL, "GetExtensionVersion( pVer )" );

    pVer->dwExtensionVersion = MAKELONG( FILEUPLD_VERSION_MINOR,
                                         FILEUPLD_VERSION_MAJOR );
    StrCpyN( pVer->lpszExtensionDesc,
              FILEUPLD_DESCRIPTION,
              HSE_MAX_EXT_DLL_NAME_LEN );

    TraceMsg( TF_FUNC | TF_DLL, "GetExtensionVersion( pVer ) Exit BOOL=TRUE" );
    return TRUE;
} // GetExtensionVersion( )

//
// What:    HttpExtensionProc
//
// Desc:    ISAPI entry point
//
DWORD  HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK  lpEcb )
{
    DWORD  dwResult  = HSE_STATUS_SUCCESS;  // return status
    BOOL   fReturn;                         // status flag
    BOOL   fMultipart;                      // multipart/form-data submit?
    BOOL   fTextPlain;                      // text/plain submit?
    BOOL   fDebug;                          // show debug spew?
    LPSTR  lpszOut   = NULL;                // server log output
    LPSTR  lpszDebug = NULL;                // debug output
    LPBYTE lpbData;                         // pointer to body data
    DWORD  dwParsed;                        // number of bytes parsed

    DUMPTABLE   DT[ MAX_DT ];               // Hex Dump table info.
    QUERYMETHOD eMethod = METHOD_UNKNOWN;   // method of query

    CMultipartParse *lpMPParser = NULL;
    CTextPlainParse *lpTPParser = NULL;

    TraceMsg( TF_FUNC | TF_DLL, "HttpExtensionProc( lpEcb )" );

#if 0
    fReturn = SendEcho( lpEcb );
#endif

    // Make sure that we have all the data
    fReturn = CompleteDownload( lpEcb, &lpbData );

    // Check content-type for multipart
    if ( fReturn )
    {
        fReturn = CheckForMultiPartFormSubmit( lpEcb, &fMultipart );
    }

    if ( fReturn )
    {
        fReturn = CheckForTextPlainSubmit( lpEcb, &fTextPlain );
    }

    if ( fReturn )
    {
        fReturn = CheckForDebug( lpEcb, &fDebug );
    }

    // Parse
    if ( fReturn )
    {
        if ( fMultipart )
        {
            if ( fDebug )
            {
                lpMPParser = new CMultipartParse( lpEcb, &lpszOut, &lpszDebug, DT );
            }
            else
            {
                lpMPParser  = new CMultipartParse( lpEcb, &lpszOut, NULL, DT );
                lpszDebug = NULL;
            }

            fReturn = lpMPParser->PreParse( lpbData, &dwParsed );
            eMethod= METHOD_POSTMULTIPART;

        } 
        else if ( fTextPlain )
        {
            if ( ! fDebug )
            {
                lpTPParser = new CTextPlainParse( lpEcb, &lpszOut, &lpszDebug, DT );
            }
            else
            {
                lpTPParser  = new CTextPlainParse( lpEcb, &lpszOut, NULL, DT );
                lpszDebug = NULL;
            }

            fReturn = lpTPParser->Parse( lpbData, &dwParsed );
            eMethod= METHOD_POSTTEXTPLAIN;

        }
        else 
        {

            if ( !StrCmpI( lpEcb->lpszMethod, "POST" ) )
            {
                eMethod= METHOD_POST;
            }
            else if ( !StrCmpI( lpEcb->lpszMethod, "GET" ) )
            {
                eMethod= METHOD_GET;
            }
        }              
    }

    // Display results
    if ( fReturn )
    {
        fReturn = SendSuccess( eMethod, lpEcb, lpszOut, lpszDebug, lpbData, dwParsed, DT );
    }
    else
    {
        fReturn = SendFailure( eMethod, lpEcb, lpszOut, lpszDebug, lpbData, dwParsed, DT );
    }

    // Check to see if everything went OK
    if ( !fReturn )
    {
        dwResult = HSE_STATUS_ERROR;
    }

    // Free if we created the buffer
    if ( lpEcb->lpbData != lpbData ) 
    {
        GlobalFree( lpbData );
    }

    delete lpMPParser;
    delete lpTPParser;
    
    TraceMsgResult( TF_FUNC | TF_DLL, &HSEtoStr, dwResult, "HttpExtensionProc( lpEcb ) " );
    lpEcb->dwHttpStatusCode = dwResult;
    return dwResult;
} // HttpExtensionProc( )


//
// Support functions
//
void *  __cdecl operator new( unsigned int nSize )
{
    return ((LPVOID) LocalAlloc( LMEM_FIXED, nSize ));

}

void  __cdecl operator delete( void *pv )
{
    LocalFree( pv );
}

extern "C" int __cdecl _purecall( void ) { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\multpars.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// MULTPARS.CPP - Parses incoming stream for files
//

#include "pch.h"

// Local globals
const char g_cszBoundaryKeyword[]    = "boundary=";             // don't include space
const DWORD g_cbBoundaryKeyword      = sizeof( g_cszBoundaryKeyword ) - 1;
const char g_cszCheck[]              = "check=";                // don't include space
const DWORD g_cbCheck                = sizeof( g_cszCheck ) - 1;
const char g_cszBoundaryIndicator[]  = "\r\n--";
const DWORD g_cbBoundaryIndicator    = sizeof( g_cszBoundaryIndicator ) - 1;

const char g_cszExtraBytes[]         = "Extra bytes";
const char g_cszBodyData[]           = "Body Data";

// 
// Parsing table
//
PARSETABLE g_LexTable[ ] = {
    // Parser search string,         Lexicon           ,Length, Color , Comment
    { (LPSTR)g_cszBoundaryIndicator, LEX_BOUNDARY        , 0, 0xFFFFFF, "Boundary String"   },
    { (LPSTR)g_cszBoundaryIndicator, LEX_EOT             , 0, 0xFFFFFF, "Ending Boundary"   },
    { (LPSTR)g_cszBoundaryIndicator +2, LEX_STARTBOUNDARY, 0, 0xFFFFFF, "Starting Boundary" },
    // must be after LEX_BOUNDARY
    { "\r\n",                        LEX_CRLF            , 0, 0x7F7F7F, NULL                },
    { "content-disposition:",        LEX_CONTENTDISP     , 0, 0x0000FF, "Header Field"      },
    { "content-type:",               LEX_CONTENTTYPE     , 0, 0x0000FF, "Header Field"      },
    { "name=",                       LEX_NAMEFIELD       , 0, 0x0000FF, "Field Param"       },
    { "filename=",                   LEX_FILENAMEFIELD   , 0, 0x0000FF, "Field Param"       },
    // MIME types
    { "multipart",                   LEX_MULTIPART       , 0, 0x003FFF, "MIME Type"         },
    { "text",                        LEX_TEXT            , 0, 0x003FFF, "MIME Type"         },
    { "application",                 LEX_APPLICATION     , 0, 0x003FFF, "MIME Type"         },
    { "audio",                       LEX_AUDIO           , 0, 0x003FFF, "MIME Type"         },
    { "image",                       LEX_IMAGE           , 0, 0x003FFF, "MIME Type"         },
    { "message",                     LEX_MESSAGE         , 0, 0x003FFF, "MIME Type"         },
    { "video",                       LEX_VIDEO           , 0, 0x003FFF, "MIME Type"         },
    { "x-",                          LEX_MIMEEXTENSION   , 0, 0x003FFF, "MIME Extension"    },
    { "iana-",                       LEX_MIMEEXTENSION   , 0, 0x003FFF, "MIME Extension"    },
    // MIME subtypes
    { "form-data",                   LEX_FORMDATA        , 0, 0x003FFF, "MIME Subtype"      },
    { "attachment",                  LEX_ATTACHMENT      , 0, 0x003FFF, "MIME Subtype"      },
    { "mixed",                       LEX_MIXED           , 0, 0x003FFF, "MIME Subtype"      },
    { "plain",                       LEX_PLAIN           , 0, 0x003FFF, "MIME Subtype"      },
    { "x-msdownload",                LEX_XMSDOWNLOAD     , 0, 0x003FFF, "MIME Subtype"      },
    { "octet-stream",                LEX_OCTETSTREAM     , 0, 0x003FFF, "MIME Subtype"      },
    { "binary",                      LEX_BINARY          , 0, 0x003FFF, "MIME Subtype"      },
    // special chacacters
    { " ",                           LEX_SPACE           , 0, 0x7F7F7F, NULL                },
    // tabs are treated as spaces
    { "\t",                          LEX_SPACE           , 0, 0x7F7F7F, NULL                },
    { "/",                           LEX_SLASH           , 0, 0x003FFF, NULL                },
    { "\"",                          LEX_QUOTE           , 0, 0x000000, NULL                },
    { ";",                           LEX_SEMICOLON       , 0, 0x7F7F7F, NULL                },
    { "(",                           LEX_BEGIN_COMMENT   , 0, 0x7F7F7F, "Comment"           },
    { ")",                           LEX_END_COMMENT     , 0, 0x7F7F7F, NULL                },
    // end of table
    { NULL,                          LEX_UNKNOWN         , 0, 0x7F7F7F, NULL                }
    // NOTE: Length should always be zero. We will calculate this the first
    //       time we encounter the string as save it here to be used on
    //       future passes.
};

//
// Constructor / Destructor
//
CMultipartParse::CMultipartParse( 
                    LPECB lpEcb, 
                    LPSTR *lppszOut, 
                    LPSTR *lpszDebug,
                    LPDUMPTABLE lpDT )
    :CBase( lpEcb, lppszOut, lpszDebug, lpDT )
{
    DebugMsg( lpszOut, g_cszTableHeader, "\
(NOTE: To turn on detailed debugging information, add '?debug' to the end of action URL in the orginating HTML file.)\
<br>\
<H2>Multipart Form Data (METHOD=POST, ENCTYPE=MULTIPART/FORM-DATA)</H2>\
",
        "TBLMULTIFORM" );

    _cbDT = 0;  // empty DUMPTABLE

} // CMultipartParse( )

CMultipartParse::~CMultipartParse( )
{
    if ( _lpszBoundary )
    {
        GlobalFree( _lpszBoundary );
    }

} // ~CMultipartParse( )

//
// METHODS
//

//
// What:    PreParse
//
// Desc:    Parses incoming form from the root header. It is assumed that by
//          this point that we are parsing a MUTLIPART / FORM-DATA POST.
//
BOOL CMultipartParse::PreParse( LPBYTE lpbData, LPDWORD lpdwParsed )
{
    BOOL   fReturn;
    LPSTR  lpszHeader;

    TraceMsg( TF_FUNC | TF_PARSE, "PreParse( )" );

    _lpbLastParse = _lpbParse = _lpbData = lpbData;

    // Grab content_type from server header
    fReturn = GetServerVarString( lpEcb, "CONTENT_TYPE", &lpszHeader, NULL );
    if ( !fReturn )
        goto Cleanup;

    // Create the boundary string that we will be searching for
    fReturn = GetBoundaryString( (LPBYTE) lpszHeader );
    GlobalFree( lpszHeader );
    if ( !fReturn )
        goto Cleanup;

    // Parse body headers
    fReturn = ParseBody( );

Cleanup:
    // End table output
    StrCat( lpszOut, g_cszTableEnd );

    // End the DUMPTABLE
    lpDT[ _cbDT ].lpAddr = NULL; // indicates EOTable

    *lpdwParsed = ( _lpbParse - _lpbData );

    TraceMsg( TF_FUNC | TF_PARSE, "PreParse( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // PreParse( )

//
// What:    ParseBody
//
// Desc:    Body header parsing state entered. We start by finding the 
//          next boundary string which indicates the beginning of a
//          body header.
//
BOOL CMultipartParse::ParseBody( )
{
    BOOL   fReturn      = TRUE; // assume success;
    DWORD  eLex;
    BOOL   fStartBoundaryOk = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "ParseBody( )" );

    // Bypass possible crap
    eLex = Lex( );
    while (( eLex != LEX_BOUNDARY ) && ( eLex !=LEX_EOT ) && ( eLex != LEX_STARTBOUNDARY ))
        eLex = Lex( );

    while (( fReturn) && ((DWORD) ( _lpbParse - _lpbData ) != lpEcb->cbTotalBytes ))
    {
        switch ( eLex )
        {
        case LEX_STARTBOUNDARY:
            if ( !fStartBoundaryOk )
            {
                DebugMsg( lpszDebug, "Found a mulformed boundary string. Missing preceeding CRLF at %u (0x%x) bytes.\n",
                    ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
                fReturn = FALSE;
                break;
            }
            // fall thru
        case LEX_BOUNDARY:
            DebugMsg( lpszDebug, "Found boundary. Content starts at %u (0x%x) bytes.\n", 
                ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
            fReturn = BodyHeader( );
            break;

        case LEX_EOT:
            {
                DWORD cbParsed = _lpbParse - _lpbData;
                fReturn = ( cbParsed == lpEcb->cbTotalBytes );
                DebugMsg( lpszDebug, "EOT found.\n" );
                DebugMsg( lpszDebug, "TotalBytesReceived == BytesParsed? %s \n",
                    BOOLTOSTRING( fReturn ) );
                if ( !fReturn )
                {
                    DebugMsg( lpszDebug, "Header 'Content-length': %u bytes. Parsed: %u bytes\n",
                        lpEcb->cbTotalBytes, ( _lpbParse - _lpbData ) );
                    DebugMsg( lpszDebug, "( Note: If bytes parsed greater than 'content-length', it \
                        is possible that the server read the entire packet in its first pass and \
                        that the actual packet size is larger than indicated by the content-length \
                        header field entry. )\n");
                }
            }
            goto Cleanup;

        default:
            DebugMsg( lpszDebug, "Did not find a boundary string after %u (0x%x) bytes.\n", 
                _lpbParse - _lpbData, _lpbParse - _lpbData );
            fReturn = FALSE;
            goto Cleanup;
        }

        fStartBoundaryOk = FALSE;
        eLex = Lex( );

    } // while ( _lpbParse - _lpbData )

    DebugMsg( lpszDebug, "Parsed %u (0x%x) bytes.\n", ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "ParseBody( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // ParseBody( )

// 
// What:    BodyHeader
//
// Desc:    State has entered the bodyheader.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::BodyHeader( )
{
    BOOL           fReturn = TRUE;
    BODYHEADERINFO sBHI;
    LEXICON        eLex;

    TraceMsg( TF_FUNC | TF_PARSE, "BodyHeader()" );

    // defaults
    sBHI.eContentDisposition = LEX_FORMDATA;
    sBHI.lpszNameField       = NULL;
    sBHI.lpszFilenameField   = NULL;
    sBHI.lpszBodyContents    = NULL;
    sBHI.dwContentType       = LEX_TEXT;
    sBHI.dwContentSubtype    = LEX_PLAIN;

    while ( fReturn )
    {
        eLex = Lex( );
        switch ( eLex )
        {
            // expected
        case LEX_CONTENTDISP:
            fReturn = ContentDisposition( &sBHI );
            break;

        case LEX_CONTENTTYPE:
            fReturn = ContentType( &sBHI );
            break;

        case LEX_CRLF:  // indicate end of header
            goto EndofHeader;

            // ignored
        case LEX_SPACE:
            break;
        case LEX_BEGIN_COMMENT:
            fReturn = HandleComments( );
            break;  // ingored

        default:
            DebugMsg( lpszDebug, "Unexpected '%s' found at %u (0x%x) bytes.\n",
                FindTokenName( eLex ), ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
            fReturn = FALSE;
            break;
        }  
    }

EndofHeader:
    // now retrieve the content...
    if ( fReturn )
    {
        fReturn = BodyContent( &sBHI );
    }

    // add results to output table
    if ( sBHI.lpszNameField )
    {
        DebugMsg( lpszOut, "<TR ID=TR%s><TD ID=TD%s>%s</TD><TD ID=%s>",
            sBHI.lpszNameField, sBHI.lpszNameField, 
            sBHI.lpszNameField, sBHI.lpszNameField );
    }
    else
    {
        DebugMsg( lpszOut, "<TR><TD> 'not given' </TD><TD>" );
    }

    if ( sBHI.lpszFilenameField )
    {
        DebugMsg( lpszOut, "%s", sBHI.lpszFilenameField );
    }
    else if ( sBHI.lpszBodyContents )
    {
        DebugMsg( lpszOut, "%s", sBHI.lpszBodyContents );
    }
    else
    {
        DebugMsg( lpszOut, "'unknown'" );
    }

    DebugMsg( lpszOut, "</TD></TR>" );

    // Free alloced memory
    if ( sBHI.lpszFilenameField )
    {
        GlobalFree( sBHI.lpszFilenameField );
    }

    if ( sBHI.lpszNameField )
    {
        GlobalFree( sBHI.lpszNameField );
    }

    if ( sBHI.lpszBodyContents )
    {
        GlobalFree( sBHI.lpszBodyContents );
    }

    TraceMsg( TF_FUNC | TF_PARSE, "BodyHeader() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // BodyHeader( )


//
// What:    ContentDisposition
//
// Desc:    Content-Disposition state reached. Parse header entry.
//
// In/Out:  lpBHI is a pointer to the body header information structure
//              that will be filled in as arguments are parsed.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::ContentDisposition( LPBODYHEADERINFO lpBHI )
{
    BOOL  fReturn = TRUE;
    LEXICON eLex;

    TraceMsg( TF_FUNC | TF_PARSE, "ContentDisposition( lpBHI=0x%x )",
        lpBHI );

    // What forms do we support?
    while ( fReturn )
    {
        eLex = Lex( );
        switch ( eLex )
        {
            // supported
        case LEX_FORMDATA:
            lpBHI->eContentDisposition = eLex;
            break; // LEX_FORMDATA

            // unsupported
        case LEX_ATTACHMENT:
            DebugMsg( lpszDebug, "'%s' (Multiple files) not supported (yet). Aborting...\n",
                FindTokenName( LEX_ATTACHMENT ) );
            fReturn = FALSE;
            break; // LEX_ATTACHMENT

            // possible optional fields
        case LEX_NAMEFIELD:
            fReturn = GetQuotedString( &lpBHI->lpszNameField );
            DebugMsg( lpszDebug, "Name Field='%s'\n", lpBHI->lpszNameField );
            break;

        case LEX_FILENAMEFIELD:
            fReturn = GetQuotedString( &lpBHI->lpszFilenameField );
            DebugMsg( lpszDebug, "Filename Field='%s'\n", lpBHI->lpszFilenameField );
            break;

            // ignored
        case LEX_SPACE:
        case LEX_SEMICOLON:
            break;

        case LEX_BEGIN_COMMENT:
            fReturn = HandleComments( );
            break;  // ingored

        case LEX_CRLF:
            eLex = Lex( );
            if ( eLex != LEX_SPACE )
            {
                fReturn = BackupLex( eLex );
                goto Cleanup;    // end of field
            }
            // otherwise we ignore the CRLF and keep going
            break;

            // unexpected things
        default:
            DebugMsg( lpszDebug, "Unexpected '%s' found at %u (0x%x) bytes.\n",
                FindTokenName( eLex), ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
            fReturn = FALSE;
        }
    } // while eLex

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "ContentDisposition() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ContentDisposition( )

//
// What:    ContentType
//
// Desc:    Content-Type state reached. Parse header entry.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::ContentType( LPBODYHEADERINFO lpBHI )
{
    BOOL  fReturn = TRUE;
    BOOL  fAfterSlash = FALSE;
    LEXICON eLex;

    TraceMsg( TF_FUNC | TF_PARSE, "ContentType( lpBHI=0x%x )",
        lpBHI );

    while ( fReturn )
    {
        eLex = Lex( );
        switch ( eLex )
        {
            // MIME types
        case LEX_MULTIPART:
        case LEX_TEXT:
        case LEX_APPLICATION:
        case LEX_AUDIO:
        case LEX_IMAGE:
        case LEX_MESSAGE:
        case LEX_VIDEO:
            lpBHI->dwContentType = eLex;
            break;

            // separator
        case LEX_SLASH:
            fAfterSlash = TRUE;
            break;

            // MIME subtypes
        case LEX_FORMDATA:
        case LEX_ATTACHMENT:
        case LEX_MIXED:
        case LEX_PLAIN:
        case LEX_XMSDOWNLOAD:
        case LEX_OCTETSTREAM:
        case LEX_BINARY:
            lpBHI->dwContentSubtype = eLex;
            break;

            // these are prefixes (like "x-") so we ignore the rest of the 
            // token name.
        case LEX_MIMEEXTENSION:     
            fReturn = GetToken( );  // ignore
            if ( !fAfterSlash )
            {
                lpBHI->dwContentType = eLex;
            }
            else
            {
                lpBHI->dwContentSubtype = eLex;
            }
            break;

          // ignored
        case LEX_SPACE:
        case LEX_SEMICOLON:
            break;

        case LEX_BEGIN_COMMENT:
            fReturn = HandleComments( );
            break;  // ingored

        case LEX_CRLF:
            eLex = Lex( );
            if ( eLex != LEX_SPACE )
            {
                fReturn = BackupLex( eLex );
                goto Cleanup;    // end of field
            }
            // otherwise we ignore the CRLF and keep going
            break;

        default:
            if ( !fAfterSlash )
            {
                DebugMsg( lpszDebug, "Unexpected '%s' found at %u (0x%x) bytes.\n",
                    FindTokenName( eLex ), ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
                fReturn = FALSE;
            }
            else
            {
                fReturn = GetToken( );
            }

        } // switch eLex

    } // while fReturn

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "ContentType() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ContentType( )

//
// What:    GetBoundaryString
//
// Desc:    Searches CONTENT_TYPE for boundary string and copies into 
//          buffer (GlobalAlloced).
//
// Return:  TRUE is boundary found and copied, otherwise FALSE.
//
BOOL CMultipartParse::GetBoundaryString( LPBYTE lpbData )
{
    BOOL fReturn;
    LPSTR lpstr;

    TraceMsg( TF_FUNC | TF_PARSE, "GetBoundaryString( )" );

    // assume failure
    _lpszBoundary = NULL;
    _cbBoundary   = 0;
    fReturn       = FALSE;

    // find the boundary keyword
    lpstr = StrStrI( (LPSTR) lpbData, g_cszBoundaryKeyword );
    if ( !lpstr )
        goto Cleanup;    

    // move forward of keyword 
    lpstr += g_cbBoundaryKeyword;

    // point to boundary string
    _lpszBoundary = StrDup( lpstr );
    _cbBoundary = lstrlen( _lpszBoundary );

    DebugMsg( lpszDebug, "Boundary String : 'CRLF--%sCRLF' %u (0x%x) bytes\n",
        _lpszBoundary, _cbBoundary + 6, _cbBoundary + 6 );
    DebugMsg( lpszDebug, "EndOfContent Str: 'CRLF--%s--CRLF' %u (0x%x) bytes\n",
        _lpszBoundary, _cbBoundary + 8, _cbBoundary + 8 );

    fReturn = TRUE;

Cleanup:
    // _lpszBoundary will be cleaned up on the destruction of the
    // class.

    TraceMsg( TF_FUNC | TF_PARSE, "GetBoundaryString( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // GetBoundaryString( )



//
// What:    HandleComments
//
// Desc:    pull down comments and discard them. 
//          ISSUE: Doesn't handle embedded comments.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::HandleComments( )
{
    BOOL fReturn = TRUE;
    TraceMsg( TF_FUNC | TF_PARSE, "HandleComments( )" );

    LEXICON eLex = LEX_UNKNOWN;
    while( eLex != LEX_END_COMMENT )
        eLex = Lex( ); // parse away...

    TraceMsg( TF_FUNC | TF_PARSE, "HandleComments( ) Exit" );
    return fReturn;
} // HandleComments( )


//
// What:    BodyContent
//
// Desc:    Handles the content part of the body.
//
// In:      lpBHI is the body header information structure that
//              contains arguments found in the body header.
//
// Return:  TRUE unless a unrecognized token is found.
//
BOOL CMultipartParse::BodyContent( LPBODYHEADERINFO lpBHI )
{
    BOOL    fReturn           = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "BodyContent( lpBHI=0x%x )",
        lpBHI );

    // Is it a file?
    if (( lpBHI->lpszFilenameField ) 
       && ( lpBHI->lpszFilenameField[ 0 ] != 0 ))
    {   // file content....
        fReturn = HandleFile( lpBHI->lpszFilenameField );
        if ( fReturn )
            DebugMsg( lpszDebug, "Body Data= FILE CONTENTS\n" );
    }
    else
    {   // TODO: we need to handle different "Content-Types".
        //         For now we will assume that it is text/plain.
        LEXICON eLex = LEX_UNKNOWN;

        LPBYTE lpbStart = _lpbParse;
        DWORD dwSize;
        fReturn = FindNextBoundary( &dwSize );

        // neaten up to be displayed and copied
        CHAR cTemp = *_lpbParse; // save
        *_lpbParse = 0;     // null to display
        DebugMsg( lpszDebug, "Body Data='%s'\n", lpbStart );
        lpBHI->lpszBodyContents = StrDup( (LPSTR) lpbStart );
        *_lpbParse = cTemp; // restore
    }

    TraceMsg( TF_FUNC | TF_PARSE, "BodyContent( _lpbParse=0x%x ) Exit = %s",
        _lpbParse, BOOLTOSTRING( fReturn ) );
    return fReturn;
} // BodyContent( )

//
// What:    GetQuotedString
//
// Desc:    Retrieves a quoted string from data.
//
// In/Out:  lppszBuf is a passed in buffer pointer which will be assigned to
//              to the field name.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::GetQuotedString( LPSTR *lppszBuf )
{
    BOOL   fReturn = TRUE;
    LPBYTE lpbStart;

    TraceMsg( TF_FUNC | TF_PARSE, "GetQuotedString( )" );

    LEXICON eLex = Lex( );
    fReturn = ( eLex == LEX_QUOTE );
    if ( !fReturn )
    {
        DebugMsg( lpszDebug, "Excepted the beginning of a quoted string at %u (0x%x) bytes.\n",
            ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );
        goto Cleanup;
    }

    lpbStart = _lpbParse;
    while (( (DWORD) ( _lpbParse - _lpbData ) < lpEcb->cbTotalBytes ) 
        && ( *_lpbParse != '\"' ))           
        _lpbParse++;

    if ( _lpbParse == (LPBYTE) lpEcb->cbTotalBytes )
    {
        fReturn = FALSE;
        *lppszBuf = StrDup( "Error!" );
    }
    else
    {
        CHAR cTmp = *_lpbParse;
        *_lpbParse = 0;             // save
        *lppszBuf = StrDup( (LPSTR) lpbStart );
        *_lpbParse = cTmp;          // restore
        _lpbParse++;        // get past the quote
    }

Cleanup:
    TraceMsg( TF_FUNC | TF_PARSE, "GetQuoteString( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // GetQuotedString( )

//
// What:    GetToken
//
// Desc:    Scans past unknow content and validates that the characters
//          used are acceptable ( see RFC 1521, page 9 ). If an invalid
//          character is found, it will exit (no error).
//
// Return:  FALSE if we run past the end of the data buffer, otherwise TRUE.
//
BOOL CMultipartParse::GetToken( )
{
    BOOL fReturn = TRUE;

    static const char szInvalidChars[] = "()<>@,;:\\\"/[]?=";
    // plus SPACE and CTLs (in if statement)

    TraceMsg( TF_FUNC | TF_PARSE, "GetToken()" );

    while ( (DWORD) ( _lpbParse - _lpbData ) < lpEcb->cbTotalBytes )
    {
        if (( *_lpbParse <= 32 ) 
           || ( StrChr( szInvalidChars, *_lpbParse ) ))
            break;

        _lpbParse++;
    }

    if ( (DWORD) ( _lpbParse - _lpbData ) == lpEcb->cbTotalBytes )
    {
        DebugMsg( lpszDebug, "Could not find the end of the token.\n" );
        fReturn = FALSE;
    }

    TraceMsg( TF_FUNC | TF_PARSE, "GetToken() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // GetToken( )

//
// What:    HandleFile
//
// Desc:    Retrieves "file" part of the body.
//
// In:      lpszFilename is the name of the file from the form submission.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::HandleFile( LPSTR lpszFilename )
{
    BOOL   fReturn = TRUE;
    DWORD  eLex = LEX_UNKNOWN;
    DWORD  dwSize;
    LPBYTE lpbStart;

    TraceMsg( TF_FUNC | TF_PARSE, "HandleFile( \"%s\" )", lpszFilename );

    // find the end of the file
    lpbStart = _lpbParse;
    fReturn = FindNextBoundary( &dwSize );

    // fix filename for server use
    if ( fReturn )
    {
        DebugMsg( lpszDebug, "Filesize= %u (0x%x) bytes\n", dwSize, dwSize );
        fReturn = FixFilename( lpszFilename, &lpszFilename );
    }

    // Check the filename for ""
    if (( fReturn ) && ( StrCmp( lpszFilename, "" ) ))
    {
#ifndef FILE_SAVE
        fReturn  = FileCompare( lpbStart, lpszFilename, dwSize );
#else // FILE_SAVE
        fReturn  = FileSave( lpbStart, lpszFilename, dwSize );
#endif // FILE_SAVE
    }

    if ( !fReturn )
    {
        LogMsg( lpEcb->lpszLogData, NULL, "Error: File possibly corrupt." );
    }

    TraceMsg( TF_FUNC | TF_PARSE, "HandleFile( \"%s\" ) Exit = %s", 
        lpszFilename, BOOLTOSTRING( fReturn ) );
    return fReturn;
} // HandleFile( )


//
// What:    FindNextBoundary
//
// Desc:    Finds the next boundary in body content and the length of
//          the block skipped.
//
// Out:     *lpdwSize will contain the size of the block skipped.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FindNextBoundary( LPDWORD lpdwSize )
{
    BOOL fReturn = FALSE;   // assume failure

    TraceMsg( TF_FUNC | TF_PARSE, "FindNextBoundary()" );

    lpDT[ _cbDT ].lpAddr      = _lpbParse;
    lpDT[ _cbDT ].dwColor     = 0x000000;
    lpDT[ _cbDT ].lpszComment = (LPSTR) g_cszBodyData;
    _cbDT++;
    if ( _cbDT >= MAX_DT )
    {
        DebugMsg( lpszDebug, "*** DEBUG ERROR *** Exceeded Dump Table Limit\n" );
        _cbDT = MAX_DT - 1;
    }

    // find the end of the file
    LPBYTE lpbStart = _lpbParse;
    while ( (DWORD) ( _lpbParse - _lpbData ) < lpEcb->cbTotalBytes )
    {
        // possible boundary?
        if ( !StrCmpN( (LPSTR) _lpbParse, g_cszBoundaryIndicator, g_cbBoundaryIndicator ) )
        { // yes... check further
            LPBYTE lpb = _lpbParse; // save
            LEXICON eLex = Lex( );
            _lpbParse = lpb;        // restore
            _cbDT--;                // ignore this parse
            if (( eLex == LEX_BOUNDARY ) || ( eLex == LEX_EOT ))
            {
                fReturn = TRUE;
                break;  // exit loop
            }
        }
        _lpbParse++;
    }

    // figure out the size
    *lpdwSize = _lpbParse - lpbStart;

    if ( !fReturn )
    {
        DebugMsg( lpszDebug, "FindNextBoundary( ): Did not find boundary after %u (0x%x) bytes.\n",
            lpbStart - _lpbData, lpbStart - _lpbData );

        _lpbParse--;    // back up one byte
        _cbDT--;        // back up one parse table entry
    }

    TraceMsg( TF_FUNC | TF_PARSE, "FindNextBoundary( *lpdwSize = %u (0x%x) ) Exit = %s",
        *lpdwSize, *lpdwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

}  // FindNextBoundary( )

#ifndef FILE_SAVE
//
// What:    MemoryCompare
//
// Desc:    Compares memory chunks and determines if they match
//
// In:      lpbSrc1 and lpbSrc2 and the memory blocks to compare.
//          dwSize is the length of the blocks.
//
// Return:  TRUE if they match, otherwise FALSE
//
BOOL CMultipartParse::MemoryCompare( LPBYTE lpbSrc1, LPBYTE lpbSrc2, DWORD dwSize )
{
    DWORD cb = 0;
    while (( cb < dwSize ) && ( *lpbSrc1 == *lpbSrc2 ))
    {
        lpbSrc1++;
        lpbSrc2++;
        cb++;
    }

    return ( cb == dwSize );
} // MemoryCompare( )

//
// What:    FileCompare
//
// Desc:    Compares bits in memory with contents of the file lpszFilename.
//
// In:      lpbStart is the starting memory address.
//          lpszFilename is the filename to use.
//          dwSize is the length of valid bits after lpbStart.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FileCompare( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize )
{
#define BIG_FILE_SIZE   4096
    BOOL fReturn = TRUE;
    DWORD dwRead;
    LPBYTE lpBuffer;

    TraceMsg( TF_FUNC | TF_PARSE, "FileCompare( lpbStart=0x%x, lpszFilename='%s', dwSize=%u )",
        lpbStart, lpszFilename, dwSize );

    HANDLE hFile = CreateFile( lpszFilename, GENERIC_READ, 
        FILE_SHARE_READ, NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
        NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        DebugMsg( lpszDebug, "CreateFile() failed to open '%s'.\n",
            lpszFilename );
        fReturn = FALSE;
        goto Cleanup;
    }

    dwRead = GetFileSize( hFile, NULL );
    if ( dwSize != dwRead )
    {
        LogMsg( lpEcb->lpszLogData, lpszDebug, "FileChecking: File sizes don't match: '%s'",
            lpszFilename );
        DebugMsg( lpszDebug, "FileChecking: Client sent=%u (0x%x) bytes and File length=%u (0x%x) bytes.\n",
            lpszFilename, dwSize, dwSize, dwRead, dwRead );
        DebugMsg( lpszDebug, "FileChecking: I will compare the bits I can.\n" );
        fReturn = FALSE;

        // shorten if needed
        dwSize = ( dwSize > dwRead ? dwRead : dwSize );                            
    }

    if ( dwSize > BIG_FILE_SIZE )
    {   // read/compare only the beginning and the end bytes
        DWORD dwShortSize = BIG_FILE_SIZE / 2;

        DebugMsg( lpszDebug, "FileChecking: **** Very large file ( > %u (0x%x) bytes )****\n",
            BIG_FILE_SIZE, BIG_FILE_SIZE );
        DebugMsg( lpszDebug, "FileChecking: Checking only the beginning %u (0x%x) bytes and the last %u (0x%x) bytes.\n",
            dwShortSize, dwShortSize, dwShortSize, dwShortSize);
            
        lpBuffer = (LPBYTE) GlobalAlloc( GMEM_FIXED, dwShortSize );
        if ( !lpBuffer )
        {
            DebugMsg( lpszDebug, "Out of memory(?).\n" );
            fReturn = FALSE;
            goto Cleanup;
        }
        // read beginning bytes
        if ( !ReadFile( hFile, lpBuffer, dwShortSize, &dwRead, NULL ) )
        {
            DebugMsg( lpszDebug, "begin bytes ReadFile() failed.\n" );
            fReturn = FALSE;
            goto Cleanup;
        }
        if ( dwShortSize != dwRead )
        {
            DebugMsg( lpszDebug, "FileChecking(begin bytes): Unable to read %u (0x%x) bytes from file '%s'.\n",
                dwShortSize, dwShortSize, lpszFilename );
            fReturn = FALSE;
            goto Cleanup;
        } 

        fReturn = MemoryCompare( lpBuffer, lpbStart, dwShortSize );
        if ( !fReturn )
            goto Cleanup;

        // seek to end bytes
        if ( 0xFFFFffff == SetFilePointer( hFile, dwSize - dwShortSize, NULL, FILE_BEGIN ) )
        {   // error
            DebugMsg( lpszDebug, "SetFilePointer() failed!\n" );
            fReturn = FALSE;
            goto Cleanup;
        }

        // read end bytes
        if ( !ReadFile( hFile, lpBuffer, dwShortSize, &dwRead, NULL ) )
        {
            DebugMsg( lpszDebug, "end bytes ReadFile() failed.\n" );
            fReturn = FALSE;
            goto Cleanup;
        } 
        if ( dwShortSize != dwRead )
        {
            DebugMsg( lpszDebug, "FileChecking(end bytes): Unable to read %u (0x%x) bytes from file '%s'.\n",
                dwShortSize, dwShortSize, lpszFilename );
            fReturn = FALSE;
            goto Cleanup;
        } 

        fReturn = MemoryCompare( lpBuffer, lpbStart + dwSize - dwShortSize, dwShortSize );
    }
    else // if ( dwSize > BIG_FILE_SIZE )
    {   // read/compare entire file
        lpBuffer = (LPBYTE) GlobalAlloc( GMEM_FIXED, dwSize );
        if ( !lpBuffer )
        {
            DebugMsg( lpszDebug, "Out of memory(?).\n" );
            fReturn = FALSE;
            goto Cleanup;
        } 

        if ( !ReadFile( hFile, lpBuffer, dwSize, &dwRead, NULL ) )
        {
            DebugMsg( lpszDebug, "ReadFile() failed.\n" );
            fReturn = FALSE;
            goto Cleanup;
        } 

        if ( dwSize != dwRead )
        {
            DebugMsg( lpszDebug, "FileChecking: Unable to read %u (0x%x) bytes from file '%s'.\n",
                dwSize, dwSize, lpszFilename );
            fReturn = FALSE;
            goto Cleanup;
        }

        fReturn = MemoryCompare( lpBuffer, lpbStart, dwSize );

    } // if ( dwSize > BIG_FILE_SIZE )


Cleanup:
    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle( hFile ); // close file

    GlobalFree( lpBuffer );

    // Output to IIS log
    if ( fReturn )
    {
        LogMsg( lpEcb->lpszLogData, lpszDebug, "FileChecking: Files matched!" );
    }
    else
    {
        LogMsg( lpEcb->lpszLogData, lpszDebug, "FileChecking: Files don't match or an error occured." );
    }

    TraceMsg( TF_FUNC | TF_PARSE, "FileCompare( lpbStart=0x%x, lpszFilename='%s', dwSize=%u ) Exit = %s",
        lpbStart, lpszFilename, dwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

} // FileCompare( )

#else // FILE_SAVE

//
// What:    FileSave
//
// Desc:    Save bits starting at lpbStart to a file called lpszFilename.
//
// In:      lpbStart is the starting memory address.
//          lpszFilename is the filename to use.
//          dwSize is the length of valid bits after lpbStart.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FileSave( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize )
{
    BOOL fReturn = TRUE;
    
    TraceMsg( TF_FUNC | TF_PARSE, "FileSave( lpbStart=0x%x, lpszFilename='%s', dwSize=%u )",
        lpbStart, lpszFilename, dwSize );

    if ( fReturn )
    {
        HANDLE hFile = CreateFile( lpszFilename, GENERIC_WRITE, 
            FILE_SHARE_READ, NULL, CREATE_NEW, 
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
            NULL );
        if ( hFile != INVALID_HANDLE_VALUE )
        {
            DWORD dwWrote;
            if ( WriteFile( hFile, lpbStart, dwSize, &dwWrote, NULL ) )
            {
                fReturn = ( dwSize == dwWrote );
                if ( !fReturn ) 
                {
                    LogMsg( lpEcb->lpszLogData, lpszDebug, "Could not write entire file '%s'. Only wrote %u (0x%x) bytes.",
                        lpszFilename, dwWrote, dwWrote );
                }
            }
            else 
            {
                LogMsg( lpEcb->lpszLogData, lpszDebug, "Could not write file '%s'.",
                    lpszFilename );
                fReturn = FALSE;
            }

            CloseHandle( hFile );

        } 
        else 
        {
            LogMsg( lpEcb->lpszLogData, lpszDebug, "CreateFile() failed to create '%s'.",
                lpszFilename );
            fReturn = FALSE;

        } // if hFile

    } // if fReturn

    TraceMsg( TF_FUNC | TF_PARSE, "FileSave( lpbStart=0x%x, lpszFilename='%s', dwSize=%u ) Exit = ",
        lpbStart, lpszFilename, dwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

} // FileSave( )

#endif // FILE_SAVE

//
// What:    FixFilename
//
// Desc:    Adjusts filename to be used on the server. It creates a path
//          to the same directory as the DLL. It then appends the just 
//          the filename ( not the path info ).
//
// In:      lpszFilename is the filename submitted by user.
//
// In/Out:  lppszNameFilename will return a pointer to the newly constructed
//              filename.
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::FixFilename( LPSTR lpszFilename, LPSTR *lppszNewFilename )
{
    BOOL fReturn = TRUE;
    CHAR szFilename[ MAX_PATH ];    // temp buffer

    TraceMsg( TF_FUNC | TF_PARSE, "FixFilename( lpszFilename='%s', *lppszNewFilename=0x%x )",
        lpszFilename, *lppszNewFilename );

    // Strip c:\ stuff
    LPSTR lpszShortFilename = StrRChr( lpszFilename, lpszFilename + lstrlen( lpszFilename ), '\\' );
    if ( lpszShortFilename )
    {
        lpszShortFilename++;    // move ahead of '\'
    }
    else
    {
        lpszShortFilename = lpszFilename;   // maybe it's already short.
    }

    // retrieve download directory file URL info
    LPSTR lpszPath;
    fReturn = GetServerVarString( lpEcb, "PATH_TRANSLATED", &lpszPath, NULL );
    if ( lpszPath )
    {
        StrCpy( szFilename, lpszPath );
        DWORD cch = lstrlen( szFilename );
        // check for '\' at the end...
        if ( szFilename[ cch - 1 ] != '\\' )
        {   // not there... add it
            szFilename[ cch ] = '\\';
            cch++;
        }
        // append filename
        StrCpy( &szFilename[ cch ], lpszShortFilename );
    } 
    else 
    {
        StrCpy( szFilename, lpszShortFilename );
    }

    *lppszNewFilename = StrDup( szFilename );
    fReturn = ( *lppszNewFilename != NULL );

    TraceMsg( TF_FUNC | TF_PARSE, "FixFilename( lpszFilename='%s', *lppszNewFilename=0x%x ) Exit = %s",
        lpszFilename, *lppszNewFilename, BOOLTOSTRING( fReturn ) );
    return fReturn;
    
} // FixFilename( )

//
// What:    Lex
//
// Desc:    Turns the next bytes into a token
//
// Return:  TRUE unless an error occurs.
//
LEXICON CMultipartParse::Lex( )
{
    TraceMsg( TF_FUNC | TF_PARSE | TF_LEX, "Lex( _lpbParse=0x%x )",
        _lpbParse );

    lpDT[ _cbDT ].lpAddr      = _lpbParse;
    lpDT[ _cbDT ].dwColor     = 0xFFFFFF;
    lpDT[ _cbDT ].lpszComment = (LPSTR) g_cszExtraBytes;

    if ( _lpbParse > _lpbData + lpEcb->cbTotalBytes )
    {
        return LEX_EOT;   // over the limit!
    }

    for( int i = 0; g_LexTable[ i ].lpszName != NULL; i++ )
    {
        // remember str length sizes to speed up on next pass
        if ( !g_LexTable[ i ].cLength )
        {
            g_LexTable[ i ].cLength  = lstrlen( g_LexTable[ i ].lpszName );
        }

        if ( !StrCmpNI( (LPSTR)_lpbParse, g_LexTable[ i ].lpszName, g_LexTable[ i ].cLength ) )
            break;  // found... exit

    } // for i

    // SPECIAL CASE
    LEXICON eLex = g_LexTable[ i ].eLex;
    if ( eLex == LEX_BOUNDARY )
    {   // check for a specific boundary marker
        _lpbParse += g_LexTable[ i ].cLength;
        eLex = LEX_UNKNOWN;

        if ( !StrCmpN( (LPSTR) _lpbParse , _lpszBoundary, _cbBoundary ) )
        { // match
            // check to see if it is an EOT Marker
            if ( !StrCmpN( (LPSTR) ( _lpbParse + _cbBoundary ), "--\r\n", 4 ) )
            {
                _lpbParse += _cbBoundary + 4;
                eLex      = LEX_EOT;
            } 
            // else make sure that it ends with a CRLF - rfc1521 Page 30
            else if ( !StrCmpN( (LPSTR) ( _lpbParse + _cbBoundary ), "\r\n", 2 ) )
            {
                _lpbParse += _cbBoundary + 2;
                eLex      = LEX_BOUNDARY;
            }
            // else it isn't a boundary
        }   
    }
    else if ( eLex == LEX_STARTBOUNDARY )
    {   // check for a specific boundary marker
        _lpbParse += g_LexTable[ i ].cLength;
        eLex = LEX_UNKNOWN;

        if ( !StrCmpN( (LPSTR) _lpbParse , _lpszBoundary, _cbBoundary ) )
        { // match
            // check to see if it is an EOT Marker
            if ( !StrCmpN( (LPSTR) ( _lpbParse + _cbBoundary ), "\r\n", 2 ) )
            {
                _lpbParse += _cbBoundary + 2;
                eLex      = LEX_STARTBOUNDARY;
            }
            // else it isn't a boundary
        }
    }
    else if ( eLex == LEX_UNKNOWN )
    {
        _lpbParse++;
    }
    else    // move past symbol
    {
        _lpbParse += g_LexTable[ i ].cLength;
    }


    lpDT[ _cbDT ].dwColor     = g_LexTable[ i ].dwColor;
    lpDT[ _cbDT ].lpszComment = g_LexTable[ i ].lpszComment;
    _cbDT++;
    if ( _cbDT >= MAX_DT )
    {
        DebugMsg( lpszDebug, "*** DEBUG ERROR *** Exceeded Dump Table Limit\n" );
        _cbDT = MAX_DT - 1;
    }

    TraceMsg( TF_FUNC | TF_PARSE | TF_LEX, "Lex( _lpbParse=0x%x ) Exit = %u ( %u, '%s')",
        _lpbParse, eLex, i,
        ( g_LexTable[ i ].lpszName ? g_LexTable[ i ].lpszName  : "NULL" ) );
    return eLex;
} // Lex( )

//
// What:    Find Token
//
// Desc:    Searches tokens and displays friendly name.
//
// In:      eLex is the Lexicon to find
//
// Return:  TRUE unless an error occurs.
//
LPSTR CMultipartParse::FindTokenName( LEXICON eLex )
{
    TraceMsg( TF_FUNC | TF_PARSE, "FindTokenName( )" );

    LPSTR lpszReturn = "<not found>";  // default

    for( int i = 0; g_LexTable[ i ].lpszName != NULL; i++ )
    {
        if ( g_LexTable[ i ].eLex == eLex )
            break;  // found... exit

    } // for i

    // SPECIAL CASE
    if ( eLex == LEX_BOUNDARY )
    {
        lpszReturn = _lpszBoundary;
    }
    else if ( eLex == LEX_EOT )
    {
        lpszReturn = _lpszBoundary;
    }
    else if ( eLex == LEX_UNKNOWN )
    {
        LPBYTE lpb = _lpbParse - 1;
        while (( *lpb ) && ( *lpb > 32 ))
            lpb++;
        *lpb = 0;
        lpszReturn = (LPSTR) _lpbParse;
    }
    else if ( g_LexTable[ i ].lpszName )
    {
        lpszReturn = g_LexTable[ i ].lpszName;
    }

    TraceMsg( TF_FUNC | TF_PARSE, "FindTokenName( ) Exit" );
    return lpszReturn;

} // FindTokenName( )

//
// What:    BackupLex
//
// Desc:    Backs parser up eLex's byte count.
//
// In:      eLex is the token ID to back up
//
// Return:  TRUE unless an error occurs.
//
BOOL CMultipartParse::BackupLex( LEXICON eLex )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "BackupLex( eLex=%s )", 
        FindTokenName( eLex ) );

    for( int i = 0; g_LexTable[ i ].lpszName != NULL; i++ )
    {
        if ( g_LexTable[ i ].eLex == eLex )
            break;  // found... exit

    } // for i

    // SPECIAL CASES
    if ( eLex == LEX_BOUNDARY )
    {
        // "CRLF--" + boundary string + "CRLF"
        _lpbParse -= ( g_LexTable[ i ].cLength + _cbBoundary + 2 );
    }
    else if ( eLex == LEX_EOT )
    {
        // "CRLF--" + boundary string + "--CRLF"
        _lpbParse -= ( g_LexTable[ i ].cLength + _cbBoundary + 4 );
    }
    else if ( eLex == LEX_UNKNOWN )
    {
        _lpbParse--;
    }
    else if ( g_LexTable[ i ].lpszName )
    {
        _lpbParse -= g_LexTable[ i ].cLength;
    }

    if ( fReturn )
    {
        _cbDT--;    // remove one
    }

    TraceMsg( TF_FUNC | TF_PARSE, "BackupLex( eLex=%s ) Exit",
        FindTokenName( eLex ) );
    return fReturn;

} // BackupLex( )

/*****************************************************************************
//
// FUNCTION TEMPLATE
//
// ***************************************************************************
//
// What:    
//
// Desc:    
//
// In:
//
// Out:
//
// Return:
//
BOOL CMultipartParse::( )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "()" );


    TraceMsg( TF_FUNC | TF_PARSE, "() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ( )

******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\debug.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// DEBUG.CPP - Debugging code
//

#include "pch.h"

// local globals
static const char s_szNewline[] = "\n";

// globals
const char g_szTrue[]  = "True";
const char g_szFalse[] = "False";

// local structures
CODETOSTR HRtoStr = {
    2,
    {
        { S_OK,                 "S_OK or NOERROR"               },
        { S_FALSE,              "S_FALSE"                       }
    }
};

CODETOSTR HSEtoStr = {
    5,
    {
        { HSE_STATUS_SUCCESS,           "HSE_STATUS_SUCCESS" },
        { ERROR_INVALID_INDEX,          "ERROR_INVALID_INDEX" },
        { ERROR_INSUFFICIENT_BUFFER,    "ERROR_INSUFFICIENT_BUFFER" },
        { ERROR_MORE_DATA,              "ERROR_MORE_DATA" },
        { ERROR_NO_DATA,                "ERROR_NO_DATA" }
    }
};

CODETOSTR ErrtoStr = {
    4,
    {
        { ERROR_INVALID_PARAMETER, "ERROR_INVALID_PARAMETER" },
        { HSE_STATUS_SUCCESS_AND_KEEP_CONN, "HSE_STATUS_SUCCESS_AND_KEEP_CONN" },
        { HSE_STATUS_PENDING, "HSE_STATUS_PENDING" },
        { HSE_STATUS_ERROR,   "HSE_STATUS_ERROR" }
    }
};


// local functions
const char *FindResult( 
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult );



#ifdef DEBUG    /***********************************************************/

// globals
DWORD   g_dwTraceFlag = // flag used to turn on/off certain debug msgs.
    // 0x00000000;
    TF_PARSE | TF_FUNC;
    // TF_ALWAYS;


//
// What:    IsTraceFlagSet
//
// Desc:    Tests to see is any of the flags in dwFlag
//          are set in g_dwTraceFlag.
// 
// In:      dwFlag are the flags to be tested.
//
// Return:  TRUE if flag is set or if dwFlags == TF_ALWAYS.
//          Otherwise, we return FALSE.
//
BOOL CDECL IsTraceFlagSet( DWORD dwFlag )
{
    return ( 
        ( (dwFlag & g_dwTraceFlag) == dwFlag ) ? 
        TRUE : 
        ( ( dwFlag == TF_ALWAYS ) ? 
            TRUE : 
            FALSE )
    );
}

//
// What:    AssertMsg
//
// Desc:    Debugging output with stop condition.
//
BOOL CDECL AssertMsg(
    BOOL fShouldBeTrue,
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszStatement )
{
    if ( !fShouldBeTrue )
    {
        CHAR ach[ 1024 + 40 ];    // Largest path plus extra
        
        wsprintf( ach, "Assert: %s (%u): %s",
            pszFile, dwLine, pszStatement );
        OutputDebugString( ach );
        OutputDebugString( s_szNewline );
    }
    return !fShouldBeTrue;

} // AssertMsg( )

//
// What:    TraceMsg
//
// Desc:    Debugging output with conditional flags (see 
//          DEBUG.H for flags).
//
void CDECL TraceMsg( 
    DWORD dwFlag, 
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;

    if ( IsTraceFlagSet( dwFlag ) )
    {
        int cch;

        StrCpy( ach, "Trace: " );

        cch = lstrlen( ach );
        va_start( vArgs, pszMsg );
        wvsprintf( &ach[ cch ], pszMsg, vArgs );
        va_end( vArgs );

        OutputDebugString( ach );
        OutputDebugString( s_szNewline );
    }

} // TraceMsg( )



// 
// What:    TraceMsgResult
//
// Desc:    Debugging output with conditional flags and
//          it displays the HRESULT in "English".
//
void CDECL TraceMsgResult( 
    DWORD dwFlag, 
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;

    if ( IsTraceFlagSet( dwFlag ) )
    {
        int cch;

        StrCpy( ach, "Trace: " );

        cch = lstrlen( ach );
        va_start( vArgs, pszMsg );
        wvsprintf( &ach[ cch ], pszMsg, vArgs );
        va_end( vArgs );

        cch = lstrlen( ach );
        wsprintf( &ach[ cch ], " = %s", FindResult( lpCodeToStr, dwResult ) );

        OutputDebugString( ach );
        OutputDebugString( s_szNewline );
    }
} // TraceMsgResult( )



#endif // DEBUG     /********************************************************/



/*********************************************************

    These are for debugging the GET/POST as well as 
    debugging the parser.

*********************************************************/


//
// What:    DebugMsg
//
// Desc:    Debugging output
//
void CDECL DebugMsg( 
    LPSTR lpszOut,
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;
    int cch;

    va_start( vArgs, pszMsg );
    wvsprintf( ach, pszMsg, vArgs );
    va_end( vArgs );

#ifdef DEBUG
    OutputDebugString( ach );
    OutputDebugString( s_szNewline );
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, ach );
    }

} // DebugMsg( )



// 
// What:    DebugMsgResult
//
// Desc:    Debugging output displaying the dwResult in "English".
//
void CDECL DebugMsgResult( 
    LPSTR lpszOut,
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... )
{
    CHAR ach[ 1024 + 40 ];    // Largest path plus extra
    va_list vArgs;
    int cch;

    va_start( vArgs, pszMsg );
    wvsprintf( ach, pszMsg, vArgs );
    va_end( vArgs );

    cch = lstrlen( ach );
    wsprintf( &ach[ cch ], " = %s", FindResult( lpCodeToStr, dwResult ) );

#ifdef DEBUG
    OutputDebugString( ach );
    OutputDebugString( s_szNewline );
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, ach );
    }

} // DebugMsgResult( )


//
// What:    LogMsg
//
// Desc:    Append text to be written to server log.
//
void CDECL LogMsg( 
    LPSTR lpszLog,
    LPSTR lpszOut,
    LPCSTR pszMsg, 
    ... )
{
    va_list vArgs;

    char szBuffer[ 1024 + 40 ];

    va_start( vArgs, pszMsg );
    wvsprintf( szBuffer, pszMsg, vArgs );
    va_end( vArgs );

#ifdef DEBUG
    if ( lstrlen( szBuffer ) >= HSE_LOG_BUFFER_LEN )
    {
        OutputDebugString( "Log overflow=" );
        OutputDebugString( szBuffer );
        OutputDebugString( s_szNewline );
    } 
    else 
    {
        StrCpy( lpszLog, szBuffer );
        OutputDebugString( "Log Message= " );
        OutputDebugString( lpszLog );
        OutputDebugString( s_szNewline );
    }
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, szBuffer );
        StrCat( lpszOut, s_szNewline );
    }

} // LogMsg( )

// 
// What:    LogMsgResult
//
// Desc:    Append text to be written to server log and appends an english
//              translation to the dwResult code.
//
void CDECL LogMsgResult( 
    LPSTR lpszLog, 
    LPSTR lpszOut,
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult, 
    LPCSTR pszMsg, 
    ... )
{
    va_list vArgs;

    int cch;
    char szBuffer[ 1024 + 40 ];

    va_start( vArgs, pszMsg );
    wvsprintf( szBuffer, pszMsg, vArgs );
    va_end( vArgs );

    cch = lstrlen( szBuffer );
    wsprintf( &szBuffer[ cch ], " = %s", FindResult( lpCodeToStr, dwResult ) );

#ifdef DEBUG
    if ( lstrlen( szBuffer ) >= HSE_LOG_BUFFER_LEN )
    {
        OutputDebugString( "Log overflow=" );
        OutputDebugString( szBuffer );
        OutputDebugString( s_szNewline );
    } 
    else 
    {
        StrCpy( lpszLog, szBuffer );
        OutputDebugString( "Log Message= " );
        OutputDebugString( lpszLog );
        OutputDebugString( s_szNewline );
    }
#endif // DEBUG

    if ( lpszOut )
    {
        StrCat( lpszOut, szBuffer );
        StrCat( lpszOut, s_szNewline );
    }
} // LogMsgResult( )

//
// What:    FindHResult
//
// Desc:    Searches for a string for a HRESULT. If not found
//          it will display the HEX value.
//
const char *FindResult( 
    LPCODETOSTR lpCodeToStr, 
    DWORD dwResult )
{
    static char szResult[ 11 ];  // just enough for "0x00000000" + NULL

    for( DWORD i = 0 ; i < lpCodeToStr->dwCount ; i++ )
    {
        if ( lpCodeToStr->ids[ i ].dwCode == dwResult )
        {
            return lpCodeToStr->ids[ i ].lpDesc;
        }
    } // for i

    wsprintf( szResult, "%x", dwResult );

    return szResult;

} // FindHResult( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\multpars.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// MULTPARS.H - Multipart parser (CMultipartParse) header
//


// Turn this on to compile a file saving version
// #define FILE_SAVE

#ifndef _MULTPARS_H_
#define _MULTPARS_H_

enum LEXICON {
    LEX_UNKNOWN,
    LEX_SPACE,
    LEX_CRLF,
    LEX_BEGIN_COMMENT,
    LEX_END_COMMENT,
    LEX_QUOTE,
    LEX_SEMICOLON,
    LEX_SLASH,
    // Body keywords
    LEX_CONTENTDISP,
    LEX_CONTENTTYPE,
    // Field IDs
    LEX_NAMEFIELD,
    LEX_FILENAMEFIELD,
    // MIME types
    LEX_MULTIPART,
    LEX_TEXT,
    LEX_APPLICATION,
    LEX_AUDIO,
    LEX_IMAGE,
    LEX_MESSAGE,
    LEX_VIDEO,
    LEX_MIMEEXTENSION,
    // MIME subtypes
    LEX_FORMDATA,
    LEX_ATTACHMENT,
    LEX_MIXED,
    LEX_PLAIN,
    LEX_XMSDOWNLOAD,
    LEX_OCTETSTREAM,
    LEX_BINARY,
    // Boundary
    LEX_BOUNDARY,   // "CR/LF" ended boundary string
    LEX_EOT,        // double-dashed ended boundary string
    LEX_STARTBOUNDARY // boundary string missing first CR/LF
};

typedef struct {
    LPSTR   lpszName;       // token name
    LEXICON eLex;           // token value
    DWORD   cLength;        // length of lpszName, filled in at runtime, 
                            // should be ZERO in table def
    DWORD   dwColor;        // debugging color to be used
    LPSTR   lpszComment;    // debugging comment to be displayed
} PARSETABLE, *LPPARSETABLE;

typedef struct {
    LEXICON eContentDisposition;
    LPSTR   lpszNameField;
    LPSTR   lpszFilenameField;
    LPSTR   lpszBodyContents;
    DWORD   dwContentType;
    DWORD   dwContentSubtype;
} BODYHEADERINFO, *LPBODYHEADERINFO;

#define LPBHI LPBODYHEADERINFO
    

class CMultipartParse : public CBase
{
public:
    CMultipartParse( LPECB lpEcb, LPSTR *lppszOut, LPSTR *lppszDebug, LPDUMPTABLE lpDT );
    ~CMultipartParse( );

    // Starts parsing data using infomation from server headers
    BOOL PreParse( LPBYTE lpbData, LPDWORD lpdwParsed );

private:
    LPBYTE  _lpbData;                   // Memory containing send data
    LPBYTE  _lpbParse;                  // Current parse location into _lpbData
    LPBYTE  _lpbLastParse;              // Last location of Lex parsing

    LPSTR   _lpszBoundary;              // Boundary string
    DWORD   _cbBoundary;                // Boundary string length

    // Debugging Data dump
    DWORD       _cbDT;                  // Counter

    // Lex
    LEXICON Lex( );                         // finds next Lex
    BOOL    BackupLex( LEXICON dwLex );     // moves back one Lex
    LPSTR   FindTokenName( LEXICON dwLex ); // finds Lex's name
    BOOL    GetToken( );                    // moves post a token of valid
                                            // header characters

    // states
    BOOL ParseBody( );                  // initial state
    BOOL BodyHeader( );
    BOOL ContentDisposition( LPBODYHEADERINFO lpBHI );
    BOOL ContentType( LPBODYHEADERINFO lpBHI );
    BOOL BodyContent( LPBODYHEADERINFO lpBHI );

    // utilities
    BOOL GetBoundaryString( LPBYTE lpbData );
    BOOL GetQuotedString( LPSTR *lppszBuf );
    BOOL HandleComments( );
#ifndef FILE_SAVE
    BOOL MemoryCompare( LPBYTE lpbSrc1, LPBYTE lpbSrc2, DWORD dwSize );
#endif
    BOOL FindNextBoundary( LPDWORD lpdwSize );

    // files
    BOOL HandleFile( LPSTR lpszFilename );
#ifndef FILE_SAVE
    BOOL FileCompare( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize );
#else // FILE_SAVE
    BOOL FileSave( LPBYTE lpbStart, LPSTR lpszFilename, DWORD dwSize );
#endif // FILE_SAVE
    BOOL FixFilename( LPSTR lpszFilename, LPSTR *lppszNewFilename );

    CMultipartParse( );

}; // CMultipartParse

#endif // _MULTPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\util\util.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: util.cpp
//
//  Contents: commonly used utility functions, etc.
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "util.h"
#define INITGUID
#include <initguid.h>  // needed for precomp headers...
#include <ddrawex.h>
#include "tokens.h"
#include <ras.h>
#include <dispex.h>
#include <shlguid.h>
#include <shlwapip.h>
#include "timevalue.h"

// Need this #define because global headers use some of the deprecated functions. Without this
// #define, we can't build unless we touch code everywhere.
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"
#undef STRSAFE_NO_DEPRECATE

//defined for VariantToTime conversion function
#define SECPERMINUTE 60   //seconds per minute
#define SECPERHOUR   3600 //seconds per hour

static IDirectDraw * g_directdraw = NULL;
static CritSect * g_ddCS = NULL;
static CritSect * g_STLCS = NULL;
static long g_lConnectSpeed = -1;
static HRESULT g_hrConnectResult = S_OK;

DISPID GetDispidAndParameter(IDispatch *pidisp, LPCWSTR wzAtributeNameIn, long *lParam);

#define MAX_REG_VALUE_LENGTH   50

#if DBG == 1

//+------------------------------------------------------------------------
//
//  Implement THR and IGNORE_HR for TIME code
//
//  This is to allow tracing of TIME-only THRs and IGNORE_HRs. Trident's THR
//  and IGNORE_HR output is too polluted to allow TIME failures to be easily detected.
//
//-------------------------------------------------------------------------
DeclareTag(tagTimeTHR, "TIME", "Trace THR and IGNORE_HR");

//+-----------------------------------------------------------------------------------
//
//  Member:     ::THRTimeImpl
//
//  Synopsis:   Implements the THR macro for TIME. This function should never be used directly.
//
//  Arguments:
//
//  Returns:    HRESULT passed in
//
//------------------------------------------------------------------------------------
HRESULT
THRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine)
{
    if (FAILED(hr))
    {
        TraceTag((tagTimeTHR, "THR: FAILURE of \"%s\" at %s:%d <hr = 0x%x>", pchExpression, pchFile, nLine, hr));
    }
    return hr;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     ::IGNORE_HRTimeImpl
//
//  Synopsis:   Implements the IGNORE_HR macro for TIME. This function should never be used directly.
//
//  Arguments:
//
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
void
IGNORE_HRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine)
{
    if (FAILED(hr))
    {
        TraceTag((tagTimeTHR, "IGNORE_HR: FAILURE of \"%s\" at %s:%d <hr = 0x%x>", pchExpression, pchFile, nLine, hr));
    }
}

#endif // if DBG == 1



IDirectDraw *
GetDirectDraw()
{
    HRESULT hr;

    {
        CritSectGrabber _csg(*g_ddCS);

        if (g_directdraw == NULL)
        {
            CComPtr<IDirectDrawFactory> lpDDF;

            hr = CoCreateInstance(CLSID_DirectDrawFactory,
                                  NULL, CLSCTX_INPROC_SERVER,
                                  IID_IDirectDrawFactory,
                                  (void **) & lpDDF);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDrawFactory object");
                return NULL;
            }

            hr = lpDDF->CreateDirectDraw(NULL, NULL, DDSCL_NORMAL, 0, NULL, &g_directdraw); //lint !e620

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDraw object");
                return NULL;
            }

            hr = g_directdraw->SetCooperativeLevel(NULL,
                                                   DDSCL_NORMAL); //lint !e620

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not set DirectDraw properties");
                g_directdraw->Release();
                g_directdraw = NULL;
                return NULL;
            }

        }
    }

    return g_directdraw;
}

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT * pf,
                       bool vidmem,
                       LONG width, LONG height)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH; //lint !e620
    ddsd.dwWidth  = width;
    ddsd.dwHeight = height;

    if (pf)
    {
        // KEVIN: if you want the pixelformat of the surface tomatach the
        // screen, comment out this line.
        ddsd.dwFlags |= DDSD_PIXELFORMAT; //lint !e620

        ddsd.ddpfPixelFormat = *pf;
    }

    // DX3 bug workaround (bug 11166): StretchBlt doesn't always work
    // for hdc's we get from ddraw surfaces.  Need to specify OWNDC
    // in order for it to work.
    ddsd.ddsCaps.dwCaps =
        (DDSCAPS_3DDEVICE |                                                         //lint !e620
         DDSCAPS_OFFSCREENPLAIN |                                                   //lint !e620
         (vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC));    //lint !e620

    IDirectDraw * dd = ddraw;

    if (!dd)
    {
        dd = GetDirectDraw();

        if (!dd)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    hr = dd->CreateSurface( &ddsd, surfPtrPtr, NULL );

    if (FAILED(hr))
    {
        *surfPtrPtr = NULL;
    }

  done:
    return hr;
}

inline LONG Width(LPRECT r) { return r->right - r->left; }
inline LONG Height(LPRECT r) { return r->bottom - r->top; }

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect)
{
    HRESULT hr;

    HDC destDC;
    hr = DDSurf->GetDC(&destDC);

    if (SUCCEEDED(hr))
    {
        HRGN hrgn;

        hrgn = CreateRectRgn(0,0,1,1);

        if (hrgn == NULL)
        {
            hr = GetLastError();
        }
        else
        {
            if (GetClipRgn(srcDC, hrgn) == ERROR)
            {
                hr = GetLastError();
            }
            else
            {
                TraceTag((tagError,
                          "CopyDCToDdrawSurface - prcDestRect(%d, %d, %d, %d)",
                          prcDestRect->left,prcDestRect->top,prcDestRect->right,prcDestRect->bottom));

                RECT targetRect;
                RECT rgnRect;

                GetRgnBox(hrgn, &rgnRect);

                TraceTag((tagError,
                          "CopyDCToDdrawSurface - rgn box(%d, %d, %d, %d)",
                          rgnRect.left,rgnRect.top,rgnRect.right,rgnRect.bottom));

                if (IntersectRect(&targetRect, &rgnRect, prcDestRect))
                {
                    TraceTag((tagError,
                              "CopyDCToDdrawSurface - targetrect(%d, %d, %d, %d)",
                              targetRect.left,targetRect.top,targetRect.right,targetRect.bottom));

                    {
                        BitBlt(destDC,
                               prcDestRect->left,
                               prcDestRect->top,
                               Width(prcDestRect),
                               Height(prcDestRect),

                               srcDC,
                               prcSrcRect->left,
                               prcSrcRect->top,
                               SRCCOPY);

                        //SelectClipRgn(destDC, NULL);
                    }
                }
            }

            DeleteObject(hrgn);
        }

        DDSurf->ReleaseDC(destDC);
    }

    return hr;
}

//////////////////////

CritSect::CritSect()
{
    InitializeCriticalSection(&_cs) ;
}

CritSect::~CritSect()
{
    DeleteCriticalSection(&_cs) ;
}

void
CritSect::Grab()
{
    EnterCriticalSection(&_cs) ;
}

void
CritSect::Release()
{
    LeaveCriticalSection(&_cs) ;
}

////// CritSect Grabber //////

CritSectGrabber::CritSectGrabber(CritSect& cs, bool grabIt)
: _cs(cs), grabbed(grabIt)
{
    if (grabIt) _cs.Grab();
}

CritSectGrabber::~CritSectGrabber()
{
    if (grabbed) _cs.Release();
}

//// Misc ///

//const wchar_t * TIMEAttrPrefix = L"t:";

BSTR
CreateTIMEAttrName(LPCWSTR str)
{
    ////////////////////////////////////////////////////////////
    // REMOVE DEPENDENCY ON t:
    // This code is left in in case we ever need to modify the attribute names
    // again.
    ////////////////////////////////////////////////////////////
    //BSTR bstr = NULL;
    //
    //LPWSTR newstr = (LPWSTR) _alloca(sizeof(wchar_t) *
    //                                 (lstrlenW(str) +
    //                                  lstrlenW(TIMEAttrPrefix) +
    //                                  1));
    //
    //if (newstr == NULL)
    //{
    //    goto done;
    //}
    //
    //StrCpyW(newstr, TIMEAttrPrefix);
    //StrCatW(newstr, str);
    //
    //bstr = SysAllocString(newstr);
    ////////////////////////////////////////////////////////////

  done:
    return SysAllocString(str);
}

HRESULT
GetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 LONG lFlags,
                 VARIANT * value)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(elm->getAttribute(bstr,lFlags,value));

    SysFreeString(bstr);

  done:
    return hr;
}

HRESULT
SetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 VARIANT value,
                 LONG lFlags)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(elm->setAttribute(bstr,value,lFlags));

    SysFreeString(bstr);

  done:
    return hr;
}

//
// Initialization
//

/*lint ++flb */

bool
InitializeModule_Util()
{
    g_ddCS = new CritSect;
    g_STLCS = new CritSect;

    if (NULL == g_ddCS || NULL == g_STLCS)
    {
        return false;
    }

    return true;
}

void
DeinitializeModule_Util(bool bShutdown)
{
    delete g_ddCS;
    g_ddCS = NULL;

    delete g_STLCS;
    g_STLCS = NULL;
}

/*lint --flb */

///////////////////////////////////////////////////////////
// Name: VariantToBool
//
// Parameters:   VARIANT var      - a variant to convert to a
//                                  BOOL value.
//
// Abstract:
//    This function coverts any VARIANT to a boolean value using
//    TRUE = 1 and FALSE = 0.  (COM uses TRUE = -1 and FALSE = 0).
//    Any VARIANT that can be coerced to a BOOL is and the coerced
//    value is returned.  If the VARIANT cannot be coerced, FALSE
//    is returned.
///////////////////////////////////////////////////////////
bool VariantToBool(VARIANT var)
{
    //if the value is already a bool return it.
    if (var.vt == VT_BOOL)
    {
        return var.boolVal == FALSE ? false : true;
    }
    else  //otherwise convert it to VT_BOOL
    {
        VARIANT vTemp;
        HRESULT hr;

        VariantInit(&vTemp);
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BOOL);
        if (SUCCEEDED(hr)) //if it can be converted return it
        {
            return vTemp.boolVal == FALSE ? false : true;
        }
        else //if it can't be converted return false
        {
            return false;
        }
    }

}


///////////////////////////////////////////////////////////
// Name: VariantToFloat
//
// Parameters:   VARIANT var      - a variant to convert to a
//                                  float value.  This can contain
//                                  the special cases 'FOREVER' and
//                                  'INDEFINITE'.
//
// Abstract:
//
///////////////////////////////////////////////////////////
float VariantToFloat(VARIANT var, bool bAllowIndefinite, bool bAllowForever)
{
    float fResult = INVALID;

    if (var.vt == VT_R4)
    {
        fResult = var.fltVal;
        goto done;
    }

    VARIANT vTemp;
    HRESULT hr;

    VariantInit(&vTemp);
    hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
    if (SUCCEEDED(hr))
    {
        fResult = vTemp.fltVal;
        goto done;
    }

    //Check to see if it is 'FOREVER' and 'INDEFINITE
    //Should these be case sensitive?
    if (bAllowForever)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, L"FOREVER") == 0)
            {
                fResult = FOREVER;
                goto done;
            }
        }
    }
    if (bAllowIndefinite)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, WZ_INDEFINITE) == 0)
            {
                fResult = INDEFINITE;
                goto done;
            }
        }
    }

  done:
    return fResult;

}

///////////////////////////////////////////////////////////
// Name: VariantToTime
//
// Parameters:   VARIANT var      - a VARIANT to convert to a
//                                  from a time value to seconds.
//                                    this can take the form of
//                                    HH:MM:SS.DD
//                                    MM:SS.DD
//                                    SS.DD
//                                    DD.DDs
//                                    DD.DDm
//                                    DD.DDh
//                                    and may be preceeded by a + or -
//
//
//
// Abstract:
//    Converts the incoming variant to a BSTR and parses for valid
//    clock values.  It passes the value back in retVal and returns
//    S_OK or E_INVALIDARG in the case of incorrect input. If the
//    return value is E_INVALIDARG, *retVal is passed back as
//    INDEFINITE.
///////////////////////////////////////////////////////////
HRESULT VariantToTime(VARIANT var, float *retVal, long *lframe, bool *fisFrame)
{

    HRESULT hr = S_OK;
    OLECHAR *szTime;
    OLECHAR *szTimeBase = NULL;
    bool bPositive = TRUE;
    int nHour = 0;
    int nMin = 0;
    int nSec = 0;
    float fFSec = 0;
    VARIANT vTemp;

    if(fisFrame)
    {
        *fisFrame = false;
    }

    //convert the parameter to a BSTR
    VariantInit(&vTemp);
    if (var.vt != VT_BSTR)
    {
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }
    else
    {
        hr = VariantCopy(&vTemp, &var);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }

    hr = S_OK;

    //convert to a char array. If not possible, return error.
    szTimeBase = TrimCopyString(vTemp.bstrVal);

    if (szTimeBase == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    szTime = szTimeBase;

    if (IsIndefinite(szTime))
    {
        *retVal = INDEFINITE;
        goto done;
    }

    //check for +/- if none, assume +
    if (*szTime == '-')
    {
        bPositive = false;
        szTime++;
    }
    else if (*szTime == '+')
    {
        szTime++;
    }

    //check for invalid and err out
    if (*szTime == '\0')
    {
        *retVal = INVALID;
        goto done;
    }

    //get first set of numbers
    while (*szTime >= '0' && *szTime <= '9')
    {
        nSec = nSec * 10 + (*szTime - '0');
        szTime++;
    }
    if (*szTime == '\0')    //if none use time as seconds
    {
        *retVal = bPositive ? nSec : -nSec; //this is the end so return;
        goto done;
    }
    else if (*szTime == '.')  //if it is a '.' treat this as the fractional part
    {
        float nDiv = 10.0;
        szTime++;
        while (*szTime >= '0' && *szTime <= '9')
        {
            fFSec = fFSec + (*szTime - '0') / nDiv;
            szTime++;
            nDiv *= 10;
        }
        if (*szTime == '\0')
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1);
            goto done;
        }
    }

    if (*szTime == 'h') //if "h" use time as hours
    {
        nHour = nSec;
        nSec = 0;
        szTime++;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nHour + fFSec) * SECPERHOUR) * (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 'i' && *(szTime + 2) == 'n') //if "min" use time as minutes
    {
        nMin = nSec;
        nSec = 0;
        szTime += 3;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nMin + fFSec) * SECPERMINUTE)* (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 's') //if "s" use time as seconds
    {
        szTime++;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 's') //if "ms" use time as milliseconds
    {
        fFSec = (fFSec + nSec) / 1000.0;
        szTime += 2;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = fFSec * (bPositive? 1 : -1); //convert minutes to seconds
        }
        goto done;
    }
    else if (*szTime == 'f') //if "s" use time as seconds
    {
        if((fisFrame == NULL) || (lframe == NULL))
        {
            hr = E_FAIL;
            goto done;
        }
        szTime++;
        if (*szTime != '\0')
        {
            *lframe = INVALID;
        }
        else
        {
            *lframe = (nSec) * (bPositive? 1 : -1);
            *fisFrame = true;
        }
        goto done;
    }
    else if (*szTime == ':' && fFSec == 0)
    {
        //handle the HH:MM:SS format here
        nMin = nSec;
        nSec = 0;

        //next part must be 2 digits
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = *szTime - '0';
        }
        else
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = nSec * 10 + (*szTime - '0');
        }
        else
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime == ':')
        {
            nHour = nMin;
            nMin = nSec;
            nSec = 0;
            //next part must be 2 digits
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = *szTime - '0';
            }
            else
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = nSec * 10 + (*szTime - '0');
            }
            else
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
        }

        if (*szTime == '.')
        {
            //handle fractional part
            float nDiv = 10.0;
            szTime++;
            while ((*szTime >= '0') && (*szTime <= '9'))
            {
                fFSec = fFSec + ((*szTime - '0') / nDiv);
                szTime++;
                nDiv *= 10;
            }
        }

        //check to be sure the string terminated
        if (*szTime != '\0')
        {
            *retVal = INVALID;
            goto done;
        }

        if (nSec < 00 || nSec > 59 || nMin < 00 || nMin > 59)
        {
            *retVal = INVALID;
            goto done;
        }
        *retVal = (((float)(nHour * SECPERHOUR + nMin * SECPERMINUTE + nSec) + fFSec)) * (bPositive? 1 : -1); //lint !e790
    }
    else
    {
        *retVal = INVALID;
    }
  done:

    if (szTimeBase != NULL)
    {
        delete [] szTimeBase;
    }

    if (vTemp.vt == VT_BSTR)
    {
        VariantClear(&vTemp);
    }

    if (*retVal == INVALID) //lint !e777
    {
        *retVal = INDEFINITE;
        hr = E_INVALIDARG;
    }

    return hr;

}

///////////////////////////////////////
// Name: IsIndefinite
//
// Abstract:
//   Determines in a case-insensitive manner
//   if the string szTime is 'INDEFINITE'.
///////////////////////////////////////
BOOL IsIndefinite(OLECHAR *szTime)
{
    BOOL bResult = FALSE;

    if (StrCmpIW(szTime, L"INDEFINITE") == 0)
    {
        bResult = TRUE;
    }

  done:
    return bResult;
}

//+-----------------------------------------------------------------------
//
//  Member:    EnsureComposerSite
//
//  Overview:  Ensure that there is a composer site behavior present on an
//             element
//
//  Arguments: The target element
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
EnsureComposerSite (IHTMLElement2 *pielemTarget, IDispatch **ppidispSite)
{
    HRESULT hr;
    CComPtr<IAnimationComposerSite> spComposerSite;

    Assert(NULL != ppidispSite);

    hr = FindBehaviorInterface(WZ_REGISTERED_ANIM_NAME,
                               pielemTarget,
                               IID_IAnimationComposerSite,
                               reinterpret_cast<void **>(&spComposerSite));

    if (S_OK != hr)
    {
        CComPtr<IAnimationComposerSiteFactory> spSiteFactory;

        hr = THR(CoCreateInstance(CLSID_AnimationComposerSiteFactory,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IAnimationComposerSiteFactory,
                                  reinterpret_cast<void**>(&spSiteFactory)));
        if (FAILED(hr))
        {
            goto done;
        }

        {
            CComVariant varComposerSiteFactory(static_cast<IUnknown *>(spSiteFactory));
            long nCookie;

            hr = THR(pielemTarget->addBehavior(WZ_SMILANIM_STYLE_PREFIX,
                                               &varComposerSiteFactory,
                                               &nCookie));
            if (FAILED(hr))
            {
                goto done;
            }
        }

        hr = FindBehaviorInterface(WZ_REGISTERED_ANIM_NAME,
                                   pielemTarget,
                                   IID_IAnimationComposerSite,
                                   reinterpret_cast<void **>(&spComposerSite));
    }

    Assert(spComposerSite != NULL);
    if (FAILED(hr) || (spComposerSite == NULL))
    {
        goto done;
    }

    hr = THR(spComposerSite->QueryInterface(IID_TO_PPV(IDispatch, ppidispSite)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // EnsureComposerSite


HRESULT
AddBodyBehavior(IHTMLElement* pBaseElement)
{
    CComPtr<IHTMLElement2>      spBodyElement2;
    CComPtr<ITIMEFactory>       spTimeFactory;
    CComPtr<ITIMEBodyElement>   spBodyElem;

    HRESULT hr;

    hr = THR(GetBodyElement(pBaseElement,
                            IID_IHTMLElement2,
                            (void **) &spBodyElement2));
    if (FAILED(hr))
    {
        // If the QI failed then simply return assuming we are using IE4
        if (E_NOINTERFACE == hr)
        {
            hr = S_OK;
        }

        goto done;
    }

    // here if we need to parent to some other page body i.e. pBodyElement != NULL
    // we no longer create a new body. We initialize variables needed for this parenting.

    if (IsTIMEBehaviorAttached(spBodyElement2))
    {
        // someone's already put a TIMEBody behavior on the time body.  bail out.
        hr = S_OK;
        goto done;
    }

    // This is really ugly but I guess necessary
    hr = THR(CoCreateInstance(CLSID_TIMEFactory,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITIMEFactory,
                              (void**)&spTimeFactory));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        CComVariant varTIMEFactory((IUnknown *) spTimeFactory);
        long nCookie;

        hr = THR(spBodyElement2->addBehavior(WZ_TIME_STYLE_PREFIX,
                                             &varTIMEFactory,
                                             &nCookie));
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
GetBodyElement(IHTMLElement* pElem, REFIID riid, void** ppBE)
{
    HRESULT hr = S_OK;

    CComPtr<IDispatch>         pBodyDispatch;
    CComPtr<IHTMLDocument2>    pDocument2;
    CComPtr<IHTMLElement>      pBodyElement;

    Assert(NULL != pElem);

    hr = THR(pElem->get_document(&pBodyDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pBodyDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocument2->get_body(&pBodyElement));

    // We need to check the point aswell as the hr since we get lied to by Trident sometimes.
    if (FAILED(hr) || !pBodyElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pBodyElement->QueryInterface(riid, ppBE));
    if (FAILED(hr))
    {
        goto done;
    }

    // pass thru:
  done:
    return hr;
}

// ------------------------------------------------------------------------------

HRESULT
FindBehaviorInterface(LPCWSTR pwszName,
                      IDispatch *pHTMLElem,
                      REFIID riid,
                      void **ppRet)
{
    CComVariant varResult;
    HRESULT hr;

    Assert(pHTMLElem != NULL);
    Assert(ppRet != NULL);

    // Don't use THR as this is expected to fail several times.
    hr = GetProperty(pHTMLElem, pwszName, &varResult);

    if (FAILED(hr))
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = THR(varResult.ChangeType(VT_DISPATCH));
    if (FAILED(hr))
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    if (V_DISPATCH(&varResult) == NULL)
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = V_DISPATCH(&varResult)->QueryInterface(riid, ppRet);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_NOINTERFACE);
}

HRESULT
FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem)
{
    HRESULT hr;
    CComPtr<IDispatch> spDispatch;

    if (NULL == pHTMLElem || NULL == ppTIMEElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(pHTMLElem->QueryInterface(IID_TO_PPV(IDispatch, &spDispatch)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(FindBehaviorInterface(WZ_REGISTERED_TIME_NAME,
                                  spDispatch,
                                  IID_ITIMEElement,
                                  reinterpret_cast<void**>(ppTIMEElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

// ------------------------------------------------------------------------------

// @@ Need to share code between the time class and here
// @@ that sniffs an element for a behavior.
bool
IsTIMEBehaviorAttached (IDispatch *pidispElem)
{
    HRESULT hr;
    CComPtr<ITIMEElement> spTIMEElm;

    hr = FindBehaviorInterface(WZ_REGISTERED_TIME_NAME,
                               pidispElem,
                               IID_ITIMEElement,
                               reinterpret_cast<void **>(&spTIMEElm));

    return (S_OK == hr);
} // IsTIMEBehaviorAttached

// ------------------------------------------------------------------------------

// @@ Need to share code between the time class and here
// @@ that sniffs an element for a behavior.
bool
IsComposerSiteBehaviorAttached (IDispatch *pidispElem)
{
    HRESULT hr;
    CComPtr<IAnimationComposerSite> spComposerSite;

    hr = FindBehaviorInterface(WZ_REGISTERED_ANIM_NAME,
                               pidispElem,
                               IID_IAnimationComposerSite,
                               reinterpret_cast<void **>(&spComposerSite));

    return (S_OK == hr);
} // IsComposerSiteBehaviorAttached

// ------------------------------------------------------------------------------

LPWSTR
TIMEGetLastErrorString()
{
    HRESULT hr = S_OK;
    CComPtr<IErrorInfo> pErrorInfo;
    CComBSTR bstrDesc;
    LPWSTR pDesc = NULL;

    hr = GetErrorInfo(0, &pErrorInfo);
    if (FAILED(hr))
    {
        goto done;
    }

    if (pErrorInfo == NULL)
    {
        goto done;
    }

    hr = pErrorInfo->GetDescription(&bstrDesc);
    if (FAILED(hr))
    {
        goto done;
    }

    pDesc = NEW WCHAR [bstrDesc.Length() + 1];
    if (pDesc == NULL)
    {
        goto done;
    }

    ZeroMemory(pDesc, (bstrDesc.Length() + 1) * sizeof(WCHAR));
    memcpy(pDesc, bstrDesc, bstrDesc.Length() * sizeof(WCHAR));

  done:
    return pDesc;
}

HRESULT
TIMEGetLastError()
{
    DWORD dwHRes = 0;
    HRESULT hr = S_OK;

    CComPtr<IErrorInfo> pErrorInfo;

    hr = GetErrorInfo(0, &pErrorInfo);

    if (FAILED(hr))
    {
        return hr;
    }

    if (pErrorInfo != NULL)
    {
        hr = pErrorInfo->GetHelpContext(&dwHRes);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return (HRESULT)dwHRes;
}

HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg)
{
    USES_CONVERSION; //lint !e522
    HINSTANCE hInst = 0;
    TCHAR szDesc[1024];
    szDesc[0] = NULL;
    // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
    if (ULONG_PTR( msg ) < 0x10000) // id
    {
        UINT nID = LOWORD((ULONG_PTR)msg);
        _ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
        if (LoadString(hInst, nID, szDesc, 1024) == 0)
        {
            _ASSERTE(FALSE);
            lstrcpy(szDesc, _T("Unknown Error"));
        }
        //this is a lint problem with the macro expansion.
        msg = T2OLE(szDesc); //lint !e506
        if (hr == 0)
        {
            //another lint problem with the macro expansion
            hr = MAKE_HRESULT(3, FACILITY_ITF, nID); //lint !e648
        }
    }
    CComPtr<ICreateErrorInfo> pICEI;
    if (SUCCEEDED(CreateErrorInfo(&pICEI)))
    {
        CComPtr<IErrorInfo> pErrorInfo;
        pICEI->SetGUID(GUID_NULL);
        LPOLESTR lpsz;
        ProgIDFromCLSID(CLSID_TIME, &lpsz);
        if (lpsz != NULL)
        {
            pICEI->SetSource(lpsz);
        }

        pICEI->SetHelpContext(hr);

        CoTaskMemFree(lpsz);
        pICEI->SetDescription((LPOLESTR)msg);
        if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
        {
            SetErrorInfo(0, pErrorInfo);
        }
    }

    return (hr == 0) ? DISP_E_EXCEPTION : hr;
} //lint !e550


//////////////////////////////////////////////////////////////////////////////////////////////////
// String Parsing utilities
//////////////////////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------------------
//
//  Function:   ::StringToTokens
//
//  Synopsis:   Parses a string into tokens
//
//  Arguments:  [pstrString]        String to be parsed
//              [pstrSeparators]    String of separators
//              [paryTokens]        Array of tokens returned
//
//  Returns:    [S_OK]      If function completes successfully
//              Failure     Otherwise
//
//  Notes:      1. Assumes null terminated strings
//              2. Assumes separators are single characters
//              3. Implicitly uses NULL as a separator
//              4. Memory: If function returns success, caller should free memory in paryTokens
//              5. Perf hint: arrange separators in decreasing frequency-of-occurrance order.
//
//------------------------------------------------------------------------------------

HRESULT
StringToTokens(/*in*/ LPWSTR                   pstrString,
               /*in*/ LPWSTR                   pstrSeparators,
               /*out*/CPtrAry<STRING_TOKEN*> * paryTokens )
{
    HRESULT         hr = E_FAIL;
    UINT            uStringLength = 0;
    UINT            uSeparatorsLength = 0;
    UINT            uStringIndex;
    UINT            uSeparatorsIndex;
    WCHAR           chCurrChar;
    bool            fTokenBegun;
    bool            fIsSeparator;
    STRING_TOKEN *  pStringToken;

    CHECK_RETURN_NULL(pstrString);
    CHECK_RETURN_NULL(pstrSeparators);
    CHECK_RETURN_NULL(paryTokens);

    uStringLength = wcslen(pstrString);
    uSeparatorsLength = wcslen(pstrSeparators);

    // done if string is empty
    if (0 == uStringLength)
    {
        hr = S_OK;
        goto done;
    }

    // We make one pass through pstrString, going left to right, processing
    // one character per iteration.
    //
    // A simple state machine (3 states) is used:
    //
    // Initial state:       Token not begun and Token not ended (state 1)
    // Intermediate state:  Token begun and Token not ended     (state 2)
    // Final state:         Token begun and Token ended         (state 3)
    //
    // State transitions depend on whether the current character is a separator:
    //
    // State 1 --- separator -------> State 1
    // State 1 --- non-separator ---> State 2
    // State 2 --- non-separator ---> State 2
    // State 2 --- separator -------> State 3
    // State 3 ---------------------> State 1 (Done with current token, move on to next token)
    //

    // initialize to state 1
    fTokenBegun = false;
    pStringToken = NULL;

    // Loop through all characters of pstrString including terminating null, from left to right
    for (uStringIndex = 0;
         uStringIndex < uStringLength + 1;
         uStringIndex ++)
    {
        //
        // Determine if current char is a separator
        //

        chCurrChar = pstrString[uStringIndex];
        for (fIsSeparator = false,
             uSeparatorsIndex = 0;
             uSeparatorsIndex < uSeparatorsLength + 1;
             uSeparatorsIndex ++)
        {
            // break if current character is a separator
            if (chCurrChar == pstrSeparators[uSeparatorsIndex])
            {
                fIsSeparator = true;
                break;
            }
        }

        //
        // Token parsing logic
        //

        if (!fTokenBegun)
        {
            // We are in State 1
            if (fIsSeparator)
            {
                // remain in State 1
                continue;
            }
            else
            {
                // go to state 2
                fTokenBegun = true;

                // Since this is nulled out when we go from state 3 to 1, if this fails it means
                // we made an illegal state transition (2 -> 1) -- Bad!!!
                Assert(NULL == pStringToken);

                // create token struct
                pStringToken = new STRING_TOKEN;
                if (NULL == pStringToken)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                // store the index of the first char of the token
                (*pStringToken).uIndex = uStringIndex;
            }
        }
        else
        {
            // We are in State 2
            if (false == fIsSeparator)
            {
                // remain in state 2
                continue;
            }
            else
            {
                // We are in State 3 now

                // This should not be null because we *should* have come here from state 2.
                Assert(NULL != pStringToken);

                // Store length of token
                (*pStringToken).uLength = uStringIndex - (*pStringToken).uIndex;

                // append token to array
                hr = (*paryTokens).Append(pStringToken);
                if (FAILED(hr))
                {
                    delete pStringToken;
                    goto done;
                }

                // Null out the reference to indicate we're done with this token
                pStringToken = NULL;

                // go to state 1 (move on to next token)
                fTokenBegun = false;
            }
        }
    } // for

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        IGNORE_HR(FreeStringTokenArray(paryTokens));
    }
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Function:   ::TokensToString
//
//  Synopsis:   Creates a string from an array of tokens
//
//  Arguments:  [paryTokens]        Iput array of tokens
//              [pstrString]        Input string
//              [ppstrOutString]    Output string
//
//  Returns:    [S_OK]      If function completes successfully
//              Failure     Otherwise
//
//  Notes:      1. Assumes null terminated strings
//              2. Memory: If function returns success, caller should free memory in ppstrOutString
//
//------------------------------------------------------------------------------------


HRESULT TokensToString(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens,
                       /*in*/  LPWSTR                   pstrString,
                       /*out*/ LPWSTR *                 ppstrOutString)
{
    HRESULT hr = E_FAIL;
    LPWSTR pstrTemp = NULL;
    UINT i1;
    UINT ichTemp;
    UINT uSize;
    UINT uStringLength;
    UINT uTokenLength;
    STRING_TOKEN ** ppToken;
    LPWSTR pstrToken;

    CHECK_RETURN_NULL(paryTokens);
    CHECK_RETURN_NULL(pstrString);
    CHECK_RETURN_SET_NULL(ppstrOutString);

    // If this fires, it means we will leak pstrString
    Assert(pstrString != *ppstrOutString);

    uSize = (*paryTokens).Size();
    uStringLength = wcslen(pstrString);

    // done if ary or string is empty
    if (0 == uSize || 0 == uStringLength)
    {
        hr = S_OK;
        goto done;
    }

    // allocate memory for string (cannot be larger than pstrString)
    pstrTemp = new WCHAR[sizeof(WCHAR) * (uStringLength + 1)];
    if (NULL == pstrTemp)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    // store index at which to append
    ichTemp = 0;

    // loop over tokens in String 1
    for (i1 = 0, ppToken = (*paryTokens);
         i1 < uSize;
         i1++, ppToken++)
    {
        Assert(*ppToken);

        // alias ugly variables
        pstrToken = &(pstrString[(**ppToken).uIndex]);
        uTokenLength = (**ppToken).uLength;

        // append to difference string
        memcpy(&(pstrTemp[ichTemp]),
               pstrToken,
               sizeof(WCHAR) * uTokenLength);

        // update index of writable sub-string
        ichTemp += uTokenLength;

        // append blank space if this is not the last Token
        if (i1 < uSize - 1)
        {
            pstrTemp[ichTemp] = L' ';
            ichTemp ++;
        }
    }

    // null terminate pstrTemp
    if (ichTemp <= uStringLength)
    {
        pstrTemp[ichTemp] = NULL;
    }
    else
    {
        // Bad! no space to put NULL
        Assert(false);
        hr = E_FAIL;
        goto done;
    }

    // TODO: dilipk 8/31/99: reallocate string of correct size
    *ppstrOutString = pstrTemp;

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (NULL != pstrTemp)
        {
            delete [] pstrTemp;
            pstrTemp = NULL;
        }
    }
    return hr;
}



//+-----------------------------------------------------------------------------------
//
//  Function:   ::TokenSetDifference
//
//  Synopsis:   Computes set difference of two arrays of tokens. Set Difference of A & B
//              (A - B) is the set of elements in A that are not in B.
//
//  Arguments:  [paryTokens1]           Input array 1
//              [pstr1]                 Input string 1
//              [paryTokens2]           Input array 2
//              [pstr2]                 Input string 2
//              [paryTokens1Minus2]     Output array
//
//  Returns:    [S_OK]      If function completes successfully
//              Failure     Otherwise
//
//  Notes:      1. Assumes null terminated strings
//              2. Memory: If function returns success, caller should free memory in paryTokens1Minus2
//              3. Token comparisons are case insensitive
//
//------------------------------------------------------------------------------------


HRESULT TokenSetDifference(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens1,
                           /*in*/  LPWSTR                   pstr1,
                           /*in*/  CPtrAry<STRING_TOKEN*> * paryTokens2,
                           /*in*/  LPWSTR                   pstr2,
                           /*out*/ CPtrAry<STRING_TOKEN*> * paryTokens1Minus2)
{
    HRESULT hr = E_FAIL;
    UINT i1;
    UINT i2;
    UINT Size1;
    UINT Size2;
    STRING_TOKEN ** ppToken1;
    STRING_TOKEN ** ppToken2;
    LPWSTR pstrToken1;
    LPWSTR pstrToken2;
    UINT uToken1Length;
    UINT uToken2Length;
    STRING_TOKEN * pNewToken;
    bool fIsUnique;

    CHECK_RETURN_NULL(paryTokens1);
    CHECK_RETURN_NULL(paryTokens2);
    CHECK_RETURN_NULL(paryTokens1Minus2);
    CHECK_RETURN_NULL(pstr1);
    CHECK_RETURN_NULL(pstr2);

    // Protect against weirdness
    if (paryTokens1 == paryTokens1Minus2 ||
        paryTokens2 == paryTokens1Minus2)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    Size1 = (*paryTokens1).Size();
    Size2 = (*paryTokens2).Size();

    // done if either Token array is empty
    if (0 == Size1 || 0 == Size2)
    {
        hr = S_OK;
        goto done;
    }

    // loop over tokens in String 1
    for (i1 = 0, ppToken1 = (*paryTokens1);
         i1 < Size1;
         i1++, ppToken1++)
    {
        Assert(*ppToken1);

        // look for match in String 2
        fIsUnique = true;
        for (i2 = 0, ppToken2 = (*paryTokens2);
             i2 < Size2;
             i2++, ppToken2++)
        {
            Assert(*ppToken2);

            // alias ugly variables
            pstrToken1 = &(pstr1[(**ppToken1).uIndex]);
            pstrToken2 = &(pstr2[(**ppToken2).uIndex]);
            uToken1Length = (**ppToken1).uLength;
            uToken2Length = (**ppToken2).uLength;

            // compare lengths
            if (uToken1Length != uToken2Length)
            {
                continue;
            }

            // compare tokens (lengths are equal)
            if (0 == StrCmpNIW(pstrToken1, pstrToken2, uToken1Length))
            {
                fIsUnique = false;
                break;
            }
        } // for

        if (fIsUnique)
        {
            // Create copy of token
            pNewToken = new STRING_TOKEN;
            if (NULL == pNewToken)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            (*pNewToken).uIndex = (**ppToken1).uIndex;
            (*pNewToken).uLength = (**ppToken1).uLength;

            // Append new token to paryTokens1Minus2
            hr = THR((*paryTokens1Minus2).Append(pNewToken));
            if (FAILED(hr))
            {
                delete pNewToken;
                goto done;
            }
        }
    } // for


    hr = S_OK;
done:
    if (FAILED(hr))
    {
        IGNORE_HR(FreeStringTokenArray(paryTokens1Minus2));
    }
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Function:   ::FreeStringTokenArray
//
//  Synopsis:   Frees memory allocated to tokens and empties the array
//
//  Arguments:  [paryTokens]           Input array
//
//  Returns:    [S_OK]      If function completes successfully
//              [E_POINTER] Bad arg pointer
//
//------------------------------------------------------------------------------------


HRESULT
FreeStringTokenArray(/*in*/CPtrAry<STRING_TOKEN*> * paryTokens)
{
    HRESULT hr = E_FAIL;
    UINT i;
    STRING_TOKEN ** ppStringToken;

    CHECK_RETURN_NULL(paryTokens);

    for (i = (*paryTokens).Size(), ppStringToken = *paryTokens;
         i > 0;
         i--, ppStringToken++)
    {
        Assert(*ppStringToken);
        delete *ppStringToken;
    }

    (*paryTokens).DeleteAll();

    hr = S_OK;
done:
    return hr;
}



#ifdef DBG

static const UINT s_cMAX_TOKEN_LENGTH = 1000;

//+-----------------------------------------------------------------------------------
//
//  Function:   ::PrintStringTokenArray
//
//  Synopsis:   Debugging utility to print tokens using TraceTag((tagError,...))
//
//  Arguments:  [pstrString]    Input string
//              [paryTokens]    Input array
//
//  Returns:    [void]
//
//  Notes:      1. Assumes null terminated strings
//
//------------------------------------------------------------------------------------

void
PrintStringTokenArray(/*in*/ LPWSTR                   pstrString,
                      /*in*/ CPtrAry<STRING_TOKEN*> * paryTokens)
{
    int i;
    STRING_TOKEN ** ppStringToken;
    char achOutputString[s_cMAX_TOKEN_LENGTH];
    WCHAR wchTemp;

    if (NULL == paryTokens || NULL == pstrString)
    {
        return;
    }

    WideCharToMultiByte(CP_ACP, NULL,
                        pstrString,
                        -1,
                        achOutputString,
                        s_cMAX_TOKEN_LENGTH, NULL, NULL);
    TraceTag((tagError, "*********Parsed String: <%s>\nTokens:\n", achOutputString));

    for (i = (*paryTokens).Size(), ppStringToken = *paryTokens;
         i > 0;
         i--, ppStringToken++)
    {
        Assert(*ppStringToken);

        wchTemp = pstrString[(**ppStringToken).uIndex + (**ppStringToken).uLength];
        *(pstrString + (**ppStringToken).uIndex + (**ppStringToken).uLength) = *(L"");
        WideCharToMultiByte(CP_ACP, NULL,
                            pstrString + (**ppStringToken).uIndex,
                            (**ppStringToken).uLength + 1,
                            achOutputString,
                            s_cMAX_TOKEN_LENGTH, NULL, NULL);
        pstrString[(**ppStringToken).uIndex + (**ppStringToken).uLength] = wchTemp;

        TraceTag((tagError, "<%s> index = %d, length = %d\n", achOutputString,
            (**ppStringToken).uIndex, (**ppStringToken).uLength));
    }
}


//+-----------------------------------------------------------------------------------
//
//  Function:   ::PrintWStr
//
//  Synopsis:   Debugging utility to print a LPWSTR using TraceTag((tagError,...))
//
//  Arguments:  [pstr]    Input string
//
//  Returns:    [void]
//
//  Notes:      1. Assumes null terminated strings
//
//------------------------------------------------------------------------------------

void
PrintWStr(LPWSTR pstr)
{
    char achOutputString[s_cMAX_TOKEN_LENGTH];

    WideCharToMultiByte(CP_ACP, NULL,
                        pstr,
                        -1,
                        achOutputString,
                        s_cMAX_TOKEN_LENGTH, NULL, NULL);
    TraceTag((tagError, "<%s>", achOutputString));
}

#endif /* DBG */


WCHAR * TrimCopyString(const WCHAR *str)
{
    int i = 0;
    int len = str?lstrlenW(str)+1:1;
    int j = len - 1;
    WCHAR *newstr = NULL;

    if (str != NULL)
    {
        while (str[i] == ' ' && i < len)
        {
            i++;
        }
        while (str[j-1] == ' ' && j > 0)
        {
            j--;
        }


        newstr = new WCHAR [(i<j)?(j - i + 1):1] ;
        if (newstr)
        {
            if (i < j)
            {
                memcpy(newstr,str+i?str+i:L"",(j - i) * sizeof(WCHAR)) ;
                newstr[j-i] = 0;
            }
            else
            {
                memcpy(newstr, L"", sizeof(WCHAR)) ;
            }
        }
    }
    else
    {
        newstr = new WCHAR;
        if (newstr != NULL)
        {
            newstr[0] = 0;
        }
    }
    return newstr ;

}

// This used to convert URL's to a netshow extension.

WCHAR *
BeckifyURL(WCHAR *url)
{
    WCHAR *newVal = NULL;
    LPCWSTR lpFileName = PathFindFileName(url);
    LPCWSTR lpwExt = PathFindExtensionW(lpFileName);

    if(url == NULL)
    {
        newVal = NULL;
        goto done;
    }

    if(lstrlenW(url) < 5)
    {
        newVal = NULL;
        goto done;
    }

    if(lpwExt != lpFileName + lstrlenW(lpFileName))
    {
        newVal = NULL;
        goto done;
    }

    if((TIMEGetUrlScheme(url) != URL_SCHEME_HTTP) && (TIMEGetUrlScheme(url) != URL_SCHEME_HTTPS))
    {
        newVal = NULL;
        goto done;
    }

    newVal = NEW OLECHAR [lstrlenW(url) + 6];
    if(newVal == NULL)
    {
        goto done;
    }

    StrCpyW(newVal, url);
    StrCatW(newVal, L".beck");

done:
    return newVal;
}

bool
IsASXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    bool bRet = false;

    if (src != NULL)
    {
        LPCWSTR lpwExt = PathFindExtensionW(src);

        // Detect .asf files and skip them
        if (StrCmpIW(lpwExt, ASFSRC) == 0)
        {
            goto done;
        }
        else if (StrCmpIW(lpwExt, ASXSRC) == 0)
        {
            bRet = true;
            goto done;
        }
    }

    if (srcType != NULL &&
        StrStrIW(srcType, ASXMIME2) != NULL)
    {
        bRet = true;
        goto done;
    }
    else if (userMimeType != NULL &&
        StrStrIW(userMimeType, ASXMIME) != NULL)
    {
        bRet = true;
        goto done;
    }
    else if (userMimeType != NULL &&
        StrStrIW(userMimeType, ASXMIME2) != NULL)
    {
        bRet = true;
        goto done;
    }

  done:
    return bRet;
}

static bool
TestFileExtension(LPCWSTR wzFile, LPCWSTR wzExtension)
{
    bool bRet = false;

    if (NULL != wzFile)
    {
        LPCWSTR lpwExt = PathFindExtensionW(wzFile);

        // Detect .asf files and skip them
        if (StrCmpIW(lpwExt, wzExtension) == 0)
        {
            bRet = true;
            goto done;
        }
    }

  done:
    return bRet;
} // TestFileExtension

bool
IsM3USrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, M3USRC);
} // IsM3USrc

bool
IsLSXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, LSXSRC);
} // IsLSXSrc

bool
IsWMXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WMXSRC);
} // IsLSXSrc

bool
IsWAXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WAXSRC);
} // IsWAXSrc

bool
IsWVXSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WVXSRC);
} // IsWVXSrc

bool
IsWMFSrc(LPCWSTR src,
         LPCWSTR srcType,
         LPCWSTR userMimeType)
{
    return TestFileExtension(src, WMFSRC);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
bool IsHTMLSrc(const WCHAR * src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    bool bFlag = false;

    if (src != NULL)
    {
        len = lstrlenW(src);
        if (len >= HTMLSTREAMSRCLEN)
        {
            memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));

            if ((StrCmpIW(stream, HTMLSTREAMSRC) == 0) || (StrCmpIW(stream, SAMISTREAMSRC) == 0))
            {
                bFlag = true;
            }

        }
    }
    return bFlag;
}

bool
StringEndsIn(const LPWSTR pszString, const LPWSTR pszSearch)
{
    if (NULL == pszString || NULL == pszSearch)
    {
        return false;
    }

    size_t iStringLength = wcslen(pszString);
    size_t iSearchLength = wcslen(pszSearch);

    if (iSearchLength > iStringLength)
    {
        return false;
    }

    if (0 == StrCmpNIW(pszString+(iStringLength - iSearchLength), pszSearch, iSearchLength))
    {
        return true;
    }
    return false;
}

//+-----------------------------------------------------------------------
//
//  Member:    MatchElements
//
//  Overview:  Find out whether two interfaces point to the same object
//
//  Arguments: the dispatch of the objects
//
//  Returns:   bool
//
//------------------------------------------------------------------------
bool
MatchElements (IUnknown *piInOne, IUnknown *piInTwo)
{
    bool bRet = false;

    if (piInOne == piInTwo)
    {
        bRet = true;
    }
    else if (NULL == piInOne || NULL == piInTwo)
    {
        bRet = false;
    }
    else
    {
        CComPtr<IUnknown> piunk1;
        CComPtr<IUnknown> piunk2;

        if (FAILED(THR(piInOne->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piunk1)))))
        {
            goto done;
        }
        if (FAILED(THR(piInTwo->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piunk2)))))
        {
            goto done;
        }

        bRet = ((piunk1.p) == (piunk2.p));
    }

done :
    return bRet;
} // MatchElements

//+-----------------------------------------------------------------------
//
//  Member:    GetProperty
//
//  Overview:  Get the value of the given property
//
//  Arguments: The dispatch, property name and the out param for the new value
//
//  Returns:   S_OK, E_INVALIDARG, misc. dispatch failures.
//
//------------------------------------------------------------------------
HRESULT
GetProperty (IDispatch *pidisp, LPCWSTR wzPropNameIn, VARIANTARG *pvar)
{
    HRESULT             hr;
    DISPID              dispid = NULL;
    LPWSTR              wzPropName = const_cast<LPWSTR>(wzPropNameIn);
    DISPPARAMS          params = {NULL, NULL, 0, 0};

    Assert(NULL != pidisp);
    Assert(NULL != wzPropName);
    Assert(NULL != pvar);

    // Don't use THR as this can fail several times
    hr = pidisp->GetIDsOfNames(IID_NULL, &wzPropName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        // need to handle the (n) case....
        long lExtraParam;
        dispid = GetDispidAndParameter(pidisp, wzPropName, &lExtraParam);
        if (NULL == dispid)
        {
            goto done;
        }
        // Now get the data....
        params.rgvarg = NEW VARIANTARG[1];
        if (NULL == params.rgvarg)
        {
            goto done;
        }

        ZeroMemory(params.rgvarg, sizeof(VARIANTARG));
        params.rgvarg[0].vt   = VT_I4;
        params.rgvarg[0].lVal = lExtraParam;
        params.cArgs          = 1;

    }

    hr = THR(pidisp->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                            &params, pvar, NULL, NULL));


    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (params.rgvarg != NULL)
    {
        delete [] params.rgvarg;
    }
    return hr;
} // GetProperty

//+-----------------------------------------------------------------------
//
//  Member:    PutProperty
//
//  Overview:  Set the value of the given property
//
//  Arguments: The dispatch, property name and the new value
//
//  Returns:   S_OK, E_INVALIDARG, misc. dispatch failures.
//
//------------------------------------------------------------------------
HRESULT
PutProperty (IDispatch *pidisp, LPCWSTR wzPropNameIn, VARIANTARG *pvar)
{
    HRESULT     hr;
    DISPID      dispid      = NULL;
    DISPID      dispidPut   = DISPID_PROPERTYPUT;
    LPWSTR      wzPropName  = const_cast<LPWSTR>(wzPropNameIn);
    DISPPARAMS  params      = {pvar, &dispidPut, 1, 1};
    long        lExtraParam = -1;
    Assert(NULL != pidisp);
    Assert(NULL != wzPropName);
    Assert(NULL != pvar);

    hr = THR(pidisp->GetIDsOfNames(IID_NULL, &wzPropName,
                                   1, LCID_SCRIPTING, &dispid));
    if (FAILED(hr))
    {
        // need to handle the (n) case....
        dispid = GetDispidAndParameter(pidisp, wzPropName, &lExtraParam);
        if (NULL == dispid)
        {
            goto done;
        }
        // Now get the data....
        params.rgvarg = new VARIANTARG[2];
        if (NULL == params.rgvarg)
        {
            goto done;
        }
        ZeroMemory(params.rgvarg, sizeof(VARIANTARG) * 2);
        params.rgvarg[1].vt   = VT_I4;
        params.rgvarg[1].lVal = lExtraParam;
        VariantCopy(&params.rgvarg[0],pvar);
        params.cArgs  = 2;
    }

    // dilipk: removed THR since this fails many times
    hr = pidisp->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_METHOD | DISPATCH_PROPERTYPUT,
                            &params, NULL, NULL, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    if (lExtraParam != -1)
    {
        delete [] params.rgvarg;
    }
    return hr;
} // PutProperty

//+-----------------------------------------------------------------------
//
//  Member:    CallMethod
//
//  Overview:  Call the method on the given dispatch
//
//  Arguments: The method name, the return value, arguments
//
//  Returns:   S_OK, E_INVALIDARG, misc. dispatch failures.
//
//------------------------------------------------------------------------
HRESULT
CallMethod(IDispatch *pidisp, LPCWSTR wzMethodNameIn, VARIANT *pvarResult, VARIANT *pvarArgument1)
{
    HRESULT     hr;
    DISPID      dispid          = NULL;
    LPWSTR      wzMethodName    = const_cast<LPWSTR>(wzMethodNameIn);
    DISPPARAMS  params          = {pvarArgument1, NULL, 0, 0};

    Assert(NULL != pidisp);
    Assert(NULL != wzMethodName);

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    hr = pidisp->GetIDsOfNames(IID_NULL, &wzMethodName,
                               1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pidisp->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_METHOD,
                        &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
} // CallMethod

//+-----------------------------------------------------------------------
//
//  Member:    GetDispidAndParameter
//
//  Overview:  Return the dispid and the paramater if the is one..
//
//  Arguments:
//
//  Returns:   lParam and the dispid if it can..
//
//------------------------------------------------------------------------
DISPID
GetDispidAndParameter(IDispatch *pidisp, LPCWSTR wzAtributeNameIn, long *lParam)
{
    USES_CONVERSION; //lint !e522
    HRESULT  hr;
    DISPID   dispid = NULL;
    int      i;
    LPWSTR   wzTemp;

    wzTemp = new WCHAR[INTERNET_MAX_URL_LENGTH];
    if (NULL == wzTemp)
    {
        goto done;
    }

    ZeroMemory(wzTemp, sizeof(WCHAR) * INTERNET_MAX_URL_LENGTH);

    i = StrCSpnIW(wzAtributeNameIn,L"(");
    if (i == wcslen(wzAtributeNameIn))
    {
        goto done;
    }

    if (i+1 >= INTERNET_MAX_URL_LENGTH)
    {
        // Prevent buffer overrun
        goto done;
    }

    StrCpyNW(wzTemp, wzAtributeNameIn, i+1);

    hr = pidisp->GetIDsOfNames(IID_NULL, &wzTemp, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        dispid = NULL;
        goto done;
    }

    hr = StringCchCopy(wzTemp, INTERNET_MAX_URL_LENGTH, wzAtributeNameIn+i+1);
    if(FAILED(hr))
    {
        dispid = NULL;
        goto done;
    }
    *lParam = (long) _ttoi(OLE2T(wzTemp));

done:
    if (wzTemp)
    {
        delete [] wzTemp;
    }
    return dispid;
} //lint !e550

//+-----------------------------------------------------------------------
//
//  Function:  IsPalettizedDisplay
//
//  Overview:  Determines if primary display is 8 bits per pixel or less
//
//  Arguments: void
//
//  Returns:   true if display is <= 8bpp
//             false if display is > 8bpp
//
//------------------------------------------------------------------------
bool IsPalettizedDisplay()
{
    HDC hdcPrimary = NULL;
    int iBppPrimary = 0;

    hdcPrimary = GetDC(NULL);
    Assert(NULL != hdcPrimary);
    if (hdcPrimary)
    {
        iBppPrimary = GetDeviceCaps(hdcPrimary, BITSPIXEL);
        ReleaseDC(NULL, hdcPrimary);

        if (8 >= iBppPrimary)
        {
            return true;
        }
    }
    return false;
}


////////////////////////////////////////////////////////////////////////////////
//Determines if captions need to be shown
////////////////////////////////////////////////////////////////////////////////
bool GetSystemCaption()
{
    BOOL bUseCaptions = false;

    //GetSystemMetrics(SM_SHOWSOUNDS);  This call is unreliable.
    SystemParametersInfo(SPI_GETSHOWSOUNDS, 0, (void*)(&bUseCaptions), 0);

    return ((bUseCaptions == 0) ? false : true);
}

//if system caption is set don't use overdub, use subtitle
bool GetSystemOverDub()
{
    bool bOverdub = false;

    bOverdub = !GetSystemCaption();

    return bOverdub;
}

//if system caption is set don't use overdub, use subtitle
LPWSTR GetSystemConnectionType()
{
    LPWSTR szConnect = NULL;
    BOOL bReturn = FALSE;
    DWORD dwFlags = 0;

    bReturn = InternetGetConnectedStateEx(&dwFlags, NULL, 0, 0);
    if (!bReturn || dwFlags & INTERNET_CONNECTION_OFFLINE)
    {
        szConnect = CopyString(WZ_NONE);
    }
    else if (dwFlags & INTERNET_CONNECTION_MODEM)
    {
        szConnect = CopyString(WZ_MODEM);
    }
    else if (dwFlags & INTERNET_CONNECTION_LAN)
    {
        szConnect = CopyString(WZ_LAN);
    }

    return szConnect;
}

////////////////////////////////////////////////////////////////////////////////
//gets the language code for the system that is currently running.
////////////////////////////////////////////////////////////////////////////////
LPWSTR GetSystemLanguage(IHTMLElement *pEle)
{
    HRESULT hr = E_FAIL;
    CComPtr <IDispatch> pDocDisp;
    CComPtr <IHTMLDocument2> pDoc2;
    CComPtr <IHTMLWindow2> pWindow2;
    CComPtr <IOmNavigator> pNav;
    BSTR bstrUserLanguage = NULL;
    LPWSTR lpszUserLanguage = NULL;

    //get the system language.
    hr = pEle->get_document(&pDocDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDoc2->get_parentWindow(&pWindow2);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pWindow2->get_clientInformation(&pNav);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pNav->get_userLanguage(&bstrUserLanguage);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

  done:

    if (SUCCEEDED(hr))
    {
        lpszUserLanguage = CopyString(bstrUserLanguage);
    }
    if (bstrUserLanguage)
    {
        SysFreeString(bstrUserLanguage);
    }

    return lpszUserLanguage;

}

bool
IsElementNameThis(IHTMLElement * pElement, LPWSTR pszName)
{
    HRESULT hr = S_OK;

    CComBSTR sBSTR;
    bool bRet = false;

    if (NULL == pElement || NULL == pszName)
    {
        goto done;
    }

    hr = pElement->get_tagName(&sBSTR);
    if (FAILED(hr))
    {
        goto done;
    }

    if (sBSTR != NULL &&
        0 == StrCmpIW(sBSTR, pszName))
    {
        bRet = true;
    }

done:
    return bRet;
}

bool
IsElementPriorityClass(IHTMLElement * pElement)
{
    return IsElementNameThis(pElement, WZ_PRIORITYCLASS_NAME);
}
bool
IsElementTransition(IHTMLElement * pElement)
{
    return IsElementNameThis(pElement, WZ_TRANSITION_NAME);
}

bool IsVMLObject(IDispatch *pidisp)
{
    CComVariant pVar;
    HRESULT hr;

    hr = GetProperty (pidisp, L"tagurn", &pVar);
    if (FAILED(hr))
    {
        return false;
    }

    if (pVar.vt == VT_BSTR &&
        pVar.bstrVal != NULL)
    {
        if (0 == StrCmpIW(WZ_VML_URN, pVar.bstrVal))
        {
            return true;
        }
    }
    return false;
}


//+-----------------------------------------------------------------------
//
//  Multi-thread lock for STL
//
//------------------------------------------------------------------------


std::_Lockit::_Lockit()
{
    if (g_STLCS)
    {
        g_STLCS->Grab();
    }
}


std::_Lockit::~_Lockit()
{
    if (g_STLCS)
    {
        g_STLCS->Release();
    }
}

HRESULT
GetReadyState(IHTMLElement * pElm,
              BSTR * pbstrReadyState)
{
    HRESULT hr;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IDispatch> pDocDisp;

    Assert(pbstrReadyState);
    Assert(pElm);

    *pbstrReadyState = NULL;

    hr = THR(pElm->get_document(&pDocDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_readyState(pbstrReadyState));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

typedef HRESULT (WINAPI *FAULTINIEFEATUREPROC)( HWND hWnd,
                                                uCLSSPEC *pClassSpec,
                                                QUERYCONTEXT *pQuery,
                                                DWORD dwFlags);
static const TCHAR URLMON_DLL[] = _T("URLMON.DLL");
static const char FAULTINIEFEATURE[] = "FaultInIEFeature";

HRESULT
CreateObject(REFCLSID clsid,
             REFIID iid,
             void ** ppObj)
{
    HRESULT hr;
    HINSTANCE hinstURLMON = NULL;

    hinstURLMON = LoadLibrary(URLMON_DLL);
    if (NULL != hinstURLMON)
    {
        FAULTINIEFEATUREPROC            faultInIEFeature;
        faultInIEFeature = (FAULTINIEFEATUREPROC) ::GetProcAddress(hinstURLMON, FAULTINIEFEATURE);

        if (NULL != faultInIEFeature)
        {
            uCLSSPEC classpec;

            // setup the classpec
            classpec.tyspec = TYSPEC_CLSID;
            classpec.tagged_union.clsid = clsid;

            IGNORE_HR((*faultInIEFeature)(NULL, &classpec, NULL, NULL)); //lint !e522
        }

        FreeLibrary(hinstURLMON);
        hinstURLMON = NULL;
    }

    // Create given a clsid
    hr = THR(CoCreateInstance(clsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              iid,
                              ppObj));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HWND
GetDocumentHwnd(IHTMLDocument2 * pDoc)
{
    HRESULT hr;
    HWND hwnd = NULL;
    CComPtr<IOleWindow> spOleWindow;

    if (pDoc == NULL)
    {
        goto done;
    }

    hr = THR(pDoc->QueryInterface(IID_TO_PPV(IOleWindow, &spOleWindow)));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(spOleWindow->GetWindow(&hwnd));
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return hwnd;
}


HRESULT GetHTMLAttribute(IHTMLElement * pElement, const WCHAR * cpwchAttribute, VARIANT * pVar)
{
    HRESULT hr = S_OK;

    BSTR bstrAttribute = NULL;

    if (NULL == pVar || NULL == pElement || NULL == cpwchAttribute)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    bstrAttribute = SysAllocString(cpwchAttribute);
    if (bstrAttribute == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = pElement->getAttribute(bstrAttribute, 0, pVar);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    SysFreeString(bstrAttribute);
    RRETURN( hr );
}

// get document.all.pwzID
HRESULT
FindHTMLElement(LPWSTR pwzID, IHTMLElement * pAnyElement, IHTMLElement ** ppElement)
{
    HRESULT hr = S_OK;

    Assert(pwzID);
    Assert(ppElement);

    CComPtr<IDispatch> spDocDispatch;
    CComPtr<IHTMLDocument2> spDocument2;
    CComPtr<IHTMLElementCollection> spCollection;
    CComPtr<IDispatch> spElementDispatch;

    CComVariant varName(pwzID);
    CComVariant varIndex(0);

    if (NULL == pAnyElement)
    {
        hr = THR(E_INVALIDARG);
        goto done;
    }

    hr = THR(pAnyElement->get_document(&spDocDispatch));
    if (FAILED(hr) || spDocDispatch == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = THR(spDocDispatch->QueryInterface(IID_TO_PPV(IHTMLDocument2, &spDocument2)));
    if (FAILED(hr) || spDocument2 == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spDocument2->get_all(&spCollection));
    if (FAILED(hr) || spCollection == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spCollection->item(varName, varIndex, &spElementDispatch));
    if (FAILED(hr) || spElementDispatch == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spElementDispatch->QueryInterface(IID_TO_PPV(IHTMLElement, ppElement)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Function:  SetVisibility
//
//  Overview:  set the visibility on the html element to bVis
//
//  Arguments: bVis - wheter or not to set visibility on / off
//
//  Returns:   HRESULT
//
//------------------------------------------------------------------------
HRESULT
SetVisibility(IHTMLElement * pElement, bool bVis)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> spElement2;
    CComPtr<IHTMLStyle> spRuntimeStyle;
    CComBSTR bstrVis;

    if (NULL == pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spElement2->get_runtimeStyle(&spRuntimeStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    if (bVis)
    {
        bstrVis = WZ_VISIBLE;
    }
    else
    {
        bstrVis = WZ_HIDDEN;
    }

    hr = THR(spRuntimeStyle->put_visibility(bstrVis));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}


HRESULT WalkUpTree(IHTMLElement *pFirst,
    long &lscrollOffsetyc, long &lscrollOffsetxc,
    long &lPixelPosTopc, long &lPixelPosLeftc)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLElement> pElem;
    CComPtr<IHTMLElement> pElemp;
    long lscrollOffsetx, lscrollOffsety, lPixelPosTop, lPixelPosLeft;
    long lclientx = 0, lclienty = 0;

    for( pElemp = pFirst;
        SUCCEEDED(hr) && (pElemp != NULL);
        hr = pElem->get_offsetParent(&pElemp))
    {
        pElem.Release();
        pElem = pElemp;
        hr = THR(pElem->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
        if (FAILED(hr))
        {
            break;
        }
        hr = pElem2->get_scrollTop(&lscrollOffsety);
        if (FAILED(hr))
        {
            break;
        }
        lscrollOffsetyc += lscrollOffsety;

        hr = pElem2->get_scrollLeft(&lscrollOffsetx);
        if (FAILED(hr))
        {
            break;
        }
        lscrollOffsetxc += lscrollOffsetx;

        hr = pElem->get_offsetTop(&lPixelPosTop);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosTopc += lPixelPosTop;

        hr = pElem->get_offsetLeft(&lPixelPosLeft);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosLeftc += lPixelPosLeft;

        hr = pElem2->get_clientLeft(&lclientx);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosLeftc += lclientx;

        hr = pElem2->get_clientTop(&lclienty);
        if (FAILED(hr))
        {
            break;
        }
        lPixelPosTopc += lclienty;

        pElem2.Release();
        pElemp.Release();
    }
    return hr;
}

void GetRelativeVideoClipBox(RECT &localRect, RECT &elementSize, RECT &videoRect, long lscaleFactor)
{
    LONG lscreenWidth = GetSystemMetrics(SM_CXSCREEN);
    LONG lscreenHeight = GetSystemMetrics(SM_CYSCREEN);

    videoRect.top = 0;
    videoRect.left = 0;
    videoRect.right = lscaleFactor;
    videoRect.bottom = lscaleFactor;

    if(localRect.left < 0)
    {
        videoRect.left = ( -localRect.left / (double )elementSize.right) * lscaleFactor; //lint !e524
        localRect.left = 0;
    }
    if(localRect.right > lscreenWidth)
    {
        videoRect.right = lscaleFactor - ( (localRect.right - lscreenWidth) / (double )elementSize.right) * lscaleFactor; //lint !e524
        localRect.right = lscreenWidth;
    }
    if(localRect.top < 0)
    {
        videoRect.top = ( -localRect.top / (double )elementSize.bottom) * lscaleFactor; //lint !e524
        localRect.top = 0;
    }
    if(localRect.bottom > lscreenHeight)
    {
        videoRect.bottom = lscaleFactor - ( (localRect.bottom - lscreenHeight) / (double )elementSize.bottom) * lscaleFactor; //lint !e524
        localRect.bottom = lscreenHeight;
    }
}

//
// Returns true if this is Win95 or 98
//

bool TIMEIsWin9x(void)
{
    return (0 != (GetVersion() & 0x80000000));
}

//
// Returns true if this is Win95
//
bool TIMEIsWin95(void)
{
    static bool bHasOSVersion = false;
    static bool bIsWin95 = false;

    if (bHasOSVersion)
    {
        return bIsWin95;
    }

    OSVERSIONINFOA osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOA));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA(&osvi);

    bIsWin95 = (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId) &&
               (4 == osvi.dwMajorVersion) &&
               (0 == osvi.dwMinorVersion);

    bHasOSVersion = true;

    return bIsWin95;
}

//
// Property change notification helper
//

HRESULT
NotifyPropertySinkCP(IConnectionPoint *pICP, DISPID dispid)
{
    HRESULT hr = E_FAIL;
    CComPtr<IEnumConnections> pEnum;

    CHECK_RETURN_NULL(pICP);

    // #14222, ie6
    // dilipk: there are too many copies of this code lying around.
    //                 all objects should use this helper function.
    //

    hr = pICP->EnumConnections(&pEnum);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
        goto done;
    }

    CONNECTDATA cdata;

    hr = pEnum->Next(1, &cdata, NULL);
    while (hr == S_OK)
    {
        // check cdata for the object we need
        IPropertyNotifySink *pNotify;

        hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
        cdata.pUnk->Release();
        if (FAILED(hr))
        {
            TIMESetLastError(hr);
            goto done;
        }

        hr = pNotify->OnChanged(dispid);
        ReleaseInterface(pNotify);
        if (FAILED(hr))
        {
            TIMESetLastError(hr);
            goto done;
        }

        // and get the next enumeration
        hr = pEnum->Next(1, &cdata, NULL);
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged


double
Round(double inValue)
{
    double cV,fV;

    cV = ceil(inValue);
    fV = floor(inValue);

    if (fabs(inValue - cV) <  fabs(inValue - fV))
    {
        return cV;
    }

    return fV;
}

double
InterpolateValues(double dblNum1,
                double dblNum2,
                double dblProgress)
{
    return (dblNum1 + ((dblNum2 - dblNum1) * dblProgress));
}


HRESULT
GetSystemBitrate(long *lpBitrate)
{
    RASCONN RasCon;
    RAS_STATS Statistics;
    DWORD dwConCount = 0;
    DWORD lSize = sizeof(RASCONN);
    long lRet = 0;
    HRESULT hr = S_OK;
    LPWSTR lpszConnectType = NULL;

    HINSTANCE histRASAPI32 = NULL;
    RASGETCONNECTIONSTATISTICSPROC RasGetConnectStatsProc = NULL;
    RASENUMCONNECTIONSPROC RasEnumConnectionsProc = NULL;
    const TCHAR RASAPI32_DLL[] = _T("RASAPI32.DLL");
    const char RASGETCONNECTIONSTATISTICS[] = "RasGetConnectionStatistics";
    const char RASENUMCONNECTIONS[] = "RasEnumConnectionsW";

    if (lpBitrate == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(g_hrConnectResult))
    {
        hr = g_hrConnectResult;
        goto done;
    }

    if (g_lConnectSpeed != -1)
    {
        hr = S_OK;
        goto done;
    }


    //Check for systemBitrate in Win9x
    lpszConnectType = GetSystemConnectionType();
    if (lpszConnectType && StrCmpIW(lpszConnectType, WZ_MODEM) == 0)
    {
        long lTemp = 0;
        //need to check that this is a modem before checking the registry
        hr = CheckRegistryBitrate(&lTemp);
        if (SUCCEEDED(hr))
        {
            g_lConnectSpeed = lTemp;
            goto done;
        }
    }

    hr = S_OK;
    //check for system bitrate on Win2k
    histRASAPI32 = LoadLibrary(RASAPI32_DLL);
    if (NULL == histRASAPI32)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    RasGetConnectStatsProc = (RASGETCONNECTIONSTATISTICSPROC)GetProcAddress(histRASAPI32, RASGETCONNECTIONSTATISTICS);
    RasEnumConnectionsProc = (RASENUMCONNECTIONSPROC)GetProcAddress(histRASAPI32, RASENUMCONNECTIONS);

    if (RasGetConnectStatsProc == NULL || RasEnumConnectionsProc == NULL)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    RasCon.dwSize = lSize;
    Statistics.dwSize = sizeof(RAS_STATS);

    lRet = RasEnumConnectionsProc(&RasCon, &lSize, &dwConCount);

    if (dwConCount == 0)
    {
        hr = S_OK;
        g_lConnectSpeed = 0;
        goto done;
    }
    if (lRet != 0)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    lRet = RasGetConnectStatsProc(RasCon.hrasconn, &Statistics);
    if (lRet != 0)
    {
        hr = E_FAIL;
        g_lConnectSpeed = 0;
        goto done;
    }

    g_lConnectSpeed = Statistics.dwBps;
    hr = S_OK;

  done:

    if (histRASAPI32 != NULL)
    {
        FreeLibrary(histRASAPI32);
        histRASAPI32 = NULL;
    }
    if (SUCCEEDED(hr))
    {
        *lpBitrate = g_lConnectSpeed;
    }

    g_hrConnectResult = hr;

    return hr;
}

HRESULT CheckRegistryBitrate(long *pBitrate)
{
    LONG lRet = 0;
    HKEY hKeyRoot = NULL;
    HRESULT hr = S_OK;
    DWORD dwSize = MAX_REG_VALUE_LENGTH;
    DWORD dwType = 0;
    BYTE bDataBuf[MAX_REG_VALUE_LENGTH];

    if (pBitrate == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    lRet = RegOpenKeyEx(HKEY_DYN_DATA, _T("PerfStats\\StatData"), 0, KEY_READ, &hKeyRoot);
    if (ERROR_SUCCESS != lRet)
    {
        hr = E_FAIL;
        goto done;
    }

    Assert(NULL != hKeyRoot);

    lRet = RegQueryValueEx(hKeyRoot, _T("Dial-up Adapter\\ConnectSpeed"), 0, &dwType, bDataBuf, &dwSize);
    if (ERROR_SUCCESS != lRet)
    {
        hr = E_FAIL;
        goto done;
    }

    if (REG_BINARY == dwType)
	{
		*pBitrate = (long)(*(DWORD*)bDataBuf);
	}
    else if (REG_DWORD == dwType)
    {
        *pBitrate = (long)(*(DWORD*)bDataBuf);
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;

done:

    RegCloseKey(hKeyRoot);
    return hr;
}


HRESULT
SinkHTMLEvents(IUnknown * pSink,
               IHTMLElement * pEle,
               IConnectionPoint ** ppDocConPt,
               DWORD * pdwDocumentEventConPtCookie,
               IConnectionPoint ** ppWndConPt,
               DWORD * pdwWindowEventConPtCookie)
{
    CComPtr<IConnectionPointContainer> spWndCPC;
    CComPtr<IConnectionPointContainer> spDocCPC;
    CComPtr<IHTMLDocument> spDoc;
    CComPtr<IDispatch> spDocDispatch;
    CComPtr<IDispatch> spScriptDispatch;
    CComPtr<IConnectionPoint> spDocConPt;
    CComPtr<IConnectionPoint> spWndConPt;
    DWORD dwDocumentEventConPtCookie = 0;
    DWORD dwWindowEventConPtCookie = 0;

    HRESULT hr;

    if (NULL == pSink || NULL == pEle ||
        NULL == ppDocConPt || NULL == pdwDocumentEventConPtCookie ||
        NULL == ppWndConPt || NULL == pdwWindowEventConPtCookie)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(pEle->get_document(&spDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(spDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&spDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(spDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&spDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &spDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }


    hr = THR(spDocConPt->Advise(pSink, &dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(spDoc->get_Script (&spScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&spWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &spWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(spWndConPt->Advise(pSink, &dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (spDocConPt)
        {
            if (dwDocumentEventConPtCookie != 0)
            {
                IGNORE_HR(spDocConPt->Unadvise(dwDocumentEventConPtCookie));
            }
            spDocConPt.Release();
        }
        if (spWndConPt)
        {
            if (dwWindowEventConPtCookie != 0)
            {
                IGNORE_HR(spWndConPt->Unadvise(dwWindowEventConPtCookie));
            }
            spWndConPt.Release();
        }
        dwWindowEventConPtCookie = 0;
        dwDocumentEventConPtCookie = 0;
    }
    else
    {
        *ppDocConPt = spDocConPt;
        (*ppDocConPt)->AddRef();
        *pdwDocumentEventConPtCookie = dwDocumentEventConPtCookie;

        *ppWndConPt = spWndConPt;
        (*ppWndConPt)->AddRef();
        *pdwWindowEventConPtCookie = dwWindowEventConPtCookie;
    }

    RRETURN(hr);
}


bool
IsValidtvList(TimeValueList *tvlist)
{
    TimeValueSTLList & l = tvlist->GetList();
    bool bIsValid = false;
    for (TimeValueSTLList::iterator iter = l.begin();
             iter != l.end();
             iter++)
    {
        TimeValue *p = (*iter);
        if ((p->GetEvent() != NULL)                            ||
            (p->GetEvent() == NULL && p->GetElement() == NULL) ||
            (StrCmpIW(p->GetEvent(), WZ_INDEFINITE) == 0))
        {
            bIsValid = true;
        }
    }

    return bIsValid;

}

static const IID SID_SMediaBarSync = { 0x2efc8085, 0x066b, 0x4823, { 0x9d, 0xb4, 0xd1, 0xe7, 0x69, 0x16, 0xda, 0xa0 } };

HRESULT GetSyncBaseBody(IHTMLElement * pHTMLElem, ITIMEBodyElement ** ppBodyElem)
{
    HRESULT hr = S_OK;
    CComPtr<IDispatch> spDispDoc;
    CComPtr<IServiceProvider> spServiceProvider;
    CComPtr<IServiceProvider> spServiceProviderOC;
    CComPtr<IOleCommandTarget> spOCT;
    CComVariant svarBodyElem;


    if (!pHTMLElem || !ppBodyElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = pHTMLElem->get_document(&spDispDoc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDispDoc->QueryInterface(IID_TO_PPV(IServiceProvider, &spServiceProvider));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(SID_SWebBrowserApp, IID_TO_PPV(IServiceProvider, &spServiceProviderOC));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProviderOC->QueryService(SID_SMediaBarSync, IID_TO_PPV(IOleCommandTarget, &spOCT));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spOCT->Exec(0, 0, 0, &svarBodyElem, NULL);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = svarBodyElem.ChangeType(VT_UNKNOWN);
    if (FAILED(hr))
    {
        goto done;
    }
    if (svarBodyElem.punkVal && ppBodyElem)
    {
        hr = (svarBodyElem.punkVal)->QueryInterface(IID_TO_PPV(ITIMEBodyElement, ppBodyElem));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: ConvertToPixels
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool
ConvertToPixelsHELPER(LPOLESTR szString, LPOLESTR szKey, double dFactor, float fPixelFactor, double *outVal)
{
    HRESULT hr = S_OK;
    bool bReturn = false;
    LPOLESTR szTemp = NULL;
    OLECHAR  szTemp2[INTERNET_MAX_URL_LENGTH];
   
    // do init
    ZeroMemory(szTemp2,sizeof(WCHAR)*INTERNET_MAX_URL_LENGTH);

    // do the compare
    szTemp = StrStr(szString,szKey);
    if (NULL != szTemp)
    {
        if (INTERNET_MAX_URL_LENGTH > (lstrlenW(szString) + 2))
        {
            CComVariant varTemp;
            StrCpyNW(szTemp2,szString,wcslen(szString) - wcslen(szTemp)+1);
            varTemp.vt = VT_BSTR;
            varTemp.bstrVal = SysAllocString(szTemp2);
            hr = ::VariantChangeTypeEx(&varTemp,&varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
            if (SUCCEEDED(hr))
            {
                *outVal = V_R8(&varTemp); 
                *outVal /= dFactor;    // convert to inches.
                *outVal *= fPixelFactor;
                bReturn = true;
            }
            varTemp.Clear();
        }
        else
        {
            bReturn = false;
        }
    }

    szTemp = NULL;
    
done :
    return bReturn;
}

UINT
TIMEGetUrlScheme(const TCHAR * pchUrlIn)
{
    PARSEDURL      puw = {0};

    if (!pchUrlIn)
        return (UINT)URL_SCHEME_INVALID;

    puw.cbSize = sizeof(PARSEDURL);

    return (SUCCEEDED(ParseURL(pchUrlIn, &puw))) ?
                puw.nScheme : URL_SCHEME_INVALID;
}


HRESULT
TIMECombineURL(LPCTSTR base, LPCTSTR src, LPOLESTR * ppOut)
{
    Assert(ppOut);

    OLECHAR szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD len = INTERNET_MAX_URL_LENGTH;
    LPOLESTR szPath = NULL;
    HRESULT hr = S_OK;

    *ppOut = NULL;

    if (NULL == src)
    {
        goto done;
    }

    if ((NULL != base) && (TIMEGetUrlScheme(base) != URL_SCHEME_FILE)
        && !PathFileExists(src) && (TIMEGetUrlScheme(src) != URL_SCHEME_FILE) && (0 != StrCmpNIW(L"\\\\", base, 2)))
    {
        hr = ::CoInternetCombineUrl(base,
                                    src,
                                    URL_DONT_ESCAPE_EXTRA_INFO | URL_ESCAPE_SPACES_ONLY,
                                    szUrl,
                                    INTERNET_MAX_URL_LENGTH,
                                    &len,
                                    0);
        if (FAILED(hr))
        {
            // could have failed for any reason - just default to copying source
            szPath = ::CopyString(src);
        }
        szPath = ::CopyString(szUrl);
    }
    else if (TRUE == InternetCombineUrlW (base, src, szUrl, &len, ICU_NO_ENCODE | ICU_DECODE))
    {
        szPath = ::CopyString(szUrl);
    }
    else
    {
        // InternetCombineUrlW failed - just copy the source
        szPath = ::CopyString(src);
    }

    if (NULL == szPath)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    *ppOut = szPath;
    szPath = NULL;

    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
TIMEFindMimeFromData(LPBC pBC,
                     LPCWSTR pwzUrl,
                     LPVOID pBuffer,
                     DWORD cbSize,
                     LPCWSTR pwzMimeProposed,
                     DWORD dwMimeFlags,
                     LPWSTR *ppwzMimeOut,
                     DWORD dwReserved)
{
    int cBytes;  // num CHARS plus NULL char times two for UNICODE

    if (NULL != pwzUrl)
    {
        if (IsASXSrc(pwzUrl, NULL, NULL) ||
            IsLSXSrc(pwzUrl, NULL, NULL) ||
            IsWMXSrc(pwzUrl, NULL, NULL))
        {
            if (ppwzMimeOut)
            {
                cBytes = 2 * (lstrlenW(ASXMIME) + 1);  // num CHARS plus NULL char times two for UNICODE
                *ppwzMimeOut = (LPWSTR)::CoTaskMemAlloc(cBytes);
                if (NULL == *ppwzMimeOut)
                {
                    return E_OUTOFMEMORY;
                }

                memcpy(*ppwzMimeOut, ASXMIME, cBytes);
                return S_OK;
            }
        }
        else if (IsWMFSrc(pwzUrl, NULL, NULL))
        {
            cBytes = 2 * (lstrlenW(L"image/wmf") + 1);  // num CHARS plus NULL char times two for UNICODE
            *ppwzMimeOut = (LPWSTR)::CoTaskMemAlloc(cBytes);
            if (NULL == *ppwzMimeOut)
            {
                return E_OUTOFMEMORY;
            }

            memcpy(*ppwzMimeOut, L"image/wmf", cBytes);
            return S_OK;
        }
    }

    return FindMimeFromData(pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\readdata.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// READDATA.CPP - Reading data helping utilities
//

#include "pch.h"

// Globals
const char g_cszMultiPartFormData[]  = "multipart/form-data";
const char g_cszDebug[]              = "debug";
const char g_cszTextPlain[]          = "text/plain";

//
// What:    ReadData
//
// Desc:    Reads the rest of the stream from the client. There is dwSize
//          bytes left to read and will be stored in lpMoreData.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK.
//          lpMoreData is the buffer where the bits will be stored.
//          dwSize is the amount of bits to be saved.
//
// Return:  FALSE if there is an error during the read, otherwise TRUE.
//
BOOL ReadData( LPECB lpEcb, LPVOID lpMoreData, DWORD dwSize )
{
    BOOL fReturn;
    BOOL fLastRequestFail = FALSE;
    DWORD cb, count;
    LPBYTE lpBytes;
    TraceMsg( TF_FUNC | TF_READDATA, "ReadData( lpEcb, lpMoreData, dwSize=%u )", dwSize );

    lpBytes = (LPBYTE) lpMoreData;
    count = 0;
    while ( count != dwSize )
    {
        cb  = dwSize - count;
        fReturn = ReadClient( lpEcb->ConnID, lpBytes, &cb );
        if ( !fReturn )
            goto Cleanup;

        count += cb;    // increment the number of bytes read
        lpBytes += cb;  // move pointer ahead

        if ( cb == 0 )
        {
            if ( fLastRequestFail )
            {
                DebugMsg( NULL, "Two ReadClient requests resulted in ZERO bytes read. Aborting rest of read." );
                break;
            }

            fLastRequestFail = TRUE;
        }
        else
        {
            fLastRequestFail = FALSE;
        }
    }

    TraceMsg( TF_READDATA, "Count= %u", count );

Cleanup:
    TraceMsg( TF_FUNC | TF_READDATA, "ReadData( lpEcb, lpMoreData, dwSize=%u ) Exit = %s", 
        dwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;
} // ReadData( )


//
// What:    CompleteDownload
//
// Desc:    Makes sure that we have everything the client is sending.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK.
//
// Out:     lpbData is the pointer to the return pointer where the entire
//          data bytes are.
//
BOOL CompleteDownload( LPECB lpEcb, LPBYTE *lppbData )
{
    BOOL fReturn = TRUE;    // assume success

    TraceMsg( TF_FUNC | TF_READDATA, "CompleteDownload( )" );

    // Point to what the server has already downloaded
    *lppbData = lpEcb->lpbData;  

    // Do we have the whole thing?
    BOOL fDownloadComplete = (lpEcb->cbTotalBytes == lpEcb->cbAvailable );

    TraceMsg( TF_READDATA, "Does cbTotalBytes(%u) == cbAvailable(%u)? %s",
        lpEcb->cbTotalBytes, lpEcb->cbAvailable, 
        BOOLTOSTRING( fDownloadComplete ) );

    if ( !fDownloadComplete )
    {   // Get the rest of the data...
        *lppbData = (LPBYTE) GlobalAlloc( GPTR, lpEcb->cbTotalBytes );
        CopyMemory( *lppbData , lpEcb->lpbData, lpEcb->cbAvailable );
        DWORD dwSize = lpEcb->cbTotalBytes - lpEcb->cbAvailable;
        fReturn = ReadData( lpEcb, *lppbData + lpEcb->cbAvailable, dwSize );
        if ( !fReturn ) {
            TraceMsg( TF_ALWAYS, NULL, "CompleteDownload( ): Error recieving submission." );
            goto Cleanup;
        }
    }

Cleanup:
    TraceMsg( TF_FUNC | TF_READDATA, "CompleteDownload( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CompleteDownload( )

//
// What:    GetServerVarString
//
// Desc:    Asks server for a server variable. It also allocs space for the 
//          resulting string.
//
// In:      lpEcb is an EXTENDED_CONTROL_BLOCK.
//          lpVarName is a pointer the string name of the server variable to
//              retrieve.
// In/Out:  lppszBuffer will be assign memory for the result string from the 
//              server.
//          lpdwSize (if passed) will be assigned the size of the buffer.
//
BOOL GetServerVarString( LPECB lpEcb, LPSTR lpszVarName, LPSTR *lppszBuffer, LPDWORD lpdwSize )
{
    CHAR  szVerySmallBuf[ 1 ];   // bogus buffer
    DWORD dwSize;
    BOOL  fReturn;

    TraceMsg( TF_FUNC | TF_READDATA, "GetServerVarString( lpEcb, lpszVarName='%s', *lppszBuffer=%x, lpdwSize=%x )",
        lpszVarName, *lppszBuffer, lpdwSize );

    // Find out how big our buffer needs to be.
    dwSize = 0;
    fReturn = GetServerVariable( lpEcb->ConnID, lpszVarName, szVerySmallBuf, &dwSize );
    DWORD dwErr = GetLastError( );
    if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
    {
        TraceMsgResult( TF_ALWAYS, &ErrtoStr, dwErr, "GetServerVariable( ) returned " );
        goto Cleanup;
    }

    // get some memory
    *lppszBuffer = (LPSTR) GlobalAlloc( GPTR, dwSize );
    if ( !*lppszBuffer )
    {   // not enough memory
        TraceMsg( TF_ALWAYS, "Operation failed. Out of Memory(?). lppszBuffer == NULL" );
        fReturn = FALSE;
        goto Cleanup;    
    }

    // grab it for real this time
    fReturn = GetServerVariable( lpEcb->ConnID, lpszVarName, *lppszBuffer , &dwSize );
    if ( !fReturn )
    {
        DWORD dwErr = GetLastError( );
        TraceMsgResult( TF_ALWAYS, &ErrtoStr, dwErr, "GetServerVariable( ) returned " );
        goto Cleanup;
    }

Cleanup:
    if ( !fReturn )
    {
        dwSize = 0;
        *lppszBuffer = NULL;
    }

    if ( lpdwSize )
        *lpdwSize = dwSize;

    TraceMsg( TF_FUNC | TF_READDATA, "GetServerVarString( lpEcb, lpszVarName='%s', *lppszBuffer=%x, lpdwSize=%x ) Exit = %s",
        lpszVarName, *lppszBuffer, lpdwSize, BOOLTOSTRING( fReturn ) );
    return fReturn;

} // GetServerVarString( )

//
// What:    CheckForMultiPartFormSubmit
//
// Desc:    Checks "content-type" to see if it is a "multipart/form-data"
//          submission.
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//
// Out:     lpfMultipart: TRUE is submission is multipart, otherwise false.
//
// Return:  FALSE is there was an error, otherwise TRUE.
//
BOOL CheckForMultiPartFormSubmit( LPECB lpEcb, BOOL *lpfMultipart )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForMultiPartFormSubmit( )" );

    *lpfMultipart = FALSE;

    fReturn = GetServerVarString( lpEcb, "CONTENT_TYPE", &lpszBuffer, NULL );
    if ( !fReturn )
        goto Cleanup;
    
    // is it found?
    if (( lpszBuffer ) && (StrStr( lpszBuffer, g_cszMultiPartFormData ) ))
        *lpfMultipart = TRUE;

Cleanup:
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForMultiPartFormSubmit( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CheckForMultiPartFormSubmit( )


//
// What:    CheckForDebug
//
// Desc:    Checks "query_string" to see if it is "debug".
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
// 
// Out:     lpfDebug is the flag that we set.
//
// Return:  TRUE is the submit is multipart, otherwise FALSE.
//
BOOL CheckForDebug( LPECB lpEcb, BOOL *lpfDebug )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForDebug( )" );

    *lpfDebug = FALSE;

    fReturn = GetServerVarString( lpEcb, "QUERY_STRING", &lpszBuffer, NULL );
    if ( !fReturn )
        goto Cleanup;
    
    // is it found?
    if (( lpszBuffer) && ( StrStr( lpszBuffer, g_cszDebug ) ))
        *lpfDebug = TRUE;

Cleanup:
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForDebug( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CheckForDebug( )


//
// What:    CheckForTextPlanSubmit
//
// Desc:    Checks "content-type" to see if it is "text/plain".
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
// 
// Out:     lpfTextPlain is the flag that we set.
//
// Return:  TRUE is the submit is multipart, otherwise FALSE.
//
BOOL CheckForTextPlainSubmit( LPECB lpEcb, BOOL *lpfTextPlain )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForTextPlainSubmit( )" );

    *lpfTextPlain = FALSE;

    fReturn = GetServerVarString( lpEcb, "CONTENT_TYPE", &lpszBuffer, NULL );
    if ( !fReturn )
        goto Cleanup;
    
    // is it found?
    if (( lpszBuffer) && ( StrStr( lpszBuffer, g_cszTextPlain ) ))
        *lpfTextPlain = TRUE;

Cleanup:
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_READDATA, "CheckForTextPlainSubmit( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // CheckForTextPlainSubmit( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\readdata.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// readdata.H - Reading data helping utilities
//

#ifndef _READDATA_H_
#define _READDATA_H_

// Methods
BOOL ReadData( LPECB lpEcb, LPVOID lpMoreData, DWORD dwSize );
BOOL CompleteDownload( LPECB lpEcb, LPBYTE *lpbData );
BOOL GetServerVarString( LPECB lpEcb, LPSTR lpVarName, LPSTR *lppszBuffer, LPDWORD lpdwSize );
BOOL CheckForMultiPartFormSubmit( LPECB lpEcb, BOOL *lpfMultipart );
BOOL CheckForDebug( LPECB lpEcb, BOOL *lpfDebug );
BOOL CheckForTextPlainSubmit( LPECB lpEcb, BOOL *lpfTextPlain );

#endif // _READDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\pch.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// PCH.H - Precompile header
//

#if DBG == 1
#define DEBUG
#endif

#include <windows.h>
#include <windowsx.h>
#include <httpext.h>
#include <shlwapi.h>
#include <wininet.h>
#include "debug.h"
#include "reflectr.h"
#include "base.h"
#include "response.h"
#include "readdata.h"
#include "multpars.h"
#include "textpars.h"

#define FILEUPLD_VERSION_MAJOR  1
#define FILEUPLD_VERSION_MINOR  0
#define FILEUPLD_DESCRIPTION    "Form Submission Reflecter"
#define FILEUPLD_FILTER_FLAGS   SF_NOTIFY_READ_RAW_DATA | SF_NOTIFY_ORDER_DEFAULT

// Macros
#define ARRAYOF( _a )  ( sizeof( _a ) / sizeof( _a[0] ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\reflectr.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// REFLECTR.H - 
//

#ifndef _REFLECTR_H_
#define _REFLECTR_H_

#define LPECB   LPEXTENSION_CONTROL_BLOCK

#define GetServerVariable( _hconn, _lpstr, _lpvoid, _lpdword )                  \
    (lpEcb->GetServerVariable)( _hconn, _lpstr, _lpvoid, _lpdword );            \
    TraceMsg( TF_SERVER, "GetServerVariable( Connid=0x%x  lpszVarName='%s'  lpBuf=0x%x  lpdwSize=0x%x )",  \
        _hconn, _lpstr, _lpvoid, _lpdword )

#define WriteClient( _hconn, _lpvoid, _lpdword, _dw )                           \
    (lpEcb->WriteClient)( _hconn, _lpvoid, _lpdword, _dw );                     \
    TraceMsg( TF_SERVER, "WriteClient( Connid=0x%x  lpBuf=0x%x  lpdwSize=0x%x  dwResv=0x%x )",  \
        _hconn, _lpvoid, _lpdword, _dw )

#define ReadClient( _hconn, _lpvoid, _lpdword )                                 \
    (lpEcb->ReadClient)( _hconn, _lpvoid, _lpdword );                           \
    TraceMsg( TF_SERVER, "ReadClient( Connid=0x%x  lpBuf=0x%x  lpdwSize=0x%x )",      \
        _hconn, _lpvoid, _lpdword )

#define ServerSupportFunction( _hconn, _dw, _lpvoid, _lpdword, _lpdword2 )                  \
    (lpEcb->ServerSupportFunction)( _hconn, _dw, _lpvoid, _lpdword, _lpdword2 );            \
    TraceMsg( TF_SERVER, "ServerSupportFunction( Connid=%x  dwService=0x%x  lpBuf=0x%x  lpdwSize=0x%x lpdwDataType=0x%x )",  \
        _hconn, _dw, _lpvoid, _lpdword, _lpdword2 )

#endif // _REFLECTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\textpars.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// TEXTPARSE.H - Text/plain parser header file
//

#ifndef _TEXTPARS_H_
#define _TEXTPARS_H_


class CTextPlainParse : public CBase
{
public:
    CTextPlainParse( LPECB lpEcb, LPSTR *lppszOut, LPSTR *lppszDebug, LPDUMPTABLE lpDT );
    ~CTextPlainParse( );

    // Starts parsing data using infomation from server headers
    BOOL Parse( LPBYTE lpbData, LPDWORD lpdwParsed );

private:
    LPBYTE  _lpbData;                   // Memory containing send data
    LPBYTE  _lpbParse;                  // Current parse location into _lpbData

    CTextPlainParse( );

}; // CTextPlainParse

#endif // _TEXTPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\response.h ===
//
// Microsoft Corporation - Copyright 1997
//

//
// RESPONSE.H - 
//

#ifndef _RESPONSE_H_
#define _RESPONSE_H_

// globals
extern const char g_cszTableHeader[];
extern const char g_cszTableEnd[];

// Defines
#define RESPONSE_BUF_SIZE   4096

// METHODS
enum QUERYMETHOD {
    METHOD_UNKNOWN,
    METHOD_POST,
    METHOD_POSTMULTIPART,
    METHOD_GET,
    METHOD_POSTTEXTPLAIN
};

// Methods
BOOL SendSuccess( 
    QUERYMETHOD  eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwSize,
    LPDUMPTABLE lpDT );

BOOL SendFailure( 
    QUERYMETHOD eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwSize,
    LPDUMPTABLE lpDT );

BOOL SendRedirect( LPECB lpEcb, LPSTR lpszURL );
BOOL SendEcho( LPECB lpEcb );
BOOL SendServerHeader( LPECB lpEcb );
BOOL OutputHTMLString( LPECB lpEcb, LPSTR lpszOut );
BOOL HexDump( 
        LPECB       lpEcb, 
        LPBYTE      lpbData, 
        DWORD       dwLength, 
        LPDUMPTABLE lpDT );

#endif // _RESPONSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\response.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// RESPONSE.CPP - Contains possible responses
//

#include "pch.h"


// Globals
const char g_cszTableHeader[] = "%s \
<TABLE ID=%s BORDER=1> \
<TR> \
  <TH WIDTH=40%%>Variable Name</TH> \
  <TH WIDTH=60%%>Value</TH> \
</TR>";

const char g_cszTableEnd[] = "</TABLE>";

// List of known server variables
LPSTR g_lpServerVars[] = {
        "AUTH_TYPE",
        "CONTENT_LENGTH",
        "CONTENT_TYPE",
        "GATEWAY_INTERFACE",
        "LOGON_USER",
        "PATH_INFO",
        "PATH_TRANSLATED",
        "QUERY_STRING",
        "REMOTE_ADDR",
        "REMOTE_HOST",
        "REQUEST_METHOD",
        "SCRIPT_MAP",
        "SCRIPT_NAME",
        "SERVER_NAME",
        "SERVER_PORT",
        "SERVER_PORT_SECURE",
        "SERVER_SOFTWARE",
        "URL" 
    };

#define FROMHEX( _v ) \
    ( ( _v >= 48 ) && ( _v <= 57 ) ? _v - 48 : \
    ( ( _v >= 65 ) && ( _v <= 70 ) ? _v + 10 - 65 : 0 ) )

//
// What:    UnCanonicalize
//
// Desc:    Un-escapes strings
//
BOOL UnCanonicalize( LPSTR lpszStart, LPSTR lpszUnURL , LPDWORD lpdwSize )
{
    LPSTR lps = lpszStart;
    DWORD cb  = 0;

    while (( *lps ) && ( cb < *lpdwSize ))
    {
        if ( *lps == '%' )
        {
            lps++;
            lpszUnURL[ cb ]  = 16 * FROMHEX( *lps);
            lps++;
            lpszUnURL[ cb ] += FROMHEX( *lps);
        } 
        else if ( *lps == '+' )
        {
            lpszUnURL[ cb ] = 32;
        }
        else 
        {
            lpszUnURL[ cb ] = *lps;
        }
        cb++;
        lps++;
    }

    lpszUnURL[ cb ] = 0;  // paranoid
    *lpdwSize = cb;

    return TRUE;

} // UnCanonicalize( )


//
// What:    DumpFormDataFromPost
//
// Desc:    Dumps the fields and values in a form from a POST.
//
BOOL DumpFormDataFromPost( LPECB lpEcb )
{
    BOOL  fReturn = TRUE;
    DWORD dwSize;

    static char szUnparsed[] = "The unparsed Form submit string is: <FONT FACE=\"Courier New\">";
    static char szUnFont[] = "</FONT>";

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpFormDataFromPost()" );

    if ( fReturn )
    {   // header and the beginning of the table
        CHAR szBuffer[ 512 ];
        dwSize = wsprintf( szBuffer, g_cszTableHeader, 
            "<H2>Form Data (METHOD=POST)</H2>", "TBLPOST" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        int i = 0;
        LPSTR lpszStart = (LPSTR) lpEcb->lpbData;
        while (( fReturn ) && ( lpszStart ))
        {
            CHAR  cTmpEnd;
            LPSTR lpszEquals = StrChr( lpszStart, '=' );
            if ( !lpszEquals )
                break;  // no more data

            LPSTR lpszEnd    = StrChr( lpszEquals, '&' );

            if ( lpszEnd )
            {
                cTmpEnd = *lpszEnd;     // save
                *lpszEnd = 0;
            }

            CHAR cTmp = *lpszEquals;    // save
            *lpszEquals = 0;

            CHAR szBuffer[ 4096 ];
            CHAR szUnURL[ 2048 ];
            dwSize = sizeof( szUnURL );
            fReturn = UnCanonicalize( lpszEquals + 1, szUnURL, &dwSize );
            if ( fReturn )
            {
                dwSize = wsprintf( szBuffer, 
                    "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                    i, i, lpszStart, lpszStart, szUnURL );
                fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
            }

            *lpszEquals = cTmp;         // restore

            if ( lpszEnd )
            {
                *lpszEnd = cTmpEnd;     // restore
                lpszEnd++;
            }

            lpszStart = lpszEnd;
            i++;
        }
    }

    // end of the table
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( g_cszTableEnd );
        fReturn = WriteClient( lpEcb->ConnID, (LPVOID) g_cszTableEnd, &dwSize, HSE_IO_ASYNC );
    }

    // display unparsed information
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnparsed );
        fReturn = WriteClient( lpEcb->ConnID, szUnparsed, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        dwSize = 1 + lstrlen( (LPSTR) lpEcb->lpbData );
        fReturn = WriteClient( lpEcb->ConnID, lpEcb->lpbData, &dwSize, HSE_IO_ASYNC );
    }

    // end FONT tag
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnFont );
        fReturn = WriteClient( lpEcb->ConnID, szUnFont, &dwSize, HSE_IO_ASYNC );
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpFormDataFromPost() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // DumpFormDataFromPost( )

//
// What:    DumpQueryStringDataFromGet
//
// Desc:    Dumps the fields and values in a form from a GET.
//
BOOL DumpQueryStringDataFromGet( LPECB lpEcb )
{
    BOOL fReturn = TRUE;
    LPSTR lpszBuffer;
    DWORD dwSize;

    static char szUnparsed[] = "The unparsed QueryString is: <FONT FACE=\"Courier New\">";
    static char szUnFont[] = "</FONT>";

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpQueryStringDataFromGet()" );

    if ( fReturn )
        fReturn = GetServerVarString( lpEcb, "QUERY_STRING", &lpszBuffer, NULL );

    if ( fReturn )
    {   // header and the beginning of the table
        CHAR szBuffer[ 512 ];
        dwSize = wsprintf( szBuffer, g_cszTableHeader, 
            "<H2>QueryString Data(METHOD=GET)</H2>", "TBLGET" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        int i = 0;
        LPSTR lpszStart = lpszBuffer;
        while (( fReturn ) && ( lpszStart ))
        {
            CHAR cTmpEnd;
            LPSTR lpszEquals = StrChr( lpszStart, '=' );
            LPSTR lpszEnd    = StrChr( lpszEquals, '&' );

            if ( lpszEnd )
            {
                cTmpEnd = *lpszEnd;     // save
                *lpszEnd = 0;
            }

            CHAR cTmp = *lpszEquals;    // save
            *lpszEquals = 0;

            CHAR szBuffer[ 4096 ];
            CHAR szUnURL[ 2048 ];
            dwSize = sizeof( szUnURL );
            fReturn = UnCanonicalize( lpszEquals + 1, szUnURL, &dwSize );
            if ( fReturn )
            {
                dwSize = wsprintf( szBuffer, 
                    "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                    i, i, lpszStart, lpszStart, szUnURL );
                fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
            }

            *lpszEquals = cTmp;         // restore

            if ( lpszEnd )
            {
                *lpszEnd = cTmpEnd;     // restore
                lpszEnd++;
            }

            lpszStart = lpszEnd;
            i++;
        }
    }

    // end the table
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( g_cszTableEnd );
        fReturn = WriteClient( lpEcb->ConnID, (LPVOID) g_cszTableEnd, &dwSize, HSE_IO_ASYNC );
    }

    // display unparsed information
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnparsed );
        fReturn = WriteClient( lpEcb->ConnID, szUnparsed, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
    {
        dwSize = 1 + lstrlen( lpszBuffer );
        fReturn = WriteClient( lpEcb->ConnID, lpszBuffer, &dwSize, HSE_IO_ASYNC );
    }

    // end font tag
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( szUnFont );
        fReturn = WriteClient( lpEcb->ConnID, szUnFont, &dwSize, HSE_IO_ASYNC );
    }

    // clean up
    if ( lpszBuffer )
        GlobalFree( lpszBuffer );

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpQueryStringDataFromGet() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // DumpQueryStringDataFromGet( )

//
// What:    DumpServerVariables
//
// Desc:    Dumps the current server variable settings from the result of
//          a form submission.
//
BOOL DumpServerVariables( LPECB lpEcb )
{
    BOOL  fReturn = TRUE;
    LPSTR lpszBuffer;
    DWORD dwSize;
    int   i = 0;    // counter

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpServerVariables()" );

    if ( fReturn )
    {   // header and the begging of the table
        CHAR szBuffer[ 512 ];
        dwSize = wsprintf( szBuffer, g_cszTableHeader, 
            "<H2>Server Variables</H2>", "TBLSERVERVARS" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    // try the known ones
    for( ; ( fReturn ) && ( i < ARRAYOF( g_lpServerVars ) ); i++ )
    {
        GetServerVarString( lpEcb, g_lpServerVars[ i ], &lpszBuffer, NULL );

        if ( lpszBuffer )
        {
            CHAR szBuffer[ 512 ];
            dwSize = wsprintf( szBuffer, 
                "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                i, i, g_lpServerVars[ i ], g_lpServerVars[ i ], lpszBuffer );
            fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
        }

        GlobalFree( lpszBuffer );
        lpszBuffer = NULL;
    }

    // try the HTTP_ALL from header that the server ignores
    if ( fReturn )
        fReturn = GetServerVarString( lpEcb, "ALL_HTTP", &lpszBuffer, NULL );

    if (( fReturn ) && ( lpszBuffer ))
    {
        LPSTR lpszStart = lpszBuffer;
        while (( fReturn ) && ( lpszStart ))
        {
            char cTmpEnd;

            LPSTR lpszColon = StrChr( lpszStart, ':' );
            LPSTR lpszEnd   = StrStr( lpszColon, "HTTP_" );
            if ( lpszEnd )
            {
                cTmpEnd = *lpszEnd; // save
                *lpszEnd = 0;
            }

            char cTmp = *lpszColon; // save
            *lpszColon = 0;

            CHAR szBuffer[ 4096 ];
            dwSize = wsprintf( szBuffer, 
                "<TR ID=TR%u><TD ID=TD%u>%s</TD><TD ID=%s>%s</TD></TR>",
                i, i, lpszStart, lpszStart, lpszColon + 1 );
            fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );

            *lpszColon = cTmp;      // restore

            if ( lpszEnd )
                *lpszEnd = cTmpEnd; // restore

            lpszStart = lpszEnd;
            i++;
        }
    }

    // end the table
    if ( fReturn )
    {
        dwSize = 1 + lstrlen( g_cszTableEnd );
        fReturn = WriteClient( lpEcb->ConnID, (LPVOID) g_cszTableEnd, &dwSize, HSE_IO_ASYNC );
    }

    // clean up
    GlobalFree( lpszBuffer );
    lpszBuffer = NULL;

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpServerVariables() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ( )

//
// What:    DumpOutput
//
// Desc:    Generate reponse body page after headers and the HTML header
//          has been.
//
BOOL DumpOutput( 
        QUERYMETHOD eMethod, 
        LPECB       lpEcb, 
        LPSTR       lpszOut, 
        LPSTR       lpszDebug )
{
    BOOL  fReturn;
    DWORD dwSize;
    char  szBuffer[ RESPONSE_BUF_SIZE ];

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpOutput()" );

    // Display form data
    switch ( eMethod )
    {
    case METHOD_POST:
        fReturn = DumpFormDataFromPost( lpEcb );
        break;

    case METHOD_GET:
        fReturn = DumpQueryStringDataFromGet( lpEcb );
        break;

    case METHOD_POSTTEXTPLAIN:
    case METHOD_POSTMULTIPART:
        if ( lpszOut )
        {
            dwSize = 1 + lstrlen( lpszOut );
            fReturn = WriteClient( lpEcb->ConnID, lpszOut, &dwSize, HSE_IO_ASYNC );
        }
        break;

    default:
        StrCpy( szBuffer, "<H2>???? (METHOD=UNKNOWN)</H2>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    // Dump the server variables
    if ( fReturn )
        fReturn = DumpServerVariables( lpEcb );

    // Dump any debugging messages
    if (( fReturn ) && ( lpszDebug ))
    {
        StrCpy( szBuffer, "<H2>Debugging Output</H2>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );

        if ( fReturn )
            fReturn = OutputHTMLString( lpEcb, lpszDebug );
    }

    // Dump any server log entries
    if (( fReturn ) && ( lpEcb->lpszLogData[ 0 ] ))
    {
        StrCpy( szBuffer, "<H2>Server Log Entry</H2>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
        if ( fReturn )
        {
            dwSize = 1 + lstrlen( lpEcb->lpszLogData );
            fReturn = WriteClient( lpEcb->ConnID, lpEcb->lpszLogData, &dwSize, HSE_IO_ASYNC );
        }
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "DumpOutput() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // DumpOutput( )

// 
// What:    SendSuccess
//
// Desc:    Sends client an HTML response for a successful upload. Just a
//          green screen with "SUCCESS!" in a big header.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK that the server sent us.
//
BOOL SendSuccess( 
    QUERYMETHOD eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwParsed,
    LPDUMPTABLE lpDT ) 
{
    BOOL  fReturn = TRUE;    // assume success
    CHAR  szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize;
    BOOL  fDebug = FALSE;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendSuccess( )" );

    // Generate on the fly so
    // fReturn = SendServerHeader( lpEcb );

    if ( fReturn )
    {
        StrCpy( szBuffer, "\
            <HTML>\
            <HEAD>\
            <TITLE>Form Submission Reflector</TITLE>\
            </HEAD>\
            <BODY bgcolor=#00FF00>\
            <FONT FACE=\"ARIAL,HELVETICA\" SIZE=2>\
            Submission Result <INPUT TYPE=TEXT NAME=RESULT VALUE=\"SUCCESS!\">" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
        fReturn = CheckForDebug( lpEcb, &fDebug );

    if ( fReturn )
    {
        if ( fDebug )
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, lpszDebug );
        else
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, NULL );
    }

    if (( fReturn ) && ( fDebug ))
        fReturn = HexDump( lpEcb, lpbData, dwParsed, lpDT );

    if ( fReturn )
    {
        StrCpy( szBuffer, "</BODY></HTML>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendSuccess( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendSuccess( )

// 
// What:    SendFailure
//
// Desc:    Sends client an HTML response for a failed upload. Just a
//          red screen with "FAILED!" in a big header.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK that the server sent us.
//
BOOL SendFailure( 
    QUERYMETHOD eMethod, 
    LPECB       lpEcb, 
    LPSTR       lpszOut, 
    LPSTR       lpszDebug,
    LPBYTE      lpbData,
    DWORD       dwParsed,
    LPDUMPTABLE lpDT ) 
{
    BOOL  fReturn = TRUE;    // assume success
    CHAR  szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize;
    BOOL  fDebug = FALSE;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendFailure( )" );

    // fReturn = SendServerHeader( lpEcb );

    if ( fReturn )
    {
        StrCpy( szBuffer, "\
            <HTML>\
            <HEAD>\
            <TITLE>Form Submission Reflector</TITLE>\
            </HEAD>\
            <BODY bgcolor=#FF0000>\
            <FONT FACE=\"ARIAL,HELVETICA\" SIZE=2>\
            Submission Result <INPUT TYPE=TEXT NAME=RESULT VALUE=\"FAILED!\">" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    if ( fReturn )
        fReturn = CheckForDebug( lpEcb, &fDebug );

    if ( fReturn )
    {
        if ( fDebug )
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, lpszDebug );
        else
            fReturn = DumpOutput( eMethod, lpEcb, lpszOut, NULL );
    }

    if (( fReturn ) && ( fDebug ))
        fReturn = HexDump( lpEcb, lpbData, dwParsed, lpDT );

    if ( fReturn )
    {
        StrCpy( szBuffer, "</BODY></HTML>" );
        dwSize = 1 + lstrlen( szBuffer );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendFailure( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendSuccess( )


// 
// What:    SendRedirect
//
// Desc:    Redirects to another URL.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK that the server sent us.
//
BOOL SendRedirect( LPECB lpEcb, LPSTR lpszURL ) 
{
    BOOL fReturn = TRUE;    // assume success
    CHAR szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize = 1 + lstrlen( lpszURL );
    DWORD dw;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendRedirect( )" );

    fReturn = ServerSupportFunction( lpEcb->ConnID, HSE_REQ_SEND_URL_REDIRECT_RESP,
        lpszURL, &dwSize, &dw );

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendRedirect( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendSuccess( )


//
// What:    SendEcho
//
// Desc:    Sends client an echo for everything that it sent to us.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//
BOOL SendEcho( LPECB lpEcb )
{
    BOOL fReturn = TRUE;    // assume success
    CHAR szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize;
    LPVOID  lpMoreData = NULL;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendEcho( )" );

    BOOL fDownloadComplete = (lpEcb->cbTotalBytes == lpEcb->cbAvailable );

    TraceMsg( TF_RESPONSE, "Does cbTotalBytes(%u) == cbAvailable(%u)? %s",
        lpEcb->cbTotalBytes, lpEcb->cbAvailable, 
        BOOLTOSTRING( fDownloadComplete ) );

    if ( !fDownloadComplete )
    {   // Get the rest of the data
        dwSize = lpEcb->cbTotalBytes - lpEcb->cbAvailable;
        lpMoreData = (LPVOID) GlobalAlloc( GPTR, dwSize );
        fReturn = ReadData( lpEcb, lpMoreData, dwSize );
        if ( !fReturn )
            goto Cleanup;
    }

    TraceMsg( TF_RESPONSE, "Total Bytes: %u\n%s", 
        lpEcb->cbAvailable, lpEcb->lpbData );

    // Server header info...
    fReturn = SendServerHeader( lpEcb );
    if ( !fReturn )
        goto Cleanup;

    // Create top part of response and send it
    StrCpy( szBuffer, "<HTML><BODY bgcolor=#0000FF><PRE>" );
    dwSize = 1 + lstrlen( szBuffer );
    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;

    // and echo it back...
    dwSize = lpEcb->cbAvailable;
    fReturn = WriteClient( lpEcb->ConnID, lpEcb->lpbData, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;

    // and anything else that was sent...
    if ( lpMoreData ) 
    {
        dwSize = lpEcb->cbTotalBytes - lpEcb->cbAvailable;
        fReturn = WriteClient( lpEcb->ConnID, lpMoreData, &dwSize, HSE_IO_ASYNC );
        if ( !fReturn )
            goto Cleanup;
    }

    // Create bottom part of response and send it
    StrCpy( szBuffer, "</PRE></BODY></HTML>" );
    dwSize = 1 + lstrlen( szBuffer );
    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;

Cleanup:
    if ( lpMoreData )
        GlobalFree( lpMoreData );

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendEcho( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // SendEcho( )


//
// What:    SendServerHeader
//
// Desc:    This sends a complete HTTP server response header including the 
//          status, server version, message time, and MIME version. The ISAPI 
//          application should append other HTTP headers such as the content 
//          type and content length, followed by an extra "\r\n". This function 
//          only takes textual data, up to the first '\0' terminator
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//
BOOL SendServerHeader( LPECB lpEcb )
{
    BOOL fReturn;
    CHAR szBuffer[ RESPONSE_BUF_SIZE ];
    DWORD dwSize, dwParam;

    TraceMsg( TF_FUNC | TF_RESPONSE, "SendServerHeader( )" );


    TraceMsg( TF_RESPONSE, "Sending Pre Header: %s", szBuffer );

    dwSize = wsprintf( szBuffer, "200 OK" );
    dwParam = 0;
    fReturn = ServerSupportFunction( lpEcb->ConnID, HSE_REQ_SEND_RESPONSE_HEADER,
        szBuffer, &dwSize, &dwParam );
    if ( !fReturn )
        goto Cleanup;

    TraceMsg( TF_RESPONSE, "Sending Post Header: %s", szBuffer );

    dwSize = wsprintf( szBuffer, "Content-Type: text/html\r\n" );

    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &dwSize, HSE_IO_ASYNC );
    if ( !fReturn )
        goto Cleanup;


Cleanup:
    TraceMsg( TF_FUNC | TF_RESPONSE, "SendServerHeader( ) Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // SendServerHeader( )

//
// What:    OutputHTMLString
//
// Desc:    Outputs HTML to client. Simply changes '\n's to <BR>s.
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//          lpszOut string to translate to HTML.
//
BOOL OutputHTMLString( LPECB lpEcb, LPSTR lpszOut )
{
    BOOL  fReturn = TRUE;
    LPSTR lpstr;
    DWORD dwSize;

    TraceMsg( TF_FUNC | TF_RESPONSE, "OutputHTMLString()" );

    if( *lpszOut )
    {
        lpstr = lpszOut;
        while (( *lpstr ) && ( fReturn))
        {
            lpszOut = lpstr;
            lpstr++;

            while (( *lpstr ) && ( *lpstr != '\n' ))
                lpstr++;

            CHAR cTmp = *lpstr;     // save
            *lpstr = 0;

            dwSize = 1 + lstrlen( lpszOut );
            fReturn = WriteClient( lpEcb->ConnID, lpszOut, &dwSize, HSE_IO_ASYNC );

            *lpstr = cTmp;          // restore

            if ( fReturn )
            {
                dwSize  = 4;
                fReturn = WriteClient( lpEcb->ConnID, "<BR>", &dwSize, HSE_IO_ASYNC );
            }
        }
    }

    TraceMsg( TF_FUNC | TF_RESPONSE, "OutputHTMLString() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // OutputHTMLString( )

// 
// What:    HexDump
//
// Desc:    Dumps a HEX dump to the client using HTML. (16-byte rows)
//
// In:      lpEcb is the EXTENDED_CONTROL_BLOCK
//          lpbData is the data to be dumped
//          dwLength is the length of the dump.
//          lpDT is DUMPTABLE which contains information about what the
//              parser found while parsing. The end of the DT is indicated
//              by a NULL lpAddr.
//
// Return:  Return a pointer to the formatted output buffer.
//
BOOL HexDump( 
        LPECB lpEcb,
        LPBYTE lpbData, 
        DWORD dwLength, 
        LPDUMPTABLE lpDT )
{
    BOOL   fReturn;
    DWORD  cb           = 0;            // number of bytes processed
    DWORD  cbDT         = 0;            // number of DTs processed
    DWORD  cbComment    = 0;            // number of DT comments processed
    LPBYTE lpb          = lpbData;      // current data byte to be processed
    DWORD  dwColor      = 0x000000;     // color to output text in
    LPBYTE lpbStartLine = lpb;          // keeps track of where this line begins
                                        // for the string dump
    BOOL   fKeepGoing   = TRUE;         // exit flag
    CHAR   szBuffer[ 4096 ];            // output buffer
    CHAR   szString[ 512 ];             // "String Dump" output buffer
    DWORD  cbBuf, cbStr;                // helper count bytes for buffers

    // Output Dump Header
    cbBuf = wsprintf( szBuffer, "\
        <H2>Parser Commented Request Dump</H2>\
        <FONT FACE=\"Courier\">\
        <TABLE colpadding=2>\
        <TR><TD>Offset</TD><TD>Hex Dump</TD><TD>String Dump</TD><TD>Comments</TD></TR>" );

    fReturn = WriteClient( lpEcb->ConnID, szBuffer, &cbBuf, HSE_IO_ASYNC );

    while (( fReturn ) && ( fKeepGoing ))
    {
        if ( cb == 0 )
        {   // beginning of every row....
            if (( cbDT ) 
               && ( ( lpDT[ cbDT ].lpAddr - lpb ) > 64 ))
            {
                // eliminates "big" body data (like binary files)
                cbBuf = wsprintf( szBuffer, "<TR><TD>Skipping...</TD><TD>.</TD><TD>.</TD><TD>.</TD></TR>" );   

                // jump to one row before the next DT point
                lpb = (LPBYTE) ( ( ( (DWORD) lpDT[ cbDT ].lpAddr / 16 ) - 1 ) * 16 );
            } 
            else 
            {
                cbBuf = 0;
            }

            // Output 0xXXXXXXXX (NNNNNN): and change the color
            cbBuf += wsprintf( &szBuffer[ cbBuf ], 
                "<TR><TD>0x%-8.8x (%-6.6u):</TD><TD><FONT COLOR=%-6.6x>",
                lpb - lpbData, lpb - lpbData, dwColor );

            // starting color on "String Dump"
            cbStr = wsprintf( szString, "<FONT COLOR=%-6.6x>", dwColor );
        }

        if ( lpb < lpbData + dwLength )
        {   // middle of every row...

            // color change if needed
            while (( lpDT[ cbDT ].lpAddr )
               && ( lpb >= lpDT[ cbDT ].lpAddr ))
            {
                dwColor = lpDT[ cbDT ].dwColor;
                cbBuf += wsprintf( &szBuffer[ cbBuf ], "</FONT><FONT COLOR=%-6.6x>", dwColor );

                cbStr += wsprintf( &szString[ cbStr ], "</FONT><FONT COLOR=%-6.6x>", dwColor );

                cbDT++;
            }

            // output hex number
            cbBuf += wsprintf( &szBuffer[ cbBuf ], "%-2.2x ", *lpb );

            // output "String Dump" character
            cbStr += wsprintf( &szString[ cbStr ], "%c", 
                ( ( *lpb < 32 || *lpb == 127 ) ? '.' : ( ( *lpb == 32 ) ? '_' : *lpb ) ) );

            lpb++;

        }

        cb++;   // always count even if there is no more data

        if ( cb == 16 )
        {   // end of every row...

            // terminate FONT tags and append "String Dump"
            cbStr += wsprintf( &szString[ cbStr ], "</FONT>" );
            cbBuf += wsprintf( &szBuffer[ cbBuf ], "</FONT></TD><TD>%s</TD>",
                szString );

            // skip NULL comments
            while (( lpDT[ cbComment ].lpAddr ) 
                  && ( !lpDT[ cbComment ].lpszComment ))
                  cbComment++;  

            // don't allow comments to get ahead of the bits
            if (( lpDT[ cbComment ].lpAddr ) && ( cbComment < cbDT )) 
            {
                cbBuf += wsprintf( &szBuffer[ cbBuf ], 
                    "<TD><FONT COLOR=%-6.6x>%s</FONT></TD></TR>",
                    lpDT[ cbComment ].dwColor, lpDT[ cbComment ].lpszComment );
                cbComment++;
            } 
            else 
            {
                cbBuf += wsprintf( &szBuffer[ cbBuf ], "<TD><BR></TD></TR>" );
            }

            fReturn = WriteClient( lpEcb->ConnID, szBuffer, &cbBuf, HSE_IO_ASYNC );

            cb = 0;
            lpbStartLine = lpb;

            if ( lpb >= lpbData + dwLength )
                fKeepGoing = FALSE;
        }
    }

    // end the table
    if ( fReturn )
    {
        cbBuf = wsprintf( szBuffer, "</TABLE></FONT>" );
        fReturn = WriteClient( lpEcb->ConnID, szBuffer, &cbBuf, HSE_IO_ASYNC );
    }

    return fReturn;
} // HexDump( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\test\reflectr\textpars.cxx ===
//
// Microsoft Corporation - Copyright 1997
//

//
// TEXTPARS.CPP - Parses text/plain submissions
//

#include "pch.h"

//
// Constructor / Destructor
//
CTextPlainParse::CTextPlainParse( 
                    LPECB lpEcb, 
                    LPSTR *lppszOut, 
                    LPSTR *lpszDebug,
                    LPDUMPTABLE lpDT )
    :CBase( lpEcb, lppszOut, lpszDebug, lpDT )
{
    DebugMsg( lpszOut, g_cszTableHeader, "<BR>\
(NOTE: To turn on detailed debugging information, add '?debug' to the end of action URL in the orginating HTML file.)\
<br>\
<H2>Text/Plain Form Data (METHOD=POST, ENCTYPE=TEXT/PLAIN)</H2>\
",
        "TBLMULTIFORM" );

} // CTextPlainParse( )

CTextPlainParse::~CTextPlainParse( )
{

} // ~CTextPlainParse( )

CTextPlainParse::Parse( LPBYTE lpbData, LPDWORD lpdwParsed )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "Parse()" );

    _lpbParse = _lpbData = lpbData;

    while ( (DWORD)(_lpbParse - _lpbData) < lpEcb->cbTotalBytes )
    {
        LPSTR lpszName  = NULL; // points to the "name" field
        LPSTR lpszValue = NULL; // points to the "value" field
        LPSTR lpszEqual = NULL; // points to the "=" sign
        CHAR  cTmp;

        lpszName = (LPSTR) _lpbParse;

        while (( *_lpbParse != '='  
              && (DWORD)(_lpbParse - _lpbData) < lpEcb->cbTotalBytes ))
              _lpbParse++;

        if ( *_lpbParse != '=' )
        {
            DebugMsg( lpszDebug, "Expected to find an '=' after %u (0x%x) bytes.",
                (LPBYTE)lpszName - _lpbData, (LPBYTE)lpszName - _lpbData );
            fReturn = FALSE;
            goto Cleanup;
        }

        lpszEqual  = (LPSTR) _lpbParse;
        *lpszEqual = 0;     // terminate (save)

        _lpbParse++;        // move past

        lpszValue = (LPSTR) _lpbParse;

        while (( *_lpbParse != '\r'  
              && *_lpbParse != '\n'
              && (DWORD)(_lpbParse - _lpbData) < lpEcb->cbTotalBytes ))
              _lpbParse++;

        if (( *_lpbParse != '\r' ) && ( *_lpbParse != '\n' ))
        {
            DebugMsg( lpszDebug, "Expected to find a CR, LF, CRLF or LFCR after %u (0x%x) bytes.",
                (LPBYTE)lpszValue - _lpbData, (LPBYTE)lpszValue - _lpbData );
            fReturn = FALSE;
            goto Cleanup;
        }

        cTmp = *_lpbParse;          // save
        *_lpbParse = 0;             // terminate

        DebugMsg( lpszOut, "<TR ID=TR%s><TD ID=TD%s>%s</TD><TD ID=%s>%s</TD></TR>",
            lpszName, lpszName, lpszName, lpszName, lpszValue );

        *_lpbParse = cTmp;         // restore
        *lpszEqual = '=';          // restore

        _lpbParse++;    // move past

        // A possible combination of CR, LF, CRLF or LFCR are acceptable.
        if (( *_lpbParse = '\r' ) || ( *_lpbParse = '\n' ))
        {
            _lpbParse++;    // move past
        }
    }

    DebugMsg( lpszDebug, "Parsed %u (0x%x) bytes.", ( _lpbParse - _lpbData ), ( _lpbParse - _lpbData ) );

Cleanup:
    // End table output
    StrCat( lpszOut, g_cszTableEnd );

    *lpdwParsed = _lpbParse - _lpbData;

    // indicates EOTable, this will be an empty table for text/plain
    lpDT[ 0 ].lpAddr = NULL;

    TraceMsg( TF_FUNC | TF_PARSE, "Parse() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;
} // Parse()

/*****************************************************************************
//
// FUNCTION TEMPLATE
//
// ***************************************************************************
//
// What:    
//
// Desc:    
//
// In:
//
// Out:
//
// Return:
//
BOOL CTextPlainParse::( )
{
    BOOL fReturn = TRUE;

    TraceMsg( TF_FUNC | TF_PARSE, "()" );


    TraceMsg( TF_FUNC | TF_PARSE, "() Exit = %s",
        BOOLTOSTRING( fReturn ) );
    return fReturn;

} // ( )

******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\designer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */
/* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved */


/* File created by MIDL compiler version 3.02.88 */
/* at Fri May 22 18:46:33 1998
 */
/* Compiler settings for d:\devbin\shell\v6\idl\DESIGNER.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none, no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __DESIGNER_h__
#define __DESIGNER_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IActiveDesigner_FWD_DEFINED__
#define __IActiveDesigner_FWD_DEFINED__
typedef interface IActiveDesigner IActiveDesigner;
#endif 	/* __IActiveDesigner_FWD_DEFINED__ */


#ifndef __ICodeNavigate_FWD_DEFINED__
#define __ICodeNavigate_FWD_DEFINED__
typedef interface ICodeNavigate ICodeNavigate;
#endif 	/* __ICodeNavigate_FWD_DEFINED__ */


#ifndef __ISelectionContainer_FWD_DEFINED__
#define __ISelectionContainer_FWD_DEFINED__
typedef interface ISelectionContainer ISelectionContainer;
#endif 	/* __ISelectionContainer_FWD_DEFINED__ */


#ifndef __ITrackSelection_FWD_DEFINED__
#define __ITrackSelection_FWD_DEFINED__
typedef interface ITrackSelection ITrackSelection;
#endif 	/* __ITrackSelection_FWD_DEFINED__ */


#ifndef __IProfferTypeLib_FWD_DEFINED__
#define __IProfferTypeLib_FWD_DEFINED__
typedef interface IProfferTypeLib IProfferTypeLib;
#endif 	/* __IProfferTypeLib_FWD_DEFINED__ */


#ifndef __IProvideDynamicClassInfo_FWD_DEFINED__
#define __IProvideDynamicClassInfo_FWD_DEFINED__
typedef interface IProvideDynamicClassInfo IProvideDynamicClassInfo;
#endif 	/* __IProvideDynamicClassInfo_FWD_DEFINED__ */


#ifndef __IExtendedObject_FWD_DEFINED__
#define __IExtendedObject_FWD_DEFINED__
typedef interface IExtendedObject IExtendedObject;
#endif 	/* __IExtendedObject_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "servprov.h"
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0000
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1997 Microsoft Corporation. All Rights Reserved.
//
//  File: designer.h
//
//--------------------------------------------------------------------------
#ifndef _DESIGNER_H_
#define _DESIGNER_H_
const GUID CATID_Designer =
{0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x00, 0xaa, 0x00, 0x62, 0xbe, 0x57};


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0000_v0_0_s_ifspec;

#ifndef __IActiveDesigner_INTERFACE_DEFINED__
#define __IActiveDesigner_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveDesigner
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ IActiveDesigner __RPC_FAR *LPACTIVEDESIGNER;


EXTERN_C const IID IID_IActiveDesigner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51aae3e0-7486-11cf-a0C2-00aa0062be57")
    IActiveDesigner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeClassID( 
            /* [out] */ CLSID __RPC_FAR *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeMiscStatusFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPersistenceInterface( 
            /* [in] */ REFIID riidPersist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveRuntimeState( 
            /* [in] */ REFIID riidPersist,
            /* [in] */ REFIID riidObjStgMed,
            /* [in] */ void __RPC_FAR *pObjStgMed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtensibilityObject( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppvObjOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveDesignerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveDesigner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveDesigner __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveDesigner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRuntimeClassID )( 
            IActiveDesigner __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRuntimeMiscStatusFlags )( 
            IActiveDesigner __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPersistenceInterface )( 
            IActiveDesigner __RPC_FAR * This,
            /* [in] */ REFIID riidPersist);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveRuntimeState )( 
            IActiveDesigner __RPC_FAR * This,
            /* [in] */ REFIID riidPersist,
            /* [in] */ REFIID riidObjStgMed,
            /* [in] */ void __RPC_FAR *pObjStgMed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtensibilityObject )( 
            IActiveDesigner __RPC_FAR * This,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppvObjOut);
        
        END_INTERFACE
    } IActiveDesignerVtbl;

    interface IActiveDesigner
    {
        CONST_VTBL struct IActiveDesignerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveDesigner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveDesigner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveDesigner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveDesigner_GetRuntimeClassID(This,pclsid)	\
    (This)->lpVtbl -> GetRuntimeClassID(This,pclsid)

#define IActiveDesigner_GetRuntimeMiscStatusFlags(This,pdwMiscFlags)	\
    (This)->lpVtbl -> GetRuntimeMiscStatusFlags(This,pdwMiscFlags)

#define IActiveDesigner_QueryPersistenceInterface(This,riidPersist)	\
    (This)->lpVtbl -> QueryPersistenceInterface(This,riidPersist)

#define IActiveDesigner_SaveRuntimeState(This,riidPersist,riidObjStgMed,pObjStgMed)	\
    (This)->lpVtbl -> SaveRuntimeState(This,riidPersist,riidObjStgMed,pObjStgMed)

#define IActiveDesigner_GetExtensibilityObject(This,ppvObjOut)	\
    (This)->lpVtbl -> GetExtensibilityObject(This,ppvObjOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveDesigner_GetRuntimeClassID_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsid);


void __RPC_STUB IActiveDesigner_GetRuntimeClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_GetRuntimeMiscStatusFlags_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);


void __RPC_STUB IActiveDesigner_GetRuntimeMiscStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_QueryPersistenceInterface_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [in] */ REFIID riidPersist);


void __RPC_STUB IActiveDesigner_QueryPersistenceInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_SaveRuntimeState_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [in] */ REFIID riidPersist,
    /* [in] */ REFIID riidObjStgMed,
    /* [in] */ void __RPC_FAR *pObjStgMed);


void __RPC_STUB IActiveDesigner_SaveRuntimeState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveDesigner_GetExtensibilityObject_Proxy( 
    IActiveDesigner __RPC_FAR * This,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppvObjOut);


void __RPC_STUB IActiveDesigner_GetExtensibilityObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveDesigner_INTERFACE_DEFINED__ */


#ifndef __ICodeNavigate_INTERFACE_DEFINED__
#define __ICodeNavigate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeNavigate
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ ICodeNavigate __RPC_FAR *LPCODENAVIGATE;


EXTERN_C const IID IID_ICodeNavigate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6d5140c4-7436-11ce-8034-00aa006009fa")
    ICodeNavigate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayDefaultEventHandler( 
            /* [in] */ LPCOLESTR lpstrObjectName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeNavigateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeNavigate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeNavigate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeNavigate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayDefaultEventHandler )( 
            ICodeNavigate __RPC_FAR * This,
            /* [in] */ LPCOLESTR lpstrObjectName);
        
        END_INTERFACE
    } ICodeNavigateVtbl;

    interface ICodeNavigate
    {
        CONST_VTBL struct ICodeNavigateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeNavigate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeNavigate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeNavigate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeNavigate_DisplayDefaultEventHandler(This,lpstrObjectName)	\
    (This)->lpVtbl -> DisplayDefaultEventHandler(This,lpstrObjectName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeNavigate_DisplayDefaultEventHandler_Proxy( 
    ICodeNavigate __RPC_FAR * This,
    /* [in] */ LPCOLESTR lpstrObjectName);


void __RPC_STUB ICodeNavigate_DisplayDefaultEventHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeNavigate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0141
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SCodeNavigate IID_ICodeNavigate
#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2
#define SELOBJS_ACTIVATE_WINDOW   1


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0141_v0_0_s_ifspec;

#ifndef __ISelectionContainer_INTERFACE_DEFINED__
#define __ISelectionContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISelectionContainer
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ ISelectionContainer __RPC_FAR *LPSELECTIONCONTAINER;


EXTERN_C const IID IID_ISelectionContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6d5140c6-7436-11ce-8034-00aa006009fa")
    ISelectionContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CountObjects( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG __RPC_FAR *pc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cObjects,
            /* [size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectObjects( 
            /* [in] */ ULONG cSelect,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkSelect,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISelectionContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISelectionContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountObjects )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG __RPC_FAR *pc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjects )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cObjects,
            /* [size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectObjects )( 
            ISelectionContainer __RPC_FAR * This,
            /* [in] */ ULONG cSelect,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkSelect,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ISelectionContainerVtbl;

    interface ISelectionContainer
    {
        CONST_VTBL struct ISelectionContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionContainer_CountObjects(This,dwFlags,pc)	\
    (This)->lpVtbl -> CountObjects(This,dwFlags,pc)

#define ISelectionContainer_GetObjects(This,dwFlags,cObjects,apUnkObjects)	\
    (This)->lpVtbl -> GetObjects(This,dwFlags,cObjects,apUnkObjects)

#define ISelectionContainer_SelectObjects(This,cSelect,apUnkSelect,dwFlags)	\
    (This)->lpVtbl -> SelectObjects(This,cSelect,apUnkSelect,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionContainer_CountObjects_Proxy( 
    ISelectionContainer __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ULONG __RPC_FAR *pc);


void __RPC_STUB ISelectionContainer_CountObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionContainer_GetObjects_Proxy( 
    ISelectionContainer __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cObjects,
    /* [size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkObjects);


void __RPC_STUB ISelectionContainer_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionContainer_SelectObjects_Proxy( 
    ISelectionContainer __RPC_FAR * This,
    /* [in] */ ULONG cSelect,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *apUnkSelect,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ISelectionContainer_SelectObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionContainer_INTERFACE_DEFINED__ */


#ifndef __ITrackSelection_INTERFACE_DEFINED__
#define __ITrackSelection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITrackSelection
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ ITrackSelection __RPC_FAR *LPTRACKSELECTION;


EXTERN_C const IID IID_ITrackSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6d5140c5-7436-11ce-8034-00aa006009fa")
    ITrackSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSelectChange( 
            /* [in] */ ISelectionContainer __RPC_FAR *pSC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrackSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITrackSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITrackSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITrackSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSelectChange )( 
            ITrackSelection __RPC_FAR * This,
            /* [in] */ ISelectionContainer __RPC_FAR *pSC);
        
        END_INTERFACE
    } ITrackSelectionVtbl;

    interface ITrackSelection
    {
        CONST_VTBL struct ITrackSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrackSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITrackSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITrackSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITrackSelection_OnSelectChange(This,pSC)	\
    (This)->lpVtbl -> OnSelectChange(This,pSC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITrackSelection_OnSelectChange_Proxy( 
    ITrackSelection __RPC_FAR * This,
    /* [in] */ ISelectionContainer __RPC_FAR *pSC);


void __RPC_STUB ITrackSelection_OnSelectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITrackSelection_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0143
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_STrackSelection IID_ITrackSelection
#define CONTROLTYPELIB       (0x00000001)


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0143_v0_0_s_ifspec;

#ifndef __IProfferTypeLib_INTERFACE_DEFINED__
#define __IProfferTypeLib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProfferTypeLib
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ IProfferTypeLib __RPC_FAR *LPPROFFERTYPELIB;


EXTERN_C const IID IID_IProfferTypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("718cc500-0a76-11cf-8045-00aa006009fa")
    IProfferTypeLib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProfferTypeLib( 
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ UINT uVerMaj,
            /* [in] */ UINT uVerMin,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProfferTypeLibVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProfferTypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProfferTypeLib __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProfferTypeLib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProfferTypeLib )( 
            IProfferTypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ UINT uVerMaj,
            /* [in] */ UINT uVerMin,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IProfferTypeLibVtbl;

    interface IProfferTypeLib
    {
        CONST_VTBL struct IProfferTypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProfferTypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProfferTypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProfferTypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProfferTypeLib_ProfferTypeLib(This,guidTypeLib,uVerMaj,uVerMin,dwFlags)	\
    (This)->lpVtbl -> ProfferTypeLib(This,guidTypeLib,uVerMaj,uVerMin,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProfferTypeLib_ProfferTypeLib_Proxy( 
    IProfferTypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ UINT uVerMaj,
    /* [in] */ UINT uVerMin,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IProfferTypeLib_ProfferTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProfferTypeLib_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0144
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SProfferTypeLib IID_IProfferTypeLib


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0144_v0_0_s_ifspec;

#ifndef __IProvideDynamicClassInfo_INTERFACE_DEFINED__
#define __IProvideDynamicClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDynamicClassInfo
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][local][object] */ 


typedef /* [unique] */ IProvideDynamicClassInfo __RPC_FAR *LPPROVIDEDYNAMICCLASSINFO;


EXTERN_C const IID IID_IProvideDynamicClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("468cfb80-b4f9-11cf-80dd-00aa00614895")
    IProvideDynamicClassInfo : public IProvideClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDynamicClassInfo( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreezeShape( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideDynamicClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideDynamicClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideDynamicClassInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideDynamicClassInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideDynamicClassInfo __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDynamicClassInfo )( 
            IProvideDynamicClassInfo __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreezeShape )( 
            IProvideDynamicClassInfo __RPC_FAR * This);
        
        END_INTERFACE
    } IProvideDynamicClassInfoVtbl;

    interface IProvideDynamicClassInfo
    {
        CONST_VTBL struct IProvideDynamicClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideDynamicClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDynamicClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDynamicClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDynamicClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideDynamicClassInfo_GetDynamicClassInfo(This,ppTI,pdwCookie)	\
    (This)->lpVtbl -> GetDynamicClassInfo(This,ppTI,pdwCookie)

#define IProvideDynamicClassInfo_FreezeShape(This)	\
    (This)->lpVtbl -> FreezeShape(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideDynamicClassInfo_GetDynamicClassInfo_Proxy( 
    IProvideDynamicClassInfo __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IProvideDynamicClassInfo_GetDynamicClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProvideDynamicClassInfo_FreezeShape_Proxy( 
    IProvideDynamicClassInfo __RPC_FAR * This);


void __RPC_STUB IProvideDynamicClassInfo_FreezeShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDynamicClassInfo_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0145
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


const GUID SID_SApplicationObject =
{0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8};


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0145_v0_0_s_ifspec;

#ifndef __IExtendedObject_INTERFACE_DEFINED__
#define __IExtendedObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendedObject
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IExtendedObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A575C060-5B17-11d1-AB3E-00A0C9055A90")
    IExtendedObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInnerObject( 
            /* [in] */ REFIID iid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendedObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendedObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendedObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendedObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInnerObject )( 
            IExtendedObject __RPC_FAR * This,
            /* [in] */ REFIID iid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IExtendedObjectVtbl;

    interface IExtendedObject
    {
        CONST_VTBL struct IExtendedObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendedObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendedObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendedObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendedObject_GetInnerObject(This,iid,ppvObject)	\
    (This)->lpVtbl -> GetInnerObject(This,iid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IExtendedObject_GetInnerObject_Proxy( 
    IExtendedObject __RPC_FAR * This,
    /* [in] */ REFIID iid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IExtendedObject_GetInnerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendedObject_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_DESIGNER_0146
 * at Fri May 22 18:46:33 1998
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0146_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DESIGNER_0146_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tools\make_altfont.cxx ===
//+-----------------------------------------------------------------------------
//
//  make_altfont.cxx
//
//  cthrash@microsoft.com, June 1998.
//
//
//  Compile and run this file to make the tables for src\intl\intlcore\altfont.cxx
//
//------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#ifndef WCHAR
typedef unsigned short WCHAR;
#endif

#ifndef BOOL
typedef int BOOL;
#endif

inline BOOL InRange( WCHAR chmin, WCHAR ch, WCHAR chmax)
{
    return (unsigned)(ch - chmin) <= (unsigned)(chmax - chmin);
}

int StrCmpIC( const WCHAR * s0, const WCHAR * s1 )
{
    int ch1, ch2;

    do {

        ch1 = *s0++;
        if (ch1 >= L'A' && ch1 <= L'Z')
            ch1 += L'a' - L'A';

        ch2 = *s1++;
        if (ch2 >= L'A' && ch2 <= L'Z')
            ch2 += L'a' - L'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

struct NAMEPAIR
{
    WCHAR * pszAName;
    WCHAR * pszBName;
};

// NB (cthrash) Data comes from chrispr in Office.

struct NAMEPAIR anpTable[] = 
{
    { L"\x0041\x0052\x884C\x6977\x9023\x7DBF\x4F53\x0048", L"Arphic Gyokailenmentai Heavy JIS" },
    { L"\x0041\x0052\x884C\x6977\x9023\x7DBF\x4F53\x004C", L"Arphic Gyokailenmentai Light JIS" },
    { L"\x0041\x0052\x884C\x6977\x66F8\x4F53\x0048", L"Arphic Gyokaisho Heavy JIS" },
    { L"\x0041\x0052\x884C\x6977\x66F8\x4F53\x004C", L"Arphic Gyokaisho Light JIS" },
    { L"\x0041\x0052\x6977\x66F8\x4F53 \x004D", L"Arphic Kaisho Medium JIS" },
    { L"\x0041\x0052\x52D8\x4EAD\x6D41\x0048", L"Arphic Kanteiryu Heavy JIS" },
    { L"\x0041\x0052\x53E4\x5370\x4F53\x0042", L"Arphic Koin-Tai Bold JIS" },
    { L"\x0041\x0052\x9ED2\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic Kuro-Maru-POP Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x884C\x6977\x66F8\x4F53\x0048", L"Arphic PGyokaisho Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x884C\x6977\x66F8\x4F53\x004C", L"Arphic PGyokaisho Light JIS" },
    { L"\x0041\x0052\x0020\x0050\x6977\x66F8\x4F53\x4F53 \x004D", L"Arphic PKaisho Medium JIS" },
    { L"\x0041\x0052\x0020\x0050\x52D8\x4EAD\x6D41\x0048", L"Arphic PKanteiryu Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x53E4\x5370\x4F53\x0042", L"Arphic PKoin-Tai Bold JIS" },
    { L"\x0041\x0052\x0020\x0050\x9ED2\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic PKuro-Maru-POP Heavy JIS" },
    { L"\x0041\x0052\x0020\x0050\x30DA\x30F3\x884C\x6977\x66F8\x4F53 \x004C", L"Arphic PPengyokaisho Light JIS" },
    { L"\x0041\x0052\x0020\x0050\x30DA\x30F3\x6977\x66F8\x4F53\x004C", L"Arphic PPenkaisho Light JIS" },
    { L"\x0041\x0052\x0020\x0050\x96B7\x66F8\x4F53 \x004D", L"Arphic PReisho Medium JIS" },
    { L"\x0041\x0052\x0020\x0050\x767D\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic PSiro-Maru-POP Heavy JIS" },
    { L"\x0041\x0052\x30DA\x30F3\x884C\x6977\x66F8\x4F53 \x004C", L"Arphic Pengyokaisho Light JIS" },
    { L"\x0041\x0052\x30DA\x30F3\x6977\x66F8\x4F53\x004C", L"Arphic Penkaisho Light JIS" },
    { L"\x0041\x0052\x96B7\x66F8\x4F53 \x004D", L"Arphic Reisho Medium JIS" },
    { L"\x0041\x0052\x767D\x4E38\xFF30\xFF2F\xFF30\x4F53\x0048", L"Arphic Siro-Maru-POP Heavy JIS" },
    { L"\xFF24\xFF26\x7279\x592A\x30B4\x30B7\x30C3\x30AF\x4F53", L"DFGothic-EB" },
    { L"\xFF24\xFF26\xFF30\x7279\x592A\x30B4\x30B7\x30C3\x30AF\x4F53", L"DFPGothic-EB" },
    { L"\xFF24\xFF26\x0050\x004F\x0050\x4F53", L"DFPOP-SB" },
    { L"\xFF24\xFF26\xFF30\x0050\x004F\x0050\x4F53", L"DFPPOP-SB" },
    { L"\x0048\x0047\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0045", L"HGGothicE" },
    { L"\x0048\x0047\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x004D", L"HGGothicM" },
    { L"\x0048\x0047\x884C\x66F8\x4F53", L"HGGyoshotai" },
    { L"\x0048\x0047\x6559\x79D1\x66F8\x4F53", L"HGKyokashotai" },
    { L"\x0048\x0047\x660E\x671D\x0042", L"HGMinchoB" },
    { L"\x0048\x0047\x660E\x671D\x0045", L"HGMinchoE" },
    { L"\x0048\x0047\x0050\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0045", L"HGPGothicE" },
    { L"\x0048\x0047\x0050\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x004D", L"HGPGothicM" },
    { L"\x0048\x0047\x0050\x884C\x66F8\x4F53", L"HGPGyoshotai" },
    { L"\x0048\x0047\x0050\x6559\x79D1\x66F8\x4F53", L"HGPKyokashotai" },
    { L"\x0048\x0047\x0050\x660E\x671D\x0042", L"HGPMinchoB" },
    { L"\x0048\x0047\x0050\x660E\x671D\x0045", L"HGPMinchoE" },
    { L"\x0048\x0047\x0050\x5275\x82F1\x89D2\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0055\x0042", L"HGPSoeiKakugothicUB" },
    { L"\x0048\x0047\x0050\x5275\x82F1\x89D2\xFF8E\xFF9F\xFF6F\xFF8C\xFF9F\x4F53", L"HGPSoeiKakupoptai" },
    { L"\x0048\x0047\x0050\x5275\x82F1\xFF8C\xFF9F\xFF9A\xFF7E\xFF9E\xFF9D\xFF7D\x0045\x0042", L"HGPSoeiPresenceEB" },
    { L"\x0048\x0047\x0053\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0045", L"HGSGothicE" },
    { L"\x0048\x0047\x0053\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x004D", L"HGSGothicM" },
    { L"\x0048\x0047\x0053\x884C\x66F8\x4F53", L"HGSGyoshotai" },
    { L"\x0048\x0047\x0053\x6559\x79D1\x66F8\x4F53", L"HGSKyokashotai" },
    { L"\x0048\x0047\x0053\x660E\x671D\x0042", L"HGSMinchoB" },
    { L"\x0048\x0047\x0053\x660E\x671D\x0045", L"HGSMinchoE" },
    { L"\x0048\x0047\x0053\x5275\x82F1\x89D2\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0055\x0042", L"HGSSoeiKakugothicUB" },
    { L"\x0048\x0047\x0053\x5275\x82F1\x89D2\xFF8E\xFF9F\xFF6F\xFF8C\xFF9F\x4F53", L"HGSSoeiKakupoptai" },
    { L"\x0048\x0047\x0053\x5275\x82F1\xFF8C\xFF9F\xFF9A\xFF7E\xFF9E\xFF9D\xFF7D\x0045\x0042", L"HGSSoeiPresenceEB" },
    { L"\x0048\x0047\x5275\x82F1\x89D2\xFF7A\xFF9E\xFF7C\xFF6F\xFF78\x0055\x0042", L"HGSoeiKakugothicUB" },
    { L"\x0048\x0047\x5275\x82F1\x89D2\xFF8E\xFF9F\xFF6F\xFF8C\xFF9F\x4F53", L"HGSoeiKakupoptai" },
    { L"\x0048\x0047\x5275\x82F1\xFF8C\xFF9F\xFF9A\xFF7E\xFF9E\xFF9D\xFF7D\x0045\x0042", L"HGSoeiPresenceEB" },
    { L"\xFF2D\xFF33\x0020\x30B4\x30B7\x30C3\x30AF", L"MS Gothic" },
    { L"\xFF2D\xFF33\x0020\x660E\x671D", L"MS Mincho" },
    { L"\xFF2D\xFF33\x0020\xFF30\x30B4\x30B7\x30C3\x30AF", L"MS PGothic" },
    { L"\xFF2D\xFF33\x0020\xFF30\x660E\x671D", L"MS PMincho" },
    { L"\x4EFF\x5B8B\x005F\x0047\x0042\x0047\x0032\x0033\x0031\x0032", L"FangSong_GB2312" },
    { L"\x6977\x4F53\x005F\x0047\x0042\x0047\x0032\x0033\x0031\x0032", L"KaiTi_GB2312" },
    { L"\x96B6\x4E66", L"LiSu" },
    { L"\x65B0\x5B8B\x4F53", L"NSimSun" },
    { L"\x9ED1\x4F53", L"SimHei" },
    { L"\x5B8B\x4F53", L"SimSun" },
    { L"\x5E7C\x5706", L"YouYuan" },
    { L"\x534e\x6587\x5b8b\x4f53", L"STSong" },
    { L"\x534e\x6587\x4e2d\x5b8b", L"STZhongsong" },
    { L"\x534e\x6587\x6977\x4f53", L"STKaii" },
    { L"\x534e\x6587\x4eff\x5b8b", L"STFangsong" },
    { L"\x534e\x6587\x7ec6\x9ed1", L"STXihei" },
    { L"\x534e\x6587\x96b6\x4e66", L"STLiti" },
    { L"\x534e\x6587\x884c\x6977", L"STXingkai" },
    { L"\x534e\x6587\x65b0\x9b4f", L"STXinwei" },
    { L"\x534e\x6587\x7425\x73c0", L"STHupo" },
    { L"\x534e\x6587\x5f69\x4e91", L"STCaiyun" },
    { L"\x65b9\x6b63\x59da\x4f53\x7b80\x4f53", L"FZYaoTi" },
    { L"\x65b9\x6b63\x8212\x4f53\x7b80\x4f53", L"FZShuTi" },
    { L"\xD734\xBA3C\xC544\xBBF8\xCCB4", L"Ami R" },
    { L"\xBC14\xD0D5", L"Batang" },
    { L"\xBC14\xD0D5\xCCB4", L"BatangChe" },
    { L"\xB3CB\xC6C0", L"Dotum" },
    { L"\xB3CB\xC6C0\xCCB4", L"DotumChe" },
    { L"\xD734\xBA3C\xC5D1\xC2A4\xD3EC", L"Expo M" },
    { L"\xAD74\xB9BC", L"Gulim" },
    { L"\xAD74\xB9BC\xCCB4", L"GulimChe" },
    { L"\xAD81\xC11C", L"Gungsuh" },
    { L"\xAD81\xC11C\xCCB4", L"GungsuhChe" },
    { L"\x0048\x0059\xBAA9\xAC01\xD30C\xC784\x0042", L"HYPMokGak-Bold" },
    { L"\x0048\x0059\xC595\xC740\xC0D8\xBB3C\x004D", L"HYShortSamul-Medium" },
    { L"\x0048\x0059\xC5FD\xC11C\x004D", L"HYPost-Medium" },
    { L"\xD734\xBA3C\xB465\xADFC\xD5E4\xB4DC\xB77C\xC778", L"Headline R" },
    { L"\xD734\xBA3C\xBAA8\xC74C\x0054", L"MoeumT R" },
    { L"\xD734\xBA3C\xD3B8\xC9C0\xCCB4", L"Pyunji R" },
    { L"\x0048\x0059\xACAC\xACE0\xB515", L"HYGothic-Extra" },
    { L"\x0048\x0059\xC2E0\xBB38\xBA85\xC870", L"HYSinMun-MyeongJo" },
    { L"\x0048\x0059\xACAC\xBA85\xC870", L"HYMyeongJo-Extra" },
    { L"\x0048\x0059\xD0C0\xC790\x004D", L"HYTaJa-Medium" },
    { L"\xD734\xBA3C\xAC01\xC9C4\xD5E4\xB4DC\xB77C\xC778", L"Headline Sans R" },
    { L"\xD734\xBA3C\xC61B\xCCB4", L"Yet R" },
    { L"\x6A19\x6977\x9AD4", L"DFKai-SB" },
    { L"\x83EF\x5EB7\x5137\x7C97\x9ED1", L"DFLiHeiBold" },
    { L"\x83EF\x5EB7\x65B0\x5137\x7C97\x9ED1", L"DFLiHeiBold(P)" },
    { L"\x7D30\x660E\x9AD4", L"MingLiU" },
    { L"\x7d30\x660e\x9ad4_HKSCS", L"MingLiU_HKSCS" },
    { L"\x65B0\x7D30\x660E\x9AD4", L"PMingLiU" },
    { L"\xff28\xff27\xff7a\xff9e\xff7c\xff6f\xff78\x0045-PRO", L"\xff28\xff27\x30b4\x30b7\x30c3\x30af\x0045-PRO" } // HACK (cthrash) For Outlook/OE (see IE5 #76530)
};
    
#define NUM sizeof(anpTable) / sizeof(WCHAR *)

void OutString( FILE *f, WCHAR * pch )
{
    int fLastWasHex = 0;
    
    printf("L\"");
    while (*pch)
    {
        WCHAR c = *pch++;

        if (   c < 128
            && (   !fLastWasHex
                || (   !InRange(L'0', c, L'9')
                    && !InRange(L'a', c, L'f')
                    && !InRange(L'A', c, L'F'))))
        {
            fputc(c,f);
            fLastWasHex = 0;
        }
        else
        {
            fprintf(f,"\\x%04x", c);
            fLastWasHex = 1;
        }
    }
    fprintf(f, "\"");
}

struct NAMEINDEX
{
    WCHAR * pchName;
    int nIndex;
};

struct NAMEINDEX *aniTable;

void MakeTable()
{
    int i;
    struct NAMEINDEX * pni;
    
    aniTable = (struct NAMEINDEX *)malloc( NUM * sizeof(struct NAMEINDEX ));

    pni = aniTable;
    
    for (i=0; i<NUM/2; i++)
    {
        pni->pchName = anpTable[i].pszAName;
        pni->nIndex = i;
        pni++;
        pni->pchName = anpTable[i].pszBName;
        pni->nIndex = NUM + i;
        pni++;
    }
}

int __cdecl cmpfunc( const void *v0, const void *v1)
{
    return StrCmpIC( ((struct NAMEINDEX *)v0)->pchName,
                     ((struct NAMEINDEX *)v1)->pchName );
}

void main(void)
{
    const int c = NUM;
    int i;

    MakeTable();
    
    qsort( aniTable, c, sizeof(struct NAMEINDEX), cmpfunc );

    for (i=0; i<c; i++)
    {
        printf("const TCHAR g_pszAltFontName%03d[] = ", i);
        OutString(stdout, aniTable[i].pchName);
        printf(";\n");
    }

    printf("\nconst TCHAR * const pszAltFontNames[] = \n{\n");
    for (i=0; i<c; i++)
    {
        printf("   g_pszAltFontName%03d,\n", i);
    }
    printf("};\n");

    printf("\nconst TCHAR * const pszAltFontNamesAlt[] = \n{\n");
    for (i=0; i<c; i++)
    {
        struct NAMEINDEX ni;
        struct NAMEINDEX *pni;

        ni.pchName = aniTable[i].nIndex >= NUM
                     ? anpTable[aniTable[i].nIndex-NUM].pszAName
                     : anpTable[aniTable[i].nIndex].pszBName;

        pni = (struct NAMEINDEX *)bsearch( &ni,
                                           aniTable,
                                           c,
                                           sizeof(struct NAMEINDEX),
                                           cmpfunc);

        printf("   g_pszAltFontName%03d,\n", pni - aniTable);
    }
    printf("};\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright (c)1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\trixacc.h ===
//	trixacc.h
//	Private interface for ITriEditAccess
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __TRIXACC_PRIVATE_H__
#define __TRIXACC_PRIVATE_H__


typedef interface ITriEditExtendedAccess ITriEditExtendedAccess;


DEFINE_GUID(IID_ITriEditExtendedAccess, 0x5387A2AE,0x0D6A,0x11d3,0x96,0x34,0x00,0xC0,0x4f,0x79,0xef,0xc4);

MIDL_INTERFACE("5387A2AE-0D6A-11d3-9634-00C04F79EFC4")
ITriEditExtendedAccess : public IUnknown
{
	public:
     STDMETHOD(GetCharsetFromStream)( IStream* piStream, BSTR* pbstrCodePage);
    
};

#endif //__TRIXACC_PRIVATE_H__

// End of trixacc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\triediid.h ===
// GUIDs for TriEdit.dll Active Document
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef _triediid_h_
#define _triediid_h_

#ifdef __cplusplus
extern "C"{
#endif 

EXTERN_C const GUID  GUID_TriEditCommandGroup;
EXTERN_C const IID   IID_ITriEditDocument;
EXTERN_C const IID   LIBID_TRIEDITLib;
EXTERN_C const CLSID CLSID_TriEditDocument;

DEFINE_GUID(GUID_TriEditCommandGroup, 0x2582f1c0, 0x084e, 0x11d1, 0x9a, 0x0e, 0x00, 0x60, 0x97, 0xc9, 0xb3, 0x44);
DEFINE_GUID(IID_ITriEditDocument,     0x438DA5DF, 0xF171, 0x11D0, 0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8);
DEFINE_GUID(LIBID_TRIEDITLib,         0x438DA5D1, 0xF171, 0x11D0, 0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8);
DEFINE_GUID(CLSID_TriEditDocument,    0x438DA5E0, 0xF171, 0x11D0, 0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8);

#ifdef __cplusplus
}
#endif

#endif	// _triediid_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\vidstamp.h ===
/* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved */

#if 	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if 	(rup == 0)

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b

#else	/* !(rup == 0) */

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b "." ruppad #c

#if 	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c) 		VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR		VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION			rmj,rmm,0,rup

/*--------------------------------------------------------------*/
/* the following section defines values used in the version 	*/
/* data structure for all files, and which do not change.		*/
/*--------------------------------------------------------------*/

#if defined(_SHIP)
#define VER_DEBUG					0
#else
#define VER_DEBUG					VS_FF_DEBUG
#endif

#if defined(_SHIP)
#define VER_PRIVATEBUILD			0
#else
#define VER_PRIVATEBUILD			VS_FF_PRIVATEBUILD
#endif

#if defined(_SHIP)
#define VER_PRERELEASE				0
#else
#define VER_PRERELEASE				VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK			VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS					VOS__WINDOWS32
#else
#define VER_FILEOS					VOS_DOS_WINDOWS16
#endif

#if defined(_DEBUG)
#define VER_FILEFLAGS				(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#else
#define VER_FILEFLAGS				0
#endif

#define VER_COMPANYNAME_STR 		"Microsoft Corporation"
#define VER_PRODUCTNAME_STR		"Microsoft (R) Visual InterDev"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\inc\version.h ===
/* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved */

#define rmj		6
#define rmm		1
/* It is CRITICAL to bump the version number with each release. */
#define rup		9212
#define szVerName	""
#define szVerUser	"IE"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\ambients.cpp ===
/*
 * AMBIENTS.CPP
 * Implementation of the ambient properties IDispatch on a
 * control site.
 *
 * Copyright (c)1995-1996 Microsoft Corporation, All Rights Reserved
 */

#include "stdafx.h"
#include <docobj.h>
#include "site.h"
#include "proxyframe.h"
#include "mshtmdid.h"

/*
 * CImpAmbientIDispatch::CImpAmbientIDispatch
 * CImpAmbientIDispatch::~CImpAmbientIDispatch
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpAmbientIDispatch::CImpAmbientIDispatch( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
    return;
}

CImpAmbientIDispatch::~CImpAmbientIDispatch(void)
{
    return;
}

/*
 * CImpAmbientIDispatch::QueryInterface
 * CImpAmbientIDispatch::AddRef
 * CImpAmbientIDispatch::Release
 */

STDMETHODIMP CImpAmbientIDispatch::QueryInterface(REFIID riid, void** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CImpAmbientIDispatch::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpAmbientIDispatch::Release(void)
{
    m_cRef--;
    return m_pUnkOuter->Release();
}


/*
 * CImpAmbientIDispatch::GetTypeInfoCount
 * CImpAmbientIDispatch::GetTypeInfo
 * CImpAmbientIDispatch::GetIDsOfNames
 *
 * Unimplemented members, not needed for ambient properties.
 */

STDMETHODIMP CImpAmbientIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo=0;
    return E_NOTIMPL;
}

STDMETHODIMP CImpAmbientIDispatch::GetTypeInfo(
	UINT		/*itinfo*/,
	LCID		/*lcid*/,
	ITypeInfo**	pptInfo
)
{
    *pptInfo=NULL;
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CImpAmbientIDispatch::GetIDsOfNames(
	REFIID		/*riid*/,
	OLECHAR**	rgszNames,
	UINT		/*cNames*/,
	LCID		/*lcid*/,
	DISPID*		rgDispID)
{
    *rgszNames	= NULL;
    *rgDispID	= NULL;
    return ResultFromScode(E_NOTIMPL);
}


/*
 * CImpAmbientIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispIDMember    DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */


STDMETHODIMP CImpAmbientIDispatch::Invoke(
	DISPID			dispIDMember,
	REFIID			riid,
	LCID			/*lcid*/,
	unsigned short	wFlags,
	DISPPARAMS*		/*pDispParams*/,
	VARIANT*		pVarResult,
	EXCEPINFO*		/*pExcepInfo*/,
	UINT*			/*puArgErr*/
)
{
    HRESULT			hr;
    VARIANT			varResult;
	VARIANT_BOOL	vbBool	= VARIANT_FALSE;


    if (IID_NULL!=riid)
        return ResultFromScode(E_INVALIDARG);

    if(NULL==pVarResult)
      pVarResult=&varResult;

    VariantInit(pVarResult);

    //The most common case is boolean, use as an initial type
    V_VT(pVarResult)=VT_BOOL;

    /*
     * Process the requested ambient property.  Anything but a
     * request for a property is invalid, so we can check that
     * before looking at the specific ID.  We can only get away
     * with this because all properties are read-only.
     */

    if (!(DISPATCH_PROPERTYGET & wFlags))
        return ResultFromScode(DISP_E_MEMBERNOTFOUND);

    hr = NOERROR;
    switch (dispIDMember)
	{
        case DISPID_AMBIENT_USERMODE:
            hr = m_pSite->GetFrame()->GetBrowseMode( &vbBool );
			if ( SUCCEEDED ( hr ) )
			{
				V_BOOL(pVarResult) = vbBool;
			}
            break;

	// BUG 542694: Disalbe the loading of frames.
        case DISPID_AMBIENT_DLCONTROL:
			if ( m_pSite->GetFrame() &&
				 m_pSite->GetFrame()->GetControl() &&
				 m_pSite->GetFrame()->GetControl()->IsSafeForScripting() )
			{
				V_VT(pVarResult)=VT_I4;
				V_I4(pVarResult) =
						DLCTL_DLIMAGES |
						DLCTL_NO_SCRIPTS |
						DLCTL_NO_DLACTIVEXCTLS |
						DLCTL_NO_FRAMEDOWNLOAD |
						DLCTL_NO_CLIENTPULL |
						DLCTL_NOFRAMES;
			}
            break;

        default:
            hr=ResultFromScode(DISP_E_MEMBERNOTFOUND);
            break;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\cpdhtmled.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// CProxy_DHTMLEditEvents

#include "triedtctlid.h"
template <class T> class CProxy_DHTMLSafeEvents : public IConnectionPointImpl<T, &DIID__DHTMLSafeEvents, CComDynamicUnkArray>
{
public:
//methods:
//_DHTMLEditEvents : IDispatch
public:

	void Fire_Generic_Event ( DISPID dispid )
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	VARIANT_BOOL Fire_Generic_Boolean_Event ( DISPID dispid )
	{
		VARIANT_BOOL	vbCancel = FALSE;
		CComVariant		varCancel ( VARIANT_FALSE );
		T*				pT = (T*)this;

		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			varCancel.ChangeType ( VT_BOOL );
			if ( varCancel.boolVal )
			{
				break;	// give up once we've received a cancel.
			}
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varCancel, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		return varCancel.boolVal;
	}
	void Fire_DocumentComplete()
	{
		Fire_Generic_Event ( DISPID_DOCUMENTCOMPLETE );
	}
	void Fire_DisplayChanged()
	{
		Fire_Generic_Event ( DISPID_DISPLAYCHANGED );
	}
	void Fire_ShowContextMenu( long xPos, long yPos)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		for (int i = 0; i < 2; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= yPos;
				pvars[1].vt = VT_I4;
				pvars[1].lVal= xPos;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_SHOWCONTEXTMENU, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_ContextMenuAction(
		long itemIndex)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= itemIndex;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_CONTEXTMENUACTION, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_onmousedown ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEDOWN );
	}
	void Fire_onmousemove ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEMOVE );
	}
	void Fire_onmouseup ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEUP );
	}
	void Fire_onmouseout ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOUT );
	}
	void Fire_onmouseover ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOVER );
	}
	void Fire_onclick ()
	{
		Fire_Generic_Event ( DISPID_ONCLICK );
	}
	void Fire_ondblclick ()
	{
		Fire_Generic_Event ( DISPID_ONDBLCLICK );
	}
	void Fire_onkeydown ()
	{
		Fire_Generic_Event ( DISPID_ONKEYDOWN );
	}
	void Fire_onkeypress ()
	{
		Fire_Generic_Event ( DISPID_ONKEYPRESS );
	}
	void Fire_onkeyup ()
	{
		Fire_Generic_Event ( DISPID_ONKEYUP );
	}
	void Fire_onblur ()
	{
		Fire_Generic_Event ( DISPID_ONBLUR );
	}
	void Fire_onreadystatechange ()
	{
		Fire_Generic_Event ( DISPID_ONREADYSTATECHANGE );
	}
};


template <class T>
class CProxy_DHTMLEditEvents : public IConnectionPointImpl<T, &DIID__DHTMLEditEvents, CComDynamicUnkArray>
{
public:
//methods:
//_DHTMLEditEvents : IDispatch
public:

	void Fire_Generic_Event ( DISPID dispid )
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	VARIANT_BOOL Fire_Generic_Boolean_Event ( DISPID dispid )
	{
		VARIANT_BOOL	vbCancel = FALSE;
		CComVariant		varCancel = VARIANT_FALSE;
		T*				pT = (T*)this;

		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			varCancel.ChangeType ( VT_BOOL );
			if ( VARIANT_TRUE == varCancel.boolVal )
			{
				break;	// give up once we've received a cancel.
			}
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varCancel, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		return varCancel.boolVal;
	}
	void Fire_DocumentComplete()
	{
		Fire_Generic_Event ( DISPID_DOCUMENTCOMPLETE );
	}
	void Fire_DisplayChanged()
	{
		Fire_Generic_Event ( DISPID_DISPLAYCHANGED );
	}
	void Fire_ShowContextMenu( long xPos, long yPos)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		for (int i = 0; i < 2; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= yPos;
				pvars[1].vt = VT_I4;
				pvars[1].lVal= xPos;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_SHOWCONTEXTMENU, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_ContextMenuAction(
		long itemIndex)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= itemIndex;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_CONTEXTMENUACTION, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_onmousedown ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEDOWN );
	}
	void Fire_onmousemove ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEMOVE );
	}
	void Fire_onmouseup ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEUP );
	}
	void Fire_onmouseout ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOUT );
	}
	void Fire_onmouseover ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOVER );
	}
	void Fire_onclick ()
	{
		Fire_Generic_Event ( DISPID_ONCLICK );
	}
	void Fire_ondblclick ()
	{
		Fire_Generic_Event ( DISPID_ONDBLCLICK );
	}
	void Fire_onkeydown ()
	{
		Fire_Generic_Event ( DISPID_ONKEYDOWN );
	}
	void Fire_onkeypress ()
	{
		Fire_Generic_Event ( DISPID_ONKEYPRESS );
	}
	void Fire_onkeyup ()
	{
		Fire_Generic_Event ( DISPID_ONKEYUP );
	}
	void Fire_onblur ()
	{
		Fire_Generic_Event ( DISPID_ONBLUR );
	}
	void Fire_onreadystatechange ()
	{
		Fire_Generic_Event ( DISPID_ONREADYSTATECHANGE );
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>
#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")

ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix);
ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric);
ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T> class CComControl;
class CComDispatchDriver;

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	DISPID dispid;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;

};

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
	CComDispatchDriver()
	{
		p = NULL;
	}
	CComDispatchDriver(IDispatch* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComDispatchDriver(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IDispatch, (void **)&p);
	}
	~CComDispatchDriver() { if (p) p->Release(); }
	void Release() {if (p) p->Release(); p=NULL;}
	operator IDispatch*() {return p;}
	IDispatch& operator*() {_ASSERTE(p!=NULL); return *p; }
	IDispatch** operator&() {_ASSERTE(p==NULL); return &p; }
	IDispatch* operator->() {_ASSERTE(p!=NULL); return p; }
	IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
	IDispatch* operator=(IUnknown* lp)
	{
		return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

	HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
	{
		_ASSERTE(p);
		return GetProperty(p, dwDispID, pVar);
	}
	HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
	{
		_ASSERTE(p);
		return PutProperty(p, dwDispID, pVar);
	}

	static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar);
	static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar);
	IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent
class CFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID);
	static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID);
};


//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
};


typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// CComControl
class ATL_NO_VTABLE CComControlBase
{
public:
	CComControlBase(HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE(_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here
	// non-virtuals only please
	void SetDirty(BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	BOOL GetDirty()
	{
		return m_bRequiresSave ? TRUE : FALSE;
	}
	void GetZoomInfo(ATL_DRAWINFO& di);
	HRESULT SendOnRename(IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	HRESULT SendOnDataChange(DWORD advf = 0);
	HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	LRESULT OnSetFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite)
			spSite->OnFocus(TRUE);
		return 0;
	}

	LRESULT OnKillFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite)
			spSite->OnFocus(FALSE);
		return 0;
	}
	LRESULT OnGetDlgCode(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		return 0;
	}

	HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		_ASSERTE(var.vt == VT_I2 || FAILED(hRes));
		nAppearance = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(BSTR& bstrDiaplayName)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		_ASSERTE(var.vt == VT_BSTR || FAILED(hRes));
		bstrDiaplayName = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientFont(IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		_ASSERTE((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		_ASSERTE(var.vt == VT_BSTR || FAILED(hRes));
		bstrScaleUnits = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientTextAlign(short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		_ASSERTE(var.vt == VT_I2 || FAILED(hRes));
		nTextAlign = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientUserMode(BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bUserMode = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientUIDead(BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bUIDead = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bShowGrabHandles = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bShowHatching = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bMessageReflect = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bAutoClip = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bDisplaysDefault = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		bSupportMnemonics = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientPalette(HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
		_ASSERTE(var.vt == VT_INT_PTR || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(var.byref);
		return hRes;
	}

	BOOL DoesVerbUIActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
		QACONTROL *pQACtrl);
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
		LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
		BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap);
	HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
		ATL_PROPMAP_ENTRY* pMap);
	HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
	HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);
	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */,
		ATL_PROPMAP_ENTRY* pMap);

	HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT IOleObject_Close(DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
	HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
		DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
		LPCRECTL prcBounds, LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */,
		BOOL& /* lResult */);

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		return S_OK;
	}


// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
	union
	{
		// m_nFreezeEvents is the only one actually used
		int m_nFreezeEvents; // count of freezes versus thaws

		// These are here to make stock properties work
		IPictureDisp* m_pMouseIcon;
		IPictureDisp* m_pPicture;
		IFontDisp* m_pFont;
		OLE_COLOR m_clrBackColor;
		OLE_COLOR m_clrBorderColor;
		OLE_COLOR m_clrFillColor;
		OLE_COLOR m_clrForeColor;
		BSTR m_bstrText;
		BSTR m_bstrCaption;
		BOOL m_bValid;
		BOOL m_bTabStop;
		BOOL m_bBorderVisible;
		BOOL m_bEnabled;
		long m_nBackStyle;
		long m_nBorderStyle;
		long m_nBorderWidth;
		long m_nDrawMode;
		long m_nDrawStyle;
		long m_nDrawWidth;
		long m_nFillStyle;
		long m_nAppearance;
		long m_nMousePointer;
		long m_nReadyState;
	};

	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels
};

template <class T>
class ATL_NO_VTABLE CComControl :  public CComControlBase, public CWindowImpl<T>
{
public:
	CComControl() : CComControlBase(m_hWnd) {}
	HRESULT FireOnRequestEdit(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryInterface(iid, ppv);
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}
};

// Forward declarations
//
template <class T> class IPersistImpl;
template <class T> class IPersistStreamInitImpl;
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class ISpecifyPropertyPagesImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}
};

#define BEGIN_PROPERTY_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), dispid, &clsid, &IID_IDispatch},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), dispid, &clsid, &iidDispatch},

#define PROP_PAGE(clsid) \
		{NULL, NULL, &clsid, &IID_NULL},

#define END_PROPERTY_MAP() \
			{NULL, 0, NULL, &IID_NULL} \
		}; \
		return pPropMap; \
	}


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStreamInitImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistStreamInitImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE(_T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		ATLTRACE(_T("IPersistStreamInitImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
	{
		ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPersistStreamInitImpl::InitNew\n"));
		pT->SendOnDataChange();
		return S_OK;
	}

};


//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStorageImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistStorageImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE(_T("IPersistStorageImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(IStorage*)
	{
		ATLTRACE(_T("IPersistStorageImpl::InitNew\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(IStorage* pStorage)
	{
		ATLTRACE(_T("IPersistStorageImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
	{
		ATLTRACE(_T("IPersistStorageImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
	{
		ATLTRACE(_T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE(_T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
	return p;
}

//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl
{
public:

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistPropertyBagImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::InitNew\n"));
		return S_OK;
	}
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl)

	// IOleControl methods
	//
	STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		dispid;
		ATLTRACE(_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE(_T(" -- DISPID = %d (%d)\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IQuickActivateImpl)

	// IQuickActivate
	//
	STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::QuickActivate\n"));
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleObjectImpl)

	// IOleObject
	//
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE(_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		else
			return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
	}
	HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
	}
	HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
	}
	HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		pT->UIDeactivate();
		if (pT->m_hWnd)
			pT->ShowWindow(SW_HIDE);
		return S_OK;
	}
	HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		return S_OK;
	}
	HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		return S_OK;
	}
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::DoVerb\n"));
		_ASSERTE(pT->m_spClientSite);

		HRESULT hr = E_NOTIMPL;
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_INPLACEACTIVATE:
			hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_UIACTIVATE:
			hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_HIDE:
			hr = pT->DoVerbHide(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_OPEN:
			hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_DISCARDUNDOSTATE:
			hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_PROPERTIES:
			hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
		}
		return hr;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE(_T("IOleObjectImpl::EnumVerbs\n"));
		_ASSERTE(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
	STDMETHOD(Update)(void)
	{
		ATLTRACE(_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE(_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
		ATLTRACE(_T("IOleObjectImpl::GetUserClassID\n"));
		_ASSERTE(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
		ATLTRACE(_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::EnumAdvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
		return hRes;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
		ATLTRACE(_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl
{

public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl)

	void SetDirty(BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (!pT->m_bDirty && bDirty)
			pT->m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE);
		pT->m_bDirty = bDirty;
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE(_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE(_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)( void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE(_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE(_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
								   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE(_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
		DLGTEMPLATE* pTemp = (DLGTEMPLATE*)LockResource(hGlob);
		if (pTemp == NULL)
		{
			ATLTRACE(_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		pT->GetDialogSize(pTemp, &m_size);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION;

		ATLTRACE(_T("IPropertyPageImpl::Help\n"));
		WinHelp(pT->m_hWnd, OLE2CT(pszHelpDir), HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(MSG *pMsg)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::TranslateAccelerator\n"));
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(UINT idRes)
	{
		USES_CONVERSION;

		TCHAR szTemp[_MAX_PATH];
		LPOLESTR sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
		if (sz == NULL)
			return NULL;
		sz[0] = NULL;

		if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
			ocscpy(sz, T2OLE(szTemp));
		else
		{
			ATLTRACE(_T("Error : Failed to load string from res\n"));
		}

		return sz;
	}

	void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		// If the dialog has a font we use it otherwise we default
		// to the system font.
		if (HasFont(pTemplate))
		{
			TCHAR szFace[LF_FACESIZE];
			WORD  wFontSize = 0;
			GetFont(pTemplate, szFace, &wFontSize);
			GetSizeInDialogUnits(pTemplate, pSize);
			ConvertDialogUnitsToPixels(szFace, wFontSize, pSize);
		}
		else
		{
			GetSizeInDialogUnits(pTemplate, pSize);
			LONG nDlgBaseUnits = GetDialogBaseUnits();
			pSize->cx = MulDiv(pSize->cx, LOWORD(nDlgBaseUnits), 4);
			pSize->cy = MulDiv(pSize->cy, HIWORD(nDlgBaseUnits), 8);
		}
	}

	static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel)
	{
		// Attempt to create the font to be used in the dialog box
		UINT cxSysChar, cySysChar;
		LOGFONT lf;
		HDC hDC = ::GetDC(NULL);
		int cxDlg = pSizePixel->cx;
		int cyDlg = pSizePixel->cy;

		ZeroMemory(&lf, sizeof(LOGFONT));
		lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
		lf.lfWeight = FW_NORMAL;
		lf.lfCharSet = DEFAULT_CHARSET;
		lstrcpy(lf.lfFaceName, pszFontFace);

		HFONT hNewFont = CreateFontIndirect(&lf);
		if (hNewFont != NULL)
		{
			TEXTMETRIC  tm;
			SIZE        size;
			HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
			GetTextMetrics(hDC, &tm);
			cySysChar = tm.tmHeight + tm.tmExternalLeading;
			::GetTextExtentPoint(hDC,
				_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
				&size);
			cxSysChar = (size.cx + 26) / 52;
			SelectObject(hDC, hFontOld);
			DeleteObject(hNewFont);
		}
		else
		{
			// Could not create the font so just use the system's values
			cxSysChar = LOWORD(GetDialogBaseUnits());
			cySysChar = HIWORD(GetDialogBaseUnits());
		}
		::ReleaseDC(NULL, hDC);

		// Translate dialog units to pixels
		pSizePixel->cx = MulDiv(cxDlg, cxSysChar, 4);
		pSizePixel->cy = MulDiv(cyDlg, cySysChar, 8);
	}

	static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
	{
		return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	static BOOL HasFont(const DLGTEMPLATE* pTemplate)
	{
		return (DS_SETFONT &
			(IsDialogEx(pTemplate) ?
				((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
	}

	static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);
		WORD* pw;

		if (bDialogEx)
			pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
		else
			pw = (WORD*)(pTemplate + 1);

		if (*pw == (WORD)-1)        // Skip menu name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		if (*pw == (WORD)-1)        // Skip class name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		while (*pw++);          // Skip caption string

		return (BYTE*)pw;
	}

	static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize)
	{
		USES_CONVERSION;
		if (!HasFont(pTemplate))
			return FALSE;

		BYTE* pb = GetFontSizeField(pTemplate);
		*pFontSize = *(WORD*)pb;
		// Skip over font attributes to get to the font name
		pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);

		_tcscpy(pszFace, W2T((WCHAR*)pb));
		return TRUE;
	}

	static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		if (IsDialogEx(pTemplate))
		{
			pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
			pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
		}
		else
		{
			pSize->cx = pTemplate->cx;
			pSize->cy = pTemplate->cy;
		}
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(DISPID dispID)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPerPropertyBrowsingImpl)

	STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
	{
		ATLTRACE(_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		T* pT = static_cast<T*>(this);
		CComVariant var;
		if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
		{
			*pBstr = NULL;
			return S_FALSE;
		}

		BSTR bstrTemp = var.bstrVal;
		if (var.vt != VT_BSTR)
		{
			CComVariant varDest;
			if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
			{
				*pBstr = NULL;
				return S_FALSE;
			}
			bstrTemp = varDest.bstrVal;
		}
		*pBstr = SysAllocString(bstrTemp);
		return S_OK;
	}

	STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
	{
		ATLTRACE(_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;
			if (pMap[i].dispid == dispID)
			{
				_ASSERTE(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
	{
		dispID;
		ATLTRACE(_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;
		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		return S_OK;
	}
	STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
	{
		ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IViewObjectExImpl)

	// IViewObject
	//
	STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
					DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
					LPCRECTL prcBounds, LPCRECTL prcWBounds,
					BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
					DWORD_PTR /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}

	STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetAdvise\n"));
		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink.p->AddRef();
		}
		return S_OK;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetExtent\n"));
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus =
//          VIEWSTATUS_DVASPECTOPAQUE | VIEWSTATUS_DVASPECTTRANSPARENT |
//          VIEWSTATUS_SOLIDBKGND |
			VIEWSTATUS_OPAQUE;

		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
	{
		ATLTRACE(_T("IViewObjectExImpl::QueryHitPoint\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE(_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
	{
		ATLTRACE(_T("IViewObjectExImpl::QueryHitRect\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE(_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetNaturalExtent\n"));
		HRESULT hRes = E_FAIL;
		if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceObjectWindowlessImpl)

	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		return (pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult)) ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceActiveObjectImpl)

	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(HWND *phwnd)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(LPMSG /* lpmsg */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		return E_NOTIMPL;
	}
	STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(BOOL /* fEnable */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(ISpecifyPropertyPagesImpl)

	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(CAUUID* pPages)
	{
		ATLTRACE(_T("ISpecifyPropertyPagesImpl::GetPages\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return pT->ISpecifyPropertyPages_GetPages(pPages, pMap);
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPointerInactiveImpl)

	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IRunnableObjectImpl)

	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
	{
		ATLTRACE(_T("IRunnableObjectImpl::GetRunningClass\n"));
		T* pT = static_cast<T*>(this);
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(LPBINDCTX)
	{
		ATLTRACE(_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE(_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE(_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
	{
		ATLTRACE(_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IDataObjectImpl)

	// IDataObject
	//
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACE(_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACE(_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACE(_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE(_T("IDataObjectImpl::EnumDAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = E_FAIL;
		if (pT->m_spDataAdviseHolder != NULL)
			hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T>
class ATL_NO_VTABLE IObjectSafetyImpl
{
public:
	IObjectSafetyImpl()
	{
		m_dwSafety = 0;
	}

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl)

	// IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
		HRESULT hr = S_OK;
		if (riid == IID_IDispatch)
		{
			*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		}
		else
		{
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions = 0;
			hr = E_NOINTERFACE;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		// If we're being asked to set our safe for scripting option then oblige
		if (riid == IID_IDispatch)
		{
			// Store our current safety level to return in GetInterfaceSafetyOptions
			m_dwSafety = dwEnabledOptions & dwOptionSetMask;
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	DWORD m_dwSafety;
};


template <class T>
class ATL_NO_VTABLE IOleLinkImpl
{
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleLinkImpl)

	STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
	{
		ATLTRACE(_T("IOleLink::GetSourceDisplayName\n"));
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE(_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};


template <class T>
class ATL_NO_VTABLE IBindStatusCallbackImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IBindStatusCallbackImpl)

	// IBindStatusCallback
	//
	STDMETHOD(OnStartBinding)(DWORD /* dwReserved */, IBinding *pBinding)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnStartBinding\n"));
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG* /* pnPriority */)
	{
		ATLTRACENOTIMPL(_T("IBindStatusCallbackImpl::GetPriority"));
	}

	STDMETHOD(OnLowResource)(DWORD /* reserved */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnLowResource\n"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(ULONG /* ulProgress */, ULONG /* ulProgressMax */, ULONG /* ulStatusCode */, LPCWSTR /* szStatusText */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnProgress\n"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT /* hresult */, LPCWSTR /* szError */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnStopBinding\n"));
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD* /* pgrfBINDF */, BINDINFO* /* pBindInfo */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::GetBindInfo\n"));
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnDataAvailable\n"));
		return S_OK;
	}

	STDMETHOD(OnObjectAvailable)(REFIID /* riid */, IUnknown* /* punk */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnObjectAvailable\n"));
		return S_OK;
	}
};


template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<typename T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallbackImpl<T>
{
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
	COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl<T>)
END_COM_MAP()


	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	~CBindStatusCallback()
	{
		ATLTRACE(_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
	{
		ATLTRACE(_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG *pnPriority)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::GetPriority"));
	}

	STDMETHOD(OnLowResource)(DWORD reserved)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnLowResource"));
	}

	STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnProgress"));
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
	{
		ATLTRACE(_T("CBindStatusCallback::OnStopBinding\n"));
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
	{
		ATLTRACE(_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
			BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

		ULONG cbSize = pbindInfo->cbSize;		// remember incoming cbSize
		memset(pbindInfo, 0, cbSize);			// zero out structure
		pbindInfo->cbSize = cbSize;				// restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	// set verb
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE(_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
					return S_FALSE;
				hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
				if (SUCCEEDED(hr))
				{
					pBytes[dwActuallyRead] = 0;
					if (dwActuallyRead>0)
					{
						(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
						m_dwTotalRead += dwActuallyRead;
					}
				}
				delete[] pBytes;
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnObjectAvailable"));
	}

	HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), IID_IStream, (void**)&spStream);
				ATLTRACE(_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;
		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname; \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		*(&(pT->m_##pname)) = SysAllocString(pname); \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = SysAllocString(pT->m_##pname); \
		return S_OK; \
	}

template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = 0;
		if (pFont)
		{
			CComQIPtr<IFont, &IID_IFont> p(pFont);
			if (p)
			{
				CComPtr<IFont> pFont;
				p->Clone(&pFont);
				if (pFont)
					pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = pFont;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		T* pT = (T*) this;
		*ppFont = pT->m_pFont;
		if (*ppFont != NULL)
			(*ppFont)->AddRef();
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		T* pT = (T*) this;
		*ppPicture = pT->m_pPicture;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		T* pT = (T*) this;
		*ppPicture = pT->m_pMouseIcon;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
        IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(LONG /*hWnd*/)
	{
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_Window(LONG* phWnd)
	{
		T* pT = (T*) this;
		*phWnd = (LONG)(LONG_PTR)pT->m_hWnd;
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(long, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(long, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(long, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(long, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(long, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(long, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(long, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(long, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(long, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(long, ReadyState, nReadyState, DISPID_READYSTATE)
};

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#endif // __ATLCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\deinstab.cpp ===
// DEInsTab.cpp : Implementation of CDEInsertTableParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DEInsTab.h"

/////////////////////////////////////////////////////////////////////////////
// CDEInsertTableParam

static WCHAR k_wszEmpty[] = L"";


CDEInsertTableParam::CDEInsertTableParam()
{
	m_nNumRows = 3;
	m_nNumCols = 3;
	m_bstrTableAttrs = ::SysAllocString(L"border=1 cellPadding=1 cellSpacing=1 width=75%");
	m_bstrCellAttrs = ::SysAllocString(k_wszEmpty);
	m_bstrCaption = ::SysAllocString(k_wszEmpty);
}

CDEInsertTableParam::~CDEInsertTableParam()
{
	::SysFreeString(m_bstrTableAttrs);
	m_bstrTableAttrs = NULL;
	::SysFreeString(m_bstrCellAttrs);
	m_bstrCellAttrs = NULL;
	::SysFreeString(m_bstrCaption);
	m_bstrCaption = NULL;
}

STDMETHODIMP CDEInsertTableParam::get_NumRows(LONG * pVal)
{
	_ASSERTE(pVal);

	*pVal = m_nNumRows;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_NumRows(LONG newVal)
{
	m_nNumRows = newVal;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_NumCols(LONG * pVal)
{
	_ASSERTE(pVal);

	*pVal = m_nNumCols;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_NumCols(LONG newVal)
{
	m_nNumCols = newVal;
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_TableAttrs(BSTR * pVal)
{
	*pVal = ::SysAllocString(m_bstrTableAttrs);
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_TableAttrs(BSTR newVal)
{
	::SysFreeString(m_bstrTableAttrs);
	if ( NULL == newVal )
	{
		m_bstrTableAttrs = ::SysAllocString(k_wszEmpty);
	}
	else
	{
		m_bstrTableAttrs = ::SysAllocString(newVal);
	}
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_CellAttrs(BSTR * pVal)
{
	*pVal = ::SysAllocString(m_bstrCellAttrs);
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_CellAttrs(BSTR newVal)
{
	::SysFreeString(m_bstrCellAttrs);
	if ( NULL == newVal )
	{
		m_bstrCellAttrs = ::SysAllocString(k_wszEmpty);
	}
	else
	{
		m_bstrCellAttrs = ::SysAllocString(newVal);
	}
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::get_Caption(BSTR * pVal)
{
	*pVal = ::SysAllocString(m_bstrCaption);
	return S_OK;
}

STDMETHODIMP CDEInsertTableParam::put_Caption(BSTR newVal)
{
	::SysFreeString(m_bstrCaption);
	if ( NULL == newVal )
	{
		m_bstrCaption = ::SysAllocString(k_wszEmpty);
	}
	else
	{
		m_bstrCaption = ::SysAllocString(newVal);
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\deinstab.h ===
// DEInsTab.h : Declaration of the CDEInsertTableParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DEINSERTTABLEPARAM_H_
#define __DEINSERTTABLEPARAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDEInsertTableParam
class ATL_NO_VTABLE CDEInsertTableParam : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDEInsertTableParam, &CLSID_DEInsertTableParam>,
	public IDispatchImpl<IDEInsertTableParam, &IID_IDEInsertTableParam, &LIBID_DHTMLEDLib>
{
public:
	CDEInsertTableParam();
	~CDEInsertTableParam();

private:

	ULONG	m_nNumRows;
	ULONG	m_nNumCols;
	BSTR	m_bstrTableAttrs;
	BSTR	m_bstrCellAttrs;
	BSTR	m_bstrCaption;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_DEINSERTTABLEPARAM)

BEGIN_COM_MAP(CDEInsertTableParam)
	COM_INTERFACE_ENTRY(IDEInsertTableParam)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDEInsertTableParam
public:
	STDMETHOD(get_Caption)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Caption)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CellAttrs)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CellAttrs)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_TableAttrs)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TableAttrs)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_NumCols)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_NumCols)(/*[in]*/ LONG newVal);
	STDMETHOD(get_NumRows)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_NumRows)(/*[in]*/ LONG newVal);
};

#endif //__DEINSERTTABLEPARAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dhshwui.cpp ===
/*
 * IDOCHOSTSHOWUI.CPP
 * IDocHostShowUI for Document Objects CSite class
 *
 * Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/


/*
 * CImpIDocHostShowUI::CImpIDocHostShowUI
 * CImpIDocHostShowUI::~CImpIDocHostShowUI
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CImpIDocHostShowUI::CImpIDocHostShowUI( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIDocHostShowUI::~CImpIDocHostShowUI( void )
{
}



/*
 * CImpIDocHostShowUI::QueryInterface
 * CImpIDocHostShowUI::AddRef
 * CImpIDocHostShowUI::Release
 *
 * Purpose:
 *  IUnknown members for CImpIDocHostShowUI object.
 */
STDMETHODIMP CImpIDocHostShowUI::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIDocHostShowUI::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIDocHostShowUI::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}


/*
 * CImpIDocHostShowUI::ShowMessage
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 */
STDMETHODIMP CImpIDocHostShowUI::ShowMessage(
            HWND /*hwnd*/,
            LPOLESTR /*lpstrText*/,
            LPOLESTR /*lpstrCaption*/, 
            DWORD /*dwType*/,
            LPOLESTR /*lpstrHelpFile*/,
            DWORD /*dwHelpContext*/,
            LRESULT* /*plResult*/)
{
	return S_FALSE;
}

/*
 * CImpIDocHostShowUI::ShowHelp
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 */
STDMETHODIMP CImpIDocHostShowUI::ShowHelp(
            HWND /*hwnd*/,
            LPOLESTR /*pszHelpFile*/,
            UINT /*uCommand*/,
            DWORD /*dwData*/,
            POINT /*ptMouse*/,
            IDispatch* /*pDispatchObjectHit*/)
{
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\denames.cpp ===
// DENames.cpp : Implementation of CDEGetBlockFmtNamesParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DENames.h"

/////////////////////////////////////////////////////////////////////////////
// CDEGetBlockFmtNamesParam

CDEGetBlockFmtNamesParam::CDEGetBlockFmtNamesParam()
{
	m_pNamesArray = NULL;

	m_pNamesArray = SafeArrayCreateVector(VT_VARIANT, 0, 0);	
	_ASSERTE(m_pNamesArray);

}


CDEGetBlockFmtNamesParam::~CDEGetBlockFmtNamesParam()
{
	if (m_pNamesArray)
		SafeArrayDestroy(m_pNamesArray);
}


//	This will always retreive a SafeArray of Variants containing BSTRs.
//
STDMETHODIMP CDEGetBlockFmtNamesParam::get_Names(VARIANT * pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);

	if (NULL == pVal)
		return E_INVALIDARG;

	VariantClear(pVal);

	V_VT(pVal) = VT_ARRAY|VT_VARIANT;
	hr = SafeArrayCopy(m_pNamesArray, &(V_ARRAY(pVal)));
	
	return hr;
}

//	The SafeArray gotten received from Trident is (currently) an array for BSTRs.
//	This works fine with VB, but not VBS or JScript.
//	We'll do the work at this end to copy the supplied array over to our private
//	storage as a SafeArray of Variants containing BSTRs.
//
STDMETHODIMP CDEGetBlockFmtNamesParam::put_Names(VARIANT* newVal)
{
	HRESULT hr = S_OK;
    LONG lLBound, lUBound, lIndex;

	_ASSERTE ( m_pNamesArray );
	_ASSERTE(VT_ARRAY == V_VT(newVal));
	_ASSERTE(NULL != V_ARRAY(newVal));

	if (VT_ARRAY != V_VT(newVal))
		return E_INVALIDARG;

	if (NULL == V_ARRAY(newVal))
		return E_INVALIDARG;

	SafeArrayGetLBound(V_ARRAY(newVal), 1, &lLBound);
	SafeArrayGetUBound(V_ARRAY(newVal), 1, &lUBound);

	SAFEARRAYBOUND rgsaBound[1];
	rgsaBound[0].lLbound	= 0;
	rgsaBound[0].cElements	= ( lUBound - lLBound ) + 1;
	hr = SafeArrayRedim ( m_pNamesArray, rgsaBound );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( FAILED ( hr ) )
	{
		SafeArrayDestroy ( V_ARRAY(newVal) );
		return hr;
	}

	// Copy all BSTRs or Variants from the source array to Variants in the m_pNamesArray
	VARIANT	var;
	BSTR	bstr = NULL;

	VariantInit ( &var );

	for (lIndex=lLBound; lIndex<=lUBound; lIndex++)
	{
		if ( FADF_BSTR & V_ARRAY(newVal)->fFeatures )
		{
			hr = SafeArrayGetElement(V_ARRAY(newVal), &lIndex, &bstr);
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( FAILED ( hr ) )
				break;

			// BSTR was copied, we can stick it in a variant, no release or duplicating needed.
			var.vt = VT_BSTR;
			var.bstrVal = bstr;
		}
		else if ( FADF_VARIANT & V_ARRAY(newVal)->fFeatures )
		{
			hr = SafeArrayGetElement(V_ARRAY(newVal), &lIndex, &var);
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( FAILED ( hr ) )
				break;

			hr = VariantChangeType ( &var, &var, 0, VT_BSTR );
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( FAILED ( hr ) )
				break;
		}
		else
		{
			_ASSERTE ( ( FADF_BSTR | FADF_VARIANT ) & V_ARRAY(newVal)->fFeatures );
			hr = E_UNEXPECTED;
			break;
		}

		hr = SafeArrayPutElement ( m_pNamesArray, &lIndex, &var );
		_ASSERTE ( SUCCEEDED ( hr ) );
		VariantClear ( &var );
	}

	VariantClear ( &var );	// In case a break occurred.
	SafeArrayDestroy ( V_ARRAY(newVal) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\denames.h ===
// DENames.h : Declaration of the CDEGetBlockFmtNamesParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DEGETBLOCKFMTNAMESPARAM_H_
#define __DEGETBLOCKFMTNAMESPARAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDEGetBlockFmtNamesParam
class ATL_NO_VTABLE CDEGetBlockFmtNamesParam : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDEGetBlockFmtNamesParam, &CLSID_DEGetBlockFmtNamesParam>,
	public IDispatchImpl<IDEGetBlockFmtNamesParam, &IID_IDEGetBlockFmtNamesParam, &LIBID_DHTMLEDLib>
{
public:
	CDEGetBlockFmtNamesParam();
	~CDEGetBlockFmtNamesParam();

private:
	SAFEARRAY* m_pNamesArray;
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DEGETBLOCKFMTNAMESPARAM)

BEGIN_COM_MAP(CDEGetBlockFmtNamesParam)
	COM_INTERFACE_ENTRY(IDEGetBlockFmtNamesParam)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDEGetBlockFmtNamesParam
public:
	STDMETHOD(get_Names)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_Names)(/*[in]*/ VARIANT* newVal);
};

#endif //__DEGETBLOCKFMTNAMESPARAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dhtmled.cpp ===
// DHTMLEd.cpp : Implementation of DLL Exports.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f DHTMLEdps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "DHTMLEd.h"
#include <TRIEDIID.h>
#include "DHTMLEd_i.c"
#include "DHTMLEdit.h"
#include "DEInsTab.h"
#include "DENames.h"


CComModule _Module;

static void SpikeSharedFileCount ();

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DHTMLEdit, CDHTMLEdit)
	OBJECT_ENTRY(CLSID_DHTMLSafe, CDHTMLSafe)
	OBJECT_ENTRY(CLSID_DEInsertTableParam, CDEInsertTableParam)
	OBJECT_ENTRY(CLSID_DEGetBlockFmtNamesParam, CDEGetBlockFmtNamesParam)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//
//	Array of CLSIDs as text to be DELETED when registering the control.
//	These represent no-longer supported GUIDs for interfaces of the past.
//	All GUIDs in this array will be deleted from the HKCR\CLSID section.
//	MAINTENANCE NOTE:
//	When interfaces get new GUIDs (and the old ones are to be invalidated)
//	add the old GUIDs here with appropriate comments.
//
static TCHAR* s_rtszOldClsids [] =
{
	TEXT("{683364AF-B37D-11D1-ADC5-006008A5848C}"),	// Original Edit control GUID
	TEXT("{711054E0-CA70-11D1-8CD2-00A0C959BC0A}"),	// Original Safe for Scripting GUID
	TEXT("{F8A79F00-DA38-11D1-8CD6-00A0C959BC0A}"),	// Intermediate Edit control GUID
	TEXT("{F8A79F01-DA38-11D1-8CD6-00A0C959BC0A}")	// Intermediate Safe for Scripting GUID
};


/////////////////////////////////////////////////////////////////////////////
//
//	Array of CURRENT Interface GUIDS.
//	Note that IIDs and CLSIDs are not equivalent!
//	ATL fails to unregister these when unregisterin the control.
//	MAINTENANCE NOTE:
//	When interface GUIDs are changed, update this array.
//
static TCHAR* s_rtszCurrentInterfaces [] =
{
	TEXT("{CE04B590-2B1F-11d2-8D1E-00A0C959BC0A}"),	// IDHTMLSafe
	TEXT("{CE04B591-2B1F-11d2-8D1E-00A0C959BC0A}"),	// IDHTMLEdit
	TEXT("{47B0DFC6-B7A3-11D1-ADC5-006008A5848C}"),	// IDEInsertTableParam
	TEXT("{8D91090D-B955-11D1-ADC5-006008A5848C}"),	// IDEGetBlockFmtNamesParam
	TEXT("{588D5040-CF28-11d1-8CD3-00A0C959BC0A}"),	// _DHTMLEditEvents
	TEXT("{D1FC78E8-B380-11d1-ADC5-006008A5848C}"),	// _DHTMLSafeEvents
};


//	MAINTENANCE NOTE:
//	If the GUID of the type library changes, update here:
//
static TCHAR* s_tszTypeLibGUID = TEXT("{683364A1-B37D-11D1-ADC5-006008A5848C}");


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
	}
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
//
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
STDAPI DllRegisterServer(void)
{
	HRESULT hr = S_OK;
	CRegKey keyClassID;

	SpikeSharedFileCount ();

	// Unregister old CLSIDs, just in case the user is upgrading without unregistering first.
	hr = keyClassID.Open ( HKEY_CLASSES_ROOT, TEXT("CLSID") );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( ERROR_SUCCESS == hr )
	{
		int ctszOldClsids = sizeof ( s_rtszOldClsids ) / sizeof ( TCHAR* );
		for ( int iOldIntf = 0; iOldIntf < ctszOldClsids; iOldIntf++ )
		{
			hr = keyClassID.RecurseDeleteKey ( s_rtszOldClsids [ iOldIntf ] );
		}
		hr = keyClassID.Close ();
	}
	// hr is NOT returned.  Any failure deleting possibly non-existant keys is OK.

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI DllUnregisterServer(void)
{
	HRESULT	hr		= S_OK;
	HRESULT hrMod	= _Module.UnregisterServer();

	// Since ATL does not unregister the TypeLib, do it manually.
	CRegKey	keyTypeLib;
	hr = keyTypeLib.Open ( HKEY_CLASSES_ROOT, TEXT("TypeLib") );
	if ( ERROR_SUCCESS == hr )
	{
		hr = keyTypeLib.RecurseDeleteKey ( s_tszTypeLibGUID );
		keyTypeLib.Close ();
	}

	// Delete all current GUIDs from the Interfaces section.  ATL fails to do this, too.
	CRegKey keyInterface;
	hr = keyInterface.Open ( HKEY_CLASSES_ROOT, TEXT("Interface") );
	if ( ERROR_SUCCESS == hr )
	{
		int ctszCurIntf = sizeof ( s_rtszCurrentInterfaces ) / sizeof ( TCHAR* );
		for ( int iCurIntf = 0; iCurIntf < ctszCurIntf; iCurIntf++ )
		{
			hr = keyInterface.RecurseDeleteKey ( s_rtszCurrentInterfaces [ iCurIntf ] );
		}
		hr = keyInterface.Close ();
	}
	// DO NOT RETURN the hr from above! It's OK to fail.

	return hrMod;
}


//	Because we've changed from a shared component to a system component, and we're now
//	installed by IE using RollBack rather than reference counting, a serious bug
//	occurs if we're installed once under IE4, IE5 is installed, and the original
//	product is uninstalled.  (We're deleted.  Bug 23681.)
//	This crude but effective routine spikes our reference count to 10000.
//	It doesn't matter so much where we're installed NOW, it matters where the shared
//	component was, or might be, installed.  Even if it's a different copy, the
//	DLL will be unregistered when its reference count is decremented to zero.
//
static void SpikeSharedFileCount ()
{
	CRegKey	keyShared;
	CRegKey	keyCurVer;
	HRESULT	hr = S_OK;

	hr = keyCurVer.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion" ) );
	_ASSERTE ( SUCCEEDED ( hr ) );

	if ( FAILED ( hr ) )
	{
		return;	// There's nothing we can do.
	}

	hr = keyShared.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls") );
	
	// We expect there to be a SharedDLLs key, but it's possible that there is none.
	if ( FAILED ( hr ) )
	{
		hr = keyShared.Create ( keyCurVer, TEXT("SharedDlls") );
	}

	_ASSERT ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
		TCHAR	tszPath[_MAX_PATH];
		TCHAR	tszMod[_MAX_PATH];
		DWORD	cchPath	= _MAX_PATH;
		
		// Build the string X:\Program Files\Common Files\Microsoft Shared\Triedit\dhtmled.ocx
		hr = keyCurVer.QueryValue ( tszPath, TEXT("CommonFilesDir"), &cchPath );
		if ( SUCCEEDED ( hr ) )
		{
			_tcscat ( tszPath, TEXT("\\Microsoft Shared\\Triedit\\") );
			
			// This routine gets the full path name of this DLL.  It SHOULD be the same
			// as the path we're constructing, but that could change in the future, so
			// truncate all but the bare file name.
			if ( 0 != GetModuleFileName ( _Module.GetModuleInstance(), tszMod, _MAX_PATH ) )
			{
				_tcsrev ( tszMod );				// Reverse the string
				_tcstok ( tszMod, TEXT("\\") );	// This replaces the first backslash with a \0.
				_tcsrev ( tszMod );
				_tcscat ( tszPath, tszMod );

				hr = keyShared.SetValue ( 10000, tszPath );
			}
		}
		hr = keyShared.Close ();
	}
	keyCurVer.Close ();
}


// End of DHTMLEd.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dhtmledit.h ===
// DHTMLEdit.h : Declaration of the CDHTMLEdit
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DHTMLEDIT_H_
#define __DHTMLEDIT_H_

#include "resource.h"       // main symbols
#include "CPDHTMLEd.h"
#include "triedtctlid.h"
#include "private.h"
#include "wininet.h"
#include "trixacc.h"


class CProxyFrame;
class CEventXferSink;

typedef /* [helpstring][uuid] */ 
enum TriEditFilterConstants
    {	filterNone	= 0x1,
		filterDTCs	= 0x2,
		filterASP	= 0x8,
		preserveSourceCode	= 0x10,
		filterSourceCode	= 0x20,
		filterAll	= filterDTCs | filterASP | preserveSourceCode
    }	TriEditCtlFilterConstants;

#define DOCUMENT_COMPETE_MESSAGE	(WM_USER+18)
#define DOCUMENT_COMPETE_SIGNATURE	0xADFE


//	ATL 3.0 macro for overriding the window class settings.
#ifndef DECLARE_WND_CLASS_EX
#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
static CWndClassInfo& GetWndClassInfo() \
{ \
	static CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDHTMLSafe
// This is the Safe for Scripting control, which is complete and stand-alone,
// but aggregated by DHTMLEdit to provide Load and Save capabilities.
//
class ATL_NO_VTABLE CDHTMLSafe : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDHTMLSafe, &CLSID_DHTMLSafe>,
	public CComControl<CDHTMLSafe>,
	public IDispatchImpl<IDHTMLSafe, &IID_IDHTMLSafe, &LIBID_DHTMLEDLib>,
	public IProvideClassInfo2Impl<&CLSID_DHTMLSafe, &DIID__DHTMLSafeEvents, &LIBID_DHTMLEDLib>,
	public IPersistStreamInitImpl<CDHTMLSafe>,
	public IPersistStorageImpl<CDHTMLSafe>,
	public IPersistPropertyBagImpl<CDHTMLSafe>,
	public IOleControlImpl<CDHTMLSafe>,
	public IOleObjectImpl<CDHTMLSafe>,
	public IOleInPlaceActiveObjectImpl<CDHTMLSafe>,
	public IViewObjectExImpl<CDHTMLSafe>,
	public IOleInPlaceObjectWindowlessImpl<CDHTMLSafe>,
	public IDataObjectImpl<CDHTMLSafe>,
	public ISpecifyPropertyPagesImpl<CDHTMLSafe>,
	public CProxy_DHTMLSafeEvents<CDHTMLSafe>,
	public IPropertyNotifySinkCP<CDHTMLSafe>,
	public IConnectionPointContainerImpl<CDHTMLSafe>,
	public IInterconnector
{
public:

	DECLARE_WND_CLASS_EX(NULL, CS_DBLCLKS, (HBRUSH)(COLOR_WINDOW+1))

	CDHTMLSafe();
	~CDHTMLSafe();

	BOOL IsUserMode() {
		HRESULT hr = S_OK;		
		BOOL bVal = FALSE;

		if (FAILED(hr = GetAmbientUserMode(bVal)))
			bVal = TRUE;
		
		return (bVal) ? TRUE : FALSE;
	};


DECLARE_REGISTRY_RESOURCEID(IDR_DHTMLSafe)
DECLARE_AGGREGATABLE(CDHTMLSafe)

BEGIN_COM_MAP(CDHTMLSafe)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDHTMLSafe)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY_IMPL(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IInterconnector)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDHTMLSafe)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	PROP_ENTRY("ActivateApplets",				DISPID_ACTIVATEAPPLETS,			CLSID_NULL)
	PROP_ENTRY("ActivateActiveXControls",		DISPID_ACTIVATEACTIVEXCONTROLS, CLSID_NULL)
	PROP_ENTRY("ActivateDTCs",					DISPID_ACTIVATEDTCS,			CLSID_NULL)
	PROP_ENTRY("ShowDetails",					DISPID_SHOWDETAILS,				CLSID_NULL)
	PROP_ENTRY("ShowBorders",					DISPID_SHOWBORDERS,				CLSID_NULL)
	PROP_ENTRY("Appearance",					DISPID_DHTMLEDITAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("Scrollbars",					DISPID_DHTMLEDITSCROLLBARS,		CLSID_NULL)
	PROP_ENTRY("ScrollbarAppearance",			DISPID_SCROLLBARAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("SourceCodePreservation",		DISPID_SOURCECODEPRESERVATION,	CLSID_NULL)
	PROP_ENTRY("AbsoluteDropMode",				DISPID_ABSOLUTEDROPMODE,		CLSID_NULL)
	PROP_ENTRY("SnapToGrid",					DISPID_SNAPTOGRID,				CLSID_NULL)
	PROP_ENTRY("SnapToGridX",					DISPID_SNAPTOGRIDX,				CLSID_NULL)
	PROP_ENTRY("SnapToGridY",					DISPID_SNAPTOGRIDY,				CLSID_NULL)
	PROP_ENTRY("UseDivOnCarriageReturn",		DISPID_USEDIVONCR,				CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CDHTMLSafe)
	CONNECTION_POINT_ENTRY(DIID__DHTMLSafeEvents)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CDHTMLSafe)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_SHOWWINDOW, OnShow)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(DOCUMENT_COMPETE_MESSAGE, OnDocumentComplete)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IDHTMLSafe
public:
	STDMETHOD(get_IsDirty)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_SourceCodePreservation)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SourceCodePreservation)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ScrollbarAppearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_ScrollbarAppearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_Scrollbars)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Scrollbars)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_Appearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_Appearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_ShowBorders)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowBorders)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ShowDetails)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowDetails)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ActivateDTCs)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateDTCs)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateActiveXControls)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateActiveXControls)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateApplets)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateApplets)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_DOM)(/*[out, retval]*/ IHTMLDocument2 **pVal);
	STDMETHOD(get_DocumentHTML)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DocumentHTML)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_AbsoluteDropMode)(/* [retval][out] */ VARIANT_BOOL *pVal);
    STDMETHOD(put_AbsoluteDropMode)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_SnapToGridX)(/* [retval][out] */ LONG  *pVal);        
    STDMETHOD(put_SnapToGridX)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGridY)(/* [retval][out] */ LONG  *pVal);
    STDMETHOD(put_SnapToGridY)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGrid)(/* [retval][out] */ VARIANT_BOOL  *pVal);
    STDMETHOD(put_SnapToGrid)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_CurrentDocumentPath)(/* [retval][out] */ BSTR  *pVal);

    STDMETHOD(get_BaseURL)(/* [retval][out] */ BSTR  *baseURL);
    STDMETHOD(put_BaseURL)(/* [in] */ BSTR baseURL);
    STDMETHOD(get_DocumentTitle)(/* [retval][out] */ BSTR  *docTitle);

	STDMETHOD(get_UseDivOnCarriageReturn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_UseDivOnCarriageReturn)(/*[in]*/ VARIANT_BOOL newVal);

    STDMETHOD(get_Busy)(/* [retval][out] */ VARIANT_BOOL *pVal);

	STDMETHOD(ExecCommand)(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar);
	STDMETHOD(QueryStatus)(DHTMLEDITCMDID cmdID, /*[out, retval]*/ DHTMLEDITCMDF* retval);
	STDMETHOD(SetContextMenu)(/*[in]*/ LPVARIANT menuStrings, /*[in]*/ LPVARIANT menuStates);
	STDMETHOD(NewDocument)(void);
	STDMETHOD(LoadURL)(BSTR url);
	STDMETHOD(FilterSourceCode)(/*[in]*/ BSTR sourceCodeIn, /*[out, retval]*/ BSTR* sourceCodeOut);
	STDMETHOD(Refresh)(void);

	HRESULT OnDraw(ATL_DRAWINFO& di);
	LRESULT OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnShow(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnDocumentComplete(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispID);
	STDMETHOD(OnMnemonic)(LPMSG pMsg);
	HRESULT IOleInPlaceObject_UIDeactivate ( void );

	// IOleObject
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

	// IOleObjectImpl
	HRESULT IOleObject_SetExtent (DWORD dwDrawAspect, SIZEL *psizel);

	// IPersist overrides
	STDMETHOD(GetClassID)(CLSID *pClassID);

	// IPersistStreamInit override
	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap);
	
	BOOL IsPropertyBagLoading ( void ) { return m_bfPropertyBagLoading; }

	// IPersistPropertyBag override
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap);

	// IInterconnector
	STDMETHOD(GetInterconnector)( SIZE_T* vp ) { *vp = (SIZE_T)m_pFrame; return S_OK; }
	STDMETHOD(GetCtlWnd)( SIZE_T* vw ) { *vw = (SIZE_T)m_hWndCD; return S_OK; }
	STDMETHOD(MakeDirty)( DISPID dispid ) { SetDirty ( TRUE ); FireOnChanged ( dispid ); return S_OK; }

	DECLARE_GET_CONTROLLING_UNKNOWN();

	// ATL helper functions override

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	HRESULT FinalConstruct();
	void FinalRelease();

	void FocusSite ( BOOL bfGetFocus );

	IOleControlSite* GetControlSite ( void ) { return m_piControlSite; }

	HRESULT ControlQueryInterface(const IID& iid, void** ppv);
	BOOL	IsSafeForScripting ( void ) { return ( NULL == GetOuterEditControl () ); }

protected:
	HRESULT SpecialEdit ( DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt );

private:
	ATL_PROPMAP_ENTRY* ProperPropMap ( void );
	IDHTMLEdit* GetOuterEditControl ( void );

protected:

	class CProxyFrame*	m_pFrame;
	IOleControlSite*	m_piControlSite;
	BOOL				m_fJustCreated;
	IDHTMLEdit*			m_piOuterEditCtl;
	BOOL				m_bfPropertyBagLoading;
	BOOL				m_bfOuterEditUnknownTested;
};


/////////////////////////////////////////////////////////////////////////////
// CDHTMLEdit
//
class ATL_NO_VTABLE CDHTMLEdit : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDHTMLEdit, &CLSID_DHTMLEdit>,
	public IDispatchImpl<IDHTMLEdit, &IID_IDHTMLEdit, &LIBID_DHTMLEDLib>,
	public CProxy_DHTMLEditEvents<CDHTMLEdit>,
	public IProvideClassInfo2Impl<&CLSID_DHTMLEdit, &DIID__DHTMLEditEvents, &LIBID_DHTMLEDLib>,
	public IConnectionPointContainerImpl<CDHTMLEdit>,
	public IOleObject,
	public IServiceProvider,
	public IInternetSecurityManager
{
public:

	CDHTMLEdit();
	~CDHTMLEdit();

DECLARE_REGISTRY_RESOURCEID(IDR_DHTMLEDIT)
DECLARE_AGGREGATABLE(CDHTMLEdit)

BEGIN_COM_MAP(CDHTMLEdit)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDHTMLEdit)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IServiceProvider)
	COM_INTERFACE_ENTRY(IInternetSecurityManager)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_punkInnerCtl)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDHTMLEdit)
	PROP_ENTRY("ActivateApplets",				DISPID_ACTIVATEAPPLETS,			CLSID_NULL)
	PROP_ENTRY("ActivateActiveXControls",		DISPID_ACTIVATEACTIVEXCONTROLS, CLSID_NULL)
	PROP_ENTRY("ActivateDTCs",					DISPID_ACTIVATEDTCS,			CLSID_NULL)
	PROP_ENTRY("ShowDetails",					DISPID_SHOWDETAILS,				CLSID_NULL)
	PROP_ENTRY("ShowBorders",					DISPID_SHOWBORDERS,				CLSID_NULL)
	PROP_ENTRY("Appearance",					DISPID_DHTMLEDITAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("Scrollbars",					DISPID_DHTMLEDITSCROLLBARS,		CLSID_NULL)
	PROP_ENTRY("ScrollbarAppearance",			DISPID_SCROLLBARAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("SourceCodePreservation",		DISPID_SOURCECODEPRESERVATION,	CLSID_NULL)
	PROP_ENTRY("AbsoluteDropMode",				DISPID_ABSOLUTEDROPMODE,		CLSID_NULL)
	PROP_ENTRY("SnapToGrid",					DISPID_SNAPTOGRID,				CLSID_NULL)
	PROP_ENTRY("SnapToGridX",					DISPID_SNAPTOGRIDX,				CLSID_NULL)
	PROP_ENTRY("SnapToGridY",					DISPID_SNAPTOGRIDY,				CLSID_NULL)
	PROP_ENTRY("BrowseMode",					DISPID_BROWSEMODE,				CLSID_NULL)
	PROP_ENTRY("UseDivOnCarriageReturn",		DISPID_USEDIVONCR,				CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CDHTMLEdit)
	CONNECTION_POINT_ENTRY(DIID__DHTMLEditEvents)
END_CONNECTION_POINT_MAP()


// IDHTMLEdit
public:
	STDMETHOD(get_IsDirty)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_SourceCodePreservation)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SourceCodePreservation)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ScrollbarAppearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_ScrollbarAppearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_Scrollbars)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Scrollbars)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_Appearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_Appearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_ShowBorders)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowBorders)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ShowDetails)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowDetails)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ActivateDTCs)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateDTCs)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateActiveXControls)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateActiveXControls)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateApplets)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateApplets)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_DOM)(/*[out, retval]*/ IHTMLDocument2 **pVal);
	STDMETHOD(get_DocumentHTML)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DocumentHTML)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_AbsoluteDropMode)(/* [retval][out] */ VARIANT_BOOL *pVal);
    STDMETHOD(put_AbsoluteDropMode)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_SnapToGridX)(/* [retval][out] */ LONG  *pVal);        
    STDMETHOD(put_SnapToGridX)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGridY)(/* [retval][out] */ LONG  *pVal);
    STDMETHOD(put_SnapToGridY)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGrid)(/* [retval][out] */ VARIANT_BOOL  *pVal);
    STDMETHOD(put_SnapToGrid)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_CurrentDocumentPath)(/* [retval][out] */ BSTR  *pVal);

    STDMETHOD(get_BaseURL)(/* [retval][out] */ BSTR  *baseURL);
    STDMETHOD(put_BaseURL)(/* [in] */ BSTR baseURL);
    STDMETHOD(get_DocumentTitle)(/* [retval][out] */ BSTR  *docTitle);
    STDMETHOD(get_BrowseMode)(/* [retval][out] */ VARIANT_BOOL  *pVal);
    STDMETHOD(put_BrowseMode)(/* [in] */ VARIANT_BOOL newVal);

	STDMETHOD(get_UseDivOnCarriageReturn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_UseDivOnCarriageReturn)(/*[in]*/ VARIANT_BOOL newVal);

    STDMETHOD(get_Busy)(/* [retval][out] */ VARIANT_BOOL *pVal);

	STDMETHOD(LoadDocument)(LPVARIANT path, LPVARIANT promptUser);
	STDMETHOD(SaveDocument)(LPVARIANT path, LPVARIANT promptUser);
	STDMETHOD(ExecCommand)(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar);
	STDMETHOD(QueryStatus)(DHTMLEDITCMDID cmdID, /*[out, retval]*/ DHTMLEDITCMDF* retval);
	STDMETHOD(SetContextMenu)(/*[in]*/ LPVARIANT menuStrings, /*[in]*/ LPVARIANT menuStates);
	STDMETHOD(NewDocument)(void);
	STDMETHOD(PrintDocument)(VARIANT* pvarWithUI);
	STDMETHOD(LoadURL)(BSTR url);
	STDMETHOD(FilterSourceCode)(/*[in]*/ BSTR sourceCodeIn, /*[out, retval]*/ BSTR* sourceCodeOut);
	STDMETHOD(Refresh)(void);

	// IOleObject
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
	STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
	STDMETHOD(Close)(DWORD dwSaveOption);
	STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker* pmk);
	STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk );
	STDMETHOD(InitFromData)(IDataObject*  pDataObject, BOOL fCreation, DWORD dwReserved);
	STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject** ppDataObject);
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite , LONG lindex , HWND hwndParent, LPCRECT lprcPosRect);
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
	STDMETHOD(Update)(void);
	STDMETHOD(IsUpToDate)(void);
	STDMETHOD(GetUserClassID)(CLSID *pClsid);
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	STDMETHOD(Unadvise)(DWORD dwConnection);
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
	STDMETHOD(SetColorScheme)(LOGPALETTE* pLogpal);

	// IServiceProvider
	STDMETHODIMP QueryService( REFGUID guidService, REFIID riid, void** ppv );

	// IInternetSecurityManager
	STDMETHOD(GetSecurityId)(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
	STDMETHOD(GetSecuritySite)(IInternetSecurityMgrSite **ppSite);
	STDMETHOD(GetZoneMappings)(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);
	STDMETHOD(MapUrlToZone)(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
	STDMETHOD(ProcessUrlAction)(LPCWSTR pwszUrl, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy, BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
	STDMETHOD(QueryCustomPolicy)(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
	STDMETHOD(SetSecuritySite)(IInternetSecurityMgrSite *pSite);
	STDMETHOD(SetZoneMapping)(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);

	DECLARE_GET_CONTROLLING_UNKNOWN()

	// ATL helper functions override

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct();
	void FinalRelease();

protected:

	HRESULT PromptOpenFile(LPTSTR pPath, ULONG ulPathLen);
	HRESULT PromptSaveAsFile(LPTSTR pPath, ULONG ulPathLen);

protected:

	IUnknown*			m_punkInnerCtl;
	IDHTMLSafe*			m_pInnerCtl;
	IOleObject*			m_pInnerIOleObj;
	IInterconnector*	m_pInterconnect;
	CEventXferSink*		m_pXferSink;
	IConnectionPoint*	m_piInnerCtlConPt;
	DWORD				m_dwXferCookie;
};


#endif //__DHTMLEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dhtmledit.cpp ===
// DHTMLEdit.cpp : Implementation of CDHTMLEdit and CDHTMLSafe
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "proxyframe.h"
#include "site.h"

/////////////////////////////////////////////////////////////////////////////
// CDHTMLSafe


CDHTMLSafe::CDHTMLSafe()
{
	m_bWindowOnly				= TRUE;				// A window is needed when we activate Trident.
	m_pFrame					= NULL;
	m_piControlSite				= NULL;
	m_fJustCreated				= TRUE;
	m_piOuterEditCtl			= (IDHTMLEdit*)-1;	// Crash if we use this without properly initializing it.
	m_bfOuterEditUnknownTested	= NULL;
}

CDHTMLSafe::~CDHTMLSafe()
{

}


HRESULT CDHTMLSafe::FinalConstruct()
{
	HRESULT hr E_FAIL;

	m_pFrame = new CProxyFrame(this);

	_ASSERTE(m_pFrame);

	if (NULL == m_pFrame)
		return E_OUTOFMEMORY;

	// not aggregating TriEdit -- don't get
	// reference to its pUnk;

	hr = m_pFrame->Init(NULL, NULL);

	_ASSERTE(SUCCEEDED(hr));

	if (FAILED(hr))
	{
		m_pFrame->Release ();
		m_pFrame = NULL;
	}

	return hr;
}


void CDHTMLSafe::FinalRelease()
{
	if ( NULL != m_piControlSite )
	{
		m_piControlSite->Release ();
		m_piControlSite = NULL;
	}

	if (NULL != m_pFrame)
	{
		if (m_pFrame->IsCreated())
		{
			_ASSERTE(FALSE == m_pFrame->IsActivated());

			m_pFrame->Close();
		}

		m_pFrame->Release ();
		m_pFrame = NULL;
	}
}


HRESULT CDHTMLSafe::OnDraw(ATL_DRAWINFO& di)
{
	HRESULT hr = S_OK;
	
	_ASSERTE(m_pFrame);

	if (NULL == m_pFrame)
		return E_UNEXPECTED;

	if (IsUserMode() == FALSE)
	{
		HBRUSH hgreyBrush = NULL;

		hgreyBrush = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
		FillRect(di.hdcDraw, &rc, hgreyBrush);
        return S_OK;

	}
	else if (IsUserMode() && m_pFrame->IsCreated() == TRUE && m_pFrame->IsActivated() == FALSE)
	{
		_ASSERTE(m_bInPlaceActive == TRUE);

		hr = m_pFrame->LoadInitialDoc();
	}

	return hr;
}


LRESULT
CDHTMLSafe::OnSize(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& lResult)
{
    m_pFrame->UpdateObjectRects();

	lResult = TRUE;
	return 0;
}


STDMETHODIMP CDHTMLSafe::TranslateAccelerator(LPMSG lpmsg)
{
	HRESULT hr = S_OK;

	hr = m_pFrame->HrTranslateAccelerator(lpmsg);
	return hr;
}	

STDMETHODIMP CDHTMLSafe::OnMnemonic(LPMSG /*pMsg*/)
{
	return S_FALSE;
}


STDMETHODIMP CDHTMLSafe::SetClientSite(IOleClientSite *pClientSite)
{
	HRESULT hr = S_OK;

	if ( NULL == pClientSite )
		{
		_ASSERTE ( m_pFrame );
		if ( NULL != m_pFrame )
		{
			_ASSERTE(m_pFrame->IsCreated());
			hr = m_pFrame->Close();
			_ASSERTE(SUCCEEDED(hr));
		}
	}
	return IOleObject_SetClientSite ( pClientSite );
}


LRESULT
CDHTMLSafe::OnDestroy(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*lResult*/)
{
	HRESULT hr = S_OK;

	// This would, in turn, destroy the hosted Trident's window.
	if ( NULL != m_pFrame )
	{
		_ASSERTE(m_pFrame->IsCreated());
		_ASSERTE ( m_hWndCD );
		m_pFrame->SetParent ( NULL );
	}

	return hr;
}


LRESULT
CDHTMLSafe::OnCreate(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*lResult*/)
{
	if ( NULL != m_pFrame )
	{
		_ASSERTE(m_pFrame->IsCreated());
		_ASSERTE ( m_hWndCD );
		m_pFrame->SetParent ( m_hWndCD );
	}

	return 0;
}


LRESULT
CDHTMLSafe::OnShow(UINT /*nMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*lResult*/)
{
	if ( NULL != m_pFrame )
	{
		_ASSERTE(m_pFrame->IsCreated());
		m_pFrame->Show ( wParam );
	}
	return 0;
}


// Do our best to set the focus on the ControlSite.
// m_piControlSite is obtained on demand, and released in FinalRelease.
//
void
CDHTMLSafe::FocusSite ( BOOL bfGetFocus )
{
	if  ( NULL == m_piControlSite )
	{
		_ASSERTE ( m_spClientSite );
		if ( m_spClientSite )
		{
			m_spClientSite->QueryInterface ( IID_IOleControlSite, (void**)&m_piControlSite );
		}
	}

	if ( m_piControlSite )
	{
		m_piControlSite->OnFocus ( bfGetFocus );
	}
}


LRESULT
CDHTMLSafe::OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
	lResult = FALSE;	// Pass it on to the default event handler if not handled by Frame.
	_ASSERTE ( m_pFrame );
	if ( NULL != m_pFrame )
	{
		// If its the Trident instance loosing the focus, let's not set it right back again!
		// Also, if it has not yet been UIActivated, don't risk inplace deactivationg with this:
		if ( m_pFrame->GetDocWindow() != (HWND)wParam )
		{
			FocusSite ( TRUE );
			return m_pFrame->OnSetFocus ( nMsg, wParam, lParam, lResult );
		}
	}
	return 0;
}


//	This message is posted in OnReadyStateChanged.
//	This postpones firing DocumentComplete until MSHTML is actually complete.
//
LRESULT
CDHTMLSafe::OnDocumentComplete(UINT /*nMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& lResult)
{
	_ASSERTE ( DOCUMENT_COMPETE_SIGNATURE == wParam );
	if ( DOCUMENT_COMPETE_SIGNATURE == wParam )
	{
		lResult = TRUE;
		m_pFrame->ClearLoadingFlag ();
		Fire_DocumentComplete();
	}
	return 0;
}


STDMETHODIMP CDHTMLSafe::OnAmbientPropertyChange(DISPID /*dispID*/)
{
	HRESULT hr = S_OK;

	// There may be some VB ambients we may want to handle here
	// in the future for VB debugging.
	return hr;
}


//	IE5 security settings for Paste, and possibly for Copy and Cut, require that we call
//	ITHMLDocument2->execCommand for testing.
//
HRESULT CDHTMLSafe::SpecialEdit ( DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt )
{
	HRESULT					hr			= S_OK;
	CComPtr<IHTMLDocument2>	spDOM		= NULL;
	VARIANT_BOOL			vbResult	= VARIANT_FALSE;
	CComBSTR				bstrCommand;
	CComVariant				varValue;

	// Regression: The point of SpecialEdit was to call execCommand rather than Exec for the
	// editing commands and allow Trident to do the corss-zone security checks, but this has
	// broken.  (Bug 547802.)  In response, we now check the cross-zone security of the current
	// selection ourselves.  We stick with execCommand to minimize impact on behavior.

	hr = m_pFrame->CheckCrossZoneSecurityOfSelection ();
	if ( SUCCEEDED ( hr ) )
	{
		hr = get_DOM ( &spDOM );
		if ( SUCCEEDED ( hr ) )
		{
			switch ( cmdID )
			{
				case DECMD_CUT:
					bstrCommand = L"Cut";
					break;
				case DECMD_COPY:
					bstrCommand = L"Copy";
					break;
				case DECMD_PASTE:
					bstrCommand = L"Paste";
					break;
				default:
					return E_UNEXPECTED;
			}
			hr = spDOM->execCommand ( bstrCommand, cmdexecopt == OLECMDEXECOPT_PROMPTUSER, varValue, &vbResult );
		}
	}
	return hr;
}


//	To be Safe for Scripting, restrict the range of cmdIDs to a known set.
//	Handle edit commands specially to utilize IE5's security settings.
//
STDMETHODIMP CDHTMLSafe::ExecCommand(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar)
{
	HRESULT			hr			= S_OK;
	LPVARIANT		_pVarIn		= NULL;
	LPVARIANT		_pVarOut	= NULL;

	// It is valid for pVar to be VT_EMPTY (on a DECMD_GETXXX op) but not VT_ERROR

	if (pInVar && (V_VT(pInVar) != VT_ERROR))
		_pVarIn = pInVar;

	if (pOutVar && (V_VT(pOutVar) != VT_ERROR))
		_pVarOut = pOutVar;

	if ( ( cmdexecopt < OLECMDEXECOPT_DODEFAULT ) ||
		 ( cmdexecopt >  OLECMDEXECOPT_DONTPROMPTUSER ) )
	{
		return E_INVALIDARG;
	}

	//	Special case for editing commands in Safe for Scripting version:
	if ( ( DECMD_CUT == cmdID ) || ( DECMD_COPY == cmdID ) || ( DECMD_PASTE == cmdID ) )
	{
		return SpecialEdit ( cmdID, cmdexecopt );
	}

	hr = m_pFrame->HrMapExecCommand(cmdID, cmdexecopt, _pVarIn, _pVarOut);

	return hr;
}


STDMETHODIMP CDHTMLSafe::QueryStatus(DHTMLEDITCMDID cmdID, DHTMLEDITCMDF* retval)
{
	HRESULT hr = S_OK;

	hr = m_pFrame->HrMapQueryStatus(cmdID, retval);

	return hr;
}


// Get Document Object Model
//
STDMETHODIMP CDHTMLSafe::get_DOM(IHTMLDocument2 ** pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);

	if (NULL == pVal)
		return E_INVALIDARG;

	*pVal = NULL;
	hr = m_pFrame->HrGetDoc(pVal);

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_DocumentHTML(BSTR * pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetDocumentHTML(pVal);
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_DocumentHTML(BSTR newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetDocumentHTML(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_DOCUMENTHTML );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_ActivateApplets(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropActivateApplets(bVal);

#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ActivateApplets(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropActivateApplets(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ACTIVATEAPPLETS );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_ActivateActiveXControls(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropActivateControls(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ActivateActiveXControls(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropActivateControls(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ACTIVATEACTIVEXCONTROLS );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_ActivateDTCs(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropActivateDTCs(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ActivateDTCs(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropActivateDTCs(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ACTIVATEDTCS );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_ShowDetails(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	 hr = m_pFrame->HrGetPropShowAllTags(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	 return hr;
}

STDMETHODIMP CDHTMLSafe::put_ShowDetails(VARIANT_BOOL newVal)
{
	_ASSERTE(m_pFrame);
	SetDirty ( TRUE );
	FireOnChanged ( DISPID_SHOWDETAILS );
	
	return m_pFrame->HrSetPropShowAllTags(newVal);
}

STDMETHODIMP CDHTMLSafe::get_ShowBorders(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropShowBorders(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ShowBorders(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropShowBorders(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SHOWBORDERS );
	}
	return hr;
}



STDMETHODIMP CDHTMLSafe::get_Appearance(DHTMLEDITAPPEARANCE * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetDisplay3D(bVal);
	*pVal = (bVal) ? DEAPPEARANCE_3D : DEAPPEARANCE_FLAT;
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_Appearance(DHTMLEDITAPPEARANCE newVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = (newVal == DEAPPEARANCE_3D) ? TRUE : FALSE;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetDisplay3D(bVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_DHTMLEDITAPPEARANCE );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_Scrollbars(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetScrollbars(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_Scrollbars(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetScrollbars(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_DHTMLEDITSCROLLBARS );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_ScrollbarAppearance(DHTMLEDITAPPEARANCE * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetDisplayFlatScrollbars(bVal);
	*pVal = (bVal) ? DEAPPEARANCE_FLAT : DEAPPEARANCE_3D;
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ScrollbarAppearance(DHTMLEDITAPPEARANCE newVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = (newVal == DEAPPEARANCE_3D) ? FALSE : TRUE;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetDisplayFlatScrollbars(bVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SCROLLBARAPPEARANCE );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_SourceCodePreservation(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPreserveSource(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_SourceCodePreservation(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPreserveSource(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SOURCECODEPRESERVATION );
	}
	return hr;
}

///////////////////////////////////////

STDMETHODIMP CDHTMLSafe::get_AbsoluteDropMode(VARIANT_BOOL* pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetAbsoluteDropMode(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_AbsoluteDropMode(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetAbsoluteDropMode(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ABSOLUTEDROPMODE );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_SnapToGrid(VARIANT_BOOL* pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetSnapToGrid(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_SnapToGrid(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetSnapToGrid(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SNAPTOGRID );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_SnapToGridX(LONG* pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetSnapToGridX(*pVal);
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_SnapToGridX(LONG newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetSnapToGridX(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SNAPTOGRIDX );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_SnapToGridY(LONG* pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetSnapToGridY(*pVal);
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_SnapToGridY(LONG newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetSnapToGridY(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SNAPTOGRIDY );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_CurrentDocumentPath(BSTR * pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetCurrentDocumentPath(pVal);
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_IsDirty(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (NULL == pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetIsDirty(bVal);

#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (TRUE == bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_BaseURL(/* [retval][out] */ BSTR  *baseURL)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);
	_ASSERTE ( baseURL );

	if ( NULL == baseURL )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstr;
	hr = m_pFrame->GetBaseURL ( bstr );

	if ( SUCCEEDED ( hr ) )
	{
		SysReAllocString ( baseURL, bstr );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_BaseURL(/* [in] */ BSTR baseURL)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);
	_ASSERTE ( baseURL );
	if ( NULL == baseURL )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstr = baseURL;
	hr = m_pFrame->SetBaseURL ( bstr );

	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_BASEURL );
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_DocumentTitle(/* [retval][out] */ BSTR  *docTitle)
{
	HRESULT hr = S_OK;

	_ASSERTE ( docTitle );
	_ASSERTE ( m_pFrame );

	if ( NULL == docTitle )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstr;
	hr = m_pFrame->GetDocumentTitle ( bstr );
	if ( SUCCEEDED ( hr ) )
	{
		SysReAllocString ( docTitle, bstr );
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_UseDivOnCarriageReturn ( VARIANT_BOOL  *pVal )
{
	_ASSERTE ( pVal );
	if ( NULL == pVal )
	{
		return E_INVALIDARG;
	}

	return m_pFrame->GetDivOnCr ( pVal );
}


STDMETHODIMP CDHTMLSafe::get_Busy ( VARIANT_BOOL  *pVal )
{
	_ASSERTE ( pVal );
	if ( NULL == pVal )
	{
		return E_INVALIDARG;
	}

	return m_pFrame->GetBusy ( pVal );
}


STDMETHODIMP CDHTMLSafe::put_UseDivOnCarriageReturn ( VARIANT_BOOL newVal )
{
	HRESULT hr = S_OK;

	hr = m_pFrame->SetDivOnCr( newVal );
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_USEDIVONCR );
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::SetContextMenu(/*[in]*/LPVARIANT menuStrings, /*[in]*/ LPVARIANT menuStates)
{
	HRESULT hr = S_OK;

	hr = m_pFrame->SetContextMenu(menuStrings, menuStates);
	return hr;
}


STDMETHODIMP CDHTMLSafe::NewDocument ()
{
	HRESULT hr = E_FAIL;

	_ASSERTE ( m_pFrame );
	if ( NULL == m_pFrame )
	{
		return E_UNEXPECTED;
	}

	hr = m_pFrame->LoadDocument( NULL );

	return hr;
}


STDMETHODIMP CDHTMLSafe::Refresh ()
{
	HRESULT hr = E_FAIL;

	_ASSERTE ( m_pFrame );
	if ( NULL == m_pFrame )
	{
		return E_UNEXPECTED;
	}

	hr = m_pFrame->RefreshDoc ();

	return hr;
}


//	In the safe for scripting version, only the http: protocol is permitted.
//
STDMETHODIMP CDHTMLSafe::LoadURL ( BSTR url )
{
	HRESULT		hr = S_OK;
	CComBSTR	rbstrSafeProtocols[] = { L"http://", L"https://", L"ftp://" };

	_ASSERTE(url);

	_ASSERTE ( m_pFrame );
	if (  NULL == m_pFrame )
	{
		return E_UNEXPECTED;
	}

	if ( ( NULL == url ) || ( 0 == SysStringLen ( url ) ) )
		return E_INVALIDARG;

	// Check for the protocol:
	CComBSTR bstrURL = url;
	_wcslwr ( bstrURL.m_str );

	BOOL bfSafe = FALSE;
	for ( int iProtocol = 0;
		iProtocol < ( sizeof ( rbstrSafeProtocols ) / sizeof ( CComBSTR ) );
		iProtocol++ )
	{
		if ( 0 == wcsncmp ( bstrURL.m_str, rbstrSafeProtocols[iProtocol],
			rbstrSafeProtocols[iProtocol].Length () ) )
		{
			bfSafe = TRUE;
			break;
		}
	}

	hr = m_pFrame->CheckCrossZoneSecurity ( url );
	if ( SUCCEEDED ( hr ) )
	{
		hr = DE_E_UNKNOWN_PROTOCOL;
		if ( bfSafe )
		{
			hr = m_pFrame->LoadDocument( url, TRUE );
		}
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::FilterSourceCode(BSTR sourceCodeIn, BSTR* sourceCodeOut)
{
	HRESULT	hr;

	_ASSERTE ( sourceCodeIn );
	_ASSERTE ( sourceCodeOut );

	if ( ( NULL == sourceCodeIn ) || ( NULL == sourceCodeOut ) )
	{
		return E_INVALIDARG;
	}

	*sourceCodeOut = NULL;

	hr = m_pFrame->FilterSourceCode ( sourceCodeIn, sourceCodeOut );
	return hr;
}


//	Override handler for IOleInPlaceObject->UIDeactivate to fire the blur event.
//
HRESULT CDHTMLSafe::IOleInPlaceObject_UIDeactivate ( void )
{
    Fire_onblur();
    m_pFrame->UIDeactivate();
    return CComControlBase::IOleInPlaceObject_UIDeactivate ();
}

// Override IOleObjectImpl methods
// We must set the object as dirty when resized
//
HRESULT CDHTMLSafe::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	if ((m_sizeExtent.cx != psizel->cx || m_sizeExtent.cy != psizel->cy) && !m_fJustCreated)
		SetDirty(TRUE);
	m_fJustCreated = FALSE;
	return CComControlBase::IOleObject_SetExtent(dwDrawAspect, psizel);
}


HRESULT CDHTMLSafe::IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY*)
{
	return CComControlBase::IPersistStreamInit_Save ( pStm, fClearDirty, ProperPropMap() );
}


HRESULT CDHTMLSafe::IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY*)
{
	return CComControlBase::IPersistStreamInit_Load ( pStm, ProperPropMap() );
}

HRESULT CDHTMLSafe::IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* )
{
	return CComControlBase::IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, ProperPropMap());
}


HRESULT CDHTMLSafe::IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY*)
{
	return CComControlBase::IPersistPropertyBag_Load(pPropBag, pErrorLog, ProperPropMap());
}


//	We cannot QI for the OuterEditControl in the FinalConstruct, or we crash whenever
//	we're aggregated.  So, we QI on demand.
//	Call this routine to get the outer control's unknown, never use m_piOuterEditCtl
//	directly.
//	NOTE:
//	This routine DOES NOT addref the interface returned!  Do not release it!
//
IDHTMLEdit * CDHTMLSafe::GetOuterEditControl ()
{
	if ( ! m_bfOuterEditUnknownTested )
	{
		m_bfOuterEditUnknownTested = TRUE;

		// Keep an un-addreffed pointer to the aggregating DHTMLEdit control, if it exists.
		if ( SUCCEEDED ( GetControllingUnknown()->QueryInterface ( IID_IDHTMLEdit, (void**)&m_piOuterEditCtl ) ) )
		{
			_ASSERTE ( m_piOuterEditCtl );
			m_piOuterEditCtl->Release ();
		}
	}
	_ASSERTE ( (IDHTMLEdit*)-1 != m_piOuterEditCtl );
	return m_piOuterEditCtl;
}


//	There are two property maps to choose from.
//	Return the one for the DHTMLEdit control if it's aggregating us,
//	else return our own.
//
ATL_PROPMAP_ENTRY* CDHTMLSafe::ProperPropMap ()
{
	IDHTMLEdit *piOuterEditControl = GetOuterEditControl ();

	if ( NULL == piOuterEditControl )
	{
		return CDHTMLSafe::GetPropertyMap();
	}
	else
	{
		return CDHTMLEdit::GetPropertyMap();
	}
}


//	Return the appropriate CLSID, depending on whether we're the safe or unsafe control.
//
HRESULT CDHTMLSafe::GetClassID( CLSID *pClassID )
{
	IDHTMLEdit *piOuterEditControl = GetOuterEditControl ();

	if ( NULL == piOuterEditControl )
	{
		*pClassID = CLSID_DHTMLSafe;
	}
	else
	{
		*pClassID = CLSID_DHTMLEdit;
	}
	return S_OK;
}


//	The above redirecting of the PropertyMap doesn't work unless we override this method,
//	We keep an un-addref'd pointer to the aggregating DHTMLEdit control if available.
//	Addreffing it would cause a circular reference.
//
HRESULT CDHTMLSafe::ControlQueryInterface(const IID& iid, void** ppv)
{
	HRESULT	hr = S_OK;
	IDHTMLEdit *piOuterEditControl = GetOuterEditControl ();

	if ( NULL == piOuterEditControl )
	{
		hr = GetUnknown()->QueryInterface ( iid, ppv );
	}
	else
	{
		hr = piOuterEditControl->QueryInterface ( iid, ppv );
	}
	return hr;
}




////////////////////////////////////////////////////
//
//	Event sink
//

class ATL_NO_VTABLE CEventXferSink :
	public CComObjectRootEx<CComSingleThreadModel>,
	public _DHTMLSafeEvents
{
public:
BEGIN_COM_MAP(CEventXferSink)
	COM_INTERFACE_ENTRY_IID(DIID__DHTMLSafeEvents, _DHTMLSafeEvents)
END_COM_MAP()

	CEventXferSink ()
	{
		m_pCtl = NULL;
	}

	void SetOwner ( CDHTMLEdit* pCtl )
	{
		_ASSERTE ( pCtl );
		_ASSERTE ( NULL == m_pCtl );
		if ( NULL == m_pCtl )
		{
			m_pCtl = pCtl;
		}
	}

	STDMETHOD(GetTypeInfoCount) ( UINT * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetTypeInfo) ( UINT, LCID, ITypeInfo ** )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetIDsOfNames) ( REFIID, OLECHAR **, UINT, LCID, DISPID * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(Invoke) ( DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS *pDispParams, VARIANT* /*pVarResult*/, EXCEPINFO *, UINT * )
	{
		HRESULT	hr = E_UNEXPECTED;
		_ASSERTE ( m_pCtl );
		if ( NULL != m_pCtl )
		{
			switch ( dispid )
			{
				case DISPID_DOCUMENTCOMPLETE:
					m_pCtl->Fire_DocumentComplete();
					break;

				case DISPID_DISPLAYCHANGED:
					m_pCtl->Fire_DisplayChanged ();
					break;

				case DISPID_SHOWCONTEXTMENU:
				{
					CComVariant		varParam;
					long			xPos = 0;
					long			yPos = 0;
					unsigned int	uiErr;

					// There should be exactly two parameters.
					_ASSERTE ( 2 == pDispParams->cArgs );
					if (2 == pDispParams->cArgs )
					{
						hr = DispGetParam( pDispParams, 1, VT_I4, &varParam, &uiErr );
						_ASSERTE ( SUCCEEDED ( hr ) );
						if ( SUCCEEDED ( hr ) )
						{
							yPos = varParam.lVal;
							hr = DispGetParam( pDispParams, 0, VT_I4, &varParam, &uiErr );
							_ASSERTE ( SUCCEEDED ( hr ) );
							if ( SUCCEEDED ( hr ) )
							{
								xPos = varParam.lVal;
								m_pCtl->Fire_ShowContextMenu ( xPos, yPos );
							}
						}
					}
					break;
				}

				case DISPID_CONTEXTMENUACTION:
				{
					CComVariant	varMenuIndex;
					unsigned int uiErr;

					// There should be exactly one parameter.
					_ASSERTE ( 1 == pDispParams->cArgs );
					if (1 == pDispParams->cArgs )
					{
						hr = DispGetParam( pDispParams, 0, VT_I4, &varMenuIndex, &uiErr );
						_ASSERTE ( SUCCEEDED ( hr ) );
						if ( SUCCEEDED ( hr ) )
						{
							long lMenuIndex = varMenuIndex.lVal;
							m_pCtl->Fire_ContextMenuAction ( lMenuIndex );
						}
					}
					break;
				}

				case DISPID_ONMOUSEDOWN:
					m_pCtl->Fire_onmousedown ();
					break;

				case DISPID_ONMOUSEMOVE:
					m_pCtl->Fire_onmousemove ();
					break;

				case DISPID_ONMOUSEUP:
					m_pCtl->Fire_onmouseup ();
					break;

				case DISPID_ONMOUSEOUT:
					m_pCtl->Fire_onmouseout ();
					break;

				case DISPID_ONMOUSEOVER:
					m_pCtl->Fire_onmouseover ();
					break;

				case DISPID_ONCLICK:
					m_pCtl->Fire_onclick ();
					break;

				case DISPID_ONDBLCLICK:
					m_pCtl->Fire_ondblclick ();
					break;

				case DISPID_ONKEYDOWN:
					m_pCtl->Fire_onkeydown ();
					break;

				case DISPID_ONKEYPRESS:
					{
						m_pCtl->Fire_onkeypress ();
#if 0
						VARIANT_BOOL	vbCancel;
						vbCancel = m_pCtl->Fire_onkeypress ();
						if ( NULL != pVarResult )
						{
							VariantClear ( pVarResult );
							pVarResult->vt = VT_BOOL;
							pVarResult->boolVal = vbCancel;
						}
#endif
					}
					break;

				case DISPID_ONKEYUP:
					m_pCtl->Fire_onkeyup ();
					break;

				case DISPID_ONBLUR:
					m_pCtl->Fire_onblur ();
					break;

				case DISPID_ONREADYSTATECHANGE:
					m_pCtl->Fire_onreadystatechange ();
					break;

				default:
					break;
			}
		}
		return S_OK;
	}

private:
	CDHTMLEdit*		m_pCtl;
};


////////////////////////////////////////////////////
//
//	CDHTMLEdit implementation
//

CDHTMLEdit::CDHTMLEdit()
{
	m_punkInnerCtl		= NULL;		// Aggregated control's IUnknown
	m_pInnerCtl			= NULL;		// Aggregated control's custome interface
	m_pInnerIOleObj		= NULL;		// Aggregated control's IOleObject
	m_pXferSink			= NULL;		// Event sink for aggregated control
	m_piInnerCtlConPt	= NULL;		// Connection point to aggregated control
	m_pInterconnect		= NULL;		// Interface on inner control for communication
	m_dwXferCookie		= 0;		// Cookie for aggregated control's connection point.
}

CDHTMLEdit::~CDHTMLEdit()
{
}


HRESULT CDHTMLEdit::FinalConstruct()
{
	// Aggregate DHTMLSafe control:
	HRESULT		hr			= E_FAIL;
	IUnknown*	punkContUnk	= NULL;

	punkContUnk = GetControllingUnknown ();
	_ASSERTE ( punkContUnk );

	hr = CoCreateInstance ( CLSID_DHTMLSafe, punkContUnk, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&m_punkInnerCtl );

	if ( SUCCEEDED ( hr ) )
	{
		_ASSERTE ( m_punkInnerCtl );

		hr = m_punkInnerCtl->QueryInterface ( IID_IOleObject, (void**)&m_pInnerIOleObj);
		_ASSERTE ( SUCCEEDED ( hr ) );
		_ASSERTE ( m_pInnerIOleObj );
		punkContUnk->Release ();

		hr = m_punkInnerCtl->QueryInterface ( IID_IDHTMLSafe, (void**)&m_pInnerCtl );	// This addrefs my unknown
		_ASSERTE ( SUCCEEDED ( hr ) );
		_ASSERTE ( m_pInnerCtl );
		punkContUnk->Release ();

		hr = m_punkInnerCtl->QueryInterface ( IID_IInterconnector, (void**)&m_pInterconnect );	// This addrefs my unknown
		_ASSERTE ( SUCCEEDED ( hr ) );
		_ASSERTE ( m_pInterconnect );
		punkContUnk->Release ();

		// Sink events from the aggregated control:
		m_pXferSink = new CComObject<CEventXferSink>;

		// Check if the new worked
		if(!m_pXferSink)
			return E_OUTOFMEMORY;

		m_pXferSink->AddRef ();
		m_pXferSink->SetOwner ( this );
		
		// Hook the sink up to the aggregated control:
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer>picpc ( m_punkInnerCtl );
		if ( picpc )
		{
			punkContUnk->Release ();
			hr = picpc->FindConnectionPoint ( DIID__DHTMLSafeEvents, &m_piInnerCtlConPt );
			if ( SUCCEEDED ( hr ) )
			{
				hr = m_piInnerCtlConPt->Advise ( static_cast<IDispatch *>(m_pXferSink), &m_dwXferCookie);
				_ASSERTE ( SUCCEEDED ( hr ) );
			}
		}
	}

	_ASSERTE ( SUCCEEDED ( hr ) );
	return hr;
}

void CDHTMLEdit::FinalRelease()
{
	IUnknown*	punkContUnk	= NULL;

	punkContUnk = GetControllingUnknown ();
	_ASSERTE ( punkContUnk );

	// Unadvise the event sink:
	_ASSERTE ( m_pXferSink );
	_ASSERTE ( m_piInnerCtlConPt );
	if ( NULL != m_piInnerCtlConPt )
	{
		punkContUnk->AddRef ();
		m_piInnerCtlConPt->Unadvise ( m_dwXferCookie );
		m_piInnerCtlConPt->Release ();
		m_piInnerCtlConPt = NULL;
	}
	if ( NULL != m_pXferSink )
	{
		m_pXferSink->Release ();
		m_pXferSink = NULL;
	}

	if ( m_pInnerCtl )
	{
		// Releasing the cached interface will release my unknown, which has already been ballanced.
		punkContUnk->AddRef ();
		m_pInnerCtl->Release ();
	}
	if ( m_pInnerIOleObj )
	{
		punkContUnk->AddRef ();
		m_pInnerIOleObj->Release ();
	}
	if ( m_pInterconnect )
	{
		punkContUnk->AddRef ();
		m_pInterconnect->Release ();
	}
	if ( m_punkInnerCtl )
	{
		punkContUnk->AddRef ();
		m_punkInnerCtl->Release ();
	}
}



HRESULT
CDHTMLEdit::PromptOpenFile(LPTSTR pPath, ULONG ulPathLen)
{
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn = {0};
    BOOL            bResult = FALSE;
	HWND			hWndCD	= NULL;
    
	_ASSERTE(pPath);

	if (NULL == pPath)
		return E_INVALIDARG;

	hr = m_pInterconnect->GetCtlWnd ( (SIZE_T*)&hWndCD );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( FAILED ( hr ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

    memset(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = NULL;
    ofn.hwndOwner = hWndCD;
	ofn.lpstrTitle = NULL;
    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0");
    ofn.lpstrFile = pPath;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrDefExt = TEXT("htm");
    ofn.nMaxFile = ulPathLen;
    ofn.Flags = OFN_EXPLORER |
				OFN_FILEMUSTEXIST |
				OFN_PATHMUSTEXIST |
				OFN_OVERWRITEPROMPT |
				OFN_HIDEREADONLY;

    bResult = GetOpenFileName(&ofn);

    if (!bResult)
        return S_FALSE;

	return S_OK;
}


HRESULT
CDHTMLEdit::PromptSaveAsFile(LPTSTR pPath, ULONG ulPathLen)
{
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn = {0};
    BOOL            bResult = FALSE;
	HWND			hWndCD	= NULL;
    
	_ASSERTE(pPath);

	if (NULL == pPath)
		return E_INVALIDARG;

	hr = m_pInterconnect->GetCtlWnd ( (SIZE_T*)&hWndCD );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( hWndCD );
	if ( FAILED ( hr ) || ( NULL == hWndCD ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

    memset(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = NULL;
    ofn.hwndOwner = hWndCD;
	ofn.lpstrTitle = NULL;
    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0");
    ofn.lpstrFile = pPath;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrDefExt = TEXT("htm");
    ofn.nMaxFile = ulPathLen;
	ofn.Flags           =   OFN_OVERWRITEPROMPT |
							OFN_CREATEPROMPT    |
							OFN_HIDEREADONLY    |
							OFN_EXPLORER;

    bResult = GetSaveFileName(&ofn);

    if (!bResult)
        return S_FALSE;

	return S_OK;
}



STDMETHODIMP CDHTMLEdit::LoadDocument(LPVARIANT path, LPVARIANT promptUser)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	BOOL bPromptUser = NULL;
	TCHAR promptPath[MAX_PATH] = {0};
	CComBSTR bstrPath;
	BSTR _path = NULL;

	_ASSERTE(path);

	CProxyFrame* pFrame = NULL;
	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if (NULL == path || !(V_VT(path) ==  VT_BSTR || V_VT(path) == (VT_BSTR|VT_BYREF)))
		return E_INVALIDARG;

	// Note that it is valid for path to be NULL,
	// In automation an empty string (BSTR) is a NULL pointer
	// Passing in an emtpy string here allows for initializing TriEdit with
	// an empty document (IPersistStreamInit->InitNew)

	if (promptUser && (V_VT(promptUser) != VT_EMPTY && V_VT(promptUser) != VT_ERROR))
	{
		// note that if promptUser is not type VT_BOOL or VT_BOOL|VT_BYREF
		// then user is not prompted

#pragma warning(disable: 4310) // cast truncates constant value
		if (VT_BOOL == V_VT(promptUser))
			bPromptUser = (VARIANT_TRUE == V_BOOL(promptUser)) ? TRUE : FALSE;
		else if ((VT_BOOL|VT_BYREF) == V_VT(promptUser))
		{
			_ASSERTE(V_BOOLREF(promptUser));

			if (V_BOOLREF(promptUser))
				bPromptUser = (BOOL) (*(V_BOOLREF(promptUser)) == VARIANT_TRUE) ? TRUE : FALSE;
		}
#pragma warning(default: 4310) // cast truncates constant value
	}

	// prompt user overrides any doc name that is specified
	// Change VK:
	// ...but the provided doc name is used as the default.
	if (bPromptUser)
	{
		if ( NULL != path->bstrVal )
		{
			_tcsncpy ( promptPath, OLE2T(path->bstrVal), MAX_PATH );
		}
		hr = PromptOpenFile(promptPath, MAX_PATH);

		if (S_FALSE == hr)
			return S_OK;

		bstrPath = promptPath;
		_path = bstrPath;
	}
	else
	{	
		if ((VT_BSTR|VT_BYREF) == V_VT(path) && V_BSTRREF(path))
			_path = *(V_BSTRREF(path));
		else if (VT_BSTR == V_VT(path) && V_BSTR(path))
			_path = V_BSTR(path);
	}

	if ( 0 == SysStringLen ( _path ) )
	{
		return DE_E_INVALIDARG;
	}

	hr = pFrame->LoadDocument(_path);

	return hr;
}


STDMETHODIMP CDHTMLEdit::SaveDocument(LPVARIANT path, LPVARIANT promptUser)
{
	USES_CONVERSION;

	HRESULT hr= S_OK;
	TCHAR promptPath[MAX_PATH] = {0};
	CComBSTR bstrPath;
	BOOL bPromptUser = FALSE;
	BSTR _path = NULL;

	_ASSERTE(path);

	CProxyFrame* pFrame = NULL;
	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if (NULL == path || !(V_VT(path) ==  VT_BSTR || V_VT(path) == (VT_BSTR|VT_BYREF)))
		return E_INVALIDARG;

	// prompt user overrides any doc name that is specified
	if (promptUser && (V_VT(promptUser) != VT_EMPTY && V_VT(promptUser) != VT_ERROR))
	{
		// note that if promptUser is not type VT_BOOL or VT_BOOL|VT_BYREF
		// then user is not prompted

#pragma warning(disable: 4310) // cast truncates constant value
		if (VT_BOOL == V_VT(promptUser))
			bPromptUser = (VARIANT_TRUE == V_BOOL(promptUser)) ? TRUE : FALSE;
		else if ((VT_BOOL|VT_BYREF) == V_VT(promptUser))
		{
			_ASSERTE(V_BOOLREF(promptUser));

			if (V_BOOLREF(promptUser))
				bPromptUser = (BOOL) (*(V_BOOLREF(promptUser)) == VARIANT_TRUE) ? TRUE : FALSE;
		}
#pragma warning(default: 4310) // cast truncates constant value
	}

	// prompt user overrides any doc name that is specified
	// Change VK:
	// ...but the provided doc name is used as the default.  If doc name is empty,
	// and the doc was opened from a file, the original file name is provided as a default.
	if (bPromptUser)
	{
		if ( NULL != path->bstrVal )
		{
			_tcsncpy ( promptPath, OLE2T(path->bstrVal), MAX_PATH );
			if ( 0 == _tcslen ( promptPath ) )
			{
				CComBSTR bstrFileName;

				if ( SUCCEEDED ( pFrame->GetCurDocNameWOPath ( bstrFileName ) ) )
				{
					_tcsncpy ( promptPath, OLE2T(bstrFileName), MAX_PATH );
				}
			}
		}
		hr = PromptSaveAsFile(promptPath, MAX_PATH);

		if (S_FALSE == hr)
			return S_OK;

		bstrPath = promptPath;
		_path = bstrPath;
	}
	else
	{	
		if ((VT_BSTR|VT_BYREF) == V_VT(path) && V_BSTRREF(path))
			_path = *(V_BSTRREF(path));
		else if (VT_BSTR == V_VT(path) && V_BSTR(path))
			_path = V_BSTR(path);
	}

	hr = pFrame->SaveDocument(_path);
	return hr;
}


STDMETHODIMP CDHTMLEdit::LoadURL ( BSTR url )
{
	HRESULT			hr		= E_FAIL;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if ( ( NULL == url ) || ( 0 == SysStringLen ( url ) ) )
		return E_INVALIDARG;

	hr = pFrame->LoadDocument( url, TRUE );

	return hr;
}


STDMETHODIMP CDHTMLEdit::PrintDocument ( VARIANT* pvarWithUI )
{
	BOOL	bfWithUI	= FALSE;
	HRESULT	hr			= E_FAIL;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if ( NULL != pvarWithUI )
	{
		CComVariant	varLocal = *pvarWithUI;

		hr = varLocal.ChangeType ( VT_BOOL );
		if ( SUCCEEDED ( hr ) )
		{
			bfWithUI = varLocal.boolVal;	// VariantBool to Bool is safe, not the reverse.
		}
	}

	hr = pFrame->Print ( bfWithUI );
	return S_OK;  // We can't return anything meaningful, because w/UI, Cancel returns E_FAIL.
}


STDMETHODIMP CDHTMLEdit::get_BrowseMode(/* [retval][out] */ VARIANT_BOOL  *pVal)
{
	HRESULT			hr		= S_OK;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	_ASSERTE ( pVal );
	if ( NULL == pVal )
	{
		return E_INVALIDARG;
	}

	return pFrame->GetBrowseMode ( pVal );
}


STDMETHODIMP CDHTMLEdit::put_BrowseMode(/* [in] */ VARIANT_BOOL newVal)
{
	HRESULT			hr		= S_OK;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	hr = pFrame->SetBrowseMode ( newVal );
	if ( SUCCEEDED ( hr ) )
	{
		m_pInterconnect->MakeDirty ( DISPID_BROWSEMODE );
	}

	return hr;
}


//	To be safe, restrict the range of cmdIDs to a known set.
//
STDMETHODIMP CDHTMLEdit::ExecCommand(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar)
{
	HRESULT			hr			= S_OK;
	LPVARIANT		_pVarIn		= NULL;
	LPVARIANT		_pVarOut	= NULL;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	// It is valid for pVar to be VT_EMPTY (on a DECMD_GETXXX op) but not VT_ERROR

	if (pInVar && (V_VT(pInVar) != VT_ERROR))
		_pVarIn = pInVar;

	if (pOutVar && (V_VT(pOutVar) != VT_ERROR))
		_pVarOut = pOutVar;

	if ( ( cmdexecopt < OLECMDEXECOPT_DODEFAULT ) ||
		 ( cmdexecopt >  OLECMDEXECOPT_DONTPROMPTUSER ) )
	{
		return E_INVALIDARG;
	}

	hr = pFrame->HrMapExecCommand(cmdID, cmdexecopt, _pVarIn, _pVarOut);

	return hr;
}


/*
 * IServiceProvider implementation
 */
STDMETHODIMP CDHTMLEdit::QueryService( REFGUID guidService, REFIID riid, void** ppvService )
{
	*ppvService = NULL;
	if ( SID_SInternetSecurityManager == guidService )
	{
		return GetUnknown()->QueryInterface ( riid, ppvService );
	}
	return E_NOINTERFACE;
}



/*
 * IInternetSecurityManager implementation
 *
 * The purpose of this implementation is to OVERRIDE security and reduce it to the minimum.
 * This should only be provided in Edit mode, not in browse mode. (Browse mode edits scripts.)
 * This prevents warnings about unsafe for scripting DTCs, etc.
 *
 * From HTMED/TriSite, by Carlos Gomes.
 *
 */

STDMETHODIMP CDHTMLEdit::GetSecurityId ( LPCWSTR /*pwszUrl*/, BYTE* /*pbSecurityId*/,
	DWORD* /*pcbSecurityId*/, DWORD_PTR /*dwReserved*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::GetSecuritySite ( IInternetSecurityMgrSite** /*ppSite*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::GetZoneMappings ( DWORD /*dwZone*/, IEnumString** /*ppenumString*/, DWORD /*dwFlags*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::MapUrlToZone ( LPCWSTR /*pwszUrl*/, DWORD *pdwZone, DWORD /*dwFlags*/ )
{
	if ( pdwZone != NULL )
	{
		*pdwZone = URLZONE_LOCAL_MACHINE;
		return NOERROR;
	}
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::ProcessUrlAction ( LPCWSTR /*pwszUrl*/, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy,
	BYTE* /*pContext*/, DWORD /*cbContext*/, DWORD /*dwFlags*/, DWORD /*dwReserved*/ )
{
	_ASSERTE ( pPolicy );
	if ( NULL == pPolicy )
	{
		return E_INVALIDARG;
	}

	// Handle
	// URLACTION_DOWNLOAD_SIGNED_ACTIVEX
	// URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY
	// URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY
	// URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY
	// URLACTION_SCRIPT_OVERRIDE_SAFETY
	// URLACTION_ACTIVEX_RUN
	// URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY
	// URLACTION_SCRIPT_SAFE_ACTIVEX
	//
	if(dwAction >= URLACTION_ACTIVEX_MIN && dwAction <= URLACTION_ACTIVEX_MAX)
	{
		if (cbPolicy >= sizeof(DWORD))
		{
			*(DWORD *)pPolicy = URLPOLICY_ALLOW;
			return S_OK;
		}
		return S_FALSE;
	}
	//
	// Handle
	// URLACTION_DOWNLOAD_SIGNED_ACTIVEX
	// URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX
	//
	
	// BUG 597859: Disable download overrides; use default action instead.
	//else if(dwAction >= URLACTION_DOWNLOAD_MIN && dwAction <= URLACTION_DOWNLOAD_MAX)
	//{
	//	if (cbPolicy >= sizeof(DWORD))
	//	{
	//		*(DWORD *)pPolicy = URLPOLICY_ALLOW;
	//		return S_OK;
	//	}
	//	return S_FALSE;
	//}
	
	//
	// Handle
	// URLACTION_SCRIPT_RUN
	// URLACTION_SCRIPT_JAVA_USE
	// URLACTION_SCRIPT_SAFE_ACTIVEX
	//
	else if(dwAction >= URLACTION_SCRIPT_MIN && dwAction <= URLACTION_SCRIPT_MAX)
	{
		if (cbPolicy >= sizeof(DWORD))
		{
			*(DWORD *)pPolicy = URLPOLICY_ALLOW;
			return S_OK;
		}
		return S_FALSE;
	}
	//
	// Allow applets to do anything they want.
	// Provide the java permissions.
	//
	else if(dwAction == URLACTION_JAVA_PERMISSIONS)
	{
		if (cbPolicy >= sizeof(DWORD))
		{
			//
			// URLPOLICY_JAVA_LOW
			// Set low Java security. Java applets will be allowed to
			// do high-capability operations, such as file I/O.
			//
			*(DWORD *)pPolicy = URLPOLICY_JAVA_LOW;
			return S_OK;
		}
		return S_FALSE;
	}
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::QueryCustomPolicy ( LPCWSTR /*pwszUrl*/, REFGUID /*guidKey*/,
	BYTE** /*ppPolicy*/, DWORD* /*pcbPolicy*/, BYTE* /*pContext*/, DWORD /*cbContext*/, DWORD /*dwReserved*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::SetSecuritySite ( IInternetSecurityMgrSite* /*pSite*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::SetZoneMapping ( DWORD /*dwZone*/, LPCWSTR /*lpszPattern*/, DWORD /*dwFlags*/ )
{
	return INET_E_DEFAULT_ACTION;
}


// Map to aggregated control's methods:
//
STDMETHODIMP CDHTMLEdit::get_IsDirty(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_IsDirty ( pVal );}
STDMETHODIMP CDHTMLEdit::get_SourceCodePreservation(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_SourceCodePreservation ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SourceCodePreservation(VARIANT_BOOL newVal) {return m_pInnerCtl->put_SourceCodePreservation ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ScrollbarAppearance(DHTMLEDITAPPEARANCE *pVal) {return m_pInnerCtl->get_ScrollbarAppearance ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ScrollbarAppearance(DHTMLEDITAPPEARANCE newVal) {return m_pInnerCtl->put_ScrollbarAppearance ( newVal );}
STDMETHODIMP CDHTMLEdit::get_Scrollbars(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_Scrollbars ( pVal );}
STDMETHODIMP CDHTMLEdit::put_Scrollbars(VARIANT_BOOL newVal) {return m_pInnerCtl->put_Scrollbars ( newVal );}
STDMETHODIMP CDHTMLEdit::get_Appearance(DHTMLEDITAPPEARANCE *pVal) {return m_pInnerCtl->get_Appearance ( pVal );}
STDMETHODIMP CDHTMLEdit::put_Appearance(DHTMLEDITAPPEARANCE newVal) {return m_pInnerCtl->put_Appearance ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ShowBorders(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ShowBorders ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ShowBorders(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ShowBorders ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ShowDetails(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ShowDetails ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ShowDetails(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ShowDetails ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ActivateDTCs(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ActivateDTCs ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ActivateDTCs(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ActivateDTCs ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ActivateActiveXControls(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ActivateActiveXControls ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ActivateActiveXControls(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ActivateActiveXControls ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ActivateApplets(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ActivateApplets ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ActivateApplets(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ActivateApplets ( newVal );}
STDMETHODIMP CDHTMLEdit::get_DOM(IHTMLDocument2 **pVal) {return m_pInnerCtl->get_DOM ( pVal );}
STDMETHODIMP CDHTMLEdit::get_DocumentHTML(BSTR *pVal) {return m_pInnerCtl->get_DocumentHTML ( pVal );}
STDMETHODIMP CDHTMLEdit::put_DocumentHTML(BSTR newVal) {return m_pInnerCtl->put_DocumentHTML ( newVal );}
STDMETHODIMP CDHTMLEdit::get_AbsoluteDropMode(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_AbsoluteDropMode ( pVal );}
STDMETHODIMP CDHTMLEdit::put_AbsoluteDropMode(VARIANT_BOOL newVal) {return m_pInnerCtl->put_AbsoluteDropMode ( newVal );}
STDMETHODIMP CDHTMLEdit::get_SnapToGridX(LONG  *pVal) {return m_pInnerCtl->get_SnapToGridX ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SnapToGridX(LONG newVal) {return m_pInnerCtl->put_SnapToGridX ( newVal );}
STDMETHODIMP CDHTMLEdit::get_SnapToGridY(LONG  *pVal) {return m_pInnerCtl->get_SnapToGridY ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SnapToGridY(LONG newVal) {return m_pInnerCtl->put_SnapToGridY ( newVal );}
STDMETHODIMP CDHTMLEdit::get_SnapToGrid(VARIANT_BOOL  *pVal) {return m_pInnerCtl->get_SnapToGrid ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SnapToGrid(VARIANT_BOOL newVal) {return m_pInnerCtl->put_SnapToGrid ( newVal );}
STDMETHODIMP CDHTMLEdit::get_CurrentDocumentPath(BSTR  *pVal) {return m_pInnerCtl->get_CurrentDocumentPath ( pVal );}
STDMETHODIMP CDHTMLEdit::QueryStatus(DHTMLEDITCMDID cmdID, DHTMLEDITCMDF* retval) {return m_pInnerCtl->QueryStatus ( cmdID, retval );}
STDMETHODIMP CDHTMLEdit::SetContextMenu(LPVARIANT menuStrings,LPVARIANT menuStates) {return m_pInnerCtl->SetContextMenu ( menuStrings, menuStates );}
STDMETHODIMP CDHTMLEdit::get_BaseURL(BSTR  *baseURL) {return m_pInnerCtl->get_BaseURL(baseURL);}
STDMETHODIMP CDHTMLEdit::put_BaseURL(BSTR baseURL) {return m_pInnerCtl->put_BaseURL(baseURL);}
STDMETHODIMP CDHTMLEdit::get_DocumentTitle(BSTR  *docTitle) {return m_pInnerCtl->get_DocumentTitle(docTitle);}
STDMETHODIMP CDHTMLEdit::NewDocument() {return m_pInnerCtl->NewDocument();}
STDMETHODIMP CDHTMLEdit::get_UseDivOnCarriageReturn(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_UseDivOnCarriageReturn(pVal);}
STDMETHODIMP CDHTMLEdit::put_UseDivOnCarriageReturn(VARIANT_BOOL newVal) {return m_pInnerCtl->put_UseDivOnCarriageReturn(newVal);}
STDMETHODIMP CDHTMLEdit::FilterSourceCode(BSTR sourceCodeIn, BSTR* sourceCodeOut) {return m_pInnerCtl->FilterSourceCode(sourceCodeIn, sourceCodeOut);}
STDMETHODIMP CDHTMLEdit::Refresh() {return m_pInnerCtl->Refresh();}
STDMETHODIMP CDHTMLEdit::get_Busy(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_Busy(pVal);}

// End of DHTMLEdit.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dispexa.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef _dispexa_h_
#define _dispexa_h_
#include <dispex.h>

class CDispExArray
{
public:

	CDispExArray() {
	};

	~CDispExArray() {
	};

	void Attach(IDispatchEx* pDispEx) {
		m_piDispEx = pDispEx;
	};

	void Detach() {
		m_piDispEx = NULL;
	};

	HRESULT HrGetLength(ULONG* pLength);
	HRESULT HrGetElement(ULONG index, LPVARIANT pVar);

private:
	CComPtr<IDispatchEx> m_piDispEx;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dispexa.cpp ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "dispexa.h"


HRESULT
CDispExArray::HrGetLength(ULONG* pLength)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	VARIANT var;
	BSTR bstrName = NULL;
	WCHAR* oleStr = NULL;
	DISPID dispid;
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

	if (!m_piDispEx)
		return E_UNEXPECTED;

	_ASSERTE(pLength);
	if (NULL == pLength)
		return E_INVALIDARG;

	VariantInit(&var);
	oleStr = T2OLE(_T("length"));
	bstrName = ::SysAllocString(oleStr);

	if (FAILED(hr = m_piDispEx->GetDispID(bstrName, fdexNameCaseSensitive, &dispid)))
		goto cleanup;

	::SysFreeString(bstrName);
	bstrName = NULL;	// BUG 597865

	hr = m_piDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, 
				DISPATCH_PROPERTYGET, &dispparamsNoArgs, 
				&var, NULL, NULL);

	if (FAILED(hr))
		goto cleanup;


	if (V_VT(&var) != VT_I4)
		goto cleanup;

	*pLength = V_I4(&var);

cleanup:
	if (FAILED(hr))
	{
		if (bstrName)
			::SysFreeString(bstrName);
	}

	return hr;
}


HRESULT 
CDispExArray::HrGetElement(ULONG index, LPVARIANT pVar)
{

	USES_CONVERSION;
	HRESULT hr = S_OK;
	VARIANT var;
	BSTR bstrName = NULL;
	WCHAR* oleStr = NULL;
	DISPID dispid = 0;
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	char buffer[32];

	if (!m_piDispEx)
		return E_UNEXPECTED;

	_ASSERTE(pVar);
	if (NULL == pVar)
		return E_INVALIDARG;

	VariantInit(&var);
	oleStr = A2OLE(_itoa(index, buffer, 10));
	bstrName = ::SysAllocString(oleStr);

	if (FAILED(hr = m_piDispEx->GetDispID(bstrName, fdexNameCaseSensitive, &dispid)))
		goto cleanup;

	SysFreeString(bstrName);
	bstrName = NULL;	// BUG 597865

	hr = m_piDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, 
				DISPATCH_PROPERTYGET, &dispparamsNoArgs, 
				pVar, NULL, NULL);

	if (FAILED(hr))
		goto cleanup;

cleanup:

	if (FAILED(hr))
	{
		if (bstrName)
			::SysFreeString(bstrName);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\iclisite.cpp ===
/*
 * ICLISITE.CPP
 * IOleClientSite for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIOleClientSite::CImpIOleClientSite
 * CImpIOleClientSite::~CImpIOleClientSite
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIOleClientSite::CImpIOleClientSite( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleClientSite::~CImpIOleClientSite( void )
{
}



/*
 * CImpIOleClientSite::QueryInterface
 * CImpIOleClientSite::AddRef
 * CImpIOleClientSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleClientSite object.
 */

STDMETHODIMP CImpIOleClientSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleClientSite::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleClientSite::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}




/*
 * CImpIOleClientSite::SaveObject
 *
 * Purpose:
 *  Requests that the container call OleSave for the object that
 *  lives here.  Typically this happens on server shutdown.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         Standard.
 */
STDMETHODIMP CImpIOleClientSite::SaveObject( void )
{
    return S_OK;
}




/*
 * Unimplemented/trivial members
 *  GetMoniker
 *  GetContainer
 *  RequestNewObjectLayout
 *  OnShowWindow
 *  ShowObject
 */

STDMETHODIMP CImpIOleClientSite::GetMoniker(DWORD /*dwAssign*/,
							DWORD /*dwWhich*/, LPMONIKER* /*ppmk*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIOleClientSite::GetContainer( LPOLECONTAINER* ppContainer )
{
	_ASSERTE ( m_pSite );
	if ( m_pSite )
	{
		return m_pSite->GetContainer ( ppContainer );
	}
    return E_NOTIMPL;
}

STDMETHODIMP CImpIOleClientSite::RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIOleClientSite::OnShowWindow(BOOL /*fShow*/)
{
    return S_OK;
}

STDMETHODIMP CImpIOleClientSite::ShowObject(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\iadvsink.cpp ===
/*
 * IADVSINK.CPP
 * IAdviseSink for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/


/*
 * CImpIAdviseSink::CImpIAdviseSink
 * CImpIAdviseSink::~CImpIAdviseSink
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIAdviseSink::CImpIAdviseSink( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIAdviseSink::~CImpIAdviseSink( void )
{
}


/*
 * CImpIAdviseSink::QueryInterface
 * CImpIAdviseSink::AddRef
 * CImpIAdviseSink::Release
 *
 * Purpose:
 *  IUnknown members for CImpIAdviseSink object.
 */

STDMETHODIMP CImpIAdviseSink::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIAdviseSink::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIAdviseSink::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * Unused members in CImpIAdviseSink
 *  OnDataChange
 *  OnViewChange
 *  OnRename
 *  OnSave
 */

STDMETHODIMP_(void) CImpIAdviseSink::OnDataChange(LPFORMATETC /*pFEIn*/,
											LPSTGMEDIUM /*pSTM*/)
{
}

STDMETHODIMP_(void) CImpIAdviseSink::OnViewChange(DWORD /*dwAspect*/,
												LONG /*lindex*/)
{    
}

STDMETHODIMP_(void) CImpIAdviseSink::OnRename( LPMONIKER /*pmk*/ )
{
}

STDMETHODIMP_(void) CImpIAdviseSink::OnSave( void )
{
}


/*
 * CImpIAdviseSink::OnClose
 *
 * Purpose:
 *  Informs the advise sink that the OLE object has closed and is
 *  no longer bound in any way.  We use this to do a File/Close
 *  to delete the object since we don't hold onto any.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

STDMETHODIMP_(void) CImpIAdviseSink::OnClose( void )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\idocsite.cpp ===
/*
 * IDOCSITE.CPP
 * IOleDocumentSite for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIOleDocumentSite::CImpIOleDocumentSite
 * CImpIOleDocumentSite::~CImpIOleDocumentSite
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CImpIOleDocumentSite::CImpIOleDocumentSite( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleDocumentSite::~CImpIOleDocumentSite( void )
{
}



/*
 * CImpIOleDocumentSite::QueryInterface
 * CImpIOleDocumentSite::AddRef
 * CImpIOleDocumentSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleDocumentSite object.
 */
STDMETHODIMP CImpIOleDocumentSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleDocumentSite::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleDocumentSite::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * CImpIOleDocumentsite::ActivateMe
 *
 * Purpose:
 *  Instructs the container to activate the object in this site as
 *  a document object.
 *
 * Parameters:
 *  pView           IOleDocumentView * of the object to activate.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, error code otherwise.
 */
STDMETHODIMP CImpIOleDocumentSite::ActivateMe( IOleDocumentView *pView )
{
    RECT                rc;
    IOleDocument*       pDoc;
    
    /*
     * If we're passed a NULL view pointer, then try to get one from
     * the document object (the object within us).
     */
    if ( NULL == pView )
    {
        if ( FAILED( m_pSite->GetObjectUnknown()->QueryInterface( 
 								IID_IOleDocument, (void **)&pDoc ) ) )
		{
            return E_FAIL;
		}

        if ( FAILED( pDoc->CreateView( m_pSite->GetIPSite(),
												NULL, 0, &pView ) ) )
		{
			pDoc->Release();
            return E_OUTOFMEMORY;
		}

        // Release doc pointer since CreateView is a good com method that addrefs
        pDoc->Release();
    }        
    else
    {
        IOleInPlaceSite* pInplaceSite = NULL;        
        pView->GetInPlaceSite(&pInplaceSite);
        
        if(pInplaceSite != m_pSite->GetIPSite())
        {
            //Make sure that the view has our client site
            pView->SetInPlaceSite( m_pSite->GetIPSite() );

        }

        //We're holding onto the pointer, so AddRef it.
        pView->AddRef();

        if(pInplaceSite)
            pInplaceSite->Release();
    }


    // Activation steps, now that we have a view:

    m_pSite->SetDocView( pView );
    
    //This sets up toolbars and menus first    
    pView->UIActivate( TRUE );

    //Set the window size sensitive to new toolbars
    m_pSite->GetFrame()->GetControl()->GetClientRect( &rc );
    pView->SetRect( &rc );

	//Makes it all active
    pView->Show( TRUE );    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\dhuihndl.cpp ===
/*
 * IDOCHOSTUIHANDLER.CPP
 * IDocHostUIHandler for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "proxyframe.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIDocHostUIHandler::CImpIDocHostUIHandler
 * CImpIDocHostUIHandler::~CImpIDocHostUIHandler
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CImpIDocHostUIHandler::CImpIDocHostUIHandler( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIDocHostUIHandler::~CImpIDocHostUIHandler( void )
{
}



/*
 * CImpIDocHostUIHandler::QueryInterface
 * CImpIDocHostUIHandler::AddRef
 * CImpIDocHostUIHandler::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleDocumentSite object.
 */
STDMETHODIMP CImpIDocHostUIHandler::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIDocHostUIHandler::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIDocHostUIHandler::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



// * CImpIDocHostUIHandler::GetHostInfo
// *
// * Purpose: Called at initialisation
// *
STDMETHODIMP CImpIDocHostUIHandler::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
	DWORD dwFlags = 0;
	BOOL bDialogEditing = FALSE;
	BOOL bDisplay3D= FALSE;
	BOOL bScrollbars = FALSE;
	BOOL bFlatScrollbars = FALSE;
	BOOL bContextMenu = FALSE;

	m_pSite->GetFrame()->HrGetDisplay3D(bDisplay3D);
	m_pSite->GetFrame()->HrGetScrollbars(bScrollbars);
	m_pSite->GetFrame()->HrGetDisplayFlatScrollbars(bFlatScrollbars);
	
	if (bDialogEditing == TRUE)
		dwFlags |= DOCHOSTUIFLAG_DIALOG;
	if (bDisplay3D == FALSE)
		dwFlags |= DOCHOSTUIFLAG_NO3DBORDER;
	if (bScrollbars == FALSE)
		dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
	if (bFlatScrollbars)
		dwFlags |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;
	if (bContextMenu == FALSE)
		dwFlags |= DOCHOSTUIFLAG_DISABLE_HELP_MENU;

	pInfo->dwFlags = dwFlags;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

// * CImpIDocHostUIHandler::ShowUI
// *
// * Purpose: Called when MSHTML.DLL shows its UI
// *
STDMETHODIMP CImpIDocHostUIHandler::ShowUI(
				DWORD /*dwID*/, 
				IOleInPlaceActiveObject * /*pActiveObject*/,
				IOleCommandTarget * /*pCommandTarget*/,
				IOleInPlaceFrame * /*pFrame*/,
				IOleInPlaceUIWindow * /*pDoc*/)
{

	// We've already got our own UI in place so just return S_OK
    return S_OK;
}

// * CImpIDocHostUIHandler::HideUI
// *
// * Purpose: Called when MSHTML.DLL hides its UI
// *
STDMETHODIMP CImpIDocHostUIHandler::HideUI(void)
{
    return S_OK;
}

// * CImpIDocHostUIHandler::UpdateUI
// *
// * Purpose: Called when MSHTML.DLL updates its UI
// *
STDMETHODIMP CImpIDocHostUIHandler::UpdateUI(void)
{
	// we fire this from proxyframe's IOleCommandTarget
	return S_OK;
}

// * CImpIDocHostUIHandler::EnableModeless
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::EnableModeless
// *
STDMETHODIMP CImpIDocHostUIHandler::EnableModeless(BOOL /*fEnable*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::OnDocWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnDocWindowActivate
// *
STDMETHODIMP CImpIDocHostUIHandler::OnDocWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::OnFrameWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnFrameWindowActivate
// *
STDMETHODIMP CImpIDocHostUIHandler::OnFrameWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::ResizeBorder
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::ResizeBorder
// *
STDMETHODIMP CImpIDocHostUIHandler::ResizeBorder(
				LPCRECT /*prcBorder*/, 
				IOleInPlaceUIWindow* /*pUIWindow*/,
				BOOL /*fRameWindow*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::ShowContextMenu
// *
// * Purpose: Called when MSHTML.DLL would normally display its context menu
// *
STDMETHODIMP CImpIDocHostUIHandler::ShowContextMenu(
				DWORD /*dwID*/, 
				POINT* pptPosition,
				IUnknown* /*pCommandTarget*/,
				IDispatch* /*pDispatchObjectHit*/)
{
	USES_CONVERSION;

	HMENU hmenu = NULL;
	INT id = 0;
    HRESULT hr = NOERROR;
    LONG lLBound, lUBound, lIndex, lLBoundState, lUBoundState;
    BSTR  bstr=0;
    SAFEARRAY * psaStrings = NULL;
    SAFEARRAY * psaStates = NULL;
    int i;
	BOOL ok = FALSE;
	ULONG	state = 0;
	CComBSTR _bstr;

	_ASSERTE(m_pSite);
	_ASSERTE(m_pSite->GetFrame());
	_ASSERTE(m_pSite->GetFrame()->GetControl());
	_ASSERTE(m_pSite->GetFrame()->GetControl()->m_hWndCD);

	// Correct X & Y position for local coordinates:
	POINT ptPos = *pptPosition;
	HWND hwndDoc = m_pSite->GetFrame()->GetDocWindow ();
	_ASSERTE ( hwndDoc );
	_ASSERTE ( ::IsWindow ( hwndDoc ) );
	if ( ( NULL != hwndDoc ) && ::IsWindow ( hwndDoc ) )
	{
		::ScreenToClient ( hwndDoc, &ptPos );
		// correct for scrolling
		POINT ptScrollPos;
		if ( SUCCEEDED ( m_pSite->GetFrame()->GetScrollPos ( &ptScrollPos ) ) )
		{
			ptPos.x += ptScrollPos.x;
			ptPos.y += ptScrollPos.y;
		}
		m_pSite->GetFrame()->GetControl()->Fire_ShowContextMenu ( ptPos.x, ptPos.y );
	}

	psaStrings = m_pSite->GetFrame()->GetMenuStrings();
	psaStates = m_pSite->GetFrame()->GetMenuStates();

	if (NULL == psaStrings || NULL == psaStates)
		return S_OK;

	SafeArrayGetLBound(psaStrings, 1, &lLBound);
	SafeArrayGetUBound(psaStrings, 1, &lUBound);

	SafeArrayGetLBound(psaStates, 1, &lLBoundState);
	SafeArrayGetUBound(psaStates, 1, &lUBoundState);

	if (lLBound != lLBoundState || lUBound != lUBoundState)
		return S_OK;

	// there arrays have no elements
#if 0
	Bug 15224: lower and upper bound are both zero if there is one element in sthe array.
	psaStrings is NULL if there are no strings.
	if (lLBound == lUBound)
		return S_OK;
#endif

	hmenu = CreatePopupMenu();

	if (NULL == hmenu)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		return hr;
	}

	for (lIndex=lLBound, i=0; lIndex<=lUBound && i <= 256; lIndex++, i++)
	{
		if ( FADF_BSTR & psaStrings->fFeatures )
		{
			SafeArrayGetElement(psaStrings, &lIndex, &bstr);
			_bstr = bstr;
		}
		else if ( FADF_VARIANT & psaStrings->fFeatures )
		{
			VARIANT var;
			VariantInit ( &var );
			SafeArrayGetElement(psaStrings, &lIndex, &var);
			VariantChangeType ( &var, &var, 0, VT_BSTR );
			_bstr = var.bstrVal;
			VariantClear ( &var );
		}
		else
		{
			_ASSERTE ( ( FADF_BSTR | FADF_VARIANT ) & psaStrings->fFeatures );
			return E_UNEXPECTED;
		}

		if ( FADF_VARIANT & psaStates->fFeatures )
		{
			VARIANT var;
			VariantInit ( &var );
			SafeArrayGetElement(psaStates, &lIndex, &var);
			VariantChangeType ( &var, &var, 0, VT_I4 );
			state = var.lVal;
			VariantClear ( &var );
		}
		else
		{
			// A safe array of integers seems to use an fFeatures == 0, which can't
			// safely be tested for.
			SafeArrayGetElement(psaStates, &lIndex, &state);
		}
		
		if (_bstr.Length() == 0)
			state = MF_SEPARATOR|MF_ENABLED;
		else  if (state == triGray)
			state = MF_GRAYED;
		else if (state == triChecked)
			state = MF_CHECKED|MF_ENABLED;
		else  
			state = MF_ENABLED;

		ok = AppendMenu(hmenu, MF_STRING | state, i+35000, W2T(_bstr.m_str));

		_ASSERTE(ok);
	}

	id = (INT)TrackPopupMenu(
			hmenu,
			TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
			pptPosition->x,
			pptPosition->y,
			0,
			m_pSite->GetFrame()->GetControl()->m_hWndCD,
			NULL);

	_ASSERTE(id == 0 || (id >= 35000 && id <= 35000+i));

	if (id >= 35000 && id <= 35000+i)
		m_pSite->GetFrame()->GetControl()->Fire_ContextMenuAction(id-35000);

	DestroyMenu(hmenu);

    return S_OK;
}

// * CImpIDocHostUIHandler::TranslateAccelerator
// *
// * Purpose: Called from MSHTML.DLL's TranslateAccelerator routines
// *
STDMETHODIMP CImpIDocHostUIHandler::TranslateAccelerator(LPMSG /*lpMsg*/,
            /* [in] */ const GUID __RPC_FAR * /*pguidCmdGroup*/,
            /* [in] */ DWORD /*nCmdID*/)
{
    return S_FALSE;
}

// * CImpIDocHostUIHandler::GetOptionKeyPath
// *
// * Purpose: Called by MSHTML.DLL to find where the host wishes to store 
// *	its options in the registry
// *
STDMETHODIMP CImpIDocHostUIHandler::GetOptionKeyPath(BSTR* pbstrKey, DWORD)
{
	pbstrKey = NULL; // docs say this should be set to null if not used
	return S_OK;
}

STDMETHODIMP CImpIDocHostUIHandler::GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR * /*pDropTarget*/,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR * /*ppDropTarget*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIDocHostUIHandler::GetExternal( 
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch)
{
	_ASSERTE ( ppDispatch );
	if ( NULL == ppDispatch )
	{
		return E_INVALIDARG;
	}
	*ppDispatch = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CImpIDocHostUIHandler::TranslateUrl( 
    /* [in] */ DWORD /*dwTranslate*/,
    /* [in] */ OLECHAR __RPC_FAR * /*pchURLIn*/,
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR * /*ppchURLOut*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIDocHostUIHandler::FilterDataObject( 
    /* [in] */ IDataObject __RPC_FAR * /*pDO*/,
    /* [out] */ IDataObject __RPC_FAR *__RPC_FAR * /*ppDORet*/)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\iipsite.cpp ===
/*
 * IIPSITE.CPP
 * IOleInPlaceSite for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIOleInPlaceSite::CImpIOleInPlaceSite
 * CImpIOleInPlaceSite::~CImpIOleInPlaceSite
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIOleInPlaceSite::CImpIOleInPlaceSite( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleInPlaceSite::~CImpIOleInPlaceSite( void )
{
}


/*
 * CImpIOleInPlaceSite::QueryInterface
 * CImpIOleInPlaceSite::AddRef
 * CImpIOleInPlaceSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleInPlaceSite object.
 */

STDMETHODIMP CImpIOleInPlaceSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}




/*
 * CImpIOleInPlaceActiveObject::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object
 *  on which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, E_FAIL if there is no
 *                  window.
 */
STDMETHODIMP CImpIOleInPlaceSite::GetWindow( HWND *phWnd )
{
    //This is the client-area window in the frame
    *phWnd = m_pSite->GetWindow();
    return S_OK;
}


/*
 * CImpIOleInPlaceActiveObject::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         S_OK
 */

STDMETHODIMP CImpIOleInPlaceSite::ContextSensitiveHelp( 
											BOOL /*fEnterMode*/ )
{
    return S_OK;
}


/*
 * CImpIOleInPlaceSite::CanInPlaceActivate
 *
 * Purpose:
 *  Answers the server whether or not we can currently in-place
 *  activate its object.  By implementing this interface we say
 *  that we support in-place activation, but through this function
 *  we indicate whether the object can currently be activated
 *  in-place.  Iconic aspects, for example, cannot, meaning we
 *  return S_FALSE.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if we can in-place activate the object
 *                  in this site, S_FALSE if not.
 */
STDMETHODIMP CImpIOleInPlaceSite::CanInPlaceActivate( void )
{    
    /*
     * We can always in-place activate--no restrictions for DocObjects.
     * We don't worry about other cases since CSite only ever creates
     * embedded files.
     */
    return S_OK;
}


/*
 * CImpIOleInPlaceSite::OnInPlaceActivate
 *
 * Purpose:
 *  Informs the container that an object is being activated in-place
 *  such that the container can prepare appropriately.  The
 *  container does not, however, make any user interface changes at
 *  this point.  See OnUIActivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */
STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceActivate( void )
{
	LPOLEINPLACEOBJECT pIOleIPObject;
    HRESULT hr = m_pSite->GetObjectUnknown()->QueryInterface(
					IID_IOleInPlaceObject, (void**) &pIOleIPObject );

	m_pSite->SetIPObject( pIOleIPObject );
    return hr;
}



/*
 * CImpIOleInPlaceSite::OnInPlaceDeactivate
 *
 * Purpose:
 *  Notifies the container that the object has deactivated itself
 *  from an in-place state.  Opposite of OnInPlaceActivate.  The
 *  container does not change any UI at this point.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */

STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceDeactivate( void )
{
    /*
     * Since we don't have an Undo command, we can tell the object
     * right away to discard its Undo state.
     */
    m_pSite->Activate(OLEIVERB_DISCARDUNDOSTATE);
    m_pSite->GetIPObject()->Release();
    return NOERROR;
}




/*
 * CImpIOleInPlaceSite::OnUIActivate
 *
 * Purpose:
 *  Informs the container that the object is going to start munging
 *  around with user interface, like replacing the menu.  The
 *  container should remove any relevant UI in preparation.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */

STDMETHODIMP CImpIOleInPlaceSite::OnUIActivate( void )
{
	m_pSite->GetFrame()->GetControl()->DoVerbUIActivate ( NULL, NULL );
	// Bug 107500 returns an error from OnUIActivate.
	// If we return that error here, the control gets into an inconsistant state.
	// All is well if we return OK.
	return S_OK;
}




/*
 * CImpIOleInPlaceSite::OnUIDeactivate
 *
 * Purpose:
 *  Informs the container that the object is deactivating its
 *  in-place user interface at which time the container may
 *  reinstate its own.  Opposite of OnUIActivate.
 *
 * Parameters:
 *  fUndoable       BOOL indicating if the object will actually
 *                  perform an Undo if the container calls
 *                  ReactivateAndUndo.
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */
STDMETHODIMP CImpIOleInPlaceSite::OnUIDeactivate( BOOL /*fUndoable*/ )
{
	// Normally we'd tidy up here, but since MSHTML.DLL is the only thing we host
	// the Frame will go away on deactivation so there's no point in restoring
	// the Frame's empty state

    return NOERROR;
}


/*
 * CImpIOleInPlaceSite::DeactivateAndUndo
 *
 * Purpose:
 *  If immediately after activation the object does an Undo, the
 *  action being undone is the activation itself, and this call
 *  informs the container that this is, in fact, what happened.
 *  The container should call IOleInPlaceObject::UIDeactivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */
STDMETHODIMP CImpIOleInPlaceSite::DeactivateAndUndo( void )
{
	// Tell the object we are deactivating
    m_pSite->GetIPObject()->InPlaceDeactivate();
    return NOERROR;
}




/*
 * CImpIOleInPlaceSite::DiscardUndoState
 *
 * Purpose:
 *  Informs the container that something happened in the object
 *  that means the container should discard any undo information
 *  it currently maintains for the object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */

STDMETHODIMP CImpIOleInPlaceSite::DiscardUndoState( void )
{
    return E_NOTIMPL;
}




/*
 * CImpIOleInPlaceSite::GetWindowContext
 *
 * Purpose:
 *  Provides an in-place object with pointers to the frame and
 *  document level in-place interfaces (IOleInPlaceFrame and
 *  IOleInPlaceUIWindow) such that the object can do border
 *  negotiation and so forth.  Also requests the position and
 *  clipping rectangles of the object in the container and a
 *  pointer to an OLEINPLACEFRAME info structure which contains
 *  accelerator information.
 *
 *  Note that the two interfaces this call returns are not
 *  available through QueryInterface on IOleInPlaceSite since they
 *  live with the frame and document, but not the site.
 *
 * Parameters:
 *  ppIIPFrame      LPOLEINPLACEFRAME * in which to return the
 *                  AddRef'd pointer to the container's
 *                  IOleInPlaceFrame.
 *  ppIIPUIWindow   LPOLEINPLACEUIWINDOW * in which to return
 *                  the AddRef'd pointer to the container document's
 *                  IOleInPlaceUIWindow.
 *  prcPos          LPRECT in which to store the object's position.
 *  prcClip         LPRECT in which to store the object's visible
 *                  region.
 *  pFI             LPOLEINPLACEFRAMEINFO to fill with accelerator
 *                  stuff.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CImpIOleInPlaceSite::GetWindowContext(
						LPOLEINPLACEFRAME* ppIIPFrame,
						LPOLEINPLACEUIWINDOW* ppIIPUIWindow,
						LPRECT prcPos,
						LPRECT prcClip,
						LPOLEINPLACEFRAMEINFO pFI )
{
    *ppIIPUIWindow = NULL;
    m_pSite->QueryInterface(
						IID_IOleInPlaceFrame, (void **)ppIIPFrame);
    
    if (NULL != prcPos)
	{
        GetClientRect( m_pSite->GetWindow(), prcPos );
	}

    *prcClip = *prcPos;

    pFI->cb = sizeof(OLEINPLACEFRAMEINFO);
    pFI->fMDIApp = FALSE;

	m_pSite->GetFrame()->GetWindow(&pFI->hwndFrame);
	SetWindowLong ( pFI->hwndFrame, GWL_STYLE,
		GetWindowLong ( pFI->hwndFrame, GWL_STYLE ) |
		WS_CLIPSIBLINGS | WS_CLIPCHILDREN );

    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return NOERROR;
}


/*
 * CImpIOleInPlaceSite::Scroll
 *
 * Purpose:
 *  Asks the container to scroll the document, and thus the object,
 *  by the given amounts in the sz parameter.
 *
 * Parameters:
 *  sz              SIZE containing signed horizontal and vertical
 *                  extents by which the container should scroll.
 *                  These are in device units.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CImpIOleInPlaceSite::Scroll( SIZE /*sz*/ )
{
    //Not needed for DocObjects
    return E_NOTIMPL;
}


/*
 * CImpIOleInPlaceSite::OnPosRectChange
 *
 * Purpose:
 *  Informs the container that the in-place object was resized.
 *  The container must call IOleInPlaceObject::SetObjectRects.
 *  This does not change the site's rectangle in any case.
 *
 * Parameters:
 *  prcPos          LPCRECT containing the new size of the object.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CImpIOleInPlaceSite::OnPosRectChange( LPCRECT /*prcPos*/ )
{
    //Not needed for DocObjects
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\inc.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

//	VK 3/13/98:  Changed from StdAfx.cpp to Inc.cpp.  This naming convention wasn't compatible with NTBuild.


#include "stdafx.h"

#pragma warning(disable: 4100 4189)	// Necessary for ia64 build

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#pragma warning(default: 4100 4189)	// Necessary for ia64 build
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\ipropsink.cpp ===
/*
 * IPROPSINK.CPP
 * IPropertyNotifySink for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImplPropertyNotifySink::CImplPropertyNotifySink
 * CImplPropertyNotifySink::~CImplPropertyNotifySink
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImplPropertyNotifySink::CImplPropertyNotifySink( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImplPropertyNotifySink::~CImplPropertyNotifySink( void )
{
}


/*
 * CImplPropertyNotifySink::QueryInterface
 * CImplPropertyNotifySink::AddRef
 * CImplPropertyNotifySink::Release
 *
 * Purpose:
 *  IUnknown members for CImplPropertyNotifySink object.
 */

STDMETHODIMP CImplPropertyNotifySink::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImplPropertyNotifySink::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImplPropertyNotifySink::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}


STDMETHODIMP CImplPropertyNotifySink::OnChanged(DISPID dispid)
{
    if (dispid == DISPID_READYSTATE)
        m_pSite->OnReadyStateChanged();
    return S_OK;
}


STDMETHODIMP CImplPropertyNotifySink::OnRequestEdit (DISPID /*dispid*/)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\private.h ===
//	private.h
//	Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//	Private interfaces for DHTMLED
// Include this in the file which used <initguid.h>

#ifndef __DHTMLED_PRIVATE_H__
#define __DHTMLED_PRIVATE_H__


typedef interface IInterconnector IInterconnector;
typedef interface IProtocolInfoConnector IProtocolInfoConnector;


DEFINE_GUID(IID_IInterconnector, 0x9499F420,0xCE86,0x11d1,0x8C,0xD3,0x00,0xA0,0xC9,0x59,0xBC,0x0A);

MIDL_INTERFACE("9499F420-CE86-11d1-8CD3-00A0C959BC0A")
IInterconnector : public IUnknown
{
	public:
    STDMETHOD(GetInterconnector)( SIZE_T* pProxyFrame );
    STDMETHOD(GetCtlWnd)( SIZE_T* pWndCD );
	STDMETHOD(MakeDirty)( DISPID dispid );
};



DEFINE_GUID(IID_IProtocolInfoConnector, 0x5ADEA280,0xC2CD,0x11d1,0x8C,0xCB,0x00,0xA0,0xC9,0x59,0xBC,0x0A);

MIDL_INTERFACE("5ADEA280-C2CD-11d1-8CCB-00A0C959BC0A")
IProtocolInfoConnector : public IUnknown
{
	public:
     STDMETHOD(SetProxyFrame)( SIZE_T* pProxyFrame);
    
};


DEFINE_GUID(CLSID_DHTMLEdProtocol, 0xF6E34E90,0xC032,0x11d1, 0x8C,0xCB,0x00,0xA0,0xC9,0x59,0xBC,0x0A);

DEFINE_GUID(IID_IMultiLanguage2Correct, 0xDCCFC164,0x2B38,0x11d2, 0xB7,0xEC,0x00,0xC0,0x4F,0x8F,0x5D,0x9A);

#endif //__DHTMLED_PRIVATE_H__

// End of private.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\ioleobj.cpp ===
//------------------------------------------------------------------------------
// ioleobj.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      6-27-97      created     (bash)
//		4-8-98       ported to dhtmled (vank)
//
// Implementation of IOleObject.
//
// We mostly just delegate to Trident's IOleObject, except
// for GetUserClassID and GetUserType.
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "DHTMLEd.h"
#include "dhtmledit.h"

STDMETHODIMP CDHTMLEdit::SetClientSite(IOleClientSite *pClientSite)
{
	ATLTRACE(_T("CDHTMLEdit::SetClientSite\n"));

	_ASSERTE(m_pInnerIOleObj);
    
	return m_pInnerIOleObj->SetClientSite ( pClientSite );
}

STDMETHODIMP CDHTMLEdit::GetClientSite(IOleClientSite **ppClientSite)
{
	ATLTRACE(_T("CDHTMLEdit::GetClientSite\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetClientSite(ppClientSite);
}

STDMETHODIMP CDHTMLEdit::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
	ATLTRACE(_T("CDHTMLEdit::SetHostNames\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetHostNames(szContainerApp, szContainerObj);
}

STDMETHODIMP CDHTMLEdit::Close(DWORD dwSaveOption)
{
	ATLTRACE(_T("CDHTMLEdit::Close\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Close(dwSaveOption);
}

STDMETHODIMP CDHTMLEdit::SetMoniker(DWORD dwWhichMoniker, IMoniker* pmk)
{
	ATLTRACE(_T("CDHTMLEdit::SetMoniker\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetMoniker(dwWhichMoniker, pmk);
}

STDMETHODIMP CDHTMLEdit::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk )
{
	ATLTRACE(_T("CDHTMLEdit::GetMoniker\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
}

STDMETHODIMP CDHTMLEdit::InitFromData(IDataObject*  pDataObject, BOOL fCreation, DWORD dwReserved)
{
	ATLTRACE(_T("CDHTMLEdit::InitFromData\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->InitFromData(pDataObject,  fCreation,  dwReserved );
}

STDMETHODIMP CDHTMLEdit::GetClipboardData(DWORD dwReserved, IDataObject** ppDataObject)
{
	ATLTRACE(_T("CDHTMLEdit::GetClipboardData\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetClipboardData(dwReserved, ppDataObject);
}


STDMETHODIMP CDHTMLEdit::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite , LONG lindex ,
								 HWND hwndParent, LPCRECT lprcPosRect)
{
	ATLTRACE(_T("CDHTMLEdit::DoVerb\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
}

STDMETHODIMP CDHTMLEdit::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
	ATLTRACE(_T("CDHTMLEdit::EnumVerbs\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->EnumVerbs(ppEnumOleVerb);
}

STDMETHODIMP CDHTMLEdit::Update(void)
{
	ATLTRACE(_T("CDHTMLEdit::Update\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Update();
}

STDMETHODIMP CDHTMLEdit::IsUpToDate(void)
{
	ATLTRACE(_T("CDHTMLEdit::IsUpToDate\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->IsUpToDate();
}

STDMETHODIMP CDHTMLEdit::GetUserClassID(CLSID *pClsid)
{
	ATLTRACE(_T("CDHTMLEdit::GetUserClassID\n"));

	_ASSERTE(m_pInnerIOleObj);

	*pClsid = GetObjectCLSID();

	return S_OK;
}

STDMETHODIMP CDHTMLEdit::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
	ATLTRACE(_T("CDHTMLEdit::GetUserType\n"));

	_ASSERTE(m_pInnerIOleObj);

	return OleRegGetUserType(GetObjectCLSID(), dwFormOfType, pszUserType);
}

STDMETHODIMP CDHTMLEdit::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	ATLTRACE(_T("CDHTMLEdit::SetExtent\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CDHTMLEdit::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	ATLTRACE(_T("CDHTMLEdit::GetExtent\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CDHTMLEdit::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
	ATLTRACE(_T("CDHTMLEdit::Advise\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP CDHTMLEdit::Unadvise(DWORD dwConnection)
{
	ATLTRACE(_T("CDHTMLEdit::Unadvise\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Unadvise(dwConnection);
}

STDMETHODIMP CDHTMLEdit::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
	ATLTRACE(_T("CDHTMLEdit::EnumAdvise\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP CDHTMLEdit::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
	ATLTRACE(_T("CDHTMLEdit::GetMiscStatus\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetMiscStatus(dwAspect, pdwStatus);
}

STDMETHODIMP CDHTMLEdit::SetColorScheme(LOGPALETTE* pLogpal)
{
	ATLTRACE(_T("CDHTMLEdit::SetColorScheme\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetColorScheme(pLogpal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\plgprot.h ===
/*

    File: PlgProt.h

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
		DHTMLEd Pluggable Protocol

    History:
        06/26/97    Cgomes - ported from trident
		03/20/98	Vank   - ported from VID/htmed

*/
#if !defined __INC_PLGPROT_H__
#define __INC_PLGPRO_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "dhtmled.h"
#include "proxyframe.h"
#include "private.h"

EXTERN_C const CLSID CLSID_DHTMLEdProtocolInfo;
EXTERN_C const CLSID CLSID_DHTMLEdProtocol;

#define BIND_ASYNC 1

#define ExpectedExpr(expr)		\
		_ASSERTE((expr));			\
		if(!(expr))					\
			{ return E_UNEXPECTED; }

#define ExpectedPtr(ptr)		\
		_ASSERTE(ptr != NULL);			\
		if(ptr == NULL)					\
			{ return E_UNEXPECTED; }

#define InitParam(param)				\
		if(param != NULL)				\
			{ *param = NULL; }

#define IfNullRet(param) 				\
		_ASSERTE(param != NULL);		\
		if(param == NULL)				\
			{ return E_INVALIDARG; }

#define IfNullGo(param) 				\
		_ASSERTE(param != NULL);		\
		if(param == NULL)				\
			{ goto ONERROR; }

#define IfFailGo(hr)							\
		_ASSERTE(SUCCEEDED(hr));				\
		if(FAILED(hr))							\
			goto ONERROR;

#define _IfFailGo(hr)							\
		if(FAILED(hr))							\
			goto ONERROR;

#define IfFailRet(hr)						\
		_ASSERTE(SUCCEEDED(hr));		\
		if(FAILED(hr)) 					\
			{ return hr; }

#define IfNullPtrGo(ptr)							\
		_ASSERTE(ptr != NULL);					\
		if(ptr == NULL)							\
		{ hr = E_POINTER; goto ONERROR;}

#define AtlCreateInstance(ClassName, iid, ppUnk) \
	{ \
		CComObject<ClassName> *pObject = NULL; \
		if(SUCCEEDED(CComObject<ClassName>::CreateInstance(&pObject)) && \
			pObject != NULL) \
		{ \
			if(FAILED(pObject->GetUnknown()->QueryInterface(iid, (void**) ppUnk))) \
			{ \
				*ppUnk = NULL; \
			} \
		} \
	}

#define dimensionof(a)  (sizeof(a)/sizeof(*(a)))


//////////////////////////////////////////////////////////////////////////////
//
// DHTMLEd ProtocolInfo class
//

class ATL_NO_VTABLE CDHTMLEdProtocolInfo :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IClassFactory,
	public IInternetProtocolInfo,
	public IProtocolInfoConnector
{
public:

//DECLARE_POLY_AGGREGATABLE(CDHTMLEdProtocolInfo)
//DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CDHTMLEdProtocolInfo)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IInternetProtocolInfo)
	COM_INTERFACE_ENTRY(IProtocolInfoConnector)
END_COM_MAP()

//
//  IClassFactory methods
//
    STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP RemoteCreateInstance( REFIID riid, IUnknown ** ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
    STDMETHODIMP RemoteLockServer(BOOL fLock);
//
//  IInternetProtocolInfo methods
//
    STDMETHODIMP CombineUrl(LPCWSTR     pwzBaseUrl,
                            LPCWSTR     pwzRelativeUrl,
                            DWORD       dwFlags,
                            LPWSTR      pwzResult,
                            DWORD       cchResult,
                            DWORD *     pcchResult,
                            DWORD       dwReserved);
    STDMETHODIMP CompareUrl(LPCWSTR     pwzUrl1,
                            LPCWSTR     pwzUrl2,
                            DWORD       dwFlags);
    STDMETHODIMP ParseUrl(LPCWSTR     pwzUrl,
                          PARSEACTION ParseAction,
                          DWORD       dwFlags,
                          LPWSTR      pwzResult,
                          DWORD       cchResult,
                          DWORD *     pcchResult,
                          DWORD       dwReserved);
    STDMETHODIMP QueryInfo(LPCWSTR         pwzUrl,
                           QUERYOPTION     QueryOption,
                           DWORD           dwQueryFlags,
                           LPVOID          pBuffer,
                           DWORD           cbBuffer,
                           DWORD *         pcbBuf,
                           DWORD           dwReserved);

	// IProtocolInfoConnector methods
	STDMETHODIMP SetProxyFrame ( SIZE_T* vpProxyFrame );
//
//  Data members
//
private:
	BOOL					m_fZombied:1;
	CProxyFrame*			m_pProxyFrame;
	IProtocolInfoConnector*	m_piProtocolConIntf;

//
//  constructor
//
public:
	CDHTMLEdProtocolInfo();
	~CDHTMLEdProtocolInfo();
	void Zombie();

#if defined _DEBUG_ADDREF_RELEASE
public:
	ULONG InternalAddRef()
	{
		ATLTRACE(_T("CDHTMLEdProtocolInfo Ref %d>\n"), m_dwRef+1);
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLTRACE(_T("CDHTMLEdProtocolInfo Ref %d<\n"), m_dwRef-1);
		return _ThreadModel::Decrement(&m_dwRef);
	}
#endif

};

//////////////////////////////////////////////////////////////////////////////
//
// DHTMLEd Protocol class
//

class ATL_NO_VTABLE CDHTMLEdProtocol :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDHTMLEdProtocol, &CLSID_DHTMLEdProtocol>,
	public IInternetProtocol,
	public IProtocolInfoConnector
{
public:

DECLARE_POLY_AGGREGATABLE(CDHTMLEdProtocol)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CDHTMLEdProtocol)
	COM_INTERFACE_ENTRY(IInternetProtocol)
	COM_INTERFACE_ENTRY(IProtocolInfoConnector)
END_COM_MAP()

//
//  IInternetProtocol methods
//
    STDMETHOD(LockRequest)(DWORD dwOptions);
    STDMETHOD(Read)(void *pv,ULONG cb,ULONG *pcbRead);
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(UnlockRequest)();

//
//  IInternetProtocolRoot methods
//
    STDMETHOD(Abort)(HRESULT hrReason,DWORD dwOptions);
    STDMETHOD(Continue)(PROTOCOLDATA *pStateInfo);
    STDMETHOD(Resume)();
    STDMETHOD(Start)(LPCWSTR szUrl, IInternetProtocolSink *pProtSink, IInternetBindInfo *pOIBindInfo, DWORD grfSTI, HANDLE_PTR dwReserved);
    STDMETHOD(Suspend)();
    STDMETHOD(Terminate)(DWORD dwOptions);

	// IProtocolInfoConnector methods
	STDMETHODIMP SetProxyFrame ( SIZE_T* vpProxyFrame );
//
//  Data members
//
private:
    CComPtr<IInternetProtocolSink> 	m_srpSink; 			// The protocol sink
    CComPtr<IInternetBindInfo>     	m_srpBindInfo; 		// The Bind info
	CComPtr<IStream>				m_srpStream;		// Buffer Stream

	CComBSTR		m_bstrBaseURL;			// BaseURL of buffer
    DWORD 			m_bscf;
	DWORD			m_grfBindF;
	DWORD			m_grfSTI;
	BINDINFO		m_bindinfo;
	BOOL			m_fAborted:1;
	BOOL 			m_fZombied:1;
	CProxyFrame*	m_pProxyFrame;

//
//  constructor
//
public:
	CDHTMLEdProtocol();
	~CDHTMLEdProtocol();
	void Zombie();

//
//  Method members
//
private:
	HRESULT ParseAndBind();
	void 	ReportData(ULONG cb);

#if defined _DEBUG_ADDREF_RELEASE
public:
	ULONG InternalAddRef()
	{
		ATLTRACE(_T("CDHTMLEdProtocol Ref %d>\n"), m_dwRef+1);
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLTRACE(_T("CDHTMLEdProtocol Ref %d<\n"), m_dwRef-1);
		return _ThreadModel::Decrement(&m_dwRef);
	}
#endif
};

#endif __INC_PLGPRO_H__

/* end of file*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\plgprot.cpp ===
/*

    File: PlgProt.cpp

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:

    History:
        06/26/97    Cgomes - ported from Trident
		03/20/98	Vank   - ported from VID/htmed

	This pluggable protocol handler allows the control to override
	URL combining, parsing the security URL, and loading data.

	The control implements a property for the BaseURL which is set
	properly by default, but can be overridden by the user.  To make
	this work we override CombineURL.

	To assure that the control is safe when hosted by IE but powerful
	when hosted by VB, we override ParseURL(PARSE_SECURITY_URL) and
	return a URL representing the zone of the outermost hosting Trident,
	or the path to the drive where the DLL is installed if Trident is
	not our host.  This correctly handles cases where we're hosted on
	an intranet page, which is hosted in an internet page, which is
	hosted in an intranet page, etc.  The topmost container's security
	zone is the one returned to IE.
	
	Finally, the control is in charge of saying what data is to be loaded.
	This can be set from a file, a URL, or a BSTR.

	NOTE:
	TSDK had the unusual requirement of having to be able to register
	even when it could not run.  WinINet and UrlMon were dynamically
	loaded when the control was instantiated.  This is clearly not
	necessary when we're a part of IE5, so this code has been disabled
	using the define LATE_BIND_URLMON_WININET.

*/
#include "stdafx.h"
#include <wininet.h>
#include "plgprot.h"
#include "dhtmledit.h"


//////////////////////////////////////////////////////////////////////////////
//
//  DHTMLEd Protocol Implementaion
//
CDHTMLEdProtocolInfo::CDHTMLEdProtocolInfo()
{
	ATLTRACE(_T("CDHTMLEdProtocolInfo::CDHTMLEdProtocolInfo\n"));

	m_fZombied			= FALSE;
	m_pProxyFrame		= NULL;
	m_piProtocolConIntf	= NULL;
}


CDHTMLEdProtocolInfo::~CDHTMLEdProtocolInfo()
{
	ATLTRACE(_T("CDHTMLEdProtocolInfo::~CDHTMLEdProtocolInfo\n"));

	Zombie();
}


void CDHTMLEdProtocolInfo::Zombie()
{
	m_fZombied = TRUE;
	if ( NULL != m_piProtocolConIntf )
	{
		m_piProtocolConIntf->Release ();
		m_piProtocolConIntf = NULL;
	}
}


//////////////////////////////////////////////////////////////////////////////
//
//  IClassFactory Implementation
//

STDMETHODIMP CDHTMLEdProtocolInfo::CreateInstance
(
	IUnknown* 	/*pUnkOuter*/,
	REFIID 	   	riid,
	void**		ppvObject
)
{
	ExpectedExpr((!m_fZombied));
	InitParam(ppvObject);
	IfNullRet(ppvObject);

	HRESULT hr;

	// Only support creating the DHTMLEdProtocol object

	AtlCreateInstance(CDHTMLEdProtocol, riid, ppvObject);
	_ASSERTE(*ppvObject != NULL);

	if(*ppvObject == NULL)
		return E_NOINTERFACE;
	else
	{
		hr = (reinterpret_cast<IUnknown*>(*ppvObject)->QueryInterface) ( IID_IProtocolInfoConnector, (LPVOID*) &m_piProtocolConIntf );
		_ASSERTE ( SUCCEEDED ( hr ) && m_piProtocolConIntf );
		if ( SUCCEEDED ( hr ) && m_piProtocolConIntf )
		{
			if ( NULL != m_pProxyFrame )
			{
				m_piProtocolConIntf->SetProxyFrame ( (SIZE_T*)m_pProxyFrame );
			}
		}
		return NOERROR;
	}
}


STDMETHODIMP CDHTMLEdProtocolInfo::RemoteCreateInstance
(
	REFIID 		/*riid*/,
	IUnknown** 	/*ppvObject*/
)
{
	ExpectedExpr((!m_fZombied));
	ATLTRACENOTIMPL(_T("RemoteCreateInstance"));
}


STDMETHODIMP CDHTMLEdProtocolInfo::LockServer(BOOL /*fLock*/)
{
	ExpectedExpr((!m_fZombied));
	ATLTRACE(_T("CDHTMLEdProtocolInfo::LockServer\n"));

	return NOERROR;
}


STDMETHODIMP CDHTMLEdProtocolInfo::RemoteLockServer(BOOL /*fLock*/)
{
	ExpectedExpr((!m_fZombied));
	ATLTRACENOTIMPL(_T("RemoteLockServer"));
}


//////////////////////////////////////////////////////////////////////////////
//
//  IInternetProtocolInfo Implementation
//


//	Override the BaseURL
//
STDMETHODIMP CDHTMLEdProtocolInfo::CombineUrl
(
    LPCWSTR     pwzBaseURL,
    LPCWSTR     pwzRelativeURL,
    DWORD       /*dwFlags*/,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       /*dwReserved*/
)
{
	_ASSERTE ( m_pProxyFrame );

	CComBSTR bstrBaseURL;
#ifdef LATE_BIND_URLMON_WININET
	PFNCoInternetCombineUrl pfnCoInternetCombineUrl = m_pProxyFrame->m_pfnCoInternetCombineUrl;
#endif // LATE_BIND_URLMON_WININET

	ExpectedExpr((!m_fZombied));
	InitParam(pcchResult);
	IfNullGo(pwzBaseURL);
	IfNullGo(pwzRelativeURL);
	IfNullGo(pwzResult);
	IfNullGo(pcchResult);

	ATLTRACE(_T("CDHTMLEdProtocolInfo::CombineUrl(%ls,%ls)\n"), pwzBaseURL, pwzRelativeURL);

	HRESULT hr;
	_ASSERTE ( m_pProxyFrame );
	IfNullGo(m_pProxyFrame);

	// GetBaseURL returns the value of the control's BaseURL property.  The pwzBaseURL parameter is ignored.
	hr = m_pProxyFrame->GetBaseURL(bstrBaseURL);
	_IfFailGo(hr);

	// Handle case where return buffer is too small
	*pcchResult  = bstrBaseURL.Length () + 1;
	if(*pcchResult > cchResult)
	{
		return S_FALSE;
	}

	// combine with our base url
#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( pfnCoInternetCombineUrl );
    hr = (*pfnCoInternetCombineUrl) ( bstrBaseURL, pwzRelativeURL, ICU_ESCAPE, pwzResult, cchResult, pcchResult, 0 );
#else
    hr = CoInternetCombineUrl ( bstrBaseURL, pwzRelativeURL, ICU_ESCAPE, pwzResult, cchResult, pcchResult, 0 );
#endif // LATE_BIND_URLMON_WININET

	IfFailGo(hr);

	if ( S_OK == hr )
		ATLTRACE(_T("CDHTMLEdProtocolInfo::CombinUrl to %ls\n"), pwzResult);

	return hr;

ONERROR:
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdProtocolInfo::CompareUrl
(
    LPCWSTR     /*pwzUrl1*/,
    LPCWSTR     /*pwzUrl2*/,
    DWORD       /*dwFlags*/
)
{
	ExpectedExpr((!m_fZombied));
    return E_NOTIMPL;
}


//	Override the security URL.  See comments at top of file.
//
STDMETHODIMP CDHTMLEdProtocolInfo::ParseUrl
(
    LPCWSTR     pwzURL,
    PARSEACTION ParseAction,
    DWORD       /*dwFlags*/,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       /*dwReserved*/
)
{
	ExpectedExpr((!m_fZombied));
	IfNullRet(pwzURL);
	InitParam(pcchResult);

	ATLTRACE(_T("CDHTMLEdProtocolInfo::ParseUrl(%d, %ls)\n"), (int)ParseAction, pwzURL);

	HRESULT hr;

	switch(ParseAction)
	{
		case PARSE_SECURITY_URL:
		{
			_ASSERTE(m_pProxyFrame != NULL);

			if(m_pProxyFrame != NULL)
			{
				CComBSTR bstrSecurityURL;

				hr = m_pProxyFrame->GetSecurityURL(bstrSecurityURL);

				if(SUCCEEDED(hr))
				{
					// set out param
					*pcchResult = bstrSecurityURL.Length () + 1;

					if(*pcchResult <= cchResult)
					{
						// copy result
						wcscpy(pwzResult, bstrSecurityURL);

						ATLTRACE(_T("CDHTMLEdProtocolInfo::ParseUrl(%ls)\n"), pwzResult);

						return NOERROR;
					}
					else
						return S_FALSE; // buffer too small
				}
			}
		}
		break;

		case PARSE_CANONICALIZE:
		case PARSE_FRIENDLY:
		case PARSE_DOCUMENT:
		case PARSE_PATH_FROM_URL:
		case PARSE_URL_FROM_PATH:
		case PARSE_ROOTDOCUMENT:
		case PARSE_ANCHOR:
		case PARSE_ENCODE:
		case PARSE_DECODE:
		case PARSE_MIME:
		case PARSE_SERVER:
		case PARSE_SCHEMA:
		case PARSE_SITE:
		case PARSE_DOMAIN:
		case PARSE_LOCATION:
		case PARSE_SECURITY_DOMAIN:
		default:
    		return INET_E_DEFAULT_ACTION;
	}

    return INET_E_DEFAULT_ACTION;
}

STDMETHODIMP CDHTMLEdProtocolInfo::QueryInfo
(
    LPCWSTR         /*pwzURL*/,
    QUERYOPTION     QueryOption,
    DWORD           /*dwQueryFlags*/,
    LPVOID          pBuffer,
    DWORD           /*cbBuffer*/,
    DWORD *         pcbBuf,
    DWORD           /*dwReserved*/
)
{
	ExpectedExpr((!m_fZombied));
	InitParam(pcbBuf);
	IfNullRet(pBuffer);
	IfNullRet(pcbBuf);

	switch(QueryOption)
	{
		case QUERY_CONTENT_TYPE:
		case QUERY_EXPIRATION_DATE:
		case QUERY_TIME_OF_LAST_CHANGE:
		case QUERY_CONTENT_ENCODING:
		case QUERY_REFRESH:
		case QUERY_RECOMBINE:
		case QUERY_CAN_NAVIGATE:
		default:
			break;
	}

    return INET_E_DEFAULT_ACTION;
}


//	This type of strong coupling should normally be avoided, but it was
//	fast, simple, and safe in this case.
//
STDMETHODIMP CDHTMLEdProtocolInfo::SetProxyFrame ( SIZE_T* vpProxyFrame )
{
	m_pProxyFrame = (CProxyFrame*)vpProxyFrame;
	if ( NULL != m_piProtocolConIntf )
	{
		m_piProtocolConIntf->SetProxyFrame ( vpProxyFrame );
	}
	return S_OK;
}


STDMETHODIMP CDHTMLEdProtocol::SetProxyFrame ( SIZE_T* vpProxyFrame )
{
	m_pProxyFrame = (CProxyFrame*)vpProxyFrame;
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  DHTMLEd Protocol Implementaion
//


CDHTMLEdProtocol::CDHTMLEdProtocol()
{
	ATLTRACE(_T("CDHTMLEdProtocol::CDHTMLEdProtocol\n"));

	m_fZombied = FALSE;
	m_fAborted = FALSE;
    m_bscf = BSCF_FIRSTDATANOTIFICATION;
	m_pProxyFrame = NULL;

}


CDHTMLEdProtocol::~CDHTMLEdProtocol()
{
	ATLTRACE(_T("CDHTMLEdProtocol::~CDHTMLEdProtocol\n"));
	Zombie();
}


void CDHTMLEdProtocol::Zombie()
{
	m_fZombied = TRUE;
	m_srpSink.Release();
	m_srpBindInfo.Release();
	m_srpStream.Release();
	m_bstrBaseURL.Empty();
}


/*

    HRESULT ParseAndBind

    Description:
		Gets the stream from the control and begins returning data to IE.

*/
HRESULT CDHTMLEdProtocol::ParseAndBind()
{
	HRESULT hr;
	STATSTG sstg = {0};

	_ASSERTE(m_bstrBaseURL != NULL);
	_ASSERTE(m_srpStream == NULL);

	hr = m_pProxyFrame->GetFilteredStream(&m_srpStream);

	IfFailGo(hr);
	IfNullPtrGo(m_srpStream);

	// Read in size of the stream

	hr = m_srpStream->Stat(&sstg, STATFLAG_NONAME);
	IfFailGo(hr);

// fall through

ONERROR:

	if(!m_fAborted)
	{
		// Report Data to sink
		if(m_srpSink != NULL)
		{
			DWORD bscf = m_bscf | BSCF_DATAFULLYAVAILABLE | BSCF_LASTDATANOTIFICATION;

			// Specify mime / type as HTML
			m_srpSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"text/html");

			// Report size of data
			ATLTRACE(_T("CDHTMLEdProtocol::ParseAndBind(%d bytes)\n"), sstg.cbSize.LowPart);
			m_srpSink->ReportData(bscf, sstg.cbSize.LowPart, sstg.cbSize.LowPart);

			// Report result should be called only when all data have been read by consumer
			// IE4 accepts ReportResult() here while IE5 does not. This is because IE4 queues
			// the report while IE5 executes it immediatetely, terminating the VID protocol.
			// See VID bug #18128 for additional details.
			//if(m_srpSink != NULL)
			//{
			//	m_srpSink->ReportResult(hr, 0, 0);  DO NOT DO THIS!
			//}
		}
	}
    return hr;
}


/*

    void ReportData

    Description:
        Report to sink data is fully available

*/
void CDHTMLEdProtocol::ReportData(ULONG cb)
{
    m_bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;

	if(m_srpSink != NULL)
	{
    	m_srpSink->ReportData(m_bscf, cb, cb);
	}
}


//////////////////////////////////////////////////////////////////////////////
//
//  IInternetProtocol Implementation
//


STDMETHODIMP CDHTMLEdProtocol::LockRequest(DWORD /*dwOptions*/)
{
	ExpectedExpr((!m_fZombied));
    return S_OK;
}


STDMETHODIMP CDHTMLEdProtocol::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Read(%ls) %d bytes\n"), m_bstrBaseURL ? m_bstrBaseURL : L"(null)", cb);

	if(m_fZombied)
		return S_FALSE;

	_ASSERTE(m_srpStream != NULL);
	if(m_srpStream == NULL)
		return INET_E_DOWNLOAD_FAILURE;

	HRESULT hr;

	hr = m_srpStream->Read(pv, cb, pcbRead);
	_ASSERTE(SUCCEEDED(hr));

	if(FAILED(hr))
		return INET_E_DOWNLOAD_FAILURE;

	ATLTRACE(_T("CDHTMLEdProtocol::Read returning hr=%08X %d bytes read\n"), ((*pcbRead) ? hr : S_FALSE), *pcbRead);

	if(*pcbRead)
		return hr;
	else
	{
		// Tell the sink that I am done reading.
		m_srpSink->ReportResult(S_FALSE, 0, 0);
		return S_FALSE;
	}
}


STDMETHODIMP CDHTMLEdProtocol::Seek
(
    LARGE_INTEGER 	dlibMove,
    DWORD 			dwOrigin,
    ULARGE_INTEGER 	*plibNewPosition
)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Seek(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
	ExpectedPtr(m_srpStream);

	HRESULT hr;

	// Do the seek

    hr = m_srpStream->Seek(dlibMove, dwOrigin, plibNewPosition);
	IfFailRet(hr);

	return hr;
}


STDMETHODIMP CDHTMLEdProtocol::UnlockRequest()
{
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  IInternetProtocolRoot Implementation
//


STDMETHODIMP CDHTMLEdProtocol::Start
(
    LPCWSTR 				pwzURL,
    IInternetProtocolSink 	*pSink,
    IInternetBindInfo 		*pBindInfo,
    DWORD 					grfSTI,
    HANDLE_PTR				/*dwReserved*/
)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Start(%ls)\n"), pwzURL);
	_ASSERTE ( m_pProxyFrame );

#ifdef LATE_BIND_URLMON_WININET
	PFNCoInternetParseUrl pfnCoInternetParseUrl = m_pProxyFrame->m_pfnCoInternetParseUrl;
#endif // LATE_BIND_URLMON_WININET

	ExpectedExpr((!m_fZombied));
	IfNullRet(pwzURL);
	IfNullRet(pBindInfo);
	IfNullRet(pSink);

    HRESULT         hr;
    WCHAR           wch[INTERNET_MAX_URL_LENGTH];
    DWORD           dwSize;

	_ASSERTE(m_srpSink == NULL);
	_ASSERTE(m_bstrBaseURL == NULL);

    if( !(grfSTI & PI_PARSE_URL))
    {
		m_srpSink.Release();
		m_srpSink = pSink;

		m_srpBindInfo.Release();
		m_srpBindInfo = pBindInfo;
    }

    m_bindinfo.cbSize = sizeof(BINDINFO);
    hr = pBindInfo->GetBindInfo(&m_grfBindF, &m_bindinfo);
	IfFailGo(hr);

	ATLTRACE(_T("CDHTMLEdProtocol::BINDF                    =%08X\n"), 	m_grfBindF);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.szExtraInfo     =%ls\n"), 	m_bindinfo.szExtraInfo ? m_bindinfo.szExtraInfo : L"(null)");
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.grfBindInfoF    =%08X\n"), 	m_bindinfo.grfBindInfoF);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwBindVerb      =%08X\n"), 	m_bindinfo.dwBindVerb);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.szCustomVerb    =%ls\n"),   	m_bindinfo.szCustomVerb ? m_bindinfo.szCustomVerb : L"(null)");
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.cbstgmedData    =%08X\n"), 	m_bindinfo.cbstgmedData);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwOptions       =%08X\n"), 	m_bindinfo.dwOptions);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwOptionsFlags  =%08X\n"), 	m_bindinfo.dwOptionsFlags);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwCodePage      =%08X\n"), 	m_bindinfo.dwCodePage);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwReserved      =%08X\n"), 	m_bindinfo.dwReserved);

    //
    // First get the basic url.  Unescape it first.
    //

#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( pfnCoInternetParseUrl );
    hr = (*pfnCoInternetParseUrl)( pwzURL, PARSE_ENCODE, 0, wch, dimensionof(wch), &dwSize, 0 );
#else
    hr = CoInternetParseUrl ( pwzURL, PARSE_ENCODE, 0, wch, dimensionof(wch), &dwSize, 0 );
#endif // LATE_BIND_URLMON_WININET

	IfFailGo(hr);

	m_bstrBaseURL = wch;
	IfNullPtrGo(m_bstrBaseURL.m_str);

    //
    // Now append any extra data if needed.
    //

    if (m_bindinfo.szExtraInfo)
    {
		m_bstrBaseURL.Append(m_bindinfo.szExtraInfo);
		IfNullPtrGo(m_bstrBaseURL.m_str);
    }

    m_grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //

    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        m_srpSink->Switch(&protdata);
    }
    else
    {
        hr = ParseAndBind();
		IfFailGo(hr);
    }

	return hr;

ONERROR:
    return hr;
}


STDMETHODIMP CDHTMLEdProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Continue(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
	IfNullRet(pStateInfoIn);

    HRESULT hr = E_FAIL;

	_ASSERTE(pStateInfoIn->pData != NULL);
	_ASSERTE(pStateInfoIn->cbData != 0);
	_ASSERTE(pStateInfoIn->dwState == (DWORD) BIND_ASYNC);

    if(pStateInfoIn->dwState == BIND_ASYNC)
    {
        hr =  ParseAndBind();
    }

    return hr;
}


STDMETHODIMP CDHTMLEdProtocol::Abort(HRESULT /*hrReason*/, DWORD /*dwOptions*/)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Abort(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));

    m_fAborted = TRUE;

	ExpectedPtr(m_srpSink);

    return m_srpSink->ReportResult(E_ABORT, 0, 0);
}


STDMETHODIMP CDHTMLEdProtocol::Terminate(DWORD dwOptions)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Terminate(%08X, %ls)\n"), dwOptions, m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));

    if (m_bindinfo.stgmedData.tymed != TYMED_NULL)
    {
        ::ReleaseStgMedium(&(m_bindinfo.stgmedData));
        m_bindinfo.stgmedData.tymed = TYMED_NULL;
    }

    if (m_bindinfo.szExtraInfo)
    {
        ::CoTaskMemFree(m_bindinfo.szExtraInfo);
        m_bindinfo.szExtraInfo = NULL;
    }

	Zombie();

    return NOERROR;
}


STDMETHODIMP CDHTMLEdProtocol::Suspend()
{
	ATLTRACE(_T("CDHTMLEdProtocol::Suspend(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
    return E_NOTIMPL;
}


STDMETHODIMP CDHTMLEdProtocol::Resume()
{
	ATLTRACE(_T("CDHTMLEdProtocol::Resume(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
    return E_NOTIMPL;
}

/* end of file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\proxyframe.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef _proxyframe_h_
#define _proxyframe_h_

#include <docobj.h>
#include <ocidl.h>
#include <WinINet.h>
#include "plgprot.h"
#include "dhtmledit.h"

// This was given in email from Josh Kaplan to Steve Isaac in response
// to what command is necessary so that Trident won't clear the undo
// stack on setAttribute calls. The command takes a BOOL -- True == good behavior
#define IDM_GOOD_UNDO_BEHAVIOR 6049

typedef struct _CommandMap
{
	DHTMLEDITCMDID typeLibCmdID;
	ULONG cmdID;
	BOOL bOutParam;

} CommandMap;

#ifdef LATE_BIND_URLMON_WININET
typedef HRESULT (WINAPI *PFNCoInternetCombineUrl)(LPCWSTR,LPCWSTR,DWORD,LPWSTR,DWORD,DWORD*,DWORD);             
typedef HRESULT (WINAPI *PFNCoInternetParseUrl)(LPCWSTR,PARSEACTION,DWORD,LPWSTR,DWORD,DWORD*,DWORD);
typedef HRESULT (WINAPI *PFNCreateURLMoniker)(LPMONIKER,LPCWSTR,LPMONIKER FAR*);
typedef HRESULT (WINAPI *PFNCoInternetGetSession)(DWORD,IInternetSession**,DWORD);
typedef HRESULT (WINAPI *PFNURLOpenBlockingStream)(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);

typedef BOOL (WINAPI *PFNDeleteUrlCacheEntry)(LPCSTR);
typedef BOOL (WINAPI *PFNInternetCreateUrl)(LPURL_COMPONENTSA,DWORD,LPSTR,LPDWORD);
typedef BOOL (WINAPI *PFNInternetCrackURL)(LPCSTR,DWORD,DWORD,LPURL_COMPONENTSA);
#endif // LATE_BIND_URLMON_WININET



class CDHTMLEdProtocolInfo;
typedef CComObject<CDHTMLEdProtocolInfo> 	*PProtocolInfo;

class CDHTMLSafe;


typedef enum DENudgeDirection {
	deNudgeUp = 8000,
	deNudgeDown,
	deNudgeLeft,
	deNudgeRight,
};


class CProxyFrame : public IOleInPlaceFrame, public IOleCommandTarget,
	public IBindStatusCallback, public IAuthenticate
{
public:
		CProxyFrame(CDHTMLSafe* pCtl);
		~CProxyFrame();

		HRESULT Init(IUnknown* pUnk, IUnknown** ppUnkTriEdit);
		HRESULT PreActivate();
		HRESULT Activate();
		void    UIDeactivate();
		HRESULT Close();
		HRESULT LoadInitialDoc();
		HRESULT LoadDocument(BSTR path, BOOL bfIsURL = FALSE);
		HRESULT FilterSourceCode ( BSTR bsSourceIn, BSTR* pbsSourceOut );
		HRESULT Print( BOOL bfWithUI );
		HRESULT SaveDocument(BSTR path);
		HRESULT SetContextMenu(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates);
		HRESULT SetContextMenuSA(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates);
		HRESULT SetContextMenuDispEx(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates);
		HRESULT GetBrowseMode ( VARIANT_BOOL  *pVal );
		HRESULT SetBrowseMode ( VARIANT_BOOL  newVal );
		HRESULT GetDocumentTitle ( CComBSTR&  bstrTitle );
		HRESULT GetDivOnCr ( VARIANT_BOOL *pVal );
		HRESULT SetDivOnCr ( VARIANT_BOOL newVal );
		HRESULT GetBusy ( VARIANT_BOOL *pVal );
		HRESULT RefreshDoc ( void );

		HRESULT HrTridentSetPropBool(ULONG cmd, BOOL bVal);
		HRESULT HrTridentGetPropBool(ULONG cmd, BOOL& bVal);

		HRESULT HrMapCommand(DHTMLEDITCMDID typeLibCmdID, ULONG* cmdID, const GUID** ppguidCmdGroup, BOOL* bpInParam);
		HRESULT HrExecCommand(const GUID* pguidCmdGroup, ULONG ucmdID, OLECMDEXECOPT cmdexecopt, VARIANT* pVarIn, VARIANT* pVarOut);
		HRESULT HrMapExecCommand(DHTMLEDITCMDID deCommand, OLECMDEXECOPT cmdexecopt, VARIANT* pVarIn, VARIANT* pVarOut);
		HRESULT HrExecGenericCommands(const GUID* pguidCmdGroup, ULONG cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pVarInput, BOOL bOutParam);
		HRESULT HrExecGetBlockFmtNames(LPVARIANT pVarInput);
		HRESULT HrExecInsertTable(LPVARIANT pVarInput);
		HRESULT HrExecGetColor(DHTMLEDITCMDID deCommand, ULONG ulMappedCommand, LPVARIANT pVarOutput);
		HRESULT HrExecSetFontSize(LPVARIANT pVarInput);

		HRESULT HrQueryStatus(const GUID* pguidCmdGroup, ULONG ucmdID, OLECMDF* cmdf);
		HRESULT HrMapQueryStatus( DHTMLEDITCMDID ucmdID, DHTMLEDITCMDF* cmdf);

		HRESULT HrGetDoc(IHTMLDocument2 **ppDoc);
		HRESULT HrGetTableSafeArray(IDEInsertTableParam* pTable, LPVARIANT pVarIn);

		HRESULT HrTranslateAccelerator(LPMSG lpmsg);
		HRESULT HrHandleAccelerator(LPMSG lpmsg);
		HRESULT HrNudge(DENudgeDirection dir);
		HRESULT HrToggleAbsolutePositioned();
		HRESULT HrHyperLink();
		HRESULT HrIncreaseIndent();
		HRESULT HrDecreaseIndent();

		void UpdateObjectRects(void);
		void SetParent ( HWND hwndControl );
		void Show ( WPARAM nCmdShow );
		LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

		void OnReadyStateChanged(READYSTATE readyState);

		inline CDHTMLSafe* GetControl() {
			return m_pCtl;
		};

		inline BOOL IsCreated() {
			return m_fCreated;
		};

		inline BOOL IsActivated() {
			return m_fActivated;
		};

		inline SAFEARRAY* GetMenuStrings() {
			return m_pMenuStrings;
		};

		inline SAFEARRAY* GetMenuStates() {
			return m_pMenuStates;
		};

		HRESULT GetContainer ( LPOLECONTAINER* ppContainer );

		HRESULT GetCurDocNameWOPath ( CComBSTR& bstrDocName );
		HRESULT GetBaseURL ( CComBSTR& bstrBaseURL );
		HRESULT SetBaseURL ( CComBSTR& bstrBaseURL );
		HRESULT GetFilteredStream ( IStream** ppStream );
		HRESULT GetSecurityURL (CComBSTR& bstrSecurityURL );

protected:

		HRESULT HrSetRuntimeProperties();
		HRESULT HrSetDocLoadedProperties();
		HRESULT SetBaseURLFromBaseHref ( void );
		HRESULT SetBaseURLFromCurDocPath ( BOOL bfIsURL );
		HRESULT SetBaseURLFromURL ( const CComBSTR& bstrURL );
		HRESULT SetBaseURLFromFileName ( const CComBSTR& bstrFName );
		HRESULT SetBaseUrlFromFileUrlComponents ( URL_COMPONENTS & urlc );
		HRESULT SetBaseUrlFromUrlComponents ( URL_COMPONENTS & urlc );

		typedef enum TriEditState {
			ESTATE_NOTCREATED = 0,
			ESTATE_CREATED,
			ESTATE_PREACTIVATING,
			ESTATE_ACTIVATING,
			ESTATE_ACTIVATED,
		} TriEditState;

		void ChangeState(TriEditState state) { m_state = state; }
		inline TriEditState GetState() { return m_state; }

		HRESULT GetSelectionPos ( LPPOINT lpWhere );

public: // properties

		HRESULT HrSetPropActivateControls(BOOL activateControls);
		HRESULT HrGetPropActivateControls(BOOL& activateControls);

		HRESULT HrSetPropActivateApplets(BOOL activateApplets);
		HRESULT HrGetPropActivateApplets(BOOL& activateApplets);

		HRESULT HrSetPropActivateDTCs(BOOL activateDTCs);
		HRESULT HrGetPropActivateDTCs(BOOL& activateDTCs);

		HRESULT HrSetPropShowAllTags(BOOL showAllTags);
		HRESULT HrGetPropShowAllTags(BOOL& showAllTags);

		HRESULT HrSetPropShowBorders(BOOL showBorders);
		HRESULT HrGetPropShowBorders(BOOL& showBorders);

		HRESULT HrSetDisplay3D(BOOL bVal);
		HRESULT HrGetDisplay3D(BOOL& bVal);

		HRESULT HrSetScrollbars(BOOL bVal);
		HRESULT HrGetScrollbars(BOOL& bVal);

		HRESULT HrSetDisplayFlatScrollbars(BOOL bVal);
		HRESULT HrGetDisplayFlatScrollbars(BOOL& bVal);

		HRESULT HrSetDocumentHTML(BSTR bVal);
		HRESULT HrGetDocumentHTML(BSTR* bVal);

		HRESULT HrSetPreserveSource(BOOL bVal);
		HRESULT HrGetPreserveSource(BOOL& bVal);

		HRESULT HrSetAbsoluteDropMode(BOOL dropMode);
		HRESULT HrGetAbsoluteDropMode(BOOL& dropMode);

		HRESULT HrSetSnapToGrid(BOOL snapToGrid);
		HRESULT HrGetSnapToGrid(BOOL& snapToGrid);

		HRESULT HrSetSnapToGridX(LONG snapToGridX);
		HRESULT HrGetSnapToGridX(LONG& snapToGridX);

		HRESULT HrSetSnapToGridY(LONG snapToGridY);
		HRESULT HrGetSnapToGridY(LONG& snapToGridY);

		HRESULT HrGetIsDirty(BOOL& bVal);

		HRESULT HrGetCurrentDocumentPath(BSTR* bVal);

		// IBindStatusCallback trivial implementation, for synchronous transfer ONLY:
		STDMETHOD(GetBindInfo)(DWORD*,BINDINFO*) { return E_NOTIMPL; }
		STDMETHOD(OnStartBinding)(DWORD, IBinding*) { return S_OK; }
		STDMETHOD(GetPriority)(LONG *pnPriority) { *pnPriority = THREAD_PRIORITY_NORMAL; return S_OK; }
		STDMETHOD(OnProgress)(ULONG, ULONG, ULONG, LPCWSTR);
		STDMETHOD(OnDataAvailable)(DWORD, DWORD, FORMATETC*, STGMEDIUM*) { return E_NOTIMPL; }
		STDMETHOD(OnObjectAvailable)(REFIID, IUnknown*) { return E_NOTIMPL; }
		STDMETHOD(OnLowResource)(DWORD) { return E_NOTIMPL; }
		STDMETHOD(OnStopBinding)(HRESULT, LPCWSTR) { return S_OK; }

		// IAuthenticate
		STDMETHOD(Authenticate)(HWND *phwnd, LPWSTR *pszUserName, LPWSTR *pszPassword)
		{ *phwnd = m_hWndObj; *pszUserName = NULL; *pszPassword = NULL; return S_OK; }

public:
		//Shared IUnknown implementation
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//IOleInPlaceFrame implementation
        STDMETHODIMP         GetWindow(HWND *);
        STDMETHODIMP         ContextSensitiveHelp(BOOL);
        STDMETHODIMP         GetBorder(LPRECT);
        STDMETHODIMP         RequestBorderSpace(LPCBORDERWIDTHS);
        STDMETHODIMP         SetBorderSpace(LPCBORDERWIDTHS);
        STDMETHODIMP         SetActiveObject(LPOLEINPLACEACTIVEOBJECT
                                 , LPCOLESTR);
        STDMETHODIMP         InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
        STDMETHODIMP         SetMenu(HMENU, HOLEMENU, HWND);
        STDMETHODIMP         RemoveMenus(HMENU);
        STDMETHODIMP         SetStatusText(LPCOLESTR);
        STDMETHODIMP         EnableModeless(BOOL);
        STDMETHODIMP         TranslateAccelerator(LPMSG, WORD);

		//IOleCommandTarget
        STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds
            , OLECMD prgCmds[], OLECMDTEXT *pCmdText);
        
        STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID
            , DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

		HRESULT OnTriEditEvent ( const GUID& iidEventInterface, DISPID dispid );	

		HWND	GetDocWindow () { return m_hWndObj; }
		HRESULT GetScrollPos ( LPPOINT lpPos );
		HRESULT CheckCrossZoneSecurity ( BSTR url );
		HRESULT	CheckCrossZoneSecurityOfSelection ( void );
		void	ClearSFSRedirect ( void ) { m_bfSFSRedirect = FALSE; }
		BOOL	GetSFSRedirect ( void ) { return m_bfSFSRedirect; }

		void	ClearLoadingFlag ( void ) { m_bfIsLoading = FALSE; }

private:
		HRESULT RegisterPluggableProtocol ( void );
		HRESULT UnRegisterPluggableProtocol ( void );
		HRESULT LoadBSTRDeferred ( BSTR bVal );
		void AssureActivated ( void );
		WCHAR* GetInitialHTML ( void );
		void InitializeDocString ( void ) { m_bstrInitialDoc = GetInitialHTML (); }
		BOOL IsMissingBackSlash ( BSTR path, BOOL bfIsURL );
		HRESULT SetDirtyFlag ( BOOL bfMakeDirty );
#ifdef LATE_BIND_URLMON_WININET
		BOOL DynLoadLibraries ( void );
		void DynUnloadLibraries ( void );
#endif // LATE_BIND_URLMON_WININET

private:

        ULONG           m_cRef;
		TriEditState	m_state;

		class CDHTMLSafe*m_pCtl; // back pointer to control
        class CSite*	m_pSite;  // Site holding object        

		BOOL			m_fCreated;
		BOOL			m_fActivated;
		LPUNKNOWN		m_pUnkTriEdit;
        IOleInPlaceActiveObject *m_pIOleIPActiveObject;
		HWND			m_hWndObj;			// Trident's window

		READYSTATE		m_readyState;

		DWORD			m_dwFilterFlags;	// Flags to use for the next filter in
		DWORD			m_dwFilterOutFlags;	// Flags used on the last filter out

		SAFEARRAY*		m_pMenuStrings;
		SAFEARRAY*		m_pMenuStates;

		BOOL m_fActivateApplets;			// takes affect at init only
		BOOL m_fActivateControls;		// takes affect at init only
		BOOL m_fActivateDTCs;			// takes affect at init only

		BOOL m_fShowAllTags;				// can be set anytime
		BOOL m_fShowBorders;				// can be set anytime

		BOOL m_fDialogEditing;				// takes affect at init only
		BOOL m_fDisplay3D;					// takes affect at init only
		BOOL m_fScrollbars;					// takes affect at init only
		BOOL m_fDisplayFlatScrollbars;		// takes affect at init only
		BOOL m_fContextMenu;				// takes affect at init only

		BOOL m_fPreserveSource;			// takes affect at init only

		BOOL m_fAbsoluteDropMode;
		BOOL m_fSnapToGrid;
		LONG m_ulSnapToGridX;
		LONG m_ulSnapToGridY;

		CComBSTR m_bstrInitialDoc;
		CComBSTR m_bstrCurDocPath;
		CComBSTR m_bstrBaseURL;
		VARIANT_BOOL	m_vbBrowseMode;
		PProtocolInfo	m_pProtInfo;
		WCHAR	m_wszProtocol[16];
		WCHAR	m_wszProtocolPrefix[16];
		BOOL	m_bfIsURL;
		CComBSTR	m_bstrLoadText;
		HWND	m_hwndRestoreFocus;
		VARIANT_BOOL	m_vbUseDivOnCr;
		BOOL	m_bfIsLoading;
		BOOL	m_bfBaseURLFromBASETag;
		BOOL	m_bfPreserveDirtyFlagAcrossBrowseMode;
		HRESULT	m_hrDeferredLoadError;

		BOOL	m_bfModeSwitched;
		BOOL	m_bfReloadAttempted;
		BOOL	m_bfSFSRedirect;

#ifdef LATE_BIND_URLMON_WININET
		HMODULE						m_hUlrMon;
		HMODULE						m_hWinINet;

public:
		PFNCoInternetCombineUrl		m_pfnCoInternetCombineUrl;
		PFNCoInternetParseUrl		m_pfnCoInternetParseUrl;
		PFNCreateURLMoniker			m_pfnCreateURLMoniker;
		PFNCoInternetGetSession		m_pfnCoInternetGetSession;
		PFNURLOpenBlockingStream	m_pfnURLOpenBlockingStream;

		PFNDeleteUrlCacheEntry		m_pfnDeleteUrlCacheEntry;
		PFNInternetCreateUrl		m_pfnInternetCreateUrl;
		PFNInternetCrackURL			m_pfnInternetCrackUrl;
#endif // LATE_BIND_URLMON_WININET
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// Used by DHTMLEd.rc
//
#define IDB_TOOLBOX                     1
#define IDB_TOOLBOX_Safe                2
#define IDS_PROJNAME                    100
#define IDR_DHTMLEDIT                   101
#define IDR_DEINSERTTABLEPARAM          102
#define IDR_DEGETBLOCKFMTNAMESPARAM     103
#define IDR_DHTMLSafe                   202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\triedcmdg.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef _triedcmdg_h_
#define _triedcmdg_h_

#ifdef __cplusplus
extern "C"{
#endif 

EXTERN_C const GUID GUID_TriEditCommandGroup;

DEFINE_GUID(GUID_TriEditCommandGroup,
0x2582f1c0, 0x84e, 0x11d1, 0x9a, 0xe, 0x0, 0x60, 0x97, 0xc9, 0xb3, 0x44);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_STDAFX_H__683364A5_B37D_11D1_ADC5_006008A5848C__INCLUDED_)
#define AFX_STDAFX_H__683364A5_B37D_11D1_ADC5_006008A5848C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif // STRICT

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#pragma warning(disable:4786)	// Turncated label warnings
#pragma warning(disable: 4505)	// unreferenced local function has been removed

#include <windows.h>

// Note that this include MUST be at this location (after the above include)
#include "win95wrp.h"

#include <atlbase.h>

#define AGGREGATE_TRIDENT 0
#define DHTMLEDTRACE OutputDebugString

// DHTMLEdit 1.0 had a requirement to be able to register WITHOUT being able to run.
// Thus, URLMon and WinINet were loaded late and necessary routines were bound as needed.
// This reuqirement went away with 2.0, and stood in the way of Win95Wrap utilization.
//#define LATE_BIND_URLMON_WININET	1


//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#pragma warning(disable: 4100 4189 4244)	// Necessary for ia64 build
#include <atlcom.h>
#pragma warning(disable: 4510 4610)			// Necessary for Win32 build W4
#include "atlctl.h"
#pragma warning(default: 4510 4610)			// Necessary for Win32 build W4
#pragma warning(default: 4100 4189 4244)	// Necessary for ia64 build

#include <mshtml.h>
#include <mshtmhst.h>
#include <mshtmcid.h>
#include <triedit.h>
#include <triedcid.h>
#include <comdef.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__683364A5_B37D_11D1_ADC5_006008A5848C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\site.cpp ===
//
// SITE.CPP
// Document Object Site Object
//
// Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "proxyframe.h"
#include "site.h"
#include <urlmon.h>
#include "triedsnk.h"
#include "private.h"

/*
 * CSite::CSite
 * CSite::~CSite
 *
 * Constructor Parameters:
 *  hWnd            HWND of the window associated with the site
 *  pFR             PCFrame to the parent structure.
 */
CSite::CSite(CProxyFrame* pFR )
{
    m_cRef						= 0;
    m_hWnd						= NULL;
    m_pFR						= pFR;
	m_dwPropNotifyCookie		= 0;
	m_dwOleObjectCookie			= 0;

    m_pObj						= NULL;
	m_bFiltered					= TRUE;//FALSE;
    
    m_pIOleObject				= NULL;
    m_pIOleIPObject				= NULL;
    m_pIOleDocView				= NULL;
	m_pIOleCommandTarget		= NULL;

    m_pImpIOleClientSite		= NULL;
    m_pImpIAdviseSink			= NULL;
    m_pImpIOleIPSite			= NULL;
    m_pImpIOleDocumentSite		= NULL;
	m_pImpIDocHostUIHandler		= NULL;
	m_pImpIDocHostShowUI		= NULL;
	m_pImpAmbientIDispatch		= NULL;
	m_pImpIPropertyNotifySink	= NULL;
	m_pImpIOleControlSite		= NULL;

	m_pTriEdDocEvtSink			= NULL;
	m_pTriEdWndEvtSink			= NULL;
	m_bfSaveAsUnicode			= FALSE;
	m_cpCodePage				= CP_ACP;
	m_piMLang					= NULL;
}


CSite::~CSite(void)
{
    //Object pointers cleaned up in Close.

    //We delete our own interfaces since we control them
    DeleteInterfaceImp( m_pImpIOleDocumentSite );
    DeleteInterfaceImp( m_pImpIOleIPSite );
    DeleteInterfaceImp( m_pImpIAdviseSink );
    DeleteInterfaceImp( m_pImpIOleClientSite );
	DeleteInterfaceImp( m_pImpIDocHostUIHandler );
	DeleteInterfaceImp( m_pImpIDocHostShowUI );
	DeleteInterfaceImp( m_pImpAmbientIDispatch);
	DeleteInterfaceImp( m_pImpIPropertyNotifySink);
	DeleteInterfaceImp( m_pImpIOleControlSite );

	if ( NULL != m_pTriEdDocEvtSink )
	{
		delete m_pTriEdDocEvtSink;
	}
	if ( NULL != m_pTriEdWndEvtSink )
	{
		delete m_pTriEdWndEvtSink;
	}
}


/*
 * CSite::QueryInterface
 * CSite::AddRef
 * CSite::Release
 *
 * Purpose:
 *  IUnknown members for CSite object.
 */
STDMETHODIMP CSite::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

#ifdef _DEBUG
	OLECHAR wszGUID[39];
	StringFromGUID2(riid, wszGUID, 39);
	USES_CONVERSION;
	LPTSTR szGUID = OLE2T(wszGUID);
	OutputDebugString(_T("CSite::QI("));
	OutputDebugString(szGUID);
	OutputDebugString(_T(")\n"));
#endif

    if ( IID_IOleClientSite == riid )
	{
        *ppv = m_pImpIOleClientSite;
	}

    if ( IID_IAdviseSink == riid )
	{
        *ppv = m_pImpIAdviseSink;
	}

    if ( IID_IOleWindow == riid || IID_IOleInPlaceSite == riid )
	{
        *ppv = m_pImpIOleIPSite;
	}

    if ( IID_IOleDocumentSite == riid )
	{
        *ppv = m_pImpIOleDocumentSite;
	}

    if ( IID_IDocHostUIHandler == riid )
    {
        *ppv = m_pImpIDocHostUIHandler;
    }

    if ( IID_IDocHostShowUI == riid )
    {
        *ppv = m_pImpIDocHostShowUI;
    }

    if ( IID_IDispatch == riid )
    {
        *ppv = m_pImpAmbientIDispatch;
    }

    if ( IID_IPropertyNotifySink== riid )
    {
        *ppv = m_pImpIPropertyNotifySink;
    }

    if ( IID_IOleControlSite== riid )
    {
        *ppv = m_pImpIOleControlSite;
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

	// Try the frame instead
	return GetFrame()->QueryInterface( riid, ppv );

}


STDMETHODIMP_(ULONG) CSite::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSite::Release(void)
{
    if ( 0 != --m_cRef )
	{
        return m_cRef;
	}

    delete this;

    return 0;
}

/*
 * CSite::HrCreate
 *
 * Purpose:
 *  Asks the site to instantiate the MSHTML.DLL object.
 *  
 *
 * Parameters:
 *  pIStorage       IStorage * of the parent storage in which we're
 *                  to create an IStorage for the new object.
 *  pchPath         Path of what to load..
 *
 * Return Value:
 *  BOOL            Result of the creation.
 */
HRESULT CSite::HrCreate(IUnknown* pUnk, IUnknown** ppUnkTriEdit)
{
    HRESULT   hr = S_OK;

	_ASSERTE(NULL == m_pObj);

	if (m_pObj)
		return E_UNEXPECTED;

	// It is valid for pUnk and ppUnkTriEdit to be NULL

	// Create the site's interface implementations which MSHTML.DLL will call
    m_pImpIOleClientSite = new CImpIOleClientSite( this, this );
    m_pImpIAdviseSink = new CImpIAdviseSink( this, this );
    m_pImpIOleIPSite = new CImpIOleInPlaceSite( this, this );
    m_pImpIOleDocumentSite = new CImpIOleDocumentSite( this, this );
	m_pImpIDocHostUIHandler = new CImpIDocHostUIHandler( this, this );
	m_pImpIDocHostShowUI = new CImpIDocHostShowUI( this, this );
	m_pImpAmbientIDispatch = new CImpAmbientIDispatch( this, this );
	m_pImpIPropertyNotifySink = new CImplPropertyNotifySink( this, this );
	m_pImpIOleControlSite = new  CImpIOleControlSite ( this, this );

	m_pTriEdDocEvtSink = new CTriEditEventSink ( m_pFR, DIID_HTMLDocumentEvents );
	m_pTriEdWndEvtSink = new CTriEditEventSink ( m_pFR, DIID_HTMLWindowEvents );

    if ( NULL == m_pImpIOleClientSite
		|| NULL == m_pImpIAdviseSink
        || NULL == m_pImpIOleIPSite
		|| NULL == m_pImpIOleDocumentSite
		|| NULL == m_pImpIDocHostUIHandler 
		|| NULL == m_pImpAmbientIDispatch
		|| NULL == m_pImpIPropertyNotifySink
		|| NULL == m_pImpIOleControlSite
		|| NULL == m_pTriEdDocEvtSink
		|| NULL == m_pImpIOleControlSite
		)
	{
		// releasing the site will delete any of the interface
		// implementations that did get allocated
        return E_OUTOFMEMORY;
	}


	// Create TriEdit
	hr = CoCreateInstance( CLSID_TriEditDocument, pUnk,								
			CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&m_pObj );

    if (SUCCEEDED(hr))
	{
		if (ppUnkTriEdit)
		{
			m_pObj->AddRef();
			*ppUnkTriEdit = m_pObj;
		}
	}
	else if ( REGDB_E_CLASSNOTREG == hr )
	{
		DllUnregisterServer ();
	}

// RJ - 2/26/98
// defer call ObjectInitialize() until control has been created
// so that props for IDHUIHandler::GetHostInfo can be set by host. ObjectInitialize
// (really SetClientSite results in IDHUIHandler::GetHostInfo being called
#if 0 
	hr = ObjectInitialize();
#endif

	return hr;
}


/*
 * CSite::HrObjectInitialize
 * (Protected)
 *
 * Purpose:
 *  Creates DocObject object and cache frequently used interfaces
 *
 * Return Value:
 *  HRESULT indicating success or failure
 */
HRESULT CSite::HrObjectInitialize()
{
    HRESULT         hr;

	_ASSERTE(m_pObj);

    if (NULL == m_pObj)
	{
        return E_UNEXPECTED;
	}

    // cache IOleObject
    if (FAILED(hr = m_pObj->QueryInterface( IID_IOleObject, (void **)&m_pIOleObject )))
		return hr;

	_ASSERTE(m_pIOleObject);

    // SetClientSite is critical for DocObjects
    m_pIOleObject->SetClientSite( m_pImpIOleClientSite );

	_ASSERTE(0 == m_dwOleObjectCookie);
    m_pIOleObject->Advise(m_pImpIAdviseSink, &m_dwOleObjectCookie);

	// cache IOleCommandTarget
    if (FAILED(hr = m_pObj->QueryInterface( IID_IOleCommandTarget, (void **) &m_pIOleCommandTarget)))
		return hr;

	_ASSERTE(m_pIOleCommandTarget);

	if (FAILED(hr = HrRegisterPropNotifySink(TRUE)))
		return hr;

	// Hook up the proxy frame to the Trident Document events
	if (FAILED(hr = m_pTriEdDocEvtSink->Advise ( m_pIOleObject )))
		return hr;

	CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2>piHtmlDoc ( m_pIOleObject );
	_ASSERTE ( piHtmlDoc );
	if ( piHtmlDoc )
	{
		CComPtr<IHTMLWindow2>	piHtmlWindow = NULL;
		hr = piHtmlDoc->get_parentWindow ( &piHtmlWindow );
		if ( SUCCEEDED ( hr ) )
		{
			hr = m_pTriEdWndEvtSink->Advise ( piHtmlWindow );
		}
	}
	if ( FAILED ( hr ) )
		return hr;

	// Attempt to create the IMultiLanguage2 object, avaialable only with IE5.
	// It's OK if this fails.
	CoCreateInstance ( CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2Correct, (void**)&m_piMLang );

	// Put the object in the running state
	OleRun( m_pIOleObject );

    return hr;
}



/*
 * CSite::Close
 *
 * Purpose:
 *  Possibly commits the storage, then releases it, afterwards
 *  frees alls the object pointers.
 *
 * Parameters:
 *  fCommit         BOOL indicating if we're to commit.
 *
 * Return Value:
 *  None
 */
void CSite::Close(BOOL fCommit)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pObj);

	hr = HrRegisterPropNotifySink(FALSE);

	_ASSERTE(SUCCEEDED(hr));

    if ( NULL != m_pIOleIPObject )
	{
        m_pIOleIPObject->InPlaceDeactivate();
	}

    ReleaseInterface( m_pIOleDocView );
	ReleaseInterface( m_pIOleCommandTarget );
	ReleaseInterface( m_piMLang );

    if ( NULL != m_pIOleObject )
    {
	    hr = m_pIOleObject->Unadvise(m_dwOleObjectCookie);
		_ASSERTE(SUCCEEDED(hr));

		m_pTriEdDocEvtSink->Unadvise ();
		m_pTriEdWndEvtSink->Unadvise ();

        m_pIOleObject->Close( fCommit ? OLECLOSE_SAVEIFDIRTY : OLECLOSE_NOSAVE );
        m_pIOleObject->SetClientSite( NULL );
        ReleaseInterface( m_pIOleObject );
    }

    ReleaseInterface( m_pObj );
}




/*
 * CSite::InitialActivate
 *
 * Purpose:
 *  Activates a verb on the object living in the site.
 *
 * Parameters:
 *  iVerb           LONG of the verb to execute.
 *  hWnd			HWND of hosting window
 *
 * Return Value:
 *  None
 */


void
CSite::InitialActivate(LONG iVerb, HWND hWnd)
{
	_ASSERTE(hWnd);

	m_hWnd = hWnd;
	Activate(iVerb);
}


void CSite::Activate(LONG iVerb)
{
    RECT rc = {0};

	// There is no window when we're being called to discard - (InPlaceDeactivate)
	if ( iVerb !=  OLEIVERB_DISCARDUNDOSTATE )
	{
		_ASSERTE(m_hWnd);
		GetClientRect(m_hWnd, &rc);
	}

    if (m_pIOleObject)
    {
        m_pIOleObject->DoVerb(iVerb, NULL, m_pImpIOleClientSite, -1, m_hWnd, &rc);
    }
}


/*
 * CSite::UpdateObjectRects
 *
 * Purpose:
 *  Informs the site that the client area window was resized and
 *  that the site needs to also tell the DocObject of the resize.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CSite::UpdateObjectRects( void )
{
    if ( NULL != m_pIOleDocView )
	{
		RECT    rc;
        
	    GetClientRect(m_hWnd, &rc);
		m_pIOleDocView->SetRect(&rc);
	}
}


void CSite::OnReadyStateChanged()
{
    HRESULT     hr = S_OK;
    VARIANT     Var;
    IDispatch * pDisp = NULL;
	CComDispatchDriver dispDriver;

    _ASSERTE(m_pObj);

    hr = m_pObj->QueryInterface(IID_IDispatch, (void **)&pDisp);

	_ASSERTE(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
	{	
		VariantInit(&Var);

		dispDriver = pDisp;

        if (SUCCEEDED(hr = dispDriver.GetProperty(DISPID_READYSTATE, &Var)))
		{
            // should be either I4 or I2
            _ASSERTE(Var.vt == VT_I4 || Var.vt == VT_I2);

            // we get the ready state so we can warn about sending while downloading
            GetFrame()->OnReadyStateChanged((READYSTATE) Var.lVal);
		}

		_ASSERTE(SUCCEEDED(hr));

        pDisp->Release();
	}
}


HRESULT 
CSite::HrRegisterPropNotifySink(BOOL fRegister)
{
    IConnectionPointContainer   *pCPContainer=0;
    IConnectionPoint            *pCP=0;
    HRESULT                     hr = S_OK;

	_ASSERTE(m_pObj);

    hr = m_pObj->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
    if (FAILED(hr))
        goto error;

    hr = pCPContainer->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
    if (FAILED(hr))
        goto error;

    if (fRegister)
	{
        _ASSERTE(m_dwPropNotifyCookie == 0);

        hr = pCP->Advise((IPropertyNotifySink *)this, &m_dwPropNotifyCookie);
        if (FAILED(hr))
            goto error;
	}
    else
	{
        if (m_dwPropNotifyCookie)
		{
            hr = pCP->Unadvise(m_dwPropNotifyCookie);
            if (FAILED(hr))
                goto error;
            m_dwPropNotifyCookie = 0;
		}
	}
error:
    ReleaseInterface(pCPContainer);
    ReleaseInterface(pCP);
    return hr;
}


HRESULT
CSite::HrSaveToStream(LPSTREAM pStream)
{
	HRESULT hr = S_OK;	
	CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> piPersistStreamInit(m_pObj);

	_ASSERTE(pStream);
	_ASSERTE(m_pObj);

	if (!piPersistStreamInit)
		return E_NOINTERFACE;

	if (FAILED(hr = piPersistStreamInit->Save(pStream, TRUE)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	// This can return an ASCII stream, even if we loaded Unicode into the control!
	hr = HrConvertStreamToUnicode ( pStream );

cleanup:
	return hr;
}


HRESULT
CSite::HrSaveToStreamAndFilter(LPSTREAM* ppStream, DWORD dwFilterFlags)
{
	HRESULT hr = S_OK;
	CComPtr<IStream> piStream;
	CComPtr<IStream> piFilteredStream;
	VARIANT_BOOL vbBrowse;

	_ASSERTE(ppStream);

	if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &piStream)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (FAILED(hr = HrSaveToStream(piStream)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	m_pFR->GetBrowseMode ( &vbBrowse );
	if ( vbBrowse )
	{
		piStream.p->AddRef ();
		piFilteredStream = piStream;
	}
	else
	{
		hr = HrFilter(FALSE, piStream, &piFilteredStream, dwFilterFlags);
	}
	if (FAILED(hr))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	*ppStream = piFilteredStream;
	(*ppStream)->AddRef();

cleanup:
	return hr;
}


HRESULT
CSite::HrSaveToFile(BSTR fileName, DWORD dwFilterFlags)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPTSTR pFileName = NULL;
	CComPtr<IStream> piStream;

	_ASSERTE(fileName);

	pFileName = OLE2T(fileName);

	_ASSERTE(pFileName);

	if (NULL == pFileName)
		return E_OUTOFMEMORY;

	_ASSERTE(fileName);

	if (FAILED(hr = HrSaveToStreamAndFilter(&piStream, dwFilterFlags)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}
	
	if (FAILED(hr = HrStreamToFile(piStream, pFileName)))
	{
		goto cleanup;
	}


cleanup:
	return hr;
}


HRESULT
CSite::HrSaveToBstr(BSTR* pBstr, DWORD dwFilterFlags)
{
	HRESULT hr = S_OK;
	CComPtr<IStream> piStream;

	_ASSERTE(pBstr);

	if (FAILED(hr = HrSaveToStreamAndFilter(&piStream, dwFilterFlags)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}
	
	if (FAILED(hr = HrStreamToBstr(piStream, pBstr)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}


cleanup:
	return hr;
}


HRESULT
CSite::HrIsDirtyIPersistStreamInit(BOOL& bVal)
{
	HRESULT hr = S_OK;
	HRESULT hrpsi = S_FALSE;
	CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> piPersistStreamInit(m_pObj);

	_ASSERTE(m_pObj);

	bVal = FALSE;

	if (!piPersistStreamInit)
		return E_NOINTERFACE;

	if (FAILED(hrpsi = piPersistStreamInit->IsDirty()))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	(S_OK == hrpsi) ? bVal = TRUE : bVal = FALSE;

cleanup:
	return hr;

}


HRESULT CSite::GetContainer ( LPOLECONTAINER* ppContainer )
{
	return m_pFR->GetContainer ( ppContainer );
}



/*
 * CImpIOleControlSite::QueryInterface
 * CImpIOleControlSite::AddRef
 * CImpIOleControlSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleControlSite object.
 */

CImpIOleControlSite::CImpIOleControlSite( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleControlSite::~CImpIOleControlSite( void )
{
}


STDMETHODIMP CImpIOleControlSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleControlSite::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleControlSite::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\triedtctlid.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __TRIEDTCTLID_H_
#define __TRIEDTCTLID_H_


// methods and properties
#define DISPID_LOADDOCUMENT				1
#define DISPID_EXECCOMMAND				2
#define DISPID_QUERYSTATUS				3
#define DISPID_SAVEDOCUMENT				4
#define DISPID_SETCONTEXTMENU			5

#define DISPID_DOCUMENT					6
#define DISPID_ACTIVATEAPPLETS			7
#define DISPID_ACTIVATEACTIVEXCONTROLS	8
#define DISPID_ACTIVATEDTCS				9	
//#define DISPID_OVERWRITEMODE			10
#define DISPID_SHOWDETAILS				11
#define DISPID_SHOWBORDERS				12
#define DISPID_DHTMLEDITAPPEARANCE		13
#define DISPID_DHTMLEDITSCROLLBARS		14
#define DISPID_SCROLLBARAPPEARANCE		15
#define DISPID_SOURCECODEPRESERVATION	16
#define DISPID_DOCUMENTHTML				17
#define DISPID_ABSOLUTEDROPMODE			18
#define DISPID_SNAPTOGRIDX				19
#define DISPID_SNAPTOGRIDY				20
#define DISPID_SNAPTOGRID				21
#define DISPID_ISDIRTY					22
#define DISPID_CURRENTDOCUMENTPATH		23
#define DISPID_BASEURL					24
#define DISPID_DOCUMENTTITLE			25
#define DISPID_BROWSEMODE				26
#define DISPID_NEWDOCUMENT				27
#define DISPID_PRINT					28
#define DISPID_LOADURL					29
#define DISPID_USEDIVONCR				30
#define DISPID_FILTERSRCCODE			31
#define DISPID_REFRESHDOC				32
#define DISPID_BUSY						33

// events
#define	DISPID_DOCUMENTCOMPLETE			1
#define	DISPID_DISPLAYCHANGED			2
#define	DISPID_SHOWCONTEXTMENU			3
#define	DISPID_CONTEXTMENUACTION		4
#define DISPID_ONMOUSEDOWN				5
#define DISPID_ONMOUSEMOVE				6
#define DISPID_ONMOUSEUP				7
#define DISPID_ONMOUSEOUT				8
#define DISPID_ONMOUSEOVER				9
#define DISPID_ONCLICK					10
#define DISPID_ONDBLCLICK				11
#define DISPID_ONKEYDOWN				12
#define DISPID_ONKEYPRESS				13
#define DISPID_ONKEYUP					14
#define DISPID_ONBLUR					15
#define DISPID_ONREADYSTATECHANGE		16


#define DISPID_TABLEPARAMS_NUMROWS		1
#define DISPID_TABLEPARAMS_NUMCOLS		2
#define DISPID_TABLEPARAMS_TABLEATTRS	3
#define DISPID_TABLEPARAMS_CELLATTRS	4
#define DISPID_TABLEPARAMS_CAPTION		5

#define DISPID_NAMESPARAM_NAMES	1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\proxyframe.cpp ===
//	Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//	Notes on m_bfModeSwitched and m_bfReloadAttempted.
//	IE5 bug 52818 was punted; pages containing IFrames don't refresh when changing
//	browse/edit modes, because the stream is seen as dirty (because the IFrame
//	considers itself dirty.)  In response, we set m_bfModeSwitched when changing mode,
//	m_bfReloadAttempted when and ATTEMPT is made to reload the page, and check for BOTH
//	in OnReadyStateChanged.  If the mode was changed but the page wasn't reloaded,
//	we have to reload it manually.


#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"
#include <TRIEDIID.h>
#include <mshtmdid.h>
#include "dispexa.h"
#include <wchar.h>
#include <string.h>


// HTML to initialize Trident with if the host didn't supply any
// The <P>&nbsp;</P> works around a nasty Trident bug.
// Change: now there is one with paragraphs, one with DIVs.
//
static WCHAR* g_initialHTMLwithP = \
L"<HTML>\r\n\
<HEAD>\r\n\
<META NAME=\"GENERATOR\" Content=\"Microsoft DHTML Editing Control\">\r\n\
<TITLE></TITLE>\r\n\
</HEAD>\r\n\
<BODY>\r\n\
<P>&nbsp;</P>\r\n\
</BODY>\r\n\
</HTML>\r\n";

static WCHAR* g_initialHTMLwithDIV = \
L"<HTML>\r\n\
<HEAD>\r\n\
<META NAME=\"GENERATOR\" Content=\"Microsoft DHTML Editing Control\">\r\n\
<TITLE></TITLE>\r\n\
</HEAD>\r\n\
<BODY>\r\n\
<DIV>&nbsp;</DIV>\r\n\
</BODY>\r\n\
</HTML>\r\n";


//	Text, numbers and constants used to construct a unique-per-process protocol ID
//
static WCHAR* g_wszProtocolPrefix = L"DHTMLEd";
static int	s_iProtocolSuffix = 0;
#define MAX_PROTOCOL_SUFFIX	999999


// Name of the Title property which we get from the IHtmlDocument2 interface.
static WCHAR* 	g_wszHTMLTitlePropName = L"title";


//	Maps private DHTMLEdit command IDs to Triedit command IDs.
//	The third field is true if the command includes an out parameter.
//
static CommandMap cmdMap[] = 
{
	{DECMD_BOLD,				IDM_TRIED_BOLD,				FALSE},
	{DECMD_COPY,				IDM_TRIED_COPY,				FALSE},
	{DECMD_CUT,					IDM_TRIED_CUT,				FALSE},
	{DECMD_DELETE,				IDM_TRIED_DELETE,			FALSE},
	{DECMD_DELETECELLS,			IDM_TRIED_DELETECELLS,		FALSE},
	{DECMD_DELETECOLS,			IDM_TRIED_DELETECOLS,		FALSE},
	{DECMD_DELETEROWS,			IDM_TRIED_DELETEROWS,		FALSE},
	{DECMD_FINDTEXT,			IDM_TRIED_FIND,				FALSE},
	{DECMD_FONT,				IDM_TRIED_FONT,				FALSE},
	{DECMD_GETBACKCOLOR,		IDM_TRIED_BACKCOLOR,		TRUE},
	{DECMD_GETBLOCKFMT,			IDM_TRIED_BLOCKFMT,			TRUE},
	{DECMD_GETBLOCKFMTNAMES,	IDM_TRIED_GETBLOCKFMTS,		TRUE},
	{DECMD_GETFONTNAME,			IDM_TRIED_FONTNAME,			TRUE},
	{DECMD_GETFONTSIZE,			IDM_TRIED_FONTSIZE,			TRUE},
	{DECMD_GETFORECOLOR,		IDM_TRIED_FORECOLOR,		TRUE},
	{DECMD_HYPERLINK,			IDM_TRIED_HYPERLINK,		FALSE},
	{DECMD_IMAGE,				IDM_TRIED_IMAGE,			FALSE},
	{DECMD_INDENT,				IDM_TRIED_INDENT,			FALSE},
	{DECMD_INSERTCELL,			IDM_TRIED_INSERTCELL,		FALSE},
	{DECMD_INSERTCOL,			IDM_TRIED_INSERTCOL,		FALSE},
	{DECMD_INSERTROW,			IDM_TRIED_INSERTROW,		FALSE},
	{DECMD_INSERTTABLE,			IDM_TRIED_INSERTTABLE,		FALSE},
	{DECMD_ITALIC,				IDM_TRIED_ITALIC,			FALSE},
	{DECMD_JUSTIFYLEFT,			IDM_TRIED_JUSTIFYLEFT,		FALSE},
	{DECMD_JUSTIFYRIGHT,		IDM_TRIED_JUSTIFYRIGHT,		FALSE},
	{DECMD_JUSTIFYCENTER,		IDM_TRIED_JUSTIFYCENTER,	FALSE},
	{DECMD_LOCK_ELEMENT,		IDM_TRIED_LOCK_ELEMENT,		FALSE},
	{DECMD_MAKE_ABSOLUTE,		IDM_TRIED_MAKE_ABSOLUTE,	FALSE},
	{DECMD_MERGECELLS,			IDM_TRIED_MERGECELLS,		FALSE},
	{DECMD_ORDERLIST,			IDM_TRIED_ORDERLIST,		FALSE},
	{DECMD_OUTDENT,				IDM_TRIED_OUTDENT,			FALSE},
	{DECMD_PASTE,				IDM_TRIED_PASTE,			FALSE},
	{DECMD_REDO,				IDM_TRIED_REDO,				FALSE},
	{DECMD_REMOVEFORMAT,		IDM_TRIED_REMOVEFORMAT,		FALSE},
	{DECMD_SELECTALL,			IDM_TRIED_SELECTALL,		FALSE},
	{DECMD_SEND_BACKWARD,		IDM_TRIED_SEND_BACKWARD,	FALSE},
	{DECMD_BRING_FORWARD,		IDM_TRIED_SEND_FORWARD,		FALSE},
	{DECMD_SEND_BELOW_TEXT,		IDM_TRIED_SEND_BEHIND_1D,	FALSE},
	{DECMD_BRING_ABOVE_TEXT,	IDM_TRIED_SEND_FRONT_1D,	FALSE},
	{DECMD_SEND_TO_BACK,		IDM_TRIED_SEND_TO_BACK,		FALSE},
	{DECMD_BRING_TO_FRONT,		IDM_TRIED_SEND_TO_FRONT,	FALSE},
	{DECMD_SETBACKCOLOR,		IDM_TRIED_BACKCOLOR,		FALSE},
	{DECMD_SETBLOCKFMT,			IDM_TRIED_BLOCKFMT,			FALSE},
	{DECMD_SETFONTNAME,			IDM_TRIED_FONTNAME,			FALSE},
	{DECMD_SETFONTSIZE,			IDM_TRIED_FONTSIZE,			FALSE},
	{DECMD_SETFORECOLOR,		IDM_TRIED_FORECOLOR,		FALSE},
	{DECMD_SPLITCELL,			IDM_TRIED_SPLITCELL,		FALSE},
	{DECMD_UNDERLINE,			IDM_TRIED_UNDERLINE,		FALSE},
	{DECMD_UNDO,				IDM_TRIED_UNDO,				FALSE},
	{DECMD_UNLINK,				IDM_TRIED_UNLINK,			FALSE},
	{DECMD_UNORDERLIST,			IDM_TRIED_UNORDERLIST,		FALSE},
	{DECMD_PROPERTIES,			IDM_TRIED_DOVERB,			FALSE}
};



CProxyFrame::CProxyFrame(CDHTMLSafe* pCtl)
{
	SAFEARRAYBOUND rgsabound[1] = {0};

	_ASSERTE(pCtl);

	m_cRef = 1;

	m_pUnkTriEdit = NULL;
	m_hWndObj = NULL;
	m_pIOleIPActiveObject = NULL;
	m_pSite = NULL;
	m_pCtl = pCtl;

	m_fCreated = FALSE;
	m_fActivated = FALSE;
	m_state = ESTATE_NOTCREATED;
	m_readyState = READYSTATE_UNINITIALIZED;
	m_dwFilterFlags = m_dwFilterOutFlags = filterAll;

	m_fActivateApplets = FALSE;
	m_fActivateControls = FALSE;
	m_fActivateDTCs = TRUE;
	m_fShowAllTags = FALSE;
	m_fShowBorders = FALSE;

	m_fDialogEditing = TRUE;
	m_fDisplay3D = TRUE;
	m_fScrollbars = TRUE;
	m_fDisplayFlatScrollbars = FALSE;
	m_fContextMenu = TRUE;

	m_fPreserveSource = TRUE;

	m_fAbsoluteDropMode = FALSE;
	m_fSnapToGrid = FALSE;
	m_ulSnapToGridX = 50;
	m_ulSnapToGridY = 50;

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = 0;

	m_pMenuStrings = NULL;	
	m_pMenuStates = NULL;	

	m_vbBrowseMode = VARIANT_FALSE;

	m_vbUseDivOnCr = VARIANT_FALSE;
	m_bfIsLoading  = FALSE;
	m_bfBaseURLFromBASETag = FALSE;
	m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;
	m_bstrInitialDoc.Empty ();

	m_bstrCurDocPath.Empty ();

	wcscpy ( m_wszProtocol, g_wszProtocolPrefix );
	WCHAR wszSuffix[8];
	_itow ( s_iProtocolSuffix++, wszSuffix, 10 );
	if ( MAX_PROTOCOL_SUFFIX <= s_iProtocolSuffix )
	{
		s_iProtocolSuffix = 0;	// Roll over.
	}
	wcscat ( m_wszProtocol, wszSuffix );
	wcscpy ( m_wszProtocolPrefix, m_wszProtocol );
	wcscat ( m_wszProtocolPrefix, L":" );

	m_pProtInfo = NULL;
	m_bfIsURL   = FALSE;
	m_bstrBaseURL = L"";
	m_hwndRestoreFocus = NULL;

#ifdef LATE_BIND_URLMON_WININET
	m_hUlrMon					= NULL;
	m_hWinINet					= NULL;
	m_pfnCoInternetCombineUrl	= NULL;
	m_pfnCoInternetParseUrl		= NULL;
	m_pfnCreateURLMoniker		= NULL;
	m_pfnCoInternetGetSession	= NULL;
	m_pfnURLOpenBlockingStream	= NULL;

	m_pfnDeleteUrlCacheEntry	= NULL;
	m_pfnInternetCreateUrl		= NULL;
	m_pfnInternetCrackUrl		= NULL;
#endif // LATE_BIND_URLMON_WININET

	m_bfModeSwitched	= FALSE;
	m_bfReloadAttempted	= FALSE;
	m_bfSFSRedirect		= FALSE;
}

CProxyFrame::~CProxyFrame()
{
	_ASSERTE(FALSE == m_fCreated);
	_ASSERTE(FALSE == m_fActivated);
	_ASSERTE( m_cRef == 0 );

	if (m_pMenuStrings)
	{
		SafeArrayDestroy(m_pMenuStrings);
		m_pMenuStrings = NULL;
	}

	if (m_pMenuStates)
	{
		SafeArrayDestroy(m_pMenuStates);
		m_pMenuStates = NULL;
	}

	// This should never happen: SetActiveObject should take care of it.
	_ASSERTE ( NULL == m_pIOleIPActiveObject );
	if (m_pIOleIPActiveObject)
	{
		m_pIOleIPActiveObject->Release();
		m_pIOleIPActiveObject = NULL;
	}

	UnRegisterPluggableProtocol ();
#ifdef LATE_BIND_URLMON_WININET
	DynUnloadLibraries ();
#endif // LATE_BIND_URLMON_WININET
}


//	Create the TriEdit object and host it.
//	Clean up and return an error if there was any problem.
//
HRESULT
CProxyFrame::Init(IUnknown* pUnk, IUnknown** ppUnkTriEdit)
{
	HRESULT hr = S_OK;

#ifdef LATE_BIND_URLMON_WININET
	if ( ! DynLoadLibraries () )
	{
		return E_FAIL;
	}
#endif // LATE_BIND_URLMON_WININET

	hr = RegisterPluggableProtocol ();
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	_ASSERTE(NULL == m_pSite);
	_ASSERTE(GetState() == ESTATE_NOTCREATED);

	InitializeDocString ();

	if (m_pSite)
		return E_UNEXPECTED;

	if (GetState() != ESTATE_NOTCREATED)
		return E_UNEXPECTED;

	// Create and initialize the site for TriEdit
	m_pSite = new CSite(this);

    if (NULL == m_pSite)
	{
        return E_OUTOFMEMORY;
	}

    m_pSite->AddRef();  // So we can free with Release

	// Ask the site to create TriEdit
    if (SUCCEEDED(hr = m_pSite->HrCreate(pUnk, &m_pUnkTriEdit)))
	{
		ChangeState(ESTATE_CREATED);
		m_fCreated = TRUE;
		if (ppUnkTriEdit)
		{
			m_pUnkTriEdit->AddRef();
			*ppUnkTriEdit = m_pUnkTriEdit;
		}
	}
	else
	{
		m_pSite->Release();
		m_pSite = NULL;
	}

    return hr;        
}


//	Destroy the site and the TriEdit object.
//
HRESULT
CProxyFrame::Close()
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pUnkTriEdit);
	_ASSERTE(m_pSite);
	_ASSERTE(GetState() != ESTATE_NOTCREATED);

	m_bstrCurDocPath.Empty ();

	// triedit must be created
	// any state from created to activated is ok
	if (GetState() == ESTATE_NOTCREATED)
		return E_UNEXPECTED;

	if (m_fActivated)
	{
		hr = HrExecCommand(&CGID_MSHTML, IDM_STOP, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
		_ASSERTE(SUCCEEDED(hr));
	}

	ChangeState(ESTATE_NOTCREATED);
	m_fCreated = FALSE;
	m_fActivated = FALSE;
    if (m_pSite != NULL)
	{
		CSite* pSite = m_pSite; // prevents reentry;
		m_pSite = NULL;

		pSite->Close(FALSE);
		ReleaseInterface(pSite)
		pSite = NULL;
	}

	if (m_pUnkTriEdit != NULL)
	{
		LPUNKNOWN pUnkTriEdit = m_pUnkTriEdit;
		m_pUnkTriEdit = NULL;

		ReleaseInterface(pUnkTriEdit);
		pUnkTriEdit = NULL;
	}

	m_hwndRestoreFocus = NULL;

	return S_OK;
}


//	Determine which string constant to use and return a pointer to it.
//
WCHAR* CProxyFrame::GetInitialHTML ()
{
	if ( m_vbUseDivOnCr )
	{
		return g_initialHTMLwithDIV;
	}
	else
	{
		return g_initialHTMLwithP;
	}
}


//	Perform these steps before loading TriEdit's contents
//
HRESULT
CProxyFrame::PreActivate()
{
	HRESULT hr = S_OK;
	_ASSERTE(m_pSite);
	_ASSERTE(m_pCtl);

	_ASSERTE(ESTATE_CREATED == GetState());

	if (GetState() != ESTATE_CREATED)
		return E_UNEXPECTED;


	if (FAILED(hr = m_pSite->HrObjectInitialize()))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	m_fActivated = TRUE;
	ChangeState(ESTATE_PREACTIVATING);

	if (FAILED(hr = HrSetRuntimeProperties()))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	ChangeState(ESTATE_ACTIVATING);

error:

	return hr;
}


void
CProxyFrame::UIDeactivate()
{
	// This was m_pSite->GetIPObject()->UIDeactivate(),
	// but the QA teams VB app using this version of the control crashed
	// with a NULL pointer dereference.

	if ( NULL != m_pSite )
	{
		LPOLEINPLACEOBJECT pipObj = m_pSite->GetIPObject();
		if ( NULL != pipObj )
		{
			pipObj->UIDeactivate();
		}
	}
}

//	Perform these steps after loading TriEdits contents to go UI active.
//
HRESULT
CProxyFrame::Activate()
{
    HRESULT hr = S_OK;

    _ASSERTE(m_pSite);
    _ASSERTE(m_pCtl);
    _ASSERTE(m_pCtl->m_hWndCD);

    _ASSERTE(GetState() == ESTATE_ACTIVATING);

    if (GetState() != ESTATE_ACTIVATING)
        return E_UNEXPECTED;

    // UI-activate the control
    if ( ! m_pCtl->m_bUIActive )
    {
        // Used to be UIActivate, until MohanB fixed OnSetFocus and activation/deactivation linkage.
        m_pCtl->DoVerbInPlaceActivate ( NULL, NULL );
    }

    // activate Trident with "Show"
    m_pSite->InitialActivate(OLEIVERB_SHOW, m_pCtl->m_hWndCD);

    ChangeState(ESTATE_ACTIVATED);

    // This may have been deferred, because the site's command target did not yet exist...
    SetBrowseMode ( m_vbBrowseMode );

    return hr;
}


//	Load and activate the control with a minimal, empty page.
//
HRESULT
CProxyFrame::LoadInitialDoc()
{
	HRESULT hr = S_OK;

	_ASSERTE(GetState() == ESTATE_CREATED);

	if (GetState() != ESTATE_CREATED)
		return E_UNEXPECTED;
	
	if (FAILED(hr = PreActivate()))
		goto error;

	if (FAILED(hr = LoadBSTRDeferred ( m_bstrInitialDoc )))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = Activate()))
		goto error;

error:

	return hr;
}


// Before getting or setting a property or calling a method on the docobject,
// assure that it's been properly activated.
//
void CProxyFrame::AssureActivated ()
{
	if ( ! m_fActivated )
	{
		if ( m_pCtl->IsUserMode() )
		{
			if ( !m_pCtl->m_bInPlaceActive )
			{
				m_pCtl->DoVerbInPlaceActivate ( NULL, NULL );
			}
			LoadInitialDoc ();
		}
	}
}


//	Loading MSHTML shifts the focus to its document window.
//	This is not desirable in a control.  Experimentation has demonstrated
//	that the focus shifts between various QIs from MSHTML (probably in response
//	to posted messages.)  There is no routine in DHTMLEdit which enters with the	
//	focus outside the control and exits with the focus within the control.
//	Therefore, a member variable is used to preserve the appropriate focus
//	across calls to OnReadyStateChanged, which are called in response to events
//	fired by the control.  m_hwndRestoreFocus is used to preserve the appropriate
//	window to receive the focus.  Note that NULL may be appropriate, but is not honored.
//	If no window had focus, the document will gain focus.
//
void 
CProxyFrame::OnReadyStateChanged(READYSTATE readyState)
{
	_ASSERTE(m_pCtl);

	m_readyState = readyState;

	switch (m_readyState)
	{	
	case READYSTATE_UNINITIALIZED:
		{
			m_hwndRestoreFocus = NULL;
		}
		break;

	case READYSTATE_LOADING:
		{
			m_hwndRestoreFocus = ::GetFocus ();
		}
		break;
		
	case READYSTATE_LOADED:
		{
		}
		break;

	case READYSTATE_INTERACTIVE:
		{
			if ( NULL != m_hwndRestoreFocus )
			{
				_ASSERTE ( ::IsWindow ( m_hwndRestoreFocus ) );
				if ( ::IsWindow ( m_hwndRestoreFocus ) )
				{
					::SetFocus ( m_hwndRestoreFocus );
				}
			}

			// See if we failed to get a refresh on a mode change.  This happens if
			// there are IFrames on the page, perhaps in other cases as well.
			if ( m_bfModeSwitched && !m_bfReloadAttempted )
			{
				HRESULT	hr	= S_OK;

				CComPtr<IMoniker> srpMoniker;
				CComPtr<IBindCtx> srpBindCtx;
				CComQIPtr<IPersistMoniker, &IID_IPersistMoniker> srpPM (m_pUnkTriEdit);
				_ASSERTE ( srpPM );

				if ( srpPM )
				{
					CComBSTR	bstrProtocol = m_wszProtocolPrefix;

#ifdef LATE_BIND_URLMON_WININET
					_ASSERTE ( m_pfnCreateURLMoniker );
					hr = (*m_pfnCreateURLMoniker)( NULL, bstrProtocol, &srpMoniker );
#else
					hr = CreateURLMoniker ( NULL, bstrProtocol, &srpMoniker );
#endif // LATE_BIND_URLMON_WININET

					_ASSERTE ( SUCCEEDED( hr ) );
					if ( SUCCEEDED ( hr ) )
					{
						hr = ::CreateBindCtx(NULL, &srpBindCtx);
						_ASSERTE ( SUCCEEDED( hr ) );
						if ( SUCCEEDED ( hr ) )
						{
							hr = srpPM->Load(FALSE, srpMoniker,  srpBindCtx, STGM_READ);
						}
					}
				}
			}
			m_bfModeSwitched	= FALSE;
			m_bfReloadAttempted	= FALSE;
		}
		break;

	case READYSTATE_COMPLETE:
		{
			HRESULT hr		= S_OK;

			m_hwndRestoreFocus = NULL;
			if ( ! m_vbBrowseMode )
			{
				hr = HrSetDocLoadedProperties();
				_ASSERTE(SUCCEEDED(hr));
			}

			_ASSERTE ( m_pCtl->m_hWnd );
			_ASSERTE ( ::IsWindow ( m_pCtl->m_hWnd ) );

			if ( m_bfPreserveDirtyFlagAcrossBrowseMode && !m_vbBrowseMode )
			{
				m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;
				SetDirtyFlag ( TRUE );
			}
			// Post a user message to fire the DocumentComplete event.
			// Otherwise, calling things like LoadURL from DocumentComplete behaves strangely.
			::PostMessage ( m_pCtl->m_hWnd, DOCUMENT_COMPETE_MESSAGE, DOCUMENT_COMPETE_SIGNATURE, 0L );
			HrSetRuntimeProperties ();
			//m_bfIsLoading = FALSE;	// This has been moved the the DOCUMENT_COMPETE_MESSAGE handler.
			SetBaseURLFromBaseHref ();	// Must be called after clearing m_bfIsLoading
		}
		break;
	}
}


/*
 * IUnknown implementation
 */
/*
 * CProxyFrame::QueryInterface
 * CProxyFrame::AddRef
 * CProxyFrame::Release
 */
STDMETHODIMP CProxyFrame::QueryInterface( REFIID riid, void **ppv )
{
    /*
     * We provide IOleInPlaceFrame and IOleCommandTarget
	 *   interfaces here for the ActiveX Document hosting
	 */
    *ppv = NULL;

    if ( IID_IUnknown == riid || IID_IOleInPlaceUIWindow == riid
        || IID_IOleWindow == riid || IID_IOleInPlaceFrame == riid )
	{
        *ppv = static_cast<IOleInPlaceFrame *>(this);
	}

	else if ( IID_IOleCommandTarget == riid )
	{
        *ppv = static_cast<IOleCommandTarget *>(this);
	}
	else if ( IID_IBindStatusCallback == riid )
	{
        *ppv = static_cast<IBindStatusCallback *>(this);
	}
	else if ( IID_IAuthenticate == riid )
	{
        *ppv = static_cast<IAuthenticate *>(this);
	}
	else if ( IID_IServiceProvider == riid )
	{
		// Ask the control for a security manager IF in edit mode:
		if ( ! m_vbBrowseMode )
		{
			return m_pCtl->GetUnknown()->QueryInterface ( riid, ppv );
		}
	}

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CProxyFrame::AddRef( void )
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProxyFrame::Release( void )
{
    //Nothing special happening here-- life if user-controlled.
	// Debug check to see we don't fall below 0
	_ASSERTE( m_cRef != 0 );

	ULONG ulRefCount = --m_cRef;
	if ( 0 == ulRefCount )
	{
		delete this;	// Do not refer to any member variables after this.
	}
    return ulRefCount;
}


/*
 * IOleInPlaceFrame implementation
 */
/*
 * CProxyFrame::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object
 *  on which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, E_FAIL if there is no
 *                  window.
 */
STDMETHODIMP CProxyFrame::GetWindow( HWND* phWnd )
{
	if ( m_pCtl != NULL )
	{
		*phWnd = m_pCtl->m_hWnd;
	}
	return S_OK;
}



/*
 * CProxyFrame::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         S_OK
 */
STDMETHODIMP CProxyFrame::ContextSensitiveHelp( BOOL /*fEnterMode*/ )
{
    return S_OK;
}



/*
 * CProxyFrame::GetBorder
 *
 * Purpose:
 *  Returns the rectangle in which the container is willing to
 *  negotiate about an object's adornments.
 *
 * Parameters:
 *  prcBorder       LPRECT in which to store the rectangle.
 *
 * Return Value:
 *  HRESULT         S_OK if all is well, INPLACE_E_NOTOOLSPACE
 *                  if there is no negotiable space.
 */
STDMETHODIMP CProxyFrame::GetBorder( LPRECT prcBorder )
{
    if ( NULL == prcBorder )
	{
        return E_INVALIDARG;
	}

    //We return all the client area space
    m_pCtl->GetClientRect( prcBorder );
    return S_OK;
}


/*
 * CProxyFrame::RequestBorderSpace
 *
 * Purpose:
 *  Asks the container if it can surrender the amount of space
 *  in pBW that the object would like for it's adornments.  The
 *  container does nothing but validate the spaces on this call.
 *
 * Parameters:
 *  pBW             LPCBORDERWIDTHS containing the requested space.
 *                  The values are the amount of space requested
 *                  from each side of the relevant window.
 *
 * Return Value:
 *  HRESULT         S_OK if we can give up space,
 *                  INPLACE_E_NOTOOLSPACE otherwise.
 */
STDMETHODIMP CProxyFrame::RequestBorderSpace( LPCBORDERWIDTHS /*pBW*/ )
{
    // We have no border space restrictions
    return S_OK;
}


/*
 * CProxyFrame::SetBorderSpace
 *
 * Purpose:
 *  Called when the object now officially requests that the
 *  container surrender border space it previously allowed
 *  in RequestBorderSpace.  The container should resize windows
 *  appropriately to surrender this space.
 *
 * Parameters:
 *  pBW             LPCBORDERWIDTHS containing the amount of space
 *                  from each side of the relevant window that the
 *                  object is now reserving.
 *
 * Return Value:
 *  HRESULT         S_OK
 */
STDMETHODIMP CProxyFrame::SetBorderSpace( LPCBORDERWIDTHS /*pBW*/ )
{
	// We turn off the MSHTML.DLL UI so we ignore all of this.

    return S_OK;
}




/*
 * CProxyFrame::SetActiveObject
 *
 * Purpose:
 *  Provides the container with the object's IOleInPlaceActiveObject
 *  pointer
 *
 * Parameters:
 *  pIIPActiveObj   LPOLEINPLACEACTIVEOBJECT of interest.
 *  pszObj          LPCOLESTR naming the object.  Not used.
 *
 * Return Value:
 *  HRESULT         S_OK
 */
STDMETHODIMP CProxyFrame::SetActiveObject( LPOLEINPLACEACTIVEOBJECT pIIPActiveObj,
											LPCOLESTR /*pszObj*/)
{
	// If we already have an active Object then release it.
    if ( NULL != m_pIOleIPActiveObject )
	{
        m_pIOleIPActiveObject->Release();
	}

    //NULLs m_pIOleIPActiveObject if pIIPActiveObj is NULL
    m_pIOleIPActiveObject = pIIPActiveObj;

    if ( NULL != m_pIOleIPActiveObject )
	{
        m_pIOleIPActiveObject->AddRef();
		m_pIOleIPActiveObject->GetWindow( &m_hWndObj );
	}
    return S_OK;
}



/*
 * CProxyFrame::InsertMenus
 *
 * Purpose:
 *  Instructs the container to place its in-place menu items where
 *  necessary in the given menu and to fill in elements 0, 2, and 4
 *  of the OLEMENUGROUPWIDTHS array to indicate how many top-level
 *  items are in each group.
 *
 * Parameters:
 *  hMenu           HMENU in which to add popups.
 *  pMGW            LPOLEMENUGROUPWIDTHS in which to store the
 *                  width of each container menu group.
 *
 * Return Value:
 *  HRESULT         E_NOTIMPL
 */
STDMETHODIMP CProxyFrame::InsertMenus( HMENU /*hMenu*/, LPOLEMENUGROUPWIDTHS /*pMGW*/ )
{
	// We've turned off the MSHTML.DLL Menus so we don't expect any merging to go on!
	return E_NOTIMPL;
}


/*
 * CProxyFrame::SetMenu
 *
 * Purpose:
 *  Instructs the container to replace whatever menu it's currently
 *  using with the given menu and to call OleSetMenuDescritor so OLE
 *  knows to whom to dispatch messages.
 *
 * Parameters:
 *  hMenu           HMENU to show.
 *  hOLEMenu        HOLEMENU to the menu descriptor.
 *  hWndObj         HWND of the active object to which messages are
 *                  dispatched.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CProxyFrame::SetMenu( HMENU /*hMenu*/, HOLEMENU /*hOLEMenu*/, HWND /*hWndObj*/ )
{
	// We've turned off the MSHTML.DLL Menus so we don't expect any merging to go on!
	return E_NOTIMPL;
}



/*
 * CProxyFrame::RemoveMenus
 *
 * Purpose:
 *  Asks the container to remove any menus it put into hMenu in
 *  InsertMenus.
 *
 * Parameters:
 *  hMenu           HMENU from which to remove the container's
 *                  items.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CProxyFrame::RemoveMenus( HMENU /*hMenu*/ )
{
	// We've turned off the MSHTML.DLL Menus so we don't expect any merging to go on!
	return E_NOTIMPL;
}


/*
 * CProxyFrame::SetStatusText
 *
 * Purpose:
 *  Asks the container to place some text in a status line, if one
 *  exists.  If the container does not have a status line it
 *  should return E_FAIL here in which case the object could
 *  display its own.
 *
 * Parameters:
 *  pszText         LPCOLESTR to display.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, S_TRUNCATED if not all
 *                  of the text could be displayed, or E_FAIL if
 *                  the container has no status line.
 */
STDMETHODIMP CProxyFrame::SetStatusText( LPCOLESTR /*pszText*/ )
{
    return S_OK;
}



/*
 * CProxyFrame::EnableModeless
 *
 * Purpose:
 *  Instructs the container to show or hide any modeless popup
 *  windows that it may be using.
 *
 * Parameters:
 *  fEnable         BOOL indicating to enable/show the windows
 *                  (TRUE) or to hide them (FALSE).
 *
 * Return Value:
 *  HRESULT         S_OK
 */

STDMETHODIMP CProxyFrame::EnableModeless( BOOL /*fEnable*/ )
{
    return S_OK;
}


/*
 * CProxyFrame::TranslateAccelerator
 *
 * Purpose:
 *  When dealing with an in-place object from an EXE server, this
 *  is called to give the container a chance to process accelerators
 *  after the server has looked at the message.
 *
 * Parameters:
 *  pMSG            LPMSG for the container to examine.
 *  wID             WORD the identifier in the container's
 *                  accelerator table (from IOleInPlaceSite
 *                  ::GetWindowContext) for this message (OLE does
 *                  some translation before calling).
 *
 * Return Value:
 *  HRESULT         NOERROR if the keystroke was used,
 *                  S_FALSE otherwise.
 */
STDMETHODIMP CProxyFrame::TranslateAccelerator( LPMSG /*pMSG*/, WORD /*wID*/ )
{
    return S_FALSE;
}


/*
 * IOleCommandTarget::QueryStatus
 */
STDMETHODIMP CProxyFrame::QueryStatus( const GUID* pguidCmdGroup, ULONG cCmds,
				OLECMD* prgCmds, OLECMDTEXT* pCmdText )
{
    if ( pguidCmdGroup != NULL )
	{
		// It's a nonstandard group!!
        return OLECMDERR_E_UNKNOWNGROUP;
	}

    MSOCMD*     pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // By default command text is NOT SUPPORTED.
    if ( pCmdText && ( pCmdText->cmdtextf != OLECMDTEXTF_NONE ) )
	{
        pCmdText->cwActual = 0;
	}

    // Loop through each command in the array, setting the status of each.
    for ( pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++ )
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        switch ( pCmd->cmdID )
        {
			case OLECMDID_UPDATECOMMANDS:
				pCmd->cmdf = OLECMDF_SUPPORTED;
				break;

			case OLECMDID_NEW:
			case OLECMDID_OPEN:
			case OLECMDID_SAVE:
				pCmd->cmdf = (MSOCMDF_SUPPORTED | MSOCMDF_ENABLED);
				break;
        }
    }

    return (hr);
}


/*
 * IOleCommandTarget::Exec
 */

STDMETHODIMP CProxyFrame::Exec( const GUID* pguidCmdGroup, DWORD nCmdID,
    DWORD /*nCmdexecopt*/, VARIANTARG* /*pvaIn*/, VARIANTARG* /*pvaOut*/ )
{
    HRESULT hr = S_OK;

    if ( pguidCmdGroup == NULL )
    {
        switch (nCmdID)
        {

			case OLECMDID_UPDATECOMMANDS:
				{
					// Fires event to container.
					m_pCtl->Fire_DisplayChanged();
					hr = S_OK;
				}
				break;

			default:
				hr = OLECMDERR_E_NOTSUPPORTED;
				break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }
    return (hr);
}


//	Connector from control to site.
//
void
CProxyFrame::UpdateObjectRects()
{
	_ASSERTE ( m_pSite );
	if ( NULL != m_pSite )
	{
		m_pSite->UpdateObjectRects();
	}
}


//	Called from the control's TranslateAccelerator.
//	Try our own (VID-like) acclerators first, and if not handled pass them along to TriEdit.
//
HRESULT
CProxyFrame::HrTranslateAccelerator(LPMSG lpmsg)
{
	HRESULT hr = S_OK;

	if (NULL != m_pIOleIPActiveObject)
	{
		_ASSERTE(lpmsg);

		hr = HrHandleAccelerator(lpmsg);

		if (hr != S_OK)
		{
			_ASSERTE(SUCCEEDED(hr));
			hr = m_pIOleIPActiveObject->TranslateAccelerator(lpmsg);
		}
	}

	return hr;
}


//	A lot of time was lost here in scenarios like clicking on/tabbing to a control
//	embedded in a VB OCX, tabbing to a control on a page, etc.
//	Exercise great caution and perform a lot of testing if this is changed.
//
LRESULT
CProxyFrame::OnSetFocus(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
{
	if ( ! m_pCtl->m_bUIActive )
	{
		m_pCtl->DoVerbUIActivate ( NULL, NULL );
	}

	// Give the focus to the ActiveX Document window
    if ( m_hWndObj != NULL )
	{
		::SetFocus( m_hWndObj );
		bHandled = TRUE;
	}

	// activate Trident with "Show"
	m_pSite->Activate(OLEIVERB_SHOW);

	return 0;
}


//	Sets the Trident window's parent correctly when created and destroyed.
//
void
CProxyFrame::SetParent ( HWND hwndParent )
{
	// This may be called before the control has been drawn.
	if ( NULL != m_hWndObj )
	{
        if( hwndParent )
        {
		    HWND hwndOldParent = ::SetParent ( m_hWndObj, hwndParent );
		    if ( NULL == hwndOldParent )
		    {
			    DWORD dwErr = 0;
			    dwErr = GetLastError ();
		    }
		    _ASSERTE ( m_pSite );
		    m_pSite->SetWindow ( hwndParent );
        }
	}
}


//	Handles WM_SHOWWINDOW messages directed to the control.
//
void
CProxyFrame::Show ( WPARAM nCmdShow )
{
	// This may be called before the control has been drawn.
	// Hide or show the hosted Trident
	if ( NULL != m_hWndObj )
	{
		::ShowWindow ( m_hWndObj, (int)nCmdShow );
	}
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	ExecCommand mechanism
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Convert a command ID into a TriEdit command ID.
//	Some commands used to represent other command groups as well, thus the ppguidCmdGroup parameter.
//	While this does little now, it may be useful again in the future.
//
HRESULT
CProxyFrame::HrMapCommand(DHTMLEDITCMDID typeLibCmdID,
	ULONG* cmdID, const GUID** ppguidCmdGroup, BOOL* pbOutParam)
{

	_ASSERTE(cmdID);
	_ASSERTE(ppguidCmdGroup);
	_ASSERTE(pbOutParam);

	*cmdID = 0;
	*ppguidCmdGroup = NULL;
	*pbOutParam = FALSE;

	for (UINT i=0; i < sizeof(cmdMap)/sizeof(CommandMap); ++i)
	{
		if (typeLibCmdID == cmdMap[i].typeLibCmdID)
		{
			*cmdID = cmdMap[i].cmdID;
			*ppguidCmdGroup = &GUID_TriEditCommandGroup;
			*pbOutParam = cmdMap[i].bOutParam;

			return S_OK;
		}
	}

	return OLECMDERR_E_NOTSUPPORTED ;
}


//	Helper routine for calling Exec.
//
HRESULT
CProxyFrame::HrExecCommand(const GUID* pguidCmdGroup, ULONG ucmdID,
	OLECMDEXECOPT cmdexecopt, VARIANT* pVarIn, VARIANT* pVarOut)
{
	HRESULT hr = E_FAIL;
	LPOLECOMMANDTARGET pCommandTarget = NULL;

	// note that it is valid for pguidCmdGroup to be NULL

	_ASSERTE(m_pSite);

	if (NULL == m_pSite)
		return E_UNEXPECTED;

	pCommandTarget = m_pSite->GetCommandTarget();

	_ASSERTE(pCommandTarget);

	if (pCommandTarget != NULL)
	{
		hr = pCommandTarget->Exec(pguidCmdGroup, ucmdID, cmdexecopt, pVarIn, pVarOut);
	}

	return hr;
}


//	Main command dispatcher; called from the control's ExecCommand method.
//	Handle our unique commands here, pass the rest onto HrExecGenericCommands.
//
HRESULT
CProxyFrame::HrMapExecCommand(DHTMLEDITCMDID deCommand, OLECMDEXECOPT cmdexecopt,
	VARIANT* pVarInput, VARIANT* pVarOutput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	ULONG ulMappedCommand = 0;
	const GUID* pguidCmdGroup = NULL;
	BOOL bOutParam = FALSE;

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	_ASSERTE(m_pSite);
	if (NULL == m_pSite)
		return E_UNEXPECTED;

	pCmdTgt = m_pSite->GetCommandTarget();
	_ASSERTE(pCmdTgt);

	if (NULL == pCmdTgt)
		return E_UNEXPECTED;

	// Its valid for pVarInput to be NULL

	if (FAILED(hr = HrMapCommand(deCommand, &ulMappedCommand, &pguidCmdGroup, &bOutParam)))
		return hr;

	AssureActivated();

	switch ( deCommand )
	{
		case DECMD_GETBLOCKFMTNAMES:
			hr = HrExecGetBlockFmtNames(pVarInput);
			break;

		case DECMD_INSERTTABLE:
			hr = HrExecInsertTable(pVarInput);
			break;

		case DECMD_GETFORECOLOR:
		case DECMD_GETBACKCOLOR:
			hr = HrExecGetColor(deCommand, ulMappedCommand, pVarOutput);
			break;

		case DECMD_SETFONTSIZE:
			hr = HrExecSetFontSize(pVarInput);
			break;

		case DECMD_GETBLOCKFMT:
			// Trident inconsistancy: GetBlockFmt fails if outparam isn't a BSTR.  GetFontName is OK with VT_EMPTY
			VariantChangeType ( pVarOutput, pVarOutput, 0, VT_BSTR );
			// Fall through; do not break!
		case DECMD_GETFONTNAME:
		case DECMD_GETFONTSIZE:
			hr = HrExecGenericCommands(pguidCmdGroup, ulMappedCommand, cmdexecopt, pVarOutput, TRUE );
			break;

		// Because our QueryStatus on DECMD_PROPERTIES returns TRUE for anything with IOleObject, executing the properties
		// verb can return an unexpected error.  Therefore, we ALWAYS return S_OK from this command to avoid causing VB and
		// script to terminate.
		case DECMD_PROPERTIES:
		{
			CComVariant	varParam;
			varParam.vt		= VT_I4;
			varParam.lVal	= OLEIVERB_PROPERTIES;
			hr = HrExecGenericCommands(pguidCmdGroup, ulMappedCommand, cmdexecopt, &varParam, FALSE );
			hr = S_OK;
		}
		break;

		default:
			hr = HrExecGenericCommands(pguidCmdGroup, ulMappedCommand, cmdexecopt, pVarInput, bOutParam);
			break;
	}

	if (FAILED(hr))
	{
		if (DISP_E_BADVARTYPE == hr || DISP_E_MEMBERNOTFOUND == hr)
		{
		// Map these Trident errors to something more general.
		// These errors can occur if Trident expected the element
		// it was trying to operate on to support certain interfaces.
		// The caller was trying to perform an operation not valid
		// for the current selection. Probably didn't call QueryStatus
		// first.

			hr = OLECMDERR_E_NOTSUPPORTED;
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	ExecCommand handler implementations
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Helper routine for calling Exec and dealing with results.
//
HRESULT
CProxyFrame::HrExecGenericCommands(const GUID* pguidCmdGroup, ULONG cmdID,
	OLECMDEXECOPT cmdexecopt, LPVARIANT pVarInput, BOOL bOutParam)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	LPVARIANT _pVar = NULL;
	VARIANT	varCopy;

	pCmdTgt = m_pSite->GetCommandTarget();

	if (pVarInput && V_VT(pVarInput) & VT_BYREF)
	{
		// convert VARIANTARGs to Variant for use by Trident
		// this occurs in VB if the user specified a basic type
		// as an arg, i.e., String or Long, instead of Variant

		VariantInit(&varCopy);
		if (FAILED(hr = VariantCopyInd(&varCopy, pVarInput)))
		{
			_ASSERTE(SUCCEEDED(hr));
			return hr;
		}

		_pVar = &varCopy;
	}
	else if (pVarInput)
		_pVar = pVarInput;

	if (bOutParam)
	{
		hr = pCmdTgt->Exec(pguidCmdGroup, cmdID, cmdexecopt, NULL, _pVar);
	}
	else
	{
		hr = pCmdTgt->Exec(pguidCmdGroup, cmdID, cmdexecopt, _pVar, NULL);
	}

	if (FAILED(hr))
		goto cleanup;

	// if a VARIANTARG was passed in for a command with output then
	// fill it in with the result from the Exec
	if (bOutParam && pVarInput && (V_VT(pVarInput) & VT_BYREF))
	{
		_ASSERTE(_pVar);	// _pVar should always be non NULL here
							// if there was an input arg that was byref,
							// then it should have been mapped to _pVar

		if (NULL == _pVar)
			return E_UNEXPECTED; // the catch all error return for "we are in a weird state"

		// if the type of return is different that the type the caller
		// passed in then do nothing and return
		if (V_VT(_pVar) != (V_VT(pVarInput) ^ VT_BYREF))
			return hr;

		switch(V_VT(_pVar))
		{
		case VT_BSTR:
			_ASSERTE(V_VT(pVarInput) == (VT_BSTR|VT_BYREF));

			if (V_BSTRREF(pVarInput))
				hr = SysReAllocString(V_BSTRREF(pVarInput), V_BSTR(_pVar));
			break;

		case VT_BOOL:
			_ASSERTE(V_VT(pVarInput) == (VT_BOOL|VT_BYREF));

			if (V_BOOLREF(pVarInput))
				*(V_BOOLREF(pVarInput)) = V_BOOL(_pVar);
			break;

		case VT_I4:
			_ASSERTE(V_VT(pVarInput) == (VT_I4|VT_BYREF));

			if (V_I4REF(pVarInput))
				*(V_I4REF(pVarInput)) = V_I4(_pVar);
			break;

		default:
			_ASSERTE(0);
			break;
		}
	}

cleanup:
	// Our documentation replaces E_FAIL with DE_E_UNEXPECTED: different values.
	if ( E_FAIL == hr )
	{
		hr = DE_E_UNEXPECTED;
	}

	return hr;
}


//	Handler for command DECMD_GETBLOCKFMTNAMES.
//	There are plenty of possible types of arrays to be handled.
//
HRESULT
CProxyFrame::HrExecGetBlockFmtNames(LPVARIANT pVarInput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varArray;
	LPUNKNOWN pUnk = NULL;
	CComPtr<IDEGetBlockFmtNamesParam> piNamesParam;

	pCmdTgt = m_pSite->GetCommandTarget();

	if (NULL == pVarInput)
		return E_INVALIDARG;

	if (V_VT(pVarInput) == (VT_BYREF|VT_DISPATCH))
	{
		if (V_DISPATCHREF(pVarInput))
			pUnk = *(V_DISPATCHREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_DISPATCH)
	{
		if (V_DISPATCH(pVarInput))
			pUnk = V_DISPATCH(pVarInput);
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == (VT_BYREF|VT_UNKNOWN))
	{
		if (V_UNKNOWNREF(pVarInput))
			pUnk = *(V_UNKNOWNREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_UNKNOWN)
	{
		if (V_UNKNOWN(pVarInput))
			pUnk = V_UNKNOWN(pVarInput);
		else
			return E_INVALIDARG;
	}
	else
		return E_INVALIDARG;

	// This can happen in VB if an object that has not
	// been set with CreateObject has been passed in
	if (NULL == pUnk)
		return E_INVALIDARG;

	// Try to get the names object before
	// performing the command

	if (FAILED(hr = pUnk->QueryInterface(IID_IDEGetBlockFmtNamesParam, (LPVOID*) &piNamesParam)))
		return E_INVALIDARG;

	_ASSERTE((!piNamesParam) == FALSE);

	// Trident wants the vt to be specifically VT_ARRAY with
	// no type qualifer -- if you give one it fails even though
	// an array of BSTRs is returned

	VariantInit(&varArray);
	V_VT(&varArray) = VT_ARRAY;

	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, IDM_TRIED_GETBLOCKFMTS,
		MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &varArray);

	if (FAILED(hr))
		goto cleanup;

	piNamesParam->put_Names(&varArray);

cleanup:

	return hr;
}


//	Handler for command DECMD_INSERTTABLE.
//
HRESULT
CProxyFrame::HrExecInsertTable(LPVARIANT pVarInput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varTableArray;
	LPUNKNOWN pUnk = NULL;
	CComPtr<IDEInsertTableParam> piTableParam;

	pCmdTgt = m_pSite->GetCommandTarget();

	VariantInit(&varTableArray);

	if (NULL == pVarInput)
		return E_INVALIDARG;

	if (V_VT(pVarInput) == (VT_BYREF|VT_DISPATCH))
	{
		if (V_DISPATCHREF(pVarInput))
			pUnk = *(V_DISPATCHREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_DISPATCH)
	{
		if (V_DISPATCH(pVarInput))
			pUnk = V_DISPATCH(pVarInput);
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == (VT_BYREF|VT_UNKNOWN))
	{
		if (V_UNKNOWNREF(pVarInput))
			pUnk = *(V_UNKNOWNREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_UNKNOWN)
	{
		if (V_UNKNOWN(pVarInput))
			pUnk = V_UNKNOWN(pVarInput);
		else
			return E_INVALIDARG;
	}
	else
		return E_INVALIDARG;

	// This can happen in VB if an object that has not
	// been set with CreateObject has been passed in
	if (NULL == pUnk)
		return E_INVALIDARG;

	if (FAILED(hr = pUnk->QueryInterface(IID_IDEInsertTableParam, (LPVOID*) &piTableParam)))
		return E_INVALIDARG;

	_ASSERTE((!piTableParam) == FALSE);

	if (FAILED(hr = HrGetTableSafeArray(piTableParam, &varTableArray)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}


	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, IDM_TRIED_INSERTTABLE,
		MSOCMDEXECOPT_DONTPROMPTUSER, &varTableArray, NULL);

	return hr;
}


//	Hanlder for commands DECMD_GETFORECOLOR and DECMD_GETBACKCOLOR.
//	Reply with a string in the format #RRGGBB or an empty string.
//
HRESULT
CProxyFrame::HrExecGetColor(DHTMLEDITCMDID deCommand, ULONG ulMappedCommand, LPVARIANT pVarOutput)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varColorOut;
	TCHAR buf[32];
	WCHAR* oleStr = NULL;

	pCmdTgt = m_pSite->GetCommandTarget();

	if (NULL == pVarOutput)
		return E_INVALIDARG;

	// validate the command
	if (DECMD_GETFORECOLOR != deCommand && DECMD_GETBACKCOLOR != deCommand)
		return E_INVALIDARG;

	// validate the args
	if (V_VT(pVarOutput) == (VT_BYREF|VT_BSTR))
	{
		if (NULL == V_BSTRREF(pVarOutput))
			return E_INVALIDARG;
	}
	else if (V_VT(pVarOutput) == VT_BSTR)
	{
		if (NULL == V_BSTR(pVarOutput))
			return E_INVALIDARG;
	}
	else if (V_VT(pVarOutput) != (VT_EMPTY) && V_VT(pVarOutput) != (VT_NULL))
		return E_INVALIDARG;

	VariantInit(&varColorOut);
	V_VT(&varColorOut) = VT_I4;

	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, ulMappedCommand,
		MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &varColorOut);

	// Trident will return VT_NULL if color selection
	// was mixed or no text is selected, we return empty
	// string ("") in that case.

	buf[0] = 0;

	if (VT_I4 == V_VT(&varColorOut))
	{
		ULONG ulColor = 0;
		ULONG r=0;
		ULONG g=0;
		ULONG b=0;

		ulColor = V_I4(&varColorOut);
		r = 0x000000ff & ulColor;
		g = (0x0000ff00 & ulColor) >> 8;
		b = (0x00ff0000 & ulColor) >> 16;

		wsprintf(buf, TEXT("#%02X%02X%02X"), r, g, b);
	}
	
	oleStr = T2OLE(buf);

	if (V_VT(pVarOutput) == (VT_BSTR|VT_BYREF))
		hr = SysReAllocString(V_BSTRREF(pVarOutput), oleStr);
	else if (V_VT(pVarOutput) == (VT_BSTR))
		hr = SysReAllocString(&(V_BSTR(pVarOutput)), oleStr);
	else if (V_VT(pVarOutput) == (VT_EMPTY) || V_VT(pVarOutput) == (VT_NULL))
	{
		V_VT(pVarOutput) = VT_BSTR;
		V_BSTR(pVarOutput) = SysAllocString(oleStr);
	}

	return hr;
}


//	Handler for command DECMD_SETFONTSIZE.
//
HRESULT
CProxyFrame::HrExecSetFontSize(LPVARIANT pVarInput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varSizeIn;
	

	pCmdTgt = m_pSite->GetCommandTarget();

	if (NULL == pVarInput)
		return E_INVALIDARG;

	VariantInit(&varSizeIn);

	if (FAILED(hr = VariantChangeType(&varSizeIn, pVarInput, 0, VT_I4)))
		return E_INVALIDARG;

	if (varSizeIn.lVal < 0 || varSizeIn.lVal > 7)
		return E_INVALIDARG;

	if (0 == varSizeIn.lVal)
		varSizeIn.lVal = varSizeIn.lVal + 1;


	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, IDM_TRIED_FONTSIZE,
		MSOCMDEXECOPT_DONTPROMPTUSER, &varSizeIn, NULL);

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	QueryStatus mechanism
//
///////////////////////////////////////////////////////////////////////////////////////////

//	Map the control specific command ID to a TriEdit command ID and call QueryStatus.
//
HRESULT
CProxyFrame::HrMapQueryStatus( DHTMLEDITCMDID ucmdID, DHTMLEDITCMDF* cmdf)
{
	LPOLECOMMANDTARGET pCommandTarget = NULL;

	_ASSERTE(cmdf);

	HRESULT hr = E_FAIL;

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	if (NULL == cmdf)
		return E_INVALIDARG;

	*cmdf = (DHTMLEDITCMDF) 0;

	_ASSERTE(m_pSite);

	if (NULL == m_pSite)
		return E_UNEXPECTED;

	pCommandTarget = m_pSite->GetCommandTarget();
	_ASSERTE(pCommandTarget);

	if ( pCommandTarget != NULL )
	{

		AssureActivated ();

		ULONG cmdID = 0;
		const GUID* pguidCmdGroup = NULL;
		BOOL bOutParam = FALSE;

		if (SUCCEEDED(hr = HrMapCommand(ucmdID, &cmdID, &pguidCmdGroup, &bOutParam)))
		{
			MSOCMD msocmd;
			msocmd.cmdID = cmdID;
			msocmd.cmdf  = 0;

			hr = pCommandTarget->QueryStatus(pguidCmdGroup, 1, &msocmd, NULL);

			*cmdf = (DHTMLEDITCMDF) msocmd.cmdf;
		}
	}

	return hr;
}


//	General routine for determining the status of a command.
//	Should resolve to not supported, disabled, enabled, latched or ninched.
//
HRESULT
CProxyFrame::HrQueryStatus(const GUID* pguidCmdGroup, ULONG ucmdID, OLECMDF* cmdf)
{
	HRESULT hr = E_FAIL;

	_ASSERTE(cmdf);

	// Note that it is valid for pguidCmdGroup to be NULL

	if (NULL == cmdf)
		return E_INVALIDARG;

	*cmdf = (OLECMDF) 0;

	_ASSERTE(m_pSite);

	if ( m_pSite != NULL ) // m_pSite should always be set
	{
		LPOLECOMMANDTARGET pCommandTarget = m_pSite->GetCommandTarget();

		if ( pCommandTarget != NULL )
		{
			MSOCMD msocmd;
			msocmd.cmdID = ucmdID;
			msocmd.cmdf  = 0;

			hr = pCommandTarget->QueryStatus(pguidCmdGroup, 1, &msocmd, NULL);

			*cmdf = (OLECMDF) msocmd.cmdf;
		}
	}

	return hr;
}


//	A tragic FAT16 compatibility problem: file names in the specific form:
//	[a-zA-z]\:[^\\].+ cause various, severe problems.  NTFS "forgives".
//	We must detect these, both in file names and file:// URL and return an error.
//
BOOL
CProxyFrame::IsMissingBackSlash ( BSTR path, BOOL bfIsURL )
{
	BOOL bfMissing = FALSE;

	if ( bfIsURL )
	{
		WCHAR	wszFileProtocol[] = L"file://";
		int		cchProtocol		= wcslen ( wszFileProtocol );

		if ( 0 == _wcsnicmp ( path, wszFileProtocol, cchProtocol ) )
		{
			if ( OLECHAR(':') == path[cchProtocol+1] )
			{
				if ( OLECHAR('\\') != path[cchProtocol+2] )
				{
					bfMissing = TRUE;
				}
			}
		}
	}
	else
	{
		// Path name.  chec for drive letter, colon, non-backslash.
		if ( OLECHAR(':') == path[1] )
		{
			if ( OLECHAR('\\') != path[2] )
			{
				bfMissing = TRUE;
			}
		}
	}
	return bfMissing;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Control methods and properties
//
///////////////////////////////////////////////////////////////////////////////////////////

//	Handles NewDocument, LoadURL and LoadDocument control methods.
//	The document is loaded indirectly via the pluggable protocol handler.
//	If "path" is NULL, do NewDocument.  TestbfURL to see if it's a URL or UNC path.
//
HRESULT
CProxyFrame::LoadDocument(BSTR path, BOOL bfIsURL )
{
	USES_CONVERSION;

	HRESULT hr			= S_OK;
	UINT pathLen		= 0;

	AssureActivated ();	// This can set m_bstrLoadText as a side effect in unactivated controls!  Be careful!

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	m_bstrLoadText.Empty ();	// Clear the text to be added directly, or it will be used instead!
	m_bstrCurDocPath	= L"";
	m_bstrBaseURL		= L"";

	if (path)
		pathLen = ::SysStringLen(path);
	else
		pathLen = 0;

	// We've resetting the contents of the control.  Go back to default save mechanism.
	// If we load Unicode it will be reset.
	m_pSite->SetSaveAsUnicode ( FALSE );

	if (path && pathLen)
	{
		_ASSERTE(path);
		_ASSERTE(pathLen > 0);

		// First, look out for a wicked error: X:FileName with no '\' is BAD on FAT16.
		if ( IsMissingBackSlash ( path, bfIsURL ) )
		{
			hr = DE_E_PATH_NOT_FOUND;
			LoadBSTRDeferred ( m_bstrInitialDoc );
			goto error;
		}

		// Try to open the file -- stop the sequence
		// if its bogus or we don't have access
		if ( !bfIsURL )
		{
			if (FAILED(hr = m_pSite->HrTestFileOpen(path)))
			{
				LoadBSTRDeferred ( m_bstrInitialDoc );
				goto error;
			}
		}
		m_bfIsURL = bfIsURL;

		m_bstrCurDocPath = path;	// This needs to be set before loading, because base url is needed durring load.
		SetBaseURLFromCurDocPath ( bfIsURL );
		m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;

		CComPtr<IMoniker> srpMoniker;
		CComPtr<IBindCtx> srpBindCtx;
		CComQIPtr<IPersistMoniker, &IID_IPersistMoniker> srpPM (m_pUnkTriEdit);
		_ASSERTE ( srpPM );

		if ( srpPM )
		{
			CComBSTR	bstrProtocol = m_wszProtocolPrefix;
			bstrProtocol += L"(";
			bstrProtocol += path;
			bstrProtocol += L")";

#ifdef LATE_BIND_URLMON_WININET
			_ASSERTE ( m_pfnCreateURLMoniker );
			hr = (*m_pfnCreateURLMoniker)( NULL, bstrProtocol, &srpMoniker );
#else
			hr = CreateURLMoniker ( NULL, bstrProtocol, &srpMoniker );
#endif // LATE_BIND_URLMON_WININET

			_ASSERTE ( SUCCEEDED( hr ) );
			if ( SUCCEEDED ( hr ) )
			{
				hr = ::CreateBindCtx(NULL, &srpBindCtx);
				_ASSERTE ( SUCCEEDED( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					// Delete the cache entry before downloading.
					// This assures that loading, posting, and reloading works.
					// Bug 18544.
					// NOTE: Inexact match fails!  http://www.microsoft.com fails,
					// because this actually loads/caches a specific default page.
					if ( bfIsURL )
					{
						LPTSTR szURL = OLE2T ( m_bstrCurDocPath );
#ifdef LATE_BIND_URLMON_WININET
						_ASSERTE ( m_pfnDeleteUrlCacheEntry );
						(*m_pfnDeleteUrlCacheEntry)( szURL );
#else
						DeleteUrlCacheEntry ( szURL );
#endif // LATE_BIND_URLMON_WININET
					}
					m_bfIsLoading = TRUE;
					m_hrDeferredLoadError = S_OK;	// URLs: don't let Trident get the error!

					hr = srpPM->Load(FALSE, srpMoniker,  srpBindCtx, STGM_READ);

					if ( SUCCEEDED ( hr ) && FAILED ( m_hrDeferredLoadError ) )
					{
						hr = m_hrDeferredLoadError;	// In case we stashed a result
					}
					if ( FAILED ( hr ) )
					{
						m_bfIsLoading = FALSE;
					}
				}
			}
		}
	}
	else
	{
		if (FAILED(hr = LoadBSTRDeferred ( m_bstrInitialDoc )))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto error;
		}
	}

error:
	return hr;
}


//	Implements FilterSourceCode control method
//	Used to restore filtered content extracted directly from DOM.
//
HRESULT
CProxyFrame::FilterSourceCode ( BSTR bsSourceIn, BSTR* pbsSourceOut )
{
	HRESULT				hr;
	CComPtr<IStream>	spStreamIn;
	IStream*			piStreamOut;

	hr = m_pSite->HrBstrToStream(bsSourceIn, &spStreamIn);
	if ( SUCCEEDED ( hr ) )
	{
		if ( m_vbBrowseMode )
		{
			spStreamIn.p->AddRef ();
			piStreamOut = spStreamIn;
		}
		else
		{
			hr = m_pSite->HrFilter ( FALSE, spStreamIn, &piStreamOut, m_dwFilterOutFlags | dwFilterSourceCode);
		}
		if ( SUCCEEDED ( hr ) )
		{
			hr = m_pSite->HrStreamToBstr ( piStreamOut, pbsSourceOut );
			piStreamOut->Release ();
		}
	}
	return hr;
}


//	Implements the control's Print method
//
HRESULT
CProxyFrame::Print ( BOOL bfWithUI )
{
	AssureActivated ();

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;
	return HrExecCommand ( &GUID_TriEditCommandGroup, IDM_TRIED_PRINT,
		bfWithUI ? MSOCMDEXECOPT_PROMPTUSER : MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL );
}


//	Implements the control's Refresh method
//
HRESULT
CProxyFrame::RefreshDoc ()
{
	if ( NULL != m_hWndObj )
	{
		if ( ::IsWindow ( m_hWndObj ) )
		{
			::InvalidateRect ( m_hWndObj, NULL, TRUE );
			return S_OK;
		}
	}
	return S_FALSE;
}


//	Implements the control's SaveDocument method
//
HRESULT
CProxyFrame::SaveDocument(BSTR path)
{
	HRESULT hr = S_OK;
	ULONG pathLen = 0;

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	_ASSERTE(GetState() == ESTATE_ACTIVATED);

	AssureActivated ();

	if (GetState() != ESTATE_ACTIVATED)
		return E_UNEXPECTED;

	_ASSERTE(path);

	if (path)
		pathLen = ::SysStringLen(path);
	else
		pathLen = 0;

	if (0 == pathLen)
		return E_INVALIDARG;

	_ASSERTE(pathLen);

	// First, look out for a wicked error: X:FileName with no '\' is BAD on FAT16.
	if ( IsMissingBackSlash ( path, FALSE ) )
	{
		return DE_E_PATH_NOT_FOUND;
	}

	hr = m_pSite->HrSaveToFile(path, m_dwFilterOutFlags);

	if ( SUCCEEDED ( hr ) )
	{
		m_bstrCurDocPath = path;
	}

	return hr;
}


//	Implements the control's SetContextMenu method
//	One routine handles javascript arrays, the other simple arrays.
//
HRESULT
CProxyFrame::SetContextMenu(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates)
{
	if (V_VT(pVarMenuStrings) == VT_DISPATCH || V_VT(pVarMenuStates) == VT_DISPATCH)
		return SetContextMenuDispEx(pVarMenuStrings, pVarMenuStates);
	else
		return SetContextMenuSA(pVarMenuStrings, pVarMenuStates);
}


// Get menu strings from SafeArray
//
HRESULT
CProxyFrame::SetContextMenuSA(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates)
{
	HRESULT hr = S_OK;
	SAFEARRAY* psaStrings = NULL;
	SAFEARRAY* psaStates = NULL;
    LONG lLBound, lUBound, lLBoundState, lUBoundState;

	if (NULL == pVarMenuStrings || NULL == pVarMenuStates)
		return E_INVALIDARG;

	if ((VT_ARRAY|VT_BSTR) != V_VT(pVarMenuStrings) &&
		((VT_ARRAY|VT_BSTR)|VT_BYREF) != V_VT(pVarMenuStrings) &&
		((VT_ARRAY|VT_VARIANT)|VT_BYREF) != V_VT(pVarMenuStrings) &&
		(VT_ARRAY|VT_VARIANT) != V_VT(pVarMenuStrings))
		return E_INVALIDARG;

	if ((VT_ARRAY|VT_I4) != V_VT(pVarMenuStates) &&
		((VT_ARRAY|VT_I4)|VT_BYREF) != V_VT(pVarMenuStates) &&
		((VT_ARRAY|VT_VARIANT)|VT_BYREF) != V_VT(pVarMenuStates) &&
		(VT_ARRAY|VT_VARIANT) != V_VT(pVarMenuStates))
		return E_INVALIDARG;

	if ((VT_ARRAY|VT_BSTR) == V_VT(pVarMenuStrings))
	{
		psaStrings = V_ARRAY(pVarMenuStrings);
	}
	if ((VT_ARRAY|VT_VARIANT) == V_VT(pVarMenuStrings))
	{
		psaStrings = V_ARRAY(pVarMenuStrings);
	}
	else if ((VT_ARRAY|VT_BSTR|VT_BYREF) == V_VT(pVarMenuStrings))
	{
		if (NULL == V_ARRAYREF(pVarMenuStrings))
			return E_INVALIDARG;

		psaStrings = *(V_ARRAYREF(pVarMenuStrings));
	}
	else if ((VT_ARRAY|VT_VARIANT|VT_BYREF) == V_VT(pVarMenuStrings))
	{
		if (NULL == V_ARRAYREF(pVarMenuStrings))
			return E_INVALIDARG;
		
		psaStrings = *(V_ARRAYREF(pVarMenuStrings));
	}

	if ((VT_ARRAY|VT_I4) == V_VT(pVarMenuStates))
	{
		psaStates = V_ARRAY(pVarMenuStates);
	}
	if ((VT_ARRAY|VT_VARIANT) == V_VT(pVarMenuStates))
	{
		psaStates = V_ARRAY(pVarMenuStates);
	}
	else if ((VT_ARRAY|VT_I4|VT_BYREF) == V_VT(pVarMenuStates))
	{
		if (NULL == V_ARRAYREF(pVarMenuStates))
			return E_INVALIDARG;

		psaStates = *(V_ARRAYREF(pVarMenuStates));
	}
	else if ((VT_ARRAY|VT_VARIANT|VT_BYREF) == V_VT(pVarMenuStates))
	{
		if (NULL == V_ARRAYREF(pVarMenuStates))
			return E_INVALIDARG;

		psaStates = *(V_ARRAYREF(pVarMenuStates));
	}


	if (NULL == psaStrings || NULL == psaStates)
		return E_INVALIDARG;

	SafeArrayGetLBound(psaStrings, 1, &lLBound);
	SafeArrayGetUBound(psaStrings, 1, &lUBound);

	SafeArrayGetLBound(psaStates, 1, &lLBoundState);
	SafeArrayGetUBound(psaStates, 1, &lUBoundState);

	if (lLBound != lLBoundState || lUBound != lUBoundState)
		return E_INVALIDARG;

	if (m_pMenuStrings)
	{
		SafeArrayDestroy(m_pMenuStrings);
		m_pMenuStrings = NULL;
	}

	if (m_pMenuStates)
	{
		SafeArrayDestroy(m_pMenuStates);
		m_pMenuStates = NULL;
	}

	// An empty array was passed in 
	// The context menu has been cleared
	if (lLBound ==lUBound )
		goto cleanup;

	if (FAILED(hr = SafeArrayCopy(psaStrings, &m_pMenuStrings)))
		goto cleanup;

	if (FAILED(hr = SafeArrayCopy(psaStates, &m_pMenuStates)))
		goto cleanup;

cleanup:

	if (FAILED(hr))
	{
		if (m_pMenuStrings)
		{
			SafeArrayDestroy(m_pMenuStrings);
			m_pMenuStrings = NULL;
		}

		if (m_pMenuStates)
		{
			SafeArrayDestroy(m_pMenuStates);
			m_pMenuStates = NULL;	
		}
	}

    return hr;
}


// Get menu strings from JScript array, or object that supports IDispatchEx
// For iterating through JScript arrays, we expect the elements
// to be accessable by ordinals starting at 0, i.e., a 0 based array
//
HRESULT
CProxyFrame::SetContextMenuDispEx(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates)
{
	HRESULT hr = S_OK;
	ULONG i=0;
	ULONG ulStringsLen = 0;
	ULONG ulStatesLen = 0;
	IDispatch* pdStrings = NULL;
	IDispatch* pdStates = NULL;
	IDispatchEx* pdexStrings = NULL;
	IDispatchEx* pdexStates = NULL;
	CDispExArray dispStrings;
	CDispExArray dispStates;
	VARIANT varString;
	VARIANT varState;
	SAFEARRAYBOUND rgsabound[1] = {0};
	LONG ix[1]					= {0};

	if (VT_DISPATCH != V_VT(pVarMenuStrings) || VT_DISPATCH != V_VT(pVarMenuStates))
		return E_INVALIDARG;

	VariantInit(&varString);
	VariantInit(&varState);

	pdStrings = V_DISPATCH(pVarMenuStrings);
	pdStates = V_DISPATCH(pVarMenuStates);

	_ASSERTE(pdStrings);
	_ASSERTE(pdStates);

	if (FAILED(hr = pdStrings->QueryInterface(IID_IDispatchEx, (LPVOID*) &pdexStrings)))
	{
		return E_INVALIDARG;
	}
	dispStrings.Attach(pdexStrings);

	if (FAILED(hr = pdStates->QueryInterface(IID_IDispatchEx, (LPVOID*) &pdexStates)))
	{
		return E_INVALIDARG;
	}
	dispStates.Attach(pdexStates);

	if (FAILED(dispStrings.HrGetLength(&ulStringsLen)))
		goto cleanup;

	if (FAILED(dispStates.HrGetLength(&ulStatesLen)))
		goto cleanup;

	// Make sure that arrays are equal length
	if (ulStringsLen != ulStatesLen)
		return E_INVALIDARG;

	if (m_pMenuStrings)
	{
		SafeArrayDestroy(m_pMenuStrings);
		m_pMenuStrings = NULL;
	}

	if (m_pMenuStates)
	{
		SafeArrayDestroy(m_pMenuStates);
		m_pMenuStates = NULL;
	}

	// An empty array was passed in 
	// The context menu has been cleared
	if (ulStringsLen <= 0)
		goto cleanup;

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = ulStringsLen;

	m_pMenuStrings = SafeArrayCreate(VT_BSTR, 1, rgsabound);	
	_ASSERTE(m_pMenuStrings);
	if (NULL == m_pMenuStrings)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	m_pMenuStates = SafeArrayCreate(VT_I4, 1, rgsabound);	
	_ASSERTE(m_pMenuStates);
	if (NULL == m_pMenuStates)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	// For iterating through JScript arrays, we expect the elements
	// to be accessable by ordinals starting at 0, i.e., a 0 based array
	hr = S_OK;
	for (i=0; i < ulStringsLen && hr != S_FALSE; i++)
	{		
		if (FAILED(hr = dispStrings.HrGetElement(i, &varString)))
			goto cleanup;

		if (FAILED(hr = dispStates.HrGetElement(i, &varState)))
			goto cleanup;

		if (VT_BSTR != V_VT(&varString) || VT_I4 != V_VT(&varState))
		{
			hr = E_INVALIDARG;
			goto cleanup;
		}

		ix[0] = i;
		if (FAILED(hr = SafeArrayPutElement(m_pMenuStrings, ix, (LPVOID) V_BSTR(&varString))))
			goto cleanup;

		if (FAILED(hr = SafeArrayPutElement(m_pMenuStates, ix, (LPVOID) &(V_I4(&varState)))))
			goto cleanup;

		VariantClear ( &varString );
		VariantClear ( &varState );
	}

cleanup:

	if (FAILED(hr))
	{
		if (m_pMenuStrings)
		{
			SafeArrayDestroy(m_pMenuStrings);
			m_pMenuStrings = NULL;
		}

		if (m_pMenuStates)
		{
			SafeArrayDestroy(m_pMenuStates);
			m_pMenuStates = NULL;	
		}
	}

    return hr;
}


//	DocumentTitle property implementation; read only.
//	Get the property from the HTML document.
//
HRESULT
CProxyFrame::GetDocumentTitle ( CComBSTR&  bstrTitle )
{
	HRESULT		hr = S_OK;
	DISPID		dispid;
	DISPPARAMS	dispparamsNoArgs = {NULL, NULL, 0, 0};
	CComVariant	varResult;

	CComPtr<IHTMLDocument2> piHtmlDoc = NULL;
	hr = HrGetDoc( &piHtmlDoc );

	if ( SUCCEEDED ( hr ) )
	{
		AssureActivated();

		hr = piHtmlDoc->GetIDsOfNames ( IID_NULL, &g_wszHTMLTitlePropName, 1, LOCALE_SYSTEM_DEFAULT, &dispid );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( FAILED ( hr ) )
		{
			return hr;
		}

		hr = piHtmlDoc->Invoke ( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
			&dispparamsNoArgs, &varResult, NULL, NULL );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( FAILED ( hr ) )
		{
			return hr;
		}
		
		hr = varResult.ChangeType ( VT_BSTR );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( FAILED ( hr ) )
		{
			return hr;
		}

		bstrTitle = varResult.bstrVal;
	}

	return hr;
}


//	Implements getting the control's BrowseMode property
//
HRESULT
CProxyFrame::GetBrowseMode ( VARIANT_BOOL  *pVal )
{
	*pVal = m_vbBrowseMode;
	return S_OK;
}


//	Implements setting the control's BrowseMode property
//
HRESULT
CProxyFrame::SetBrowseMode ( VARIANT_BOOL  newVal )
{
	HRESULT hr = S_FALSE;	// Indicates value was set, but actual mode was not changed.

	_ASSERTE ( m_pSite );

	// If we're still reading the property bag, just set the value, don't change the text;
	// it hasn't been loaded yet.
	if ( NULL == m_pSite->GetCommandTarget() )
	{
		m_vbBrowseMode = newVal;
		hr = S_OK;
	}
	else
	{
		if ( m_vbBrowseMode != newVal )
		{
			AssureActivated ();

			m_bfModeSwitched = TRUE;

			if ( newVal && m_pCtl->IsUserMode () )	// newVal means "switching to browse mode"
			{
				CComPtr<IStream>	spStream	= NULL;

				HrGetIsDirty ( m_bfPreserveDirtyFlagAcrossBrowseMode );
				hr = m_pSite->HrSaveToStreamAndFilter ( &spStream, m_dwFilterOutFlags );
				if ( SUCCEEDED ( hr ) )
				{
					m_bstrLoadText.Empty ();
					// Preserve the byte order mark, or else it will not be reloaded properly
					hr = m_pSite->HrStreamToBstr ( spStream, &m_bstrLoadText, TRUE );
				}
			}

			m_vbBrowseMode = newVal;

			// Let Trident know the ambient property has changed.
			CComQIPtr<IOleControl,&IID_IOleControl>spioc ( m_pSite->GetObjectUnknown() );
			if ( spioc )
			{
				m_bfIsLoading = TRUE;
				spioc->OnAmbientPropertyChange ( DISPID_AMBIENT_USERMODE );
			}
		}
	}
	return hr;
}


//	Implements getting the control's UseDivOnCarriageReturn property
//
HRESULT
CProxyFrame::GetDivOnCr ( VARIANT_BOOL  *pVal )
{
	*pVal = m_vbUseDivOnCr;
	return S_OK;
}


//	Implements setting the control's UseDivOnCarriageReturn property
//
HRESULT
CProxyFrame::SetDivOnCr ( VARIANT_BOOL  newVal )
{
	HRESULT		hr	= S_OK;
	CComVariant varDefBlock;

	m_vbUseDivOnCr = newVal;

	// Reinitialize if we haven't loaded our properties before this point.
	if ( READYSTATE_UNINITIALIZED == m_readyState )
	{
		// InitializeDocString takes m_vbUseDivOnCr into account
		InitializeDocString ();
	}
	return hr;
}


//	Implements getting the control's read-only Busy property
//
HRESULT
CProxyFrame::GetBusy ( VARIANT_BOOL *pVal )
{
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = ( m_bfIsLoading ) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return S_OK;
}


// Implements setting the control's ActivateActiveXControls property
//
HRESULT
CProxyFrame::HrSetPropActivateControls(BOOL activateControls)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_NOACTIVATENORMALOLECONTROLS, !activateControls)))
			m_fActivateControls = activateControls;
	}
	else
		m_fActivateControls = activateControls;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ActivateActiveXControls property
//
HRESULT
CProxyFrame::HrGetPropActivateControls(BOOL& activateControls)
{
	HRESULT hr = S_OK;

	activateControls = m_fActivateControls;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's ActivateApplets property
//
HRESULT
CProxyFrame::HrSetPropActivateApplets(BOOL activateApplets)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_NOACTIVATEJAVAAPPLETS, !activateApplets)))
			m_fActivateApplets = activateApplets;
	}
	else
		m_fActivateApplets = activateApplets;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ActivateApplets property
//
HRESULT
CProxyFrame::HrGetPropActivateApplets(BOOL& activateApplets)
{
	HRESULT hr = S_OK;

	activateApplets = m_fActivateApplets;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's ActivateDTCs property
//
HRESULT
CProxyFrame::HrSetPropActivateDTCs(BOOL activateDTCs)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_NOACTIVATEDESIGNTIMECONTROLS, !activateDTCs)))
			m_fActivateDTCs = activateDTCs;
	}
	else
		m_fActivateDTCs = activateDTCs;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ActivateDTCs property
//
HRESULT
CProxyFrame::HrGetPropActivateDTCs(BOOL& activateDTCs)
{
	HRESULT hr = S_OK;

	activateDTCs = m_fActivateDTCs;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}



// Implements setting the control's ShowDetails property
//
HRESULT
CProxyFrame::HrSetPropShowAllTags(BOOL showAllTags)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_SHOWALLTAGS, showAllTags)))
			m_fShowAllTags = showAllTags;
	}
	else
		m_fShowAllTags = showAllTags;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ShowDetails property
//
HRESULT
CProxyFrame::HrGetPropShowAllTags(BOOL& showAllTags)
{
	HRESULT hr = S_OK;

	showAllTags = m_fShowAllTags;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's ShowBorders property
//
HRESULT
CProxyFrame::HrSetPropShowBorders(BOOL showBorders)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_SHOWZEROBORDERATDESIGNTIME, showBorders)))
			m_fShowBorders = showBorders;
	}
	else
		m_fShowBorders = showBorders;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ShowBorders property
//
HRESULT
CProxyFrame::HrGetPropShowBorders(BOOL& showBorders)
{
	HRESULT hr = S_OK;

	showBorders = m_fShowBorders;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's Appearance property
//
HRESULT
CProxyFrame::HrSetDisplay3D(BOOL bVal)
{
	m_fDisplay3D = bVal;
	return S_OK;
}


// Implements getting the control's Appearance property
//
HRESULT
CProxyFrame::HrGetDisplay3D(BOOL& bVal)
{
	bVal = m_fDisplay3D;
	return S_OK;
}


// Implements setting the control's Scrollbars property
//
HRESULT
CProxyFrame::HrSetScrollbars(BOOL bVal)
{
	m_fScrollbars = bVal;
	return S_OK;
}


// Implements getting the control's Scrollbars property
//
HRESULT
CProxyFrame::HrGetScrollbars(BOOL& bVal)
{
	bVal = m_fScrollbars;
	return S_OK;
}


// Implements setting the control's ScrollbarAppearance property
//
HRESULT
CProxyFrame::HrSetDisplayFlatScrollbars(BOOL bVal)
{
	m_fDisplayFlatScrollbars = bVal;
	return S_OK;
}


// Implements getting the control's ScrollbarAppearance property
//
HRESULT
CProxyFrame::HrGetDisplayFlatScrollbars(BOOL& bVal)
{
	bVal = m_fDisplayFlatScrollbars;
	return S_OK;
}


// Implements setting the control's AbsoluteDropMode property
//
HRESULT
CProxyFrame::HrSetAbsoluteDropMode(BOOL dropMode)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		VARIANT var;

		VariantInit(&var);

		V_VT(&var) = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		V_BOOL(&var) = (dropMode) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_2D_DROP_MODE,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_fAbsoluteDropMode = dropMode;
	}
	else
		m_fAbsoluteDropMode = dropMode;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's AbsoluteDropMode property
//
HRESULT
CProxyFrame::HrGetAbsoluteDropMode(BOOL& dropMode)
{
	HRESULT hr = S_OK;

	dropMode = m_fAbsoluteDropMode;
	return hr;
}


// Implements setting the control's SnapToGrid property
//
HRESULT
CProxyFrame::HrSetSnapToGrid(BOOL snapToGrid)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		VARIANT var;
		POINT pt = {0};

		VariantInit(&var);
		if ( snapToGrid )
		{
			pt.y = m_ulSnapToGridY;
			pt.x = m_ulSnapToGridX;
		}
		else
		{
			pt.y = 0;
			pt.x = 0;
		}

		V_VT(&var) = VT_BYREF;
		V_BYREF(&var) = &pt;

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_ALIGNMENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_fSnapToGrid = snapToGrid;

	}
	else
		m_fSnapToGrid = snapToGrid;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's SnapToGrid property
//
HRESULT
CProxyFrame::HrGetSnapToGrid(BOOL& snapToGrid)
{
	HRESULT hr = S_OK;

	snapToGrid = m_fSnapToGrid;
	return hr;
}


// Implements setting the control's SnapToGridX property
//
HRESULT
CProxyFrame::HrSetSnapToGridX(LONG snapToGridX)
{
	HRESULT hr = S_OK;

	if ( 0 >= snapToGridX )
	{
		return DE_E_INVALIDARG;
	}

	if (m_fActivated)
	{
		VARIANT var;
		POINT pt = {0};

		VariantInit(&var);

		pt.x = snapToGridX;
		pt.y = m_ulSnapToGridY;

		V_VT(&var) = VT_BYREF;
		V_BYREF(&var) = &pt;

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_ALIGNMENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_ulSnapToGridX = snapToGridX;
	}
	else
		m_ulSnapToGridX = snapToGridX;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's SnapToGridX property
//
HRESULT
CProxyFrame::HrGetSnapToGridX(LONG& snapToGridX)
{
	HRESULT hr = S_OK;

	snapToGridX = m_ulSnapToGridX;
	return hr;
}


// Implements setting the control's SnapToGridY property
//
HRESULT
CProxyFrame::HrSetSnapToGridY(LONG snapToGridY)
{
	HRESULT hr = S_OK;

	if ( 0 >= snapToGridY )
	{
		return DE_E_INVALIDARG;
	}

	if (m_fActivated)
	{
		VARIANT var;
		POINT pt = {0};

		VariantInit(&var);
		pt.y = snapToGridY;
		pt.x = m_ulSnapToGridX;

		V_VT(&var) = VT_BYREF;
		V_BYREF(&var) = &pt;

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_ALIGNMENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_ulSnapToGridY = snapToGridY;
	}
	else
		m_ulSnapToGridY = snapToGridY;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's SnapToGridY property
//
HRESULT
CProxyFrame::HrGetSnapToGridY(LONG& snapToGridY)
{
	HRESULT hr = S_OK;

	snapToGridY = m_ulSnapToGridY;
	return hr;
}


// Implements setting the control's DocumentHTML property
//
HRESULT
CProxyFrame::HrSetDocumentHTML(BSTR bVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(bVal);

	if (NULL == bVal)
		return E_INVALIDARG;

	if (m_pCtl->IsUserMode ())
	{
		hr = DE_E_UNEXPECTED;

		AssureActivated ();
		if ( m_fActivated )
		{
			m_bstrBaseURL = L"";
			m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;
			if ( 0 == SysStringLen ( bVal ) )
			{
				CComBSTR bstrMT = GetInitialHTML ();
				hr = LoadBSTRDeferred ( bstrMT );
			}
			else
			{
				hr = LoadBSTRDeferred ( bVal );
			}

			if ( FAILED ( hr ) )
			{
				goto error;
			}

			// We've reset the contents of the control.  Go back to default save mechanism.
			m_pSite->SetSaveAsUnicode ( FALSE );
		}
	}

error:

	return hr;
}


// Implements getting the control's DocumentHTML property
//
HRESULT
CProxyFrame::HrGetDocumentHTML(BSTR* bVal)
{
	HRESULT hr			= S_OK;
	BOOL	bfWasDirty	= FALSE;

	_ASSERTE(bVal);

	if (NULL == bVal)
		return E_INVALIDARG;

	if ( m_bfIsLoading )
		return DE_E_UNEXPECTED;	// This is invalid while document is still loading.

	if ( FAILED ( hr = m_pSite->HrIsDirtyIPersistStreamInit(bfWasDirty) ) )
	{
		_ASSERTE ( SUCCEEDED ( hr ) );
		bfWasDirty = FALSE;	// what else can we do in a situation like this?
	}

	AssureActivated ();

	if (m_fActivated)
	{
		_ASSERTE(m_pSite);

		hr = m_pSite->HrSaveToBstr(bVal, m_dwFilterOutFlags );

		// Preserve original dirty state.
		if ( bfWasDirty )
		{
			SetDirtyFlag ( TRUE );
		}
	}

	return hr;
}


// Implements setting the control's SourceCodePreservation property
//
HRESULT
CProxyFrame::HrSetPreserveSource(BOOL bVal)
{
	m_fPreserveSource = bVal;
	if (m_fPreserveSource)
		m_dwFilterFlags = filterAll;
	else
		m_dwFilterFlags = filterDTCs | filterASP;

	return S_OK;
}


// Implements getting the control's SourceCodePreservation property
//
HRESULT
CProxyFrame::HrGetPreserveSource(BOOL& bVal)
{
	bVal = m_fPreserveSource;
	return S_OK;
}


// Implements getting the control's read-only IsDirty property
//
HRESULT
CProxyFrame::HrGetIsDirty(BOOL& bVal)
{
	HRESULT hr = S_OK;

	bVal = FALSE;

	AssureActivated ();

	if (m_fActivated)
	{
		hr = m_pSite->HrIsDirtyIPersistStreamInit(bVal);
	}

	return hr;
}


//	Implements getting the BaseURL property
//
HRESULT
CProxyFrame::GetBaseURL ( CComBSTR& bstrBaseURL )
{
	AssureActivated ();

	if ( NULL == m_bstrBaseURL.m_str )
	{
		bstrBaseURL = L"";
	}
	else
	{
		bstrBaseURL = m_bstrBaseURL;
	}
	return S_OK;
}


//	Implements setting the BaseURL property.
//	NOTE:
//	The BaseURL can't be (effectively) changed if there's a <BASE HREF=XXX> tag in
//	the document.  Our pluggable Protocol's CombineURL is never called in this case,
//	so don't misguide the user by changing the property.
//
//	Pay attention to m_bfBaseURLFromBASETag before calling to set the value from
//	the routine parsing the <BASE> tag!
//
HRESULT
CProxyFrame::SetBaseURL ( CComBSTR& bstrBaseURL )
{
	HRESULT hr = S_OK;

	_ASSERTE ( bstrBaseURL );

	// Non-persisted property.  Ignore if not in UserMode.
	if ( m_pCtl->IsUserMode () )
	{
		if ( m_bfBaseURLFromBASETag )
		{
			return S_FALSE;
		}
		else
		{
			if ( NULL == m_bstrBaseURL.m_str )
			{
				m_bstrBaseURL = L"";
			}

			// If this test succeedes, the user has done something like x.BaseURL = x.DOM.url or
			// x.BaseURL = y.DOM.url.
			// Response: bstrBaseURL may be the bare protocol prefix, or a prefix with a URL attached
			// for example: dhtmled0:(http://www.microsoft.com).
			// Strip off the prefix and parens (if they exist) and use the interior URL.
			if ( 0 == _wcsnicmp ( bstrBaseURL.m_str, g_wszProtocolPrefix, wcslen ( g_wszProtocolPrefix ) ) )
			{
				CComBSTR bstrNew = bstrBaseURL.m_str;

				// There must be a colon; it would be possibe to have a legitimate base url beginning with g_wszProtocolPrefix
				WCHAR* pwcURL = wcschr ( bstrNew, (WCHAR)':' );
				if ( NULL != pwcURL )
				{
					// Find the first open paren:
					pwcURL = wcschr ( pwcURL, (WCHAR)'(' );
					
					if ( NULL == pwcURL )
					{
						bstrBaseURL = L"";	// No (...)? Set the Base to empty.  Input must have been bare protocol ID.
					}
					else
					{
						pwcURL++;	// Step past the paren.

						// Strip of dhtmledXXX:( ...to... ) and set the BaseURL to what remains.
						_ASSERTE ( (WCHAR)')' == pwcURL[wcslen(pwcURL)-1] );
						if ( (WCHAR)')' == pwcURL[wcslen(pwcURL)-1] )
						{
							pwcURL[wcslen(pwcURL)-1] = (WCHAR)'\0';
							bstrBaseURL = pwcURL;
						}
						else
						{
							// Unexpected:  ill formed pluggable protocol id:
							// starts with dhtml[n[n]]:( but does not end with ).
							// If we skipped it, we would crash.  Best to use an empty base URL.
							bstrBaseURL = L"";
						}
					}
				}
			}

			if ( 0 != wcscmp ( m_bstrBaseURL.m_str, bstrBaseURL.m_str ) )
			{
				m_bstrBaseURL = bstrBaseURL;
				m_bfIsLoading = TRUE;

				// Can't Exec without a command target:
				if ( NULL != m_pSite->GetCommandTarget() )
				{
					// Reload the page, revaluating relative links.
					hr = HrExecCommand(&CGID_MSHTML, IDM_REFRESH, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
				}
			}
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Accelerator handler implementations
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Nudge accelerator handler
//	Nudge the selection in the given direction by one pixle if SnaptoGrid is off, or by
//	the SnaptoGridX/Y quantity if SnapToGrid is on.
//
HRESULT
CProxyFrame::HrNudge(DENudgeDirection dir)
{
	HRESULT		hr		= S_FALSE;
	OLECMDF		cmdf	= (OLECMDF) 0;
	VARIANT		var;
	LPVARIANT	pVarIn	= &var;
	LONG		lXDelta	= m_fSnapToGrid ? m_ulSnapToGridX : 1;
	LONG		lYDelta	= m_fSnapToGrid ? m_ulSnapToGridY : 1;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_NUDGE_ELEMENT, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		LPPOINT lpPoint = new POINT;

		if (NULL == lpPoint)
		{
			hr = E_OUTOFMEMORY;
			goto cleanup;
		}
		_ASSERTE(lpPoint);

		lpPoint->x = 0;
		lpPoint->y = 0;

		// Set increment to snap to absolute grid, not relative grid.
		// Find the selections current position and set increment modulo that position.
		// This assures the first nudge snaps to a grid corner.
		if ( m_fSnapToGrid )
		{
			POINT	ptSelPos;
			if ( SUCCEEDED ( GetSelectionPos ( &ptSelPos ) ) )
			{
				LONG lXNorm = ptSelPos.x % lXDelta;
				LONG lYNorm = ptSelPos.y % lYDelta;
				lXDelta = lXNorm ? lXNorm : lXDelta;
				lYDelta = lYNorm ? lYNorm : lYDelta;
			}
		}

		switch(dir)
		{
		case deNudgeUp:
			{
				lpPoint->x = 0;
				lpPoint->y = -lYDelta;
			}
			break;

		case deNudgeDown:
			{
				lpPoint->x = 0;
				lpPoint->y = lYDelta;
			}
			break;

		case deNudgeLeft:
			{
				lpPoint->x = -lXDelta;
				lpPoint->y = 0;
			}
			break;

		case deNudgeRight:
			{
				lpPoint->x = lXDelta;
				lpPoint->y = 0;
			}
			break;

		default: // move right by default
			{
				lpPoint->x = lXDelta;
				lpPoint->y = 0;
			}
			break;
		}

		VariantInit(pVarIn);
		V_VT(pVarIn) = VT_BYREF;
		V_BYREF(pVarIn) = lpPoint;

		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_NUDGE_ELEMENT, MSOCMDEXECOPT_DONTPROMPTUSER, pVarIn, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}
	else
		hr = S_FALSE;

cleanup:
	return hr;
}


//	Accelerator handler
//	Toggle the absolute positioned property of the selected object
//
HRESULT
CProxyFrame::HrToggleAbsolutePositioned()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_MAKE_ABSOLUTE, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_MAKE_ABSOLUTE,
			MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Accelerator handler
//	Make a link out of the current selection (with UI.)
//
HRESULT
CProxyFrame::HrHyperLink()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_HYPERLINK, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_HYPERLINK,
			MSOCMDEXECOPT_PROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Accelerator handler
//	Increase the indent of the current selection.
//
HRESULT
CProxyFrame::HrIncreaseIndent()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_INDENT, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_INDENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Accelerator handler
//	Decrease the indent of the current selection.
//
HRESULT
CProxyFrame::HrDecreaseIndent()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_OUTDENT, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_OUTDENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Check for and handle control-specific accelerators.  If none is found, call TriEdit to handle it.
//	
HRESULT
CProxyFrame::HrHandleAccelerator(LPMSG lpmsg)
{
	HRESULT hr = S_FALSE;
	BOOL fControl = (0x8000 & GetKeyState(VK_CONTROL));
	BOOL fShift = (0x8000 & GetKeyState(VK_SHIFT));
	BOOL fAlt = (0x8000 & GetKeyState(VK_MENU));

    if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_UP)
	{
		hr = HrNudge(deNudgeUp);
	}
    else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_DOWN)
	{
		hr = HrNudge(deNudgeDown);
	}
    else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_LEFT)
	{
		hr = HrNudge(deNudgeLeft);
	}
    else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_RIGHT)
	{
		hr = HrNudge(deNudgeRight);
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'K' && fControl)
	{
		hr = HrToggleAbsolutePositioned();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'L' && fControl && !fAlt)
	{
		hr = HrHyperLink();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'T' && !fShift && fControl)
	{
		hr = HrIncreaseIndent();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'T' && fShift && fControl)
	{
		hr = HrDecreaseIndent();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_TAB && fControl)
	{
		// Process control-tab keys as belonging to the container; this allows the user
		// to tab out of the control in non-MDI apps.  MDI uses control-tab to switch
		// windows, thus these apps (like VID) do not pass them to us.
		IOleControlSite* piControlSite = m_pCtl->GetControlSite ();
		_ASSERTE ( piControlSite );
		if ( NULL != piControlSite )
		{
			// Eat the control key, but preserve shift to perform reverse tabbing.
			// KEYMOD_SHIFT = 0x00000001, but isn't defined in any header...
			DWORD dwModifiers = fShift ? 1 : 0;

			hr = piControlSite->TranslateAccelerator ( lpmsg, dwModifiers );
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	BaseURL helper routines
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Override the default BaseURL if there is one or more <BASE HREF=...> tags
//	in the document.  If successful, set m_bfBaseURLFromBASETag to TRUE
//	If multiple BASE tags exist, simply use the last one.
//	Equivilent script:  baseurl = document.all.tags("BASE")[<LAST>].href,
//	where <LAST> is derived.
//
HRESULT
CProxyFrame::SetBaseURLFromBaseHref ()
{
	HRESULT		hr	= S_OK;
	CComBSTR	bstrBase;

	if ( !m_bfBaseURLFromBASETag )
	{
		if ( SUCCEEDED ( hr ) )
		{
			CComPtr<IHTMLDocument2> spHtmlDoc = NULL;
			hr = HrGetDoc( &spHtmlDoc );
			if ( spHtmlDoc && SUCCEEDED ( hr ) )
			{
				CComPtr<IHTMLElementCollection> spAll = NULL;
				hr = spHtmlDoc->get_all ( &spAll );
				if ( spAll && SUCCEEDED ( hr ) )
				{
					CComVariant varTag		= L"BASE";
					IDispatch*	piDispTags	= NULL;

					hr = spAll->tags ( varTag, &piDispTags );
					if ( piDispTags && SUCCEEDED ( hr ) )
					{
						CComQIPtr<IHTMLElementCollection, &IID_IHTMLElementCollection> spBases (piDispTags);
						piDispTags->Release ();
						piDispTags = NULL;
						if ( spBases )
						{
							long	cBases = 0;
							hr = spBases->get_length ( &cBases );
							if ( SUCCEEDED ( hr ) && ( 0 != cBases ) )
							{
								CComVariant varName;
								varName.vt = VT_I2;

								for ( varName.iVal = 0; varName.iVal < cBases; varName.iVal++ )
								{
									IDispatch*	piDispBase = NULL;
									CComVariant varValue;

									hr = spBases->item ( varName, varName, &piDispBase );
									if ( piDispBase && SUCCEEDED ( hr ) )
									{
										CComQIPtr<IHTMLElement, &IID_IHTMLElement> spElem ( piDispBase );
										piDispBase->Release ();
										piDispBase = NULL;

										if ( spElem )
										{
											varValue.Clear ();
											hr = spElem->getAttribute ( L"HREF", FALSE, &varValue );
											if ( SUCCEEDED ( hr ) )
											{
												hr = varValue.ChangeType ( VT_BSTR );
												if ( SUCCEEDED ( hr ) )
												{
													if ( 0 != SysStringLen ( varValue.bstrVal ) )
													{
														bstrBase = varValue.bstrVal;
													}
												}
											}
										}
									}
								}
								if ( 0 != bstrBase.Length () )
								{
									hr = SetBaseURL ( bstrBase );	// This clears m_bfBaseURLIsDefault
									m_bfBaseURLFromBASETag = TRUE;
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
}


//	Set the m_bstrBaseURL value using m_bstrCurDocPath.
//	With URLs, it may be impossible to be certain about the correct BaseURL,
//	so make an intellegent guess.  With files, it should be deterministic.
//	
HRESULT
CProxyFrame::SetBaseURLFromCurDocPath ( BOOL bfIsURL )
{
	m_bfBaseURLFromBASETag = FALSE;	// We're reloading: whipe this out.
	if ( bfIsURL )
	{
		return SetBaseURLFromURL ( m_bstrCurDocPath );
	}
	else
	{
		return SetBaseURLFromFileName ( m_bstrCurDocPath );
	}
}


//	Given a URL_COMPONENTS with nScheme set to INTERNET_SCHEME_FILE,
//	modify the path part to reflect the base path, reconstruct the URL,
//	and set m_bstrBaseURL.
//	Separators may be \ or /.
//
HRESULT
CProxyFrame::SetBaseUrlFromFileUrlComponents ( URL_COMPONENTS & urlc )
{
	TCHAR*	pszPath;
	BOOL	bfBackSlash	= TRUE;
	HRESULT	hr			= S_OK;

	_ASSERTE ( INTERNET_SCHEME_FILE == urlc.nScheme );
	_ASSERTE ( urlc.dwUrlPathLength );
	if ( urlc.dwUrlPathLength <= 0)
	{
		return E_UNEXPECTED;
	}
	pszPath = new TCHAR [urlc.dwUrlPathLength + 3];	// Extra room for \0, dot, and /.
	if ( NULL != pszPath )
	{
		TCHAR	c		= 0;
		int		iPos	= 0;

		// Scan backwards and modify in copy (never in BSTR, please) for beginning, '/' or '\'
		memcpy ( pszPath, urlc.lpszUrlPath, ( urlc.dwUrlPathLength + 1 ) * sizeof(TCHAR) );
		for ( iPos = urlc.dwUrlPathLength - 1; iPos >= 0; iPos-- )
		{
			c = pszPath[iPos];
			pszPath[iPos] = '\0';	// Delete first, ask questions later.  '\' must go.
			if ( '\\' == c )
			{
				break;
			}
			if ( '/' == c )
			{
				bfBackSlash = FALSE;
				break;
			}
		}

		// Space was reserved for an additional two characters, if needed.
		// If empty, add a dot.
		if ( 0 == _tcslen ( pszPath ) )
		{
			_tcscat ( pszPath, TEXT(".") );
		}
		// Add a / or \.
		if ( bfBackSlash )
		{
			_tcscat ( pszPath, TEXT("\\") );
		}
		else
		{
			_tcscat ( pszPath, TEXT("/") );
		}

		urlc.lpszUrlPath = pszPath;
		urlc.dwUrlPathLength = _tcslen ( pszPath );

		DWORD	dwLen = 0;
#ifdef LATE_BIND_URLMON_WININET
		_ASSERTE ( m_pfnInternetCreateUrl );
		(*m_pfnInternetCreateUrl)( &urlc, 0, NULL, &dwLen );	// Get the size required.
#else
		InternetCreateUrl ( &urlc, 0, NULL, &dwLen );	// Get the size required.
#endif // LATE_BIND_URLMON_WININET

		_ASSERTE ( 0 != dwLen );
		TCHAR* pszURL = new TCHAR [ dwLen + 1 ];
		_ASSERTE ( pszURL );
		if ( NULL != pszURL )
		{
			// Incredibly, on Win98, the URL is terminated with a single byte \0.
			// Intializing this buffer to zero assures full termination of the string.
			dwLen += 1;
			memset ( pszURL, 0, sizeof(TCHAR) * dwLen );
#ifdef LATE_BIND_URLMON_WININET
			if ( (*m_pfnInternetCreateUrl)( &urlc, 0, pszURL, &dwLen ) )
#else
			if ( InternetCreateUrl ( &urlc, 0, pszURL, &dwLen ) )
#endif // LATE_BIND_URLMON_WININET
			{
				m_bstrBaseURL = pszURL;
			}
			else
			{
				hr = HRESULT_FROM_WIN32 ( GetLastError () );
			}
			delete [] pszURL;
		}

		delete [] pszPath;
	}
	else
	{
		return E_FAIL;
	}

	return hr;
}


//	The most complicated scenario for "guessing" at the base URL.
//	URLs like http://www.x.com/stuff could be either a file or a directory;
//	a default page might actually be loaded.  We guess based on whether or
//	not the last item in the path contains a period.  If so, we eliminate it.
//	We make sure the path ends with a '/'.
//
HRESULT
CProxyFrame::SetBaseUrlFromUrlComponents ( URL_COMPONENTS & urlc )
{
	_ASSERTE ( INTERNET_SCHEME_FILE != urlc.nScheme );

	BOOL	bfPeriodIncluded	= FALSE;
	HRESULT	hr					= S_OK;

	if ( 0 == urlc.dwSchemeLength )
	{
		m_bstrBaseURL = L"";
		return S_FALSE;
	}

	// Scan backwards over path for beginning, '/'
	TCHAR	c		= 0;
	int		iPos	= 0;

	for ( iPos = urlc.dwUrlPathLength - 1; iPos >= 0; iPos-- )
	{
		c = urlc.lpszUrlPath[iPos];
		if ( '/' == c )
		{
			break;
		}
		if ( '.' == c )
		{
			bfPeriodIncluded = TRUE;
		}
	}

	if ( bfPeriodIncluded )
	{
		if ( 0 > iPos ) iPos = 0;
		urlc.lpszUrlPath[iPos] = '\0';	// Truncate at the '/', or beginning
		urlc.dwUrlPathLength = _tcslen ( urlc.lpszUrlPath );
	}

	// Recreate the URL:
	DWORD	dwLen = 0;
#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnInternetCreateUrl );
	(*m_pfnInternetCreateUrl)( &urlc, 0, NULL, &dwLen );	// Get the size required.
#else
	InternetCreateUrl ( &urlc, 0, NULL, &dwLen );	// Get the size required.
#endif // LATE_BIND_URLMON_WININET

	_ASSERTE ( 0 != dwLen );
	TCHAR* pszURL = new TCHAR [ dwLen + 1 ];
	_ASSERTE ( pszURL );
	if ( NULL != pszURL )
	{
		dwLen += 1;
		memset ( pszURL, 0, sizeof(TCHAR) * dwLen );
#ifdef LATE_BIND_URLMON_WININET
		if ( (*m_pfnInternetCreateUrl)( &urlc, 0, pszURL, &dwLen ) )
#else
		if ( InternetCreateUrl ( &urlc, 0, pszURL, &dwLen ) )
#endif
		{
			m_bstrBaseURL = pszURL;

			// Append a '/' if needed.
			WCHAR wc = m_bstrBaseURL.m_str[m_bstrBaseURL.Length () - 1];
			if ( ( WCHAR('/') != wc ) && ( NULL != urlc.lpszHostName ) )	// hostname: special case for user pluggable protocols
			{
				m_bstrBaseURL += L"/";
			}
		}
		else
		{
			hr = HRESULT_FROM_WIN32 ( GetLastError () );
		}
		delete [] pszURL;
	}
	return hr;
}


//	Crack the URL, determine if it's a file scheme or other, and call the appropriate handler.
//
HRESULT
CProxyFrame::SetBaseURLFromURL ( const CComBSTR& bstrURL )
{
	USES_CONVERSION;

	HRESULT			hr	= S_OK;
	URL_COMPONENTS	urlc;
	TCHAR			*ptszScheme		= NULL;
	TCHAR			*ptszHostName	= NULL;
	TCHAR			*ptszUrlPath	= NULL;
	BOOL			fSuccess		= FALSE;
	TCHAR*			tszURL			= NULL;

	_ASSERTE ( 0 != bstrURL.Length () );

	tszURL = OLE2T ( bstrURL );
	_ASSERTE ( tszURL );
	if ( NULL == tszURL )
	{
		return E_OUTOFMEMORY;
	}

	memset ( &urlc, 0, sizeof ( urlc ) );
	urlc.dwStructSize		= sizeof ( urlc );
	urlc.dwSchemeLength		= 1;
	urlc.dwHostNameLength	= 1;
	urlc.dwUrlPathLength	= 1;

#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnInternetCrackUrl );
	fSuccess = (*m_pfnInternetCrackUrl)( tszURL, 0, 0, &urlc );
#else
	fSuccess = InternetCrackUrl ( tszURL, 0, 0, &urlc );
#endif // LATE_BIND_URLMON_WININET

	if ( !fSuccess )
	{
		return E_FAIL;
	}

	if ( 0 != urlc.dwSchemeLength )
	{
		urlc.dwSchemeLength++;
		ptszScheme		= new TCHAR[urlc.dwSchemeLength];
		urlc.lpszScheme	= ptszScheme;
		if ( NULL == ptszScheme )
			goto ONERROR;
	}
	if ( 0 != urlc.dwHostNameLength )
	{
		urlc.dwHostNameLength++;
		ptszHostName		= new TCHAR[urlc.dwHostNameLength];
		urlc.lpszHostName	= ptszHostName;
		if ( NULL == ptszHostName )
			goto ONERROR;
	}
	if ( 0 != urlc.dwUrlPathLength )
	{
		urlc.dwUrlPathLength++;
		ptszUrlPath			= new TCHAR[urlc.dwUrlPathLength];
		urlc.lpszUrlPath	= ptszUrlPath;
		if ( NULL == ptszUrlPath )
			goto ONERROR;
	}

#ifdef LATE_BIND_URLMON_WININET
	fSuccess = (*m_pfnInternetCrackUrl)( tszURL, 0, 0, &urlc );
#else
	fSuccess = InternetCrackUrl ( tszURL, 0, 0, &urlc );
#endif
	
	if ( fSuccess )
	{
		if ( INTERNET_SCHEME_FILE == urlc.nScheme )
		{
			hr = SetBaseUrlFromFileUrlComponents ( urlc );
		}
		else
		{
			hr = SetBaseUrlFromUrlComponents ( urlc );
		}
	}

ONERROR:
	if ( ptszScheme )
		delete [] ptszScheme;
	if ( ptszHostName )
		delete [] ptszHostName;
	if ( ptszUrlPath )
		delete [] ptszUrlPath;

	return hr;
}


//	Given a UNC file name, set the m_bstrBaseURL member variable.
//	if bstrFName is empty, set m_bstrBaseURL to empty.
//	Else, scan backward to the first "\" or the beginning of the string.
//	Truncate the string at this point.  If the resultant string is empty,
//	add ".".  Then, add "\".
//
HRESULT
CProxyFrame::SetBaseURLFromFileName ( const CComBSTR& bstrFName )
{
	if ( 0 == bstrFName.Length () )
	{
		m_bstrBaseURL = L"";
	}
	else
	{
		WCHAR* pwzstr = new WCHAR[bstrFName.Length () + 1];
		_ASSERTE ( pwzstr );
		if ( NULL != pwzstr )
		{
			WCHAR	wc		= 0;
			int		iPos	= 0;

			// Scan backwards and modify in copy (never in BSTR, please) for beginning or '\'
			memcpy ( pwzstr, bstrFName.m_str, sizeof(WCHAR) * (bstrFName.Length () + 1) );
			for ( iPos = wcslen ( pwzstr ) - 1; iPos >= 0; iPos-- )
			{
				wc = pwzstr[iPos];
				pwzstr[iPos] = WCHAR('\0');	// Delete first, ask questions later.  '\' must go.
				if ( WCHAR('\\') == wc )
				{
					break;
				}
			}
			m_bstrBaseURL = pwzstr;
			delete [] pwzstr;

			// If empty, add a '.'
			if ( 0 == m_bstrBaseURL.Length () )
			{
				m_bstrBaseURL += L".";
			}
			m_bstrBaseURL += L"\\";
		}
		else
		{
			return E_FAIL;
		}
	}
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Security oriented routines
//
///////////////////////////////////////////////////////////////////////////////////////////


//	This is a critical security issue:
//	The pluggable protocol's ParseURL is called with PARSE_SECURITY_URL in the SFS control.
//	If the BaseURL is empty, and if we're hosted in Trident, we should return the
//	URL of the hosting page.
//	If there is no Trident host, say we're hosted in VB, return the bootdrive + : + /.
//	Bootdrive is not always C.
//
HRESULT
CProxyFrame::GetSecurityURL (CComBSTR& bstrSecurityURL )
{
	HRESULT			hr						= S_OK;
	IOleClientSite	*piClientSiteUnreffed	= NULL;

	bstrSecurityURL = L"";
	
	piClientSiteUnreffed = m_pCtl->m_spClientSite;
	if ( NULL != piClientSiteUnreffed )
	{
		CComPtr<IOleContainer> spContainer = NULL;
		hr = piClientSiteUnreffed->GetContainer ( &spContainer );
		if ( SUCCEEDED ( hr ) && spContainer )
		{
			CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> spHostDoc ( spContainer );
			if ( spHostDoc )
			{
				CComPtr<IHTMLLocation> spHostLoc = NULL;


				spHostDoc->get_location ( &spHostLoc );
				if ( spHostLoc )
				{
					BSTR bsOut;
					hr = spHostLoc->get_href ( &bsOut );
					if ( SUCCEEDED ( hr ) )
					{
						bstrSecurityURL.Empty ();
						bstrSecurityURL.Attach ( bsOut );
					}
				}
			}
			else
			{
				// If we are not hosted in Trident, use local machine access:
				TCHAR	tszDrive[4];
				GetModuleFileName ( _Module.m_hInst, tszDrive, 3 );	// Get X:\.
				_ASSERTE ( TCHAR(':') == tszDrive[1] );
				_ASSERTE ( TCHAR('\\') == tszDrive[2] );
				bstrSecurityURL = tszDrive;
				hr = S_OK;
			}
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Pluggable protocol oriented routines
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Register our pluggable protocol handler so dhtmledN[N...] is loaded by our code.
//
HRESULT
CProxyFrame::RegisterPluggableProtocol()
{
	HRESULT hr;

	// Get InternetSession

	CComPtr<IInternetSession> srpSession;
#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnCoInternetGetSession );
	hr = (*m_pfnCoInternetGetSession)(0, &srpSession, 0);
#else
	hr = CoInternetGetSession (0, &srpSession, 0);
#endif // LATE_BIND_URLMON_WININET

	if ( FAILED ( hr ) )
	{
		return hr;
	}

	if(m_pProtInfo == NULL)
	{
		hr = CComObject<CDHTMLEdProtocolInfo>::CreateInstance(&m_pProtInfo);
		if ( FAILED ( hr ) )
		{
			return hr;
		}

		// CreateInstance - doesnt AddRef
		m_pProtInfo->GetUnknown()->AddRef();
	}

	hr = srpSession->RegisterNameSpace(
						static_cast<IClassFactory*>(m_pProtInfo),
						CLSID_DHTMLEdProtocol,
						m_wszProtocol,
						0,
						NULL,
						0);

	if ( FAILED ( hr ) )
	{
		return hr;
	}

	CComQIPtr <IProtocolInfoConnector, &IID_IProtocolInfoConnector> piPic ( m_pProtInfo );
	_ASSERTE ( piPic );
	piPic->SetProxyFrame ( (SIZE_T*)this );

	ATLTRACE( _T("CProxyFrame::Registered ProtocolInfo\n"));

	return NOERROR;
}

//	Unregister the pluggable protocol handler installed in RegisterPluggableProtocol
//
HRESULT
CProxyFrame::UnRegisterPluggableProtocol()
{
	if(m_pProtInfo == NULL)
		return E_UNEXPECTED;

	// Get InternetSession

	HRESULT hr;
	CComPtr<IInternetSession> srpSession;

#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnCoInternetGetSession );
	hr = (*m_pfnCoInternetGetSession)(0, &srpSession, 0);
#else
	hr = CoInternetGetSession (0, &srpSession, 0);
#endif // LATE_BIND_URLMON_WININET

	if(SUCCEEDED(hr))
	{
		// UnRegister Protocol

		srpSession->UnregisterNameSpace(
							static_cast<IClassFactory*>(m_pProtInfo),
							m_wszProtocol);

	}

	m_pProtInfo->GetUnknown()->Release();
	m_pProtInfo = NULL;

	ATLTRACE(_T("CProxyFrame::UnRegistered ProtocolInfo\n"));

	return NOERROR;
}


//	Workhorse routine that actually performs the loading of the control, including filtering.
//	ParseAndBind calls this to retrieve the data to be displayed in the control.
//
HRESULT
CProxyFrame::GetFilteredStream ( IStream** ppStream )
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPTSTR pFileName = NULL;
	CComPtr<IStream> piStream;
	BOOL	bfLoadingFromBSTR = ( 0 != m_bstrLoadText.Length () );

	*ppStream = NULL;
	m_bfReloadAttempted = TRUE;

	if ( !bfLoadingFromBSTR )
	{
		_ASSERTE(m_bstrCurDocPath);

		pFileName = OLE2T(m_bstrCurDocPath);

		_ASSERTE(pFileName);

		if (NULL == pFileName)
			return E_OUTOFMEMORY;
	}

	if ( bfLoadingFromBSTR )
	{
		hr = m_pSite->HrBstrToStream(m_bstrLoadText, &piStream);
	}
	else if ( m_bfIsURL )
	{
		hr = m_pSite->HrURLToStream(pFileName, &piStream);
	}
	else
	{
		hr = m_pSite->HrFileToStream(pFileName, &piStream);
	}

	if (FAILED( hr ))
	{
		m_bstrCurDocPath.Empty ();
		m_bstrBaseURL.Empty ();

		// Get TriEdit into a reasonable state by loading an empty document
		// If we reinstanced successfully, this should never fail
		// Also, this will make ignoring the above assert benign
		if (FAILED(m_pSite->HrBstrToStream(m_bstrInitialDoc, ppStream)))
		{
			_ASSERTE(SUCCEEDED(hr));
		}

	}
	else
	{
		if ( m_vbBrowseMode )
		{
			piStream.p->AddRef ();
			*ppStream = piStream;
		}
		else
		{
			hr = m_pSite->HrFilter(TRUE, piStream, ppStream, m_dwFilterFlags);
		}

		if (FAILED(hr))
		{
			m_pSite->HrBstrToStream(m_bstrInitialDoc, ppStream);
		}
		else
		{
			m_dwFilterOutFlags = m_dwFilterFlags;
		}
	}

	// Store the result to return from the (indirectly) called routine,
	// but don't return an error to ParseAndBind!
	if ( FAILED(hr) && ( ! bfLoadingFromBSTR ) )
	{
		m_hrDeferredLoadError = hr;	// Stash this away, we'll pic it up in LoadDocument
		hr = S_OK;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Document event handling routines
//
///////////////////////////////////////////////////////////////////////////////////////////


HRESULT
CProxyFrame::OnTriEditEvent ( const GUID& iidEventInterface, DISPID dispid )
{
	HRESULT hr = S_OK;

	if ( DIID_HTMLDocumentEvents == iidEventInterface )
	{
		switch ( dispid )
		{
			case DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS:
			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN:
				if ( DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN == dispid )
				{
					m_pCtl->Fire_onmousedown();
				}
				else if ( DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS == dispid )
				{
					m_pCtl->Fire_onkeypress();
				}

				// Make the control UIActive if it was clicked in.  Since the DocObject swallows the clicks,
				// the control isn't activated automatically.
				// Not needed in browse mode.
				if (  !m_pCtl->m_bUIActive && ! m_vbBrowseMode )
				{
					m_pCtl->DoVerbUIActivate ( NULL, NULL );
					if ( m_hWndObj != NULL )
					{
						::SetFocus( m_hWndObj );
					}
				}
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE:
				m_pCtl->Fire_onmousemove();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP:
				m_pCtl->Fire_onmouseup();
				// onclick is not delivered in edit mode.  First one lost in broswe mode.
				m_pCtl->Fire_onclick();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOUT:
				m_pCtl->Fire_onmouseout();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOVER:
				m_pCtl->Fire_onmouseover();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONCLICK:
				// We do not fire the onclick event in response.
				// It is only delivered in browse mode, and in addition,
				// the first onclick is lost.  We fire on onmouseup.
				//m_pCtl->Fire_onclick();

				// The addition of the DesignMode property, in addition to <BASE TARGET="_top">
				// makes links exploitable for cross-zone access in the SFS control.
				// We must disable clicks (user and script) in the SFS control to prevent this.
				if ( m_pCtl->IsSafeForScripting ())
				{
					CComPtr<IHTMLDocument2>	spHtmlDoc;
					hr = HrGetDoc ( &spHtmlDoc );
					if ( SUCCEEDED ( hr ) && spHtmlDoc )
					{
						CComPtr<IHTMLWindow2> spWindow;

						hr = spHtmlDoc->get_parentWindow ( &spWindow );
						if ( SUCCEEDED ( hr ) && spWindow )
						{
							CComPtr<IHTMLEventObj> spEvt;
							hr = spWindow->get_event ( &spEvt );
							if ( SUCCEEDED ( hr ) && spEvt )
							{
								CComVariant varFalse(VARIANT_FALSE);

								spEvt->put_cancelBubble ( VARIANT_TRUE );
								spEvt->put_returnValue ( varFalse );
							}
						}
					}
				}

				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK:
				m_pCtl->Fire_ondblclick();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN:
				m_pCtl->Fire_onkeydown();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONKEYUP:
				m_pCtl->Fire_onkeyup();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE:
				m_pCtl->Fire_onreadystatechange();
				break;

			default:
				_ASSERTE ( TRUE );
				break;
		}
	}
	else if ( DIID_HTMLWindowEvents == iidEventInterface )
	{
		// I expected to get these, but I'm not...
		switch ( dispid )
		{
			case DISPID_HTMLWINDOWEVENTS_ONLOAD:
			case DISPID_HTMLWINDOWEVENTS_ONUNLOAD:
			case DISPID_HTMLWINDOWEVENTS_ONHELP:
			case DISPID_HTMLWINDOWEVENTS_ONFOCUS:
			case DISPID_HTMLWINDOWEVENTS_ONBLUR:
			case DISPID_HTMLWINDOWEVENTS_ONERROR:
			case DISPID_HTMLWINDOWEVENTS_ONRESIZE:
			case DISPID_HTMLWINDOWEVENTS_ONSCROLL:
			case DISPID_HTMLWINDOWEVENTS_ONBEFOREUNLOAD:
				hr = S_OK;
				break;
			
			default:
				_ASSERTE ( TRUE );
				break;
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Dynamic loading routines, used in 4.0 versions
//
///////////////////////////////////////////////////////////////////////////////////////////


#ifdef LATE_BIND_URLMON_WININET
//	Load Urlmon and Wininet and get the proc addresses of every routine we use.
//	We must be able to register the control, even if these libraries are not installed.
//	NOTE:
//	This routine loads ANSI versions.  Needs addaptation for UNICODE.
//
BOOL CProxyFrame::DynLoadLibraries ()
{
	m_hUlrMon	= LoadLibrary ( TEXT("URLMON.DLL") );
	m_hWinINet	= LoadLibrary ( TEXT("WININET.DLL") );
	if ( ( NULL == m_hUlrMon ) || ( NULL == m_hWinINet ) )
	{
		DynUnloadLibraries ();
		return FALSE;
	}

	m_pfnCoInternetCombineUrl	= (PFNCoInternetCombineUrl)GetProcAddress (
									m_hUlrMon, "CoInternetCombineUrl" );
									_ASSERTE ( m_pfnCoInternetCombineUrl );
	m_pfnCoInternetParseUrl		= (PFNCoInternetParseUrl)GetProcAddress (
									m_hUlrMon, "CoInternetParseUrl" );
									_ASSERTE ( m_pfnCoInternetParseUrl );
	m_pfnCreateURLMoniker		= (PFNCreateURLMoniker)GetProcAddress (
									m_hUlrMon, "CreateURLMoniker" );
									_ASSERTE ( m_pfnCreateURLMoniker );
	m_pfnCoInternetGetSession	= (PFNCoInternetGetSession)GetProcAddress (
									m_hUlrMon, "CoInternetGetSession" );
									_ASSERTE ( m_pfnCoInternetGetSession );
	m_pfnURLOpenBlockingStream	= (PFNURLOpenBlockingStream)GetProcAddress (
									m_hUlrMon, "URLOpenBlockingStreamA" );
									_ASSERTE ( m_pfnURLOpenBlockingStream );

	m_pfnDeleteUrlCacheEntry	= (PFNDeleteUrlCacheEntry)GetProcAddress (
									m_hWinINet, "DeleteUrlCacheEntry" );
									_ASSERTE ( m_pfnDeleteUrlCacheEntry );
	m_pfnInternetCreateUrl		= (PFNInternetCreateUrl)GetProcAddress (
									m_hWinINet, "InternetCreateUrlA" );
									_ASSERTE ( m_pfnInternetCreateUrl );
	m_pfnInternetCrackUrl		= (PFNInternetCrackURL)GetProcAddress (
									m_hWinINet, "InternetCrackUrlA" );
									_ASSERTE ( m_pfnInternetCrackUrl );

	return ( m_pfnCoInternetCombineUrl && m_pfnCoInternetParseUrl && m_pfnCreateURLMoniker &&
		m_pfnCoInternetGetSession && m_pfnURLOpenBlockingStream && m_pfnDeleteUrlCacheEntry &&
		m_pfnInternetCreateUrl && m_pfnInternetCrackUrl );
}


//	Release the libraries loaded by DynLoadLibraries
//
void CProxyFrame::DynUnloadLibraries ()
{
	if ( NULL != m_hUlrMon )
	{
		FreeLibrary ( m_hUlrMon );
		m_hUlrMon = NULL;
	}
	if ( NULL != m_hWinINet )
	{
		FreeLibrary ( m_hWinINet );
		m_hWinINet = NULL;
	}

	m_pfnCoInternetCombineUrl	= NULL;
	m_pfnCoInternetParseUrl		= NULL;
	m_pfnCreateURLMoniker		= NULL;
	m_pfnCoInternetGetSession	= NULL;
	m_pfnURLOpenBlockingStream	= NULL;

	m_pfnDeleteUrlCacheEntry	= NULL;
	m_pfnInternetCreateUrl		= NULL;
	m_pfnInternetCrackUrl		= NULL;
}
#endif // LATE_BIND_URLMON_WININET


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Utility routines
//
///////////////////////////////////////////////////////////////////////////////////////////

//	Return the IHTMLDocument2 pointer from the hosted doc.
//
HRESULT
CProxyFrame::HrGetDoc(IHTMLDocument2 **ppDoc)
{
	HRESULT hr = E_FAIL;
	IUnknown* lpUnk = m_pSite->GetObjectUnknown();

	if (FALSE == m_fActivated)
		return DE_E_UNEXPECTED;

	_ASSERTE(ppDoc);

	if (NULL == ppDoc)
		return DE_E_INVALIDARG;

	_ASSERTE(lpUnk);

	if ( m_bfIsLoading )
		return DE_E_UNEXPECTED;	// This is invalid while document is still loading.

	if (lpUnk != NULL)
	{
		// Request the "document" object from the MSHTML
		*ppDoc = NULL;
		hr = lpUnk->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
	}

	_ASSERTE(SUCCEEDED(hr)); // this should always succeed
	return hr;
}


//	Helper routine to set any Boolean Trident property
//
HRESULT
CProxyFrame::HrTridentSetPropBool(ULONG cmd, BOOL bVal)
{
	HRESULT hr = S_OK;
	VARIANT varIn;

	VariantInit(&varIn);
	V_VT(&varIn) = VT_BOOL;

#pragma warning(disable: 4310) // cast truncates constant value
	bVal ? V_BOOL(&varIn) = VARIANT_TRUE : V_BOOL(&varIn) = VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

	hr = HrExecCommand(&CGID_MSHTML, cmd, MSOCMDEXECOPT_DONTPROMPTUSER, &varIn, NULL);

	// this should always succeed since all props 
	// should be set in correct phases of Trident creation

	_ASSERTE(SUCCEEDED(hr)); 
	return hr;
}


//	Helper routine to get any Boolean Trident property
//
HRESULT
CProxyFrame::HrTridentGetPropBool(ULONG cmd, BOOL& bVal)
{
	HRESULT hr = S_OK;
	OLECMDF cmdf = (OLECMDF) 0;

	if (SUCCEEDED(HrQueryStatus(&CGID_MSHTML, cmd, &cmdf)))
	{
		bVal = (cmdf & OLECMDF_ENABLED) == OLECMDF_ENABLED ? TRUE : FALSE;
	}

	// this should always succeed since all props 
	// should be set in correct phases of Trident creation

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


//	Store the BSTR so LoadFilteredStream can access it, and load a URL with our protocol
//	to kick off the load/resolve/display through the pluggable protocol handler.
//
//	Clear the BaseURL, and mark the control "Loading..."
//
HRESULT
CProxyFrame::LoadBSTRDeferred ( BSTR bVal )
{
	HRESULT	hr	= E_FAIL;

	_ASSERTE ( m_pUnkTriEdit );

	m_bstrLoadText = bVal;

	CComPtr<IMoniker> srpMoniker;
	CComPtr<IBindCtx> srpBindCtx;
	CComQIPtr<IPersistMoniker, &IID_IPersistMoniker> srpPM (m_pUnkTriEdit);
	_ASSERTE ( srpPM );

	if ( srpPM )
	{
#ifdef LATE_BIND_URLMON_WININET
		_ASSERTE ( m_pfnCreateURLMoniker );
		hr = (*m_pfnCreateURLMoniker)( NULL, m_wszProtocolPrefix, &srpMoniker );
#else
		hr = CreateURLMoniker ( NULL, m_wszProtocolPrefix, &srpMoniker );
#endif // LATE_BIND_URLMON_WININET

		_ASSERTE ( SUCCEEDED( hr ) );
		if ( SUCCEEDED ( hr ) )
		{
			hr = ::CreateBindCtx(NULL, &srpBindCtx);
			_ASSERTE ( SUCCEEDED( hr ) );
			if ( SUCCEEDED ( hr ) )
			{
				m_bfIsLoading = TRUE;
				m_bfBaseURLFromBASETag = FALSE;

				hr = srpPM->Load(FALSE, srpMoniker,  srpBindCtx, STGM_READ);

				_ASSERTE ( SUCCEEDED( hr ) );
			}
		}
	}
	return hr;
}


//	Set the document stream's dirty flag
//
HRESULT
CProxyFrame::SetDirtyFlag ( BOOL bfMakeDirty )
{
	CComVariant varDirty;

	varDirty = bfMakeDirty ? true : false;

	return HrExecCommand(&CGID_MSHTML, IDM_SETDIRTY, MSOCMDEXECOPT_DONTPROMPTUSER, &varDirty, NULL);
}


// properties that can be set only after TriEdit is in running state
HRESULT
CProxyFrame::HrSetRuntimeProperties()
{
	HRESULT hr = S_OK;

	if (FAILED(hr = HrSetPropActivateControls(m_fActivateControls)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetPropActivateApplets(m_fActivateApplets)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetPropActivateDTCs(m_fActivateDTCs)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	// toggle properties

	if (FAILED(hr = HrSetPropShowAllTags(m_fShowAllTags)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}


	if (FAILED(hr = HrSetPropShowBorders(m_fShowBorders)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

error:

	return hr;
}


HRESULT
CProxyFrame::HrGetCurrentDocumentPath(BSTR* bVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(bVal);

	if (NULL == bVal)
		return E_INVALIDARG;

	*bVal = m_bstrCurDocPath.Copy ();
	return hr;
}


// properties that can only be set after UIActivation
HRESULT
CProxyFrame::HrSetDocLoadedProperties()
{
	HRESULT hr = S_OK;
	BOOL bGoodUndoBehavior = TRUE;

	bGoodUndoBehavior = TRUE;
	if (FAILED(HrTridentGetPropBool(IDM_GOOD_UNDO_BEHAVIOR, bGoodUndoBehavior)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetAbsoluteDropMode(m_fAbsoluteDropMode)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetSnapToGridX(m_ulSnapToGridX)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetSnapToGridY(m_ulSnapToGridY)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetSnapToGrid(m_fSnapToGrid)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

error:

	return hr;
}


//	HrExecInsertTable helper.  Extract the safearrys
//
HRESULT
CProxyFrame::HrGetTableSafeArray(IDEInsertTableParam* pTable, LPVARIANT pVarIn)
{
	HRESULT hr					= S_OK;
	UINT i						= 0;
	SAFEARRAY FAR* psa			= NULL;
	SAFEARRAYBOUND rgsabound[1] = {0};
	LONG ix[1]					= {0};
	VARIANT varElem;
	LONG  nNumRows				= 0;
	LONG  nNumCols				= 0;
	BSTR bstrTableAttrs			= NULL;
	BSTR bstrCellAttrs			= NULL;
	BSTR bstrCaption			= NULL;

	_ASSERTE(pTable);

	if (FAILED(hr = pTable->get_NumRows(&nNumRows)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	if (FAILED(hr = pTable->get_NumCols(&nNumCols)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	if (FAILED(hr = pTable->get_TableAttrs(&bstrTableAttrs)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}
	_ASSERTE(bstrTableAttrs);

	if (FAILED(hr = pTable->get_CellAttrs(&bstrCellAttrs)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}
	_ASSERTE(bstrCellAttrs);

	if (FAILED(hr = pTable->get_Caption(&bstrCaption)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}
	_ASSERTE(bstrCaption);

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = 5;

	psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);	
	_ASSERTE(psa);

	if(NULL == psa)
		return E_OUTOFMEMORY;

	VariantInit(pVarIn);
	V_VT(pVarIn) = VT_ARRAY;
	V_ARRAY(pVarIn) = psa;

	i=0;

	// elmement 1: number of rows
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_I4;
	V_I4(&varElem) = nNumRows; 
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 2: number of columns
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_I4;
	V_I4(&varElem) = nNumCols;
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 3: table tag attributes
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_BSTR;
	V_BSTR(&varElem) = bstrTableAttrs;
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 4: cell attributes
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_BSTR;
	V_BSTR(&varElem) = bstrCellAttrs;
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 5: table caption
	// VK bug 15857: don't include caption if it's empty.
	if ( 0 != SysStringLen ( bstrCaption ) )
	{
		ix[0] = i;
		VariantInit(&varElem);
		V_VT(&varElem) = VT_BSTR;
		V_BSTR(&varElem) = bstrCaption;
		hr = SafeArrayPutElement(psa, ix, &varElem);
		VariantClear(&varElem);
		++i;
	}

	return hr;
}


//	Determine which object is selected, and return its position
//
HRESULT
CProxyFrame::GetSelectionPos ( LPPOINT lpWhere )
{
	HRESULT	hr	= E_FAIL;
	CComPtr<IHTMLDocument2> spHtmlDoc				= NULL;
	CComPtr<IHTMLSelectionObject> spSelectionObj	= NULL;
	CComPtr<IDispatch> spRangeDisp					= NULL;
	CComPtr<IHTMLElement> spElement					= NULL;
	
	lpWhere->x	= 0;
	lpWhere->y	= 0;

	hr = HrGetDoc ( &spHtmlDoc );
	if ( SUCCEEDED ( hr ) )
	{
		hr = spHtmlDoc->get_selection ( &spSelectionObj );
		if ( SUCCEEDED ( hr ) )
		{
			hr = spSelectionObj->createRange ( &spRangeDisp );
			if (SUCCEEDED ( hr ) )
			{
				CComQIPtr<IHTMLTxtRange, &IID_IHTMLTxtRange> spTextRange ( spRangeDisp );
				if ( spTextRange )
				{
					hr = spTextRange->parentElement(&spElement);
				}
				else
				{
					CComQIPtr<IHTMLControlRange, &IID_IHTMLControlRange> spControlRange ( spRangeDisp );
					if ( spControlRange )
					{
						hr = spControlRange->commonParentElement(&spElement);
					}
				}
				if ( spElement )
				{
					CComPtr<IHTMLStyle> spStyle = NULL;
					hr = spElement->get_style ( &spStyle );
					if ( spStyle )
					{
						spStyle->get_pixelTop ( &( lpWhere->y ) );
						spStyle->get_pixelLeft ( &( lpWhere->x ) );
					}
				}
			}
		}
	}
	return hr;
}


//	If the current document is loaded from a URL, return the empty string.
//	If it's loaded from a file, strip the path part off and return just the file name.
//	Return S_FALSE for a URL or no file name.  S_OK if a file name is supplied.
//
HRESULT
CProxyFrame::GetCurDocNameWOPath ( CComBSTR& bstrDocName )
{
	bstrDocName = L"";

	if ( m_bfIsURL )
	{
		return S_FALSE;
	}
	if ( 0 == m_bstrCurDocPath.Length () )
	{
		return S_FALSE;
	}

	bstrDocName = m_bstrCurDocPath;

	// Truncate at first backslash:
	_wcsrev ( bstrDocName );
	wcstok ( bstrDocName, OLESTR( "\\" ) );
	_wcsrev ( bstrDocName );

	return S_OK;
}


//	Used by ShowContextMenu to properly offset the position of the click
// 
HRESULT
CProxyFrame::GetScrollPos ( LPPOINT lpPos )
{
	HRESULT					hr			= E_FAIL;
	CComPtr<IHTMLDocument2>	spHtmlDoc	= NULL;
	CComPtr<IHTMLElement>	spBodyElem	= NULL;

	_ASSERTE ( lpPos );
	
	hr = HrGetDoc ( &spHtmlDoc );
	
	// It's possible that the user clicked while the doc was still loading.
	// If so, just return 0, 0.
	if ( DE_E_UNEXPECTED == hr )
	{
		lpPos->x = lpPos->y = 0;
		return S_FALSE;
	}

	_ASSERTE ( spHtmlDoc );
	if ( SUCCEEDED ( hr ) )
	{
		hr = spHtmlDoc->get_body ( &spBodyElem );
		_ASSERTE ( spBodyElem );
		if ( SUCCEEDED ( hr ) )
		{
			CComQIPtr<IHTMLTextContainer, &IID_IHTMLTextContainer> spHtmlTextCont ( spBodyElem );
			if ( spHtmlTextCont )
			{
				LONG	lxPos	= 0;
				LONG	lyPos	= 0;

				hr = spHtmlTextCont->get_scrollLeft ( &lxPos );
				_ASSERTE ( SUCCEEDED ( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					hr = spHtmlTextCont->get_scrollTop ( &lyPos );
					_ASSERTE ( SUCCEEDED ( hr ) );
					if ( SUCCEEDED ( hr ) )
					{
						lpPos->x = lxPos;
						lpPos->y = lyPos;
					}
				}
			}
			else
			{
				hr = E_NOINTERFACE;
				_ASSERTE ( SUCCEEDED ( hr ) );
			}
		}
	}
	return hr;
}


HRESULT
CProxyFrame::GetContainer ( LPOLECONTAINER* ppContainer )
{
	_ASSERTE ( m_pCtl );
	_ASSERTE ( m_pCtl->m_spClientSite );
	if ( m_pCtl->m_spClientSite )
	{
		return m_pCtl->m_spClientSite->GetContainer ( ppContainer );
	}
	return E_NOTIMPL;
}


//	For the Safe for Scripting control, make sure the URL specified comes from
//	the same host as the SecurityURL, the URL of the hosting container..
//	Note that this makes the SFS control virtually useless in VB, which returns
//	the Boot Drive Root Folder as the Security URL.
//
HRESULT CProxyFrame::CheckCrossZoneSecurity ( BSTR urlToLoad )
{
	HRESULT		hr	= S_OK;

	CComPtr<IInternetSecurityManager> srpSec;
	CComBSTR	bstrSecURL;

	hr = GetSecurityURL ( bstrSecURL );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
#ifdef LATE_BIND_URLMON_WININET
		hr = (m_pfnCoInternetCreateSecurityManager)( NULL, &srpSec, 0 );
#else
		hr = CoInternetCreateSecurityManager( NULL, &srpSec, 0 );
#endif // LATE_BIND_URLMON_WININET
		if ( SUCCEEDED ( hr ) && srpSec )
		{
			BYTE*	pbSidToLoad		= NULL;
			BYTE*	pbDSidSecURL	= NULL;
			DWORD	dwSizeToLoad	= INTERNET_MAX_URL_LENGTH;
			DWORD	dwSizeSecURL	= INTERNET_MAX_URL_LENGTH;

			pbSidToLoad  = new BYTE [INTERNET_MAX_URL_LENGTH];
			pbDSidSecURL = new BYTE [INTERNET_MAX_URL_LENGTH];

			hr = srpSec->GetSecurityId ( urlToLoad, pbSidToLoad, &dwSizeToLoad, 0 );
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( SUCCEEDED ( hr ) )
			{
				hr = srpSec->GetSecurityId ( bstrSecURL, pbDSidSecURL, &dwSizeSecURL, 0 );
				_ASSERTE ( SUCCEEDED ( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					hr = DE_E_ACCESS_DENIED;

					if ( ( dwSizeToLoad == dwSizeSecURL ) &&
						( 0 == memcmp ( pbSidToLoad, pbDSidSecURL, dwSizeToLoad ) ) )
					{
						hr = S_OK;
					}
				}
			}

			delete [] pbSidToLoad;
			delete [] pbDSidSecURL;
		}
		else
		{
			// BUG 597887: If CoInternetCreateSecurityManager returns NULL and success, return error:
			if ( !srpSec )
			{
				hr = E_UNEXPECTED;
			}
		}
	}
	return hr;
}


//	A specialization of CheckCrossZoneSecurity which works on the current selection.
//	Bug 547802 indicated a regression in execCommand, so we will assure safety ourselves.
//
HRESULT CProxyFrame::CheckCrossZoneSecurityOfSelection ()
{
	HRESULT						hr	= S_OK;
	CComPtr<IHTMLDocument2>		spDOM;
	CComPtr<IServiceProvider>	srpSP;
	CComPtr<IHTMLEditServices>	srpEditor;
	CComPtr<ISelectionServices>	srpSelSvc;
	CComPtr<IMarkupContainer>	sprMarkupCont;
	CComPtr<IHTMLDocument2>		spSelDoc;
	CComPtr<IHTMLLocation>		spHostLoc;
	CComBSTR					bstrHref;

	hr = HrGetDoc( &spDOM );
	if ( FAILED(hr) ) goto ONERROR;

	hr = spDOM->QueryInterface(IID_IServiceProvider, (LPVOID *)&srpSP);
	if ( FAILED(hr) ) goto ONERROR;
	hr = srpSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)&srpEditor);
	if ( FAILED(hr) ) goto ONERROR;
	hr = srpEditor->GetSelectionServices(NULL, &srpSelSvc);
	if ( FAILED(hr) ) goto ONERROR;
	if ( !srpSelSvc ) goto ONERROR;
	hr = srpSelSvc->GetMarkupContainer(&sprMarkupCont);
	if ( FAILED(hr) ) goto ONERROR;
	if ( !sprMarkupCont ) goto ONERROR;
	hr = sprMarkupCont->QueryInterface(&spSelDoc);
	if ( FAILED(hr) ) goto ONERROR;
	
	hr = spSelDoc->get_location ( &spHostLoc );
	if ( FAILED(hr) ) goto ONERROR;
	if ( !spHostLoc ) goto ONERROR;
	hr = spHostLoc->get_href ( &bstrHref );
	if ( FAILED(hr) ) goto ONERROR;
	if ( !bstrHref ) goto ONERROR;

	hr = CheckCrossZoneSecurity ( bstrHref );

	return hr;

ONERROR:
	return DE_E_ACCESS_DENIED;
}


HRESULT CProxyFrame::OnProgress(ULONG, ULONG, ULONG ulStatusCode, LPCWSTR)
{
	if ( BINDSTATUS_REDIRECTING == ulStatusCode )
	{
		// If we're the SFS control, cancel on Redirect.  Otherwise, ignore it.
		if ( m_pCtl->IsSafeForScripting ())
		{
			m_bfSFSRedirect = TRUE;
		}
	}
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\triedsnk.h ===
//	Event sink for TriEdit/Trident
//	Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//	Van Kichline



//	Create an event sink impl, then immediately call SetOwner with, in this case,
//	a pointer to a CProxyFrame, implementing OnTriEditEvent.
//	It would be better to require an interface on the OnTriEditEvent when time allows.
//	The lifetime of the CProxyFrame is managed by the CTriEditEventSink, below.
//
//	OnTriEditEvent will be called with the following DISPIDs for Document events:
//		DISPID_HTMLDOCUMENTEVENTS_ONHELP:
//		DISPID_HTMLDOCUMENTEVENTS_ONCLICK:
//		DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK:
//		DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN:
//		DISPID_HTMLDOCUMENTEVENTS_ONKEYUP:
//		DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS:
//		DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE:
//		DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN:
//		DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP:
//		DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE:
//
//	Changes: more versital implementation allows creating sinks for various event interfaces.
//	The interface IID is sent along to OnTriEditEvent.
//
class ATL_NO_VTABLE CTriEditEventSinkImpl :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatch
{
public:
BEGIN_COM_MAP(CTriEditEventSinkImpl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	CTriEditEventSinkImpl ()
	{
		m_pFR = NULL;
	}

	void SetOwner ( CProxyFrame* pFR, const GUID& iidEventInterface )
	{
		_ASSERTE ( pFR );
		_ASSERTE ( NULL == m_pFR );
		if ( NULL == m_pFR )
		{
			m_pFR = pFR;
			m_iidEventInterface = iidEventInterface;
		}
	}

	STDMETHOD(GetTypeInfoCount) ( UINT * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetTypeInfo) ( UINT, LCID, ITypeInfo ** )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetIDsOfNames) ( REFIID, OLECHAR **, UINT, LCID, DISPID * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(Invoke) ( DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT * )
	{
		HRESULT	hr = E_UNEXPECTED;
		_ASSERTE ( m_pFR );
		if ( NULL != m_pFR )
		{
			hr = m_pFR->OnTriEditEvent ( m_iidEventInterface, dispid );
		}
		return hr;
	}

private:
	CProxyFrame*	m_pFR;
	GUID			m_iidEventInterface;
};


//	This class manages hooking up an event sink on Trident using CTriEditEventSinkImpl above.
//	The sink is advised and unadvised by this class, making management simple.
//	CProxyFrame must implement OnTriEditEvent.
//
class CTriEditEventSink
{
public:
	CTriEditEventSink ( CProxyFrame* pFR, GUID iidEventInterface ) :
	  m_piConPt ( NULL ), m_dwCookie ( 0 ), m_pSink ( NULL ), m_iidEventInterface ( iidEventInterface )
	{
		_ASSERTE ( pFR );
		m_pFR = pFR;
		if ( NULL != m_pFR )
		{
			m_pFR->AddRef ();
			m_pSink = new CComObject<CTriEditEventSinkImpl>;
			_ASSERTE ( m_pSink );
			m_pSink->AddRef ();
			m_pSink->SetOwner ( m_pFR, m_iidEventInterface );
			m_bfSunk = FALSE;
		}
	}

	~CTriEditEventSink ()
	{
		_ASSERTE ( m_pFR );

		Unadvise ();
		
		if ( NULL != m_pSink )
		{
			m_pSink->Release ();
			m_pSink = NULL;
		}

		if ( NULL != m_pFR )
		{
			m_pFR->Release ();
			m_pFR = NULL;
		}
	}

	HRESULT Advise ( IUnknown* pUnk )
	{
		HRESULT hr	= E_FAIL;
		_ASSERTE ( pUnk );
		_ASSERTE ( m_pFR );
		_ASSERTE ( m_pSink );

		if ( NULL == pUnk )
		{
			_ASSERTE ( FALSE );
			return E_UNEXPECTED;
		}

		if ( m_bfSunk )
		{
			_ASSERTE ( FALSE );
			return E_UNEXPECTED;
		}

		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer>picpc ( pUnk );
		if ( picpc )
		{
			hr = picpc->FindConnectionPoint ( m_iidEventInterface, &m_piConPt );
			if ( SUCCEEDED ( hr ) )
			{
				hr = m_piConPt->Advise ( static_cast<IDispatch *>(m_pSink), &m_dwCookie);
				_ASSERTE ( SUCCEEDED ( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					m_bfSunk = TRUE;
				}
			}
		}
		return hr;
	}

	void Unadvise ()
	{
		if ( !m_bfSunk )
		{
			return;
		}

		if ( ( NULL != m_pSink ) && ( NULL != m_piConPt ) )
		{
			m_piConPt->Unadvise ( m_dwCookie );
			m_bfSunk = FALSE;
				
		}
		if ( NULL != m_piConPt )
		{
			m_piConPt->Release ();
			m_piConPt = NULL;
		}
	}

private:
	CTriEditEventSinkImpl*	m_pSink;
	IConnectionPoint*		m_piConPt;
	DWORD					m_dwCookie;
	CProxyFrame*			m_pFR;
	BOOL					m_bfSunk;
	GUID					m_iidEventInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\site.h ===
/*
 * SITE.H
 * View Site for Document Objects.
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#ifndef _SITE_H_
#define _SITE_H_

#include "stdafx.h"
#include "mlang.h"


class CProxyFrame;
class CTriEditEventSink;

class CImpIOleClientSite : public IOleClientSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleClientSite(class CSite *, IUnknown *);
        ~CImpIOleClientSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP SaveObject(void);
        STDMETHODIMP GetMoniker(DWORD, DWORD, LPMONIKER *);
        STDMETHODIMP GetContainer(LPOLECONTAINER *);
        STDMETHODIMP ShowObject(void);
        STDMETHODIMP OnShowWindow(BOOL);
        STDMETHODIMP RequestNewObjectLayout(void);
};

typedef CImpIOleClientSite *PCImpIOleClientSite;



class CImpIAdviseSink : public IAdviseSink
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIAdviseSink(class CSite *, IUnknown *);
        ~CImpIAdviseSink(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
        STDMETHODIMP_(void)  OnRename(LPMONIKER);
        STDMETHODIMP_(void)  OnSave(void);
        STDMETHODIMP_(void)  OnClose(void);
};


typedef CImpIAdviseSink *PCImpIAdviseSink;


class CImplPropertyNotifySink : public IPropertyNotifySink
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImplPropertyNotifySink(class CSite *, IUnknown *);
        ~CImplPropertyNotifySink(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP OnChanged(DISPID dispid);
        STDMETHODIMP OnRequestEdit (DISPID dispid);
};


typedef CImplPropertyNotifySink *PCImplPropertyNotifySink;


class CImpIOleInPlaceSite : public IOleInPlaceSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleInPlaceSite(class CSite *, IUnknown *);
        ~CImpIOleInPlaceSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetWindow(HWND *);
        STDMETHODIMP ContextSensitiveHelp(BOOL);
        STDMETHODIMP CanInPlaceActivate(void);
        STDMETHODIMP OnInPlaceActivate(void);
        STDMETHODIMP OnUIActivate(void);
        STDMETHODIMP GetWindowContext(LPOLEINPLACEFRAME *
                        , LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT
                        , LPOLEINPLACEFRAMEINFO);
        STDMETHODIMP Scroll(SIZE);
        STDMETHODIMP OnUIDeactivate(BOOL);
        STDMETHODIMP OnInPlaceDeactivate(void);
        STDMETHODIMP DiscardUndoState(void);
        STDMETHODIMP DeactivateAndUndo(void);
        STDMETHODIMP OnPosRectChange(LPCRECT);
};

typedef CImpIOleInPlaceSite *PCImpIOleInPlaceSite;


class CImpIOleDocumentSite : public IOleDocumentSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleDocumentSite(class CSite *, IUnknown *);
        ~CImpIOleDocumentSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP ActivateMe(IOleDocumentView *);
};

typedef CImpIOleDocumentSite *PCImpIOleDocumentSite;



///////////////////////////////////////////////////
// MSHTML.DLL host integration interfaces
///////////////////////////////////////////////////
class CImpIDocHostUIHandler : public IDocHostUIHandler
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIDocHostUIHandler(class CSite *, IUnknown *);
        ~CImpIDocHostUIHandler(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		STDMETHODIMP GetHostInfo(DOCHOSTUIINFO * pInfo);
		STDMETHODIMP ShowUI(
				DWORD dwID, 
				IOleInPlaceActiveObject * pActiveObject,
				IOleCommandTarget * pCommandTarget,
				IOleInPlaceFrame * pFrame,
				IOleInPlaceUIWindow * pDoc);
		STDMETHODIMP HideUI(void);
		STDMETHODIMP UpdateUI(void);
		STDMETHODIMP EnableModeless(BOOL fEnable);
		STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
		STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
		STDMETHODIMP ResizeBorder(
				LPCRECT prcBorder, 
				IOleInPlaceUIWindow * pUIWindow, 
				BOOL fRameWindow);
		STDMETHODIMP ShowContextMenu(
				DWORD dwID, 
				POINT * pptPosition,
				IUnknown* pCommandTarget,
				IDispatch * pDispatchObjectHit);
		STDMETHODIMP TranslateAccelerator(
            /* [in] */ LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID);
		STDMETHODIMP GetOptionKeyPath(BSTR* pbstrKey, DWORD dw);
		STDMETHODIMP GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget);

		STDMETHODIMP GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        STDMETHODIMP TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut);
        
        STDMETHODIMP FilterDataObject( 
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet);


};

typedef CImpIDocHostUIHandler* PCImpIDocHostUIHandler;



class CImpIDocHostShowUI : public IDocHostShowUI
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIDocHostShowUI(class CSite *, IUnknown *);
        ~CImpIDocHostShowUI(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		STDMETHODIMP ShowMessage(
								HWND hwnd,
								LPOLESTR lpstrText,
								LPOLESTR lpstrCaption, 
								DWORD dwType,
								LPOLESTR lpstrHelpFile,
								DWORD dwHelpContext,
								LRESULT * plResult);
		STDMETHODIMP ShowHelp(
								HWND hwnd,
								LPOLESTR pszHelpFile,
								UINT uCommand,
								DWORD dwData,
								POINT ptMouse,
								IDispatch * pDispatchObjectHit);
};

typedef CImpIDocHostShowUI* PCImpIDocHostShowUI;



/*
 * IDispatch - implements Ambient properties
 */
class CImpAmbientIDispatch : public IDispatch
{
    protected:
        ULONG           m_cRef;
        class CSite		*m_pSite;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpAmbientIDispatch(class CSite *, IUnknown *);
        ~CImpAmbientIDispatch(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT
            , LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, USHORT
            , DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
};

typedef class CImpAmbientIDispatch *PCImpAmbientIDispatch;


class CImpIOleControlSite : public IOleControlSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleControlSite(class CSite *, IUnknown *);
        ~CImpIOleControlSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP OnControlInfoChanged(void) { return S_OK;}
        STDMETHODIMP LockInPlaceActive(BOOL) {return E_NOTIMPL;}
        STDMETHODIMP GetExtendedControl(IDispatch**) {return E_NOTIMPL;}
        STDMETHODIMP TransformCoords(POINTL*, POINTF*, DWORD) {return E_NOTIMPL;}
        STDMETHODIMP TranslateAccelerator(LPMSG, DWORD) {return E_NOTIMPL;}
        STDMETHODIMP OnFocus(BOOL) { return S_OK;}
        STDMETHODIMP ShowPropertyFrame(void) { return E_NOTIMPL; }
};

typedef class CImpIOleControlSite *PCImpIOleControlSite;



/*
 * The CSite class, a COM object with the interfaces IOleClientSite,
 * IAdviseSink, IOleInPlaceSite, and IOleDocumentSite.
 */


class CSite : public IUnknown
{
	
    private:
        ULONG						m_cRef;
        HWND						m_hWnd; //Client area window of parent
		DWORD						m_dwPropNotifyCookie;
		DWORD						m_dwOleObjectCookie;
        class CProxyFrame*			m_pFR;
		BOOL						m_bFiltered;

        //Object interfaces
        LPUNKNOWN					m_pObj;
        LPOLEOBJECT					m_pIOleObject;
        LPOLEINPLACEOBJECT			m_pIOleIPObject;
        LPOLEDOCUMENTVIEW			m_pIOleDocView;
		LPOLECOMMANDTARGET			m_pIOleCommandTarget;


        //Our interfaces
        PCImpIOleClientSite			m_pImpIOleClientSite;
        PCImpIAdviseSink			m_pImpIAdviseSink;
        PCImpIOleInPlaceSite		m_pImpIOleIPSite;
        PCImpIOleDocumentSite		m_pImpIOleDocumentSite;
        PCImpIDocHostUIHandler		m_pImpIDocHostUIHandler;
        PCImpIDocHostShowUI			m_pImpIDocHostShowUI;
		PCImpAmbientIDispatch		m_pImpAmbientIDispatch;
		PCImplPropertyNotifySink	m_pImpIPropertyNotifySink;
		PCImpIOleControlSite		m_pImpIOleControlSite;

		CTriEditEventSink*			m_pTriEdDocEvtSink;		
		CTriEditEventSink*			m_pTriEdWndEvtSink;		
		BOOL						m_bfSaveAsUnicode;
		UINT						m_cpCodePage;
		IMultiLanguage2*			m_piMLang;

    protected:

    public:
        CSite(CProxyFrame*);
        ~CSite(void);

        //BOOL    ObjectInitialize( TCHAR* pchPath );

        //Gotta have an IUnknown for delegation
        STDMETHODIMP QueryInterface(REFIID, void** );
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);


		// Other functions
        HRESULT		HrCreate(IUnknown* pUnk, IUnknown** ppUnkTriEdit);
		HRESULT		HrObjectInitialize();
		HRESULT		HrRegisterPropNotifySink(BOOL fRegister);
        void        Close(BOOL);
		void		InitialActivate(LONG, HWND hWnd);
		void		Activate(LONG);
        void        UpdateObjectRects(void);

		HRESULT		HrIsDirtyIPersistStreamInit(BOOL& bVal);

		HRESULT		HrSaveToFile(BSTR bstrPath, DWORD dwFilterFlags);
		HRESULT		HrSaveToBstr(BSTR* bstr, DWORD dwFilterFlags);

		HRESULT		HrSaveToStream(LPSTREAM pStream);
		HRESULT		HrSaveToStreamAndFilter(LPSTREAM* ppStream, DWORD dwFilterFlags);

		HRESULT		HrTestFileOpen(BSTR path);

		// Filtering methods

		HRESULT		HrFileToStream(LPCTSTR fileName, LPSTREAM* ppiStream);
		HRESULT		HrURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream);
		HRESULT		HrSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream);
		HRESULT		HrNonSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream);
		HRESULT		HrStreamToFile(LPSTREAM pStream, LPCTSTR fileName);
		HRESULT		HrBstrToStream(BSTR bstrSrc, LPSTREAM* ppStream);
		HRESULT		HrStreamToBstr(LPSTREAM pStream, BSTR* pBstr, BOOL bfRetainByteOrderMark = FALSE);
		HRESULT		HrFilter(BOOL bDirection, LPSTREAM pSrcStream, LPSTREAM* ppFilteredStream, DWORD dwFilterFlags);

		HRESULT		HrConvertStreamToUnicode ( IStream* piStream );
		BOOL		BfFlipBytesIfBigEndianUnicode ( CHAR* pchData, int cbSize );
		BOOL		IsUnicode ( void* pData, int cbSize );

		// ReadyState property methods
		void OnReadyStateChanged();

		// helper functions

		HRESULT GetContainer ( LPOLECONTAINER* ppContainer );

		inline CProxyFrame*	GetFrame(void) {
							return m_pFR;
						}

		inline LPUNKNOWN		GetObjectUnknown(void ) {
							return m_pObj; 
						} 

		inline PCImpIOleInPlaceSite GetIPSite(void) {
							return m_pImpIOleIPSite;
						}

		inline HWND			GetWindow(void) {
							return m_hWnd;
						}

		inline void			SetWindow(HWND hwnd) {
							m_hWnd = hwnd;
						}

		inline LPOLECOMMANDTARGET GetCommandTarget(void) {
							return m_pIOleCommandTarget;
						}

		inline void			SetCommandTarget(LPOLECOMMANDTARGET pTarget) {
							m_pIOleCommandTarget = pTarget;
						}

		inline void			SetDocView(LPOLEDOCUMENTVIEW pDocView) {
							// VSQFE:406/WinSERAID:23872, hongyuwu, 4/18/2002
							// need to release the old pointer first 
							// (AddRef'ed in CImpIOleDocumentSite::ActivateMe)
							if(m_pIOleDocView) m_pIOleDocView->Release();
							m_pIOleDocView = pDocView;
						}
		
		inline void			SetIPObject(LPOLEINPLACEOBJECT pIPObject) {
							m_pIOleIPObject = pIPObject;
						}

		inline LPOLEINPLACEOBJECT GetIPObject(void) {
							return m_pIOleIPObject; 
						}

		inline BOOL GetSaveAsUnicode ( void ) {
							return m_bfSaveAsUnicode;
						}

		inline BOOL SetSaveAsUnicode ( BOOL bfUnicode ) {
							BOOL bf = m_bfSaveAsUnicode;
							m_bfSaveAsUnicode = bfUnicode;
							return bf;
						}

		inline UINT GetCurrentCodePage ( void ) {
							return m_cpCodePage;
						}
};


typedef CSite* PCSite;



//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
{\
            if (NULL!=p)\
            {\
                delete p;\
                p=NULL;\
            }\
}


//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
{\
            IUnknown *pt=(IUnknown *)p;\
            p=NULL;\
            if (NULL!=pt)\
                pt->Release();\
}

#endif //_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\trifilter.cpp ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"

#define AGENT_SIGNATURE (TEXT("Mozilla/4.0 (compatible; MSIE 5.01; DHTML Editing Control)"))

#define CP_20127 20127      // Code page for us-ascii
#define CP_1252  1252

//	Check to see if a buffer starts with a byte order Unicode character.
//	This implementation is processor byte-order independant.
//
static BOOL StartsWithByteOrderMark ( LPVOID pvData )
{
	CHAR	*pchData	= (CHAR*)pvData;

#pragma warning(disable: 4310) // cast truncates constant value
	if ( ( (char)0xff == pchData[0] ) && ( (char)0xfe == pchData[1] ) )
#pragma warning(default: 4310) // cast truncates constant value
	{
		return TRUE;
	}
	return FALSE;
}


//	Given a pointer to a buffer assumed to hold at least two bytes,
//	write a Unicode byte order mark to it.
//	This implementation is processor byte-order independant.
//
static void InsertByteOrderMark ( LPVOID pvData )
{
	CHAR	*pchData	= (CHAR*)pvData;

#pragma warning(disable: 4310) // cast truncates constant value
	pchData[0] = (CHAR)0xff;
	pchData[1] = (CHAR)0xfe;
#pragma warning(default: 4310) // cast truncates constant value
}


HRESULT
CSite::HrFileToStream(LPCTSTR fileName, LPSTREAM* ppiStream)
{
	HRESULT hr = S_OK;
	HANDLE hFile = NULL;
	HGLOBAL hMem = NULL;
	DWORD cbData = 0;
	LPVOID pbData = NULL;
	BOOL memLocked = FALSE;
	DWORD bytesRead = 0;
	BOOL bResult = FALSE;
	BOOL  bfUnicode = FALSE;

	hFile = CreateFile(
				fileName,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);

	if(INVALID_HANDLE_VALUE == hFile)
	{
		DWORD ec = ::GetLastError();
		if ( ERROR_BAD_NETPATH == ec ) ec = ERROR_PATH_NOT_FOUND;
		hr = HRESULT_FROM_WIN32(ec);
		return hr;
	}

	cbData = GetFileSize(hFile, NULL);

	if (0xFFFFFFFF == cbData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto cleanup;
	}


	// If the file is empty, create a zero length stream, but the global block must be non-zero in size.
	// VID98BUG 23121
	hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, ( 0 == cbData ) ? 2 : cbData );
#if _DEBUG
	size = GlobalSize(hMem);
#endif

	if (NULL == hMem)
	{
		_ASSERTE(hMem);
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	pbData = GlobalLock(hMem);

	_ASSERTE(pbData);

	if (NULL == pbData)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	bResult = ReadFile(hFile, pbData, cbData, &bytesRead, NULL) ; 

	_ASSERTE(bResult);

	if (FALSE == bResult)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto cleanup;
	}

	_ASSERTE(bytesRead == cbData);

	BfFlipBytesIfBigEndianUnicode ( (CHAR*)pbData, bytesRead );

	if ( IsUnicode ( pbData, (int)cbData ) )
	{
		bfUnicode = TRUE;
	}
	else
	{
		bfUnicode = FALSE;
	}


cleanup:


	::CloseHandle((HANDLE) hFile);

	if (hr != E_OUTOFMEMORY)
		memLocked = GlobalUnlock(hMem);

	_ASSERTE(FALSE == memLocked);

	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(hMem, TRUE, ppiStream)))
		{
			ULARGE_INTEGER ui = {0};

			_ASSERTE(ppiStream);

			ui.LowPart = cbData;
			ui.HighPart = 0x00;
			hr = (*ppiStream)->SetSize(ui);

			_ASSERTE(SUCCEEDED(hr));
		}

		if ( SUCCEEDED ( hr ) )
		{
			SetSaveAsUnicode ( bfUnicode );
			if ( !bfUnicode )
			{
				hr = HrConvertStreamToUnicode ( *ppiStream );
				_ASSERTE(SUCCEEDED(hr));
			}
		}
	}
	else // if failed
	{
		hMem = GlobalFree(hMem);
		_ASSERTE(NULL == hMem);
	}

	return hr;
}


//	Determine which method of URL fetch to use.  We have one for https, and another for other protocols.
//
HRESULT
CSite::HrURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream)
{
	HRESULT			hr = S_OK;
	URL_COMPONENTS	urlc;

	_ASSERTE ( szURL );
	_ASSERTE ( ppiStream );

	memset ( &urlc, 0, sizeof ( urlc ) );
	urlc.dwStructSize = sizeof ( urlc );

	hr = InternetCrackUrl ( szURL, 0, 0, &urlc );
	if ( SUCCEEDED ( hr ) )
	{
		if ( INTERNET_SCHEME_HTTPS == urlc.nScheme )
		{
			hr = HrSecureURLToStream ( szURL, ppiStream );
		}
		else
		{
			hr = HrNonSecureURLToStream ( szURL, ppiStream );
		}
	}
	return hr;
}



//	This version utilizes WinINet, which does not create cache files so is usable with https.
//	However, pluggable protocols cannot be stacked on the WinINet fucntions.
//
#define BUFFLEN 4096
HRESULT
CSite::HrSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream)
{
	HRESULT		hr		= S_OK;

	_ASSERTE ( szURL );
	_ASSERTE ( ppiStream );
	*ppiStream = NULL;

	// Create a new read/write stream:
	hr = CreateStreamOnHGlobal ( NULL, TRUE, ppiStream );

	if ( SUCCEEDED ( hr ) && *ppiStream )
	{
		CHAR			*pBuff			= NULL;
		DWORD			dwRead			= 0;
		ULONG			ulStreamLen		= 0;
		ULONG			ulStreamWrite	= 0;
		ULARGE_INTEGER	ui				= {0};
		BOOL			bfUnicode		= FALSE;

		pBuff = new CHAR[BUFFLEN];
		if ( NULL == pBuff )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			HINTERNET hSession = InternetOpen ( AGENT_SIGNATURE, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );
			if ( NULL == hSession )
			{
				// InternetOpen failed
				hr = HRESULT_FROM_WIN32 ( GetLastError () );
				_ASSERTE ( FAILED ( hr ) );	// Make sure error returned wasn't NO_ERR
			}
			else
			{
				// Do not allow redirects in the SFS control.
				DWORD dwFlags = m_pFR->GetControl()->IsSafeForScripting () ? INTERNET_FLAG_NO_AUTO_REDIRECT : 0;
				
				HINTERNET hFile = InternetOpenUrl ( hSession, szURL, NULL, 0, dwFlags, 0 );
				if ( NULL == hFile )
				{
					// InternetOpenURL failed
					hr = HRESULT_FROM_WIN32 ( GetLastError () );
					_ASSERTE ( FAILED ( hr ) );	// Make sure error returned wasn't NO_ERR
				}
				else
				{
					// Read in data and write it to the stream to return.
					while ( InternetReadFile ( hFile, pBuff, BUFFLEN, &dwRead ) )
					{
						if ( 0 == dwRead )
						{
							break;
						}
						hr = (*ppiStream)->Write ( pBuff, dwRead, &ulStreamWrite );
						_ASSERTE ( dwRead == ulStreamWrite );

						if ( SUCCEEDED ( hr ) )
						{
							ulStreamLen += ulStreamWrite;
						}
						else
						{
							// Failed to read the data.  Make sure the error is not overwritten.
							goto READFILE_BAILOUT;
						}
					}


					ui.LowPart	= ulStreamLen;
					ui.HighPart	= 0x00;
					hr = (*ppiStream)->SetSize(ui);

					hr = HrConvertStreamToUnicode ( *ppiStream );
					bfUnicode = ( S_FALSE == hr );
					if ( SUCCEEDED ( hr ) )
					{
						hr = S_OK;	// the S_FALSE result wouldn't make much sense to caller of this function.
					}
					SetSaveAsUnicode ( bfUnicode );

READFILE_BAILOUT:
					InternetCloseHandle ( hFile );
				}

				InternetCloseHandle ( hSession );
			}
			delete [] pBuff;
		}
	}

	// If an error is being returned, cleat the stream here.
	if ( FAILED ( hr ) && ( NULL != *ppiStream ) )
	{
		(*ppiStream)->Release();
		*ppiStream = NULL;
	}

	return hr;
}


//  This version utilizes URLMon, which makes stacking pluggable protocols possible.
// However, it cannot be used with https because it creates a cache file.
//
HRESULT
CSite::HrNonSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream)
{
	HRESULT		hr				= S_OK;
	IStream*	piStreamOrig	= NULL;

	*ppiStream = NULL;

	// Use the degenerate IBindStatusCallback implemented on the proxyframe exclusively
	// to provide IAuthenticate.
	IBindStatusCallback* piBSCB = NULL;
	m_pFR->QueryInterface ( IID_IBindStatusCallback, (void**)&piBSCB );

	m_pFR->ClearSFSRedirect ();

#ifdef LATE_BIND_URLMON_WININET
	PFNURLOpenBlockingStream pfnURLOpenBlockingStream = m_pFR->m_pfnURLOpenBlockingStream;
	_ASSERTE ( pfnURLOpenBlockingStream );
	hr = (*pfnURLOpenBlockingStream)( NULL, szURL, &piStreamOrig, 0, piBSCB );
#else
	hr = URLOpenBlockingStream ( NULL, szURL, &piStreamOrig, 0, piBSCB );
#endif // LATE_BIND_URLMON_WININET

	if ( NULL != piBSCB )
	{
		piBSCB->Release ();
		piBSCB = NULL;
	}

	// If SFSRedirect got set, this is the SFS control and a redirect was detected.  Abort for security!
	if ( m_pFR->GetSFSRedirect () )
	{
		if ( NULL != piStreamOrig )
		{
			piStreamOrig->Release ();
			piStreamOrig = NULL;
		}
		hr = DE_E_ACCESS_DENIED;
	}

	if ( SUCCEEDED ( hr ) )
	{
		ULONG	cbStreamSize	= 0;
		HGLOBAL	hGlob			= NULL;
		STATSTG stat;

		// TriEdit will call GetHGlobalFromStream on the stream, which will fail.
		// We need to recopy it into this process.
		if ((hr = piStreamOrig->Stat(&stat, STATFLAG_NONAME)) == S_OK)
		{
			cbStreamSize = stat.cbSize.LowPart;
			// If the file is empty, create a zero length stream, but the global block must be non-zero in size.
			hGlob = GlobalAlloc ( GHND, ( 0 == cbStreamSize ) ? 2 : cbStreamSize );
			if ( NULL == hGlob )
			{
				DWORD ec = ::GetLastError();
				hr = HRESULT_FROM_WIN32(ec);
			}
			else
			{
				void* pBuff = GlobalLock ( hGlob );
				if ( NULL == pBuff )
				{
					DWORD ec = ::GetLastError();
					hr = HRESULT_FROM_WIN32(ec);
				}
				else
				{
					ULONG	cbBytesRead = 0;

					hr = piStreamOrig->Read ( pBuff, cbStreamSize, &cbBytesRead );
					_ASSERTE ( SUCCEEDED ( hr ) );
					_ASSERTE ( cbBytesRead == cbStreamSize );

					if ( SUCCEEDED ( hr ) )
					{
						// We now have a global to creat a NEW stream from, locally.
						hr = CreateStreamOnHGlobal ( hGlob, TRUE, ppiStream );

						if ( SUCCEEDED ( hr ) )
						{
							// Convert it to Unicode if necessary.  Set SaveAsUnicode so it can be saved properly.
							hr = HrConvertStreamToUnicode ( *ppiStream );
							BOOL bfUnicode = ( S_FALSE == hr );
							if ( SUCCEEDED ( hr ) )
							{
								hr = S_OK;	// the S_FALSE result wouldn't make much sense to caller of this function.
							}
							SetSaveAsUnicode ( bfUnicode );
						}
					}
				}

				GlobalUnlock ( hGlob );
			}

			if ( FAILED ( hr ) && hGlob!=NULL )
			{
				GlobalFree ( hGlob );
			}
			piStreamOrig->Release();
		}
	}
	return hr;
}


//	Post V1.0 change:
//	The stream will now always be Unicode.
//	We should save the file as Unicode only if it was loaded as Unicode from File or URL,
//	otherwise convert to MBCS string.
//
HRESULT
CSite::HrStreamToFile(LPSTREAM pStream, LPCTSTR fileName)
{
	HRESULT	hr				= S_OK;
	HANDLE	hFile			= NULL;
	HGLOBAL hMem			= NULL;
	WCHAR	*pwcData		= NULL;
	DWORD	bytesWritten	= 0;
	BOOL	bResult			= FALSE;
	STATSTG	statStg			= {0};
            
	UINT unCP = GetCurrentCodePage();


        // WINSE BUG 22289: If us-ascii (20127) encoding is used and it's not available on the system,
        // MLang uses 1252 during conversion to Unicode. But it cannot convert to Unicode using 20127. 
        // So callers may fail to do conversion.In this case pretend using 1252.
        if ( unCP == CP_20127 && !IsValidCodePage(CP_20127) )
            unCP = CP_1252;

        hFile = CreateFile(fileName,
			        GENERIC_WRITE,
			        FILE_SHARE_WRITE, 
			        NULL,
			        CREATE_ALWAYS,
			        FILE_ATTRIBUTE_NORMAL,
			        NULL);

        if (INVALID_HANDLE_VALUE == hFile)
        {
	        DWORD ec = ::GetLastError();

	        if ( ERROR_BAD_NETPATH == ec ) ec = ERROR_PATH_NOT_FOUND;
	        hr = HRESULT_FROM_WIN32(ec);
	        return hr;
        }

        if (FAILED(hr = pStream->Stat(&statStg, STATFLAG_NONAME)))
        {
	        _ASSERTE(SUCCEEDED(hr));
	        return hr;
        }

	if (FAILED(hr = GetHGlobalFromStream(pStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	pwcData = (WCHAR*)GlobalLock(hMem);
	if (NULL == pwcData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		_ASSERTE(pwcData);
		return hr;		
	}

	_ASSERTE ( IsUnicode ( pwcData, statStg.cbSize.LowPart ) );

	// Should it be converted to MBCS?
	if ( GetSaveAsUnicode () )
	{
		bResult = WriteFile(hFile, pwcData, statStg.cbSize.LowPart, &bytesWritten, NULL);
		_ASSERTE(bytesWritten == statStg.cbSize.LowPart);
	}
	else
	{
		UINT cbOrigSize	= statStg.cbSize.LowPart / sizeof ( WCHAR );
		UINT cbNewSize	= 0;
		char *pchTemp	= NULL;

		// Substract one for the byte order mark if it begins the stream.  (It should.)
		if ( StartsWithByteOrderMark ( pwcData ) )
		{
			pwcData++;	// Skip the byte order mark WCHAR
			cbOrigSize--;
		}

		if ( NULL != m_piMLang )
		{
			DWORD dwMode	= 0;

			hr = m_piMLang->ConvertStringFromUnicode ( &dwMode, unCP, pwcData, &cbOrigSize, NULL, &cbNewSize );
			if ( S_FALSE == hr )
			{
				// This indicates that a conversion was not available.  Happens for default CP_ACP if test is typed into new page!
				hr = S_OK;
				goto fallback;
			}

			_ASSERTE ( 0 != cbNewSize );
			if ( SUCCEEDED ( hr ) )
			{
				pchTemp = new char [cbNewSize];
				_ASSERTE ( pchTemp );
				if ( NULL != pchTemp )
				{
					hr = m_piMLang->ConvertStringFromUnicode ( &dwMode, unCP, pwcData, &cbOrigSize, pchTemp, &cbNewSize );
					bResult = WriteFile(hFile, pchTemp, cbNewSize, &bytesWritten, NULL);
					_ASSERTE(bytesWritten == cbNewSize);
					delete [] pchTemp;
				}
			}
		}
		else
		{
fallback:
			cbNewSize = ::WideCharToMultiByte ( unCP, 0, pwcData, cbOrigSize, NULL, 0, NULL, NULL );
			_ASSERTE ( 0 != cbNewSize );
			pchTemp = new char [cbNewSize];
			_ASSERTE ( pchTemp );
			if ( NULL != pchTemp )
			{
				::WideCharToMultiByte ( unCP, 0, pwcData, cbOrigSize, pchTemp, cbNewSize, NULL, NULL );
				bResult = WriteFile(hFile, pchTemp, cbNewSize, &bytesWritten, NULL);
				_ASSERTE(bytesWritten == cbNewSize);
				delete [] pchTemp;
			}
		}
	}


	if (FALSE == bResult)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto cleanup;
	}



cleanup:

	::CloseHandle(hFile);
	// Reference count of hMem not checked here
	// since we can't assume how many times the
	// Stream has locked it
	GlobalUnlock(hMem); 
	return hr;
}


//	Post V1.0 change:
//	The stream is always Unicode now.
//
HRESULT
CSite::HrBstrToStream(BSTR bstrSrc, LPSTREAM* ppStream)
{
	HRESULT hr = S_OK;
	HGLOBAL hMem = NULL;
	ULONG	cbMBStr = 0;
	ULONG	cbBuff = 0;
	LPVOID	pStrDest = NULL;
	LPVOID	pCopyPos = NULL;
	ULARGE_INTEGER ui = {0};

	_ASSERTE(bstrSrc);
	_ASSERTE(ppStream);

	cbMBStr = SysStringLen ( bstrSrc ) * sizeof (OLECHAR);
	cbBuff  = cbMBStr;

	// If the Unicode string does not contain a byte order mark at the beginning, it is
	// misinterpreted by Trident.  When DocumentHTML was set with Japanese text, the
	// BSTR was fed in without the byte order mark and was misinterpreted. (Possibly as UTF-8?)
	// Now, the byte-order mark is prepended to all non-empty strings.

	if ( 2 <= cbMBStr )
	{
		if ( !StartsWithByteOrderMark ( bstrSrc ) )
		{
			cbBuff += 2;	// Reserve space for the byte order mark we'll add.
		}
	}

	// If the file is empty, create a zero length stream, but the global block must be non-zero in size.
	hMem = GlobalAlloc ( GMEM_MOVEABLE|GMEM_ZEROINIT, ( 0 == cbBuff ) ? 2 : cbBuff );

	_ASSERTE(hMem);

	if (NULL == hMem)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	pStrDest = GlobalLock(hMem);

	_ASSERTE(pStrDest);

	if (NULL == pStrDest)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		GlobalFree(hMem);
		goto cleanup;
	}

	// Insert the byte order mark if it is not already there
	pCopyPos = pStrDest;
	if ( cbMBStr != cbBuff )
	{
		InsertByteOrderMark ( pStrDest );
		pCopyPos = &((char*)pCopyPos)[2];	// Advance copy target two bytes.
	}
	memcpy ( pCopyPos, bstrSrc, cbMBStr );
	GlobalUnlock(hMem);

	if (FAILED(hr = CreateStreamOnHGlobal(hMem, TRUE, ppStream)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	_ASSERTE(ppStream);

	ui.LowPart = cbBuff;
	ui.HighPart = 0x00;

	hr = (*ppStream)->SetSize(ui);


	_ASSERTE((*ppStream));

cleanup:

	return hr;
}


//	Post V1.0 change:
//	The stream is expected to be in Unicode now.
//	Just copy the contents to a BSTR.
//	Exception: the stream can begin with FFFE (or theoretically FEFF, but then I think we'd be broken.)
//	If the byte order mark begins the stream, don't copy it to the BSTR UNLESS bfRetainByteOrderMark
//	is set.  This should be retained in the case where we're loading an interal BSTR to be returned
//	to the pluggable protocol.  If the byte order mark is missing in that case, IE5 does not properly
//	convert the string.
//
HRESULT
CSite::HrStreamToBstr(LPSTREAM pStream, BSTR* pBstr, BOOL bfRetainByteOrderMark)
{
	HRESULT hr			= S_OK;
	HGLOBAL hMem		= NULL;
	WCHAR	*pwcData	= NULL;
	STATSTG statStg		= {0};

	_ASSERTE(pStream);
	_ASSERTE(pBstr);

	*pBstr = NULL;

	if (FAILED(hr = GetHGlobalFromStream(pStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	hr = pStream->Stat(&statStg, STATFLAG_NONAME);
	_ASSERTE(SUCCEEDED(hr));

	pwcData = (WCHAR*)GlobalLock(hMem);

	_ASSERTE(pwcData);
	
	if (NULL == pwcData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		return hr;		
	}

	_ASSERTE ( IsUnicode ( pwcData, statStg.cbSize.LowPart ) );

	if ( !bfRetainByteOrderMark && StartsWithByteOrderMark ( pwcData ) )
	{
		pwcData++;	// Skip the first WCHAR
		statStg.cbSize.LowPart -= sizeof(WCHAR);	// This is a byte count rather than a WCHAR count.
	}

	*pBstr = SysAllocStringLen ( pwcData, statStg.cbSize.LowPart / sizeof(WCHAR) );
	
	GlobalUnlock(hMem); 
	return hr;
}


#ifdef _DEBUG_HELPER
static void ExamineStream ( IStream* piStream, char* pchNameOfStream )
{
	HGLOBAL hMem	= NULL;
	LPVOID	pvData	= NULL;
	HRESULT	hr		= S_OK;

	_ASSERTE ( pchNameOfStream );
	hr = GetHGlobalFromStream(piStream, &hMem);
	pvData = GlobalLock ( hMem );
	// Examine *(char*)pvData
	GlobalUnlock ( hMem );
}
#endif


HRESULT
CSite::HrFilter(BOOL bDirection, LPSTREAM pSrcStream, LPSTREAM* ppFilteredStream, DWORD dwFilterFlags)
{
	_ASSERTE(m_pObj);
	_ASSERTE(pSrcStream);
	_ASSERTE(ppFilteredStream);

	HRESULT hr		= S_OK;
	STATSTG statStg	= {0};

	// Test for the exceptional case of an empty stream.  Opening an empyt file can cause this.
	hr = pSrcStream->Stat(&statStg, STATFLAG_NONAME);
	_ASSERTE(SUCCEEDED(hr));

	if ( 0 == statStg.cbSize.HighPart && 0 == statStg.cbSize.LowPart )
	{
		*ppFilteredStream = pSrcStream;
		pSrcStream->AddRef ();
		return S_OK;
	}

	CComQIPtr<ITriEditDocument, &IID_ITriEditDocument> piTriEditDoc(m_pObj);
	CComQIPtr<IStream, &IID_IStream> piFilteredStream;
	DWORD dwTriEditFlags = 0;

#ifdef _DEBUG_HELPER
	ExamineStream ( pSrcStream, "pSrcStream" );
#endif

	if (dwFilterFlags == filterNone)
	{
		pSrcStream->AddRef();
		*ppFilteredStream = pSrcStream;
		return hr;
	}

	// dwTriEditFlags |= dwFilterMultiByteStream; // loading an ANSI Stream NOT ANY MORE.  The stream is ALWAYS Unicode now.

	if (dwFilterFlags & filterDTCs)
		dwTriEditFlags |= dwFilterDTCs;

	if (dwFilterFlags & filterASP)
		dwTriEditFlags |= dwFilterServerSideScripts;

	if (dwFilterFlags & preserveSourceCode)
		dwTriEditFlags |= dwPreserveSourceCode;

	if (dwFilterFlags & filterSourceCode)
		dwTriEditFlags |= filterSourceCode;

	if (!piTriEditDoc)
		return E_NOINTERFACE;

	CComBSTR bstrBaseURL;
	m_pFR->GetBaseURL ( bstrBaseURL );

	if (TRUE == bDirection)
	{
		if (FAILED(hr = piTriEditDoc->FilterIn(pSrcStream, (LPUNKNOWN*) &piFilteredStream, dwTriEditFlags, bstrBaseURL)))
		{
			goto cleanup;
		}
	}
	else
	{
		if (FAILED(hr = piTriEditDoc->FilterOut(pSrcStream, (LPUNKNOWN*) &piFilteredStream, dwTriEditFlags, bstrBaseURL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}
	}

	*ppFilteredStream = piFilteredStream;

#ifdef _DEBUG_HELPER
	ExamineStream ( *ppFilteredStream, "*ppFilteredStream" );
#endif

	_ASSERTE((*ppFilteredStream));
	if (!(*ppFilteredStream))
	{
		hr = E_NOINTERFACE;
		goto cleanup;
	}

	(*ppFilteredStream)->AddRef();

cleanup:

	return hr;
}



// Attempts to open the file specified by the UNC path
// This method is a crude way of seeing if a given file
// is available and current permissions allow for opening
// Returns:
// S_OK is file is available and it can be opened for reading
// else
// HRESULT containing Win32 facility and error code from ::GetLastError()
HRESULT
CSite::HrTestFileOpen(BSTR path)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPTSTR pFileName = NULL;
	HANDLE hFile = NULL;

	pFileName = OLE2T(path);

	_ASSERTE(pFileName);

	hFile = CreateFile(
				pFileName,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);

	if(INVALID_HANDLE_VALUE == hFile)
	{
		DWORD ec = ::GetLastError();

		if ( ERROR_BAD_NETPATH == ec ) ec = ERROR_PATH_NOT_FOUND;
		hr = HRESULT_FROM_WIN32(ec);
	}

	::CloseHandle(hFile);

	return hr;
}


//******************************************************************************************
//
//	Unicode Utilities
//
//	Post V1.0, we changed the internal data format from (unchecked, assumed) MBCS to Unicode.
//	The Stream and associated Trident is always Unicode.
//
//******************************************************************************************


//	This can be called without knowing if the stream is already Unicode or not.
//	Convert stream in place.  Assume the stream is created with CreateStreamOnHGlobal.
//	Convert without using ATL macros.  They give out at about 200KB.
//	If the stream was already Unicode, return S_FALSE.
//
HRESULT CSite::HrConvertStreamToUnicode ( IStream* piStream )
{
	HRESULT hr			= S_OK;
	HGLOBAL hMem		= NULL;
	LPVOID	pbData		= NULL;
	STATSTG statStg		= {0};
	UINT	cwcNewStr	= 0;
	WCHAR	*pwcUnicode	= NULL;

	_ASSERTE(piStream);

	// The stream MUST be created on a global
	if (FAILED(hr = GetHGlobalFromStream(piStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	hr = piStream->Stat(&statStg, STATFLAG_NONAME);
	_ASSERTE(SUCCEEDED(hr));

	if ( 0 == statStg.cbSize.HighPart && 4 > statStg.cbSize.LowPart )
	{
		return S_FALSE;	// If it's not even four bytes long, leave as is.
	}

	pbData = GlobalLock(hMem);

	_ASSERTE(pbData);
	
	if (NULL == pbData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		return hr;		
	}

	// If the stream was already Unicode, do nothing!
	if ( IsUnicode ( pbData, statStg.cbSize.LowPart ) )
	{
		hr = S_FALSE;
		goto exit;
	}
	
	// If IMultilanguage2 is available, try to determine its code page.
	if ( NULL != m_piMLang )
	{
		DetectEncodingInfo	rdei[8];
		int					nScores		= 8;
		DWORD				dwMode		= 0;
		UINT				uiInSize	= statStg.cbSize.LowPart;
		HRESULT				hrCharset	= E_FAIL;

		// Check to see if there's an embedded META charset tag.
		// Only if the appropriate TriEdit is installed will this work.
		// We need access to MLang to make sense out of the result, too.
		_ASSERTE ( m_pObj );
		CComQIPtr<ITriEditExtendedAccess, &IID_ITriEditExtendedAccess> pItex ( m_pObj );
		if ( pItex )
		{
			CComBSTR	bstrCodePage;

			hrCharset = pItex->GetCharsetFromStream ( piStream, &bstrCodePage );
			
			// If "Unicode" is returned, it's got to be bogus.
			// We would have mangled Unicode in the initial translation.
			// This turns out to be a not-so-rare special case.  Outlook produced such files.
			if ( S_OK == hrCharset )
			{
				MIMECSETINFO	mcsi;

				if ( 0 == _wcsicmp ( L"unicode", bstrCodePage ) )
				{
					hrCharset = S_FALSE;
				}
				else
				{
					hrCharset = m_piMLang->GetCharsetInfo ( bstrCodePage, &mcsi );
					if ( SUCCEEDED ( hrCharset ) )
					{
						m_cpCodePage = mcsi.uiInternetEncoding;
					}
				}
			}
			
		}

		// If we found the charset via GetCharsetFromStream, don't use MLang.
		if ( S_OK != hrCharset )
		{

			hr = m_piMLang->DetectCodepageInIStream ( MLDETECTCP_HTML, 0, piStream, rdei, &nScores );

			if ( FAILED ( hr ) )
			{
				goto fallback;	// Use default ANSI code page
			}

			m_cpCodePage = rdei[0].nCodePage;
		}

		hr = m_piMLang->ConvertStringToUnicode ( &dwMode, m_cpCodePage, (char*)pbData, &uiInSize, NULL, &cwcNewStr );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( S_OK != hr )	// S_FALSE for conversion not supported (no such language pack), E_FAIL for internal error.
		{
			goto fallback;	// Use default ANSI code page
		}

		// Create the buffer to convert to.
		pwcUnicode = new WCHAR[cwcNewStr+1];	// One extra character for the byte order mark.
		_ASSERTE ( pwcUnicode );
		if ( NULL == pwcUnicode )
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		InsertByteOrderMark ( pwcUnicode );

		hr = m_piMLang->ConvertStringToUnicode ( &dwMode, m_cpCodePage, (char*)pbData, &uiInSize, &pwcUnicode[1], &cwcNewStr );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( S_OK != hr )	// S_FALSE for conversion not supported (no such language pack), E_FAIL for internal error.
		{
			delete [] pwcUnicode;	// This will be reallocated.
			pwcUnicode = NULL;
			goto fallback;	// Use default ANSI code page
		}
	}
	else
	{
fallback:	// If we attempt to use MLang but fail, we must STILL convert to Unicode...

		// Set code page to default:
		m_cpCodePage = CP_ACP;

		// Count how many wide characters are required:
		cwcNewStr = ::MultiByteToWideChar(GetCurrentCodePage (), 0, (char*)pbData, statStg.cbSize.LowPart, NULL, 0);
		_ASSERTE ( 0 != cwcNewStr );
		if ( 0 == cwcNewStr )
		{
#ifdef _DEBUG
			DWORD dwError = GetLastError ();
			_ASSERTE ( 0 == dwError );
#endif
			goto exit;
		}

		// Create the buffer to convert to.
		pwcUnicode = new WCHAR[cwcNewStr+1];	// One extra character for the byte order mark.
		_ASSERTE ( pwcUnicode );
		if ( NULL == pwcUnicode )
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		InsertByteOrderMark ( pwcUnicode );

		// Create the wide string.  Write starting at position [1], preserving the byte order character.
		cwcNewStr = ::MultiByteToWideChar(GetCurrentCodePage (), 0, (char*)pbData, statStg.cbSize.LowPart, &pwcUnicode[1], cwcNewStr);
		if ( 0 == cwcNewStr )
		{
#ifdef _DEBUG
			DWORD dwError = GetLastError ();
			_ASSERTE ( 0 == dwError );
#endif
			goto exit1;
		}
	}

	// We've successfully read the data in, now replace the stream.  pwcUnicode contains the data.
	ULARGE_INTEGER ui;
	ui.LowPart = (cwcNewStr+1) * 2;	// + 1 for the byte order mark at the beginning.
	ui.HighPart = 0x00;
	hr = piStream->SetSize ( ui );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
		GlobalUnlock(hMem);
		pbData = GlobalLock(hMem);
		memcpy ( pbData, pwcUnicode, (cwcNewStr+1) * 2 );	// Copy string + byte order mark

		// Reposition the mark to the beginning of the stream
		LARGE_INTEGER	liIn	= {0};
		ULARGE_INTEGER	uliOut	= {0};
		piStream->Seek ( liIn, STREAM_SEEK_SET, &uliOut );
	}

exit1:
	delete [] pwcUnicode;

exit:
	GlobalUnlock(hMem);
	return hr;
}



//	Test the buffer to see if it contains a Unicode string.  It's assumed to if:
//	It starts with the byte order marker FFFE or
//	It contains NULL bytes before the last four bytes.
//	If it's less than or equal to four bytes, do not consider it Unicode.
//
BOOL CSite::IsUnicode ( void* pData, int cbSize )
{
	BOOL	bfUnicode	= FALSE;
	CHAR	*pchData	= (CHAR*)pData;

	if ( 4 < cbSize )
	{

	#pragma warning(disable: 4310) // cast truncates constant value
		if ( ( (char)0xff == pchData[0] ) && ( (char)0xfe == pchData[1] ) )
			bfUnicode = TRUE;
		if ( ( (char)0xfe == pchData[0] ) && ( (char)0xff == pchData[1] ) )
	#pragma warning(default: 4310) // cast truncates constant value
		{
			// Reverse order Unicode?  Will this be encountered?
			_ASSERTE ( ! ( (char)0xfe == pchData[0] ) && ( (char)0xff == pchData[1] ) );
			bfUnicode = FALSE;
		}

		if ( ! bfUnicode )
		{
			bfUnicode = FALSE;

			for ( int i = 0; i < cbSize - 4; i++ )
			{
				if ( 0 == pchData[i] )
				{
					bfUnicode = TRUE;
					break;
				}
			}
		}
	}
	return bfUnicode;
}


//	Given a buffer of characters, detect whether its a BigEndian Unicode stream by the first word (FEFF).
//	If not, return FALSE.
//	If so, flip all words to LittleEndian order (FFFE) and return true.
//	Note: this is a storage convention, not an encoding.  This may be encountered in disk files, not in downloads.
//	A Unicode stream should contain an even number of bytes!  If not, we'll assert, but continue.
//
BOOL CSite::BfFlipBytesIfBigEndianUnicode ( CHAR* pchData, int cbSize )
{
	_ASSERTE ( pchData );

	// See if it's Unicode stored in reverse order.
#pragma warning(disable: 4310) // cast truncates constant value
	if ( ( (CHAR)0xFE == pchData[0] ) && ( (CHAR)0xFF == pchData[1] ) )
#pragma warning(default: 4310) // cast truncates constant value
	{
		// A Unicode stream must contain an even number of characters.
		_ASSERTE ( 0 != ( cbSize & 1 ) );

		// This stream is populated with reversed Unicode.  Flip it in place.
		// Subtract 1 from initial byte count to avoid overrunning odd length buffer.
		CHAR chTemp = '\0';
		for ( int iPos = 0; iPos < cbSize - 1; iPos += 2 )
		{
			chTemp = pchData[iPos];
			pchData[iPos] = pchData[iPos+1];
			pchData[iPos+1] = chTemp;
		}
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\win95wrp.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __WIN95WRP_CPP__

#ifndef __WIN95WRP_H__
#define __WIN95WRP_H__

/* HACK! - wininet.h includes iedial.h, and iedial.h includes ocidl.h,
  and ocidl.h defines IProvideClassInfo::GetClassInfo.  If we did not
  pre-reroute GetClassInfoW, then what would happen is that
  ocidl would define
    IProvideClassInfo::GetClassInfo ->
    IProvideClassInfo::GetClassInfoW
  and then we would define GetClassInfoW to OGetClassInfoW, so when <atlcom.h>
  implements IProvideClassInfo, it declares
    IProvideClassInfo::GetClassInfo ->
    IProvideClassInfo::GetClassInfoW ->
    IProvideClassInfo::OGetClassInfoW
  which doesn't match the interface definition, so the compiler yells at us.
 */
#define GetClassInfoW OGetClassInfoW

#include <urlmon.h>
#include <wininet.h>

extern "C"{

BOOL WINAPI OAppendMenuW(HMENU hMenu, UINT uFlags, UINT uIDnewItem, LPCWSTR lpnewItem);
LRESULT WINAPI OCallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI OCharLowerBuffW(LPWSTR lpsz, DWORD cchLength);
LPWSTR WINAPI OCharLowerW(LPWSTR lpsz);
LPWSTR WINAPI OCharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
BOOL WINAPI OCharToOemW(LPCWSTR lpszSrc, LPSTR lpszDst);
LPWSTR WINAPI OCharUpperW(LPWSTR lpsz);
BOOL WINAPI OCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
BOOL WINAPI OCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HDC WINAPI OCreateDCW(LPCWSTR lpszDriver, LPCWSTR lpszDevice, LPCWSTR lpszOutput, CONST DEVMODEW *lpInitData);
BOOL WINAPI OCreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HDC WINAPI OCreateEnhMetaFileW(HDC hdc, LPCWSTR lpFileName, CONST RECT *lpRect, LPCWSTR lpDescription);
HANDLE WINAPI OCreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
HANDLE WINAPI OCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
HFONT WINAPI OCreateFontIndirectW(CONST LOGFONTW * plfw);
HFONT OCreateFontW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace);
HWND WINAPI OCreateMDIWindowW(LPWSTR lpClassName, LPWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
HDC WINAPI OCreateMetaFileW(LPCWSTR lpstr);
HANDLE WINAPI OCreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
HWND WINAPI OCreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
HSZ WINAPI ODdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
UINT WINAPI ODdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
LRESULT WINAPI ODefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI ODeleteFileW(LPCWSTR pwsz);
LRESULT WINAPI ODialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODispatchMessageW(CONST MSG *lpMsg);
int WINAPI ODrawTextW(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);
int WINAPI ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
DWORD WINAPI OExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
VOID WINAPI OFatalAppExitW(UINT uAction, LPCWSTR lpMessageText);
HANDLE WINAPI OFindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
HANDLE WINAPI OFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
BOOL WINAPI OFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
HRSRC WINAPI OFindResourceW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType);
HWND WINAPI OFindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
DWORD WINAPI OFormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
BOOL APIENTRY OGetCharABCWidthsFloatW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABCFLOAT lpABC);
BOOL APIENTRY OGetCharABCWidthsW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABC lpABC);
BOOL APIENTRY OGetCharWidthFloatW(HDC hdc, UINT iFirstChar, UINT iLastChar, PFLOAT pBuffer);
BOOL WINAPI OGetCharWidthW(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
BOOL WINAPI OGetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass);
BOOL WINAPI OGetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSEXW lpWndClass);
DWORD WINAPI OGetClassLongW(HWND hWnd, int nIndex);
DWORD WINAPI OSetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);
int WINAPI OGetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
DWORD WINAPI OGetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
UINT WINAPI OGetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int nMaxCount);
DWORD WINAPI OGetFileAttributesW(LPCWSTR lpFileName);
DWORD WINAPI OGetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
DWORD WINAPI OGetGlyphOutlineW(HDC hdc, UINT uChar, UINT uFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpvBuffer, CONST MAT2 *lpmat2);
DWORD WINAPI OGetKerningPairsW(HDC hdc, DWORD nNumPairs, LPKERNINGPAIR lpkrnpair);
BOOL WINAPI OGetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DWORD WINAPI OGetModuleFileNameW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize);
HMODULE WINAPI OGetModuleHandleW(LPCWSTR lpModuleName);
UINT APIENTRY OGetOutlineTextMetricsW(HDC hdc, UINT cbData, LPOUTLINETEXTMETRICW lpOTM);
UINT WINAPI OGetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
DWORD WINAPI OGetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
int WINAPI OGetObjectW(HGDIOBJ hgdiobj, int cbBuffer, LPVOID lpvObject);
BOOL WINAPI OGetOpenFileNameW(LPOPENFILENAMEW lpofn);
UINT WINAPI OGetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
HANDLE WINAPI OGetPropW(HWND hWnd, LPCWSTR lpString);
BOOL WINAPI OGetSaveFileNameW(LPOPENFILENAMEW lpofn);
DWORD WINAPI OGetTabbedTextExtentW(HDC hDC, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions);
UINT WINAPI OGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
DWORD WINAPI OGetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
BOOL APIENTRY OGetTextExtentPoint32W(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentPointW(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentExPointW(HDC hdc, LPCWSTR lpszStr, int cchString, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE pSize);
LONG WINAPI OGetWindowLongW(HWND hWnd, int nIndex);
BOOL WINAPI OGetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
BOOL WINAPI OGetUserNameW(LPWSTR lpBuffer, LPDWORD nSize);
BOOL WINAPI OGetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
int WINAPI OGetWindowTextLengthW(HWND hWnd);
int WINAPI OGetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
ATOM WINAPI OGlobalAddAtomW(LPCWSTR lpString);
UINT WINAPI OGlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
BOOL WINAPI OGrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
BOOL WINAPI OInsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OIsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
BOOL WINAPI OIsCharAlphaNumericW(WCHAR wch);
BOOL WINAPI OIsCharAlphaW(WCHAR wch);
BOOL WINAPI OIsDialogMessageW(HWND hDlg, LPMSG lpMsg);
int WINAPI OLCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
HACCEL WINAPI OLoadAcceleratorsW(HINSTANCE hInst, LPCWSTR lpTableName);
HBITMAP WINAPI OLoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);
HCURSOR WINAPI OLoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
HICON WINAPI OLoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
HINSTANCE WINAPI OLoadLibraryW(LPCWSTR pwszFileName);
HMODULE WINAPI OLoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
HMENU WINAPI OLoadMenuIndirectW(CONST MENUTEMPLATEW *lpMenuTemplate);
HMENU WINAPI OLoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
int WINAPI OLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);
LPWSTR WINAPI OlstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
int WINAPI OlstrlenW(LPCWSTR lpString);
UINT WINAPI OMapVirtualKeyW(UINT uCode, UINT uMapType);
int WINAPI OMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
int WINAPI OMessageBoxIndirectW(LPMSGBOXPARAMSW lpmbp);
BOOL WINAPI OModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OMoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
BOOL WINAPI OMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
HANDLE WINAPI OLoadImageW(HINSTANCE hinst, LPCWSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
BOOL WINAPI OOemToCharW(LPCSTR lpszSrc, LPWSTR lpszDst);
VOID WINAPI OOutputDebugStringW(LPCWSTR lpOutputString);
BOOL WINAPI OPeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
BOOL WINAPI OPostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OPostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
LONG APIENTRY ORegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG APIENTRY ORegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
LONG APIENTRY ORegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
LONG APIENTRY ORegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);
LONG APIENTRY ORegDeleteKeyW(HKEY hKey, LPCWSTR pwszSubKey);
LONG APIENTRY ORegDeleteValueW(HKEY hKey, LPWSTR lpValueName);
ATOM WINAPI ORegisterClassW(CONST WNDCLASSW *lpWndClass);
ATOM WINAPI ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass);
BOOL WINAPI OUnregisterClassW(LPCTSTR  lpClassName, HINSTANCE  hInstance);
UINT WINAPI ORegisterClipboardFormatW(LPCWSTR lpszFormat);
UINT WINAPI ORegisterWindowMessageW(LPCWSTR lpString);
LONG APIENTRY ORegOpenKeyExW(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
LONG APIENTRY ORegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
LONG APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue, PLONG lpcbValue);
LONG APIENTRY ORegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE* lpData, DWORD cbData);
LONG APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
LONG APIENTRY ORegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HANDLE WINAPI ORemovePropW(HWND hWnd, LPCWSTR lpString);
LRESULT WINAPI OSendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI OSendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
BOOL WINAPI OSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
BOOL WINAPI OSetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
BOOL WINAPI OSetMenuItemInfoW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW lpcmii);
LONG WINAPI OSetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong); 
HHOOK WINAPI OSetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
BOOL WINAPI OSetWindowTextW(HWND hWnd, LPCWSTR lpString);
LONG WINAPI OTabbedTextOutW(HDC hDC, int X, int Y, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
// FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
//int WINAPI OTranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
SHORT WINAPI OVkKeyScanW(WCHAR ch);
BOOL WINAPI OWinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, DWORD dwData);
BOOL WINAPI OWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
int WINAPIV OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);
BOOL WINAPI OGetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
LONG APIENTRY ORegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
HANDLE WINAPI OCreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
LRESULT WINAPI ODefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI OGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
BOOL WINAPI OSetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);
HRESULT WINAPI OStgCreateDocfile(const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, IStorage ** ppstgOpen);
int WINAPI OStartDocW(HDC hDC, CONST DOCINFOW * pdiDocW);
BOOL WINAPI OSystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
LPWSTR WINAPI OCharNextW(LPCWSTR lpsz);

// Added by VK -- 12/1/98
HRESULT __stdcall OURLOpenBlockingStreamW(LPUNKNOWN pCaller, LPCWSTR wszURL, LPSTREAM *ppStream, DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
BOOL WINAPI OInternetCreateUrlW(LPURL_COMPONENTSW lpUrlComponents, DWORD dwFlags, LPWSTR lpwszUrl, LPDWORD lpdwUrlLength);
BOOL WINAPI OInternetCrackUrlW(LPCWSTR lpwszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTSW lpUrlComponents);
BOOL WINAPI ODeleteUrlCacheEntryW(LPCWSTR lpwszUrlName);

// Added by VK -- 8/10/99
HINTERNET WINAPI OInternetOpenW(LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags);
HINTERNET WINAPI OInternetOpenUrlW(HINTERNET hInternet, LPCWSTR lpszUrl, LPCWSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext);

#ifdef DEBUG
int WINAPI ODlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
int WINAPI ODlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
BOOL WINAPI ODlgDirSelectComboBoxExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDComboBox);
BOOL WINAPI ODlgDirSelectExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDListBox);
#endif

} // extern "C"

#define AppendMenuW OAppendMenuW
#define CallWindowProcW OCallWindowProcW
#define CharLowerBuffW OCharLowerBuffW
#define CharLowerW OCharLowerW
#define CharNextW OCharNextW
#define CharPrevW OCharPrevW
#define CharToOemW OCharToOemW
#define CharUpperW OCharUpperW
#define CopyFileW OCopyFileW
#define CreateDCW OCreateDCW
#define CreateDirectoryExW OCreateDirectoryExW
#define CreateDirectoryW OCreateDirectoryW
#define CreateEnhMetaFileW OCreateEnhMetaFileW
#define CreateEventW OCreateEventW
#define CreateFileMappingW OCreateFileMappingW
#define CreateFileW OCreateFileW
#define CreateFontIndirectW OCreateFontIndirectW
#define CreateFontW OCreateFontW
#define CreateMDIWindowW OCreateMDIWindowW
#define CreateMetaFileW OCreateMetaFileW
#define CreateSemaphoreW OCreateSemaphoreW
#define CreateWindowExW OCreateWindowExW
#define DdeCreateStringHandleW ODdeCreateStringHandleW
#define DdeInitializeW ODdeInitializeW
#define DefFrameProcW ODefFrameProcW
#define DefMDIChildProcW ODefMDIChildProcW
#define DefWindowProcW ODefWindowProcW
#define DeleteFileW ODeleteFileW
#define DialogBoxIndirectParamW ODialogBoxIndirectParamW
#define DialogBoxParamW ODialogBoxParamW
#define DispatchMessageW ODispatchMessageW
#define DrawTextExW ODrawTextExW
#define DrawTextW ODrawTextW
#define ExpandEnvironmentStringsW OExpandEnvironmentStringsW
#define FatalAppExitW OFatalAppExitW
#define FindFirstChangeNotificationW OFindFirstChangeNotificationW
#define FindFirstFileW OFindFirstFileW
#define FindNextFileW OFindNextFileW
#define FindResourceW OFindResourceW
#define FindWindowW OFindWindowW
#define FormatMessageW OFormatMessageW
#define GetCharABCWidthsFloatW OGetCharABCWidthsFloatW
#define GetCharABCWidthsW OGetCharABCWidthsW
#define GetCharWidthFloatW OGetCharWidthFloatW
#define GetCharWidthW OGetCharWidthW
// HACKHACK(VK)  Next two temporarily commented out due to change in WinINet (including defines)
// Remove before 5.5 B3.  Temporary safety fix, long term maintenance problem:
//#define GetClassInfoW OGetClassInfoW
//#define GetClassInfoExW OGetClassInfoExW
#define GetClassLongW OGetClassLongW
#define GetClassNameW OGetClassNameW
#define GetCurrentDirectoryW OGetCurrentDirectoryW
#define GetDlgItemTextW OGetDlgItemTextW
#define GetFileAttributesW OGetFileAttributesW
#define GetFullPathNameW OGetFullPathNameW
#define GetGlyphOutlineW OGetGlyphOutlineW
#define GetKerningPairsW OGetKerningPairsW
#define GetLocaleInfoW OGetLocaleInfoW
#define GetMessageW OGetMessageW
#define GetModuleFileNameW OGetModuleFileNameW
#define GetModuleHandleW OGetModuleHandleW
#define GetObjectW OGetObjectW
#define GetOpenFileNameW OGetOpenFileNameW
#define GetOutlineTextMetricsW OGetOutlineTextMetricsW
#define GetPrivateProfileIntW OGetPrivateProfileIntW
#define GetPrivateProfileStringW OGetPrivateProfileStringW
#define GetProfileIntW OGetProfileIntW
#define GetPropW OGetPropW
#define GetSaveFileNameW OGetSaveFileNameW
#define GetTabbedTextExtentW OGetTabbedTextExtentW
#define GetTempFileNameW OGetTempFileNameW
#define GetTempPathW OGetTempPathW
#define GetTextExtentPoint32W OGetTextExtentPoint32W
#define GetTextExtentPointW OGetTextExtentPointW
#define GetTextExtentExPointW OGetTextExtentExPointW
#define GetTextMetricsW OGetTextMetricsW
#define GetUserNameW OGetUserNameW
#define GetVersionExW OGetVersionExW
#define GetVolumeInformationW OGetVolumeInformationW
#define GetWindowLongW OGetWindowLongW
#define GetWindowTextLengthW OGetWindowTextLengthW
#define GetWindowTextW OGetWindowTextW
#define GlobalAddAtomW OGlobalAddAtomW
#define GlobalGetAtomNameW OGlobalGetAtomNameW
#define GrayStringW OGrayStringW
#define InsertMenuW OInsertMenuW
#define IsBadStringPtrW OIsBadStringPtrW
#define IsCharAlphaNumericW OIsCharAlphaNumericW
#define IsCharAlphaW OIsCharAlphaW
#define IsDialogMessageW OIsDialogMessageW
#define LCMapStringW OLCMapStringW
#define LoadAcceleratorsW OLoadAcceleratorsW
#define LoadBitmapW OLoadBitmapW
#define LoadCursorW OLoadCursorW
#define LoadIconW OLoadIconW
#define LoadImageW OLoadImageW
#define LoadLibraryExW OLoadLibraryExW
#define LoadLibraryW OLoadLibraryW
#define LoadMenuIndirectW OLoadMenuIndirectW
#define LoadMenuW OLoadMenuW
#define LoadStringW OLoadStringW
#define lstrcatW OlstrcatW
#define lstrcmpiW OlstrcmpiW
#define lstrcmpW OlstrcmpW
#define lstrcpynW OlstrcpynW
#define lstrcpyW OlstrcpyW
#define lstrlenW OlstrlenW
#define MapVirtualKeyW OMapVirtualKeyW
#define MessageBoxW OMessageBoxW
#define MessageBoxIndirectW OMessageBoxIndirectW
#define ModifyMenuW OModifyMenuW
#define MoveFileExW OMoveFileExW
#define MoveFileW OMoveFileW
#define OemToCharW OOemToCharW
#define OutputDebugStringW OOutputDebugStringW
#define PeekMessageW OPeekMessageW
#define PostMessageW OPostMessageW
#define PostThreadMessageW OPostThreadMessageW
#define RegCreateKeyExW ORegCreateKeyExW
#define RegCreateKeyW ORegCreateKeyW
#define RegDeleteKeyW ORegDeleteKeyW
#define RegDeleteValueW ORegDeleteValueW
#define RegEnumKeyW ORegEnumKeyW
#define RegEnumValueW ORegEnumValueW
#define RegEnumKeyExW ORegEnumKeyExW
#define RegisterClassW ORegisterClassW
#define RegisterClassExW ORegisterClassExW
#define RegisterClipboardFormatW ORegisterClipboardFormatW
#define RegisterWindowMessageW ORegisterWindowMessageW
#define RegOpenKeyExW ORegOpenKeyExW
#define RegOpenKeyW ORegOpenKeyW
#define RegQueryInfoKeyW ORegQueryInfoKeyW
#define RegQueryValueExW ORegQueryValueExW
#define RegQueryValueW ORegQueryValueW
#define RegSetValueExW ORegSetValueExW
#define RegSetValueW ORegSetValueW
#define RemovePropW ORemovePropW
#define SendDlgItemMessageW OSendDlgItemMessageW
#define SendMessageW OSendMessageW
#define SendNotifyMessageW OSendNotifyMessageW
#define SetDlgItemTextW OSetDlgItemTextW
#define SetFileAttributesW OSetFileAttributesW
#define SetLocaleInfoW OSetLocaleInfoW
#define SetMenuItemInfoW OSetMenuItemInfoW
#define SetPropW OSetPropW
#define SetWindowLongW OSetWindowLongW
#define SetWindowsHookExW OSetWindowsHookExW
#define SetWindowTextW OSetWindowTextW
#define StartDocW OStartDocW
#define StgCreateDocfile OStgCreateDocfile
#define SystemParametersInfoW OSystemParametersInfoW
#define TabbedTextOutW OTabbedTextOutW
// #define TranslateAcceleratorW OTranslateAcceleratorW	FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
#define UnregisterClassW OUnregisterClassW
#define VkKeyScanW OVkKeyScanW
#define WinHelpW OWinHelpW
#define WritePrivateProfileStringW OWritePrivateProfileStringW
#define wsprintfW OwsprintfW

// Added by VK -- 12/1/98
#define URLOpenBlockingStreamW OURLOpenBlockingStreamW
#define InternetCreateUrlW OInternetCreateUrlW
#define InternetCrackUrlW OInternetCrackUrlW
#define DeleteUrlCacheEntryW ODeleteUrlCacheEntryW

// Added by VK -- 8/10/99
#define InternetOpenW OInternetOpenW
#define InternetOpenUrlW OInternetOpenUrlW


// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#define AbortSystemShutdownW OAbortSystemShutdownW
#define AccessCheckAndAuditAlarmW OAccessCheckAndAuditAlarmW
#define AddFontResourceW OAddFontResourceW
#define AddFormW OAddFormW
#define AddJobW OAddJobW
#define AddMonitorW OAddMonitorW
#define AddPortW OAddPortW
#define AddPrinterConnectionW OAddPrinterConnectionW
#define AddPrinterDriverW OAddPrinterDriverW
#define AddPrinterW OAddPrinterW
#define AddPrintProcessorW OAddPrintProcessorW
#define AddPrintProvidorW OAddPrintProvidorW
#define AdvancedDocumentPropertiesW OAdvancedDocumentPropertiesW
#define auxGetDevCapsW OauxGetDevCapsW
#define BackupEventLogW OBackupEventLogW
#define BeginUpdateResourceW OBeginUpdateResourceW
#define BuildCommDCBAndTimeoutsW OBuildCommDCBAndTimeoutsW
#define BuildCommDCBW OBuildCommDCBW
#define CallMsgFilterW OCallMsgFilterW
#define CallNamedPipeW OCallNamedPipeW
#define ChangeDisplaySettingsW OChangeDisplaySettingsW
#define ChangeMenuW OChangeMenuW
#define CharToOemBuffW OCharToOemBuffW
#define CharUpperBuffW OCharUpperBuffW
#define ChooseColorW OChooseColorW
#define ChooseFontW OChooseFontW
#define ClearEventLogW OClearEventLogW
#define CommConfigDialogW OCommConfigDialogW
#define CompareStringW OCompareStringW
#define ConfigurePortW OConfigurePortW
#define CopyAcceleratorTableW OCopyAcceleratorTableW
#define CopyEnhMetaFileW OCopyEnhMetaFileW
#define CopyMetaFileW OCopyMetaFileW
#define CreateAcceleratorTableW OCreateAcceleratorTableW
#define CreateColorSpaceW OCreateColorSpaceW
#define CreateDesktopW OCreateDesktopW
#define CreateDialogIndirectParamW OCreateDialogIndirectParamW
#define CreateDialogParamW OCreateDialogParamW
#define CreateICW OCreateICW
#define CreateMailslotW OCreateMailslotW
#define CreateMutexW OCreateMutexW
#define CreateNamedPipeW OCreateNamedPipeW
#define CreateProcessW OCreateProcessW
#define CreateProcessAsUserW OCreateProcessAsUserW
#define CreatePropertySheetPageW OCreatePropertySheetPageW
#define CreateScalableFontResourceW OCreateScalableFontResourceW
#define CreateStatusWindowW OCreateStatusWindowW
#define CreateWindowStationW OCreateWindowStationW
#define DceErrorInqTextW ODceErrorInqTextW
#define DdeQueryStringW   ODdeQueryStringW
#define DefDlgProcW ODefDlgProcW
#define DefineDosDeviceW ODefineDosDeviceW
#define DeleteFormW ODeleteFormW
#define DeleteMonitorW ODeleteMonitorW
#define DeletePortW ODeletePortW
#define DeletePrinterConnectionW ODeletePrinterConnectionW
#define DeletePrinterDriverW ODeletePrinterDriverW
#define DeletePrintProcessorW ODeletePrintProcessorW
#define DeletePrintProvidorW ODeletePrintProvidorW
#define DeviceCapabilitiesW ODeviceCapabilitiesW
#define DlgDirListComboBoxW ODlgDirListComboBoxW
#define DlgDirListW ODlgDirListW
#define DlgDirSelectComboBoxExW ODlgDirSelectComboBoxExW
#define DlgDirSelectExW ODlgDirSelectExW
#define DocumentPropertiesW ODocumentPropertiesW
#define DoEnvironmentSubstW ODoEnvironmentSubstW
#define DragQueryFileW ODragQueryFileW
#define DrawStateW ODrawStateW
#define EndUpdateResourceW OEndUpdateResourceW
#define EnumCalendarInfoW OEnumCalendarInfoW
#define EnumDateFormatsW OEnumDateFormatsW
#define EnumDesktopsW OEnumDesktopsW
#define EnumDisplaySettingsW OEnumDisplaySettingsW
#define EnumFontFamiliesExW OEnumFontFamiliesExW
#define EnumFontFamiliesW OEnumFontFamiliesW
#define EnumFontsW OEnumFontsW
#define EnumFormsW OEnumFormsW
#define EnumICMProfilesW OEnumICMProfilesW
#define EnumJobsW OEnumJobsW
#define EnumMonitorsW OEnumMonitorsW
#define EnumPortsW OEnumPortsW
#define EnumPrinterDriversW OEnumPrinterDriversW
#define EnumPrintersW OEnumPrintersW
#define EnumPrintProcessorDatatypesW OEnumPrintProcessorDatatypesW
#define EnumPrintProcessorsW OEnumPrintProcessorsW
#define EnumPropsExW OEnumPropsExW
#define EnumPropsW OEnumPropsW
#define EnumProtocolsW OEnumProtocolsW
#define EnumResourceLanguagesW OEnumResourceLanguagesW
#define EnumResourceNamesW OEnumResourceNamesW
#define EnumResourceTypesW OEnumResourceTypesW
#define EnumSystemCodePagesW OEnumSystemCodePagesW
#define EnumSystemLocalesW OEnumSystemLocalesW
#define EnumTimeFormatsW OEnumTimeFormatsW
#define EnumWindowStationsW OEnumWindowStationsW
#define ExtractAssociatedIconW OExtractAssociatedIconW
#define ExtractIconW OExtractIconW
#define ExtractIconExW OExtractIconExW
#define FillConsoleOutputCharacterW OFillConsoleOutputCharacterW
#define FindEnvironmentStringW OFindEnvironmentStringW
#define FindExecutableW OFindExecutableW
#define FindResourceExW OFindResourceExW
#define FindTextW OFindTextW
#define FindWindowExW OFindWindowExW
#define FoldStringW OFoldStringW
#define GetBinaryTypeW OGetBinaryTypeW
#define GetCharacterPlacementW OGetCharacterPlacementW
#define GetCharWidth32W OGetCharWidth32W
#define GetCommandLineW OGetCommandLineW
#define GetClipboardFormatNameW OGetClipboardFormatNameW
#define GetCompressedFileSizeW OGetCompressedFileSizeW
#define GetComputerNameW OGetComputerNameW
#define GetConsoleTitleW OGetConsoleTitleW
#define GetCurrencyFormatW OGetCurrencyFormatW
#define GetDateFormatW OGetDateFormatW
#define GetDefaultCommConfigW OGetDefaultCommConfigW
#define GetDiskFreeSpaceW OGetDiskFreeSpaceW
#define GetDriveTypeW OGetDriveTypeW
#define GetEnhMetaFileDescriptionW OGetEnhMetaFileDescriptionW
#define GetEnhMetaFileW OGetEnhMetaFileW
#define GetEnvironmentVariableW OGetEnvironmentVariableW
#define GetExpandedNameW OGetExpandedNameW
#define GetFileSecurityW OGetFileSecurityW
#define GetFileTitleW OGetFileTitleW
#define GetFileVersionInfoW OGetFileVersionInfoW
#define GetFileVersionInfoSizeW OGetFileVersionInfoSizeW
#define GetFormW OGetFormW
#define GetICMProfileW OGetICMProfileW
#define GetJobW OGetJobW
#define GetKeyboardLayoutNameW OGetKeyboardLayoutNameW
#define GetKeyNameTextW OGetKeyNameTextW
#define GetLogColorSpaceW OGetLogColorSpaceW
#define GetLogicalDriveStringsW OGetLogicalDriveStringsW
#define GetMenuItemInfoW OGetMenuItemInfoW
#define GetMenuStringW OGetMenuStringW
#define GetMetaFileW OGetMetaFileW
#define GetNameByTypeW OGetNameByTypeW
#define GetNamedPipeHandleStateW OGetNamedPipeHandleStateW
#define GetNumberFormatW OGetNumberFormatW
#define GetPrinterW OGetPrinterW
#define GetPrinterDataW OGetPrinterDataW
#define GetPrinterDriverDirectoryW OGetPrinterDriverDirectoryW
#define GetPrinterDriverW OGetPrinterDriverW
#define GetPrintProcessorDirectoryW OGetPrintProcessorDirectoryW
#define GetPrivateProfileSectionNamesW OGetPrivateProfileSectionNamesW
#define GetPrivateProfileSectionW OGetPrivateProfileSectionW
#define GetPrivateProfileStructW OGetPrivateProfileStructW
#define GetProfileSectionW OGetProfileSectionW
#define GetProfileStringW OGetProfileStringW
#define GetShortPathNameW OGetShortPathNameW
#define GetStartupInfoW OGetStartupInfoW
#define GetStringTypeExW OGetStringTypeExW
#define GetSystemDirectoryW OGetSystemDirectoryW
#define GetTextFaceW OGetTextFaceW
#define GetTimeFormatW OGetTimeFormatW
#define GetTypeByNameW OGetTypeByNameW
#define GetUserObjectInformationW OGetUserObjectInformationW
#define GetWindowsDirectoryW OGetWindowsDirectoryW
#define GlobalFindAtomW OGlobalFindAtomW
#define ImageList_LoadImageW OImageList_LoadImageW
#define ImmConfigureIMEW OImmConfigureIMEW
#define ImmEnumRegisterWordW OImmEnumRegisterWordW
#define ImmEscapeW OImmEscapeW
#define ImmGetCandidateListCountW OImmGetCandidateListCountW
#define ImmGetCandidateListW OImmGetCandidateListW
#define ImmGetCompositionFontW OImmGetCompositionFontW
#define ImmGetCompositionStringW OImmGetCompositionStringW
#define ImmGetConversionListW OImmGetConversionListW
#define ImmGetDescriptionW OImmGetDescriptionW
#define ImmGetGuideLineW OImmGetGuideLineW
#define ImmGetIMEFileNameW OImmGetIMEFileNameW
#define ImmGetRegisterWordStyleW OImmGetRegisterWordStyleW
#define ImmInstallIMEW OImmInstallIMEW
#define ImmIsUIMessageW OImmIsUIMessageW
#define ImmRegisterWordW OImmRegisterWordW
#define ImmSetCompositionFontW OImmSetCompositionFontW
#define ImmSetCompositionStringW OImmSetCompositionStringW
#define ImmUnregisterWordW OImmUnregisterWordW
#define InitiateSystemShutdownW OInitiateSystemShutdownW
#define InsertMenuItemW OInsertMenuItemW
#define IsCharLowerW OIsCharLowerW
#define IsCharUpperW OIsCharUpperW
#define I_RpcServerUnregisterEndpointW OI_RpcServerUnregisterEndpointW
#define joyGetDevCapsW OjoyGetDevCapsW
#define LoadCursorFromFileW OLoadCursorFromFileW
#define LoadKeyboardLayoutW OLoadKeyboardLayoutW
#define LogonUserW OLogonUserW
#define LZOpenFileW OLZOpenFileW
#define MapVirtualKeyExW OMapVirtualKeyExW
#define MIMEAssociationDialogW OMIMEAssociationDialogW
#define MultinetGetConnectionPerformanceW OMultinetGetConnectionPerformanceW
#define ObjectCloseAuditAlarmW OObjectCloseAuditAlarmW
#define ObjectOpenAuditAlarmW OObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarmW OObjectPrivilegeAuditAlarmW
#define OemToCharBuffW OOemToCharBuffW
#define OpenBackupEventLogW OOpenBackupEventLogW
#define OpenDesktopW OOpenDesktopW
#define OpenEventLogW OOpenEventLogW
#define OpenEventW OOpenEventW
#define OpenFileMappingW OOpenFileMappingW
#define OpenMutexW OOpenMutexW
#define OpenPrinterW OOpenPrinterW
#define OpenSemaphoreW OOpenSemaphoreW
#define OpenWindowStationW OOpenWindowStationW
#define PageSetupDlgW OPageSetupDlgW
#define PeekConsoleInputW OPeekConsoleInputW
#define PolyTextOutW OPolyTextOutW
#define PrintDlgW OPrintDlgW
#define PrinterMessageBoxW OPrinterMessageBoxW
#define PrivilegedServiceAuditAlarmW OPrivilegedServiceAuditAlarmW
#define PropertySheetW OPropertySheetW
#define QueryDosDeviceW OQueryDosDeviceW
#define ReadConsoleInputW OReadConsoleInputW
#define ReadConsoleOutputCharacterW OReadConsoleOutputCharacterW
#define ReadConsoleOutputW OReadConsoleOutputW
#define ReadConsoleW OReadConsoleW
#define ReadEventLogW OReadEventLogW
#define RegConnectRegistryW ORegConnectRegistryW
#define RegisterEventSourceW ORegisterEventSourceW
#define RegLoadKeyW ORegLoadKeyW
#define RegQueryMultipleValuesW ORegQueryMultipleValuesW
#define RegReplaceKeyW ORegReplaceKeyW
#define RegRestoreKeyW ORegRestoreKeyW
#define RegSaveKeyW ORegSaveKeyW
#define RegUnLoadKeyW ORegUnLoadKeyW
#define RemoveDirectoryW ORemoveDirectoryW
#define RemoveFontResourceW ORemoveFontResourceW
#define ReplaceTextW OReplaceTextW
#define ReportEventW OReportEventW
#define ResetDCW OResetDCW
#define ResetPrinterW OResetPrinterW
#define RpcBindingFromStringBindingW ORpcBindingFromStringBindingW
#define RpcBindingInqAuthClientW ORpcBindingInqAuthClientW
#define RpcBindingToStringBindingW ORpcBindingToStringBindingW
#define RpcEpRegisterNoReplaceW ORpcEpRegisterNoReplaceW
#define RpcMgmtEpEltInqNextW ORpcMgmtEpEltInqNextW
#define RpcMgmtInqServerPrincNameW ORpcMgmtInqServerPrincNameW
#define RpcNetworkInqProtseqsW ORpcNetworkInqProtseqsW
#define RpcNetworkIsProtseqValidW ORpcNetworkIsProtseqValidW
#define RpcNsBindingInqEntryNameW ORpcNsBindingInqEntryNameW
#define RpcProtseqVectorFreeW ORpcProtseqVectorFreeW
#define RpcServerInqDefaultPrincNameW ORpcServerInqDefaultPrincNameW
#define RpcServerUseProtseqEpW ORpcServerUseProtseqEpW
#define RpcServerUseProtseqIfW ORpcServerUseProtseqIfW
#define RpcServerUseProtseqW ORpcServerUseProtseqW
#define RpcStringBindingComposeW ORpcStringBindingComposeW
#define RpcStringBindingParseW ORpcStringBindingParseW
#define RpcStringFreeW ORpcStringFreeW
#define ScrollConsoleScreenBufferW OScrollConsoleScreenBufferW
#define SearchPathW OSearchPathW
#define SendMessageCallbackW OSendMessageCallbackW
#define SendMessageTimeoutW OSendMessageTimeoutW
#define SetClassLongW OSetClassLongW
#define SetComputerNameW OSetComputerNameW
#define SetConsoleTitleW OSetConsoleTitleW
#define SetCurrentDirectoryW OSetCurrentDirectoryW
#define SetDefaultCommConfigW OSetDefaultCommConfigW
#define SetEnvironmentVariableW OSetEnvironmentVariableW
#define SetFileSecurityW OSetFileSecurityW
#define SetFormW OSetFormW
#define SetICMProfileW OSetICMProfileW
#define SetJobW OSetJobW
#define SetPrinterDataW OSetPrinterDataW
#define SetPrinterW OSetPrinterW
#define SetUserObjectInformationW OSetUserObjectInformationW
#define SetVolumeLabelW OSetVolumeLabelW
#define SetWindowsHookW OSetWindowsHookW
#define SHBrowseForFolderW OSHBrowseForFolderW
#define Shell_NotifyIconW OShell_NotifyIconW
#define ShellAboutW OShellAboutW
#define ShellExecuteW OShellExecuteW
#define ShellExecuteExW OShellExecuteExW
#define SHFileOperationW OSHFileOperationW
#define SHGetFileInfoW OSHGetFileInfoW
#define SHGetNewLinkInfoW OSHGetNewLinkInfoW
#define SHGetPathFromIDListW OSHGetPathFromIDListW
#define sndPlaySoundW OsndPlaySoundW
#define StartDocPrinterW OStartDocPrinterW
#define StgCreateDocfile OStgCreateDocfile
#define TranslateURLW OTranslateURLW
#define UpdateICMRegKeyW OUpdateICMRegKeyW
#define URLAssociationDialogW OURLAssociationDialogW
#define UuidFromStringW OUuidFromStringW
#define VerFindFileW OVerFindFileW
#define VerInstallFileW OVerInstallFileW
#define VerLanguageNameW OVerLanguageNameW
#define VerQueryValueW OVerQueryValueW
#define VkKeyScanExW OVkKeyScanExW
#define WaitNamedPipeW OWaitNamedPipeW
#define waveInGetDevCapsW OwaveInGetDevCapsW
#define waveInGetErrorTextW OwaveInGetErrorTextW
#define waveOutGetDevCapsW OwaveOutGetDevCapsW
#define waveOutGetErrorTextW OwaveOutGetErrorTextW
#define wglUseFontBitmapsW OwglUseFontBitmapsW
#define wglUseFontOutlinesW OwglUseFontOutlinesW
#define WinExecErrorW OWinExecErrorW
#define WNetAddConnection2W OWNetAddConnection2W
#define WNetAddConnection3W OWNetAddConnection3W
#define WNetAddConnectionW OWNetAddConnectionW
#define WNetCancelConnection2W OWNetCancelConnection2W
#define WNetCancelConnectionW OWNetCancelConnectionW
#define WNetConnectionDialog1W OWNetConnectionDialog1W
#define WNetDisconnectDialog1W OWNetDisconnectDialog1W
#define WNetEnumResourceW OWNetEnumResourceW
#define WNetGetConnectionW OWNetGetConnectionW
#define WNetGetLastErrorW OWNetGetLastErrorW
#define WNetGetNetworkInformationW OWNetGetNetworkInformationW
#define WNetGetProviderNameW OWNetGetProviderNameW
#define WNetGetUniversalNameW OWNetGetUniversalNameW
#define WNetGetUserW OWNetGetUserW
#define WNetOpenEnumW OWNetOpenEnumW
#define WNetSetConnectionW OWNetSetConnectionW
#define WNetUseConnectionW OWNetUseConnectionW
#define WriteConsoleInputW OWriteConsoleInputW
#define WriteConsoleOutputCharacterW OWriteConsoleOutputCharacterW
#define WriteConsoleOutputW OWriteConsoleOutputW
#define WriteConsoleW OWriteConsoleW
#define WritePrivateProfileSectionW OWritePrivateProfileSectionW
#define WritePrivateProfileStructW OWritePrivateProfileStructW
#define WriteProfileSectionW OWriteProfileSectionW
#define WriteProfileStringW OWriteProfileStringW
#define wvsprintfW OwvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_H__

#else // __WIN95WRP_CPP__

#undef AppendMenuW
#undef CallWindowProcW
#undef CharLowerBuffW
#undef CharLowerW
#undef CharNextW
#undef CharPrevW
#undef CharToOemW
#undef CharUpperW
#undef CopyFileW
#undef CreateDCW
#undef CreateDirectoryExW
#undef CreateDirectoryW
#undef CreateEnhMetaFileW
#undef CreateEventW
#undef CreateFileMappingW
#undef CreateFileW
#undef CreateFontIndirectW
#undef CreateFontW
#undef CreateMDIWindowW
#undef CreateMetaFileW
#undef CreateSemaphoreW
#undef CreateWindowExW
#undef DdeCreateStringHandleW
#undef DdeInitializeW
#undef DefFrameProcW
#undef DefMDIChildProcW
#undef DefWindowProcW
#undef DeleteFileW
#undef DialogBoxIndirectParamW
#undef DialogBoxParamW
#undef DispatchMessageW
#undef DrawTextExW
#undef DrawTextW
#undef ExpandEnvironmentStringsW
#undef FatalAppExitW
#undef FindFirstChangeNotificationW
#undef FindFirstFileW
#undef FindNextFileW
#undef FindResourceW
#undef FindWindowW
#undef FormatMessageW
#undef GetCharABCWidthsFloatW
#undef GetCharABCWidthsW
#undef GetCharWidthFloatW
#undef GetCharWidthW
#undef GetClassInfoW
#undef GetClassInfoExW
#undef GetClassLongW
#undef GetClassNameW
#undef GetCurrentDirectoryW
#undef GetDlgItemTextW
#undef GetFileAttributesW
#undef GetFullPathNameW
#undef GetGlyphOutlineW
#undef GetKerningPairsW
#undef GetLocaleInfoW
#undef GetMessageW
#undef GetModuleFileNameW
#undef GetModuleHandleW
#undef GetObjectW
#undef GetOpenFileNameW
#undef GetOutlineTextMetricsW
#undef GetPrivateProfileIntW
#undef GetPrivateProfileStringW
#undef GetProfileIntW
#undef GetPropW
#undef GetSaveFileNameW
#undef GetTabbedTextExtentW
#undef GetTempFileNameW
#undef GetTempPathW
#undef GetTextExtentPoint32W
#undef GetTextExtentPointW
#undef GetTextExtentExPointW
#undef GetTextMetricsW
#undef GetUserNameW
#undef GetVersionExW
#undef GetVolumeInformationW
#undef GetWindowLongW
#undef GetWindowTextLengthW
#undef GetWindowTextW
#undef GlobalAddAtomW
#undef GlobalGetAtomNameW
#undef GrayStringW
#undef InsertMenuW
#undef IsBadStringPtrW
#undef IsCharAlphaNumericW
#undef IsCharAlphaW
#undef IsDialogMessageW
#undef LCMapStringW
#undef LoadAcceleratorsW
#undef LoadBitmapW
#undef LoadCursorW
#undef LoadIconW
#undef LoadImageW
#undef LoadLibraryExW
#undef LoadLibraryW
#undef LoadMenuIndirectW
#undef LoadMenuW
#undef LoadStringW
#undef lstrcatW
#undef lstrcmpiW
#undef lstrcmpW
#undef lstrcpynW
#undef lstrcpyW
#undef lstrlenW
#undef MapVirtualKeyW
#undef MessageBoxW
#undef MessageBoxIndirectW
#undef ModifyMenuW
#undef MoveFileExW
#undef MoveFileW
#undef OemToCharW
#undef OutputDebugStringW
#undef PeekMessageW
#undef PostMessageW
#undef PostThreadMessageW
#undef RegCreateKeyExW
#undef RegCreateKeyW
#undef RegDeleteKeyW
#undef RegDeleteValueW
#undef RegEnumKeyW
#undef RegEnumValueW
#undef RegEnumKeyExW
#undef RegisterClassW
#undef RegisterClassExW
#undef RegisterClipboardFormatW
#undef RegisterWindowMessageW
#undef RegOpenKeyExW
#undef RegOpenKeyW
#undef RegQueryInfoKeyW
#undef RegQueryValueExW
#undef RegQueryValueW
#undef RegSetValueExW
#undef RegSetValueW
#undef RemovePropW
#undef SendDlgItemMessageW
#undef SendMessageW
#undef SendNotifyMessageW
#undef SetDlgItemTextW
#undef SetFileAttributesW
#undef SetLocaleInfoW
#undef SetMenuItemInfoW
#undef SetPropW
#undef SetWindowLongW
#undef SetWindowsHookExW
#undef SetWindowTextW
#undef StartDocW
#undef StgCreateDocfileW
#undef SystemParametersInfoW
#undef TabbedTextOutW
//#undef TranslateAcceleratorW	FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
#undef UnregisterClassW
#undef VkKeyScanW
#undef WinHelpW
#undef WritePrivateProfileStringW
#undef wsprintfW

// Added by VK -- 12/1/98
#undef URLOpenBlockingStreamW
#undef InternetCreateUrlW
#undef InternetCrackUrlW
#undef DeleteUrlCacheEntryW

// Added by VK -- 8/10/99
#undef InternetOpenW
#undef InternetOpenUrlW


// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#undef AbortSystemShutdownW
#undef AccessCheckAndAuditAlarmW
#undef AddFontResourceW
#undef AddFormW
#undef AddJobW
#undef AddMonitorW
#undef AddPortW
#undef AddPrinterConnectionW
#undef AddPrinterDriverW
#undef AddPrinterW
#undef AddPrintProcessorW
#undef AddPrintProvidorW
#undef AdvancedDocumentPropertiesW
#undef auxGetDevCapsW
#undef BackupEventLogW
#undef BeginUpdateResourceW
#undef BuildCommDCBAndTimeoutsW
#undef BuildCommDCBW
#undef CallMsgFilterW
#undef CallNamedPipeW
#undef ChangeDisplaySettingsW
#undef ChangeMenuW
#undef CharToOemBuffW
#undef CharUpperBuffW
#undef ChooseColorW
#undef ChooseFontW
#undef ClearEventLogW
#undef CommConfigDialogW
#undef CompareStringW
#undef ConfigurePortW
#undef CopyAcceleratorTableW
#undef CopyEnhMetaFileW
#undef CopyMetaFileW
#undef CreateAcceleratorTableW
#undef CreateColorSpaceW
#undef CreateDesktopW
#undef CreateDialogIndirectParamW
#undef CreateDialogParamW
#undef CreateICW
#undef CreateMailslotW
#undef CreateMutexW
#undef CreateNamedPipeW
#undef CreateProcessW
#undef CreateProcessAsUserW
#undef CreatePropertySheetPageW
#undef CreateScalableFontResourceW
#undef CreateStatusWindowW
#undef CreateWindowStationW
#undef DceErrorInqTextW
#undef DdeQueryStringW
#undef DefDlgProcW
#undef undefDosDeviceW
#undef DeleteFormW
#undef DeleteMonitorW
#undef DeletePortW
#undef DeletePrinterConnectionW
#undef DeletePrinterDriverW
#undef DeletePrintProcessorW
#undef DeletePrintProvidorW
#undef DeviceCapabilitiesW
#undef DlgDirListComboBoxW
#undef DlgDirListW
#undef DlgDirSelectComboBoxExW
#undef DlgDirSelectExW
#undef DocumentPropertiesW
#undef DoEnvironmentSubstW
#undef DragQueryFileW
#undef DrawStateW
#undef EndUpdateResourceW
#undef EnumCalendarInfoW
#undef EnumDateFormatsW
#undef EnumDesktopsW
#undef EnumDisplaySettingsW
#undef EnumFontFamiliesExW
#undef EnumFontFamiliesW
#undef EnumFontsW
#undef EnumFormsW
#undef EnumICMProfilesW
#undef EnumJobsW
#undef EnumMonitorsW
#undef EnumPortsW
#undef EnumPrinterDriversW
#undef EnumPrintersW
#undef EnumPrintProcessorDatatypesW
#undef EnumPrintProcessorsW
#undef EnumPropsExW
#undef EnumPropsW
#undef EnumProtocolsW
#undef EnumResourceLanguagesW
#undef EnumResourceNamesW
#undef EnumResourceTypesW
#undef EnumSystemCodePagesW
#undef EnumSystemLocalesW
#undef EnumTimeFormatsW
#undef EnumWindowStationsW
#undef ExtractAssociatedIconW
#undef ExtractIconW
#undef ExtractIconExW
#undef FillConsoleOutputCharacterW
#undef FindEnvironmentStringW
#undef FindExecutableW
#undef FindResourceExW
#undef FindTextW
#undef FindWindowExW
#undef FoldStringW
#undef GetBinaryTypeW
#undef GetCharacterPlacementW
#undef GetCharWidth32W
#undef GetCommandLineW
#undef GetClipboardFormatNameW
#undef GetCompressedFileSizeW
#undef GetComputerNameW
#undef GetConsoleTitleW
#undef GetCurrencyFormatW
#undef GetDateFormatW
#undef GetDefaultCommConfigW
#undef GetDiskFreeSpaceW
#undef GetDriveTypeW
#undef GetEnhMetaFileDescriptionW
#undef GetEnhMetaFileW
#undef GetEnvironmentVariableW
#undef GetExpandedNameW
#undef GetFileSecurityW
#undef GetFileTitleW
#undef GetFileVersionInfoW
#undef GetFileVersionInfoSizeW
#undef GetFormW
#undef GetICMProfileW
#undef GetJobW
#undef GetKeyboardLayoutNameW
#undef GetKeyNameTextW
#undef GetLogColorSpaceW
#undef GetLogicalDriveStringsW
#undef GetMenuItemInfoW
#undef GetMenuStringW
#undef GetMetaFileW
#undef GetNameByTypeW
#undef GetNamedPipeHandleStateW
#undef GetNumberFormatW
#undef GetPrinterW
#undef GetPrinterDataW
#undef GetPrinterDriverDirectoryW
#undef GetPrinterDriverW
#undef GetPrintProcessorDirectoryW
#undef GetPrivateProfileSectionNamesW
#undef GetPrivateProfileSectionW
#undef GetPrivateProfileStructW
#undef GetProfileSectionW
#undef GetProfileStringW
#undef GetShortPathNameW
#undef GetStartupInfoW
#undef GetStringTypeExW
#undef GetSystemDirectoryW
#undef GetTextFaceW
#undef GetTimeFormatW
#undef GetTypeByNameW
#undef GetUserObjectInformationW
#undef GetWindowsDirectoryW
#undef GlobalFindAtomW
#undef ImageList_LoadImageW
#undef ImmConfigureIMEW
#undef ImmEnumRegisterWordW
#undef ImmEscapeW
#undef ImmGetCandidateListCountW
#undef ImmGetCandidateListW
#undef ImmGetCompositionFontW
#undef ImmGetCompositionStringW
#undef ImmGetConversionListW
#undef ImmGetDescriptionW
#undef ImmGetGuideLineW
#undef ImmGetIMEFileNameW
#undef ImmGetRegisterWordStyleW
#undef ImmInstallIMEW
#undef ImmIsUIMessageW
#undef ImmRegisterWordW
#undef ImmSetCompositionFontW
#undef ImmSetCompositionStringW
#undef ImmUnregisterWordW
#undef InitiateSystemShutdownW
#undef InsertMenuItemW
#undef IsCharLowerW
#undef IsCharUpperW
#undef I_RpcServerUnregisterEndpointW
#undef joyGetDevCapsW
#undef LoadCursorFromFileW
#undef LoadKeyboardLayoutW
#undef LogonUserW
#undef LZOpenFileW
#undef MapVirtualKeyExW
#undef MIMEAssociationDialogW
#undef MultinetGetConnectionPerformanceW
#undef ObjectCloseAuditAlarmW
#undef ObjectOpenAuditAlarmW
#undef ObjectPrivilegeAuditAlarmW
#undef OemToCharBuffW
#undef OpenBackupEventLogW
#undef OpenDesktopW
#undef OpenEventLogW
#undef OpenEventW
#undef OpenFileMappingW
#undef OpenMutexW
#undef OpenPrinterW
#undef OpenSemaphoreW
#undef OpenWindowStationW
#undef PageSetupDlgW
#undef PeekConsoleInputW
#undef PolyTextOutW
#undef PrintDlgW
#undef PrinterMessageBoxW
#undef PrivilegedServiceAuditAlarmW
#undef PropertySheetW
#undef QueryDosDeviceW
#undef ReadConsoleInputW
#undef ReadConsoleOutputCharacterW
#undef ReadConsoleOutputW
#undef ReadConsoleW
#undef ReadEventLogW
#undef RegConnectRegistryW
#undef RegisterEventSourceW
#undef RegLoadKeyW
#undef RegQueryMultipleValuesW
#undef RegReplaceKeyW
#undef RegRestoreKeyW
#undef RegSaveKeyW
#undef RegUnLoadKeyW
#undef RemoveDirectoryW
#undef RemoveFontResourceW
#undef ReplaceTextW
#undef ReportEventW
#undef ResetDCW
#undef ResetPrinterW
#undef RpcBindingFromStringBindingW
#undef RpcBindingInqAuthClientW
#undef RpcBindingToStringBindingW
#undef RpcEpRegisterNoReplaceW
#undef RpcMgmtEpEltInqNextW
#undef RpcMgmtInqServerPrincNameW
#undef RpcNetworkInqProtseqsW
#undef RpcNetworkIsProtseqValidW
#undef RpcNsBindingInqEntryNameW
#undef RpcProtseqVectorFreeW
#undef RpcServerInqDefaultPrincNameW
#undef RpcServerUseProtseqEpW
#undef RpcServerUseProtseqIfW
#undef RpcServerUseProtseqW
#undef RpcStringBindingComposeW
#undef RpcStringBindingParseW
#undef RpcStringFreeW
#undef ScrollConsoleScreenBufferW
#undef SearchPathW
#undef SendMessageCallbackW
#undef SendMessageTimeoutW
#undef SetClassLongW
#undef SetComputerNameW
#undef SetConsoleTitleW
#undef SetCurrentDirectoryW
#undef SetDefaultCommConfigW
#undef SetEnvironmentVariableW
#undef SetFileSecurityW
#undef SetFormW
#undef SetICMProfileW
#undef SetJobW
#undef SetPrinterDataW
#undef SetPrinterW
#undef SetUserObjectInformationW
#undef SetVolumeLabelW
#undef SetWindowsHookW
#undef SHBrowseForFolderW
#undef Shell_NotifyIconW
#undef ShellAboutW
#undef ShellExecuteW
#undef ShellExecuteExW
#undef SHFileOperationW
#undef SHGetFileInfoW
#undef SHGetNewLinkInfoW
#undef SHGetPathFromIDListW
#undef sndPlaySoundW
#undef StartDocPrinterW
#undef StgCreateDocfileW
#undef TranslateURLW
#undef UpdateICMRegKeyW
#undef URLAssociationDialogW
#undef UuidFromStringW
#undef VerFindFileW
#undef VerInstallFileW
#undef VerLanguageNameW
#undef VerQueryValueW
#undef VkKeyScanExW
#undef WaitNamedPipeW
#undef waveInGetDevCapsW
#undef waveInGetErrorTextW
#undef waveOutGetDevCapsW
#undef waveOutGetErrorTextW
#undef wglUseFontBitmapsW
#undef wglUseFontOutlinesW
#undef WinExecErrorW
#undef WNetAddConnection2W
#undef WNetAddConnection3W
#undef WNetAddConnectionW
#undef WNetCancelConnection2W
#undef WNetCancelConnectionW
#undef WNetConnectionDialog1W
#undef WNetDisconnectDialog1W
#undef WNetEnumResourceW
#undef WNetGetConnectionW
#undef WNetGetLastErrorW
#undef WNetGetNetworkInformationW
#undef WNetGetProviderNameW
#undef WNetGetUniversalNameW
#undef WNetGetUserW
#undef WNetOpenEnumW
#undef WNetSetConnectionW
#undef WNetUseConnectionW
#undef WriteConsoleInputW
#undef WriteConsoleOutputCharacterW
#undef WriteConsoleOutputW
#undef WriteConsoleW
#undef WritePrivateProfileSectionW
#undef WritePrivateProfileStructW
#undef WriteProfileSectionW
#undef WriteProfileStringW
#undef wvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedctl\win95wrp.cpp ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       win95wrp.cpp
//
//  This file was taken from the Davinci sources and adapted for TriEdit
//  on 3/11/98 in order to get rid of the external dependency for the TriEdit SDK
//  The adaptation process included getting rid of several APIs that were not being
//  supported and moving some APIs from the supported to unsupported group
//
//  Contents:   Unicode wrapper API, used only on Win95
//
//  Functions:  About 125 Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//              All memory allocation is done on the stack.
//
//----------------------------------------------------------------------------

// Includes ------------------------------------------------------------------

#include "stdafx.h"

// The following two lines will ensure that no mapping from Foo to OFoo will take place
// and the real windows APIs will get called from this file
#define __WIN95WRP_CPP__
#include "win95wrp.h"

#include <mbstring.h>
#include <commctrl.h>
#include <shlobj.h>

// Function prototypes
inline LONG UnicodeToAnsi(LPSTR szOut, LPCWSTR pwszIn, LONG cbOut, LONG cbIn = -1) throw();
inline LONG AnsiToUnicode(LPWSTR pwszOut, LPCSTR szIn, LONG cbOut, LONG cbIn = -1) throw();
static void CvtDevmode(DEVMODEA *pdma, const DEVMODEW *pdmw) throw();

BOOL g_fWin95;
BOOL g_fOSInit = FALSE;

// Debug ----------------------------------------------------------------------
#ifdef _DEBUG
#define Assert(f)   ((f) ? 0 : AssertFail(#f))
#define Verify(f)   Assert(f)
#define Debug(f)    (f)
#else
#define Assert(f)   (0)
#define Verify(f)   (f)
#define Debug(f)    (0)
#endif

#ifdef DEBUG
int AssertFail(const CHAR *pszMsg) throw()
{
	int wRet = MessageBoxA(NULL, pszMsg, "Assert Failed in Win95 layer",
						   MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 |
						   MB_SYSTEMMODAL | MB_ICONHAND );

	switch (wRet)
		{
		case IDABORT:
			FatalAppExit(0, L"BOO HOO");
			break;

		case IDRETRY:
			DebugBreak();
			// deliberately fall through to IDIGNORE in order to continue

		case IDIGNORE:

			// go aways
			break;
		}
	return 0;
}
#else
#define AssertFail(s) (0)
#endif  // ! DEBUG

// This macro determines whether a LPTSTR is an atom or string pointer
#define FATOM(x)    (!(HIWORD(x)))

// OffsetOf       - Return the byte offset into s of m
#define	OffsetOf(s,m)	(size_t)(((unsigned char*)&(((s*)0)->m))-((unsigned char*)0))

inline LONG UnicodeToAnsi(LPSTR szDestString, LPCWSTR pwszSrcString,
						  LONG  cbDestString, LONG    cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || szDestString));
	return WideCharToMultiByte(CP_ACP, 0, pwszSrcString, cbSrcString,
							   szDestString, cbDestString, NULL, NULL);

}

inline LONG AnsiToUnicode(LPWSTR pwszDestString, LPCSTR szSrcString,
						  LONG   cbDestString,   LONG   cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || pwszDestString));
	return MultiByteToWideChar(CP_ACP, 0, szSrcString, cbSrcString,
							   pwszDestString, cbDestString );
}

static void CvtDevmode(
	DEVMODEA *pdma,
	const DEVMODEW *pdmw
	) throw()
{
	Verify(0 <= UnicodeToAnsi((LPSTR)pdma->dmDeviceName, pdmw->dmDeviceName, CCHDEVICENAME));

	memcpy(&pdma->dmSpecVersion, &pdmw->dmSpecVersion, OffsetOf(DEVMODE,dmFormName) -
		OffsetOf(DEVMODE,dmSpecVersion));

	Verify(0 <= UnicodeToAnsi((LPSTR)pdma->dmFormName, pdmw->dmFormName, CCHFORMNAME));

	memcpy(&pdma->dmLogPixels, &pdmw->dmLogPixels, sizeof(DEVMODE)-OffsetOf(DEVMODE, dmLogPixels));

	// Make sure we copy the extra driver bits.
	if ( pdmw->dmDriverExtra )
		memcpy((char*)pdma + sizeof(DEVMODEA), (char*)pdmw + sizeof(DEVMODEW), pdmw->dmDriverExtra );
}


inline bool FWide() throw()
{
	if (!g_fOSInit)
	{
		OSVERSIONINFOA osvi;
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		GetVersionExA(&osvi);
		g_fWin95 = (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId);
		g_fOSInit = TRUE;
	}

	Assert(g_fOSInit);
	return !g_fWin95;
}

//  The implementation of the Unicode to ANSI (MBCS) convertion macros use the
//  _alloca() function to allocate memory from the stack instead of the heap.
//  Allocating memory from the stack is much faster than allocating memory on
//  the heap, and the memory is automatically freed when the function is exited.
//  In addition, these macros avoid calling WideCharToMultiByte more than one
//  time.  This is done by allocating a little bit more memory than is
//  necessary.  We know that an MBC will convert into at most one WCHAR and
//  that for each WCHAR we will have a maximum of two MBC bytes.  By allocating
//  a little more than necessary, but always enough to handle the conversion
//  the second call to the conversion function is avoided.  The call to the
//  helper function UnicodeToAnsi reduces the number of argument pushes that
//  must be done in order to perform the conversion (this results in smaller
//  code, than if it called WideCharToMultiByte directly).
//
//  In order for the macros to store the temporary length and the pointer to
//  the resultant string, it is necessary to declare some local variables
//  called _len and _sz in each function that uses these conversion macros.
//  This is done by invoking the PreConvert macro in each function before any
//  uses of Convert or ConverWithLen.  (PreConvert just need to be invoked once
//  per function.)

#define PreConvert() \
	LONG   _len;     \
	LPSTR  _sz;      \
	LONG   _lJunk;   \
	_lJunk; // Unused sometimes

// stack-allocates a char buffer of size cch
#define SzAlloc(cch)  ((LPSTR)_alloca(cch))

// stack-allocates a wchar buffer of size cch
#define SzWAlloc(cch) ((LPWSTR)_alloca(cch * sizeof(WCHAR)))

// Returns a properly converted string,
//   or NULL string on failure or szFrom == NULL
// On return the variable passed via pnTo will have the output byte count
//   (including the trailing '\0' iff the nFrom is -1)
#define ConvertWithLen(szFrom, nFrom, pnTo) \
			(!szFrom ? NULL : \
				(_len = (-1 == nFrom ? (wcslen(szFrom) + 1) : nFrom) * \
						sizeof(WCHAR), \
				 _sz = SzAlloc(_len + sizeof(WCHAR)), \
				 Debug(_sz[_len] = '\0'), \
				 ( ((*pnTo) = UnicodeToAnsi(_sz, szFrom, _len, nFrom)) < 0 ? \
				  (AssertFail("Convert failed in Unicode wrapper"), NULL) : \
				  (Assert('\0' == _sz[_len]), _sz) ) ) )
#define Convert(szFrom) ConvertWithLen(szFrom, -1, &_lJunk)

// There are strings which are blocks of strings end to end with a trailing '\0'
// to indicate the true end.  These strings are used with the REG_MULTI_SZ
// option of the Reg... routines and the lpstrFilter field of the OPENFILENAME
// structure used in the GetOpenFileName and GetSaveFileName routines.  To help
// in converting these strings here are two routines which calculate the length
// of the Unicode and ASNI versions (including all '\0's!):

size_t
cUnicodeMultiSzLen
(
LPCWSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = wcslen(lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

size_t
cAnsiMultiSzLen
(
LPCSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = _mbslen((const unsigned char*)lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

extern "C"{

// Added by VanK for DHTMLEdit OCX
HINTERNET
WINAPI
OInternetOpenW(LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags)
{
	if(FWide())
		return InternetOpenW(lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags);

	PreConvert();

	LPSTR szAgent	= NULL;
	LPSTR szProxy	= NULL;
	LPSTR szBypass	= NULL;

	if ( NULL != lpszAgent )
		szAgent = Convert(lpszAgent);
	if ( NULL != lpszProxy )
		szProxy = Convert(lpszProxy);
	if ( NULL != lpszProxyBypass )
		szBypass = Convert(lpszProxyBypass);

	return InternetOpenA(szAgent, dwAccessType, szProxy, szBypass, dwFlags);
}


HINTERNET
WINAPI
OInternetOpenUrlW(HINTERNET hInternet, LPCWSTR lpszUrl, LPCWSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext)
{
	if(FWide())
		return InternetOpenUrlW(hInternet, lpszUrl, lpszHeaders, dwHeadersLength, dwFlags, dwContext);

	PreConvert();

	LPSTR szURL		= NULL;
	LPSTR szHead	= NULL;

	if ( NULL != lpszUrl )
		szURL = Convert(lpszUrl);
	if ( NULL != lpszHeaders )
		szHead = Convert(lpszHeaders);

	return InternetOpenUrlA(hInternet, szURL, szHead, dwHeadersLength, dwFlags, dwContext);
}


HRESULT
__stdcall
OURLOpenBlockingStreamW(
	LPUNKNOWN				pCaller,	// In
	LPCWSTR					wszURL,		// In
	LPSTREAM				*ppStream,	// Out
	DWORD					dwReserved,	// In
	LPBINDSTATUSCALLBACK	lpfnCB		// In
	)
{
	if(FWide())
		return URLOpenBlockingStreamW(pCaller, wszURL, ppStream, dwReserved, lpfnCB);

	PreConvert();
	LPSTR szURL = Convert(wszURL);
	return URLOpenBlockingStreamA(pCaller, szURL, ppStream, dwReserved, lpfnCB);
}

// Added by VanK for DHTMLEdit OCX
// lpdwUrlLength must be set even on failure; callers use a zero length to determine
// how many bytes to actually allocate.
// NOTE that contrary to all expectations, lpdwUrlLength is a byte count, not a character count!
BOOL
WINAPI
OInternetCreateUrlW(
	LPURL_COMPONENTSW	lpUrlComponents,	// In
	DWORD				dwFlags,			// In
	LPWSTR				lpwszUrl,			// Out
	LPDWORD				lpdwUrlLength		// In/Out
	)
{
	Assert ( lpUrlComponents );
	Assert ( lpdwUrlLength );

	if(FWide())
		return InternetCreateUrlW(lpUrlComponents, dwFlags, lpwszUrl, lpdwUrlLength);

	PreConvert();
	DWORD cchLen = (*lpdwUrlLength) / sizeof(WCHAR);	// dwUrlLength is a count of bytes
	LPSTR szUrl = SzAlloc(*lpdwUrlLength);
	URL_COMPONENTSA	urlaComp;
	memset ( &urlaComp, 0, sizeof ( urlaComp ) );	// In case this is ever recompiled with a larger structure

	urlaComp.dwStructSize		= sizeof(URL_COMPONENTSA);
    urlaComp.lpszScheme			= Convert(lpUrlComponents->lpszScheme);
	urlaComp.dwSchemeLength		= lpUrlComponents->dwSchemeLength;
	urlaComp.nScheme			= lpUrlComponents->nScheme;
    urlaComp.lpszHostName		= Convert(lpUrlComponents->lpszHostName);
	urlaComp.dwHostNameLength	= lpUrlComponents->dwHostNameLength;
	urlaComp.nPort				= lpUrlComponents->nPort;
	urlaComp.lpszUserName		= Convert(lpUrlComponents->lpszUserName);
	urlaComp.dwUserNameLength	= lpUrlComponents->dwUserNameLength;
	urlaComp.lpszPassword		= Convert(lpUrlComponents->lpszPassword);
	urlaComp.dwPasswordLength	= lpUrlComponents->dwPasswordLength;
	urlaComp.lpszUrlPath		= Convert(lpUrlComponents->lpszUrlPath);
	urlaComp.dwUrlPathLength	= lpUrlComponents->dwUrlPathLength;
	urlaComp.lpszExtraInfo		= Convert(lpUrlComponents->lpszExtraInfo);
	urlaComp.dwExtraInfoLength	= lpUrlComponents->dwExtraInfoLength;

	BOOL bfResult = InternetCreateUrlA(&urlaComp, dwFlags, szUrl, &cchLen);
	*lpdwUrlLength = cchLen*sizeof(WCHAR);	// Return even on fail; this tells how much to allocate on next call.
	if ( bfResult )
	{
		LONG lRet = AnsiToUnicode(lpwszUrl, szUrl, *lpdwUrlLength, cchLen);
		*lpdwUrlLength = lRet * sizeof(WCHAR);
	}
	return bfResult;
}

// Added by VanK for DHTMLEdit OCX
//	INCOMPLETE IMPLEMENTATION:
//	This implementation is not designed to work in the case where string pointers
//	are specified as NULL and their corresponding lengths non-zero.
//	Normally, this results in a pointer to the first character of the corresponding
//	component to be stored in the pointer.
//
//	IMPLEMENTATION NOTE:
//	Returned strings are terminated.  Although the system implementation seems to assume
//	that the buffers are one character larger than the character count supplied, and
//	thereby equipped to accept an additional terminator, this behavior is never clearly
//	documented.  I feel this behavior is too unsafe, so ONE CHARACTER LESS than the
//	buffer size in characters is the maximum size of the string that can be returned.
BOOL WINAPI OInternetCrackUrlW(
	LPCWSTR				lpwszUrl,		// In
	DWORD				dwUrlLength,	// In
	DWORD				dwFlags,		// In
	LPURL_COMPONENTSW	lpUrlComponents	// Out
	)
{
	if(FWide())
		return InternetCrackUrlW(lpwszUrl, dwUrlLength, dwFlags, lpUrlComponents);

	// Test our limitation restrictions:
	Assert ( ((NULL != lpUrlComponents->lpszScheme) && (0 < lpUrlComponents->dwSchemeLength)) ||
			 ((NULL == lpUrlComponents->lpszScheme) && (0 == lpUrlComponents->dwSchemeLength)));
	Assert ( ((NULL != lpUrlComponents->lpszHostName) && (0 < lpUrlComponents->dwHostNameLength)) ||
			 ((NULL == lpUrlComponents->lpszHostName) && (0 == lpUrlComponents->dwHostNameLength)));
	Assert ( ((NULL != lpUrlComponents->lpszUserName) && (0 < lpUrlComponents->dwUserNameLength)) ||
			 ((NULL == lpUrlComponents->lpszUserName) && (0 == lpUrlComponents->dwUserNameLength)));
	Assert ( ((NULL != lpUrlComponents->lpszPassword) && (0 < lpUrlComponents->dwPasswordLength)) ||
			 ((NULL == lpUrlComponents->lpszPassword) && (0 == lpUrlComponents->dwPasswordLength)));
	Assert ( ((NULL != lpUrlComponents->lpszUrlPath) && (0 < lpUrlComponents->dwUrlPathLength)) ||
			 ((NULL == lpUrlComponents->lpszUrlPath) && (0 == lpUrlComponents->dwUrlPathLength)));
	Assert ( ((NULL != lpUrlComponents->lpszExtraInfo) && (0 < lpUrlComponents->dwExtraInfoLength)) ||
			 ((NULL == lpUrlComponents->lpszExtraInfo) && (0 == lpUrlComponents->dwExtraInfoLength)));

	PreConvert();
	LPCSTR	szURLIn		= Convert(lpwszUrl);
	LPSTR	szScheme	= NULL;
	LPSTR	szHostName	= NULL;
	LPSTR	szUserName	= NULL;
	LPSTR	szPassword	= NULL;
	LPSTR	szUrlPath	= NULL;
	LPSTR	szExtraInfo	= NULL;

	URL_COMPONENTSA	urlaComp;
	memset ( &urlaComp, 0, sizeof ( urlaComp ) );	// In case this is ever recompiled with a larger structure
	
	if ( 0 != lpUrlComponents->dwSchemeLength && NULL != lpUrlComponents->lpszScheme )
	{
		szScheme = SzAlloc((lpUrlComponents->dwSchemeLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwHostNameLength && NULL != lpUrlComponents->lpszHostName )
	{
		szHostName = SzAlloc((lpUrlComponents->dwHostNameLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwUserNameLength && NULL != lpUrlComponents->lpszUserName )
	{
		szUserName = SzAlloc((lpUrlComponents->dwUserNameLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwPasswordLength && NULL != lpUrlComponents->lpszPassword )
	{
		szPassword = SzAlloc((lpUrlComponents->dwPasswordLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwUrlPathLength && NULL != lpUrlComponents->lpszUrlPath )
	{
		szUrlPath = SzAlloc((lpUrlComponents->dwUrlPathLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwExtraInfoLength && NULL != lpUrlComponents->lpszExtraInfo )
	{
		szExtraInfo = SzAlloc((lpUrlComponents->dwExtraInfoLength+1)*sizeof(WCHAR));
	}

	urlaComp.dwStructSize		= sizeof(URL_COMPONENTSA);
    urlaComp.lpszScheme			= szScheme;
	urlaComp.dwSchemeLength		= lpUrlComponents->dwSchemeLength;
	urlaComp.nScheme			= lpUrlComponents->nScheme;
    urlaComp.lpszHostName		= szHostName;
	urlaComp.dwHostNameLength	= lpUrlComponents->dwHostNameLength;
	urlaComp.nPort				= lpUrlComponents->nPort;
	urlaComp.lpszUserName		= szUserName;
	urlaComp.dwUserNameLength	= lpUrlComponents->dwUserNameLength;
	urlaComp.lpszPassword		= szPassword;
	urlaComp.dwPasswordLength	= lpUrlComponents->dwPasswordLength;
	urlaComp.lpszUrlPath		= szUrlPath;
	urlaComp.dwUrlPathLength	= lpUrlComponents->dwUrlPathLength;
	urlaComp.lpszExtraInfo		= szExtraInfo;
	urlaComp.dwExtraInfoLength	= lpUrlComponents->dwExtraInfoLength;

	BOOL bfResult = InternetCrackUrlA ( szURLIn, dwUrlLength, dwFlags, &urlaComp );
	
	if ( bfResult )
	{
		lpUrlComponents->nScheme = urlaComp.nScheme;
		lpUrlComponents->nPort = urlaComp.nPort;

		if ( NULL != szScheme )
		{
			lpUrlComponents->dwSchemeLength = AnsiToUnicode(
				lpUrlComponents->lpszScheme, szScheme,
				lpUrlComponents->dwSchemeLength, urlaComp.dwSchemeLength+1) - 1;
		}
		if ( NULL != szHostName )
		{
			lpUrlComponents->dwHostNameLength = AnsiToUnicode(
				lpUrlComponents->lpszHostName, szHostName,
				lpUrlComponents->dwHostNameLength, urlaComp.dwHostNameLength+1) - 1;
		}
		if ( NULL != szUserName )
		{
			lpUrlComponents->dwUserNameLength = AnsiToUnicode(
				lpUrlComponents->lpszUserName, szUserName,
				lpUrlComponents->dwUserNameLength, urlaComp.dwUserNameLength+1) - 1;
		}
		if ( NULL != szPassword )
		{
			lpUrlComponents->dwPasswordLength = AnsiToUnicode(
				lpUrlComponents->lpszPassword, szPassword,
				lpUrlComponents->dwPasswordLength, urlaComp.dwPasswordLength+1) - 1;
		}
		if ( NULL != szUrlPath )
		{
			lpUrlComponents->dwUrlPathLength = AnsiToUnicode(
				lpUrlComponents->lpszUrlPath, szUrlPath,
				lpUrlComponents->dwUrlPathLength, urlaComp.dwUrlPathLength+1) - 1;
		}
		if ( NULL != szExtraInfo )
		{
			lpUrlComponents->dwExtraInfoLength = AnsiToUnicode(
				lpUrlComponents->lpszExtraInfo, szExtraInfo,
				lpUrlComponents->dwExtraInfoLength, urlaComp.dwExtraInfoLength+1) - 1;
		}
	}
	return bfResult;
}

// Added by VanK for DHTMLEdit OCX
BOOL
WINAPI
ODeleteUrlCacheEntryW(
	LPCWSTR	lpwszUrlName	// In
	)
{
	if(FWide())
		return DeleteUrlCacheEntryW(lpwszUrlName);

	PreConvert();
	LPSTR szUrlName = Convert(lpwszUrlName);
	return DeleteUrlCacheEntryA(szUrlName);
}

BOOL
WINAPI
OAppendMenuW(
	HMENU hMenu,
	UINT uFlags,
	UINT uIDnewItem,
	LPCWSTR lpnewItem
	)
{
	if(FWide())
		return AppendMenuW(hMenu, uFlags, uIDnewItem, lpnewItem);

	if(MF_STRING != uFlags)
		return AppendMenuA(hMenu, uFlags, uIDnewItem, (LPSTR)lpnewItem);

	PreConvert();
	LPSTR sz = Convert(lpnewItem);
	return AppendMenuA(hMenu, uFlags, uIDnewItem, sz);
}

LRESULT
WINAPI
OCallWindowProcW(
	WNDPROC lpPrevWndFunc,
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);

	return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);  //$ CONSIDER - Not really wrapped
}

DWORD
WINAPI
OCharLowerBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	if(!lpsz)
		return 0;

	if(FWide())
		return CharLowerBuffW(lpsz, cchLength);

	DWORD i = 0;
	while(i++ < cchLength)
		{
		*lpsz = towlower(*lpsz);
		lpsz++;
		}
	return i;
}

LPWSTR
WINAPI
OCharLowerW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharLowerW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towlower((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towlower(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/29/97
LPWSTR
WINAPI
OCharPrevW(
	LPCWSTR lpszStart,
	LPCWSTR lpszCurrent)
{
	return (LPWSTR)((lpszStart != lpszCurrent) ? lpszCurrent - 1 : lpszCurrent);
}

BOOL
WINAPI
OCharToOemW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst)
{
	if(FWide())
		{
		Assert((LPSTR) lpszSrc != lpszDst);
		return CharToOemW(lpszSrc, lpszDst);
		}

	PreConvert();
	LPSTR sz = Convert(lpszSrc);

	return CharToOemA(sz, lpszDst);
}

LPWSTR
WINAPI
OCharUpperW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharUpperW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towupper((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towupper(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCopyFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	BOOL bFailIfExists
	)
{
	if (FWide())
		return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

	char szExisting[_MAX_PATH], szNew[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szExisting, lpExistingFileName, _MAX_PATH));
	Verify(0 <= UnicodeToAnsi(szNew, lpNewFileName, _MAX_PATH));
	return CopyFileA(szExisting, szNew, bFailIfExists);
}

HDC
WINAPI
OCreateDCW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpInitData)
{
	Assert(!lpszOutput);
	if(FWide())
		return CreateDCW(lpszDriver, lpszDevice, lpszOutput, lpInitData);

	DEVMODEA *pdma = lpInitData ?
						(DEVMODEA*)SzAlloc(sizeof(DEVMODEA) + lpInitData->dmDriverExtra) :
						NULL;

	PreConvert();
	LPSTR szDriv = Convert(lpszDriver);
	LPSTR szDev = NULL;

	// in Win95, only "display" is allowed as a driver name
	if (szDriv && !lstrcmpiA(szDriv, "display"))
		{
		Assert(!lpszDevice);
		Assert(!lpInitData);
		pdma = NULL;	// Force to NULL.
		}
	else
		{
#ifdef DEBUG
		// For NT we pass this in so only assert if this is
		// not true.
		if (szDriv && lstrcmpiA(szDriv, "winspool"))
			Assert(!lpszDriver);
#endif // DEBUG
		szDriv = NULL;
		Assert(lpszDevice);
		szDev = Convert(lpszDevice);
		if (lpInitData)
			{
			CvtDevmode(pdma, lpInitData);
			}
		}

	return CreateDCA(szDriv, szDev, NULL, pdma);
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCreateDirectoryW(
	LPCWSTR lpPathName,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryW(lpPathName, lpSecurityAttributes);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	return CreateDirectoryA(sz, NULL);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith: simpified on 6/25
// Smoke tested by Mark Ashton on 6/25
BOOL
WINAPI
OCreateDirectoryExW(
	LPCWSTR lpTemplateDirectory,
	LPCWSTR lpNewDirectory,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);

	PreConvert();
	LPSTR szTemplateDirectory = Convert(lpTemplateDirectory);
	LPSTR szNewDirectory      = Convert(lpNewDirectory);
	return CreateDirectoryExA(szTemplateDirectory, szNewDirectory, NULL);
}

HDC
WINAPI
OCreateEnhMetaFileW(
	HDC hdc,
	LPCWSTR lpFileName,
	CONST RECT *lpRect,
	LPCWSTR lpDescription)
{
	if(FWide())
		return CreateEnhMetaFileW(hdc, lpFileName, lpRect, lpDescription);

	PreConvert();
	LPSTR szN = Convert(lpFileName);
	LPSTR szD = ConvertWithLen(lpDescription, cUnicodeMultiSzLen(lpDescription), &_lJunk);
	return  CreateEnhMetaFileA(hdc, szN, lpRect, szD);
}

HANDLE
WINAPI
OCreateEventW(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
}

HANDLE
WINAPI
OCreateFileW(
	LPCWSTR lpFileName,
	DWORD dwDesiredAccess,
	DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes,
	HANDLE hTemplateFile
	)
{
	// Don't even attempt this on Win95!
	Assert(0 != wcsncmp(lpFileName, L"\\\\?\\", 4));

	if(FWide())
		return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
			dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return CreateFileA(sz, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
		dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HFONT
WINAPI
OCreateFontIndirectW(CONST LOGFONTW * plfw)
{
	Assert(plfw);

	if(FWide())
		return CreateFontIndirectW(plfw);

	LOGFONTA  lfa;

	// It's assumed here that sizeof(LOGFONTA) <= sizeof (LOGFONTW);
	memcpy(&lfa, plfw, sizeof(LOGFONTA));

	Verify(0 <= UnicodeToAnsi(lfa.lfFaceName, plfw->lfFaceName, LF_FACESIZE));
	return CreateFontIndirectA(&lfa);
}

// From: Mark Ashton on 5/29/97
HFONT
OCreateFontW(
	int nHeight, // logical height of font
	int nWidth, // logical average character width
	int nEscapement, // angle of escapement
	int nOrientation, // base-line orientation angle
	int fnWeight, // font weight
	DWORD fdwItalic, // italic attribute flag
	DWORD fdwUnderline, // underline attribute flag
	DWORD fdwStrikeOut, // strikeout attribute flag
	DWORD fdwCharSet, // character set identifier
	DWORD fdwOutputPrecision, // output precision
	DWORD fdwClipPrecision, // clipping precision
	DWORD fdwQuality, // output quality
	DWORD fdwPitchAndFamily, // pitch and family
	LPCWSTR lpszFace) // pointer to typeface name string
{
	if (FWide())
		return CreateFontW(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, lpszFace);
	PreConvert();
	LPSTR sz = Convert(lpszFace);
	return CreateFontA(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, sz);
}

HWND
WINAPI
OCreateMDIWindowW(
	LPWSTR lpClassName,
	LPWSTR lpWindowName,
	DWORD dwStyle,
	int X,
	int Y,
	int nWidth,
	int nHeight,
	HWND hWndParent,
	HINSTANCE hInstance,
	LPARAM lParam
	)
{
	if(FWide())
		return CreateMDIWindowW(lpClassName, lpWindowName, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWin   = Convert(lpWindowName);

	return CreateMDIWindowA(szClass, szWin, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
}

HDC
WINAPI
OCreateMetaFileW(LPCWSTR lpstr)
{
	if(FWide())
		return CreateMetaFileW(lpstr);

	PreConvert();
	LPSTR sz = Convert(lpstr);
	return CreateMetaFileA(sz);
}

HANDLE
WINAPI
OCreateSemaphoreW(
	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
	LONG lInitialCount,
	LONG lMaximumCount,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, sz);
}

HWND
WINAPI
OCreateWindowExW( DWORD dwExStyle,
			  LPCWSTR lpClassName,
				LPCWSTR lpWindowName,
				DWORD dwStyle,
				int X,
				int Y,
				int nWidth,
				int nHeight,
				HWND hWndParent ,
				HMENU hMenu,
				HINSTANCE hInstance,
				LPVOID lpParam )
{
	if(FWide())
		return CreateWindowExW(dwExStyle,
				lpClassName,
				lpWindowName,
				dwStyle,
				X,
				Y,
				nWidth,
				nHeight,
				hWndParent ,
				hMenu,
				hInstance,
				lpParam );

	PreConvert();

	LPSTR szClass;
	if (FATOM(lpClassName))
		{
		// is it an atom?
		szClass = (LPSTR) lpClassName;
		}
	else
		{
		// otherwise convert the string
		szClass = Convert(lpClassName);
		}
	LPSTR szWindow = Convert(lpWindowName);

	return CreateWindowExA (dwExStyle, szClass, szWindow, dwStyle, X, Y,
						 nWidth, nHeight, hWndParent, hMenu, hInstance,
						 lpParam);

}

HSZ
WINAPI
ODdeCreateStringHandleW(
	DWORD idInst,
	LPCWSTR psz,
	int iCodePage)
{
	if(FWide())
		{
		Assert(CP_WINUNICODE == iCodePage);
		return DdeCreateStringHandleW(idInst, psz, iCodePage);
		}
	PreConvert();
	LPSTR sz = Convert(psz);
	return DdeCreateStringHandleA(idInst, sz, CP_WINANSI);
}

UINT
WINAPI
ODdeInitializeW(
	LPDWORD pidInst,
	PFNCALLBACK pfnCallback,
	DWORD afCmd,
	DWORD ulRes)
{
	if(FWide())
		return DdeInitializeW(pidInst, pfnCallback, afCmd, ulRes);
	return DdeInitializeA(pidInst, pfnCallback, afCmd, ulRes);
}

LRESULT
WINAPI
ODefFrameProcW(
	HWND hWnd,
	HWND hWndMDIClient ,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefFrameProcW(hWnd, hWndMDIClient , uMsg, wParam, lParam);

	return DefFrameProcA(hWnd, hWndMDIClient , uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefMDIChildProcW(
	HWND hWnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefMDIChildProcW(hWnd, uMsg, wParam, lParam);

	return DefMDIChildProcA(hWnd, uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefWindowProcW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefWindowProcW( hWnd, Msg,wParam, lParam);

	return DefWindowProcA( hWnd, Msg,wParam, lParam);
}

BOOL
WINAPI
ODeleteFileW(
	LPCWSTR pwsz)
{
	if(FWide())
		return DeleteFileW(pwsz);

	PreConvert();
	LPSTR sz = Convert(pwsz);
	return DeleteFileA(sz);
}

LRESULT
WINAPI
ODialogBoxIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW hDialogTemplate,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);

	return DialogBoxIndirectParamA(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODialogBoxParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxParamW(hInstance, lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	if(FATOM(lpTemplateName))
		return DialogBoxParamA(hInstance, (LPSTR)lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	PreConvert();
	LPSTR sz = Convert(lpTemplateName);
	return DialogBoxParamA(hInstance, sz, hWndParent , lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODispatchMessageW(
	CONST MSG *lpMsg)
{
	if(FWide())
		return DispatchMessageW(lpMsg);

	return DispatchMessageA(lpMsg);
}

int
WINAPI
ODrawTextW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	LPRECT lpRect,
	UINT uFormat)
{
	// NOTE OS may write 3 characters beyond end of lpString so make room!


	if(FWide())
		return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);

	bool fModifyString = (uFormat & DT_MODIFYSTRING) &&
						 (uFormat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS));

	const int nBuff = WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										  NULL, 0, NULL, NULL );
	Assert(0 <= nBuff);

	// OS may write beyond end of buffer so make room!
	const LPSTR sz = SzAlloc(nBuff + 4);

	Verify(nBuff == WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										sz, nBuff, NULL, NULL ));

	if (fModifyString)
		{
		// DrawTextA doesn't nessacerily '\0' terminate the output,
		// so have termiators ready
		memcpy(sz + nBuff, "\0\0\0\0", 4);
		}

	const int iDrawTextReturn = DrawTextA(hDC, sz, nBuff - 1, lpRect, uFormat);

	// With certain flags, DrawText modifies the string, truncating it with
	// an ellipsis.  We need to convert back and update the string passed to
	// the wrapper before we return.
	if (fModifyString && 0 <= iDrawTextReturn)
		{
		Assert('\0' == sz[nBuff + 3]); // Verify not too many were overwritten

		// The windows function prototype has lpString as constant even
		//    though the string gets modified!
		const int nStringLen = -1 != nCount ? nCount : wcslen(lpString);
		Verify(0 <= AnsiToUnicode(const_cast<LPWSTR>(lpString), sz,
								 nStringLen + 4 ));
		}
	return iDrawTextReturn;
}

// Written by Bill Hiebert on 9/4/97
// Smoke tested by Bill Hiebert 9/4/97
int
WINAPI
ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
	Assert(-1 != cb);
	Assert(!(DT_MODIFYSTRING & dwDTFormat));

	if(FWide())
		return DrawTextExW(hdc, pwsz, cb, lprect, dwDTFormat, lpDTParams);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);

	return DrawTextExA(hdc, sz, n, lprect, dwDTFormat, lpDTParams);
}


// Written for Carlos Gomes on 6/26/97 by Ted Smith
// Smoke tested by Carlos Gomes on 6/26
DWORD
WINAPI
OExpandEnvironmentStringsW(
	LPCWSTR lpSrc,
	LPWSTR lpDst,
	DWORD nSize
	)
{
	if (FWide())
		return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);

	PreConvert();
	LPSTR szSrc = Convert(lpSrc);
	LPSTR szDst = SzAlloc(sizeof(WCHAR) * nSize);
	DWORD dwRet = ExpandEnvironmentStringsA(szSrc, szDst, sizeof(WCHAR) * nSize);

	if (dwRet)
		{
		LONG lRet = AnsiToUnicode(lpDst, szDst, nSize, min(dwRet, sizeof(WCHAR) * nSize));
		if (dwRet < (DWORD) lRet)
			{
			dwRet = lRet;
			}
		}
	else if (lpDst && 0 < nSize)
		{
		*lpDst = L'\0';
		}

	return dwRet;
}

VOID
WINAPI
OFatalAppExitW(
	UINT uAction,
	LPCWSTR lpMessageText
	)
{
	if(FWide())
		FatalAppExitW(uAction, lpMessageText);

	PreConvert();
	LPSTR sz = Convert(lpMessageText);
	FatalAppExitA(uAction, sz);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstChangeNotificationW(
	LPCWSTR lpPathName,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter
	)
{
	if (FWide())
		return FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	return FindFirstChangeNotificationA(sz, bWatchSubtree, dwNotifyFilter);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstFileW(
	LPCWSTR lpFileName,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindFirstFileW(lpFileName, lpFindFileData);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	WIN32_FIND_DATAA findFileData;
	HANDLE h = FindFirstFileA(sz, &findFileData);
	if (INVALID_HANDLE_VALUE != h)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return h;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OFindNextFileW(
	HANDLE hFindFile,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindNextFileW(hFindFile, lpFindFileData);

	WIN32_FIND_DATAA findFileData;
	BOOL fFlag = FindNextFileA(hFindFile, &findFileData);
	if (fFlag)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return fFlag;
}

HRSRC
WINAPI
OFindResourceW(
	HINSTANCE hModule,
	LPCWSTR lpName,
	LPCWSTR lpType
	)
{
	if(FWide())
		return FindResourceW(hModule, lpName, lpType);

	LPCSTR szName = (LPCSTR)lpName;
	LPCSTR szType = (LPCSTR)lpType;

	PreConvert();
	if(!FATOM(lpName))
		szName = Convert(lpName);
	if(!FATOM(lpType))
		szType = Convert(lpType);

	return FindResourceA(hModule, szName, szType);
}

HWND
WINAPI
OFindWindowW(
	LPCWSTR lpClassName ,
	LPCWSTR lpWindowName)
{
	if(FWide())
		return FindWindowW(lpClassName , lpWindowName);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWnd   = Convert(lpWindowName);

	return FindWindowA(szClass, szWnd);
}

// Bill Hiebert of IStudio on 6/13/97 added support for the
//   FORMAT_MESSAGE_ALLOCATE_BUFFER flag
// Bill donated a bugfix for 1819 on 8/1/97

DWORD
WINAPI
OFormatMessageW(
	DWORD dwFlags,
	LPCVOID lpSource,
	DWORD dwMessageId,
	DWORD dwLanguageId,
	LPWSTR lpBuffer,
	DWORD nSize,
	va_list *Arguments)
{

	if (FWide())
		return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId,
							  lpBuffer, nSize, Arguments );

	DWORD dwRet;

	LPSTR szBuffer = NULL;

	if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
		{
		Assert(!IsBadWritePtr(lpBuffer, nSize * sizeof(WCHAR)));
		szBuffer = SzAlloc(sizeof(WCHAR) * nSize);
		}

	if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
		{
		PreConvert();
		LPSTR szSource = Convert((LPWSTR)lpSource);

		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}
	else
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}

	if (dwRet)
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{ // szBuffer contains LocalAlloc ptr to new string. lpBuffer is a
			  // WCHAR** when FORMAT_MESSAGE_ALLOCATE_BUFFER is defined.
			WCHAR* pTemp = (WCHAR*)LocalAlloc(NONZEROLPTR, (dwRet + 1) * sizeof(WCHAR) );
			dwRet = pTemp == NULL? 0 : AnsiToUnicode(pTemp, szBuffer, dwRet + 1);
			LocalFree(szBuffer);
			if (dwRet)
				{
				*(WCHAR**)lpBuffer = pTemp;
				}
			return dwRet;
			}
		else
			{ // Just convert
			return AnsiToUnicode(lpBuffer, szBuffer, nSize);
			}
		}
	else if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

BOOL
APIENTRY
OGetCharABCWidthsFloatW(
	HDC     hdc,
	UINT    uFirstChar,
	UINT    uLastChar,
	LPABCFLOAT      lpABC)
{
	if(FWide())
		return GetCharABCWidthsFloatW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsFloatA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharABCWidthsW(
	HDC hdc,
	UINT uFirstChar,
	UINT uLastChar,
	LPABC lpABC)
{
	if(FWide())
		return GetCharABCWidthsW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharWidthFloatW(
	HDC     hdc,
	UINT    iFirstChar,
	UINT    iLastChar,
	PFLOAT  pBuffer)
{
	if(FWide())
		return GetCharWidthFloatW(hdc, iFirstChar, iLastChar, pBuffer);

	return GetCharWidthFloatA(hdc, iFirstChar, iLastChar, pBuffer);
}


BOOL
WINAPI
OGetCharWidthW(
	HDC hdc,
	UINT iFirstChar,
	UINT iLastChar,
	LPINT lpBuffer)
{
	if(FWide())
		return GetCharWidth32W(hdc, iFirstChar, iLastChar, lpBuffer);

	return GetCharWidth32A(hdc, iFirstChar, iLastChar, lpBuffer);
}

// Static buffers for GetClassInfo[Ex] to return the classname
// and menuname in Unicode, when running on an Ansi system.
// The contract of GetClassInfo is that it returns const ptrs
// back to the class name and menu name.  Unfortuntely, this
// prevents us from translating these back from Ansi to Unicode,
// without having some static buffers to use.  Since we strongly
// believe that the only people calling this are doing it just to
// see if it succeeds or not, so they know whether the class is
// already registered, we've willing to just have one set of
// static buffers to use.
// CAUTION: this will work as long as two threads don't call
// GetClassInfo[Ex] at the same time!
static WCHAR g_szClassName[256];
static WCHAR g_szMenuName[256];

#ifdef DEBUG
static DWORD g_dwCallingThread = 0;    // debug global for ensuring one thread.
#endif // DEBUG

BOOL
WINAPI
OGetClassInfoW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSW lpWndClass
)
{
	if (FWide())
		return GetClassInfoW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoA(hInstance, szClassName, (LPWNDCLASSA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

BOOL
WINAPI
OGetClassInfoExW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSEXW lpWndClass
)
{
	if (FWide())
		return GetClassInfoExW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoExA(hInstance, szClassName, (LPWNDCLASSEXA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

DWORD
WINAPI
OGetClassLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetClassLongW(hWnd, nIndex);
	return GetClassLongA(hWnd, nIndex);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!
}

DWORD
WINAPI
OSetClassLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if (FWide())
		return SetClassLongW(hWnd, nIndex, dwNewLong);

	return SetClassLongA(hWnd, nIndex, dwNewLong);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!

}

int
WINAPI
OGetClassNameW(
	HWND hWnd,
	LPWSTR lpClassName,
	int nMaxCount)
{
	if(FWide())
		return GetClassNameW(hWnd, lpClassName, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount + 2);
	int nRet = GetClassNameA(hWnd, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (nRet)
		{
		// force null-termination
		sz[sizeof(WCHAR) * nMaxCount] = '\0';
		sz[sizeof(WCHAR) * nMaxCount + 1] = '\0';

		// need a temporary wide string
		LPWSTR wsz = SzWAlloc(2 * nMaxCount + 1);

		nRet = min(AnsiToUnicode(wsz, sz, 2 * nMaxCount + 1), nMaxCount);

		// copy the requested number of characters
		if (lpClassName)
			{
			memcpy(lpClassName, wsz, nRet * sizeof(WCHAR));
			}

		return nRet;
		}

	else if (lpClassName && 0 < nMaxCount)
		{
		*lpClassName = L'\0';
		}

	return nRet;
}

DWORD
WINAPI
OGetCurrentDirectoryW(
	DWORD nBufferLength,
	LPWSTR lpBuffer)
{
	if (FWide())
		return GetCurrentDirectoryW(nBufferLength, lpBuffer);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferLength);
	DWORD dwRet = GetCurrentDirectoryA(sizeof(WCHAR) * nBufferLength, sz);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(lpBuffer, sz, nBufferLength);
		}
	else if (lpBuffer && 0 < nBufferLength)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

UINT
WINAPI
OGetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPWSTR lpString,
	int nMaxCount)
{
	if(FWide())
		return GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	UINT uRet = GetDlgItemTextA(hDlg, nIDDlgItem, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(uRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else if (lpString && 0 < nMaxCount)
		{
		*lpString = L'\0';
		}

	return uRet;
}

DWORD
WINAPI
OGetFileAttributesW(
	LPCWSTR lpFileName
	)
{
	if(FWide())
		return GetFileAttributesW(lpFileName);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return GetFileAttributesA(sz);
}

DWORD
WINAPI
OGetFullPathNameW(
	LPCWSTR lpFileName,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	if(FWide())
		return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);

	PreConvert();
	LPSTR szFile = Convert(lpFileName);
	LPSTR szBuffer = SzAlloc(sizeof(WCHAR) * nBufferLength);
	LPSTR pszFile;

	DWORD dwRet = GetFullPathNameA(szFile ,sizeof(WCHAR) * nBufferLength, szBuffer , &pszFile);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		DWORD dwNoOfChar = AnsiToUnicode(lpBuffer, szBuffer , nBufferLength);
		*pszFile = '\0';
		*lpFilePart = lpBuffer + AnsiToUnicode(NULL, szBuffer, 0);
		return dwNoOfChar;
		}

	return dwRet;
}

DWORD
WINAPI
OGetGlyphOutlineW(
	HDC     hdc,
	UINT    uChar,
	UINT    uFormat,
	LPGLYPHMETRICS      lpgm,
	DWORD       cbBuffer,
	LPVOID      lpvBuffer,
	CONST MAT2 *    lpmat2)
{
	if (FWide())
		return GetGlyphOutlineW(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);

	return GetGlyphOutlineA(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);
}

DWORD
WINAPI
OGetKerningPairsW(
	HDC         hdc,
	DWORD       nNumPairs,
	LPKERNINGPAIR       lpkrnpair)
{
	if(FWide())
		return GetKerningPairsW(hdc, nNumPairs, lpkrnpair);

	return GetKerningPairsA(hdc, nNumPairs, lpkrnpair);
}

BOOL
WINAPI
OGetMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax)
{
	if(FWide())
		return GetMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);

	return GetMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);
}

DWORD
WINAPI
OGetModuleFileNameW(
	HINSTANCE hModule,
	LPWSTR pwszFilename,
	DWORD nSize
	)
{
	if(FWide())
		return GetModuleFileNameW(
			hModule,
			pwszFilename,
			nSize
			);

	LPSTR sz    = SzAlloc(sizeof(WCHAR) * nSize);
	DWORD dwRet = GetModuleFileNameA(hModule, sz, sizeof(WCHAR) * nSize);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(pwszFilename, sz, nSize, dwRet + 1);
		}
	else if (pwszFilename && 0 < nSize)
		{
		*pwszFilename = L'\0';
		}

	return dwRet;
}

HMODULE
WINAPI
OGetModuleHandleW(
	LPCWSTR lpModuleName
	)
{
	if(FWide())
		return GetModuleHandleW(lpModuleName);

	PreConvert();
	LPSTR sz = Convert(lpModuleName);

	return GetModuleHandleA(sz);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith: Re-wrote fixing handling of non-trivial parameters on 6/25
// Smoke tested by Mark Ashton on 6/25

APIENTRY
OGetOpenFileNameW
(
LPOPENFILENAMEW lpofn
)
{
	if (FWide())
		return GetOpenFileNameW(lpofn);

	Assert(!(lpofn->Flags & OFN_ENABLEHOOK));

	PreConvert();
	OPENFILENAMEA ofn;
	ofn.lStructSize       = sizeof(OPENFILENAMEA);
	ofn.hwndOwner         = lpofn->hwndOwner;
	ofn.hInstance         = lpofn->hInstance;
	ofn.lpstrFilter       = ConvertWithLen(lpofn->lpstrFilter, cUnicodeMultiSzLen(lpofn->lpstrFilter), &_lJunk);
	ofn.lpstrCustomFilter = ConvertWithLen(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter, (LONG *)&ofn.nMaxCustFilter);
	ofn.nFilterIndex      = lpofn->nFilterIndex;
	ofn.lpstrFile         = ConvertWithLen(lpofn->lpstrFile, lpofn->nMaxFile, (LONG *)&ofn.nMaxFile);
	ofn.lpstrFileTitle    = ConvertWithLen(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle, (LONG *)&ofn.nMaxFileTitle);
	ofn.lpstrInitialDir   = Convert(lpofn->lpstrInitialDir);
	ofn.lpstrTitle        = Convert(lpofn->lpstrTitle);
	ofn.Flags             = lpofn->Flags;
	ofn.nFileOffset       = lpofn->nFileOffset;
	ofn.nFileExtension    = lpofn->nFileExtension;
	ofn.lpstrDefExt       = Convert(lpofn->lpstrDefExt);
	ofn.lCustData         = lpofn->lCustData;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = ((lpofn->Flags & OFN_ENABLETEMPLATE) &&
							 !FATOM(lpofn->lpTemplateName) ) ?
							Convert(lpofn->lpTemplateName) :
							(LPSTR)lpofn->lpTemplateName;
	BOOL fFlag = GetOpenFileNameA(&ofn);
	if (fFlag)
		{
		Assert(lpofn->hwndOwner == ofn.hwndOwner);
		Assert(lpofn->hInstance == ofn.hInstance);
		if (ofn.lpstrCustomFilter)
			{
			lpofn->nMaxCustFilter = AnsiToUnicode(lpofn->lpstrCustomFilter, ofn.lpstrCustomFilter, lpofn->nMaxCustFilter, strlen(ofn.lpstrCustomFilter) + 1);
			}
		lpofn->nFilterIndex   = ofn.nFilterIndex;
		Assert(lpofn->nMaxFile == ofn.nMaxFile);
		Verify(0 <= AnsiToUnicode(lpofn->lpstrFile, ofn.lpstrFile, lpofn->nMaxFile, strlen(ofn.lpstrFile) + 1));
		if (ofn.lpstrFileTitle)
			{
			lpofn->nMaxFileTitle = AnsiToUnicode(lpofn->lpstrFileTitle, ofn.lpstrFileTitle, strlen(ofn.lpstrFileTitle) + 1);
			}
		lpofn->Flags          = ofn.Flags;
		lpofn->nFileOffset    = ofn.nFileOffset;
		lpofn->nFileExtension = ofn.nFileExtension;
		Assert(lpofn->lCustData == ofn.lCustData);
		Assert(lpofn->lpfnHook == ofn.lpfnHook);
		}
	else if (lpofn->lpstrFile)
		{   // if buffer too small first 2 bytes are the required size
		memcpy(lpofn->lpstrFile, ofn.lpstrFile, sizeof(short));
		}
	return fFlag;
}

UINT
APIENTRY
OGetOutlineTextMetricsW(
	HDC hdc,
	UINT cbData,
	LPOUTLINETEXTMETRICW lpOTM)
{
	// *** TextMetrics defines BYTE elements in the structure for the
	// value of first first/last character defined in the font.
	// Problem for DBCS.

	if(FWide())
		return GetOutlineTextMetricsW(hdc, cbData, lpOTM);

	return GetOutlineTextMetricsA(hdc, cbData, (LPOUTLINETEXTMETRICA)lpOTM); //$ UNDONE_POST_98 - This doesn't convert the embedded Names...
}

UINT
WINAPI
OGetPrivateProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szFileName = Convert(lpFileName);

	return GetPrivateProfileIntA(szAppName, szKeyName, nDefault, szFileName);
}

DWORD
WINAPI
OGetPrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString,
		  nSize, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szDefault  = Convert(lpDefault);
	LPSTR szFileName = Convert(lpFileName);

	LPSTR szReturnedString = SzAlloc(sizeof(WCHAR) * nSize);

	DWORD dwRet = GetPrivateProfileStringA(szAppName, szKeyName, szDefault, szReturnedString,
	  sizeof(WCHAR) * nSize, szFileName);

	// I hope this doesn't fail because there's no clear failure value in the docs

	DWORD dwNoOfChar = AnsiToUnicode(lpReturnedString, szReturnedString, nSize);

	if (dwNoOfChar)
		return dwRet;
	else
		{
		LPWSTR lpTempString = SzWAlloc(sizeof(WCHAR) * nSize);
		if (AnsiToUnicode(lpTempString, szReturnedString, sizeof(WCHAR) * nSize))
			{
			if (lpAppName && lpKeyName)
				{
				lpTempString[nSize - 1] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 1;
				}
			else
				{
				lpTempString[nSize - 1] = L'\0';
				lpTempString[nSize - 2] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 2;
				}
			}
		}

	return dwRet;
}


int
WINAPI
OGetObjectW(
	HGDIOBJ hgdiobj,
	int cbBuffer,
	LPVOID lpvObject)
{
	if(FWide())
		return GetObjectW(hgdiobj, cbBuffer, lpvObject);

	DWORD dwObj = GetObjectType(hgdiobj);
	if (OBJ_FONT == dwObj)
		{
		//$CONSIDER: This effects all getobject call, performance?
		Assert(cbBuffer == sizeof(LOGFONTW));
		LOGFONTA  lfa;
		LOGFONTW *plfw = (LOGFONTW *)lpvObject;

		int nRet = GetObjectA(hgdiobj, sizeof(lfa), &lfa);

		if(nRet)
			{
			memcpy(plfw, &lfa, sizeof(LOGFONTA));
			Verify(0 <= AnsiToUnicode(plfw->lfFaceName, lfa.lfFaceName, LF_FACESIZE));
			}

		return nRet;
		}
	else
		{
		return GetObjectA(hgdiobj, cbBuffer, lpvObject);
		}
}

UINT
WINAPI
OGetProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault
	)
{
	if(FWide())
		return GetProfileIntW(lpAppName, lpKeyName, nDefault);

	PreConvert();
	LPSTR szApp = Convert(lpAppName);
	LPSTR szKey = Convert(lpKeyName);

	return GetProfileIntA(szApp, szKey, nDefault);
}

HANDLE
WINAPI
OGetPropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return GetPropW(hWnd, lpString);

	if(FATOM(lpString))
		return GetPropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return GetPropA(hWnd, sz);
}

// From: Mark Ashton on 5/29/97
//       Ted Smith: Re-wrote fixing handling of non-trivial parameters on 6/25
// Smoke tested by Mark Ashton on 6/25

APIENTRY
OGetSaveFileNameW(LPOPENFILENAMEW lpofn)
{
	if (FWide())
		return GetSaveFileNameW(lpofn);

	PreConvert();
	Assert(!(lpofn->Flags & OFN_ENABLEHOOK));

	OPENFILENAMEA ofn;
	ofn.lStructSize       = sizeof(OPENFILENAMEA);
	ofn.hwndOwner         = lpofn->hwndOwner;
	ofn.hInstance         = lpofn->hInstance;
	ofn.lpstrFilter       = ConvertWithLen(lpofn->lpstrFilter, cUnicodeMultiSzLen(lpofn->lpstrFilter), &_lJunk);
	ofn.lpstrCustomFilter = ConvertWithLen(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter, (LONG *)&ofn.nMaxCustFilter);
	ofn.nFilterIndex      = lpofn->nFilterIndex;
	ofn.lpstrFile         = ConvertWithLen(lpofn->lpstrFile, lpofn->nMaxFile, (LONG *)&ofn.nMaxFile);
	ofn.lpstrFileTitle    = ConvertWithLen(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle, (LONG *)&ofn.nMaxFileTitle);
	ofn.lpstrInitialDir   = Convert(lpofn->lpstrInitialDir);
	ofn.lpstrTitle        = Convert(lpofn->lpstrTitle);
	ofn.Flags             = lpofn->Flags;
	ofn.nFileOffset       = lpofn->nFileOffset;
	ofn.nFileExtension    = lpofn->nFileExtension;
	ofn.lpstrDefExt       = Convert(lpofn->lpstrDefExt);
	ofn.lCustData         = lpofn->lCustData;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = ((lpofn->Flags & OFN_ENABLETEMPLATE) &&
							 !FATOM(lpofn->lpTemplateName) ) ?
							Convert(lpofn->lpTemplateName) :
							(LPSTR)lpofn->lpTemplateName;
	BOOL fFlag = GetSaveFileNameA(&ofn);
	if (fFlag)
		{
		Assert(lpofn->hwndOwner == ofn.hwndOwner);
		Assert(lpofn->hInstance == ofn.hInstance);
		if (ofn.lpstrCustomFilter)
			{
			lpofn->nMaxCustFilter = AnsiToUnicode(lpofn->lpstrCustomFilter, ofn.lpstrCustomFilter, lpofn->nMaxCustFilter, ofn.nMaxCustFilter);
			}
		lpofn->nFilterIndex   = ofn.nFilterIndex;
		Assert(lpofn->nMaxFile == ofn.nMaxFile);
		Verify(0 <= AnsiToUnicode(lpofn->lpstrFile, ofn.lpstrFile, lpofn->nMaxFile, ofn.nMaxFile));
		if (ofn.lpstrFileTitle)
			{
			lpofn->nMaxFileTitle = AnsiToUnicode(lpofn->lpstrFileTitle, ofn.lpstrFileTitle, lpofn->nMaxFileTitle);
			}
		lpofn->Flags          = ofn.Flags;
		lpofn->nFileOffset    = ofn.nFileOffset;
		lpofn->nFileExtension = ofn.nFileExtension;
		Assert(lpofn->lCustData == ofn.lCustData);
		Assert(lpofn->lpfnHook == ofn.lpfnHook);
		}
	else if (lpofn->lpstrFile)
		{   // if buffer too small first 2 bytes are the required size
		memcpy(lpofn->lpstrFile, ofn.lpstrFile, sizeof(short));
		}
	return fFlag;
}

DWORD
WINAPI
OGetTabbedTextExtentW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions)
{
	Assert(-1 != nCount);

	if(FWide())
		return GetTabbedTextExtentW(hDC, lpString, nCount, nTabPositions, lpnTabStopPositions);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);

	return GetTabbedTextExtentA(hDC, sz, n, nTabPositions, lpnTabStopPositions);
}

// From: Mark Ashton on 5/8/97
UINT
WINAPI
OGetTempFileNameW(
	LPCWSTR lpPathName,
	LPCWSTR lpPrefixString,
	UINT uUnique,
	LPWSTR lpTempFileName
	)
{
	if (FWide())
		return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

	char szPathName[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPathName, lpPathName, _MAX_PATH));

	char szPrefixString[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPrefixString, lpPrefixString, _MAX_PATH));

	char szTempFilename[_MAX_PATH];
	UINT dwRet = GetTempFileNameA(szPathName, szPrefixString, uUnique, szTempFilename);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpTempFileName, szTempFilename, _MAX_PATH));
		}
	return dwRet;
}

// From: Mark Ashton on 5/8/97
DWORD
WINAPI
OGetTempPathW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	if (FWide())
		return GetTempPathW(nBufferLength, lpBuffer);

	char szPath[_MAX_PATH];
	DWORD dwRet = GetTempPathA(_MAX_PATH, szPath);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpBuffer, szPath, nBufferLength));
		}
	return dwRet;
}

BOOL
APIENTRY
OGetTextExtentPoint32W(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPoint32W(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);

	return GetTextExtentPoint32A(hdc, sz, n, pSize);
}

BOOL
APIENTRY
OGetTextExtentPointW(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPointW(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);
	return GetTextExtentPointA(hdc, sz, n, pSize);
}

BOOL
APIENTRY OGetTextExtentExPointW(
					HDC hdc,
					LPCWSTR lpszStr,
					int cchString,
					int nMaxExtent,
					LPINT lpnFit,
					LPINT alpDx,
					LPSIZE pSize
					)
{
	Assert(-1 != cchString);

	if(FWide())
		return GetTextExtentExPointW(hdc, lpszStr, cchString,
									 nMaxExtent, lpnFit, alpDx, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpszStr, cchString, &n);
	return GetTextExtentExPointA(hdc, sz, n, nMaxExtent, lpnFit, alpDx, pSize);

}

LONG
WINAPI
OGetWindowLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetWindowLongW(hWnd, nIndex);

	return GetWindowLongA(hWnd, nIndex);
}

BOOL
WINAPI
OGetTextMetricsW(
	HDC hdc,
	LPTEXTMETRICW lptm)
{
	if(FWide())
		return GetTextMetricsW(hdc, lptm);

	TEXTMETRICA tma;

	memcpy(&tma, lptm, OffsetOf(TEXTMETRIC, tmFirstChar));

	// tmFirstChar is defined as BYTE.
	// $CONSIDER : will fail for DBCS !!

	wctomb((LPSTR)&tma.tmFirstChar, lptm->tmFirstChar);
	wctomb((LPSTR)&tma.tmLastChar, lptm->tmLastChar);
	wctomb((LPSTR)&tma.tmDefaultChar, lptm->tmDefaultChar);
	wctomb((LPSTR)&tma.tmBreakChar, lptm->tmBreakChar);

	memcpy(&tma.tmItalic, &lptm->tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

	BOOL fRet = GetTextMetricsA(hdc, &tma);

	if(fRet)
		{
		memcpy(&lptm->tmItalic, &tma.tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

		// Convert tma.tmFirstChar (1 byte char) to lptm->tmFirstChar
		mbtowc(&lptm->tmFirstChar, (LPSTR)&tma.tmFirstChar, 1);
		mbtowc(&lptm->tmLastChar, (LPSTR)&tma.tmLastChar, 1);
		mbtowc(&lptm->tmDefaultChar, (LPSTR)&tma.tmDefaultChar, 1);
		mbtowc(&lptm->tmBreakChar, (LPSTR)&tma.tmBreakChar, 1);

		memcpy(lptm, &tma, OffsetOf(TEXTMETRIC, tmFirstChar));
		}

	return fRet;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OGetUserNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	if (FWide())
		return GetUserNameW(lpBuffer, nSize);

	DWORD dwLen = *nSize;
	LPSTR sz = SzAlloc(dwLen);

	BOOL fFlag = GetUserNameA(sz, nSize);
	if (fFlag)
		{
		*nSize = AnsiToUnicode(lpBuffer, sz, dwLen);
		}
	return fFlag;
}

BOOL
WINAPI
OGetVolumeInformationW(
	LPCWSTR lpRootPathName,
	LPWSTR lpVolumeNameBuffer,
	DWORD nVolumeNameSize,
	LPDWORD lpVolumeSerialNumber,
	LPDWORD lpMaximumComponentLength,
	LPDWORD lpFileSystemFlags,
	LPWSTR lpFileSystemNameBuffer,
	DWORD nFileSystemNameSize
	)
{
	if(FWide())
		return GetVolumeInformationW(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);

	PreConvert();
	LPSTR szRoot = Convert(lpRootPathName);
	LPSTR szName = SzAlloc(sizeof(WCHAR) * nVolumeNameSize);
	LPSTR szSysName = SzAlloc(sizeof(WCHAR) * nFileSystemNameSize);

	BOOL fRet = GetVolumeInformationA(szRoot, szName, sizeof(WCHAR) * nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, szSysName, sizeof(WCHAR) * nFileSystemNameSize);

	if(fRet)
		{
		if (!AnsiToUnicode(lpVolumeNameBuffer, szName, nVolumeNameSize) ||
			!AnsiToUnicode(lpFileSystemNameBuffer, szSysName, nFileSystemNameSize))
			{
			fRet = false;
			}
		}
	if (!fRet)
		{
		if (lpVolumeNameBuffer && 0 < nVolumeNameSize)
			{
			*lpVolumeNameBuffer = L'\0';
			}

		if (lpFileSystemNameBuffer && 0 < nFileSystemNameSize)
			{
			*lpFileSystemNameBuffer = L'\0';
			}
		}

	return fRet;
}

int
WINAPI
OGetWindowTextLengthW(
	HWND hWnd)
{
	if(FWide())
		return GetWindowTextLengthW(hWnd);

	return GetWindowTextLengthA(hWnd);
}

int
WINAPI
OGetWindowTextW(
	HWND hWnd,
	LPWSTR lpString,
	int nMaxCount)
{

	/*******  Blackbox Testing results for GetWindowText Win32 API ******

	TestCase    lpString    nMaxCount   Return Value    *lpString modified
	======================================================================
	Testing GetWindowTextW on WinNT :-
		A       not NULL        0           0               No
		B           NULL        0           0               No
		C           NULL    not 0           0               No
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator

	Testing GetWindowTextA on Win95 :-
		A       not NULL        0           0               Yes
		B           NULL        0               GPF!!
		C           NULL    not 0               GPF!!
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator
	*********************************************************************/

	if(FWide())
		return GetWindowTextW(hWnd, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	int nRet = GetWindowTextA(hWnd, sz, sizeof(WCHAR) * nMaxCount);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(nRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else
		{
		// GetWindowText() returns 0 when you call it on a window which
		// has no text (e.g. edit control without any text). It also initializes
		// the buffer passed in to receive the text to "\0". So we should initialize
		// the buffer passed in before returning.
		if (lpString && 0 < nMaxCount)
			{
			*lpString = L'\0';
			}
		}

	return nRet;
}

ATOM
WINAPI
OGlobalAddAtomW(
	LPCWSTR lpString
	)
{
	if(FWide())
		return GlobalAddAtomW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return GlobalAddAtomA(sz);
}

// From: Josh Kaplan on 8/12/97
UINT
WINAPI
OGlobalGetAtomNameW(
	ATOM nAtom,
	LPWSTR lpBuffer,
	int nSize
	)
{
	if(FWide())
		return GlobalGetAtomNameW(nAtom, lpBuffer, nSize);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nSize);
	if (GlobalGetAtomNameA(nAtom, sz, sizeof(WCHAR) * nSize))
		{
		// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
		return AnsiToUnicode(lpBuffer, sz, nSize) - 1;
		}

	if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}
	return 0;
}

BOOL
WINAPI
OGrayStringW(
	HDC hDC,
	HBRUSH hBrush,
	GRAYSTRINGPROC lpOutputFunc,
	LPARAM lpData,
	int nCount,
	int X,
	int Y,
	int nWidth,
	int nHeight)
{
	if(FWide())
		return GrayStringW(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);

	if (!lpOutputFunc)
		{
		PreConvert();
		LPSTR szData = Convert((LPCWSTR) lpData);
		return GrayStringA(hDC, hBrush, lpOutputFunc, (LPARAM) szData, nCount, X, Y, nWidth, nHeight);
		}

	return GrayStringA(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
}

BOOL
WINAPI
OInsertMenuW(
	HMENU hMenu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if(uFlags & (MF_BITMAP | MF_OWNERDRAW))
		return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPSTR)lpNewItem);

	PreConvert();
	LPSTR sz = Convert(lpNewItem);
	return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, sz);
}

BOOL
WINAPI
OIsBadStringPtrW(
	LPCWSTR lpsz,
	UINT ucchMax
	)
{
	if(FWide())
		return IsBadStringPtrW(lpsz, ucchMax);

	return IsBadStringPtrA((LPSTR) lpsz, ucchMax * sizeof(WCHAR));  //$UNDONE_POST_98 - We should use IsBadReadPtr(strlen)!
}


BOOL
WINAPI
OIsCharAlphaNumericW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaNumericW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if (1 == cch)
		{
		return IsCharAlphaNumericA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsCharAlphaW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if(1 == cch)
		{
		return IsCharAlphaA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsDialogMessageW(
	HWND hDlg,
	LPMSG lpMsg)
{
	// WARNING!!!
	// Bug #6488. We have run into problems due to using IsDialogMessageW on
	// WinNT Japanese. The fix for the bug was calling ANSI version of
	// IsDialogMessage irrespective of whether we are running on NT or Win95.
	// The shell is compiled MBCS (not UNICODE) and they are always using the
	// ANSI versions of the routines. lpMsg passed by shell contains MBCS
	// characters & not UNICODE. So in cases where you get the message
	// structure from the Shell, you will have to call the IsDialogMessageA
	// directly and not use this wrapper.

	if(FWide())
		return IsDialogMessageW(hDlg, lpMsg);

	return IsDialogMessageA(hDlg, lpMsg);
}

// From: Mark Ashton on 5/8/97
//		 Bill Hieber - 2/5/98 fixed buffer size problem.
int
WINAPI
OLCMapStringW(
	LCID     Locale,
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	if (FWide())
		return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);

	// lpSrcStr is not required to be '\0' terminated. Note that we don't support -1!
	Assert(cchSrc != -1);
	LPSTR sz = SzAlloc(cchSrc * 2);
	int dw = WideCharToMultiByte(CP_ACP, 0, lpSrcStr, cchSrc, sz, cchSrc * 2, NULL, NULL);

	LPSTR dst = cchDest ? SzAlloc(cchDest*2) : NULL;
	int dwRet = LCMapStringA(Locale, dwMapFlags, sz, dw, dst, cchDest*2);
	if (dwRet && cchDest)
		{
		dwRet = MultiByteToWideChar(CP_ACP, 0, dst, dwRet, lpDestStr, cchDest);
		}
	return dwRet;
}

HACCEL
WINAPI
OLoadAcceleratorsW(
	HINSTANCE hInst,
	LPCWSTR   lpTableName)
{
	if(FWide())
		return LoadAcceleratorsW(hInst, lpTableName);

	if(FATOM(lpTableName))
		return LoadAcceleratorsA(hInst, (LPSTR)lpTableName);

	PreConvert();
	LPSTR sz = Convert(lpTableName);
	return LoadAcceleratorsA(hInst, sz);
}

HBITMAP
WINAPI
OLoadBitmapW(
	HINSTANCE hInstance,
	LPCWSTR lpBitmapName)
{
	if(FWide())
		return LoadBitmapW(hInstance, lpBitmapName);

	if(FATOM(lpBitmapName))
		return LoadBitmapA(hInstance, (LPSTR)lpBitmapName);

	PreConvert();
	LPSTR sz = Convert(lpBitmapName);
	return LoadBitmapA(hInstance, sz);
}

HCURSOR
WINAPI
OLoadCursorW(
	HINSTANCE hInstance,
	LPCWSTR lpCursorName)
{
	if(FWide())
		return LoadCursorW(
			hInstance,
			lpCursorName);

	if (FATOM(lpCursorName))
		return LoadCursorA(hInstance, (LPSTR) lpCursorName);

	PreConvert();
	LPSTR sz = Convert(lpCursorName);
	return LoadCursorA(hInstance, sz);
}

HICON
WINAPI
OLoadIconW(
	HINSTANCE hInstance,
	LPCWSTR lpIconName)
{
	if(FWide())
		return LoadIconW(hInstance, lpIconName);

	if(FATOM(lpIconName))
		return LoadIconA(hInstance, (LPSTR)lpIconName);

	PreConvert();
	LPSTR sz = Convert(lpIconName);
	return LoadIconA(hInstance, sz);
}

HINSTANCE
WINAPI
OLoadLibraryW(
	LPCWSTR pwszFileName
	)
{
	if(FWide())
		return LoadLibraryW(pwszFileName);

	PreConvert();
	LPSTR sz = Convert(pwszFileName);
	return LoadLibraryA(sz);
}

HMODULE
WINAPI
OLoadLibraryExW(
	LPCWSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
	)
{
	if(FWide())
		return LoadLibraryExW(lpLibFileName, hFile, dwFlags);

	PreConvert();
	LPSTR sz = Convert(lpLibFileName);
	return LoadLibraryExA(sz, hFile, dwFlags);
}

HMENU
WINAPI
OLoadMenuIndirectW(
	CONST MENUTEMPLATEW *lpMenuTemplate)
{
	if(FWide())
		return LoadMenuIndirectW(lpMenuTemplate);

	//$NOTE: For both the ANSI and the Unicode version of this function,
	//the strings in the MENUITEMTEMPLATE structure must be Unicode strings

	return LoadMenuIndirectA(lpMenuTemplate);
}

HMENU
WINAPI
OLoadMenuW(
	HINSTANCE hInstance,
	LPCWSTR lpMenuName)
{
	if(FWide())
		return LoadMenuW(hInstance, lpMenuName);

	if(FATOM(lpMenuName))
		return LoadMenuA(hInstance, (LPCSTR)lpMenuName);

	PreConvert();
	LPSTR sz = Convert(lpMenuName);
	return LoadMenuA(hInstance, sz);
}

int
WINAPI
OLoadStringW(
	HINSTANCE hInstance,
	UINT uID,
	LPWSTR lpBuffer,
	int nBufferMax)
{
	if(FWide())
		return LoadStringW(hInstance, uID,  lpBuffer, nBufferMax);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferMax);
	int nRet = LoadStringA(hInstance, uID, sz, sizeof(WCHAR) * nBufferMax);

	if (!nRet)
		{
		if (lpBuffer && 0 < nBufferMax)
			{
			*lpBuffer = L'\0';
			}
		return 0;
		}

	LONG lRet = AnsiToUnicode(lpBuffer, sz, nBufferMax, nRet + 1); // '\0'
	if (lRet)
		{
		return lRet - 1;
		}

	LPWSTR szBuff = SzWAlloc(nRet + 1);
	lRet = AnsiToUnicode(szBuff, sz, nRet + 1, nRet + 1);
	Assert(lRet);
	memcpy(lpBuffer, szBuff, sizeof(WCHAR) * nBufferMax);
	lpBuffer[nBufferMax - 1] = L'\0';
	return nBufferMax - 1;
}

LPWSTR
WINAPI
OlstrcatW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1 || !lpString2)
		return lpString1;

	return wcscat(lpString1, lpString2);
}

int
WINAPI
OlstrcmpiW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpiW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpiA(psz1, psz2);
}

int
WINAPI
OlstrcmpW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpA(psz1, psz2);
}

LPWSTR
WINAPI
OlstrcpyW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1)
		return lpString1;

	if (!lpString2)
		lpString2 = L"";

	return wcscpy(lpString1, lpString2);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith added null string pointer handling
LPWSTR
WINAPI
OlstrcpynW(
	LPWSTR lpString1,
	LPCWSTR lpString2,
	int iMaxLength
	)
{
	if (!lpString1)
		{
		return lpString1;
		}

	if (!lpString2)
		{
		lpString2 = L"";
		}

	if(FWide())
		return lstrcpynW(lpString1, lpString2, iMaxLength);

	lpString1[--iMaxLength] = L'\0';
	return wcsncpy(lpString1, lpString2, iMaxLength);
}

int
WINAPI
OlstrlenW(
	LPCWSTR lpString
	)
{
	return lpString ? wcslen(lpString) : 0;
}

UINT
WINAPI
OMapVirtualKeyW(
	UINT uCode,
	UINT uMapType)
{
	// The only person using this so far is using uMapType == 0
	Assert(2 != uMapType);
	if (FWide())
		return MapVirtualKeyW(uCode, uMapType);
	return MapVirtualKeyA(uCode, uMapType);
}

int
WINAPI
OMessageBoxW(
	HWND hWnd ,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType)
{
	if(FWide())
		return MessageBoxW(hWnd, lpText, lpCaption, uType);

	PreConvert();
	LPSTR szText = Convert(lpText);
	LPSTR szCap  = Convert(lpCaption);

	return MessageBoxA(hWnd, szText, szCap, uType);
}

int
WINAPI
OMessageBoxIndirectW(
	LPMSGBOXPARAMSW lpmbp)
{
	Assert(!IsBadWritePtr((void*)lpmbp, sizeof MSGBOXPARAMSW));
	Assert(sizeof MSGBOXPARAMSW == lpmbp->cbSize);
	Assert(sizeof MSGBOXPARAMSW == sizeof MSGBOXPARAMSA);

	if(FWide())
		return MessageBoxIndirectW(lpmbp);

	PreConvert();

	MSGBOXPARAMSA mbpa;
	memcpy(&mbpa, lpmbp, sizeof MSGBOXPARAMSA);

	if (!FATOM(lpmbp->lpszText))
		{
		mbpa.lpszText = Convert(lpmbp->lpszText);
		}
	if (!FATOM(lpmbp->lpszCaption))
		{
		mbpa.lpszCaption = Convert(lpmbp->lpszCaption);
		}
	if ((lpmbp->dwStyle & MB_USERICON) && !FATOM(lpmbp->lpszIcon))
		{
		mbpa.lpszIcon = Convert(lpmbp->lpszIcon);
		}

	return MessageBoxIndirectA(&mbpa);
}

BOOL
WINAPI
OModifyMenuW(
	HMENU hMnu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return ModifyMenuW(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if (MF_STRING == uFlags)
		{
		PreConvert();
		LPSTR sz = Convert(lpNewItem);
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, sz);
		}
	else
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, (LPSTR) lpNewItem);

}


// From: Mark Ashton on 5/29/97
BOOL
WINAPI
OMoveFileExW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	DWORD dwFlags
	)
{
	if (FWide())
		return MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileExA(szOld, szNew, dwFlags);
}

BOOL
WINAPI
OMoveFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName)
{
	if(FWide())
		return MoveFileW(lpExistingFileName, lpNewFileName);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileA(szOld, szNew);
}

HANDLE
WINAPI
OLoadImageW(
	HINSTANCE hinst,
	LPCWSTR lpszName,
	UINT uType,
	int cxDesired,
	int cyDesired,
	UINT fuLoad)
{
	if (FWide())
		{
		Assert(!(LR_LOADFROMFILE & fuLoad));
		return LoadImageW(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
		}

	if (!FATOM(lpszName))
		{
		PreConvert();
		LPSTR pszName = Convert(lpszName);
		return LoadImageA(hinst, pszName, uType, cxDesired, cyDesired, fuLoad);
		}
	 else
		return LoadImageA(hinst, (LPSTR) lpszName, uType, cxDesired, cyDesired, fuLoad);
}

BOOL
WINAPI
OOemToCharW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst)
{
	if(FWide())
		{
		Assert(lpszSrc != (LPCSTR) lpszDst);
#pragma prefast(suppress:56, "do not know the size of the destination")
		return OemToCharW(lpszSrc, lpszDst);
		}

	DWORD cb = _mbslen((const unsigned char *)lpszSrc);
	LPSTR szDst = SzAlloc(cb);
#pragma prefast(suppress:56, "noise")
	BOOL fRet = OemToCharA(lpszSrc, szDst);
	if(fRet)
		{
		Verify(0 <= AnsiToUnicode(lpszDst, szDst, cb));
		}
	return fRet;
}

VOID
WINAPI
OOutputDebugStringW(
	LPCWSTR lpOutputString
	)
{
	if(FWide())
		{
		OutputDebugStringW(lpOutputString);
		return;
		}

	PreConvert();
	LPSTR sz = Convert(lpOutputString);
	OutputDebugStringA(sz);
}

BOOL
WINAPI
OPeekMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax,
	UINT wRemoveMsg)
{
	if(FWide())
		return PeekMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

	return PeekMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

BOOL
WINAPI
OPostMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return PostMessageW(hWnd, Msg, wParam, lParam);

	return PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OPostThreadMessageW(
	DWORD idThread,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
 {
	if (FWide())
		return PostThreadMessageW(idThread, Msg, wParam, lParam);

	return PostThreadMessageA(idThread, Msg, wParam, lParam);
 }


// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyExW(
	HKEY hKey,
	LPCWSTR lpSubKey,
	DWORD Reserved,
	LPWSTR lpClass,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition
	)
{
	Assert(lpSubKey);
	if(FWide())
		return RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	LPSTR sz2 = Convert(lpClass);
	return RegCreateKeyExA(hKey, sz, Reserved, sz2, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyW (
	HKEY hKey,
	LPCWSTR lpSubKey,
	PHKEY phkResult
	)
{
	if (FWide())
		return RegCreateKeyW(hKey, lpSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	return RegCreateKeyA(hKey, sz, phkResult);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegEnumKeyW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	DWORD cbName
	)
{
	if (FWide())
		return RegEnumKeyW(hKey, dwIndex, lpName, cbName);

	LPSTR sz = SzAlloc(cbName);
	LONG dwRet = RegEnumKeyA(hKey, dwIndex, sz, cbName);
	Verify(0 <= AnsiToUnicode(lpName, sz, cbName));
	return dwRet;
}

//  Van Kichline
//  IHammer group
//  Not supported: REG_MULTI_SZ
//
LONG
APIENTRY
ORegEnumValueW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpValueName,
	LPDWORD lpcbValueName,  // Documentation indicates this is a count of characters, despite the Hungarian.
	LPDWORD lpReserved,
	LPDWORD lpType,         // May be NULL, but we need to know it on return if lpData is not NULL.
	LPBYTE lpData,          // May be NULL
	LPDWORD lpcbData        // May be NULL is lpData is NULL
	)
{
	if (FWide())
		return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData);

	// Required pointers:
	if (!lpValueName || !lpcbValueName || !lpcbData && lpData)
		{
		Assert(lpValueName);
		Assert(lpcbValueName);
		Assert(!lpcbData && lpData);
		return E_POINTER;
		}

	// If NULL was specified for lpType, we need to supply our own so we can check for string results.
	DWORD dwPrivateType = 0;
	if (!lpType)
		{
		lpType = &dwPrivateType;
		}

	DWORD cbValueName  = *lpcbValueName;
	DWORD dwOrigCbData = lpcbData ? *lpcbData : 0;
	LPSTR pchValueName = SzAlloc(*lpcbValueName);

	LONG lResult = RegEnumValueA(hKey, dwIndex, pchValueName, &cbValueName, lpReserved, lpType, lpData, lpcbData);

	if (ERROR_SUCCESS == lResult)
		{
		*lpcbValueName = AnsiToUnicode(lpValueName, pchValueName, min(*lpcbValueName, cbValueName + 1)) - 1; // Returned value does NOT include terminating NULL

		if (lpData)
			{
			// If the resulting data was a string, convert it in place.
			switch (*lpType)
				{
				case REG_MULTI_SZ:
					// Not supported
					Assert(0 && REG_MULTI_SZ);
					lResult = E_FAIL;
					break;
				case REG_EXPAND_SZ:
				case REG_SZ:
					{
					Assert(lpcbData);
					LPSTR pszTemp = SzAlloc(*lpcbData); // is the number of bytes!
					memcpy(pszTemp, lpData, *lpcbData);
					*lpcbData = AnsiToUnicode((LPWSTR)lpData, pszTemp, dwOrigCbData/sizeof(WCHAR), *lpcbData) * sizeof(WCHAR);

					//	It's possible to encounter a second stage overflow, if lpData >= sizeof(Unicode)/2
					if ( 0 == *lpcbData )
						{
						lResult = ERROR_MORE_DATA;
						}
					}
					break;
				}
			}
		}

	return lResult;
}

LONG
APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
	if(FWide())
		return RegOpenKeyW(hKey, pwszSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	return RegOpenKeyA(hKey, sz, phkResult);
}

LONG
APIENTRY
ORegDeleteKeyW(
	HKEY hKey,
	LPCWSTR pwszSubKey
	)
{
	Assert(pwszSubKey);
	if(FWide())
		return RegDeleteKeyW(hKey, pwszSubKey);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);
	return RegDeleteKeyA(hKey, sz);
}

LONG
APIENTRY
ORegDeleteValueW(
	HKEY hKey,
	LPWSTR lpValueName
	)
{
	if(FWide())
		return RegDeleteValueW (hKey, lpValueName);

	PreConvert();
	LPSTR sz = Convert(lpValueName);
	return RegDeleteValueA(hKey, sz);
}

ATOM
WINAPI
ORegisterClassW(
	CONST WNDCLASSW *lpWndClass)
{
	if(FWide())
		return RegisterClassW(lpWndClass);

	WNDCLASSA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!(IsBadReadPtr(wc.lpszMenuName, sizeof(* wc.lpszMenuName)) ||
		  IsBadReadPtr(lpWndClass->lpszMenuName, sizeof (*(lpWndClass->lpszMenuName)))))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassA(&wc);
}

ATOM
WINAPI
ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass)
{
	if (FWide())
		return RegisterClassExW(lpWndClass);

	WNDCLASSEXA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!FATOM(wc.lpszMenuName))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	if (!FATOM(wc.lpszClassName))
		wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassExA(&wc);
}

BOOL
WINAPI
OUnregisterClassW
(
LPCTSTR  lpClassName,   // address of class name string
HINSTANCE  hInstance    // handle of application instance
)
{
	if(FWide())
		return UnregisterClassW(lpClassName, hInstance);

	if (FATOM(lpClassName))
		return UnregisterClassW(lpClassName, hInstance);

	PreConvert();
	LPSTR sz = Convert(lpClassName);

	return UnregisterClassA(sz, hInstance);
}

UINT
WINAPI
ORegisterClipboardFormatW(
	LPCWSTR lpszFormat)
{
	if(FWide())
		return RegisterClipboardFormatW(lpszFormat);

	PreConvert();
	LPSTR sz = Convert(lpszFormat);

	return RegisterClipboardFormatA(sz);
}

UINT
WINAPI
ORegisterWindowMessageW(LPCWSTR lpString)
{
	if(FWide())
		return RegisterWindowMessageW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return  RegisterWindowMessageA(sz);
}

LONG
APIENTRY
ORegOpenKeyExW (
	HKEY hKey,
	LPCTSTR lpSubKey,
	DWORD ulOptions,
	REGSAM samDesired,
	PHKEY phkResult
	)
{
	if(FWide())
		return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);

	return RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
}

LONG
APIENTRY
ORegQueryInfoKeyW (
	HKEY hKey,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	LPDWORD lpReserved,
	LPDWORD lpcSubKeys,
	LPDWORD lpcbMaxSubKeyLen,
	LPDWORD lpcbMaxClassLen,
	LPDWORD lpcValues,
	LPDWORD lpcbMaxValueNameLen,
	LPDWORD lpcbMaxValueLen,
	LPDWORD lpcbSecurityDescriptor,
	PFILETIME lpftLastWriteTime
	)
{
	Assert(!lpClass && !lpcbClass); //$ UNDONE_POST_98 - Not wrapped yet!
	if(FWide())
		return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved,
								lpcSubKeys, lpcbMaxSubKeyLen,
								lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
								lpcbMaxValueLen, lpcbSecurityDescriptor,
								lpftLastWriteTime );

	if (lpClass && (!lpcbClass || IsBadWritePtr(lpcbClass, sizeof(lpcbClass))))
		{
		// lpcbClass must be valid if lpClass is non-NULL
		return ERROR_INVALID_PARAMETER;
		}

	return RegQueryInfoKeyA(hKey, NULL, NULL, lpReserved,
							lpcSubKeys, lpcbMaxSubKeyLen,
							lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
							lpcbMaxValueLen, lpcbSecurityDescriptor,
							lpftLastWriteTime );
}

LONG
APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
	PLONG   lpcbValue)
{
	if(FWide())
		return RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);

	LONG  cb;
	LONG  lRet    = 0;
	LPSTR szValue = NULL;
	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	lRet = RegQueryValueA(hKey, sz, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}
	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!pwszValue)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		goto Exit;
		}


	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
		{
		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	szValue = SzAlloc(cb);

	lRet = RegQueryValueA(hKey, sz, szValue, &cb);

	if (ERROR_SUCCESS == lRet)
		{
		Verify(0 <= AnsiToUnicode(pwszValue, szValue, cb));

		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		}
	else if (pwszValue && 0 < cb)
		{
		*pwszValue = L'\0';
		}

Exit:

	return lRet;
}

LONG
APIENTRY
ORegSetValueExW(
	HKEY hKey,
	LPCWSTR lpValueName,
	DWORD Reserved,
	DWORD dwType,
	CONST BYTE* lpData,
	DWORD cbData
	)
{
	if(FWide())
		return RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

	PreConvert();
	LPSTR sz = Convert(lpValueName);

	LONG lRet;

	// NOTE: when calling RegSetValueExA, if the data type is
	// REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, then the API expects the strings
	// to be ansi also.
	if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPTSTR)lpData, -1, &lData);
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else if (REG_MULTI_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPWSTR)lpData,
									  cUnicodeMultiSzLen((LPWSTR)lpData),
									  &lData );
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else
		{
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, lpData, cbData);
		}

	return lRet;
}

LONG
APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
	LPCWSTR lpData, DWORD cbData)
{
	Assert(REG_SZ == dwType);

	if(FWide())
		return RegSetValueW(hKey, lpSubKey, dwType,
			lpData, cbData);

	PreConvert();
	LPSTR szKey   = Convert(lpSubKey);
	LPSTR szValue = Convert(lpData);

	return RegSetValueA(hKey, szKey, dwType, szValue, cbData);
}

LONG
APIENTRY
ORegQueryValueExW (
	HKEY hKey,
	LPCWSTR lpValueName,
	LPDWORD lpReserved,
	LPDWORD lpType,
	LPBYTE lpData,
	LPDWORD lpcbData
	)
{
	Assert(lpcbData || !lpData); // lpcbData can be NULL only if lpData is NULL
	if(FWide())
		return RegQueryValueExW (
			hKey,
			lpValueName,
			lpReserved,
			lpType,
			lpData,
			lpcbData
			);

	LPBYTE lpTempBuffer;
	DWORD dwTempType;
	DWORD cb, cbRequired;
	LONG  lRet;
	PreConvert();
	LPSTR sz = Convert(lpValueName);

	lRet = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!lpData)
		{
		switch (dwTempType)
			{
			case REG_EXPAND_SZ:
			case REG_MULTI_SZ:
			case REG_SZ:
				// Adjust size of buffer to report, to account for CHAR -> WCHAR

				*lpcbData = cb * sizeof(WCHAR);
				break;

			default:
				*lpcbData = cb;
				break;
			}

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		goto Exit;
		}


	//
	// Determine the size of buffer needed
	//

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:
			cbRequired = cb * sizeof(WCHAR);
			break;

		default:
			cbRequired = cb;
			break;
		}

	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbData < cbRequired)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbData = cbRequired;

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:

			lpTempBuffer = (LPBYTE)SzAlloc(cbRequired);

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									&dwTempType,
									lpTempBuffer,
									&cb);

			if (ERROR_SUCCESS == lRet)
				{
				switch (dwTempType)
					{
					case REG_EXPAND_SZ:
					case REG_MULTI_SZ:
					case REG_SZ:

						*lpcbData = AnsiToUnicode((LPWSTR)lpData, (LPSTR)lpTempBuffer, *lpcbData, cb);
						*lpcbData = cb * sizeof(WCHAR); // Result it in BYTES!

						// Set the type, if required.
						if (lpType)
							{
							*lpType = dwTempType;
							}
						break;
					}
				}

			goto Exit;

		default:

			//
			// No conversion of out parameters needed.  Just call narrow
			// version with args passed in, and return directly.
			//

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									lpType,
									lpData,
									lpcbData);

		}

Exit:

	return lRet;
}

HANDLE
WINAPI
ORemovePropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return RemovePropW(hWnd, lpString);

	if(FATOM(lpString))
		return RemovePropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return RemovePropA(hWnd, sz);
}

LRESULT
WINAPI
OSendDlgItemMessageW(
	HWND hDlg,
	int nIDDlgItem,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);

	PreConvert();
	switch (Msg)
		{
		case LB_ADDSTRING:
		case LB_INSERTSTRING:
		case LB_SELECTSTRING:
		case LB_FINDSTRING:
		case LB_FINDSTRINGEXACT:
		case CB_ADDSTRING:
		case CB_INSERTSTRING:
		case CB_SELECTSTRING:
		case CB_FINDSTRING:
		case CB_FINDSTRINGEXACT:
			{
			lParam = (LPARAM)Convert((LPWSTR)lParam);
			break;
			}
		}

	return SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
}

LRESULT
WINAPI
OSendMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return SendMessageW(hWnd, Msg, wParam, lParam);

	return SendMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSendNotifyMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendNotifyMessageW(hWnd, Msg, wParam, lParam);

	return SendNotifyMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPCWSTR lpString)
{
	if(FWide())
		return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetDlgItemTextA(hDlg, nIDDlgItem, sz);
}

BOOL
WINAPI
OSetFileAttributesW(
	LPCWSTR lpFileName,
	DWORD dwFileAttributes
	)
{
	if (FWide())
		return SetFileAttributesW(lpFileName, dwFileAttributes);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return SetFileAttributesA(sz, dwFileAttributes);
}

BOOL
WINAPI
OSetPropW(
	HWND hWnd,
	LPCWSTR lpString,
	HANDLE hData)
{
	if(FWide())
		return SetPropW(hWnd, lpString, hData);

	if(FATOM(lpString))
		return SetPropA(hWnd, (LPSTR)lpString, hData);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetPropA(hWnd, sz, hData);
}

BOOL
WINAPI
OSetMenuItemInfoW(
	HMENU hMenu,
	UINT uItem,
	BOOL fByPosition,
	LPCMENUITEMINFOW lpcmii
	)
{
	Assert(!IsBadWritePtr((void*)lpcmii, sizeof MENUITEMINFOW));
	Assert(sizeof MENUITEMINFOW == lpcmii->cbSize);
	Assert(sizeof MENUITEMINFOW == sizeof MENUITEMINFOA);

	if (FWide())
		return SetMenuItemInfoW(hMenu, uItem, fByPosition, lpcmii);

	MENUITEMINFOA mii;
	memcpy(&mii, lpcmii, sizeof MENUITEMINFOA);

	if (!(lpcmii->fMask & MIIM_TYPE) ||
		MFT_STRING != (lpcmii->fType &
				  (MFT_BITMAP | MFT_SEPARATOR | MFT_OWNERDRAW | MFT_STRING) ) )
		{
		return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
		}

	PreConvert();
	mii.dwTypeData = Convert(lpcmii->dwTypeData);
	return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
}

LONG
WINAPI
OSetWindowLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if(FWide())
		return SetWindowLongW(hWnd, nIndex, dwNewLong);

	return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

HHOOK
WINAPI
OSetWindowsHookExW(
	int idHook,
	HOOKPROC lpfn,
	HINSTANCE hmod,
	DWORD dwThreadId)
{
	if(FWide())
		return SetWindowsHookExW(idHook, lpfn, hmod, dwThreadId);

	return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);  //$ CONSIDER - Not really wrapped
}

BOOL
WINAPI
OSetWindowTextW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return SetWindowTextW(hWnd, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetWindowTextA(hWnd, sz);
}

LONG
WINAPI
OTabbedTextOutW(
	HDC hDC,
	int X,
	int Y,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions,
	int nTabOrigin)
{
	Assert(-1 != nCount);

	if(FWide())
		return TabbedTextOutW(hDC, X, Y, lpString, nCount, nTabPositions,
			lpnTabStopPositions, nTabOrigin);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);

	return TabbedTextOutA(hDC, X, Y, sz, n, nTabPositions,
						  lpnTabStopPositions, nTabOrigin );
}

#if 0
// FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
int
WINAPI
OTranslateAcceleratorW(
	HWND hWnd,
	HACCEL hAccTable,
	LPMSG lpMsg)
{
	if(FWide())
		return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);

	return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);
}
#endif

SHORT
WINAPI
OVkKeyScanW(
	WCHAR ch)
{
	if (FWide())
		return VkKeyScanW(ch);
	TCHAR szW[2];
	char szA[2];
	szW[0] = ch;
	szW[1] = L'\0';
	Verify(0 <= UnicodeToAnsi(szA, szW, 2));
	return VkKeyScanA(szA[0]);
}

BOOL
WINAPI
OWinHelpW(
	HWND hWndMain,
	LPCWSTR lpszHelp,
	UINT uCommand,
	DWORD dwData
	)
{
	if(FWide())
		return WinHelpW(hWndMain, lpszHelp, uCommand,dwData);

	PreConvert();
	LPSTR sz = Convert(lpszHelp);
	return WinHelpA(hWndMain, sz, uCommand, dwData);
}

BOOL
WINAPI
OWritePrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString,
	LPCWSTR lpFileName)
{
	if(FWide())
		return WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szString   = Convert(lpString);
	LPSTR szFileName = Convert(lpFileName);

	return WritePrivateProfileStringA(szAppName, szKeyName, szString, szFileName);
}

int
WINAPIV
OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
	va_list vaArgs;
	va_start(vaArgs, pwszFormat);
	int retval;

	if(FWide())
		retval = wvsprintfW(pwszOut, pwszFormat, vaArgs);
	else
		retval = _vstprintf(pwszOut, pwszFormat, vaArgs); //$CONSIDER Why isn't this vswprint?

	va_end(vaArgs);
	return retval;
}

BOOL
WINAPI
OGetVersionExW(
	LPOSVERSIONINFOW lpVersionInformation
	)
{
	if(FWide())
		return GetVersionExW(lpVersionInformation);

	if (lpVersionInformation->dwOSVersionInfoSize < sizeof(OSVERSIONINFOW))
		return false;

	OSVERSIONINFOA  osviVersionInfo;
	osviVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	int fRetval = GetVersionExA(&osviVersionInfo);

	if (fRetval)
		{
		memcpy(lpVersionInformation, &osviVersionInfo, sizeof(OSVERSIONINFOA));

		Verify(0 <= AnsiToUnicode(lpVersionInformation->szCSDVersion,
								 osviVersionInfo.szCSDVersion,
								 sizeof(lpVersionInformation->szCSDVersion)
								 /sizeof(lpVersionInformation->szCSDVersion[0])));
		}

	return fRetval;
}

LONG
APIENTRY
ORegEnumKeyExW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	LPDWORD lpcbName,
	LPDWORD lpReserved,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	PFILETIME lpftLastWriteTime
	)
{
	if(FWide())
		return RegEnumKeyExW (
			hKey,
			dwIndex,
			lpName,
			lpcbName,
			lpReserved,
			lpClass,
			lpcbClass,
			lpftLastWriteTime
			);

	LPSTR szName, szClass;
	DWORD cbName, cbClass;

	if (lpcbName)
		{
		cbName = sizeof(WCHAR) * *lpcbName;
		szName = lpName ? SzAlloc(cbName) : NULL;
		}
	else
		{
		szName = NULL;
		cbName = 0;
		}

	if (lpcbClass)
		{
		cbClass = sizeof(WCHAR) * (*lpcbClass);
		szClass = lpClass ? SzAlloc(cbClass) : NULL;
		}
	else
		{
		szClass = NULL;
		cbClass = 0;
		}

	LONG lRet = RegEnumKeyExA(hKey, dwIndex, szName, &cbName, lpReserved,
							  szClass, &cbClass, lpftLastWriteTime );

	if (ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// Get the number of characters instead of number of bytes.
	if (lpcbName)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpName, (LPSTR) szName, *lpcbName);
		if (cbName && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbName = dwNoOfChar;
		}

	if (lpcbClass && lpClass)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpClass, (LPSTR) szClass, *lpcbClass);

		if (cbClass && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbClass = dwNoOfChar;
		}

	return lRet;

}

HANDLE
WINAPI
OCreateFileMappingW(
	HANDLE hFile,
	LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, sz);
}

LRESULT
WINAPI
ODefDlgProcW(
	HWND hDlg,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return DefDlgProcW(hDlg, Msg, wParam, lParam);

	return DefDlgProcA(hDlg, Msg, wParam, lParam);
}

int
WINAPI
OGetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPWSTR  lpLCData,
	int      cchData)
{
	DWORD dwRet;

	if (FWide())
		return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);

	if (!cchData || !lpLCData)
		return GetLocaleInfoA(Locale, LCType, NULL, cchData);

	int cchDataAnsi = sizeof(WCHAR) * cchData;
	LPSTR szBuffer = SzAlloc(cchDataAnsi);

	dwRet = GetLocaleInfoA(Locale, LCType, szBuffer, cchDataAnsi);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		return AnsiToUnicode(lpLCData, szBuffer, cchData, dwRet);
		}
	else if (lpLCData && 0 < cchData)
		{
		*lpLCData = L'\0';
		}

	return dwRet;
}

BOOL
WINAPI
OSetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPCWSTR lpLCData)
{
	if (FWide())
		return SetLocaleInfoW(Locale, LCType, lpLCData);
	PreConvert();
	LPSTR sz = Convert(lpLCData);

	return SetLocaleInfoA(Locale, LCType, sz);
}

// $UNDONE_POST_98$ Workaround because StgCreateDocfile is not reentrant.
//          We were getting ACCESS DENIED errors when multiple threads opened
//             temp files simultaneously.

//-----------------------------------------------------------------------------
// Name: StgCreateDocfileCriticalSection
//
// Description:
// Used solely by OStgCreateDocfile in order to protect its call to
// StgCreateDocfile from simultaneously entry by multiple threads.
//
//-----------------------------------------------------------------------------
class StgCreateDocfileCriticalSection
{
public:
	StgCreateDocfileCriticalSection() {InitializeCriticalSection(&m_critsec);}
	~StgCreateDocfileCriticalSection() {DeleteCriticalSection(&m_critsec);}
	VOID VEnter() {EnterCriticalSection(&m_critsec);}
	VOID VLeave() {LeaveCriticalSection(&m_critsec);}
private:
	CRITICAL_SECTION m_critsec;
};

//-----------------------------------------------------------------------------
// Name: OStgCreateDocfile
//
// Description:
// Wrapper for StgCreateDocfile to protect against reentrancy bug in OLE.
//
// Thread-Safety: Bullet-proof
//
// Return Values: same HRESULT as StgCreateDocfile
//-----------------------------------------------------------------------------
HRESULT
WINAPI
OStgCreateDocfile
(
const WCHAR * pwcsName,
DWORD grfMode,
DWORD reserved,
IStorage ** ppstgOpen
)
{
	HRESULT hrReturn;
	static StgCreateDocfileCriticalSection Crit;
	Crit.VEnter();
// Change: Vank
// This definitions was infinitely recursive.  The 64 bit compiler caught it and refused to let it pass.
#ifdef StgCreateDocfile
#undef StgCreateDocfile
	hrReturn = StgCreateDocfile(pwcsName, grfMode, reserved, ppstgOpen);
#define StgCreateDocfile OStgCreateDocfile
#else
	hrReturn = StgCreateDocfile(pwcsName, grfMode, reserved, ppstgOpen);
#endif
// End change: VanK
	Crit.VLeave();
	return hrReturn;
}

int
WINAPI
OStartDocW
(
HDC hDC,
CONST DOCINFOW * pdiDocW
)
{
	if (FWide())
		return StartDocW(hDC, pdiDocW);

	DOCINFOA diDocA;

	PreConvert();

	diDocA.lpszDocName  = Convert(pdiDocW->lpszDocName);
	diDocA.lpszOutput   = Convert(pdiDocW->lpszOutput);
	diDocA.lpszDatatype = Convert(pdiDocW->lpszDatatype);
	diDocA.cbSize       = sizeof(DOCINFOA);
	diDocA.fwType       = pdiDocW->fwType;

	return StartDocA(hDC, &diDocA);

}

BOOL
WINAPI
OSystemParametersInfoW(
	UINT uiAction,
	UINT uiParam,
	PVOID pvParam,
	UINT fWinIni)
{
	if (FWide())
		return SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni);

	switch (uiAction)
		{   // unsupported actions
		case SPI_GETHIGHCONTRAST:
		case SPI_GETICONMETRICS:
		case SPI_GETICONTITLELOGFONT:
		case SPI_GETNONCLIENTMETRICS:
		case SPI_GETSERIALKEYS:
		case SPI_GETSOUNDSENTRY:

		case SPI_SETDESKWALLPAPER:
		case SPI_SETHIGHCONTRAST:
		case SPI_SETICONMETRICS:
		case SPI_SETICONTITLELOGFONT:
		case SPI_SETNONCLIENTMETRICS:
		case SPI_SETSERIALKEYS:
		case SPI_SETSOUNDSENTRY:
			AssertFail("No Unicode Wrapper Available for Win32 API - SystemParametersInfoW");
			return 0;
		};
	return SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni);
}

LPWSTR
WINAPI
OCharNextW(
LPCWSTR lpsz)
{
	if ( FWide() )
		return CharNextW( lpsz );

	if (*lpsz == L'\0')
		{
		return const_cast<LPWSTR>(lpsz);
		}

	return const_cast<LPWSTR>(lpsz + 1);
}


#ifdef DEBUG
BOOL
APIENTRY
OAbortSystemShutdownW(
	LPWSTR lpMachineName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AbortSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OAccessCheckAndAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR SecurityDescriptor,
	DWORD DesiredAccess,
	PGENERIC_MAPPING GenericMapping,
	BOOL ObjectCreation,
	LPDWORD GrantedAccess,
	LPBOOL AccessStatus,
	LPBOOL pfGenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AccessCheckAndAuditAlarmW");
	return 0;
}

int
WINAPI OAddFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFontResourceW");
	return 0;
}

BOOL
WINAPI
OAddFormW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFormW");
	return 0;
}

BOOL
WINAPI
OAddJobW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pData,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddJobW");
	return 0;
}

BOOL
WINAPI
OAddMonitorW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddMonitorW");
	return 0;
}

BOOL
WINAPI
OAddPortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPortW");
	return 0;
}

HANDLE
WINAPI
OAddPrinterW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPrinter
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterW");
	return 0;
}

BOOL
WINAPI
OAddPrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterConnectionW");
	return 0;
}

BOOL
WINAPI
OAddPrinterDriverW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pDriverInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OAddPrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPathName,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProcessorW");
	return 0;
}

BOOL
WINAPI
OAddPrintProvidorW(
	LPWSTR  pName,
	DWORD    level,
	LPBYTE   pProvidorInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProvidorW");
	return 0;
}

LONG
WINAPI
OAdvancedDocumentPropertiesW(
	HWND    hWnd,
	HANDLE  hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AdvancedDocumentPropertiesW");
	return 0;
}

MMRESULT WINAPI OauxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - auxGetDevCapsW");
	return 0;
}

BOOL
WINAPI
OBackupEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BackupEventLogW");
	return 0;
}

HANDLE
WINAPI
OBeginUpdateResourceW(
	LPCWSTR pFileName,
	BOOL bDeleteExistingResources
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BeginUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBW(
	LPCWSTR lpDef,
	LPDCB lpDCB
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBAndTimeoutsW(
	LPCWSTR lpDef,
	LPDCB lpDCB,
	LPCOMMTIMEOUTS lpCommTimeouts
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBAndTimeoutsW");
	return 0;
}

BOOL
WINAPI
OCallMsgFilterW(
	LPMSG lpMsg,
	int nCode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallMsgFilterW");
	return 0;
}

BOOL
WINAPI
OCallNamedPipeW(
	LPCWSTR lpNamedPipeName,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesRead,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallNamedPipeW");
	return 0;
}

LONG
WINAPI
OChangeDisplaySettingsW(
	LPDEVMODEW lpDevMode,
	DWORD dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeDisplaySettingsW");
	return 0;
}

BOOL
WINAPI
OChangeMenuW(
	HMENU hMenu,
	UINT cmd,
	LPCWSTR lpszNewItem,
	UINT cmdInsert,
	UINT flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeMenuW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OChangeServiceConfigW(
	SC_HANDLE    hService,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword,
	LPCWSTR     lpDisplayName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeServiceConfigW");
	return 0;
}
#endif

BOOL
WINAPI
OCharToOemBuffW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharToOemBuffW");
	return 0;
}

DWORD
WINAPI
OCharUpperBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharUpperBuffW");
	return 0;
}

BOOL
WINAPI
OChooseColorW(
	LPCHOOSECOLORW lpcc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseColorW");
	return 0;
}

BOOL
APIENTRY OChooseFontW(LPCHOOSEFONTW pchfw)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseFontW");
	return 0;
}

BOOL
WINAPI
OClearEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ClearEventLogW");
	return 0;
}

BOOL
WINAPI
OCommConfigDialogW(
	LPCWSTR lpszName,
	HWND hWnd,
	LPCOMMCONFIG lpCC
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CommConfigDialogW");
	return 0;
}

int
WINAPI
OCompareStringW(
	LCID     Locale,
	DWORD    dwCmpFlags,
	LPCWSTR lpString1,
	int      cchCount1,
	LPCWSTR lpString2,
	int      cchCount2)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CompareStringW");
	return 0;
}

BOOL
WINAPI
OConfigurePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ConfigurePortW");
	return 0;
}

int
WINAPI
OCopyAcceleratorTableW(
	HACCEL hAccelSrc,
	LPACCEL lpAccelDst,
	int cAccelEntries)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyAcceleratorTableW");
	return 0;
}

HENHMETAFILE
WINAPI
OCopyEnhMetaFileW(HENHMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyEnhMetaFileW");
	return 0;
}

HMETAFILE
WINAPI
OCopyMetaFileW(HMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyMetaFileW");
	return 0;
}

HACCEL
WINAPI
OCreateAcceleratorTableW(
	LPACCEL, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateAcceleratorTableW");
	return 0;
}

WINAPI
OCreateColorSpaceW(LPLOGCOLORSPACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateColorSpaceW");
	return 0;
}

HDESK
WINAPI
OCreateDesktopW(
	LPWSTR lpszDesktop,
	LPWSTR lpszDevice,
	LPDEVMODEW pDevmode,
	DWORD dwFlags,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDesktopW");
	return 0;
}

HWND
WINAPI
OCreateDialogIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW lpTemplate,
	HWND hWndParent,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogIndirectParamW");
	return 0;
}

HWND
WINAPI
OCreateDialogParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogParamW");
	return 0;
}

HDC
WINAPI
OCreateICW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpdvmInit)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateICW");
	return 0;
}

HANDLE
WINAPI
OCreateMailslotW(
	LPCWSTR lpName,
	DWORD nMaxMessageSize,
	DWORD lReadTimeout,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMailslotW");
	return 0;
}

HANDLE
WINAPI
OCreateMutexW(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMutexW");
	return 0;
}

HANDLE
WINAPI
OCreateNamedPipeW(
	LPCWSTR lpName,
	DWORD dwOpenMode,
	DWORD dwPipeMode,
	DWORD nMaxInstances,
	DWORD nOutBufferSize,
	DWORD nInBufferSize,
	DWORD nDefaultTimeOut,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateNamedPipeW");
	return 0;
}

BOOL
WINAPI
OCreateProcessW(
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessW");
	return 0;
}

BOOL
WINAPI
OCreateProcessAsUserW (
	HANDLE hToken,
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessAsUserW");
	return 0;
}

HPROPSHEETPAGE
WINAPI
OCreatePropertySheetPageW(
	LPCPROPSHEETPAGEW lpcpsp
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreatePropertySheetPageW");
	return 0;
}

BOOL
WINAPI
OCreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateScalableFontResourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OCreateServiceW(
	SC_HANDLE    hSCManager,
	LPCWSTR     lpServiceName,
	LPCWSTR     lpDisplayName,
	DWORD        dwDesiredAccess,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateServiceW");
	return 0;
}
#endif

HWND WINAPI OCreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateStatusWindowW");
	return 0;
}

HWINSTA
WINAPI
OCreateWindowStationW(
	LPWSTR lpwinsta,
	DWORD dwReserved,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateWindowStationW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ODceErrorInqTextW (
	IN RPC_STATUS RpcStatus,
	OUT unsigned short __RPC_FAR * ErrorText
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DceErrorInqTextW");
	return 0;
}

BOOL
WINAPI
ODefineDosDeviceW(
	DWORD dwFlags,
	LPCWSTR lpDeviceName,
	LPCWSTR lpTargetPath
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DefineDosDeviceW");
	return 0;
}

BOOL
WINAPI
ODeleteFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteFormW");
	return 0;
}

BOOL
WINAPI
ODeleteMonitorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteMonitorW");
	return 0;
}

BOOL
WINAPI
ODeletePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePortW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterConnectionW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterDriverW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProcessorW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProvidorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProvidorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProvidorW");
	return 0;
}

int
WINAPI
ODeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
								LPWSTR, CONST DEVMODEW *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeviceCapabilitiesW");
	return 0;
}

int
WINAPI
ODlgDirListW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDListBox,
	int nIDStaticPath,
	UINT uFileType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListW");
	return 0;
}

int
WINAPI
ODlgDirListComboBoxW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDComboBox,
	int nIDStaticPath,
	UINT uFiletype)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListComboBoxW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectComboBoxExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDComboBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectComboBoxExW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDListBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectExW");
	return 0;
}

DWORD
WINAPI
ODocumentPropertiesW(
	HWND      hWnd,
	HANDLE    hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput,
	DWORD     fMode
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DocumentPropertiesW");
	return 0;
}

DWORD
APIENTRY
ODoEnvironmentSubstW(LPWSTR szString, UINT cbString)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DoEnvironmentSubstW");
	return 0;
}

UINT
APIENTRY
ODragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DragQueryFileW");
	return 0;
}

BOOL
WINAPI
ODrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DrawStateW");
	return 0;
}

BOOL
WINAPI
OEndUpdateResourceW(
	HANDLE      hUpdate,
	BOOL        fDiscard
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EndUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OEnumCalendarInfoW(
	CALINFO_ENUMPROCW lpCalInfoEnumProc,
	LCID              Locale,
	CALID             Calendar,
	CALTYPE           CalType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumCalendarInfoW");
	return 0;
}

BOOL
WINAPI
OEnumDateFormatsW(
	DATEFMT_ENUMPROCW lpDateFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDateFormatsW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumDependentServicesW(
	SC_HANDLE               hService,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDependentServicesW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumDesktopsW(
	HWINSTA hwinsta,
	DESKTOPENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDesktopsW");
	return 0;
}

BOOL
WINAPI
OEnumDisplaySettingsW(
	LPCWSTR lpszDeviceName,
	DWORD iModeNum,
	LPDEVMODEW lpDevMode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDisplaySettingsW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesExW");
	return 0;
}

int
WINAPI
OEnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontsW");
	return 0;
}

BOOL
WINAPI
OEnumFormsW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFormsW");
	return 0;
}

WINAPI
OEnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumICMProfilesW");
	return 0;
}

BOOL
WINAPI
OEnumJobsW(
	HANDLE  hPrinter,
	DWORD   FirstJob,
	DWORD   NoJobs,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumJobsW");
	return 0;
}

BOOL
WINAPI
OEnumMonitorsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumMonitorsW");
	return 0;
}

BOOL
WINAPI
OEnumPortsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPorts,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPortsW");
	return 0;
}

BOOL
WINAPI
OEnumPrinterDriversW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrinterDriversW");
	return 0;
}

BOOL
WINAPI
OEnumPrintersW(
	DWORD   Flags,
	LPWSTR   Name,
	DWORD   Level,
	LPBYTE  pPrinterEnum,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintersW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorDatatypesW(
	LPWSTR   pName,
	LPWSTR   pPrintProcessorName,
	DWORD   Level,
	LPBYTE  pDatatypes,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorDatatypesW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorsW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorsW");
	return 0;
}

int
WINAPI
OEnumPropsW(
	HWND hWnd,
	PROPENUMPROCW lpEnumFunc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsW");
	return 0;
}

int
WINAPI
OEnumPropsExW(
	HWND hWnd,
	PROPENUMPROCEXW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsExW");
	return 0;
}

INT
APIENTRY
OEnumProtocolsW (
	IN     LPINT           lpiProtocols,
	IN OUT LPVOID          lpProtocolBuffer,
	IN OUT LPDWORD         lpdwBufferLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumProtocolsW");
	return 0;
}

BOOL
WINAPI
OEnumResourceLanguagesW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	ENUMRESLANGPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceLanguagesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceNamesW(
	HMODULE hModule,
	LPCWSTR lpType,
	ENUMRESNAMEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceNamesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceTypesW(
	HMODULE hModule,
	ENUMRESTYPEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceTypesW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumServicesStatusW(
	SC_HANDLE               hSCManager,
	DWORD                   dwServiceType,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned,
	LPDWORD                 lpResumeHandle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumServicesStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumSystemCodePagesW(
	CODEPAGE_ENUMPROCW lpCodePageEnumProc,
	DWORD              dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemCodePagesW");
	return 0;
}

BOOL
WINAPI
OEnumSystemLocalesW(
	LOCALE_ENUMPROCW lpLocaleEnumProc,
	DWORD            dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemLocalesW");
	return 0;
}

BOOL
WINAPI
OEnumTimeFormatsW(
	TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumTimeFormatsW");
	return 0;
}

BOOL
WINAPI
OEnumWindowStationsW(
	WINSTAENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumWindowStationsW");
	return 0;
}

HICON
APIENTRY
OExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractAssociatedIconW");
	return 0;
}

HICON
APIENTRY
OExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconW");
	return 0;
}


UINT
WINAPI
OExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconExW");
	return 0;
}

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtTextOutW");
	return 0;
}
*/

BOOL
WINAPI
OFillConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	WCHAR  cCharacter,
	DWORD  nLength,
	COORD  dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FillConsoleOutputCharacterW");
	return 0;
}

LPWSTR
APIENTRY
OFindEnvironmentStringW(LPWSTR szEnvVar)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindEnvironmentStringW");
	return 0;
}

HINSTANCE
APIENTRY
OFindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindExecutableW");
	return 0;
}

HRSRC
WINAPI
OFindResourceExW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	WORD    wLanguage
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindResourceExW");
	return 0;
}

APIENTRY
OFindTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindTextW");
	return 0;
}

HWND
WINAPI
OFindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindWindowExW");
	return 0;
}

int
WINAPI
OFoldStringW(
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FoldStringW");
	return 0;
}

BOOL
WINAPI
OGetBinaryTypeW(
	LPCWSTR lpApplicationName,
	LPDWORD lpBinaryType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetBinaryTypeW");
	return 0;
}

DWORD
WINAPI
OGetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharacterPlacementW");
	return 0;
}

BOOL
WINAPI
OGetCharWidth32W(HDC, UINT, UINT, LPINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharWidth32W");
	return 0;
}

LPWSTR
WINAPI
OGetCommandLineW(
	VOID
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCommandLineW");
	return 0;
}

DWORD
WINAPI
OGetCompressedFileSizeW(
	LPCWSTR lpFileName,
	LPDWORD lpFileSizeHigh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCompressedFileSizeW");
	return 0;
}

BOOL
WINAPI
OGetComputerNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetComputerNameW");
	return 0;
}

DWORD
WINAPI
OGetConsoleTitleW(
	LPWSTR lpConsoleTitle,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetConsoleTitleW");
	return 0;
}

int
WINAPI
OGetCurrencyFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST CURRENCYFMTW *lpFormat,
	LPWSTR  lpCurrencyStr,
	int      cchCurrency)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCurrencyFormatW");
	return 0;
}

int
WINAPI
OGetDateFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpDate,
	LPCWSTR lpFormat,
	LPWSTR  lpDateStr,
	int      cchDate)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDateFormatW");
	return 0;
}

BOOL
WINAPI
OGetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	LPDWORD lpdwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OGetDiskFreeSpaceW(
	LPCWSTR lpRootPathName,
	LPDWORD lpSectorsPerCluster,
	LPDWORD lpBytesPerSector,
	LPDWORD lpNumberOfFreeClusters,
	LPDWORD lpTotalNumberOfClusters
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDiskFreeSpaceW");
	return 0;
}

UINT
WINAPI
OGetDriveTypeW(
	LPCWSTR lpRootPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDriveTypeW");
	return 0;
}

HENHMETAFILE
WINAPI
OGetEnhMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileW");
	return 0;
}

UINT
WINAPI
OGetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileDescriptionW");
	return 0;
}

DWORD
WINAPI
OGetEnvironmentVariableW(
	LPCWSTR lpName,
	LPWSTR lpBuffer,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnvironmentVariableW");
	return 0;
}

INT
APIENTRY
OGetExpandedNameW(
	LPWSTR,
	LPWSTR
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetExpandedNameW");
	return 0;
}

BOOL
WINAPI
OGetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION RequestedInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	DWORD nLength,
	LPDWORD lpnLengthNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileSecurityW");
	return 0;
}

short
WINAPI
OGetFileTitleW
(
LPCWSTR pwszFile,
LPWSTR pwszOut,
WORD w
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileTitleW");
	return 0;
}

BOOL
WINAPI
OGetFileVersionInfoW(
	LPWSTR lpszFile,
	DWORD dwHandle,
	DWORD cbBuf,
	LPVOID lpvData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoW");
	return 0;
}

DWORD
WINAPI
OGetFileVersionInfoSizeW(
	LPWSTR lpszFile,
	LPDWORD lpdwHandle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoSizeW");
	return 0;
}

BOOL
WINAPI
OGetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFormW");
	return 0;
}

WINAPI OGetICMProfileW(HDC,LPDWORD,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetICMProfileW");
	return 0;
}

BOOL
WINAPI
OGetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetJobW");
	return 0;
}

BOOL
WINAPI
OGetKeyboardLayoutNameW(
	LPWSTR pwszKLID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyboardLayoutNameW");
	return 0;
}

WINAPI OGetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogColorSpaceW");
	return 0;
}

DWORD
WINAPI
OGetLogicalDriveStringsW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogicalDriveStringsW");
	return 0;
}

BOOL
WINAPI
OGetMenuItemInfoW(
	HMENU,
	UINT,
	BOOL,
	LPMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuItemInfoW");
	return 0;
}

HMETAFILE   WINAPI OGetMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMetaFileW");
	return 0;
}

INT
APIENTRY
OGetNameByTypeW (
	IN     LPGUID          lpServiceType,
	IN OUT LPWSTR         lpServiceName,
	IN     DWORD           dwNameLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNameByTypeW");
	return 0;
}

BOOL
WINAPI
OGetNamedPipeHandleStateW(
	HANDLE hNamedPipe,
	LPDWORD lpState,
	LPDWORD lpCurInstances,
	LPDWORD lpMaxCollectionCount,
	LPDWORD lpCollectDataTimeout,
	LPWSTR lpUserName,
	DWORD nMaxUserNameSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNamedPipeHandleStateW");
	return 0;
}

int
WINAPI
OGetNumberFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST NUMBERFMTW *lpFormat,
	LPWSTR  lpNumberStr,
	int      cchNumber)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNumberFormatW");
	return 0;
}

BOOL
WINAPI
OGetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterW");
	return 0;
}

DWORD
WINAPI
OGetPrinterDataW(
	HANDLE   hPrinter,
	LPWSTR    pValueName,
	LPDWORD  pType,
	LPBYTE   pData,
	DWORD    nSize,
	LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverW(
	HANDLE  hPrinter,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverDirectory,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverDirectoryW");
	return 0;
}

BOOL
WINAPI
OGetPrintProcessorDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrintProcessorDirectoryW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionNamesW(
	LPWSTR lpszReturnBuffer,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionNamesW");
	return 0;
}

BOOL
WINAPI
OGetPrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileStructW");
	return 0;
}

DWORD
WINAPI
OGetProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileStringW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OGetServiceDisplayNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpServiceName,
	LPWSTR                 lpDisplayName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceDisplayNameW");
	return 0;
}

BOOL
WINAPI
OGetServiceKeyNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpDisplayName,
	LPWSTR                 lpServiceName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceKeyNameW");
	return 0;
}
#endif

DWORD
WINAPI
OGetShortPathNameW(
	LPCWSTR lpszLongPath,
	LPWSTR  lpszShortPath,
	DWORD    cchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetShortPathNameW");
	return 0;
}

VOID
WINAPI
OGetStartupInfoW(
	LPSTARTUPINFOW lpStartupInfo
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStartupInfoW");
	return;
}

BOOL
WINAPI
OGetStringTypeExW(
	LCID     Locale,
	DWORD    dwInfoType,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWORD   lpCharType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStringTypeExW");
	return 0;
}

UINT
WINAPI
OGetSystemDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetSystemDirectoryW");
	return 0;
}

int
WINAPI
OGetTimeFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpTime,
	LPCWSTR lpFormat,
	LPWSTR  lpTimeStr,
	int      cchTime)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTimeFormatW");
	return 0;
}

INT
APIENTRY
OGetTypeByNameW (
	IN     LPWSTR         lpServiceName,
	IN OUT LPGUID          lpServiceType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTypeByNameW");
	return 0;
}

BOOL
WINAPI
OGetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength,
	LPDWORD lpnLengthNeeded)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetUserObjectInformationW");
	return 0;
}

UINT
WINAPI
OGetWindowsDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetWindowsDirectoryW");
	return 0;
}

ATOM
WINAPI
OGlobalFindAtomW(
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GlobalFindAtomW");
	return 0;
}

RPC_STATUS RPC_ENTRY
OI_RpcServerUnregisterEndpointW (
	IN unsigned short * Protseq,
	IN unsigned short * Endpoint
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - I_RpcServerUnregisterEndpointW");
	return 0;
}

HIMAGELIST
WINAPI
OImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImageList_LoadImageW");
	return 0;
}

WINAPI
OImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmConfigureIMEW");
	return 0;
}

WINAPI
OImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEnumRegisterWordW");
	return 0;
}

WINAPI
OImmEscapeW(HKL, HIMC, UINT, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEscapeW");
	return 0;
}

WINAPI
OImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListW");
	return 0;
}

WINAPI
OImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListCountW");
	return 0;
}

WINAPI
OImmGetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionFontW");
	return 0;
}

WINAPI
OImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionStringW");
	return 0;
}

WINAPI
OImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetConversionListW");
	return 0;
}

WINAPI
OImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetDescriptionW");
	return 0;
}

WINAPI
OImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetGuideLineW");
	return 0;
}

WINAPI
OImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetIMEFileNameW");
	return 0;
}

WINAPI
OImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetRegisterWordStyleW");
	return 0;
}

WINAPI
OImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmInstallIMEW");
	return 0;
}

WINAPI
OImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmIsUIMessageW");
	return 0;
}

WINAPI
OImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmRegisterWordW");
	return 0;
}

WINAPI
OImmSetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionFontW");
	return 0;
}

WINAPI
OImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionStringW");
	return 0;
}

WINAPI
OImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmUnregisterWordW");
	return 0;
}

BOOL
APIENTRY
OInitiateSystemShutdownW(
	LPWSTR lpMachineName,
	LPWSTR lpMessage,
	DWORD dwTimeout,
	BOOL bForceAppsClosed,
	BOOL bRebootAfterShutdown
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InitiateSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OInsertMenuItemW(
	HMENU,
	UINT,
	BOOL,
	LPCMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InsertMenuItemW");
	return 0;
}

BOOL
WINAPI
OIsCharLowerW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharLowerW");
	return 0;
}

BOOL
WINAPI
OIsCharUpperW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharUpperW");
	return 0;
}

MMRESULT
WINAPI
OjoyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - joyGetDevCapsW");
	return 0;
}

HCURSOR
WINAPI
OLoadCursorFromFileW(
	LPCWSTR    lpFileName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadCursorFromFileW");
	return 0;
}

HKL
WINAPI
OLoadKeyboardLayoutW(
	LPCWSTR pwszKLID,
	UINT Flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadKeyboardLayoutW");
	return 0;
}

BOOL
WINAPI
OLogonUserW (
	LPWSTR lpszUsername,
	LPWSTR lpszDomain,
	LPWSTR lpszPassword,
	DWORD dwLogonType,
	DWORD dwLogonProvider,
	PHANDLE phToken
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LogonUserW");
	return 0;
}

INT
APIENTRY
OLZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LZOpenFileW");
	return 0;
}

UINT
WINAPI
OMapVirtualKeyExW(
	UINT uCode,
	UINT uMapType,
	HKL dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MapVirtualKeyExW");
	return 0;
}

HRESULT
WINAPI
OMIMEAssociationDialogW(HWND hwndParent,
									   DWORD dwInFlags,
									   PCWSTR pcszFile,
									   PCWSTR pcszMIMEContentType,
									   PWSTR pszAppBuf,
									   UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MIMEAssociationDialogW");
	return 0;
}

DWORD
APIENTRY
OMultinetGetConnectionPerformanceW(
		LPNETRESOURCEW lpNetResource,
		LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MultinetGetConnectionPerformanceW");
	return 0;
}

BOOL
WINAPI
OObjectCloseAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	BOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectCloseAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectOpenAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	DWORD GrantedAccess,
	PPRIVILEGE_SET Privileges,
	BOOL ObjectCreation,
	BOOL AccessGranted,
	LPBOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectOpenAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectPrivilegeAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectPrivilegeAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OOemToCharBuffW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OemToCharBuffW");
	return 0;
}

HANDLE
WINAPI
OOpenBackupEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenBackupEventLogW");
	return 0;
}

HDESK
WINAPI
OOpenDesktopW(
	LPWSTR lpszDesktop,
	DWORD dwFlags,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenDesktopW");
	return 0;
}

HANDLE
WINAPI
OOpenEventW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventW");
	return 0;
}

HANDLE
WINAPI
OOpenEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventLogW");
	return 0;
}

HANDLE
WINAPI
OOpenFileMappingW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenFileMappingW");
	return 0;
}

HANDLE
WINAPI
OOpenMutexW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenMutexW");
	return 0;
}

BOOL
WINAPI
OOpenPrinterW(
	LPWSTR    pPrinterName,
	LPHANDLE phPrinter,
	LPPRINTER_DEFAULTSW pDefault
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenSCManagerW(
	LPCWSTR lpMachineName,
	LPCWSTR lpDatabaseName,
	DWORD   dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSCManagerW");
	return 0;
}
#endif

HANDLE
WINAPI
OOpenSemaphoreW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSemaphoreW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenServiceW(
	SC_HANDLE   hSCManager,
	LPCWSTR    lpServiceName,
	DWORD       dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenServiceW");
	return 0;
}
#endif

HWINSTA
WINAPI
OOpenWindowStationW(
	LPWSTR lpszWinSta,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenWindowStationW");
	return 0;
}

APIENTRY OPageSetupDlgW( LPPAGESETUPDLGW )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PageSetupDlgW");
	return 0;
}

BOOL
WINAPI
OPeekConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PeekConsoleInputW");
	return 0;
}

BOOL
WINAPI
OPolyTextOutW(HDC, CONST POLYTEXTW *, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PolyTextOutW");
	return 0;
}

APIENTRY
OPrintDlgW(LPPRINTDLGW lppd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrintDlgW");
	return 0;
}

DWORD
WINAPI
OPrinterMessageBoxW(
	HANDLE  hPrinter,
	DWORD   Error,
	HWND    hWnd,
	LPWSTR   pText,
	LPWSTR   pCaption,
	DWORD   dwType
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrinterMessageBoxW");
	return 0;
}

BOOL
WINAPI
OPrivilegedServiceAuditAlarmW (
	LPCWSTR SubsystemName,
	LPCWSTR ServiceName,
	HANDLE ClientToken,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrivilegedServiceAuditAlarmW");
	return 0;
}

int
WINAPI
OPropertySheetW(
	LPCPROPSHEETHEADERW lpcpsh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PropertySheetW");
	return 0;
}

DWORD
WINAPI
OQueryDosDeviceW(
	LPCWSTR lpDeviceName,
	LPWSTR lpTargetPath,
	DWORD ucchMax
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryDosDeviceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OQueryServiceConfigW(
	SC_HANDLE               hService,
	LPQUERY_SERVICE_CONFIGW lpServiceConfig,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceConfigW");
	return 0;
}

BOOL
WINAPI
OQueryServiceLockStatusW(
	SC_HANDLE                       hSCManager,
	LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
	DWORD                           cbBufSize,
	LPDWORD                         pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceLockStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OReadConsoleW(
	HANDLE hConsoleInput,
	LPVOID lpBuffer,
	DWORD nNumberOfCharsToRead,
	LPDWORD lpNumberOfCharsRead,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleW");
	return 0;
}

BOOL
WINAPI
OReadConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleInputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputW(
	HANDLE hConsoleOutput,
	PCHAR_INFO lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpReadRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPWSTR lpCharacter,
	DWORD nLength,
	COORD dwReadCoord,
	LPDWORD lpNumberOfCharsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OReadEventLogW (
	 HANDLE     hEventLog,
	 DWORD      dwReadFlags,
	 DWORD      dwRecordOffset,
	 LPVOID     lpBuffer,
	 DWORD      nNumberOfBytesToRead,
	 DWORD      *pnBytesRead,
	 DWORD      *pnMinNumberOfBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadEventLogW");
	return 0;
}

LONG
APIENTRY
ORegConnectRegistryW (
	LPWSTR lpMachineName,
	HKEY hKey,
	PHKEY phkResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegConnectRegistryW");
	return 0;
}

HANDLE
WINAPI
ORegisterEventSourceW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterEventSourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SERVICE_STATUS_HANDLE
WINAPI
ORegisterServiceCtrlHandlerW(
	LPCWSTR             lpServiceName,
	LPHANDLER_FUNCTION   lpHandlerProc
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterServiceCtrlHandlerW");
	return 0;
}
#endif

LONG
APIENTRY
ORegLoadKeyW (
	HKEY    hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegLoadKeyW");
	return 0;
}

LONG
APIENTRY
ORegQueryMultipleValuesW (
	HKEY hKey,
	PVALENTW val_list,
	DWORD num_vals,
	LPWSTR lpValueBuf,
	LPDWORD ldwTotsize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegQueryMultipleValuesW");
	return 0;
}

LONG
APIENTRY
ORegReplaceKeyW (
	HKEY     hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpNewFile,
	LPCWSTR  lpOldFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegReplaceKeyW");
	return 0;
}

LONG
APIENTRY
ORegRestoreKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	DWORD   dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegRestoreKeyW");
	return 0;
}

LONG
APIENTRY
ORegSaveKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegSaveKeyW");
	return 0;
}

LONG
APIENTRY
ORegUnLoadKeyW (
	HKEY    hKey,
	LPCWSTR lpSubKey
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegUnLoadKeyW");
	return 0;
}

BOOL
WINAPI
ORemoveDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveDirectoryW");
	return 0;
}

BOOL
WINAPI
ORemoveFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveFontResourceW");
	return 0;
}

APIENTRY
OReplaceTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReplaceTextW");
	return 0;
}

BOOL
WINAPI
OReportEventW (
	 HANDLE     hEventLog,
	 WORD       wType,
	 WORD       wCategory,
	 DWORD      dwEventID,
	 PSID       lpUserSid,
	 WORD       wNumStrings,
	 DWORD      dwDataSize,
	 LPCWSTR   *lpStrings,
	 LPVOID     lpRawData
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReportEventW");
	return 0;
}

HDC
WINAPI
OResetDCW(
	HDC hdc,
	CONST DEVMODEW *lpInitData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetDCW");
	return 0;
}

BOOL
WINAPI
OResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetPrinterW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingFromStringBindingW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingFromStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingInqAuthClientW (
	IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
	OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingInqAuthClientW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingToStringBindingW (
	IN RPC_BINDING_HANDLE Binding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingToStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcEpRegisterNoReplaceW (
	IN RPC_IF_HANDLE IfSpec,
	IN RPC_BINDING_VECTOR * BindingVector,
	IN UUID_VECTOR * UuidVector OPTIONAL,
	IN unsigned short  * Annotation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcEpRegisterNoReplaceW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtEpEltInqNextW (
	IN RPC_EP_INQ_HANDLE InquiryContext,
	OUT RPC_IF_ID __RPC_FAR * IfId,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
	OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtEpEltInqNextW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtInqServerPrincNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtInqServerPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkInqProtseqsW (
	OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkInqProtseqsW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkIsProtseqValidW (
	IN unsigned short __RPC_FAR * Protseq
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkIsProtseqValidW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNsBindingInqEntryNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long EntryNameSyntax,
	OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNsBindingInqEntryNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcProtseqVectorFreeW (
	IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcProtseqVectorFreeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerInqDefaultPrincNameW (
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerInqDefaultPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqEpW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN unsigned short __RPC_FAR * Endpoint,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqEpW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqIfW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN RPC_IF_HANDLE IfSpec,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqIfW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingComposeW (
	IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
	IN unsigned short __RPC_FAR * Protseq OPTIONAL,
	IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
	IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
	IN unsigned short __RPC_FAR * Options OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingComposeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingParseW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingParseW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringFreeW (
	IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringFreeW");
	return 0;
}

BOOL
WINAPI
OScrollConsoleScreenBufferW(
	HANDLE hConsoleOutput,
	CONST SMALL_RECT *lpScrollRectangle,
	CONST SMALL_RECT *lpClipRectangle,
	COORD dwDestinationOrigin,
	CONST CHAR_INFO *lpFill
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ScrollConsoleScreenBufferW");
	return 0;
}

DWORD
WINAPI
OSearchPathW(
	LPCWSTR lpPath,
	LPCWSTR lpFileName,
	LPCWSTR lpExtension,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SearchPathW");
	return 0;
}

BOOL
WINAPI
OSendMessageCallbackW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	SENDASYNCPROC lpResultCallBack,
	DWORD dwData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageCallbackW");
	return 0;
}

LRESULT
WINAPI
OSendMessageTimeoutW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	UINT fuFlags,
	UINT uTimeout,
	LPDWORD lpdwResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageTimeoutW");
	return 0;
}

BOOL
WINAPI
OSetComputerNameW (
	LPCWSTR lpComputerName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetComputerNameW");
	return 0;
}

BOOL
WINAPI
OSetConsoleTitleW(
	LPCWSTR lpConsoleTitle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetConsoleTitleW");
	return 0;
}

BOOL
WINAPI
OSetCurrentDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetCurrentDirectoryW");
	return 0;
}

BOOL
WINAPI
OSetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	DWORD dwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OSetEnvironmentVariableW(
	LPCWSTR lpName,
	LPCWSTR lpValue
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetEnvironmentVariableW");
	return 0;
}

BOOL
WINAPI
OSetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFileSecurityW");
	return 0;
}

BOOL
WINAPI
OSetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFormW");
	return 0;
}

WINAPI
OSetICMProfileW(HDC,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetICMProfileW");
	return 0;
}

BOOL
WINAPI
OSetJobW(
	HANDLE  hPrinter,
	DWORD   JobId,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetJobW");
	return 0;
}

BOOL
WINAPI
OSetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterW");
	return 0;
}

DWORD
WINAPI
OSetPrinterDataW(
	HANDLE  hPrinter,
	LPWSTR   pValueName,
	DWORD   Type,
	LPBYTE  pData,
	DWORD   cbData
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OSetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetUserObjectInformationW");
	return 0;
}

BOOL
WINAPI
OSetVolumeLabelW(
	LPCWSTR lpRootPathName,
	LPCWSTR lpVolumeName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetVolumeLabelW");
	return 0;
}

HHOOK
WINAPI
OSetWindowsHookW(
	int nFilterType,
	HOOKPROC pfnFilterProc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetWindowsHookW");
	return 0;
}

LPITEMIDLIST
WINAPI
OSHBrowseForFolderW(
	LPBROWSEINFO lpbi)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHBrowseForFolderW");
	return 0;
}

BOOL
WINAPI
OShell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - Shell_NotifyIconW");
	return 0;
}

INT
APIENTRY
OShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellAboutW");
	return 0;
}

HINSTANCE
APIENTRY
OShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteW");
	return 0;
}

BOOL
WINAPI
OShellExecuteExW(
	LPSHELLEXECUTEINFOW lpExecInfo)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteExW");
	return 0;
}


int
WINAPI
OSHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHFileOperationW");
	return 0;
}

DWORD
WINAPI
OSHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetFileInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
							 BOOL FAR * pfMustCopy, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetNewLinkInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetPathFromIDListW(
	LPCITEMIDLIST pidl,
	LPTSTR pszPath)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetPathFromIDListW");
	return 0;
}

BOOL
WINAPI
OsndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - sndPlaySoundW");
	return 0;
}

DWORD
WINAPI
OStartDocPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pDocInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartDocPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OStartServiceW(
	SC_HANDLE            hService,
	DWORD                dwNumServiceArgs,
	LPCWSTR             *lpServiceArgVectors
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceW");
	return 0;
}

BOOL
WINAPI
OStartServiceCtrlDispatcherW(
	LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceCtrlDispatcherW");
	return 0;
}
#endif

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OTextOutW(HDC, int, int, LPCWSTR, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TextOutW");
	return 0;
}
*/

HRESULT
WINAPI
OTranslateURLW(PCWSTR pcszURL,
										 DWORD dwInFlags,
										 PWSTR *ppszTranslatedURL)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TranslateURLW");
	return 0;
}

WINAPI
OUpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UpdateICMRegKeyW");
	return 0;
}

HRESULT
WINAPI
OURLAssociationDialogW(HWND hwndParent,
												 DWORD dwInFlags,
												 PCWSTR pcszFile,
												 PCWSTR pcszURL,
												 PWSTR pszAppBuf,
												 UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - URLAssociationDialogW");
	return 0;
}

/* client/server */
RPC_STATUS RPC_ENTRY
OUuidFromStringW (
	IN unsigned short __RPC_FAR * StringUuid,
	OUT UUID __RPC_FAR * Uuid
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UuidFromStringW");
	return 0;
}

DWORD
APIENTRY
OVerFindFileW(
		DWORD uFlags,
		LPWSTR szFileName,
		LPWSTR szWinDir,
		LPWSTR szAppDir,
		LPWSTR szCurDir,
		PUINT lpuCurDirLen,
		LPWSTR szDestDir,
		PUINT lpuDestDirLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerFindFileW");
	return 0;
}

DWORD
APIENTRY
OVerInstallFileW(
		DWORD uFlags,
		LPWSTR szSrcFileName,
		LPWSTR szDestFileName,
		LPWSTR szSrcDir,
		LPWSTR szDestDir,
		LPWSTR szCurDir,
		LPWSTR szTmpFile,
		PUINT lpuTmpFileLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerInstallFileW");
	return 0;
}

DWORD
APIENTRY
OVerLanguageNameW(
		DWORD wLang,
		LPWSTR szLang,
		DWORD nSize
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerLanguageNameW");
	return 0;
}

BOOL
WINAPI
OVerQueryValueW(
	const LPVOID pBlock,
	LPWSTR lpSubBlock,
	LPVOID *lplpBuffer,
	PUINT puLerr)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerQueryValueW");
	return 0;
}

WINAPI
OVkKeyScanExW(
	WCHAR  ch,
	HKL   dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VkKeyScanExW");
	return 0;
}

BOOL
WINAPI
OWaitNamedPipeW(
	LPCWSTR lpNamedPipeName,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WaitNamedPipeW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetErrorTextW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetErrorTextW");
	return 0;
}

BOOL
WINAPI
OwglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontBitmapsW");
	return 0;
}

BOOL
WINAPI
OwglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
										   FLOAT, int, LPGLYPHMETRICSFLOAT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontOutlinesW");
	return 0;
}

void
WINAPI
OWinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WinExecErrorW");
	return;
}

DWORD
APIENTRY
OWNetAddConnectionW(
	 LPCWSTR   lpRemoteName,
	 LPCWSTR   lpPassword,
	 LPCWSTR   lpLocalName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection2W(
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection3W(
	 HWND           hwndOwner,
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection3W");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnectionW(
	 LPCWSTR lpName,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnection2W(
	 LPCWSTR lpName,
	 DWORD    dwFlags,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetConnectionDialog1W(
	LPCONNECTDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetConnectionDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetDisconnectDialog1W(
	LPDISCDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetDisconnectDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetEnumResourceW(
	 HANDLE  hEnum,
	 LPDWORD lpcCount,
	 LPVOID  lpBuffer,
	 LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetEnumResourceW");
	return 0;
}

DWORD
APIENTRY
OWNetGetConnectionW(
	 LPCWSTR lpLocalName,
	 LPWSTR  lpRemoteName,
	 LPDWORD  lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetGetLastErrorW(
	 LPDWORD    lpError,
	 LPWSTR    lpErrorBuf,
	 DWORD      nErrorBufSize,
	 LPWSTR    lpNameBuf,
	 DWORD      nNameBufSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetLastErrorW");
	return 0;
}

DWORD
APIENTRY
OWNetGetNetworkInformationW(
	LPCWSTR          lpProvider,
	LPNETINFOSTRUCT   lpNetInfoStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetNetworkInformationW");
	return 0;
}

DWORD
APIENTRY
OWNetGetProviderNameW(
	DWORD   dwNetType,
	LPWSTR lpProviderName,
	LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetProviderNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUniversalNameW(
	 LPCWSTR lpLocalPath,
	 DWORD    dwInfoLevel,
	 LPVOID   lpBuffer,
	 LPDWORD  lpBufferSize
	 )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUniversalNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUserW(
	 LPCWSTR  lpName,
	 LPWSTR   lpUserName,
	 LPDWORD   lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUserW");
	return 0;
}

DWORD
APIENTRY
OWNetOpenEnumW(
	 DWORD          dwScope,
	 DWORD          dwType,
	 DWORD          dwUsage,
	 LPNETRESOURCEW lpNetResource,
	 LPHANDLE       lphEnum
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetOpenEnumW");
	return 0;
}

DWORD
APIENTRY
OWNetSetConnectionW(
	LPCWSTR    lpName,
	DWORD       dwProperties,
	LPVOID      pvValues
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetSetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetUseConnectionW(
	HWND            hwndOwner,
	LPNETRESOURCEW  lpNetResource,
	LPCWSTR        lpUserID,
	LPCWSTR        lpPassword,
	DWORD           dwFlags,
	LPWSTR         lpAccessName,
	LPDWORD         lpBufferSize,
	LPDWORD         lpResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetUseConnectionW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleW(
	HANDLE hConsoleOutput,
	CONST VOID *lpBuffer,
	DWORD nNumberOfCharsToWrite,
	LPDWORD lpNumberOfCharsWritten,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleInputW(
	HANDLE hConsoleInput,
	CONST INPUT_RECORD *lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleInputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputW(
	HANDLE hConsoleOutput,
	CONST CHAR_INFO *lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpWriteRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPCWSTR lpCharacter,
	DWORD nLength,
	COORD dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileStructW");
	return 0;
}

BOOL
WINAPI
OWriteProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWriteProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileStringW");
	return 0;
}

int
WINAPI
OwvsprintfW(
	LPWSTR,
	LPCWSTR,
	va_list arglist)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wvsprintfW");
	return 0;
}

DWORD
WINAPI
ODdeQueryStringW(
	DWORD idInst,
	HSZ hsz,
	LPWSTR psz,
	DWORD cchMax,
	int iCodePage)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DdeQueryStringW");
	return 0;
}

int WINAPI
OGetClipboardFormatNameW(
	UINT format,
	LPWSTR pwsz,
	int cchMaxCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetClipboardFormatNameW");
	return 0;
}

int
WINAPI
OGetKeyNameTextW(
	LONG lParam,
	LPWSTR lpString,
	int nSize)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyNameTextW");
	return 0;
}

int
WINAPI
OGetMenuStringW(
	HMENU hMenu,
	UINT uIDItem,
	LPWSTR lpString,
	int nMaxCount,
	UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

int
WINAPI
OGetTextFaceW(
	HDC    hdc,
	int    cch,
	LPWSTR lpFaceName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

#endif    //ifdef DEBUG

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\dispatch.cpp ===
/*

    File: Dispatch.cpp

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
        Dispatch helpers.  stolen from HTMED tree

*/

#include "stdafx.h"

#include "resource.h"
#include "dispatch.h"

//#include "viewhdrs.h"

#define RETURN return
#define SetLastError(x,y) SetLastError(x)

HRESULT
CallDispatchMethod(
        IDispatch * pDisp,
        DISPID dispid,
        VARIANT * pvarFirst,
        char * pstrSig,
        va_list val)
{
    HRESULT     hr;
    int         c;
    int         i;
    VARIANT *   pvar;
    VARIANT *   pvarOut         = NULL;
    VARIANT     avar[10];
    VARIANT     varOut;
    void *      pvOut = NULL;
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr;

    _ASSERTE(pDisp);

    VariantInit(&varOut);

    if (pstrSig)
    {
        c = strlen(pstrSig);
        //_ASSERTE(c > 0);
        //_ASSERTE(c <= DIM(avar));

        if (pstrSig[c - 1] & VTS_RETURN_FLAG)
        {
            pvarOut = &varOut;
            c--;
        }

        for (i = 0, pvar = avar + c - 1; i < c; i++, pvar--)
        {
            pvar->vt = pstrSig[i];
            switch (pstrSig[i])
            {
            case VT_I2:
                pvar->iVal = va_arg(val, short);
                break;

            case VT_I4:
                pvar->lVal = va_arg(val, long);
                break;

            case VT_BSTR:
                pvar->bstrVal = va_arg(val, BSTR);
                break;

            case VT_DISPATCH:
                pvar->pdispVal = va_arg(val, IDispatch *);
                break;

            case VT_UNKNOWN:
                pvar->punkVal = va_arg(val, IUnknown *);
                break;

            case VT_BOOL:
                pvar->boolVal = va_arg(val, VARIANT_BOOL);
                break;

            case VT_BSTR | VTS_BYREF_FLAG:
            case VT_DISPATCH | VTS_BYREF_FLAG:
            case VT_UNKNOWN | VTS_BYREF_FLAG:
                pvar->vt = (VARTYPE)((pstrSig[i] & (VTS_BYREF_FLAG - 1)) | VT_BYREF);
                pvar->ppdispVal = va_arg(val, IDispatch **);

                // Passing an uninitialized BSTR or object will crash when the callee
                // frees the existing value as it's supposed to.
                // This has been a common source of hard-to-find bugs, but
                // this _ASSERTE can be removed if we need to pass an in/out string.
                _ASSERTE(*pvar->ppdispVal == NULL);
                break;

            case VT_I2 | VTS_BYREF_FLAG:
            case VT_I4 | VTS_BYREF_FLAG:
            case VT_BOOL | VTS_BYREF_FLAG:
            case VT_VARIANT | VTS_BYREF_FLAG:
                pvar->vt = (VARTYPE)((pstrSig[i] & (VTS_BYREF_FLAG - 1)) | VT_BYREF);
                pvar->ppdispVal = va_arg(val, IDispatch **);
                break;

            default:
                _ASSERTE(FALSE && "Unsupported variant type");
                break;
            }
        }

        if (pvarOut)
        {
            pvOut = va_arg(val, void *);
        }
    }
    else
    {
        c = 0;
    }

    if (pvarFirst)
    {
    //  _ASSERTE(c >= 0);
    //  _ASSERTE(c < DIM(avar));
        avar[c++] = *pvarFirst;
    }

    dp.rgvarg = avar;
    dp.cArgs = c;
    dp.rgdispidNamedArgs = NULL;
    dp.cNamedArgs = 0;

    memset(&ei, 0, sizeof (ei));

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_METHOD,
            &dp,
            pvarOut,
            &ei,
            &uArgErr);
    if (hr)
    {
        SetLastError(hr, &ei);
        goto Error;
    }

    //  If we're returning a value, coerce it to the correct
    //    type

    if (pvarOut)
    {
#pragma warning(disable: 4310) // cast truncates constant value
        hr = VariantChangeTypeEx(
                &varOut,
                &varOut,
                LOCALE_SYSTEM_DEFAULT,
                0,
                (VARTYPE)(pstrSig[c] & (char) ~VTS_RETURN_FLAG));
#pragma warning(default: 4310) // cast truncates constant value
        if (hr)
            goto Error;

#pragma warning(disable: 4310) // cast truncates constant value
        switch (pstrSig[c] & (char) ~VTS_RETURN_FLAG)
#pragma warning(default: 4310) // cast truncates constant value
        {
        case VT_I2:
            * (short *) pvOut = varOut.iVal;
            break;

        case VT_I4:
            * (long *) pvOut = varOut.lVal;
            break;

        case VT_BSTR:
            * (BSTR *) pvOut = varOut.bstrVal;
            break;

        case VT_DISPATCH:
            * (IDispatch **) pvOut = varOut.pdispVal;
            break;

        case VT_UNKNOWN:
            * (IUnknown **) pvOut = varOut.punkVal;
            break;

        case VT_BOOL:
            * (VARIANT_BOOL *) pvOut = varOut.boolVal;
            break;

        default:
            _ASSERTE(FALSE && "Unsupported type");
            break;
        }

        varOut.vt = VT_EMPTY;
    }

Error:
    VariantClear(&varOut);

    RETURN(hr);
}


HRESULT __cdecl
CallDispatchMethod(IDispatch * pDisp, DISPID dispid, char * pstrSig, ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, pstrSig);

    hr = CallDispatchMethod(pDisp, dispid, NULL, pstrSig, val);

    va_end(val);

    return hr;
}


HRESULT
CallDispatchMethod(
        IDispatch * pDisp,
        WCHAR * pstrMethod,
        VARIANT * pvarFirst,
        char * pstrSig,
        va_list val)
{
    HRESULT     hr;
    DISPID      dispid;

    //  NOTE that depending on the dispatch implementation, this
    //    method call can fail with more than one error code
    //    (notably DISP_E_MEMBERNOTFOUND and TYPE_E_ELEMENTNOTFOUND,
    //    including others).  Since we want to reliably detect a
    //    missing method, we map all errors to DISP_E_MEMBERNOTFOUND.

    hr = pDisp->GetIDsOfNames(
            IID_NULL,
            &pstrMethod,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (hr)
    {
#if DBG == 1
        switch (hr)
        {
        case DISP_E_MEMBERNOTFOUND:
        case DISP_E_UNKNOWNNAME:
        case TYPE_E_ELEMENTNOTFOUND:
        case E_NOTIMPL:
        case RPC_E_SERVER_DIED:
            break;

        default:
            _ASSERTE(FALSE && "Unexpected error code from GetIDsOfNames.");
            break;
        }
#endif

        hr = DISP_E_MEMBERNOTFOUND;
        goto Error;
    }

    hr = CallDispatchMethod(pDisp, dispid, pvarFirst, pstrSig, val);
    if (hr)
        goto Error;

Error:
    return hr;
}


HRESULT __cdecl
CallDispatchMethod(
        IDispatch * pDisp,
        WCHAR * pstrMethod,
        char * pstrSig,
        ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, pstrSig);

    hr = CallDispatchMethod(pDisp, pstrMethod, NULL, pstrSig, val);

    va_end(val);

    return hr;
}


HRESULT __cdecl
CallDispatchMethod(
        IDispatch * pDisp,
        WCHAR * pstrMethod,
        VARIANT * pvarFirst,
        char * pstrSig,
        ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, pstrSig);

    hr = CallDispatchMethod(pDisp, pstrMethod, pvarFirst, pstrSig, val);

    va_end(val);

    return hr;
}


HRESULT
GetDispatchProperty(
        IDispatch * pDisp,
        WCHAR * pstrProperty,
        VARENUM vt,
        void * pv)
{
    HRESULT     hr;
    DISPID      dispid;

    hr = pDisp->GetIDsOfNames(
            IID_NULL,
            &pstrProperty,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (hr)
    {
#if DBG == 1
        switch (hr)
        {
        case DISP_E_MEMBERNOTFOUND:
        case DISP_E_UNKNOWNNAME:
        case TYPE_E_ELEMENTNOTFOUND:
        case E_NOTIMPL:
            break;

        default:
            _ASSERTE(FALSE && "Unexpected error code from GetIDsOfNames.");
            break;
        }
#endif

        RETURN(DISP_E_MEMBERNOTFOUND);
    }

    return GetDispatchProperty(pDisp, dispid, vt, pv);
}


HRESULT
GetDispatchProperty(
        IDispatch * pDisp,
        DISPID dispidProperty,
        VARENUM vt,
        void * pv)
{
    HRESULT         hr;
    VARIANT         var;
    DISPPARAMS      dp = { NULL, NULL, 0, 0 };
    EXCEPINFO       ei;
    UINT            uArgErr;

#if DBG == 1
    switch (vt)
    {
    case VT_I4:
    case VT_DISPATCH:
    case VT_UNKNOWN:
    case VT_BSTR:
        break;

    }
#endif

    VariantInit(&var);

    hr = pDisp->Invoke(
            dispidProperty,
            IID_NULL,
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_PROPERTYGET|DISPATCH_METHOD,
            &dp,
            &var,
            &ei,
            &uArgErr);
    if (hr)
        goto Error;

    if (vt != VT_VARIANT)
    {
        hr = VariantChangeTypeEx(
                &var,
                &var,
                LOCALE_SYSTEM_DEFAULT,
                0,
                (VARTYPE)vt);
        if (hr)
            goto Error;
    }

    switch (vt)
    {
    case VT_I2:
        * (short *) pv = var.iVal;
        break;

    case VT_I4:
        * (int *) pv = var.lVal;
        break;

    case VT_DISPATCH:
        * (IDispatch **) pv = var.pdispVal;
        break;

    case VT_UNKNOWN:
        * (IUnknown **) pv = var.punkVal;
        break;

    case VT_BSTR:
        * (BSTR *) pv = var.bstrVal;
        break;

    case VT_BOOL:
        * (VARIANT_BOOL *) pv = var.boolVal;
        break;
    case VT_VARIANT:
        VariantCopy( (VARIANT *) pv, &var);
        break;
    default:
        _ASSERTE(FALSE && "Unsupported type");
        break;
    }

Error:
    RETURN(hr);
}


HRESULT
PutDispatchProperty(
        IDispatch * pDisp,
        DISPID dispidProperty,
        VARENUM vt,
        va_list val)
{
    VARIANT         var;
    DISPPARAMS      dp;
    EXCEPINFO       ei;
    UINT            uArgErr;
    DISPID          dispidPropertyPut   = DISPID_PROPERTYPUT;

    var.vt = (VARTYPE)vt;
    switch (vt)
    {
    case VT_I2:
        var.iVal = va_arg(val, short);
        break;

    case VT_I4:
        var.lVal = va_arg(val, int);
        break;

    case VT_DISPATCH:
        var.pdispVal = va_arg(val, IDispatch *);
        break;

    case VT_UNKNOWN:
        var.punkVal = va_arg(val, IUnknown *);
        break;

    case VT_BSTR:
        var.bstrVal = va_arg(val, BSTR);
        break;

    case VT_BOOL:
        var.boolVal = va_arg(val, VARIANT_BOOL);
        break;
    case VT_VARIANT:
        VariantCopy(&var, &(va_arg(val, VARIANT)));
        break;
    default:
        _ASSERTE(FALSE && "Unsupported type");
        break;
    }

    dp.rgvarg = &var;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    dp.rgdispidNamedArgs = &dispidPropertyPut;

    RETURN(pDisp->Invoke(
            dispidProperty,
            IID_NULL,
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            &ei,
            &uArgErr));
}


HRESULT
__cdecl
PutDispatchProperty(
        IDispatch * pDisp,
        DISPID dispidProperty,
        VARENUM vt,
        ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, vt);

    hr = PutDispatchProperty(pDisp, dispidProperty, vt, val);

    va_end(val);

    RETURN(hr);
}


HRESULT
__cdecl
PutDispatchProperty(
        IDispatch * pDisp,
        WCHAR * pstrProperty,
        VARENUM vt,
        ...)
{
    HRESULT     hr;
    DISPID      dispid;
    va_list     val;

    hr = pDisp->GetIDsOfNames(
            IID_NULL,
            &pstrProperty,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (hr)
    {
#if DBG == 1
        switch (hr)
        {
        case DISP_E_MEMBERNOTFOUND:
        case DISP_E_UNKNOWNNAME:
        case TYPE_E_ELEMENTNOTFOUND:
        case E_NOTIMPL:
            break;

        default:
            _ASSERTE(FALSE && "Unexpected error code from GetIDsOfNames.");
            break;
        }
#endif

        RETURN(DISP_E_MEMBERNOTFOUND);
    }

    va_start(val, vt);

    hr = PutDispatchProperty(pDisp, dispid, vt, val);

    va_end(val);

    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\dispatch.h ===
/*

    File: Dispatch.h

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
        Dispatch helpers.

*/

//  Defines

#define VTS_I2              "\x02"
#define VTS_I4              "\x03"
#define VTS_BSTR            "\x08"
#define VTS_DISPATCH        "\x09"
#define VTS_BOOL            "\x0b"
#define VTS_VARIANT         "\x0c"
#define VTS_UNKNOWN         "\x0d"

#define VTS_I2_BYREF        "\x42"
#define VTS_I4_BYREF        "\x43"
#define VTS_BSTR_BYREF      "\x48"
#define VTS_DISPATCH_BYREF  "\x49"
#define VTS_BOOL_BYREF      "\x4b"
#define VTS_VARIANT_BYREF   "\x4c"
#define VTS_UNKNOWN_BYREF   "\x4d"

#define VTS_I2_RETURN       "\x82"
#define VTS_I4_RETURN       "\x83"
#define VTS_BSTR_RETURN     "\x88"
#define VTS_DISPATCH_RETURN "\x89"
#define VTS_BOOL_RETURN     "\x8b"
#define VTS_UNKNOWN_RETURN  "\x8d"

#define VTS_BYREF_FLAG      0x40
#define VTS_RETURN_FLAG     0x80


// Functions

HRESULT         CallDispatchMethod(
                        IDispatch * pDisp,
                        DISPID dispid,
                        VARIANT * pvarFirst,
                        char * pstrSig,
                        va_list val);

HRESULT __cdecl CallDispatchMethod(
                        IDispatch * pDisp,
                        DISPID dispid,
                        char * pstrSig,
                        ...);

HRESULT         CallDispatchMethod(
                        IDispatch * pDisp,
                        WCHAR * pstrMethod,
                        VARIANT * pvarFirst,
                        char * pstrSig,
                        va_list val);

HRESULT __cdecl CallDispatchMethod(
                        IDispatch * pDisp,
                        WCHAR * pstrMethod,
                        char * pstrSig,
                        ...);

HRESULT __cdecl CallDispatchMethod(
                        IDispatch * pDisp,
                        WCHAR * pstrMethod,
                        VARIANT * pvarFirst,
                        char * pstrSig,
                        ...);

HRESULT         GetDispatchProperty(
                        IDispatch * pDisp,
                        WCHAR * pstrProperty,
                        VARENUM vt,
                        void * pv);

HRESULT         GetDispatchProperty(
                        IDispatch * pDisp,
                        DISPID dispidProperty,
                        VARENUM vt,
                        void * pv);

HRESULT __cdecl PutDispatchProperty(
                        IDispatch * pDisp,
                        WCHAR * pstrProperty,
                        VARENUM vt,
                        ...);

HRESULT __cdecl PutDispatchProperty(
                        IDispatch * pDisp,
                        DISPID dispidProperty,
                        VARENUM vt,
                        ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\document.cpp ===
// Document.cpp : Implementation of CTriEditDocument
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"

#include "triedit.h"
#include "Document.h"
#include "util.h"

#ifdef IE5_SPACING
#include "dispatch.h"
#include <mshtmdid.h>
#include <mshtmcid.h>
#endif //IE5_SPACING

/////////////////////////////////////////////////////////////////////////////
// CTriEditDocument

CTriEditDocument::CTriEditDocument()
{
    m_pUnkTrident = NULL;
    m_pOleObjTrident = NULL;
    m_pCmdTgtTrident = NULL;
    m_pDropTgtTrident = NULL;
#ifdef IE5_SPACING
    m_pTridentPersistStreamInit = NULL;
    m_pMapArray = NULL;
    m_hgMap = NULL;
    m_pspNonDSP = NULL;
    m_hgSpacingNonDSP = NULL;
    m_ichspNonDSPMax = 0;
    m_ichspNonDSP = 0;
#endif //IE5_SPACING

    m_pClientSiteHost = NULL;
    m_pUIHandlerHost = NULL;
    m_pDragDropHandlerHost = NULL;

    m_pUIHandler = NULL;

    m_pTokenizer = NULL;
    m_hwndTrident = NULL;

    m_fUIHandlerSet = FALSE;
    m_fInContextMenu = FALSE;

    m_fDragRectVisible = FALSE;
    m_fConstrain = FALSE;
    m_f2dDropMode = FALSE;
    m_eDirection = CONSTRAIN_NONE;
    m_ptAlign.x = 1;
    m_ptAlign.y = 1;
    m_pihtmlElement = NULL;
    m_pihtmlStyle = NULL;
    m_hbrDragRect = NULL;
    m_fLocked = FALSE;
    m_hgDocRestore = NULL;
}

HRESULT CTriEditDocument::FinalConstruct()
{
    HRESULT hr;
    IUnknown *pUnk = GetControllingUnknown();

    hr = CoCreateInstance(CLSID_HTMLDocument, pUnk, CLSCTX_INPROC_SERVER,
               IID_IUnknown, (void**)&m_pUnkTrident);

    if (SUCCEEDED(hr)) 
    {
        _ASSERTE(NULL != m_pUnkTrident);

                // When we cache Trident pointers, we do a GetControllingUnknown()->Release()
                // since the addref will increment our outer unknown pointer and not Trident
                // We compensate for this by doing a corresponding GetControllingUnknown()->AddRef()
                // in our FinalRelease.  Though these cancel out, it is necessary to do this in order
                // to ensure that our FinalRelease will get called.

        // Cache Trident's IOleObject pointer

        hr = m_pUnkTrident->QueryInterface(IID_IOleObject, (void **)&m_pOleObjTrident);
        _ASSERTE(S_OK == hr && NULL != m_pOleObjTrident);
        pUnk->Release();

        // Cache Trident's IOleCommandTarget pointer

        hr = m_pUnkTrident->QueryInterface(IID_IOleCommandTarget, (void **)&m_pCmdTgtTrident);
        _ASSERTE(S_OK == hr && NULL != m_pCmdTgtTrident);
        pUnk->Release();

        // Allocate UI handler sub-object
        m_pUIHandler = new CTriEditUIHandler(this);
        if (NULL == m_pUIHandler)
            hr = E_OUTOFMEMORY;

#ifdef IE5_SPACING
        // Get IPersistStreamInit
        hr = m_pUnkTrident->QueryInterface(IID_IPersistStreamInit, (void **) &m_pTridentPersistStreamInit);
        _ASSERTE(S_OK == hr && NULL != m_pTridentPersistStreamInit);
        pUnk->Release(); // PuruK - REVIEW Why do we need to do this?
        SetFilterInDone(FALSE);
#endif //IE5_SPACING

        // Allocate buffer for saving document's contents before <BODY> tag
        // Trident replaces all content before <BODY> tag by its own header
        m_hgDocRestore = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbHeader);
        if (NULL == m_hgDocRestore)
        {
            delete m_pUIHandler;
            hr = E_OUTOFMEMORY;
        }

    }

    _ASSERTE(SUCCEEDED(hr));

    return hr;
}

void CTriEditDocument::FinalRelease()
{
    IUnknown *pUnk = GetControllingUnknown();

    // Release host interface pointers
    SAFERELEASE(m_pClientSiteHost);
    SAFERELEASE(m_pUIHandlerHost);
    SAFERELEASE(m_pDragDropHandlerHost);

    // Release internal interface pointers
    SAFERELEASE(m_pTokenizer);

    // Release 2d drop related pointers
    ReleaseElement();
    
    // Release Trident interface pointers
    SAFERELEASE(m_pDropTgtTrident);

    pUnk->AddRef();
    SAFERELEASE(m_pOleObjTrident);
    pUnk->AddRef();
    SAFERELEASE(m_pCmdTgtTrident);
#ifdef IE5_SPACING
    pUnk->AddRef(); // REVIEW - PuruK - Why do we need to do this?
    SAFERELEASE(m_pTridentPersistStreamInit);
#endif //IE5_SPACING

    SAFERELEASE(m_pUnkTrident);

    // Delete UI handler sub-object
    if (m_pUIHandler != NULL)
    {
        // Assert that the ref count on the sub-object is 1
        // If this isn't 1, then Trident is holding on to this pointer
        _ASSERTE(m_pUIHandler->m_cRef == 1);
        delete m_pUIHandler;
    }

    if (m_hgDocRestore != NULL)
    {
        GlobalUnlock(m_hgDocRestore);
        GlobalFree(m_hgDocRestore);
    }

#ifdef IE5_SPACING
    if (m_hgMap != NULL)
    {
        GlobalUnlock(m_hgMap);
        GlobalFree(m_hgMap);
        m_hgMap = NULL;
    }
    if (m_hgSpacingNonDSP != NULL)
    {
        GlobalUnlock(m_hgSpacingNonDSP);
        GlobalFree(m_hgSpacingNonDSP);
        m_hgSpacingNonDSP = NULL;
    }
#endif
}

#ifdef IE5_SPACING
void CTriEditDocument::FillUniqueID(BSTR bstrUniqueID, BSTR bstrDspVal, int ichNonDSP, MAPSTRUCT *pMap, int iMapCur, BOOL fLowerCase, int iType)
{
    memcpy((BYTE *)pMap[iMapCur].szUniqueID, (BYTE *)bstrUniqueID, min(wcslen(bstrUniqueID), cchID)*sizeof(WCHAR));
    if (iType == INDEX_DSP)
    {
        memcpy((BYTE *)pMap[iMapCur].szDspID, (BYTE *)bstrDspVal, min(wcslen(bstrDspVal), cchID)*sizeof(WCHAR));
        _ASSERTE(ichNonDSP == -1);
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else if (iType == INDEX_COMMENT)
    {
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else if (iType == INDEX_AIMGLINK)
    {
        memcpy((BYTE *)pMap[iMapCur].szDspID, (BYTE *)bstrDspVal, min(wcslen(bstrDspVal), cchID)*sizeof(WCHAR));
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else if (iType == INDEX_OBJ_COMMENT)
    {
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else
        _ASSERTE(FALSE);
    pMap[iMapCur].fLowerCase = fLowerCase;
    _ASSERTE(iType >= INDEX_NIL && iType < INDEX_MAX);
    pMap[iMapCur].iType = iType;
}

BOOL CTriEditDocument::FGetSavedDSP(BSTR bstrUniqueID, BSTR *pbstrDspVal, int *pichNonDSP, MAPSTRUCT *pMap, BOOL *pfLowerCase, int *pIndex)
{
    BOOL fRet = FALSE;
    int i;

    // TODO - find a faster way than this linear search...
    for (i = 0; i < m_iMapCur; i++)
    {
        if (0 == _wcsnicmp(pMap[i].szUniqueID, bstrUniqueID, wcslen(bstrUniqueID)))
        {
            fRet = TRUE;
            if (pMap[i].iType == INDEX_DSP)
            {
                *pbstrDspVal = SysAllocString(pMap[i].szDspID);
                *pichNonDSP = -1;
            }
            else if (pMap[i].iType == INDEX_COMMENT)
            {
                *pbstrDspVal = (BSTR)NULL;
                *pichNonDSP = pMap[i].ichNonDSP;
            }
            else if (pMap[i].iType == INDEX_AIMGLINK)
            {
                *pbstrDspVal = SysAllocString(pMap[i].szDspID);
                *pichNonDSP = pMap[i].ichNonDSP;
                _ASSERTE(*pichNonDSP != -1);
            }
            else if (pMap[i].iType == INDEX_OBJ_COMMENT)
            {
                *pbstrDspVal = (BSTR)NULL;
                *pichNonDSP = pMap[i].ichNonDSP;
                _ASSERTE(*pichNonDSP != -1);
            }
            *pfLowerCase = pMap[i].fLowerCase;
            *pIndex = pMap[i].iType;

            goto LRet;
        }
    }

LRet:
    return(fRet);
}

void 
CTriEditDocument::FillNonDSPData(BSTR pOuterTag)
{
    int len = 0;

    _ASSERTE(m_ichspNonDSPMax != -1);
    _ASSERTE(m_ichspNonDSP != -1);
    _ASSERTE(m_hgSpacingNonDSP != NULL);
    _ASSERTE(m_pspNonDSP != NULL);

    // even if pOuterTag is NULL, we still need to store the fact that we have
    // zero bytes of data.
    if (pOuterTag != NULL)
        len = wcslen(pOuterTag);

    if ((int)(m_ichspNonDSP + len + sizeof(int)) > m_ichspNonDSPMax)
    {
        HGLOBAL hgSpacingNonDSP;

        //reallocate & set m_ichspNonDSPMax
        GlobalUnlock(m_hgSpacingNonDSP);
        hgSpacingNonDSP = m_hgSpacingNonDSP;
#pragma prefast(suppress: 308, "noise")
        m_hgSpacingNonDSP = GlobalReAlloc(m_hgSpacingNonDSP, (m_ichspNonDSP + len + sizeof(int)+MIN_SP_NONDSP)*sizeof(WCHAR), GMEM_MOVEABLE|GMEM_ZEROINIT);
        // if this alloc failed, we may still want to continue
        if (m_hgSpacingNonDSP == NULL)
        {
            GlobalFree(hgSpacingNonDSP);
            goto LRet;
        }
        else
        {
            m_pspNonDSP = (WCHAR *)GlobalLock(m_hgSpacingNonDSP);
            _ASSERTE(m_pspNonDSP != NULL);
            m_ichspNonDSPMax = (m_ichspNonDSP + len + sizeof(int)+MIN_SP_NONDSP);
        }
        _ASSERTE(m_ichspNonDSP < m_ichspNonDSPMax);
    }

    memcpy((BYTE *)(m_pspNonDSP+m_ichspNonDSP), (BYTE *)&len, sizeof(int));
    m_ichspNonDSP += sizeof(int)/sizeof(WCHAR);
    memcpy((BYTE *)(m_pspNonDSP+m_ichspNonDSP), (BYTE *)pOuterTag, len*sizeof(WCHAR));
    m_ichspNonDSP += len;

LRet:
    return;

}

void 
CTriEditDocument::ReSetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement* /*pElement*/, int ichspNonDSP)
{
    WCHAR *pStrComment = NULL;
//#ifdef DEBUG
//  CComBSTR bstrOuter, bstrOuterBefore;
//#endif //DEBUG
    int cchComment = 0;

    // get the ich, get the saved comment, set it
    memcpy((BYTE *)&cchComment, (BYTE *)(m_pspNonDSP+ichspNonDSP), sizeof(int));
    _ASSERTE(cchComment > 0);
//#ifdef DEBUG
//  pElement->get_outerHTML(&bstrOuterBefore);
//#endif //DEBUG
    pStrComment = new WCHAR[cchComment + 1];
    if (pStrComment == NULL)
		return;

    memcpy((BYTE *)pStrComment, (BYTE *)(m_pspNonDSP+ichspNonDSP+sizeof(int)/sizeof(WCHAR)), cchComment*sizeof(WCHAR));
    pStrComment[cchComment] = '\0';
    pCommentElement->put_text((BSTR)pStrComment);
//#ifdef DEBUG
//  pElement->get_outerHTML(&bstrOuter);
//#endif //DEBUG
    if (pStrComment)
        delete pStrComment;
//#ifdef DEBUG
//  bstrOuter.Empty();
//  bstrOuterBefore.Empty();
//#endif //DEBUG

}

void 
CTriEditDocument::SetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement* /*pElement*/, BSTR pOuterTag)
{
    WCHAR *pStr = NULL;
    WCHAR *pStrComment = NULL;
    LPCWSTR rgComment[] =
    {
        L"TRIEDITPRECOMMENT-",
        L"-->",
        L"<!--",
    };
//#ifdef DEBUG
//  CComBSTR bstrOuter, bstrInnerBefore, bstrInnerAfter, bstrOuterBefore;
//#endif //DEBUG

    // special case - 
    // send pOuterTag as NULL, if we want to get rid of the comment completely
    if (pOuterTag == NULL)
    {
        pCommentElement->put_text((BSTR)pOuterTag);
        goto LRet;
    }

    //remove the TRIEDITCOMMENT stuff from pOuterTag and set the outerHTML properly
    pStr = wcsstr(pOuterTag, rgComment[0]);
    if (pStr != NULL)
    {
        pStrComment = new WCHAR[wcslen(pOuterTag)-(SAFE_PTR_DIFF_TO_INT(pStr-pOuterTag)+wcslen(rgComment[0]))+wcslen(rgComment[1])+wcslen(rgComment[2])+1];
        if (pStrComment != NULL)
        {
            memcpy( (BYTE *)pStrComment, 
                    (BYTE *)(rgComment[2]),
                    (wcslen(rgComment[2]))*sizeof(WCHAR)
                    );
            memcpy( (BYTE *)(pStrComment+wcslen(rgComment[2])), 
                    (BYTE *)(pStr+wcslen(rgComment[0])),
                    (wcslen(pOuterTag)-(SAFE_PTR_DIFF_TO_INT(pStr-pOuterTag)+wcslen(rgComment[0]))-wcslen(rgComment[1]))*sizeof(WCHAR)
                    );
            memcpy( (BYTE *)(pStrComment+wcslen(rgComment[2])+wcslen(pOuterTag)-(pStr-pOuterTag+wcslen(rgComment[0]))-wcslen(rgComment[1])),
                    (BYTE *)(rgComment[1]),
                    (wcslen(rgComment[1]))*sizeof(WCHAR)
                    );
            pStrComment[wcslen(pOuterTag)-(pStr-pOuterTag+wcslen(rgComment[0]))-wcslen(rgComment[1])+wcslen(rgComment[1])+wcslen(rgComment[2])] = '\0';
//#ifdef DEBUG
//          pElement->get_innerHTML(&bstrInnerBefore);
//          pElement->get_outerHTML(&bstrOuterBefore);
//#endif //DEBUG
            pCommentElement->put_text((BSTR)pStrComment);
//#ifdef DEBUG
//          pElement->get_outerHTML(&bstrOuter);
//          pElement->get_innerHTML(&bstrInnerAfter);
//#endif //DEBUG
            delete pStrComment;
        }
    }
LRet:
//#ifdef DEBUG
//  bstrOuter.Empty(); 
//  bstrInnerBefore.Empty();
//  bstrInnerAfter.Empty();
//  bstrOuterBefore.Empty();
//#endif //DEBUG
    return;
}

void
CTriEditDocument::RemoveEPComment(IHTMLObjectElement *pObjectElement, BSTR bstrAlt, 
                                  int cch, BSTR *pbstrAltComment, BSTR *pbstrAltNew)
{
    int ich = 0;
    WCHAR *pAltNew = NULL;
    WCHAR *pStrAlt = bstrAlt;
    WCHAR *pStr = NULL;
    WCHAR *pStrEnd = NULL;
    WCHAR *pStrComment = NULL;
    LPCWSTR rgComment[] =
    {
        L"<!--ERRORPARAM",
        L"ERRORPARAM-->",
    };

    if (bstrAlt == (BSTR)NULL || pObjectElement == NULL)
        return;

    // look for ERRORPARAM
    pStr = wcsstr(bstrAlt, rgComment[0]);
    pStrEnd = wcsstr(bstrAlt, rgComment[1]);
    if (pStr != NULL && pStrEnd != NULL)
    {
        pStrEnd += wcslen(rgComment[1]);
        pStrComment = new WCHAR[SAFE_PTR_DIFF_TO_INT(pStrEnd-pStr)+1];
        if (pStrComment == NULL)
            goto LRetNull;
        memcpy((BYTE *)pStrComment, (BYTE *)pStr, SAFE_PTR_DIFF_TO_INT(pStrEnd-pStr)*sizeof(WCHAR));
        pStrComment[pStrEnd-pStr] = '\0';
        *pbstrAltComment = SysAllocString(pStrComment);
        delete pStrComment;

        pAltNew = new WCHAR[cch+1]; // max size
        if (pAltNew == NULL)
            goto LRetNull;
        // remove stuff from pStr till pStrEnd & copy into *pbstrAltNew
        if (pStr > pStrAlt)
        {
            memcpy((BYTE *)pAltNew, (BYTE *)pStrAlt, SAFE_PTR_DIFF_TO_INT(pStr-pStrAlt)*sizeof(WCHAR));
            ich += SAFE_PTR_DIFF_TO_INT(pStr-pStrAlt);
        }
        if ((pStrAlt+cch)-pStrEnd > 0)
        {
            memcpy((BYTE *)(pAltNew+ich), (BYTE *)pStrEnd, SAFE_PTR_DIFF_TO_INT((pStrAlt+cch)-pStrEnd)*sizeof(WCHAR));
            ich += SAFE_PTR_DIFF_TO_INT((pStrAlt+cch)-pStrEnd);
        }
        pAltNew[ich] = '\0';
        *pbstrAltNew = SysAllocString(pAltNew);
        delete pAltNew;
    }
    else
    {
LRetNull:
		*pbstrAltNew = (bstrAlt) ? SysAllocString(bstrAlt) : (BSTR)NULL;
        *pbstrAltComment = (BSTR)NULL;
    }

} /* CTriEditDocument::RemoveEPComment() */

HRESULT 
CTriEditDocument::SetObjectComment(IHTMLObjectElement *pObjectElement, BSTR bstrAltNew)
{
    HRESULT hr;

    _ASSERTE(pObjectElement != NULL);
    hr = pObjectElement->put_altHtml(bstrAltNew);
    return(hr);

} /* CTriEditDocument::SetObjectComment() */

void
CTriEditDocument::AppendEPComment(IHTMLObjectElement *pObjectElement, int ichspNonDSP)
{
    CComBSTR bstrAltNew;
    int cch;
    WCHAR *pStrSaved = NULL;
    HRESULT hr;
    
    // get current altHtml from the tree
    hr = pObjectElement->get_altHtml(&bstrAltNew);
    if (hr != S_OK || bstrAltNew == (BSTR)NULL)
        goto LRet;
    
    // get saved altHtml in m_pspNonDSP
    memcpy((BYTE *)&cch, (BYTE *)(m_pspNonDSP+ichspNonDSP), sizeof(int));
    if (cch <= 0)
        goto LRet;
    pStrSaved = new WCHAR[cch + 1];
    if (pStrSaved == NULL)
        goto LRet;
    memcpy((BYTE *)pStrSaved, (BYTE *)(m_pspNonDSP+ichspNonDSP+sizeof(int)/sizeof(WCHAR)), cch*sizeof(WCHAR));
    pStrSaved[cch] = '\0';
    
    // append saved altHtml
    bstrAltNew += pStrSaved;

    // save it back in the tree
    hr = pObjectElement->put_altHtml(bstrAltNew);
    if (pStrSaved)
        delete pStrSaved;

LRet:
    return;
} /* CTriEditDocument::AppendEPComment() */


void 
CTriEditDocument::MapUniqueID(BOOL fGet)
{
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IHTMLElementCollection> pHTMLCollection;
    CComPtr<IDispatch> pDispControl;
    CComPtr<IHTMLElement> pElement;
    CComPtr<IHTMLUniqueName> pUniqueName;
    CComPtr<IHTMLCommentElement> pCommentElement;
    CComPtr<IHTMLObjectElement> pObjectElement;

    HRESULT hr;
    //CComBSTR bstrUniqueID;
    WCHAR *pAttr = NULL;
    WCHAR *pAttrL = NULL;
    WCHAR *pAttrDSU = NULL;
    long len;
    int i;
    LPCWSTR szDSP[] =
    {
        L"DESIGNTIMESP",
        L"designtimesp",
        L"DESIGNTIMEURL",
    };
    LPCWSTR szComment[] =
    {
        L"<!--TRIEDITCOMMENT",
        L"<!--ERRORPARAM",
        L"<!--ERROROBJECT",
    };
    VARIANT var, vaName, vaIndex;

    if (!IsIE5OrBetterInstalled())
        goto LRet;

    pHTMLDoc = NULL;
    hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void **) &pHTMLDoc);
    if (hr != S_OK)
        goto LRet;


    pHTMLDoc->get_all(&pHTMLCollection);
    if (hr != S_OK)
        goto LRet;

    pAttr = new WCHAR[wcslen(szDSP[0])+1];
    memcpy((BYTE *)pAttr, (BYTE *)szDSP[0], wcslen(szDSP[0])*sizeof(WCHAR));
    pAttr[wcslen(szDSP[0])] = '\0';
    pAttrL = new WCHAR[wcslen(szDSP[1])+1];
    memcpy((BYTE *)pAttrL, (BYTE *)szDSP[1], wcslen(szDSP[1])*sizeof(WCHAR));
    pAttrL[wcslen(szDSP[1])] = '\0';
    pAttrDSU = new WCHAR[wcslen(szDSP[2])+1];
    memcpy((BYTE *)pAttrDSU, (BYTE *)szDSP[2], wcslen(szDSP[2])*sizeof(WCHAR));
    pAttrDSU[wcslen(szDSP[2])] = '\0';

    pHTMLCollection->get_length(&len);

    if (len == 0)
        goto LRet;

    if (!fGet)
    {
        // now we know that we atleast have one element, lets allocate space for saving
        // UniqueID's & designtimesp's
        if (m_pMapArray == NULL) // this is the first time we are here
        {
            _ASSERTE(m_hgMap == NULL);
            m_hgMap = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_MAP*sizeof(MAPSTRUCT));
            if (m_hgMap == NULL)
                goto LRet;
            m_cMapMax = MIN_MAP;
        }
        _ASSERTE(m_hgMap != NULL);
        m_pMapArray = (MAPSTRUCT *) GlobalLock(m_hgMap);
        _ASSERTE(m_pMapArray != NULL);
        // even if we allocate the space for m_hgMap here or not, we should start from 0
        m_iMapCur = 0;
        // zeroise the array
        memset((BYTE *)m_pMapArray, 0, m_cMapMax*sizeof(MAPSTRUCT));
        
        if (m_pspNonDSP == NULL) // this is the first time we are here
        {
            _ASSERTE(m_hgSpacingNonDSP == NULL);
            m_hgSpacingNonDSP = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_SP_NONDSP*sizeof(WCHAR));
            if (m_hgSpacingNonDSP == NULL)
                goto LRet;
            m_ichspNonDSPMax = MIN_SP_NONDSP;
        }
        _ASSERTE(m_hgSpacingNonDSP != NULL);
        m_pspNonDSP = (WCHAR *) GlobalLock(m_hgSpacingNonDSP);
        _ASSERTE(m_pspNonDSP != NULL);
        // even if we allocate the space for m_hgSpacingNonDSP here or not, we should start from 0
        m_ichspNonDSP = 0;
        // zeroise the array
        memset((BYTE *)m_pspNonDSP, 0, m_ichspNonDSPMax*sizeof(WCHAR));
    }
    else // if (fGet)
    {
        if (m_iMapCur < 1) // we don't have any mappings saved
            goto LRet;
        m_pMapArray = (MAPSTRUCT *)GlobalLock(m_hgMap);
        _ASSERTE(m_pMapArray != NULL);

        m_pspNonDSP = (WCHAR *)GlobalLock(m_hgSpacingNonDSP);
        _ASSERTE(m_pspNonDSP != NULL);
    }

    // loop through all the elemets and fill m_pMapArray
    for (i = 0; i < len; i++)
    {
        VARIANT_BOOL fSuccess;

        if (!fGet)
        {
            // reallocate m_hgMap if needed
            if (m_iMapCur == m_cMapMax - 1)
            {
                HGLOBAL hgMap;
                GlobalUnlock(m_hgMap);
                hgMap = m_hgMap;
#pragma prefast(suppress:308, "noise")
                m_hgMap = GlobalReAlloc(m_hgMap, (m_cMapMax+MIN_MAP)*sizeof(MAPSTRUCT), GMEM_MOVEABLE|GMEM_ZEROINIT);
                // if this alloc failed, we may still want to continue
                if (m_hgMap == NULL)
                {
                    GlobalFree(hgMap);
                    goto LRet;
                }
                else
                {
                    m_pMapArray = (MAPSTRUCT *)GlobalLock(m_hgMap);
                    _ASSERTE(m_pMapArray != NULL);
                    m_cMapMax += MIN_MAP;
                }
            }
            _ASSERTE(m_iMapCur < m_cMapMax);
        }

        VariantInit(&vaName);
        VariantInit(&vaIndex);

        V_VT(&vaName) = VT_ERROR;
        V_ERROR(&vaName) = DISP_E_PARAMNOTFOUND;

        V_VT(&vaIndex) = VT_I4;
        V_I4(&vaIndex) = i;

        pDispControl = NULL;
        hr = pHTMLCollection->item(vaIndex, vaName, &pDispControl);
        VariantClear(&vaName);
        VariantClear(&vaIndex);
        // Trident has a bug that if the object was nested inside <scripts> tags,
        // it returns S_OK with pDispControl as NULL. (See VID BUG 11303)
        if (hr == S_OK && pDispControl != NULL)
        {
            pElement = NULL;
            hr = pDispControl->QueryInterface(IID_IHTMLElement, (void **) &pElement);
            if (hr == S_OK && pElement != NULL)
            {
//#ifdef DEBUG
//              CComBSTR bstrTagName, bstrClsName;
//
//              hr = pElement->get_className(&bstrClsName);
//              hr = pElement->get_tagName(&bstrTagName);
//#endif //DEBUG
                if (!fGet) // saving the data
                {
                    BOOL fLowerCase = FALSE;

                    VariantInit(&var);
                    // KNOWN (and postponed) TRIDENT BUG - ideally, we should be able to look for hr's value here,
                    // but trident returns S_OK even if it can't get the attribute!!!
                    hr = pElement->getAttribute(pAttr, 0, &var); // look for DESIGNTIMESP (upper or lower case'd)
                    if (var.vt == VT_BSTR)
                    {
                        CComVariant varT;

                        hr = pElement->getAttribute(pAttrL, 1, &varT); // look for lowercase designtimesp
                        if (varT.vt == VT_BSTR)
                            fLowerCase = TRUE;
                    }
                    if (var.vt == VT_BSTR && var.bstrVal != NULL)
                    {
                        CComBSTR bstrUniqueID;
                        CComVariant varDSU;
                        int iType = INDEX_DSP; // initial value
                        int ich = -1; // initial value;
//#ifdef DEBUG
//                      CComBSTR pOuterTag;
//#endif //DEBUG

                        pUniqueName = NULL;
                        hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                        if (hr == S_OK && pUniqueName != NULL)
                            hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                        if (pUniqueName)
                            pUniqueName.Release();
                        //pHTMLDoc3->get_uniqueID(&bstrUniqueID);

//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                        // at this point, we know that this tag had designtimesp.
                        // It may also have additional triedit attributes like designtimeurl
                        // lets check for those as well
                        hr = pElement->getAttribute(pAttrDSU, 0, &varDSU); // look for DESIGNTIMEURL (upper or lower case'd)
                        if (   hr == S_OK 
                            && varDSU.vt == VT_BSTR 
                            && varDSU.bstrVal != NULL
                            )
                        {
                            // we found 'designtimeurl'
                            iType = INDEX_AIMGLINK;
                            ich = m_ichspNonDSP;

                            FillNonDSPData(varDSU.bstrVal);
//#ifdef DEBUG
//                          pElement->get_outerHTML(&pOuterTag);
//                          pOuterTag.Empty();
//#endif //DEBUG
                            // now remove designtimeurl & its value
                            hr = pElement->removeAttribute(pAttrDSU, 0, &fSuccess);
//#ifdef DEBUG
//                          pElement->get_outerHTML(&pOuterTag);
//                          pOuterTag.Empty();
//#endif //DEBUG
                        }

                        // fill ID mapping structure
                        FillUniqueID(bstrUniqueID, var.bstrVal, ich, m_pMapArray, m_iMapCur, fLowerCase, iType);
                        bstrUniqueID.Empty();
                        m_iMapCur++;
//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                        // Now, remove designtimesp and its value
                        hr = pElement->removeAttribute(pAttr, 0, &fSuccess);
//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                        bstrUniqueID.Empty();
                    }
                    else if (var.vt == VT_NULL)
                    {
                        CComBSTR bstrUniqueID;
                        CComBSTR pOuterTag;
//#ifdef DEBUG
//                      CComBSTR pOuter;
//#endif // DEBUG

                        // see if this is a comment and save it
                        pElement->get_outerHTML(&pOuterTag);
                        if (   pOuterTag != NULL
                            && 0 == _wcsnicmp(pOuterTag, szComment[0], wcslen(szComment[0]))
                            )
                        {
                            pUniqueName = NULL;
                            hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                            if (hr == S_OK && pUniqueName != NULL)
                                hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                            if (pUniqueName)
                                pUniqueName.Release();

                            // fill ID mapping structure
                            FillUniqueID(bstrUniqueID, NULL, m_ichspNonDSP, m_pMapArray, m_iMapCur, fLowerCase, INDEX_COMMENT);
                            bstrUniqueID.Empty();
                            m_iMapCur++;

                            FillNonDSPData(pOuterTag);
                            // now, remove the comment spacing stuff and set_outerHTML
                            hr = pDispControl->QueryInterface(IID_IHTMLCommentElement, (void **) &pCommentElement);
                            if (hr == S_OK && pCommentElement != NULL)
                                SetinnerHTMLComment(pCommentElement, pElement, pOuterTag);
//#ifdef DEBUG
//                          pElement->get_outerHTML(&pOuter);
//                          pOuter.Empty();
//#endif //DEBUG
                            if (pCommentElement)
                                pCommentElement.Release();
                        }
                        else if (      S_OK == pDispControl->QueryInterface(IID_IHTMLObjectElement, (void **) &pObjectElement)
                                    && pObjectElement != NULL
                                    )
                        {
                            BSTR bstrAlt, bstrAltNew, bstrAltComment;

                            bstrAlt = bstrAltNew = bstrAltComment = NULL;
                            pUniqueName = NULL;
                            hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                            if (hr == S_OK && pUniqueName != NULL)
                                hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                            if (pUniqueName)
                                pUniqueName.Release();

                            // fill ID mapping structure
                            FillUniqueID(bstrUniqueID, NULL, m_ichspNonDSP, m_pMapArray, m_iMapCur, FALSE, INDEX_OBJ_COMMENT);
                            bstrUniqueID.Empty();
                            m_iMapCur++;

                            pObjectElement->get_altHtml(&bstrAlt);
                            // remove <!--ERRORPARAM ...ERRORPARAM-->
                            // ASSUME (FOR NOW) that we won't see TRIEDITCOMMENT or others here
                            RemoveEPComment(pObjectElement, bstrAlt, SysStringLen(bstrAlt), &bstrAltComment, &bstrAltNew);

                            FillNonDSPData(bstrAltComment);
                            SysFreeString(bstrAltComment);

                            hr = SetObjectComment(pObjectElement, bstrAltNew);
                            SysFreeString(bstrAltNew);

                            SysFreeString(bstrAlt);
//#ifdef DEBUG
//                          pObjectElement->get_altHtml(&bstrAlt);
//                          bstrAlt.Empty();
//#endif //DEBUG
                        }
                        if (pObjectElement)
                            pObjectElement.Release();

                        bstrUniqueID.Empty();
                        pOuterTag.Empty();
                    }
                    VariantClear(&var);
                }
                else // if (fGet)
                {
                    BOOL fLowerCase = FALSE;
                    int index, ichNonDSP;
                    CComBSTR bstrUniqueID;

                    pUniqueName = NULL;
                    hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                    if (hr == S_OK && pUniqueName != NULL)
                        hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                    if (pUniqueName)
                        pUniqueName.Release();

                    // get the uniqueID
                    //pHTMLDoc3->get_uniqueID(&bstrUniqueID);
                    // see if we have it in m_hgMap, if we do, get corresponding designtimesp ID
                    // if we don't have a DSP for this uniqueID, this is newly inserted element
                    VariantInit(&var);
                    if (FGetSavedDSP(bstrUniqueID, &(var.bstrVal), &ichNonDSP, m_pMapArray, &fLowerCase, &index))
                    {
//#ifdef DEBUG
//                      CComBSTR pOuterTag;
//#endif //DEBUG
                        // insert (correct case) "designtimesp = xxxx" in the tag by setting attribute/value
                        var.vt = VT_BSTR;
#ifdef DEBUG
                        if (index == INDEX_DSP)
                            _ASSERTE(var.bstrVal != NULL && ichNonDSP == -1);
                        else if (index == INDEX_COMMENT)
                            _ASSERTE(var.bstrVal == (BSTR)NULL && ichNonDSP != -1);
                        else if (index == INDEX_AIMGLINK)
                            _ASSERTE(var.bstrVal != NULL && ichNonDSP != -1);
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
#endif //DEBUG
                        if (index == INDEX_DSP)
                        {
                            if (fLowerCase)
                                hr = pElement->setAttribute(pAttrL, var, 1);
                            else
                                hr = pElement->setAttribute(pAttr, var, 1);
                        }
                        else if (index == INDEX_COMMENT)
                        {
                            hr = pDispControl->QueryInterface(IID_IHTMLCommentElement, (void **) &pCommentElement);
                            if (hr == S_OK && pCommentElement != NULL)
                                ReSetinnerHTMLComment(pCommentElement, pElement, ichNonDSP);
                            if (pCommentElement)
                                pCommentElement.Release();
                        }
                        else if (index == INDEX_AIMGLINK)
                        {
                            CComVariant varDSU;
                            WCHAR *pchDSU;
                            int cchDSU = 0;

                            if (fLowerCase)
                                hr = pElement->setAttribute(pAttrL, var, 1);
                            else
                                hr = pElement->setAttribute(pAttr, var, 1);

                            // put designtimeurl as well
                            // get the data from ichNonDSP and setAttribute
                            _ASSERTE(ichNonDSP != -1);
                            memcpy((BYTE *)&cchDSU, (BYTE *)(m_pspNonDSP+ichNonDSP), sizeof(INT));
                            _ASSERTE(cchDSU > 0);
                            pchDSU = new WCHAR[cchDSU+1];
                            memcpy((BYTE *)pchDSU, (BYTE *)(m_pspNonDSP+ichNonDSP+sizeof(int)/sizeof(WCHAR)), cchDSU*sizeof(WCHAR));
                            pchDSU[cchDSU] = '\0';
                            varDSU.bstrVal = SysAllocString(pchDSU);
                            varDSU.vt = VT_BSTR;
                            hr = pElement->setAttribute(pAttrDSU, varDSU, 1);
                            delete pchDSU;
                        } //else if (index == INDEX_AIMGLINK)
                        else if (index == INDEX_OBJ_COMMENT)
                        {
                            hr = pDispControl->QueryInterface(IID_IHTMLObjectElement, (void **) &pObjectElement);
                            if (pObjectElement != NULL)
                            {
                                AppendEPComment(pObjectElement, ichNonDSP);
                            }
                            else // something is not right, just ignore
                            {
                                _ASSERTE(FALSE);
                            }
                            if (pObjectElement)
                                pObjectElement.Release();
                        }
//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                    } // if (FGetSavedDSP())
                    VariantClear(&var);
                    bstrUniqueID.Empty();
                } // end of else case of 'if (!fGet)'
//#ifdef DEBUG
//              bstrTagName.Empty();
//              bstrClsName.Empty();
//#endif //DEBUG
            } // if (hr == S_OK && pElement != NULL)
            if (pElement)
                pElement.Release();
        } // if (hr == S_OK && pDispControl != NULL)
        if (pDispControl)
            pDispControl.Release();
    } // for (i ...)

LRet:
    if (pAttr != NULL)
        delete pAttr; 
    if (pAttrL != NULL)
        delete pAttrL;
    if (pAttrDSU != NULL)
        delete pAttrDSU;
    if (pHTMLCollection)
        pHTMLCollection.Release();
    if (pHTMLDoc)
        pHTMLDoc.Release();
    if (m_hgMap != NULL)
        GlobalUnlock(m_hgMap);
    if (m_hgSpacingNonDSP != NULL)
        GlobalUnlock(m_hgSpacingNonDSP);


    return;
}

/////////////////////////////////////////////////////////////////////
//
STDMETHODIMP
CTridentEventSink::Invoke(DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
{
    switch(dispid)
    {
    case DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE:
        {
            CComBSTR p;
            HRESULT hr;
            LPCWSTR szComplete[] =
            {
                L"complete",
            };

            //look for READYSTATE_COMPLETE)
            hr = m_pHTMLDocument2->get_readyState(&p);
            if (   hr == S_OK
                && (p != NULL)
                && 0 == _wcsnicmp(p, szComplete[0], wcslen(szComplete[0]))
                && m_pTriEditDocument->FIsFilterInDone()
                )
            {
                CComVariant varDirty;

                // we know that the document is loaded.
                // get pointer to DOM and access all tags
                // create a table that holds mapping from designtimespID to uniqueID
                // save the mapping and remove designtimesp attribute

                // at the time of save, fill in the designtimesp's for each uniqueID

                m_pTriEditDocument->MapUniqueID(/*fGet*/FALSE);
                m_pTriEditDocument->SetFilterInDone(FALSE);
                // set the document to be CLEAN (non-DIRTY), we don't care about hr
                varDirty.bVal = FALSE;
                varDirty.vt = VT_BOOL;
                hr = m_pTriEditDocument->Exec(&CGID_MSHTML, IDM_SETDIRTY, MSOCMDEXECOPT_DODEFAULT, &varDirty, NULL);
            }
            p.Empty();
        }
        break;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//
HRESULT 
CBaseTridentEventSink::Advise(IUnknown* pUnkSource, REFIID riidEventInterface)
{
    HRESULT hr = E_FAIL;
    
    if(NULL == pUnkSource)
    {
        _ASSERTE(FALSE);
        return E_INVALIDARG;
    }

    if(m_dwCookie > 0)
    {
        _ASSERTE(FALSE);
        return E_UNEXPECTED;
    }

    hr = AtlAdvise(pUnkSource, static_cast<IUnknown*>(this), riidEventInterface, &m_dwCookie);
    if(SUCCEEDED(hr) && m_dwCookie > 0)
    {
        m_iidEventInterface = riidEventInterface;

        m_pUnkSource = pUnkSource; // no addref. Advise already addref'ed it
        return S_OK;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
void 
CBaseTridentEventSink::Unadvise(void)
{
    if(0 == m_dwCookie)
        return;

    AtlUnadvise(m_pUnkSource, m_iidEventInterface, m_dwCookie);
    m_dwCookie = 0; 
    m_pUnkSource = NULL;
}






//------------------------------------------------------------------------------
// IPersistStreamInit
//------------------------------------------------------------------------------



STDMETHODIMP CTriEditDocument::Load(LPSTREAM pStm)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::Load"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return m_pTridentPersistStreamInit->Load(pStm);
}

STDMETHODIMP CTriEditDocument::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::Save"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      

    // before we deligate Save to Trident, do the preFiltering stuff
    if (m_hgMap != NULL)
    {
        MapUniqueID(/*fGet*/TRUE);
    }

    return m_pTridentPersistStreamInit->Save(pStm, fClearDirty);
}

STDMETHODIMP CTriEditDocument::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::GetSizeMax"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return m_pTridentPersistStreamInit->GetSizeMax(pcbSize);
}

STDMETHODIMP CTriEditDocument::IsDirty()
{
    //ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::IsDirty\n"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return m_pTridentPersistStreamInit->IsDirty();
}

STDMETHODIMP CTriEditDocument::InitNew()
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::InitNew\n"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return(m_pTridentPersistStreamInit->InitNew());
}

STDMETHODIMP CTriEditDocument::GetClassID(CLSID *pClassID)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::GetClassID\n"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);
    *pClassID = GetObjectCLSID();
    return S_OK;
}
#endif //IE5_SPACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\document.h ===
// Document.h : Declaration of the CTriEditDocument
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DOCUMENT_H_
#define __DOCUMENT_H_

#include "resource.h"       // main symbols

#include "token.h"
#include "triedcid.h"
#include "trixacc.h"

#include <mshtmhst.h>

#define grfInSingleRow          0x00000001 // selection is in any number of cells within a single row
#define grfSelectOneCell        0x00000002 // only one single cell is selected
#define grpSelectEntireRow      0x00000004 // selection is any number of whole rows being selected

#define IE5_SPACING 
#ifdef IE5_SPACING
class CTridentEventSink;
#endif //IE5_SPACING

typedef enum {
    CONSTRAIN_NONE,
    CONSTRAIN_HORIZONTAL,
    CONSTRAIN_VERTICAL
} ENUMCONSTRAINDIRECTION;

DEFINE_GUID(GUID_TriEditCommandGroup,
0x2582f1c0, 0x84e, 0x11d1, 0x9a, 0xe, 0x0, 0x60, 0x97, 0xc9, 0xb3, 0x44);

//for use with IDM_TRIED_LOCK_ELEMENT
#define DESIGN_TIME_LOCK L"Design_Time_Lock"

// The following definition is used in LockElement while invalidating the element.
// This size is dependent on Trident's grab handle size.
// This value should be atleast as big as Trident's grab handle size.
#define ELEMENT_GRAB_SIZE 12

#ifndef SAFERELEASE
#define SAFERELEASE(a) if (a) {a->Release();a=NULL;}
#endif  //SAFERELEASE

#include "zorder.h"

#ifdef IE5_SPACING
// move followign defines in a new header file - uniqueid,h
#define INDEX_NIL       0
#define INDEX_DSP       1
#define INDEX_COMMENT   2
#define INDEX_AIMGLINK  3
#define INDEX_OBJ_COMMENT   4
#define INDEX_MAX       5

#define  MIN_MAP    20
#define cchID       20
struct MAPSTRUCT
{
    WCHAR szUniqueID[cchID];
    WCHAR szDspID[cchID];
    int ichNonDSP;
    BOOL fLowerCase;
    int iType;
};
#define MIN_SP_NONDSP   0x800
#endif //IE5_SPACING

class CTriEditUIHandler;

/////////////////////////////////////////////////////////////////////////////
// CTriEditDocument
class ATL_NO_VTABLE CTriEditDocument :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTriEditDocument, &CLSID_TriEditDocument>,
    public IDispatchImpl<ITriEditDocument, &IID_ITriEditDocument, &LIBID_TRIEDITLib>,
    public IOleObject,
    public IOleCommandTarget,
    public IDropTarget,
    public ITriEditExtendedAccess
#ifdef IE5_SPACING
    ,
    public IPersistStreamInit,
    public IPersistStream
#endif //IE5_SPACING
{
public:

    // IOleObject

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */);
    STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */);
    STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */);
    STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */, HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */);

    // IOleCommandTarget
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    // IDropTarget
    STDMETHOD(DragEnter)(IDataObject *pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)(IDataObject *pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

#ifdef IE5_SPACING
    //  IPersistStreamInit, IPersistStream
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER * pcbSize);
    STDMETHOD(InitNew)();
    STDMETHOD(GetClassID)(CLSID *pClassID);
#endif //IE5_SPACING

    // ITriEditDocument

    STDMETHOD(FilterIn)(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL);
    STDMETHOD(FilterOut)(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL);

    // ITriEditExtendedAccess
    STDMETHOD(GetCharsetFromStream)(IStream* piStream, BSTR* pbstrCodePage);

    DECLARE_GET_CONTROLLING_UNKNOWN()

    // ATL helper functions override

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    HRESULT FinalConstruct();   // for aggregation
    void FinalRelease();        // for aggregation

#ifdef IE5_SPACING
    // methods for mapping unique IDs and designtimesp's
    void MapUniqueID(BOOL fGet);
    void FillUniqueID(BSTR bstrUniqueID, BSTR bstrDspVal, int ichNonDSP, MAPSTRUCT *pMap, int iMapCur, BOOL fLowerCase, int iType);
    BOOL FGetSavedDSP(BSTR bstrUniqueID, BSTR *pbstrDspVal, int *pichNonDSP, MAPSTRUCT *pMap, BOOL *pfLowerCase, int *pIndex);
    BOOL FIsFilterInDone() {return(m_fFilterInDone);}
    void SetFilterInDone(BOOL fSet) {m_fFilterInDone = fSet;}
    void FillNonDSPData(BSTR pOuterTag);
    void SetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement *pElement, BSTR pOuterTag);
    void ReSetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement *pElement, int ichspNonDSP);
    void RemoveEPComment(IHTMLObjectElement *pObjectElement, BSTR bstrAlt, int cch, BSTR *pbstrAltComment, BSTR *pbstrAltNew);
    HRESULT  SetObjectComment(IHTMLObjectElement *pObjectElement, BSTR bstrAltNew);
    void AppendEPComment(IHTMLObjectElement *pObjectElement, int ichspNonDSP);
#endif //IE5_SPACING

protected:
    // Trident interface pointers
    IUnknown *m_pUnkTrident;
    IOleObject *m_pOleObjTrident;
    IOleCommandTarget *m_pCmdTgtTrident;
    IDropTarget *m_pDropTgtTrident;
#ifdef IE5_SPACING
    IPersistStreamInit *m_pTridentPersistStreamInit;
#endif //IE5_SPACING

    // Host interface pointers
    IOleClientSite *m_pClientSiteHost;
    IDocHostUIHandler *m_pUIHandlerHost;
    IDocHostDragDropHandler *m_pDragDropHandlerHost;

    // Pointer to our UI handler sub-object
    CTriEditUIHandler *m_pUIHandler;

    // General hosting related data
    BOOL m_fUIHandlerSet;
    BOOL m_fInContextMenu;

    // 2D editing data
    IHTMLElement* m_pihtmlElement;
    IHTMLStyle* m_pihtmlStyle;
    RECT m_rcElement;
    RECT m_rcElementOrig;
    RECT m_rcElementParent;

    BOOL m_fConstrain;
    ENUMCONSTRAINDIRECTION m_eDirection;
    HWND m_hwndTrident;
    HBRUSH m_hbrDragRect;
    BOOL m_fDragRectVisible;
    RECT m_rcDragRect;

    POINT m_ptClickOrig;
    POINT m_ptClickLast;
    POINT m_ptConstrain;

    POINT m_ptScroll;
    POINT m_ptAlign;
    BOOL m_fLocked;

    //for 2D drop mode.
    BOOL m_f2dDropMode;

#ifdef IE5_SPACING
    CTridentEventSink *m_pTridentEventSink;
    IHTMLDocument2  *m_pHTMLDocument2;
    MAPSTRUCT *m_pMapArray;
    HGLOBAL m_hgMap;
    int m_cMapMax;
    int m_iMapCur;
    WCHAR *m_pspNonDSP;
    HGLOBAL m_hgSpacingNonDSP;
    int m_ichspNonDSPMax;
    int m_ichspNonDSP;
#endif //IE5_SPACING

private:
    // Filtering related members
    ITokenGen *m_pTokenizer;
    HGLOBAL m_hgDocRestore;
    HRESULT DoFilter(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew, DWORD dwFlags, FilterMode mode, int cbSizeIn, UINT* pcbSizeOut, BSTR bstrBaseURL);

    //Stubs for IOleCommandTarget commands
    HRESULT Is2DElement(IHTMLElement* pihtmlElement, BOOL* pf2D);
    HRESULT NudgeElement(IHTMLElement* pihtmlElement, LPPOINT ptNudge);
    HRESULT SetAlignment(LPPOINT pptAlign);
    HRESULT LockElement(IHTMLElement* pihtmlElement, BOOL fLock);
    HRESULT Make1DElement(IHTMLElement* pihtmlElement);
    HRESULT Make2DElement(IHTMLElement* pihtmlElement, POINT *ppt = NULL);
    HRESULT Constrain(BOOL fConstrain);
    HRESULT DoVerb(VARIANTARG *pvarargIn, BOOL fQueryStatus);

    //Z-Ordering related functions
    static int _cdecl CompareProc(const void* arg1, const void* arg2);
    HRESULT GetZIndex(IHTMLElement* pihtmlElement, LONG* plZindex);
    HRESULT SetZIndex(IHTMLElement* pihtmlElement, LONG lZindex);
    HRESULT AssignZIndex(IHTMLElement *pihtmlElement, int nZIndexMode);
    HRESULT PropagateZIndex(CZOrder* pczOrder, LONG lZIndex, BOOL fZindexNegative = FALSE);
    BOOL IsEqualZIndex(CZOrder* pczOrder,LONG lIndex);

    // table editing
    HRESULT IsSelectionInTable(IDispatch **ppTable=NULL);
    HRESULT FillInSelectionCellsInfo(struct SELCELLINFO * pselStart, struct SELCELLINFO *pselEnd);
    ULONG GetSelectionTypeInTable(void);
    HRESULT CopyStyle(IDispatch *pFrom, IDispatch *pTo);
    HRESULT CopyProperty(IDispatch *pFrom, IDispatch *pTo);
    HRESULT DeleteTableRows(void);
    HRESULT InsertTableRow(void);
    HRESULT DeleteTableCols(void);
    HRESULT InsertTableCol(void);
    HRESULT InsertTableCell(void);
    HRESULT DeleteTableCells(void);
    HRESULT MergeTableCells(void);
    HRESULT SplitTableCell(void);
    HRESULT SplitTableCell(IDispatch *srpTable, INT iRow, INT index);
    HRESULT MergeTableCells(IDispatch* srpTable, INT iRow, INT iIndexStart, INT iIndexEnd);
    HRESULT InsertTable(VARIANTARG *pvarargIn=NULL);
    HRESULT MapCellToFirstRowCell(IDispatch *srpTable, struct SELCELLINFO *pselinfo);
    HRESULT GetTableRowElementAndTableFromCell(IDispatch *srpCell, LONG *pindexRow = NULL, IDispatch **srpRow=NULL,IDispatch **srpTable=NULL);
    BOOL FEnableInsertTable(void);
    HRESULT DeleteTable(IHTMLElement *pTable);
    inline HRESULT DeleteRowEx(IHTMLElement *pTable, LONG index);
    inline HRESULT DeleteCellEx(IHTMLElement *pTable, IDispatch *pRow, LONG indexRow, LONG indexCell);
    
    //Helpers
    void SetUpDefaults(void);
    void SetUpGlyphTable(BOOL);
    HRESULT MapTriEditCommand(ULONG cmdTriEdit, ULONG *pcmdTrident);
    void Draw2DDragRect(BOOL fDraw);
    HRESULT GetElement(BOOL fDragDrop = FALSE);
    void ReleaseElement(void);
    HRESULT GetScrollPosition(void);
    HRESULT DragScroll(POINT pt);
    HRESULT CalculateNewDropPosition(POINT *pt);
    BOOL IsDragSource(void);
    BOOL IsDesignMode(void);
    HRESULT IsLocked(IHTMLElement* pihtmlElement, BOOL* pfLocked);
    HRESULT ConstrainXY(LPPOINT lppt);
    HRESULT SnapToGrid(LPPOINT lppt);
    HRESULT GetElementPosition(IHTMLElement* pihtmlElement, LPRECT prc);
    STDMETHOD (GetDocument)(IHTMLDocument2** ppihtmlDoc2);
    STDMETHOD (GetAllCollection)(IHTMLElementCollection** ppihtmlCollection);
    STDMETHOD (GetCollectionElement)(IHTMLElementCollection* ppihtmlCollection,
        LONG iIndex,
        IHTMLElement** ppihtmlElem);
    STDMETHOD (Is2DCapable)(IHTMLElement* pihtmlElement, BOOL* pfBool);
    STDMETHOD (GetTridentWindow)();
    STDMETHOD (SelectElement)(IHTMLElement* pihtmlElement, IHTMLElement* pihtmlElementParent);
    HRESULT IsElementDTC(IHTMLElement *pihtmlElement);
    HRESULT GetCharset(HGLOBAL hgUHTML, int cbSizeIn, BSTR* pbstrCharset);
#ifdef IE5_SPACING
    BOOL m_fFilterInDone;
#endif //IE5_SPACING

    // utility inlines
    inline BOOL IsIE5OrBetterInstalled()
    {
        BOOL fIsIE5AndBeyond = FALSE;
        CComPtr<IHTMLDocument3> pHTMLDoc3 = NULL;

        // check if we have IE5 or better installed
        if (   m_pUnkTrident != NULL
            && S_OK == m_pUnkTrident->QueryInterface(IID_IHTMLDocument3, (void **) &pHTMLDoc3)
            && pHTMLDoc3 != NULL
            )
        {
            fIsIE5AndBeyond = TRUE;
        }
        return(fIsIE5AndBeyond);
    }

public:
    CTriEditDocument();

DECLARE_AGGREGATABLE(CTriEditDocument)
DECLARE_REGISTRY_RESOURCEID(IDR_TRIEDITDOCUMENT)

BEGIN_COM_MAP(CTriEditDocument)
    COM_INTERFACE_ENTRY(ITriEditDocument)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
    COM_INTERFACE_ENTRY(IDropTarget)
    COM_INTERFACE_ENTRY(ITriEditExtendedAccess)
#ifdef IE5_SPACING
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IPersistStream)
#endif //IE5_SPACING
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pUnkTrident)
END_COM_MAP()

friend class CTriEditUIHandler;

};

class CTriEditUIHandler : public IDocHostUIHandler
{

public:
    ULONG            m_cRef;
    CTriEditDocument *m_pDoc;

    CTriEditUIHandler(CTriEditDocument *pDoc) { m_cRef = 1; m_pDoc = pDoc; }
    ~CTriEditUIHandler(void) {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDocHostUIHandler

    STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo);
    STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject,
                        IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame,
                        IOleInPlaceUIWindow* pDoc);
    STDMETHOD(HideUI)();
    STDMETHOD(UpdateUI)();
    STDMETHOD(EnableModeless)(BOOL fEnable);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow);
    STDMETHOD(ShowContextMenu)(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget,
                                 IDispatch* pDispatchObjectHit);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID __RPC_FAR *pguidCmdGroup, DWORD nCmdID);
    STDMETHOD(GetOptionKeyPath)(LPOLESTR* pbstrKey, DWORD dw);
    STDMETHOD(GetDropTarget)(IDropTarget __RPC_FAR *pDropTarget,
                               IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget);
    STDMETHOD(GetExternal)(IDispatch **ppDispatch);
    STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    STDMETHOD(FilterDataObject)(IDataObject *pDO, IDataObject **ppDORet);
};

#ifdef IE5_SPACING
/////////////////////////////////////////////////////////////////////
//
class ATL_NO_VTABLE CBaseTridentEventSink :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatch
{
public:

BEGIN_COM_MAP(CBaseTridentEventSink)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT *) 
        { return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **)  
        { return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR**, UINT, LCID, DISPID*)  
        { return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, USHORT, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
         { return S_OK; }

public:
    HRESULT Advise(IUnknown* pUnkSource, REFIID riidEventInterface);
    void    Unadvise(void);

    CBaseTridentEventSink()
        {
            m_dwCookie = 0;
            m_pUnkSource  = NULL;

            ::ZeroMemory(&m_iidEventInterface, sizeof(m_iidEventInterface));
        }
            

protected:
    DWORD               m_dwCookie;
    IUnknown*           m_pUnkSource;

    GUID                m_iidEventInterface;
public:
    IHTMLDocument2*     m_pHTMLDocument2;
    CTriEditDocument*   m_pTriEditDocument;
};

class CTridentEventSink: public CBaseTridentEventSink
{
public:
    // IDispatch
    STDMETHOD(Invoke)(DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);
};
#endif //IE5_SPACING

#endif //__DOCUMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\filter.cpp ===
// filter.cpp : Implementation of filtering/parsing of the document
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"

#include "triedit.h"
#include "Document.h"
#include "guids.h"
#include "HtmParse.h"

STDMETHODIMP CTriEditDocument::FilterIn(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL)
{
    HGLOBAL hOld, hNew;
    HRESULT hr;
    IStream *pStmOld;
    UINT    chSize;
    ULARGE_INTEGER li;
    int cbSizeIn = -1;
    STATSTG stat;

    if (pUnkOld == NULL)
        return E_INVALIDARG;

    hr = pUnkOld->QueryInterface(IID_IStream, (void **) &pStmOld);
    if (hr != S_OK)
        return E_INVALIDARG;

    if ((hr = pStmOld->Stat(&stat, STATFLAG_NONAME)) == S_OK)
    {
        cbSizeIn = stat.cbSize.LowPart;
        _ASSERTE(stat.cbSize.HighPart == 0); // This will ensure that we don't have a doc larger than 4 gigabytes
    }

    if (GetHGlobalFromStream(pStmOld, &hOld) != S_OK)
    {
        pStmOld->Release();
        return E_INVALIDARG;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
        *ppUnkNew = NULL;

    hr = DoFilter(hOld, &hNew, (IStream*) *ppUnkNew, dwFlags, modeInput, cbSizeIn, &chSize, bstrBaseURL);
#ifdef IE5_SPACING
    if (!(dwFlags & dwFilterNone) && hr == S_OK)
        SetFilterInDone(TRUE);
#endif //IE5_SPACING
    if (hr != S_OK)
    {
        pStmOld->Release();
        return hr;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
    {
        _ASSERTE(hNew != NULL);
        hr = CreateStreamOnHGlobal(hNew, TRUE, (IStream **) ppUnkNew);
        if (FAILED(hr))
            GlobalFree(hNew);
    }
        
    if (SUCCEEDED(hr))
    {
        li.LowPart = chSize;
        li.HighPart = 0;
        (*((IStream**)ppUnkNew))->SetSize(li);
    }

    pStmOld->Release();
    return hr;
}

STDMETHODIMP CTriEditDocument::FilterOut(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL)
{
    HGLOBAL hOld, hNew;
    HRESULT hr;
    IStream *pStmOld;
    UINT    chSize;
    ULARGE_INTEGER li;
    int cbSizeIn = -1;
    STATSTG stat;

    if (pUnkOld == NULL)
        return E_INVALIDARG;

    hr = pUnkOld->QueryInterface(IID_IStream, (void **) &pStmOld);
    if (hr != S_OK)
        return E_INVALIDARG;

    if ((hr = pStmOld->Stat(&stat, STATFLAG_NONAME)) == S_OK)
    {
        cbSizeIn = stat.cbSize.LowPart;
        _ASSERTE(stat.cbSize.HighPart == 0); // This will ensure that we don't have a doc larger than 4 gigabytes
    }

    if (GetHGlobalFromStream(pStmOld, &hOld) != S_OK)
    {
        pStmOld->Release();
        return E_INVALIDARG;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
        *ppUnkNew = NULL;

    hr = DoFilter(hOld, &hNew, (IStream *) *ppUnkNew, dwFlags, modeOutput, cbSizeIn, &chSize, bstrBaseURL);
    if (hr != S_OK)
    {
        pStmOld->Release();
        return hr;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
    {
        _ASSERTE(hNew != NULL);
        hr = CreateStreamOnHGlobal(hNew, TRUE, (IStream **) ppUnkNew);
        if (FAILED(hr))
            GlobalFree(hNew);
    }

    if (SUCCEEDED(hr))
    {
        li.LowPart = chSize;
        li.HighPart = 0;
        (*((IStream**)ppUnkNew))->SetSize(li);
    }

    pStmOld->Release();
    return hr;
}

HRESULT CTriEditDocument::DoFilter(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew, DWORD dwFlags, FilterMode mode, int cbSizeIn, UINT* pcbSizeOut, BSTR bstrBaseURL)
{
    HRESULT hr;
    HGLOBAL hgTokArray;
    UINT cMaxToken;

    // Create tokenizer if it hasn't yet been created
    if (m_pTokenizer == NULL)
    {
        hr = ::CoCreateInstance(CLSID_TriEditParse, NULL, CLSCTX_INPROC_SERVER, IID_ITokenGen, (void **)&m_pTokenizer);
        if (hr != S_OK)
            return hr;
    }

    _ASSERTE(m_pTokenizer != NULL);

    _ASSERTE(dwFilterDefaults == 0);
    if ((dwFlags & ~(dwFilterMultiByteStream|dwFilterUsePstmNew)) == dwFilterDefaults) // means that caller wants us to set the flags
    {
        dwFlags |= (dwFilterDTCs|dwFilterServerSideScripts|dwPreserveSourceCode);
    }

    hr = m_pTokenizer->hrTokenizeAndParse(hOld, phNew, pStmNew, dwFlags, mode, cbSizeIn, pcbSizeOut, m_pUnkTrident, &hgTokArray, &cMaxToken, &m_hgDocRestore, bstrBaseURL, 0/*dwReserved*/);

    if (hgTokArray != NULL)
    {
        GlobalFree(hgTokArray); // hrTokenizeAndParse() would have unlocked it.
    }

    return hr;
}


//	Parse the document for a charset specification.
//	They can take the following forms:
//		<META CHARSET=XXX>
//		<META HTTP_EQUIV CHARSET=XXX>
//		<META HTTP_EQUIV="Content-type" CONTENT="text/html; charset=XXX">
//		<META HTTP_EQUIV="Charset" CONTENT="text/html; charset=XXX">
//
//	Return S_OK if found, S_FALSE if not found.  Error on exceptional cases.

HRESULT CTriEditDocument::GetCharset(HGLOBAL hgUHTML, int cbSizeIn, BSTR* pbstrCharset)
{
	HRESULT hr = E_FAIL;
	HGLOBAL hgTokArray = NULL; // holds the token array
	UINT cMaxToken; // size of token array
	UINT cbSizeOut = 0; // init
	HGLOBAL hNew = NULL; // not really used. need to pass as params to hrTokenizeAndParse()
	int iArray = 0;
	TOKSTRUCT *pTokArray;
	BOOL fFoundContent = FALSE;
	BOOL fFoundCharset = FALSE;
	HRESULT	hrCharset = S_FALSE;	// This is the error code to return if no other error occurs

	_ASSERTE ( bstrIn );
	_ASSERTE ( pbstrCharset );
	_ASSERTE ( hgUHTML );

	if ( ( cbSizeIn <= 0 ) || ( NULL == hgUHTML ) )
		goto LRet;

	*pbstrCharset = NULL;

	// step 1. generate a token array
	// Create tokenizer if it hasn't yet been created
	if (m_pTokenizer == NULL)
	{
		CoCreateInstance(CLSID_TriEditParse, NULL, CLSCTX_INPROC_SERVER, IID_ITokenGen, (void **)&m_pTokenizer);
		if (m_pTokenizer == NULL)
		{
			hr = E_FAIL;
			goto LRet;
		}
	}

	hr = m_pTokenizer->hrTokenizeAndParse(	hgUHTML, &hNew, NULL, dwFilterNone, 
												modeInput, cbSizeIn, &cbSizeOut, m_pUnkTrident, 
												&hgTokArray, &cMaxToken, NULL, NULL, 
												PARSE_SPECIAL_HEAD_ONLY );

	if (hr != S_OK || hgTokArray == NULL)
		goto LRet;
	pTokArray = (TOKSTRUCT *) GlobalLock(hgTokArray);
	if (pTokArray == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto LRet;
	}

	// step 2. look for TokAttrib_CHARSET in the META tag it.
	iArray = 0;
	while (iArray < (int)cMaxToken) // we won't go this far and will get the META tag before we hit </head>
	{
		// If a META tag is found with a CONTENT attribute, explore it.
		if ( ( pTokArray[iArray].token.tok == TokAttrib_CONTENT )
			&& pTokArray[iArray].token.tokClass == tokAttr)
		{
			fFoundContent = TRUE;			
		}
		// If a META tag is fount with a CHARSET attribute, explor it as well.
		if ( ( pTokArray[iArray].token.tok == TokAttrib_CHARSET )
			&& pTokArray[iArray].token.tokClass == tokAttr)
		{
			fFoundCharset = TRUE;			
		}

		if ( ( fFoundContent || fFoundCharset )
			&& (   pTokArray[iArray].token.tokClass == tokValue
				|| pTokArray[iArray].token.tokClass == tokString
				)
			)
		{
			// get its value, put it in pbstrCharset and return
			int cwContent = pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin;
			WCHAR *pwContent = new WCHAR[cwContent+1];
			WCHAR* pwCharset = NULL; // This represents a movable pointer, not an allocation.

			if (pwContent != NULL)
			{
				pwContent[0]   = WCHAR('\0');
				WCHAR* pwcText = (WCHAR*)GlobalLock ( hgUHTML );
				if ( NULL == pwcText )
				{
					hr = E_OUTOFMEMORY;
					goto LRet;
				}
				memcpy(	(BYTE *)pwContent, 
						(BYTE *)&pwcText[pTokArray[iArray].token.ibTokMin], 
						cwContent*sizeof(WCHAR));
				pwContent[cwContent] = WCHAR('\0');

				GlobalUnlock ( hgUHTML );
				_wcslwr ( pwContent );

				if ( fFoundCharset )
				{
					pwCharset = pwContent;
				}

				// If it's a CONTENT attribute, this string actually contains something like
				// "text/html; charset=something".  We need to return only the "something" part.
				if ( fFoundContent )
				{
					// Find the "charset", case insensitive.
					pwCharset = wcsstr ( pwContent, L"charset" );

					// Find the equal sign following the charset
					if ( NULL != pwCharset )
					{
						pwCharset = wcsstr ( pwContent, L"=" );
					}

					// Find the charset name itself. There could be spaces between the = and the name.
					if ( NULL != pwCharset )
					{
						WCHAR wc = '\0';

						// Skip the equal sign we just found:
						pwCharset++;

						// Pick up a character.  It should never be \0, but could be for ill formed HTML.
						while ( WCHAR('\0') != ( wc = *pwCharset ) )
						{
							if ( iswspace(wc) || WCHAR('\'') == wc )
							{
								pwCharset++;
							}
							else
							{
								break;
							}
						}
					}

					// Now terminate the charset name.  It could have trailing spaces, a closing quote, a semi-colon, etc.
					if ( NULL != pwCharset )
					{
						pwCharset = wcstok ( pwCharset, L" \t\r\n\"\';" );	// First token not containing whitespace, quote or semicolon
					}
				}

				// If it was not found, try again.
				if ( NULL == pwCharset )
				{
					delete [] pwContent;
					fFoundContent = FALSE;
					fFoundCharset = FALSE;
					continue;
				}

				*pbstrCharset = SysAllocString(pwCharset);
				if (*pbstrCharset != NULL)
				{
					hrCharset = S_OK;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				delete [] pwContent;
			}
			break; // even if we didn't succeed in above allocations, we should quit because we already found the charset
		}
		iArray++;
	}

LRet:
	if (hgTokArray != NULL)
	{
		GlobalUnlock(hgTokArray);
		GlobalFree(hgTokArray);
	}
	if (hNew != NULL)
		GlobalFree(hNew); // hrTokenizeAndParse() would have unlocked it.

	// If no error occurred, return S_OK or S_FALSE indicating if the charset was found:
	if ( SUCCEEDED ( hr ) )
	{
		hr = hrCharset;
	}
	return(hr);

} /* CDocument::GetCharset() */


//	Given a stream, created on a global, find any META charset tag that might exist in it.
//	The input stream may be in Unicode or MBCS: Unicode streams MUST be byte-order prefixed.
//	The stream pos will not be affected by this operation, nor will its contents be changed.
//	If the stream is in Unicode, in either byte order, the charset "unicode" is returned,
//	because this routine is primarily of interest in converting streams to unicode.
//
//	If the input stream is empty, or if no META charset tag exists, return S_FALSE and NULL
//	for pbstrCharset.
//	If a charset tag is found, return S_OK and allocate a SysString for pbstrCharset.
//	The caller must call SysFreeString if pbstrCharset is returned.
//
HRESULT CTriEditDocument::GetCharsetFromStream(IStream* pStream, BSTR* pbstrCharset)
{
	HRESULT	hr			= S_OK;
	STATSTG	statStg		= {0};
	HGLOBAL hMem		= NULL;
	CHAR*	pbData		= NULL;
	WCHAR*	pwcUnicode	= NULL;
	HGLOBAL	hgUHTML		= NULL;
	UINT	cbNewSize	= 0;

	_ASSERTE ( pbstrCharset );
	*pbstrCharset = NULL;

	if (FAILED(hr = pStream->Stat(&statStg, STATFLAG_NONAME)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	if ( 0 == statStg.cbSize.LowPart )
	{
		return S_FALSE;
	}

	if (FAILED(hr = GetHGlobalFromStream(pStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	pbData = (CHAR*)GlobalLock(hMem);
	if (NULL == pbData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		_ASSERTE(pbData);
		return hr;		
	}

	// If the stream is already in Unicode, that's all we need to know.
	if ( 0xfffe == *((WCHAR*)pbData) )
	{
		*pbstrCharset = SysAllocString ( L"Unicode" );
		hr = S_OK;
		goto LRet;
	}

	// Convert the SBCS or MBCS stream to Unicode as ANSI.
	// This will be adequate for finding the charset META tag.

	cbNewSize = ::MultiByteToWideChar ( CP_ACP, 0, pbData, statStg.cbSize.LowPart, NULL, 0 );
	if ( 0 == cbNewSize )
	{
		hr = E_FAIL;
		goto LRet;
	}

	// Create the buffer to convert to.
	hgUHTML = GlobalAlloc ( GMEM_MOVEABLE|GMEM_ZEROINIT, (cbNewSize + 1) * sizeof(WCHAR) );
	_ASSERTE ( hgUHTML );
	if ( NULL == hgUHTML )
	{
		hr = E_OUTOFMEMORY;
		goto LRet;
	}

	pwcUnicode = (WCHAR*)GlobalLock ( hgUHTML );
	_ASSERTE ( pwcUnicode );
	if ( NULL == hgUHTML )
	{
		hr = E_OUTOFMEMORY;
		goto LRet;
	}

	// Create the wide string.
	cbNewSize = ::MultiByteToWideChar ( CP_ACP, 0, pbData, statStg.cbSize.LowPart, pwcUnicode, cbNewSize);
	if ( 0 == cbNewSize )
	{
		hr = E_FAIL;
		goto LRet;
	}

	hr = GetCharset ( hgUHTML, cbNewSize * sizeof(WCHAR), pbstrCharset );

LRet:
	if ( NULL != hgUHTML )	{
		GlobalUnlock ( hgUHTML );
		GlobalFree ( hgUHTML );
	}

	GlobalUnlock ( hMem );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\guids.h ===
// guids.h: definitions of GUIDs/IIDs/CLSIDs used in TriEdit
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//

//#ifndef __GUIDS_H__
//#define __GUIDS_H__

// IID_ITokenGen for interface in token.h
DEFINE_GUID(IID_ITokenGen,
0x1106aec0, 0xfe30, 0x11d0, 0xb0, 0x79, 0x00, 0x60, 0x08, 0x05, 0x8a, 0x0e);

// IID_IPersistTextStream and IID_IActiveDesigner for DTC filtering
DEFINE_GUID(IID_IPersistTextStream,
0x56223fe3, 0xd397, 0x11cf, 0xa4, 0x2e, 0x00, 0xaa, 0x00, 0xc0, 0x09, 0x40);

DEFINE_GUID(IID_IActiveDesigner,
0x51aae3e0, 0x7486, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// Page Transition DTC
DEFINE_GUID(CLSID_PageTr,
0x8EA785B1, 0x4738, 0x11D1, 0xB4, 0x7C, 0x0, 0xA0, 0xC9, 0x59, 0xBB, 0x15);

// Trident's Command Set
DEFINE_GUID(CMDSETID_Forms3,
0xDE4BA900, 0x59CA, 0x11CF, 0x95, 0x92, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

// TriEditParse
DEFINE_GUID(CLSID_TriEditParse, 
0x010E6CBE, 0xFE2B, 0x11D0, 0xB0, 0x79, 0x00, 0x60, 0x08, 0x05, 0x8A, 0x0E);

#define IE5_SPACING
#ifdef IE5_SPACING
// ie5 specific - temporary use
DEFINE_GUID(IID_IHTMLUniqueName, 
0x3050f4d0, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEFINE_GUID(IID_IHTMLDocument3, 
0x3050f485, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);
#endif //IE5_SPACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\fmtinfo.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __FMTINFO_H__
#define __FMTINFO_H__


#define RGB_BLACK       RGB(0x00, 0x00, 0x00)
#define RGB_WHITE       RGB(0xFF, 0xFF, 0xFF)
#define RGB_RED         RGB(0xFF, 0x00, 0x00)
#define RGB_GREEN       RGB(0x00, 0xFF, 0x00)
#define RGB_BLUE        RGB(0x00, 0x00, 0xFF)
#define RGB_YELLOW      RGB(0xFF, 0xFF, 0x00)
#define RGB_MAGENTA     RGB(0xFF, 0x00, 0xFF)
#define RGB_CYAN        RGB(0x00, 0xFF, 0xFF)
#define RGB_LIGHTGRAY   RGB(0xC0, 0xC0, 0xC0)
#define RGB_GRAY        RGB(0x80, 0x80, 0x80)
#define RGB_DARKRED     RGB(0x80, 0x00, 0x00)
#define RGB_DARKGREEN   RGB(0x00, 0x80, 0x00)
#define RGB_DARKBLUE    RGB(0x00, 0x00, 0x80)
#define RGB_LIGHTBROWN  RGB(0x80, 0x80, 0x00)
#define RGB_DARKMAGENTA RGB(0x80, 0x00, 0x80)
#define RGB_DARKCYAN    RGB(0x00, 0x80, 0x80)

// IMPORTANT: These macros depend heavily on the order of things in colors.cpp.
//    1) The order of colors in window must be Source Text, Text Selection, Text Highlight.
#define AUTO_TEXT           { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },  { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define AUTO_SELECTION      { TRUE, FALSE, FALSE, TRUE, FALSE, 0 },                 { TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define AUTO_HIGHLIGHT      { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },   { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define AUTO_REF(n)         { TRUE, FALSE, FALSE, FALSE, FALSE, n },    { TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define AUTO_REF_SRC(n)     { TRUE, FALSE, TRUE, FALSE, FALSE, n },     { TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define BACKAUTO_TEXT           { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT }, { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define BACKAUTO_SELECTION      { FALSE, FALSE, FALSE, TRUE, FALSE, 0 },                    { TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define BACKAUTO_HIGHLIGHT      { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },  { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define BACKAUTO_REF(n)         { FALSE, FALSE, FALSE, FALSE, FALSE, n },   { TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define BACKAUTO_REF_SRC(n)     { FALSE, FALSE, TRUE, FALSE, FALSE, n },    { TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define NOTAUTO_TEXT        { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT }, { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define NOTAUTO_SELECTION   { FALSE, FALSE, FALSE, TRUE, FALSE, 0 },    { FALSE, FALSE, FALSE, TRUE, FALSE, 0 }
#define NOTAUTO_HIGHLIGHT   { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },  { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define NOTAUTO_REF(n)      { FALSE, FALSE, FALSE, FALSE, FALSE, n },       { FALSE, FALSE, FALSE, FALSE, FALSE, n }
#define NOTAUTO_REF_SRC(n)  { FALSE, FALSE, TRUE, FALSE, FALSE, n },        { FALSE, FALSE, TRUE, FALSE, FALSE, n }

struct AUTO_COLOR
{
    WORD    bOn:1;      // Is auto color being used now?
    WORD    bSys:1;     // Get the color from the system(1) or from a window(0)?
    WORD    bSrc:1;     // If bSys == 0, use this window(0) or the Source Window(1)?
    WORD    bRev:1;     // If from this window, reverse fore/background(1)?
    WORD    bUpd:1;     // Used by UpdateAutoColors().
    WORD    index:5;    // Index into element list(bSys==0) or COLOR_* value (bSys==1).
};



#endif /* __FMTINFO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\idhuihnd.cpp ===
//------------------------------------------------------------------------------
// idhuihnd.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      6-27-97     created     (bash)
//
// Implementation of IDocHostUIHandler.
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include "triedit.h"
#include "document.h"

STDMETHODIMP CTriEditUIHandler::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

    if ( IID_IDocHostUIHandler == riid || IID_IUnknown == riid )
    {
        *ppv = this;
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTriEditUIHandler::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CTriEditUIHandler::Release(void)
{
    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    return 0;
}

STDMETHODIMP CTriEditUIHandler::GetHostInfo(DOCHOSTUIINFO* pInfo)
{
    ATLTRACE(_T("IDocHostUIImpl::GetHostInfo\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->GetHostInfo(pInfo);

// REVIEW(MikhailA): remove this as soon as we start using IE5 headers VS-wide
#define DOCHOSTUIFLAG_TABSTOPONBODY 0x0800 // MikhailA: From IE5 headers

    pInfo->dwFlags = DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_TABSTOPONBODY;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::ShowUI(DWORD dwID, IOleInPlaceActiveObject* pActiveObject,
                    IOleCommandTarget* /*pCommandTarget*/, IOleInPlaceFrame* pFrame,
                    IOleInPlaceUIWindow* pDoc)
{
    // ATLTRACE(_T("IDocHostUIImpl::ShowUI\n"));  Turn this off for now

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->ShowUI(dwID, pActiveObject, static_cast<IOleCommandTarget*>(m_pDoc), pFrame, pDoc);

    return S_FALSE;
}

STDMETHODIMP CTriEditUIHandler::HideUI()
{
    // ATLTRACE(_T("IDocHostUIImpl::HideUI\n"));  Turn this off for now

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->HideUI();

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::UpdateUI()
{
    // ATLTRACE(_T("IDocHostUIImpl::UpdateUI\n"));  Turn this off for now

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->UpdateUI();

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::EnableModeless(BOOL fEnable)
{
    ATLTRACE(_T("IDocHostUIImpl::EnableModeless\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->EnableModeless(fEnable);
    
    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    ATLTRACE(_T("IDocHostUIImpl::OnDocWindowActivate\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->OnDocWindowActivate(fActivate);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    ATLTRACE(_T("IDocHostUIImpl::OnFrameWindowActivate\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->OnFrameWindowActivate(fActivate);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
{
    ATLTRACE(_T("IDocHostUIImpl::ResizeBorder\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->ResizeBorder(prcBorder, pUIWindow, fFrameWindow);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::ShowContextMenu(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget,
                             IDispatch* pDispatchObjectHit)
{
    ATLTRACE(_T("IDocHostUIImpl::ShowContextMenu\n"));

    if (m_pDoc->m_pUIHandlerHost)
    {
        HRESULT hr = S_OK;

        // Work around a Trident bug where they call ShowContextMenu recursively under some circumstances
        if (!m_pDoc->m_fInContextMenu)
        {
            m_pDoc->m_fInContextMenu = TRUE;
            hr = m_pDoc->m_pUIHandlerHost->ShowContextMenu(dwID, pptPosition, pCommandTarget, pDispatchObjectHit);
            m_pDoc->m_fInContextMenu = FALSE;
        }

        ATLTRACE(_T("Returning From IDocHostUIImpl::ShowContextMenu\n"));
        return hr;
    }

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::TranslateAccelerator(LPMSG lpMsg, const GUID __RPC_FAR *pguidCmdGroup, DWORD nCmdID)
{
    // ATLTRACE(_T("IDocHostUIImpl::TranslateAccelerator\n"));  Turn this off for now.

    // This is where we would add code if we wanted to handle any accelerators in TriEdit
    
    HRESULT hr  = S_FALSE;  // Defualt return value: not handled

    if (m_pDoc->m_pUIHandlerHost)
    {
        hr = m_pDoc->m_pUIHandlerHost->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
    }

    // Kill ctrl-g and ctrl-h before they reach Trident: erronious handling attempts to bring up
    // non-existant html dialogs for Go and Replace.
    if ( ( S_FALSE == hr ) && ( lpMsg->message == WM_KEYDOWN ) )
    {
        BOOL fControl = (0x8000 & GetKeyState(VK_CONTROL));
        BOOL fShift = (0x8000 & GetKeyState(VK_SHIFT));
        if ( fControl && !fShift )
        {
            switch ( lpMsg->wParam )
            {
                case 'G':
                case 'H':
                    hr = S_OK;  // Consider them handled.
                default:
                    break;
            }
        }
    }

    return hr;
}

STDMETHODIMP CTriEditUIHandler::GetOptionKeyPath(LPOLESTR* pbstrKey, DWORD dw)
{
    ATLTRACE(_T("IDocHostUIImpl::GetOptionKeyPath\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->GetOptionKeyPath(pbstrKey, dw);
    
    *pbstrKey = NULL;
    return S_FALSE;
}

STDMETHODIMP CTriEditUIHandler::GetDropTarget(IDropTarget __RPC_FAR *pDropTarget,
                           IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget)
{
    ATLTRACE(_T("IDocHostUIImpl::GetDropTarget\n"));

    SAFERELEASE(m_pDoc->m_pDropTgtTrident);

    m_pDoc->m_pDropTgtTrident = pDropTarget;
    m_pDoc->m_pDropTgtTrident->AddRef();

    if (NULL == m_pDoc->m_pUIHandlerHost ||
        S_OK != m_pDoc->m_pUIHandlerHost->GetDropTarget(static_cast<IDropTarget*>(m_pDoc), ppDropTarget))
    {
        *ppDropTarget = static_cast<IDropTarget*>(m_pDoc);
        (*ppDropTarget)->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::GetExternal(IDispatch **ppDispatch)
{
    ATLTRACE(_T("IDocHostUIImpl::GetExternal\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->GetExternal(ppDispatch);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    ATLTRACE(_T("IDocHostUIImpl::TranslateUrl\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    ATLTRACE(_T("IDocHostUIImpl::FilterDataObject\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->FilterDataObject(pDO, ppDORet);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\htmparse.h ===
// HtmParse.h : Declaration of the CHtmParse
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __HTMPARSE_H_
#define __HTMPARSE_H_

#include "resource.h"       // main symbols
#include "guids.h"
#include "lexhtml.h"
#include "token.h"

#define tokClsIgnore tokclsError // if you don't want to use the token class info in the rule, use this.

#define cbBufPadding 0x800 // we allocate this much extra memory so that subsequent reallocs are saved
#define MIN_TOK 100 // init size for token stack to keep track of nested blocks. e.g. <table>...<table>...</table>...</table>

// init value for number of <TBODY> tags
#define cTBodyInit 20 // init size of nested TBODY's. we start with the assumption that we won't have more than these many nested TBODYs and reallocate if needed.

#define cchspBlockMax 20 // size of spacing block index. we can't have more than 20 digit number
// state flags for space preservation
#define initState   0x0000
#define inChar      0x0001
#define inSpace     0x0002
#define inEOL       0x0003
#define inTab       0x0004
#define inTagOpen   0x0005
#define inTagClose  0x0006
#define inTagEq     0x0007

// used by space preservation in comments
#define chCommentSp '2'
#define chCommentEOL '3'
#define chCommentTab '4'

// Specializations for hrTokenizeAndParse
#define PARSE_SPECIAL_NONE		0x00000000
#define PARSE_SPECIAL_HEAD_ONLY	0x00000001

/////////////////////////////////////////////////////////////////////////////
// CTriEditParse
class ATL_NO_VTABLE CTriEditParse : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTriEditParse, &CLSID_TriEditParse>,
    public ITokenGen
{
public:
    CTriEditParse();
    ~CTriEditParse();

DECLARE_REGISTRY_RESOURCEID(IDR_TRIEDITPARSE)

BEGIN_COM_MAP(CTriEditParse)
    COM_INTERFACE_ENTRY_IID(IID_ITokenGen, ITokenGen)
END_COM_MAP()



// ITokenGen // copied from CColorHtml
public:
    STDMETHOD(NextToken)(LPCWSTR pszText, UINT cbText, UINT* pcbCur, DWORD * pLXS, TXTB* pToken);
    STDMETHOD(hrTokenizeAndParse)(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew, DWORD dwFlags, FilterMode mode, int cbSizeIn, UINT* pcbSizeOut, IUnknown* pUnkTrident, HGLOBAL *phgTokArray, UINT *pcMaxToken, HGLOBAL *phgDocRestore, BSTR bstrBaseURL, DWORD dwReserved);

private:
    static long m_bInit;
    PSUBLANG    m_rgSublang;

    IUnknown *m_pUnkTrident; // we cache it in hrTokenizeAndParse()
    HGLOBAL m_hgDocRestore; // we cache it in hrTokenizeAndParse()
    LPWSTR m_bstrBaseURL;

    // flag used to remember if we have a unicode file that has 0xff,0xfe at the begining
    BOOL m_fUnicodeFile;

    // following m_c's keep track of number of respective tags found
    // during parsing. e.g. m_cHtml will keep track of count of 
    // <html> tags
    INT m_cHtml;
    INT m_cDTC;
    INT m_cObj;
    INT m_cSSSIn;
    INT m_cSSSOut;
    INT m_cNbsp;
    INT m_cHdr;
    INT m_cFtr;
    INT m_cObjIn;
    INT m_cComment;
    INT m_cAImgLink;

    UINT m_cMaxToken;       // Max of token array (pTokArray)
    BOOL m_fEndTagFound;    // end tag found
    INT  m_iControl;        // index in applet collection
    BOOL m_fSpecialSSS;     // found special SSS <%@....%>

    // used to save space preservation info
    HGLOBAL m_hgspInfo;
    WORD *m_pspInfo;
    WORD *m_pspInfoOut;
    WORD *m_pspInfoOutStart;
    WORD *m_pspInfoCur;
    UINT m_ichStartSP;          // save all prev spacing info at this ich
    INT m_ispInfoBase;
    INT m_ispInfoIn;
    INT m_ispInfoOut;
    INT m_iArrayspLast;
    INT m_ispInfoBlock;
    INT m_cchspInfoTotal;
    BOOL m_fDontDeccItem;       // we don't have counters for items that we don't process, so we use this to preserve the total count
    
    // used by <TBODY> code.
    // Trident puts in extra <tbody></tbody> tags inside table
    // and filtering tries to remove them.
    HGLOBAL m_hgTBodyStack;
    UINT *m_pTBodyStack;
    INT m_iMaxTBody;
    INT m_iTBodyMax;

    // used by Page Transition DTC code
    // page transition dtc is a special case in filtering because 
    // we have to maintain its location inside the head section.
    BOOL m_fInHdrIn;
    INT m_cchPTDTCObj;
    INT m_ichPTDTC;
    INT m_cchPTDTC;
    INT m_indexBeginBody;
    INT m_indexEndBody;
    WCHAR *m_pPTDTC;
    HGLOBAL m_hgPTDTC;

    // used by the code that recreates our own pre-Body part of the document
    BOOL m_fHasTitleIn;
    INT m_indexTitleIn;
    INT m_ichTitleIn;
    INT m_cchTitleIn;
    INT m_ichBeginBodyTagIn;
    INT m_indexHttpEquivIn;
    INT m_ichBeginHeadTagIn;

    // used by APPLET pretty-printing code
    int m_cAppletIn;
    int m_cAppletOut;

    // used to keep track of multiple occurances of BODY, HTML, TITLE & HEAD tags
    int m_cBodyTags;
    int m_cHtmlTags;
    int m_cTitleTags;
    int m_cHeadTags;

    void SetTable(DWORD lxs);
    void InitSublanguages();
    void PreProcessToken(TOKSTRUCT *pTokArray, INT *pitokCur, LPWSTR pszText, UINT cbCur, TXTB token, DWORD lxs, INT tagID, FilterMode mode);
    void PostProcessToken(OLECHAR *pwOld, OLECHAR *pwNew, UINT *pcbNew, UINT cbCur, UINT cbCurSav, TXTB token, FilterMode mode, DWORD lxs, DWORD dwFlags);
    int ValidateTag(LPWSTR pszText);
    int GetTagID(LPWSTR pszText, TXTB token);
    HRESULT hrMarkSpacing(WCHAR *pwOld, UINT cbCur, INT *pchStartSP);
    void SetSPInfoState(WORD inState, WORD *pdwState, WORD *pdwStatePrev, BOOL *pfSave);
    BOOL FRestoreSpacing(LPWSTR pwNew, LPWSTR pwOld, UINT *pichNewCur, INT *pcchwspInfo, INT cchRange, INT ichtoktagStart, BOOL fLookback, INT index);
    HRESULT hrMarkOrdering(WCHAR *pwOld, TOKSTRUCT *pTokArray, INT iArrayStart, INT iArrayEnd, UINT cbCur, INT *pichStartOR);
    BOOL FRestoreOrder(WCHAR *pwNew, WCHAR *pwOld, WORD *pspInfoOrder, UINT *pichNewCur, INT cwOrderInfo, TOKSTRUCT *pTokArray, INT iArrayStart, INT iArrayEnd, INT iArrayDSPStart, INT iArrayDSPEnd, INT cchNewCopy, HGLOBAL *phgNew);
    void SaveSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL *phgNew, TOKSTRUCT *pTokArray, INT iArray, UINT *pichNewCur);
    void RestoreSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL *phgNew, TOKSTRUCT *pTokArray, UINT iArray, UINT *pichNewCur);

    HRESULT ProcessToken(DWORD &lxs, TXTB &tok, LPWSTR pszText, UINT cbCur, TOKSTACK *pTokStack, INT *pitokTop, TOKSTRUCT *pTokArray, INT iArrayPos, INT tagID);
    void FilterHtml(LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, TOKSTRUCT *pTokArray, FilterMode mode, DWORD dwFlags);


    struct FilterTok
    {
        TOKEN tokBegin;
        TOKEN tokBegin2; // supporting token
        TOKEN tokClsBegin;
        TOKEN tokEnd;
        TOKEN tokEnd2; // supporting token
        TOKEN tokClsEnd;
    };

    typedef  void (_stdcall* PFNACTION)(CTriEditParse *, LPWSTR, LPWSTR *, UINT *, HGLOBAL *, TOKSTRUCT *, UINT*, FilterTok, INT*, UINT*, UINT*, DWORD);
    struct FilterRule
    {
        FilterTok ft;
        PFNACTION pfn;
    };

    // Following are static functions. We could make them members, but it wasn't felt necessary then.
    void static fnRestoreDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);

    void static fnRestoreSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);

    void static fnRestoreHtmlTag(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveHtmlTag(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveNBSP(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreNBSP(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnSaveHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnSaveFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreSpaceEnd(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreTbody(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveTbody(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveComment(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreComment(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveTextArea(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreTextArea(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);

    #define cRuleMax 26 /* max number of filtering rules. if you add a new rule above, change this too */
    FilterRule m_FilterRule[cRuleMax];

};


#endif //__HTMPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\icmdtgt.cpp ===
//------------------------------------------------------------------------------
// icmdtgt.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      7-19-97     created     (bash)
//
// Implementation of IOleCommandTarget
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <mshtmcid.h>
#include <designer.h>

//#include "mfcincl.h"
#include "triedit.h"
#include "document.h"
#include "triedcid.h"       //TriEdit Command IDs here.
#include "dispatch.h"
#include "undo.h"

#define CMDSTATE_NOTSUPPORTED  0
#define CMDSTATE_DISABLED      OLECMDF_SUPPORTED
#define CMDSTATE_UP           (OLECMDF_SUPPORTED | OLECMDF_ENABLED)
#define CMDSTATE_DOWN         (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_LATCHED)
#define CMDSTATE_NINCHED      (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED)

// Mapping from TriEdit to Trident commands
typedef struct {
ULONG cmdTriEdit;
ULONG cmdTrident;    
} CMDMAP;

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MapTriEditCommand 
//
// Map the given TriEdit IDM to the equivalent Trident IDM. 
//
// Return:
//   Mapped command under *pCmdTrident and S_OK for a valid command.
//   E_FAIL for an invalid command.
//

HRESULT CTriEditDocument::MapTriEditCommand(ULONG cmdTriEdit, ULONG *pCmdTrident)
{
    static CMDMAP rgCmdMap[] = {
        { IDM_TRIED_ACTIVATEACTIVEXCONTROLS, IDM_NOACTIVATENORMALOLECONTROLS }, 
        { IDM_TRIED_ACTIVATEAPPLETS, IDM_NOACTIVATEJAVAAPPLETS },
        { IDM_TRIED_ACTIVATEDTCS, IDM_NOACTIVATEDESIGNTIMECONTROLS },
        { IDM_TRIED_BACKCOLOR, IDM_BACKCOLOR },
        { IDM_TRIED_BLOCKFMT, IDM_BLOCKFMT },
        { IDM_TRIED_BOLD, IDM_BOLD },
        { IDM_TRIED_BROWSEMODE, IDM_BROWSEMODE },
        { IDM_TRIED_COPY, IDM_COPY },
        { IDM_TRIED_CUT, IDM_CUT },
        { IDM_TRIED_DELETE, IDM_DELETE },
        { IDM_TRIED_EDITMODE, IDM_EDITMODE },
        { IDM_TRIED_FIND, IDM_FIND },
        { IDM_TRIED_FONT, IDM_FONT },
        { IDM_TRIED_FONTNAME, IDM_FONTNAME },
        { IDM_TRIED_FONTSIZE, IDM_FONTSIZE },
        { IDM_TRIED_FORECOLOR, IDM_FORECOLOR },
        { IDM_TRIED_GETBLOCKFMTS, IDM_GETBLOCKFMTS },
        { IDM_TRIED_HYPERLINK, IDM_HYPERLINK },
        { IDM_TRIED_IMAGE, IDM_IMAGE },
        { IDM_TRIED_INDENT, IDM_INDENT },
        { IDM_TRIED_ITALIC, IDM_ITALIC },
        { IDM_TRIED_JUSTIFYCENTER, IDM_JUSTIFYCENTER },
        { IDM_TRIED_JUSTIFYLEFT, IDM_JUSTIFYLEFT },
        { IDM_TRIED_JUSTIFYRIGHT, IDM_JUSTIFYRIGHT },
        { IDM_TRIED_ORDERLIST, IDM_ORDERLIST },
        { IDM_TRIED_OUTDENT, IDM_OUTDENT },
        { IDM_TRIED_PASTE, IDM_PASTE },
        { IDM_TRIED_PRINT, IDM_PRINT },
        { IDM_TRIED_REDO, IDM_REDO },
        { IDM_TRIED_REMOVEFORMAT, IDM_REMOVEFORMAT },
        { IDM_TRIED_SELECTALL, IDM_SELECTALL },
        { IDM_TRIED_SHOWBORDERS, IDM_SHOWZEROBORDERATDESIGNTIME },
        { IDM_TRIED_SHOWDETAILS, IDM_SHOWALLTAGS },
        { IDM_TRIED_UNDERLINE, IDM_UNDERLINE },
        { IDM_TRIED_UNDO, IDM_UNDO },
        { IDM_TRIED_UNLINK, IDM_UNLINK },
        { IDM_TRIED_UNORDERLIST, IDM_UNORDERLIST }
    };

    if (NULL == pCmdTrident)
        return E_POINTER;

    for (int i=0; i < sizeof(rgCmdMap)/sizeof(CMDMAP); ++i)
    {
        if (cmdTriEdit == rgCmdMap[i].cmdTriEdit)
        {
            *pCmdTrident = rgCmdMap[i].cmdTrident;
            return S_OK;
        }
    }

    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SetUpDefaults
//
// Set Trident flags to the TriEdit default values:
//
//      IDM_PRESERVEUNDOALWAYS                  On
//      IDM_NOFIXUPURLSONPASTE                  On
//      IDM_NOACTIVATEDESIGNTIMECONTROLS        Off
//      IDM_NOACTIVATEJAVAAPPLETS               On
//      IDM_NOACTIVATENORMALOLECONTROLS         On
//
//
// No return value.

void CTriEditDocument::SetUpDefaults()
{
    VARIANT var;

    // Turn on Trident's preserve undo flag for setting properties
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             6049, // IDM_PRESERVEUNDOALWAYS
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    // Turn on Trident's url fixup flag for paste and drag-drop
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             2335, // IDM_NOFIXUPURLSONPASTE
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    // Set up defaults for Activating DTCs but not Applets or other ActiveX Controls
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = FALSE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_NOACTIVATEDESIGNTIMECONTROLS,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_NOACTIVATEJAVAAPPLETS,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_NOACTIVATENORMALOLECONTROLS,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::SetUpGlyphTable
//
// Load the glyphs from the DLL and install them in Trident's table. No return
// value.
//

void CTriEditDocument::SetUpGlyphTable(BOOL fDetails)
{
    VARIANT var;
    const int RuleMax = 100; // This needs to be updated if we ever have a long rule
    const int PathMax = 256; // For %program files%\common files\microsoft shared\triedit\triedit.dll
    int iGlyphTableStart = IDS_GLYPHTABLESTART;
    int iGlyphTableEnd = fDetails ? IDS_GLYPHTABLEEND : IDS_GLYPHTABLEFORMEND;
    TCHAR szPathName[PathMax];
    TCHAR szRule[RuleMax + PathMax];
    TCHAR szGlyphTable[(RuleMax + PathMax) * (IDS_GLYPHTABLEEND - IDS_GLYPHTABLESTART + 1)];
    TCHAR *pchGlyphTable, *pchTemp;

    // Get full path name for triedit.dll
    ::GetModuleFileName(_Module.GetModuleInstance(),
            szPathName,
            sizeof(szPathName)
            );

    // Load glyph table
    pchGlyphTable = szGlyphTable;
    for (int i = iGlyphTableStart; i <= iGlyphTableEnd; i++)
    {
        ::LoadString(_Module.GetModuleInstance(), i, szRule, RuleMax);
        pchTemp = wcsstr(szRule, _T("!"));
        if (pchTemp) // else bad rule, ignore
        {
            *pchTemp = 0;
            // Copy upto the "!"
            wcscpy(pchGlyphTable, szRule);
            pchGlyphTable += wcslen(szRule);
            // Append pathname
            wcscpy(pchGlyphTable, szPathName);
            pchGlyphTable += wcslen(szPathName);
            // Skip past "!"
            pchTemp = pchTemp + 1;
            // Copy remaining characters
            wcscpy(pchGlyphTable, pchTemp);
            pchGlyphTable += wcslen(pchTemp);
        }
    }
     
    // First empty the glyph table
    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_EMPTYGLYPHTABLE,
             OLECMDEXECOPT_DONTPROMPTUSER,
             NULL,
             NULL);
    
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = SysAllocString(szGlyphTable);
    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_ADDTOGLYPHTABLE,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);
    VariantInit(&var);

}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::QueryStatus
//
// Report on the status of the given array of TriEdit and Trident commands. 
// Pass Trident commands on to Trident. Fix the Trident return value to
// compensate for some inconsistencies. Return S_OK if all goes well, or
// E_FAIL if not.
//


STDMETHODIMP CTriEditDocument::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                           OLECMD prgCmds[], OLECMDTEXT *pCmdText)

{
    OLECMD *pCmd;
    INT c;
    HRESULT hr;

    if (pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, GUID_TriEditCommandGroup))
    {
        // Loop through each command in the ary, setting the status of each.
        for (pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++)
        {
            // Assume this is a valid command and set default command status to DISABLED.
            // The state will get reset to UP, DOWN or NOTSUPPORTED in the switch statement below.
            pCmd->cmdf = CMDSTATE_DISABLED;
        
            switch(pCmd->cmdID)
            {
                case IDM_TRIED_IS_1D_ELEMENT:   
                case IDM_TRIED_IS_2D_ELEMENT:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            pCmd->cmdf = CMDSTATE_UP;
                        }
                        break;
                    }

                case IDM_TRIED_SET_ALIGNMENT:
                    {
                        pCmd->cmdf = CMDSTATE_UP;
                        break;
                    }

                case IDM_TRIED_LOCK_ELEMENT:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            BOOL f2d=FALSE;
                            if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d)
                            {
                                BOOL fLocked=FALSE;
                                pCmd->cmdf =
                                        (SUCCEEDED(IsLocked(m_pihtmlElement, &fLocked)) && fLocked)
                                        ? CMDSTATE_DOWN : CMDSTATE_UP;
                            }
                        }
                        break;
                    }
                case IDM_TRIED_CONSTRAIN:
                    {
                        pCmd->cmdf = (m_fConstrain) ? CMDSTATE_DOWN : CMDSTATE_UP;
                        break;
                    }

                case IDM_TRIED_SEND_TO_BACK:
                case IDM_TRIED_SEND_TO_FRONT:
                case IDM_TRIED_SEND_BACKWARD:
                case IDM_TRIED_SEND_FORWARD:
                case IDM_TRIED_SEND_BEHIND_1D:
                case IDM_TRIED_SEND_FRONT_1D:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            BOOL f2d=FALSE;

                            if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d)
                            {
                                pCmd->cmdf = CMDSTATE_UP;
                            }
                        }
                        break;
                    }

                case IDM_TRIED_NUDGE_ELEMENT:
                    {
                        BOOL f2d = FALSE;

                        if (SUCCEEDED(GetElement()) && m_pihtmlElement
                            && SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d)
                        {
                            BOOL fLock = FALSE;

                            if (!(SUCCEEDED(IsLocked(m_pihtmlElement, &fLock)) && fLock))
                                pCmd->cmdf = CMDSTATE_UP;
                        }
                        break;
                    }

                case IDM_TRIED_MAKE_ABSOLUTE:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            BOOL f2d = FALSE;

                            if (SUCCEEDED(IsElementDTC(m_pihtmlElement)))
                                break;

                            if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)))
                            {
                                BOOL f2dCapable=FALSE;
                                if ( f2d )
                                {
                                    pCmd->cmdf = CMDSTATE_DOWN;
                                }
                                else if (SUCCEEDED(Is2DCapable(m_pihtmlElement, &f2dCapable)) && f2dCapable)
                                {
                                    pCmd->cmdf = CMDSTATE_UP;
                                }
                            }
                        }
                        break;
                    }

                case IDM_TRIED_SET_2D_DROP_MODE:
                    {
                        pCmd->cmdf = (m_f2dDropMode) ? CMDSTATE_DOWN : CMDSTATE_UP;
                        break;
                    }

                case IDM_TRIED_INSERTROW:
                case IDM_TRIED_DELETEROWS:
                case IDM_TRIED_INSERTCELL:
                case IDM_TRIED_DELETECELLS:
                case IDM_TRIED_INSERTCOL:
                    {
                        pCmd->cmdf = (IsSelectionInTable() == S_OK && GetSelectionTypeInTable() != -1)? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_MERGECELLS:
                    {
                        ULONG grf = IsSelectionInTable() == S_OK ? GetSelectionTypeInTable() : 0;
                        pCmd->cmdf =  ( (grf != -1) && (!(grf & grfSelectOneCell) && (grf & (grfInSingleRow|grpSelectEntireRow))))  ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_SPLITCELL:
                    {
                        ULONG grf = IsSelectionInTable() == S_OK ? GetSelectionTypeInTable() : 0;
                        pCmd->cmdf = ((grf != -1) && (grf & grfSelectOneCell)) ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_DELETECOLS:
                    {
                        ULONG grf = IsSelectionInTable() == S_OK ? GetSelectionTypeInTable() : 0;
                        pCmd->cmdf = ((grf != -1) && (grf & grfInSingleRow)) ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_INSERTTABLE:
                    {
                        pCmd->cmdf = FEnableInsertTable() ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_DOVERB:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement && SUCCEEDED(DoVerb(NULL, TRUE)))
                            pCmd->cmdf = CMDSTATE_UP;

                        break;
                    }

                case IDM_TRIED_ACTIVATEACTIVEXCONTROLS:
                case IDM_TRIED_ACTIVATEAPPLETS:
                case IDM_TRIED_ACTIVATEDTCS:
                case IDM_TRIED_BACKCOLOR:
                case IDM_TRIED_BLOCKFMT:
                case IDM_TRIED_BOLD:
                case IDM_TRIED_BROWSEMODE:
                case IDM_TRIED_COPY:
                case IDM_TRIED_CUT:
                case IDM_TRIED_DELETE:
                case IDM_TRIED_EDITMODE:
                case IDM_TRIED_FIND:
                case IDM_TRIED_FONT:
                case IDM_TRIED_FONTNAME:
                case IDM_TRIED_FONTSIZE:
                case IDM_TRIED_FORECOLOR:
                case IDM_TRIED_GETBLOCKFMTS:
                case IDM_TRIED_HYPERLINK:
                case IDM_TRIED_IMAGE:
                case IDM_TRIED_INDENT:
                case IDM_TRIED_ITALIC:
                case IDM_TRIED_JUSTIFYCENTER:
                case IDM_TRIED_JUSTIFYLEFT:
                case IDM_TRIED_JUSTIFYRIGHT:
                case IDM_TRIED_ORDERLIST:
                case IDM_TRIED_OUTDENT:
                case IDM_TRIED_PASTE:
                case IDM_TRIED_PRINT:
                case IDM_TRIED_REDO:
                case IDM_TRIED_REMOVEFORMAT:
                case IDM_TRIED_SELECTALL:
                case IDM_TRIED_SHOWBORDERS:
                case IDM_TRIED_SHOWDETAILS:
                case IDM_TRIED_UNDERLINE:
                case IDM_TRIED_UNDO:
                case IDM_TRIED_UNLINK:
                case IDM_TRIED_UNORDERLIST:
                    {
                        // We will return E_UNEXPECTED if Trident's command target is not available
                        hr = E_UNEXPECTED;

                        _ASSERTE(m_pCmdTgtTrident);
                        if (m_pCmdTgtTrident)
                        {
                            OLECMD olecmd;
                            
                            olecmd.cmdf = pCmd->cmdf;
                            if (SUCCEEDED(MapTriEditCommand(pCmd->cmdID, &olecmd.cmdID)))
                            {
                                hr = m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, pCmdText);
                            }
                            pCmd->cmdf = olecmd.cmdf;
                        }
                        
                        if (FAILED(hr))
                            return hr;

                        // Trident returns NOTSUPPORTED sometimes when they really mean DISABLED, so we fix this up here.
                        if (pCmd->cmdf == CMDSTATE_NOTSUPPORTED)
                            pCmd->cmdf = CMDSTATE_DISABLED;

                        // Trident returns CMDSTATE_DISABLED for IDM_TRIED_GETBLOCKFMTS but this command should never be disabled
                        if (pCmd->cmdID == IDM_TRIED_GETBLOCKFMTS)
                            pCmd->cmdf = CMDSTATE_UP;

                        // Trident bug: Trident returns the wrong value for IDM_TRIED_SHOWBORDERS,
                        // IDM_TRIED_SHOWDETAILS and the IDM_TRIED_ACTIVATE* commands, so we fix
                        // them up here.  We don't have code for IDM_TRIED_ACTIVATE* since the logic
                        // of the Trident commands is actually reverse in these cases.

                        if (pCmd->cmdID == IDM_TRIED_SHOWBORDERS ||
                            pCmd->cmdID == IDM_TRIED_SHOWDETAILS)
                        {
                            if (pCmd->cmdf == CMDSTATE_UP)
                                pCmd->cmdf = CMDSTATE_DOWN;
                            else if (pCmd->cmdf == CMDSTATE_DOWN)
                                pCmd->cmdf = CMDSTATE_UP;
                        }

                        break;
                    }

                default:
                    {
                        pCmd->cmdf = CMDSTATE_NOTSUPPORTED;
                        break;
                    }
            } // switch
        } // for

        return S_OK;
    }
    else if (m_pCmdTgtTrident)
    {
        hr = m_pCmdTgtTrident->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
        if (hr != S_OK)
            return hr;

        // Loop through each command in the ary, fixing up the status of each.
        for (pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++)
        {
            // Trident returns NOTSUPPORTED sometimes when they really mean DISABLED.
            if (pCmd->cmdf == CMDSTATE_NOTSUPPORTED)
                pCmd->cmdf = CMDSTATE_DISABLED;

            if (pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, CMDSETID_Forms3))
            {
                // Trident returns CMDSTATE_DISABLED for IDM_GETBLOCKFMTS but this command should never be disabled
                if (pCmd->cmdID == IDM_GETBLOCKFMTS)
                    pCmd->cmdf = CMDSTATE_UP;

                // Trident bug: Trident returns the wrong value for IDM_SHOWZEROBORDER*,
                // IDM_SHOWALLTAGS and the IDM_NOACTIVATE* commands, so we fix
                // them up here.

                if (pCmd->cmdID == IDM_NOACTIVATENORMALOLECONTROLS ||
                    pCmd->cmdID == IDM_NOACTIVATEJAVAAPPLETS ||
                    pCmd->cmdID == IDM_NOACTIVATEDESIGNTIMECONTROLS ||
                    pCmd->cmdID == IDM_SHOWZEROBORDERATDESIGNTIME ||
                    pCmd->cmdID == IDM_SHOWALLTAGS)
                {
                    if (pCmd->cmdf == CMDSTATE_UP)
                        pCmd->cmdf = CMDSTATE_DOWN;
                    else if (pCmd->cmdf == CMDSTATE_DOWN)
                        pCmd->cmdf = CMDSTATE_UP;
                }
            }
        }

        return S_OK;
    }

    return E_UNEXPECTED;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Exec
//
// Perform the given TriEdit or Trident command. Pass Trident commands on to
// Trident for execution. Return S_OK if all goes well or E_FAIL if not.
//

STDMETHODIMP CTriEditDocument::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, GUID_TriEditCommandGroup) &&
        m_pUnkTrident)
    {
        HRESULT hr = GetElement();

        switch(nCmdID)
        {
            case IDM_TRIED_IS_1D_ELEMENT:   //[out,VT_BOOL]
                if (pvaOut && m_pihtmlElement &&
                    SUCCEEDED(VariantChangeType(pvaOut, pvaOut, 0, VT_BOOL)))
                {
                    hr = Is2DElement(m_pihtmlElement, (BOOL*)&pvaOut->boolVal);
                    _ASSERTE(SUCCEEDED(hr));
                    if (SUCCEEDED(hr))
                    {
                        pvaOut->boolVal = !pvaOut->boolVal;
                    }
                }
                break;
           case IDM_TRIED_IS_2D_ELEMENT:   //[out,VT_BOOL]
                if (pvaOut && m_pihtmlElement &&
                    SUCCEEDED(VariantChangeType(pvaOut, pvaOut, 0, VT_BOOL)))
                {
                    hr = Is2DElement(m_pihtmlElement, (BOOL*)&pvaOut->boolVal);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_NUDGE_ELEMENT:   //[in,VT_BYREF (VARIANT.byref=LPPOINT)]
                {
                    BOOL fLock = FALSE;
                    IsLocked(m_pihtmlElement, &fLock);
                    if (!pvaIn)
                        hr = E_FAIL;
                    else if (!fLock && VT_BYREF == pvaIn->vt && pvaIn->byref)
                    {
                        hr = NudgeElement(m_pihtmlElement, (LPPOINT)pvaIn->byref);
                        _ASSERTE(SUCCEEDED(hr));
                    }
                }
                break;
            case IDM_TRIED_SET_ALIGNMENT:   //[in,VT_BYREF (VARIANT.byref=LPPOINT)]
                if (!pvaIn)
                    hr = E_FAIL;
                else if (VT_BYREF == pvaIn->vt && pvaIn->byref)
                {
                    hr = SetAlignment((LPPOINT)pvaIn->byref);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_LOCK_ELEMENT:
                if (m_pihtmlElement)
                {
                    BOOL f2d=FALSE;
                    BOOL fLocked=TRUE;
                    if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d &&
                            SUCCEEDED(IsLocked(m_pihtmlElement, &fLocked)))
                    {
                        hr = LockElement(m_pihtmlElement, !fLocked);
                        _ASSERTE(SUCCEEDED(hr));
                    }
                }
                break;
            case IDM_TRIED_SEND_TO_BACK:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_TO_BACK);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_TO_FRONT:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_TO_FRONT);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_BACKWARD:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_BACKWARD);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_FORWARD:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_FORWARD);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_BEHIND_1D:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_BEHIND_1D);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_FRONT_1D:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_FRONT_1D);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_CONSTRAIN:
                if (!pvaIn)
                    hr = E_FAIL;
                else if (SUCCEEDED(hr = VariantChangeType(pvaIn, pvaIn, 0, VT_BOOL)))
                {
                    hr = Constrain((BOOL)pvaIn->boolVal);
                }
                break;
            case IDM_TRIED_SET_2D_DROP_MODE:
                if (!pvaIn)
                    hr = E_FAIL;
                else if (SUCCEEDED(hr = VariantChangeType(pvaIn, pvaIn, 0, VT_BOOL)))
                {
                    m_f2dDropMode = pvaIn->boolVal;
                }
                break;
            case IDM_TRIED_INSERTROW:
                hr = InsertTableRow();
                break;
            case IDM_TRIED_INSERTCOL:
                hr = InsertTableCol();
                break;
            case IDM_TRIED_INSERTCELL:
                hr = InsertTableCell();
                break;
            case IDM_TRIED_DELETEROWS:
                hr = DeleteTableRows();
                break;
            case IDM_TRIED_DELETECOLS:
                hr = DeleteTableCols();
                break;
            case IDM_TRIED_DELETECELLS:
                hr = DeleteTableCells();
                break;
            case IDM_TRIED_MERGECELLS:
                hr = MergeTableCells();
                break;
            case IDM_TRIED_SPLITCELL:
                hr = SplitTableCell();
                break;
            case IDM_TRIED_INSERTTABLE:
                hr = InsertTable(pvaIn);
                break;
            case IDM_TRIED_DOVERB:
                if (m_pihtmlElement)
                    hr = DoVerb(pvaIn, FALSE);
                else
                    hr = E_FAIL;
                break;
            case IDM_TRIED_MAKE_ABSOLUTE:
                if (m_pihtmlElement)
                {
                    BOOL f2d = FALSE;
                    hr = Is2DElement(m_pihtmlElement, &f2d);

                    if (SUCCEEDED(hr))
                    {
                        BOOL f2dCapable=FALSE;
                        if ( f2d )
                        {
                            hr = Make1DElement(m_pihtmlElement);
                            _ASSERTE(SUCCEEDED(hr));
                        }
                        else if (SUCCEEDED(Is2DCapable(m_pihtmlElement, &f2dCapable)) && f2dCapable)
                        {
                            hr = Make2DElement(m_pihtmlElement);
                            _ASSERTE(SUCCEEDED(hr));
                        }

                    }

                }
                break;

            case IDM_TRIED_ACTIVATEACTIVEXCONTROLS:
            case IDM_TRIED_ACTIVATEAPPLETS:
            case IDM_TRIED_ACTIVATEDTCS:
            case IDM_TRIED_BACKCOLOR:
            case IDM_TRIED_BLOCKFMT:
            case IDM_TRIED_BOLD:
            case IDM_TRIED_BROWSEMODE:
            case IDM_TRIED_COPY:
            case IDM_TRIED_CUT:
            case IDM_TRIED_DELETE:
            case IDM_TRIED_EDITMODE:
            case IDM_TRIED_FIND:
            case IDM_TRIED_FONT:
            case IDM_TRIED_FONTNAME:
            case IDM_TRIED_FONTSIZE:
            case IDM_TRIED_FORECOLOR:
            case IDM_TRIED_GETBLOCKFMTS:
            case IDM_TRIED_HYPERLINK:
            case IDM_TRIED_IMAGE:
            case IDM_TRIED_INDENT:
            case IDM_TRIED_ITALIC:
            case IDM_TRIED_JUSTIFYCENTER:
            case IDM_TRIED_JUSTIFYLEFT:
            case IDM_TRIED_JUSTIFYRIGHT:
            case IDM_TRIED_ORDERLIST:
            case IDM_TRIED_OUTDENT:
            case IDM_TRIED_PASTE:
            case IDM_TRIED_PRINT:
            case IDM_TRIED_REDO:
            case IDM_TRIED_REMOVEFORMAT:
            case IDM_TRIED_SELECTALL:
            case IDM_TRIED_SHOWBORDERS:
            case IDM_TRIED_SHOWDETAILS:
            case IDM_TRIED_UNDERLINE:
            case IDM_TRIED_UNDO:
            case IDM_TRIED_UNLINK:
            case IDM_TRIED_UNORDERLIST:
                {
                    ULONG cmdTrident;
                    VARIANT varColor;

                    // We will return E_FAIL if Trident's command target is not available
                    hr = E_FAIL;

                    _ASSERTE(m_pCmdTgtTrident);
                    if (m_pCmdTgtTrident && (SUCCEEDED(MapTriEditCommand(nCmdID, &cmdTrident))))
                    {
                        if (nCmdID == IDM_TRIED_ACTIVATEACTIVEXCONTROLS ||
                            nCmdID == IDM_TRIED_ACTIVATEAPPLETS ||
                            nCmdID == IDM_TRIED_ACTIVATEDTCS)
                        {
                            if (pvaIn && pvaIn->vt == VT_BOOL)
                                pvaIn->boolVal = !pvaIn->boolVal;
                        }
                       
                        // Trident bug: When you exec the forecolor, fontname or fontsize command, they also change the backcolor,
                        // so we apply a workaround here.  The workaround is to save the old backcolor and exec it later.
                        if (pvaIn && (nCmdID == IDM_TRIED_FORECOLOR || nCmdID == IDM_TRIED_FONTNAME || nCmdID == IDM_TRIED_FONTSIZE))
                        {
                            HRESULT hrT;
 
                            VariantInit(&varColor);
                            V_VT(&varColor) = VT_I4;

                            hrT = m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &varColor);
                            _ASSERTE(SUCCEEDED(hrT));
                        }

                        // Trident bug: When you exec the block format command with "Normal", they don't remove OL and UL tags
                        if (pvaIn && nCmdID == IDM_TRIED_BLOCKFMT && pvaIn->vt == VT_BSTR && (_wcsicmp(pvaIn->bstrVal, L"Normal") == 0))
                        {
                            OLECMD olecmd;

                            olecmd.cmdID = IDM_ORDERLIST;
                            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
                            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_ORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
                            
                            olecmd.cmdID = IDM_UNORDERLIST;
                            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
                            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_UNORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
                        }

                        hr = m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, cmdTrident, nCmdExecOpt, pvaIn, pvaOut);

                        if (pvaIn && (nCmdID == IDM_TRIED_FORECOLOR || nCmdID == IDM_TRIED_FONTNAME || nCmdID == IDM_TRIED_FONTSIZE))
                        {
                            HRESULT hrT;

                            hrT = m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, &varColor, NULL);
                            _ASSERTE(SUCCEEDED(hrT));
                        }
                        else if (nCmdID == IDM_TRIED_SHOWDETAILS && pvaIn && pvaIn->vt == VT_BOOL)
                        {
                            SetUpGlyphTable(pvaIn->boolVal);
                        }

                        // Trident bug: They enable the justify commands but not actually support them.
                        // We workaround this by returning S_OK for these no matter what Trident returns.
                        if (nCmdID == IDM_TRIED_JUSTIFYLEFT || nCmdID == IDM_TRIED_JUSTIFYCENTER || nCmdID == IDM_TRIED_JUSTIFYRIGHT)
                            hr = S_OK;
                    }

                    break;
                }

            default:
                hr = E_FAIL;
                break;
        }

        if (pvaIn)
            VariantClear(pvaIn);

        // We shouldn't return any unexpected error codes here, so return E_FAIL
        if (FAILED(hr))
            hr = E_FAIL;

        return hr;
    }
    else if (m_pCmdTgtTrident)
    {
        HRESULT hr;
        BOOL fTridentCmdSet;
        VARIANT varColor;

        fTridentCmdSet = pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, CMDSETID_Forms3);

#ifdef NEEDED
        if (fTridentCmdSet)
        {
            if (nCmdID == IDM_PARSECOMPLETE)
                OnObjectModelComplete();
            return S_OK;
        }
#endif //NEEDED

        // Trident bug: When you exec the forecolor, fontname or fontsize command, they also change the backcolor,
        // so we apply a workaround here.  The workaround is to save the old backcolor and exec it later.
        if (pvaIn && fTridentCmdSet && (nCmdID == IDM_FORECOLOR || nCmdID == IDM_FONTNAME || nCmdID == IDM_FONTSIZE))
        {
            HRESULT hrT;

            VariantInit(&varColor);
            V_VT(&varColor) = VT_I4;

            hrT = m_pCmdTgtTrident->Exec(pguidCmdGroup, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &varColor);
            _ASSERTE(SUCCEEDED(hrT));
        }

        // Trident bug: When you exec the block format command with "Normal", they don't remove OL and UL tags
        if (pvaIn && fTridentCmdSet && nCmdID == IDM_BLOCKFMT && pvaIn->vt == VT_BSTR && (_wcsicmp(pvaIn->bstrVal, L"Normal") == 0))
        {
            OLECMD olecmd;

            olecmd.cmdID = IDM_ORDERLIST;
            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_ORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            
            olecmd.cmdID = IDM_UNORDERLIST;
            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_UNORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }

        hr = m_pCmdTgtTrident->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        if (pvaIn && fTridentCmdSet && (nCmdID == IDM_FORECOLOR || nCmdID == IDM_FONTNAME || nCmdID == IDM_FONTSIZE))
        {
            HRESULT hrT;

            hrT = m_pCmdTgtTrident->Exec(pguidCmdGroup, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, &varColor, NULL);
            _ASSERTE(SUCCEEDED(hrT));
        }
        else if ((nCmdID == IDM_SHOWALLTAGS || nCmdID == IDM_SHOWMISCTAGS) && pvaIn && pvaIn->vt == VT_BOOL)
        {
            SetUpGlyphTable(pvaIn->boolVal);
        }

        // Trident bug: They enable the justify commands but not actually support them.
        // We workaround this by returning S_OK for these no matter what Trident returns.
        if (fTridentCmdSet && (nCmdID == IDM_JUSTIFYLEFT || nCmdID == IDM_JUSTIFYCENTER || nCmdID == IDM_JUSTIFYRIGHT))
            hr = S_OK;

        return hr;
    }

    return E_UNEXPECTED;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Is2DElement
//
// Test the given HTML element to ascertain if it is 2D positioned or not.
// Return:
//      S_OK and *pf2D = TRUE if the element is 2D positioned.
//      S_OK and *pf2D = FALSE if the element is not 2D positioned.
//

HRESULT CTriEditDocument::Is2DElement(IHTMLElement* pihtmlElement, BOOL* pf2D)
{
    IHTMLStyle* pihtmlStyle = NULL;
    BSTR bstrPosition = NULL;
    BOOL f2DCapable;
    _ASSERTE(pihtmlElement);
    _ASSERTE(pf2D);

    *pf2D = FALSE;

    if (SUCCEEDED(Is2DCapable(pihtmlElement, &f2DCapable)))
    {
        if (f2DCapable && SUCCEEDED(pihtmlElement->get_style(&pihtmlStyle)))
        {
            _ASSERTE(pihtmlStyle);
            if (SUCCEEDED(pihtmlStyle->get_position(&bstrPosition)))
            {
                if (bstrPosition)
                {
                    *pf2D = (_wcsicmp(bstrPosition, L"absolute") == 0);
                    SysFreeString(bstrPosition);
                }
            SAFERELEASE(pihtmlStyle);
            }
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEDitDocument::NudgeElement
//
// Move the given HTML element (which must be 2D positioned) as indicated
// by pptNudge, further adjusted by the grid spacing in m_ptAlign. Returns
// S_OK if all goes well; E_UNEXPECTED otherwise.
//

HRESULT CTriEditDocument::NudgeElement(IHTMLElement* pihtmlElement, LPPOINT pptNudge)
{
    HRESULT hr = E_UNEXPECTED;
    IHTMLStyle* pihtmlStyle = NULL;
    long x, y;

    _ASSERTE(pihtmlElement);
    _ASSERTE(pptNudge);
    if (pihtmlElement)
    {
        if (SUCCEEDED(pihtmlElement->get_style(&pihtmlStyle)) &&
            pihtmlStyle &&
            SUCCEEDED(pihtmlStyle->get_pixelTop(&y)) &&
            SUCCEEDED(pihtmlStyle->get_pixelLeft(&x)))
        {
            if (x == 0 || y == 0)
            {
                IHTMLElement *pihtmlElementParent = NULL;
                RECT rcElement, rcParent;

                if (SUCCEEDED(pihtmlElement->get_offsetParent(&pihtmlElementParent))
                    && pihtmlElementParent)
                {
                    if (SUCCEEDED(GetElementPosition(pihtmlElement, &rcElement)))
                    {
                        ::SetRect(&rcParent, 0, 0, 0, 0);

                        if (SUCCEEDED(GetElementPosition(pihtmlElementParent, &rcParent)))
                        {
                            x = rcElement.left - rcParent.left;
                            y = rcElement.top - rcParent.top;
                        }
                    }
                    pihtmlElementParent->Release();
                }
            }

            x += pptNudge->x;
            y += pptNudge->y;
            if (pptNudge->x != 0)
            {
                if (x >= 0)
                    x -= (x % m_ptAlign.x);
                else
                    x -= (((x % m_ptAlign.x) ? m_ptAlign.x : 0) + (x % m_ptAlign.x));
            }
            if (pptNudge->y != 0)
            {
                if (y >= 0)
                    y -= (y % m_ptAlign.y);
                else
                    y -= (((y % m_ptAlign.y) ? m_ptAlign.y : 0) + (y % m_ptAlign.y));
            }
            pihtmlStyle->put_pixelTop(y);
            pihtmlStyle->put_pixelLeft(x);
            return S_OK;
        }
    }
    SAFERELEASE(pihtmlStyle);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SetAlignment
//
// Set the TriEdit alignment values as indicated. Return S_OK if all goes
// well; or E_POINTER if a bad pointer is supplied.
//

HRESULT CTriEditDocument::SetAlignment(LPPOINT pptAlign)
{
    _ASSERTE(pptAlign);
    if (pptAlign)
    {
        m_ptAlign.x = max(pptAlign->x, 1);
        m_ptAlign.y = max(pptAlign->y, 1);
        return S_OK;
    }
    return E_POINTER;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::LockElement
//
// Set or clear the TriEdit design-time locking flag (an expando attribute) as
// indicated by fLock. Return S_OK if all goes well; E_FAIL if not. Note that
// setting the locking flag also sets the top and left attributes if they
// were not already set.
//

HRESULT CTriEditDocument::LockElement(IHTMLElement* pihtmlElement, BOOL fLock)
{
    IHTMLStyle* pihtmlStyle=NULL;
    HRESULT hr = E_FAIL;
    VARIANT var;
    VARIANT_BOOL fSuccess = FALSE;

    if (pihtmlElement)
    {
        hr = pihtmlElement->get_style(&pihtmlStyle);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            _ASSERTE(pihtmlStyle);
            if (pihtmlStyle)
            {
                if(!fLock)
                {
                    hr = pihtmlStyle->removeAttribute(DESIGN_TIME_LOCK, 0, &fSuccess);
                    _ASSERTE(fSuccess);
                }
                else
                {
                    // Trident doesn't persist the Design_Time_Lock attribute
                    // if left, top, width and height properties are not present as part of
                    // the elements style attribute. Hence as a part of locking the element 
                    // we also assign the top and left styles only if they don't exist.

                    LONG lTop, lLeft;

                    pihtmlStyle->get_pixelTop(&lTop);
                    pihtmlStyle->get_pixelLeft(&lLeft);

                    if (lTop == 0 || lLeft == 0)
                    {
                        IHTMLElement *pihtmlElementParent = NULL;

                        if (SUCCEEDED(pihtmlElement->get_offsetParent(&pihtmlElementParent))
                            && pihtmlElementParent)
                        {
                            if (SUCCEEDED(GetElementPosition(pihtmlElement, &m_rcElement)))
                            {
                                RECT rcParent;
                                ::SetRect(&rcParent, 0, 0, 0, 0);
    
                                if (SUCCEEDED(GetElementPosition(pihtmlElementParent, &rcParent)))
                                {
                                    m_rcElement.left   = m_rcElement.left - rcParent.left;
                                    m_rcElement.top    = m_rcElement.top  - rcParent.top;
                                    pihtmlStyle->put_pixelTop(m_rcElement.top);
                                    pihtmlStyle->put_pixelLeft(m_rcElement.left);
                                }
                            }
                            pihtmlElementParent->Release();
                        }
                    }

                    VariantInit(&var);
                    var.vt = VT_BSTR;
                    var.bstrVal = SysAllocString(L"True");
                    hr = pihtmlStyle->setAttribute(DESIGN_TIME_LOCK, var, 0);
                    hr = SUCCEEDED(hr) ? S_OK:E_FAIL;
                }
                pihtmlStyle->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            RECT rcElement;

            hr = GetElementPosition(pihtmlElement, &rcElement);
            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                 InflateRect(&rcElement, ELEMENT_GRAB_SIZE, ELEMENT_GRAB_SIZE);
                 if( SUCCEEDED(hr = GetTridentWindow()))
                 {
                     _ASSERTE(m_hwndTrident);
                     InvalidateRect(m_hwndTrident,&rcElement, FALSE);
                 }
            }

            // Trident doesn't set itself to be dirty, so force the dirty state.
            VariantInit(&var);
            var.vt = VT_BOOL;
            var.boolVal = TRUE; 
            if (m_pCmdTgtTrident)           
                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_SETDIRTY, 0, &var, NULL);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsLocked
//
// Test the given HTML element to ascertain if it is design-time locked or not.
// Return:
//      S_OK and *pfLocked = TRUE if the element is design-time locked.
//      S_OK and *pfLocked = FALSE if the element is not design-time locked.
//

HRESULT CTriEditDocument::IsLocked(IHTMLElement* pihtmlElement, BOOL* pfLocked)
{
    IHTMLStyle* pihtmlStyle=NULL;
    BSTR bstrAttributeName = NULL;
    HRESULT hr = E_FAIL;
    VARIANT var;

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    if (pihtmlElement)
    {
        hr = pihtmlElement->get_style(&pihtmlStyle);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            _ASSERTE(pihtmlStyle);
            if (pihtmlStyle)
            {
                bstrAttributeName = SysAllocString(DESIGN_TIME_LOCK);

                if (bstrAttributeName)
                {
                    hr = pihtmlStyle->getAttribute(bstrAttributeName, 0, &var);
                    _ASSERTE(SUCCEEDED(hr));
                    if (var.bstrVal == NULL)
                        *pfLocked = FALSE;
                    else
                        *pfLocked = TRUE;
                    SysFreeString(bstrAttributeName);
                }
                pihtmlStyle->Release();
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::Make1DElement
//
// Set the given HTML element to layout in the flow. As a side effect this
// also removes any design-time lock on the element. Return S_OK if all goes
// well; E_UNEXPECTED otherwise.
//

HRESULT CTriEditDocument::Make1DElement(IHTMLElement* pihtmlElement)
{
    IHTMLStyle* pihtmlStyle=NULL;
    VARIANT_BOOL fSuccess = FALSE;
    VARIANT var;
    HRESULT hr;

    if (pihtmlElement)
    {
        pihtmlElement->get_style(&pihtmlStyle);
        _ASSERTE(pihtmlStyle);
        if (pihtmlStyle)
        {
            VariantInit(&var);
            var.vt = VT_I4;
            var.lVal = 0; 
            hr = pihtmlStyle->put_zIndex(var);
            _ASSERTE(SUCCEEDED(hr));

            pihtmlStyle->removeAttribute(DESIGN_TIME_LOCK, 0, &fSuccess);
            pihtmlStyle->removeAttribute(L"position", 0, &fSuccess);
            pihtmlStyle->Release();
        }
    }
    
    return (fSuccess? S_OK: E_UNEXPECTED);
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::Make2DElement
//
// Set the given HTML element to be positioned. Return S_OK if all goes
// well; E_FAIL otherwise.
//

HRESULT CTriEditDocument::Make2DElement(IHTMLElement* pihtmlElement, POINT *ppt)
{

    IHTMLElement* pihtmlElementParent = NULL;
    IHTMLElementCollection* pihtmlCollection = NULL;
    IHTMLElement* pihtmlElementNew = NULL;
    IHTMLStyle* pihtmlElementStyle = NULL;
    VARIANT var;
    LONG lSourceIndex;
    HRESULT hr = E_FAIL;
    BSTR bstrOuterHtml = NULL;

    _ASSERTE(pihtmlElement);

    if(!pihtmlElement)
    {
        return E_FAIL;
    }
    
    hr = pihtmlElement->get_style(&pihtmlElementStyle);
    _ASSERTE(SUCCEEDED(hr) && pihtmlElementStyle);

    if (FAILED(hr) || !pihtmlElementStyle)
    {
        return E_FAIL;
    }

    // The reason to save the source index here is that once we call put_outerHTML
    // the element is lost, we later use the source index to get back the element from the collection.  
    // Note that the source index remains the same after put_outerHTML.
    hr = pihtmlElement->get_sourceIndex(&lSourceIndex); 
    _ASSERTE(SUCCEEDED(hr) && (lSourceIndex != -1));
    
    if (lSourceIndex == -1 || FAILED(hr))
    {
        return E_FAIL;
    }

    hr = pihtmlElement->get_offsetParent(&pihtmlElementParent);
    _ASSERTE(SUCCEEDED(hr) && pihtmlElementParent);

    if (SUCCEEDED(hr) && pihtmlElementParent)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(L"absolute");
        hr = pihtmlElementStyle->setAttribute(L"position", var, 1);

        if (var.bstrVal)
            SysFreeString(var.bstrVal);

        _ASSERTE(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr = GetElementPosition(pihtmlElement, &m_rcElement)))
            {
                IHTMLTable* pihtmlTable = NULL;
                IHTMLElement* pihtmlElementTemp = NULL, *pihtmlElementPrev = NULL;
                RECT rcParent;
                BOOL f2d = FALSE;
                BOOL fIsIE5AndBeyond = IsIE5OrBetterInstalled();

                ::SetRect(&rcParent, 0, 0, 0, 0);

                pihtmlElementTemp = pihtmlElementParent;
                pihtmlElementTemp->AddRef();

                // Handle tables specially since the offset parent may have been the TD or the TR
                while (pihtmlElementTemp)
                {
                    if (SUCCEEDED(pihtmlElementTemp->QueryInterface(IID_IHTMLTable, (void **)&pihtmlTable)) && pihtmlTable)
                        break;

                    pihtmlElementPrev = pihtmlElementTemp;
                    pihtmlElementPrev->get_offsetParent(&pihtmlElementTemp);
                    SAFERELEASE(pihtmlElementPrev);
                }

                // If parent is a 2d element, we need to offset its top and left
                if (pihtmlElementTemp && SUCCEEDED(Is2DElement(pihtmlElementTemp, &f2d)) && f2d)
                {
                    GetElementPosition(pihtmlElementTemp, &rcParent);
                }
                else if (SUCCEEDED(Is2DElement(pihtmlElementParent, &f2d)) && f2d)
                {
                    GetElementPosition(pihtmlElementParent, &rcParent);
                }

                SAFERELEASE(pihtmlTable);
                SAFERELEASE(pihtmlElementTemp);
                SAFERELEASE(pihtmlElementPrev);

                m_rcElement.left   = (ppt ? ppt->x : m_rcElement.left) - rcParent.left;
                m_rcElement.top    = (ppt ? ppt->y : m_rcElement.top) - rcParent.top;

                // We need to call get_outerHTML and put_outerHTML to work around a Trident bug
                // We should not really have to call these here, but the element doesn't get
                // updated unless we do this.
                if (fIsIE5AndBeyond || SUCCEEDED(hr = pihtmlElement->get_outerHTML(&bstrOuterHtml)))
                {
                    if (fIsIE5AndBeyond || SUCCEEDED(hr = pihtmlElement->put_outerHTML(bstrOuterHtml)))
                    {
                        hr = GetAllCollection(&pihtmlCollection);
                        _ASSERTE(SUCCEEDED(hr));
                        _ASSERTE(pihtmlCollection);

                        if (SUCCEEDED(hr) && pihtmlCollection)
                        {
                            hr = GetCollectionElement(pihtmlCollection, lSourceIndex, &pihtmlElementNew);
                            _ASSERTE(SUCCEEDED(hr));
                            _ASSERTE(pihtmlElementNew);

                            if (SUCCEEDED(hr) && pihtmlElementNew)
                            {
                                hr = SelectElement(pihtmlElementNew, pihtmlElementParent);

                                GetElement(); // to update m_pihtmlElement and friends after the above SelectElement

                                if (SUCCEEDED(hr))
                                {
                                    hr = AssignZIndex(pihtmlElementNew,  MADE_ABSOLUTE);
                                    _ASSERTE(SUCCEEDED(hr));

                                    if (SUCCEEDED(hr))
                                    {
                                        SAFERELEASE(pihtmlElementStyle);
                                        if (SUCCEEDED(hr = pihtmlElementNew->get_style(&pihtmlElementStyle)))
                                        {
                                            pihtmlElementStyle->put_pixelLeft(m_rcElement.left);
                                            pihtmlElementStyle->put_pixelTop(m_rcElement.top);
                                            VariantInit(&var);
                                            var.vt = VT_BOOL;
                                            var.boolVal = FALSE;
                                            pihtmlElementNew->scrollIntoView(var);
                                         }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }
               
    if (bstrOuterHtml)                  
        SysFreeString(bstrOuterHtml);

    SAFERELEASE(pihtmlElementParent);
    SAFERELEASE(pihtmlElementStyle);
    SAFERELEASE(pihtmlElementNew);
    SAFERELEASE(pihtmlCollection);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Constrain
// 
// Set the TriEdit constraint flag as indicated by fConstrain. Also, reset
// the constraint direction to CONSTRAIN_NONE. Return S_OK.

HRESULT CTriEditDocument::Constrain(BOOL fConstrain)
{
    m_fConstrain = (fConstrain) ? TRUE:FALSE;
    m_eDirection = CONSTRAIN_NONE;
    return S_OK;
}

typedef struct SELCELLINFO
   {
       LONG cCellIndex; // cell index in a row
       LONG cRowIndex; // which row is this cell in
       CComPtr<IDispatch> srpCell; // cell element
       CComPtr<IDispatch> srpRow; // row element
       CComPtr<IDispatch> srpTable;
   } SELCELLINFO;


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetTableRowElementAndTableFromCell
//
// Given the IDispatch pointer to an element within a table, return the
// row index in *pindexRow (if pindexRow is not NULL) and/or the 
// actual row element in *psrpRow (if psrpRow is not NULL) of the
// element within the table. If psrpTable is not NULL, return the
// table containing the element therein. Return S_OK if all goes well,
// or E_FAIL if something goes wrong.
//

HRESULT CTriEditDocument::GetTableRowElementAndTableFromCell(IDispatch *srpCell, LONG *pindexRow , IDispatch **psrpRow, IDispatch **psrpTable)
{
   CComPtr<IDispatch>    srpParent,srpElement;
   HRESULT hr = E_FAIL;
   CComBSTR bstrTag;

    _ASSERTE(srpCell != NULL);

    if (pindexRow == NULL && psrpRow == NULL)
        goto Fail;

    srpParent = srpCell;

    while (srpParent != NULL)
    {
        srpElement.Release();
        if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
            goto Fail;

        if (srpElement == NULL)
            {
            hr = E_FAIL;
            goto Fail;
            }

        bstrTag.Empty();
        if (FAILED(hr = GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
            goto Fail;

        if (lstrcmpi(_T("TR"), OLE2T(bstrTag)) == 0)
        {
            if (psrpRow != NULL)
            {
                *psrpRow = srpElement;
                (*psrpRow)->AddRef();
            }

            if (pindexRow != NULL)
            {
                if (FAILED(hr = GetDispatchProperty(srpElement, L"rowIndex", VT_I4, pindexRow)))
                    goto Fail;
            }
            break;
        }
        srpParent = srpElement;
    }

   if (psrpTable != NULL)
   {
       srpParent = srpElement;
       while (srpParent != NULL)
       {
            srpElement.Release();
            if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
                goto Fail;

            if (srpElement == NULL)
                {
                hr = E_FAIL;
                goto Fail;
                }

            bstrTag.Empty();
            if (FAILED(hr = GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
                goto Fail;

            if (lstrcmpi(_T("TABLE"), OLE2T(bstrTag)) == 0)
            {
                if (psrpTable != NULL)
                {
                    *psrpTable = srpElement;
                    (*psrpTable)->AddRef();
                }
                break;
            }
            srpParent = srpElement;
        }
   }

Fail:

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::FEnableInsertTable
//
// Return TRUE if the Trident selection is within a table and if the selection
// type and location will allow elements to be inserted within the table. 
// Return FALSE otherwise.
//

BOOL CTriEditDocument::FEnableInsertTable(void)
{
    BOOL fRet = FALSE;
    CComPtr<IDispatch>    srpRange,srpParent,srpElement;
    CComPtr<IHTMLSelectionObject>    srpSel;
    CComPtr<IHTMLDocument2>    srpiHTMLDoc;
    CComBSTR    bstr;
    CComBSTR    bstrTag;

    if (FAILED(m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    if (FAILED(GetDispatchProperty(srpSel, L"type", VT_BSTR, &bstr)))
        goto Fail;

    if (lstrcmpi(_T("CONTROL"), OLE2T(bstr)) == 0)
    {
        return FALSE;
    }

    if (FAILED(CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpRange)))
        goto Fail;

    if (srpRange == NULL)
        goto Fail;
        
    srpParent = srpRange;

    while (srpParent != NULL)
    {
        srpElement.Release();
        if (FAILED(GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
            goto Fail;

        if (srpElement == NULL)
            break;

        bstrTag.Empty();
        if (FAILED(GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
            goto Fail;

        if (lstrcmpi(_T("INPUT"), OLE2T(bstrTag)) == 0)
        {
           return FALSE;
        }
        srpParent = srpElement;
    }

    // if the selection is inside a table, make sure only one  cell is selected
    if (IsSelectionInTable() == S_OK)
    {
        UINT grf = GetSelectionTypeInTable();
        if (grf != -1 && !(grf & grfSelectOneCell)) 
            return FALSE;
    }
    
    fRet = TRUE;

Fail:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsSelectionInTable
//
// Return S_OK if the Trident selection is within a table. Return
// E_FAIL otherwise.
//

HRESULT CTriEditDocument::IsSelectionInTable(IDispatch **ppTable)
{
    HRESULT    hr=0;
    CComPtr<IHTMLSelectionObject>    srpSel;
    CComPtr<IDispatch>    srpRange,srpParent,srpElement;
    CComPtr<IHTMLDocument2>    srpiHTMLDoc;
    CComBSTR    bstrTag;
    BOOL  fTable= FALSE;

    if (FAILED(hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(hr = srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpRange)))
        goto Fail;

    srpParent = srpRange;
    
    while (srpParent != NULL)
    {
        srpElement.Release();
        if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
            goto Fail;

        if (srpElement == NULL)
            break;

        bstrTag.Empty();
        if (FAILED(hr = GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
            goto Fail;

        if (lstrcmpi(_T("TABLE"), OLE2T(bstrTag)) == 0)
        {
            if (ppTable != NULL)
            {
                *ppTable = srpElement;
                (*ppTable)->AddRef();
            }
            fTable = TRUE;
            break;
        }
        else if (lstrcmpi(_T("CAPTION"), OLE2T(bstrTag)) == 0)
        {
            fTable = FALSE;
            break;
        }

        srpParent = srpElement;
    }

Fail:

    return fTable ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::FillInSelectionCellsInfo
//
// Fill *pSelStart with the information concerning the table cell containing
// the beginning of the Trident selection and *pSelSle with the information
// on the table cell at the end of the selection. Return S_OK if all goes well,
// or E_FAIL otherwise.

HRESULT   CTriEditDocument::FillInSelectionCellsInfo(struct SELCELLINFO * pselStart, struct SELCELLINFO *pselEnd)
{
    CComPtr<IHTMLDocument2>  srpiHTMLDoc;
    CComPtr<IHTMLSelectionObject>   srpSel;
    CComPtr<IHTMLTxtRange>      srpRange[2];
    CComPtr<IDispatch>    srpParent;
    CComBSTR       bstrText, bstrTag;;
    LONG cReturn=0;
    HRESULT i=0, hr=0;
    LONG cCharSelected=0;
    WCHAR *pData = NULL;
    BOOL fContain = FALSE;

    if (FAILED(hr = IsSelectionInTable()))
        goto Fail;

    if (FAILED(hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(hr = srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    for (i=0; i<2 ; i++)
    {
		// BUG 568250.  We HAD treated the dispatch like a text range, this now crashes.
		CComPtr<IDispatch> srpDisp;
        if (FAILED(hr = CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpDisp)))
		{
             goto Fail;
		}
		else
		{
			if (FAILED(hr = srpDisp->QueryInterface(&srpRange[i])))
				goto Fail;
		}
    }

    bstrText.Empty();
    hr = srpRange[0]->get_text(&bstrText);
    if (FAILED(hr))
    goto Fail;

    cCharSelected = bstrText ? ocslen(bstrText) : 0;
    pData = (WCHAR *) bstrText;

    // VID98 bug 3117: trident use '0x0D' to mark column/row and this char is ignored when
    // move range so we need to deduct these characters
    while (pData != NULL && *pData !='\0')
    {
        if (*pData == 0x0D)
            cCharSelected--;
        pData++;
    }

    if (pselStart != NULL)
    {
        hr = srpRange[0]->collapse(TRUE);
        if (FAILED(hr))
        goto Fail;

        srpParent = srpRange[0];
        while (srpParent != NULL)
        {
            pselStart->srpCell.Release();
            if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&pselStart->srpCell)))
                goto Fail;

            if (pselStart->srpCell == NULL)
                {
                hr = E_FAIL;
                goto Fail;
                }

            bstrTag.Empty();
            if (FAILED(hr = GetDispatchProperty(pselStart->srpCell, L"tagName", VT_BSTR, &bstrTag)))
                goto Fail;

            if (lstrcmpi(_T("TD"), OLE2T(bstrTag)) == 0 || lstrcmpi(_T("TH"), OLE2T(bstrTag)) == 0)
            {
                break;
            }
          
            srpParent = pselStart->srpCell;
        }

        _ASSERTE(pselStart->srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(pselStart->srpCell, L"cellIndex", VT_I4, &pselStart->cCellIndex)))
            goto Fail;

        pselStart->srpRow.Release();
        if (FAILED(hr = GetTableRowElementAndTableFromCell(pselStart->srpCell, &pselStart->cRowIndex, &pselStart->srpRow, &pselStart->srpTable)))
            goto Fail;
    }

    if (pselEnd != NULL)
    {
        hr = srpRange[1]->collapse(FALSE);
        if (FAILED(hr))
            goto Fail;

        if (cCharSelected != 0)
        {
            hr = srpRange[1]->moveStart(L"Character", -1, &cReturn);
            if (FAILED(hr))
                goto Fail;
    
            hr = srpRange[1]->moveEnd(L"Character", -1, &cReturn);
            if (FAILED(hr))
                goto Fail;
        }

        srpParent = srpRange[1];
        while (srpParent != NULL)
        {
            pselEnd->srpCell.Release();
            if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&pselEnd->srpCell)))
                goto Fail;

            if (pselEnd->srpCell == NULL)
                {
                hr = E_FAIL;
                goto Fail;
                }

            bstrTag.Empty();
            if (FAILED(hr = GetDispatchProperty(pselEnd->srpCell, L"tagName", VT_BSTR, &bstrTag)))
                goto Fail;
            
            if (lstrcmpi(_T("TD"), OLE2T(bstrTag)) == 0 || lstrcmpi(_T("TH"), OLE2T(bstrTag)) == 0)
            {
                break;
            }
            srpParent = pselEnd->srpCell;
        }

        _ASSERTE(pselEnd->srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(pselEnd->srpCell, L"cellIndex", VT_I4, &pselEnd->cCellIndex)))
            goto Fail;

        pselEnd->srpRow.Release();
        if (FAILED(hr =  GetTableRowElementAndTableFromCell(pselEnd->srpCell, &pselEnd->cRowIndex, &pselEnd->srpRow, &pselEnd->srpTable)))
            goto Fail;
    }

    if (pselEnd != NULL && pselStart != NULL)
    {
    // VID 98 bug 3116: we need to check if first cell and last cell are in the same table. If they are not
    // the row index and cell index we just got do not make sense
        if (FAILED(hr = CallDispatchMethod(pselEnd->srpTable, L"contains", VTS_DISPATCH VTS_BOOL_RETURN, pselStart->srpRow, &fContain)))
            goto Fail;

        if (!fContain)
           return E_FAIL;

        fContain = FALSE;
        if (FAILED(hr = CallDispatchMethod(pselStart->srpTable, L"contains", VTS_DISPATCH VTS_BOOL_RETURN, pselEnd->srpRow, &fContain)))
            goto Fail;

        if (!fContain)
           return E_FAIL;
    }


Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetSelectionTypeInTable
//
// Return a set of flags that characterize the current selection. Return
// -1 if something goes wrong. The flags are as follows:
//
//      grfInSingleRow          Selection is comprised of one or more cells 
//                              within a single row.
//
//      grfSelectOneCell        Selection is comprised of a single cell.
//
//      grpSelectEntireRow      Selection is comprised of one or more 
//                              complete rows.

ULONG    CTriEditDocument::GetSelectionTypeInTable(void)
{
    CComPtr<IDispatch>    srpCells;
    struct SELCELLINFO    selinfo[2]; // 0 is start cell, 1 is end cell
    LONG cCells=0;
    HRESULT hr=0;
    ULONG grf=0;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex)
    {
        grf |= grfInSingleRow;
        if (selinfo[0].cCellIndex == selinfo[1].cCellIndex)
            grf |= grfSelectOneCell;
    }
    else
    {
        grf &= ~grfInSingleRow;
    }

    if (selinfo[0].cCellIndex != 0)
        grf &= ~grpSelectEntireRow;
    else
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[1].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        if (selinfo[1].cCellIndex != cCells-1)
            grf &= ~grpSelectEntireRow;
        else
            grf |= grpSelectEntireRow;
    }



Fail:
    return FAILED(hr) ? -1 : grf;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CopyProperty
//
// Copy properties from the pFrom element on to the pTo element. Return S_OK.
//

HRESULT CTriEditDocument::CopyProperty(IDispatch *pFrom, IDispatch *pTo)
{
    CComVariant varProp;
    CComBSTR bstrProp;
    VARIANT_BOOL bProp;

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"align", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"align", VT_BSTR, bstrProp);
    }
    
    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"vAlign", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"vAlign", VT_BSTR, bstrProp);
    }

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"background", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"background", VT_BSTR, bstrProp);
    }

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"lang", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"lang", VT_BSTR, bstrProp);
    }   

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"className", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"className", VT_BSTR, bstrProp);
    }   
    
    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"bgColor", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"bgColor", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"borderColor", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"borderColor", VT_VARIANT, varProp);
    
    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"borderColorLight", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"borderColorLight", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"borderColorDark", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"borderColorDark", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"height", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"height", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"width", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"width", VT_VARIANT, varProp);

    
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"noWrap", VT_BOOL, (void **)&bProp)))
    {
#pragma warning(disable: 4310) // cast truncates constant value
        if (bProp == VARIANT_TRUE) 
#pragma warning(default: 4310) // cast truncates constant value
            PutDispatchProperty(pTo, L"noWrap", VT_BOOL, bProp);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CopyStyle
//
// Copy style properties from style element pFrom on to style element pTo.
// Return S_OK.
//      

HRESULT CTriEditDocument::CopyStyle(IDispatch *pFrom, IDispatch *pTo)
{
    CComPtr<IDispatch>  srpStyleTo, srpStyleFrom;
  
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"style", VT_DISPATCH, (void **)&srpStyleFrom)))
    {
        if (SUCCEEDED(GetDispatchProperty(pTo, L"style", VT_DISPATCH, (void **)&srpStyleTo)))
        {
            CComVariant varProp;
            CComBSTR bstrProp;

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundAttachment", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"backgroundAttachment", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundImage", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"backgroundImage", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundRepeat", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"backgroundRepeat", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderBottom", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderBottom", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderLeft", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderLeft", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderTop", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderTop", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderRight", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderRight", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontFamily", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontFamily", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontStyle", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontStyle", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontVariant", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontVariant", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontWeight", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontWeight", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"textAlign", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"textAlign", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"textTransform", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"textTransform", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"textDecoration", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"textDecoration", VT_BSTR, bstrProp);
            }   
            
            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundcolor", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"backgroundcolor", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"color", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"color", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontSize", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"fontSize", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"height", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"height", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"letterSpacing", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"letterSpacing", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"lineHeight", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"lineHeight", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingRight", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingRight", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingBottom", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingBottom", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingLeft", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingLeft", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingTop", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingTop", VT_VARIANT, varProp);
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTableRows
//
// Delete the table row(s) contained within the Trident selection. The 
// entire operation is a single undo unit. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::DeleteTableRows(void)
{
    HRESULT    hr = S_OK;
    CComPtr<IHTMLElement>       srpTable;
    struct SELCELLINFO    selinfo[2]; // 0 is start cell, 1 is end cell
    INT i=0;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;
            
    undoPackMgr.Start();
    
    for(i= selinfo[0].cRowIndex; i <= selinfo[1].cRowIndex; i++)
    {
        if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
            goto Fail;
    }
    
Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteRowEx
//
// Delete the indicated table row. If the row is the only row in the table,
// delete the whole table. Return S_OK or a Trident error.
//

inline HRESULT CTriEditDocument::DeleteRowEx(IHTMLElement *pTable, LONG index)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch> srpRows;
    INT cRows = 0;

    if (FAILED(hr = GetDispatchProperty(pTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
        goto Fail;

    // if this is the only row in the table, delete the whole table
    if (cRows == 1)
    {
        _ASSERT(index == 0);
        hr = DeleteTable(pTable);
    }
    else
    {
        if (FAILED(hr = CallDispatchMethod(pTable, L"deleteRow", VTS_I4, index)))
            goto Fail;
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteCellEx
//
// Delete the indicated cell from the indicated row of the given table. If
// the cell is the only row in the table, delete the whole table. Return
// S_OK or a Trident error.
//

inline HRESULT CTriEditDocument::DeleteCellEx(IHTMLElement *pTable, IDispatch *pRow, LONG indexRow, LONG indexCell)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch> srpCells;
    INT cCells = 0;

    if (FAILED(hr = GetDispatchProperty(pRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
        goto Fail;

    // if this is the only cell in the table, delete the whole row
    if (cCells == 1)
    {
        _ASSERT(indexCell == 0);
        hr = DeleteRowEx(pTable, indexRow);
    }
    else
    {
        if (FAILED(hr = CallDispatchMethod(pRow, L"deleteCell", VTS_I4, indexCell)))
            goto Fail;
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTable
//
// Delete the given table. Return S_OK if all goes well; E_FAIL if something
// goes wrong.
//

HRESULT CTriEditDocument::DeleteTable(IHTMLElement *pTable)
{
    CComPtr<IHTMLElement>   srpParent;
    HRESULT hr = E_FAIL;

    _ASSERTE(pTable != NULL);

    if (pTable  == NULL)
        goto Fail;
        
    if (FAILED(hr=pTable->get_offsetParent(&srpParent)))
        goto Fail;

    _ASSERTE(srpParent != NULL);
    if (FAILED(hr = SelectElement(pTable, srpParent)))
        goto Fail;
        
    hr = Exec(&CMDSETID_Forms3, IDM_DELETE, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
    
Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTableRow
//
// Insert a new table row in to the table which contains the Trident selection,
// in the row preceding the selection. The new row will have the same number of
// cells as the row containing the selection. The colSpan of each new cell
// will be copied from the row containing the selection. The entire operation
// is a single undo unit. Returns S_OK or a Trident error.
//

HRESULT CTriEditDocument::InsertTableRow(void)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch> srpCell,srpCellNew, srpTable,srpCells,srpRows,srpNewRow,srpCellsNew;
    LONG ccolSpan=0;
    LONG cCells=0,i=0;
    struct SELCELLINFO    selinfo;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable(&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo, NULL)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpTable, L"insertRow", VTS_I4, selinfo.cRowIndex)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, selinfo.cRowIndex, &srpNewRow)))
        goto Fail;

    CopyStyle(selinfo.srpRow, srpNewRow);
    
    // get the number of cells contains in the selected row
    if (FAILED(hr = GetDispatchProperty(selinfo.srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
        goto Fail;

    // now insert cells
    for (i=cCells-1; i >=0; i--)
    {
         if (FAILED(hr = CallDispatchMethod(srpNewRow, L"insertCell", VTS_I4, 0)))
             goto Fail;

         srpCell.Release();
         if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
             goto Fail;

         srpCellsNew.Release();
         if (FAILED(hr = GetDispatchProperty(srpNewRow, L"cells", VT_DISPATCH, (void**)&srpCellsNew)))
             goto Fail;
         srpCellNew.Release();
         if (FAILED(hr = CallDispatchMethod(srpCellsNew, L"Item", VTS_I4 VTS_DISPATCH_RETURN, 0, &srpCellNew)))
             goto Fail;

         CopyStyle(srpCell, srpCellNew);
         CopyProperty(srpCell, srpCellNew);
         
         {
         VARIANT width;
         VariantInit(&width);
         if (SUCCEEDED(hr = GetDispatchProperty(srpCell, L"width", VT_VARIANT, &width)))
             PutDispatchProperty(srpCellNew, L"width", VT_VARIANT, width);
         }

         if (SUCCEEDED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpan)))
             PutDispatchProperty(srpCellNew, L"colSpan", VT_I4, ccolSpan);
    }

Fail:
       return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MapCellToFirstRowCell
//
// Given a table cell in pselInfo, return (by modifying pselInfo) the cell in
// the first row with the same column position, accounting for colSpans. Return
// S_OK or a Trident error.
//

HRESULT CTriEditDocument::MapCellToFirstRowCell(IDispatch *srpTable, struct SELCELLINFO *pselinfo)
{
    HRESULT hr = 0;
    CComPtr<IDispatch> srpCell, srpCells,srpRow,srpRows;
    INT i=0,iCellIndex=0,iColSpanCurRow=0,cSpan=0,iColSpanFirstRow=0,crowSpan=0;

    _ASSERTE(pselinfo != NULL);
    // if current selection is not first row, find the corresponding first row cell index
    if (pselinfo->cRowIndex == 0)
        return S_OK;

    srpCells.Release();
    _ASSERTE(pselinfo->srpRow != NULL);
    if (FAILED(hr = GetDispatchProperty(pselinfo->srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    for (i=0; i < pselinfo->cCellIndex ; i++)
    {
        srpCell.Release();
        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
            goto Fail;

        _ASSERTE(srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
            goto Fail;

        iColSpanCurRow += cSpan;
    }

    srpRows.Release();
     _ASSERTE(srpTable != NULL);

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    _ASSERTE(srpRows != NULL);
    srpRow.Release();
    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item",VTS_I4 VTS_DISPATCH_RETURN, 0, &srpRow)))
        goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    iCellIndex=-1;
    while(iColSpanCurRow >= iColSpanFirstRow)
    {
        iCellIndex++;
        srpCell.Release();
        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, iCellIndex, &srpCell)))
            goto Fail;

        // we might hit the end. If so, first row is shorter than curret row and there's no mapping first row, bail out...
        if (srpCell == NULL)
        {
        hr = E_FAIL;
        goto Fail;
        }

        _ASSERTE(srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
            goto Fail;

        iColSpanFirstRow += cSpan;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &crowSpan)))
            goto Fail;

        if (crowSpan > pselinfo->cRowIndex)
        {
            iColSpanCurRow += cSpan;
        }

    }

    pselinfo->srpCell = srpCell;
    pselinfo->srpRow.Release();
    if (FAILED(hr = GetTableRowElementAndTableFromCell(pselinfo->srpCell, NULL, &pselinfo->srpRow)))
        goto Fail;

    pselinfo->cRowIndex = 0;
    _ASSERTE(iCellIndex >= 0);
    pselinfo->cCellIndex = iCellIndex;

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTableCol
//
// Insert a new column in to the table containing the selection, at the column
// of the selection. The entire operation is a single undo unit. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::InsertTableCol(void)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch>               srpCellNew, srpTable,srpRows,srpRow,srpCells,srpCell;
    LONG    cRows=0,i=0, j=0, iColSpanInsert=0, iColSpanCur=0, cSpan=0,crowSpan = 0, cCells=0;
    struct SELCELLINFO    selinfo;
    INT *pccolFix = NULL;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable(&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo, NULL)))
        goto Fail;

    MapCellToFirstRowCell(srpTable, &selinfo);

    srpCells.Release();
    _ASSERTE(selinfo.srpRow != NULL);
    if (FAILED(hr = GetDispatchProperty(selinfo.srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    _ASSERTE(srpTable != NULL);
    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
       goto Fail;

    _ASSERTE(srpRows != NULL);
    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
       goto Fail;

    pccolFix = new INT[cRows];
    _ASSERTE(pccolFix != NULL);
    for (i=0; i< cRows; i++)
        *(pccolFix+i) = 0;

    for (i=0; i < selinfo.cCellIndex; i++)
    {
        srpCell.Release();
        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))             goto Fail;

        _ASSERTE(srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
            goto Fail;

        iColSpanInsert += cSpan;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &crowSpan)))
            goto Fail;

    // if someone before the current cell has row span, this needs to propogate to
    // the next spanned rows
        if (crowSpan > 1)
            {
            for (j= selinfo.cRowIndex+1; j < (selinfo.cRowIndex+crowSpan); j++)
                *(pccolFix+j) += cSpan;
            }
    }

    for (i=0; i < cRows;)
    {
        srpRow.Release();
         _ASSERTE(srpRows != NULL);
        if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpRow)))
            goto Fail;

        srpCells.Release();
        _ASSERTE(srpRow != NULL);
        if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        iColSpanCur =  *(pccolFix+i);
        for (j=0; j < cCells; j++)
        {
            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpCell)))             goto Fail;

             _ASSERTE(srpCell != NULL);
            if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
                goto Fail;

            if (iColSpanCur >= iColSpanInsert)
                break;

            iColSpanCur += cSpan;
        }

        _ASSERTE(srpRow != NULL);
        if (FAILED(hr = CallDispatchMethod(srpRow, L"insertCell", VTS_I4, j)))
            goto Fail;

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        srpCellNew.Release();
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpCellNew)))
            goto Fail;

                
        if (!(!srpCell))
        {
            CopyStyle(srpCell, srpCellNew);
            CopyProperty(srpCell, srpCellNew);
            
            {
            VARIANT height;
            VariantInit(&height);
            if (SUCCEEDED(hr = GetDispatchProperty(srpCell, L"height", VT_VARIANT, &height)))
                PutDispatchProperty(srpCellNew, L"height", VT_VARIANT, height);
             }

            if (SUCCEEDED(GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &cSpan)))
                PutDispatchProperty(srpCellNew, L"rowSpan", VT_I4, cSpan);
        }

        // cSpan might be 0 if we are inserting a cell into an empty row
        i += max(1, cSpan);
    }

Fail:
    if (pccolFix != NULL)
        delete [] pccolFix;
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTableCols
//
// Delete the table columns that are contained within the Trident selection.
// The entire operation is a single undo unit. Return S_OK or a Trident error. 
//

HRESULT CTriEditDocument::DeleteTableCols(void)
{
    CComPtr<IDispatch>       srpRows,srpRow,srpCells,srpCell;
    CComPtr<IHTMLElement>   srpTable;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG cRows=0, i=0, j=0, k=0, cCells=0;
    HRESULT      hr=0;
    LONG iColSpanStart=0, iColSpanEnd=0,cColSpan=0,iColSpanCur=0, crowSpan=0;
    INT *  pccolFixStart=NULL, *pccolFixEnd = NULL;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (!FAILED(MapCellToFirstRowCell(srpTable, &selinfo[1])))
        MapCellToFirstRowCell(srpTable, &selinfo[0]);

    _ASSERTE(selinfo[0].srpRow != NULL);
    if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    _ASSERTE(srpCells != NULL);
    if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
        goto Fail;

    _ASSERTE(selinfo[1].cRowIndex == selinfo[0].cRowIndex);
    _ASSERTE(selinfo[1].cCellIndex >= selinfo[0].cCellIndex);

    srpRows.Release();
    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
       goto Fail;

    _ASSERTE(srpRows != NULL);
    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
       goto Fail;

    pccolFixEnd = new INT[cRows];
    pccolFixStart = new INT[cRows];
    for (i=0; i< cRows; i++)
        {
        *(pccolFixStart+i) = 0;
        *(pccolFixEnd+i) = 0;
        }

    for (i=0; i<= selinfo[1].cCellIndex; i++)
    {
        srpCell.Release();
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))             goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cColSpan)))
            goto Fail;
        if (i < selinfo[0].cCellIndex)
           iColSpanStart += cColSpan;

        if (i <= selinfo[1].cCellIndex)
           iColSpanEnd += cColSpan;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &crowSpan)))
            goto Fail;

        if (crowSpan > 1)
        {
            if (i < selinfo[0].cCellIndex)
            {
                for (j= selinfo[0].cRowIndex+1; j < selinfo[0].cRowIndex+crowSpan; j++)
                    *(pccolFixStart+j) += cColSpan;
            }

            if (i <= selinfo[1].cCellIndex)
            {
                for (j= selinfo[0].cRowIndex+1; j < selinfo[0].cRowIndex+crowSpan; j++)
                    *(pccolFixEnd+j) += cColSpan;
            }
        }
    }

    for (j=cRows-1; j >= 0; j--)
    {
        srpRow.Release();
        if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpRow)))
            goto Fail;

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        iColSpanCur = 0;
        _ASSERTE(iColSpanEnd-*(pccolFixEnd+j) >= 0);
        _ASSERTE(iColSpanStart-*(pccolFixStart+j) >= 0);

        for (i=0, k=0; iColSpanCur <= (iColSpanEnd-*(pccolFixEnd+j)) && k < cCells ; i++, k++)
        {
            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
                goto Fail;
            if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cColSpan)))
                goto Fail;

            if (iColSpanCur >= (iColSpanStart-*(pccolFixStart+j)) && iColSpanCur < (iColSpanEnd-*(pccolFixEnd+j)))
            {
                if (FAILED(hr = DeleteCellEx(srpTable, srpRow, j, i)))
                    goto Fail;
                i--; // we've deleted one cell, need to decrement cell index
            }

            iColSpanCur += cColSpan;
        }
    }

Fail:
    if (pccolFixStart != NULL)
     {
         delete [] pccolFixStart;
     }

    if (pccolFixEnd != NULL)
     {
         delete [] pccolFixEnd;
     }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTableCell
//
// Insert a table cell before the cell containing the Trident selection; copy
// the properties and style of the cell containing the selection to the new
// cell. The entire operation is a single undo unit. Returns S_OK or a Trident
// error.
//

HRESULT CTriEditDocument::InsertTableCell(void)
{
    HRESULT    hr = S_OK;
    struct SELCELLINFO    selinfo;
    CComPtr<IDispatch>    srpCellNew, srpCells;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();
    
    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo, NULL)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(selinfo.srpRow, L"insertCell", VTS_I4, selinfo.cCellIndex)))
       goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(selinfo.srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    srpCellNew.Release();
    if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, selinfo.cCellIndex, &srpCellNew)))
        goto Fail;

    CopyStyle(selinfo.srpCell, srpCellNew);
    CopyProperty(selinfo.srpCell, srpCellNew);

Fail:

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTableCells
//
// Delete the table cells contained within the Trident selection. Delete entire
// rows as indicated. The entire operation is a single undo unit. Return
// S_OK or a Trident error.
//

HRESULT CTriEditDocument::DeleteTableCells(void)
{
    CComPtr<IHTMLElement>       srpTable,srpCells;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG i=0, cCells=0;
    HRESULT      hr=0;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex) // same row
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        // if the selection is select all the cells in this row, delete the whole row instead
        if ( cCells == selinfo[1].cCellIndex+1 && selinfo[0].cCellIndex == 0)
        {
            if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
                goto Fail;
        }
        else // delete cell by cell
        {
            for (i = selinfo[1].cCellIndex; i >= selinfo[0].cCellIndex; i--)
            {
                if (FAILED(hr = DeleteCellEx(srpTable, selinfo[0].srpRow, selinfo[0].cRowIndex, i)))
                    goto Fail;
            }
         }
    }
    else
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[1].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

        // if the selection ends at the last cell of the row, delete the whole row instead
        if ( cCells == selinfo[1].cCellIndex+1)
        {
            if (FAILED(hr = DeleteRowEx(srpTable, selinfo[1].cRowIndex)))
                goto Fail;
        }
        else // delete cell by cell
        {
            for (i = selinfo[1].cCellIndex; i >= 0; i--)
            {
                if (FAILED(hr = DeleteCellEx(srpTable, selinfo[1].srpRow, selinfo[1].cRowIndex, i)))
                    goto Fail;
            }
        }
        
        for (i = selinfo[1].cRowIndex-1; i > selinfo[0].cRowIndex; i--)
        {
            if (FAILED(hr = DeleteRowEx(srpTable, i)))
                goto Fail;
        }

       
        if (selinfo[0].cCellIndex == 0) // if the selection is from first cell of a row across other rows, delete the whole row instead
        {
            if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
                goto Fail;
        }
        else // delete cell by cell
        {
            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            for (i = cCells-1; i >= selinfo[0].cCellIndex; i--)
            {
                if (FAILED(hr = DeleteCellEx(srpTable, selinfo[0].srpRow, selinfo[0].cRowIndex, i)))
                    goto Fail;
            }
        }
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MergeTableCells
//
// Merge the indicated cells in to a single cell, and adjust its colSpan.
// The cells must be within a single table row. The innerHTML of all merged cells
// is concatenated and placed in the remaining cell. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::MergeTableCells(IDispatch* srpTable, INT iRow, INT iIndexStart, INT iIndexEnd)
{
    CComPtr<IDispatch>    srpCells,srpRows,srpCurRow,srpCell;
    INT ccolSpanTotal=0, i=0, ccolSpan=0;
    HRESULT      hr=0;
    CComBSTR    bstrText;
    CComBSTR    bstrMergedText;

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, iRow, &srpCurRow)))
        goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(srpCurRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    bstrMergedText.Empty();
    ccolSpanTotal = 0;

    for (i = iIndexEnd; i >= iIndexStart; i--)
    {
        srpCell.Release();
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
            goto Fail;

        bstrText.Empty();
        if (FAILED(hr = GetDispatchProperty(srpCell, L"innerHTML", VT_BSTR, &bstrText)))
            goto Fail;
        bstrText += bstrMergedText;
        bstrMergedText = bstrText;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpan)))
            goto Fail;
        ccolSpanTotal += ccolSpan;

        if (i != iIndexStart)
        {
              if (FAILED(hr = DeleteCellEx((IHTMLElement*)srpTable, srpCurRow, iRow, i)))
                  goto Fail;
        }
        else
        {
            if (FAILED(hr = PutDispatchProperty(srpCell, L"colSpan", VT_I4, ccolSpanTotal)))
                goto Fail;
            if (FAILED(hr = PutDispatchProperty(srpCell, L"innerHTML", VT_BSTR, bstrMergedText)))
                goto Fail;
        }
    }
Fail:
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MergeTableCells
//
// Merge the cells in the Trident selection in to a single cell, and adjust that
// cell's colSpan. The cells must be within a single table row. The innerHTML of
// all merged cells is concatenated and placed in the remaining cell. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::MergeTableCells(void)
{
    CComPtr<IDispatch>       srpCell, srpCells,srpElement,srpRows,srpRow;
    CComPtr<IHTMLElement>   srpTable;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG i=0, cCells=0;
    HRESULT      hr=0;
    CComBSTR    bstrText;
    CComBSTR    bstrMergedText;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex)
    {
        if (selinfo[1].cCellIndex == selinfo[0].cCellIndex)
            {
                hr = S_OK;
                goto Fail;
            }

        if (FAILED(hr = MergeTableCells(srpTable, selinfo[0].cRowIndex, selinfo[0].cCellIndex, selinfo[1].cCellIndex)))
            goto Fail;
    }
    else
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[1].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = MergeTableCells(srpTable, selinfo[1].cRowIndex, 0, selinfo[1].cCellIndex)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
            goto Fail;

        for (i = selinfo[1].cRowIndex-1; i > selinfo[0].cRowIndex; i--)
        {
            srpElement.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpElement)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpElement, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            if (FAILED(hr = MergeTableCells(srpTable, i, 0, cCells-1)))
                goto Fail;
        }

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        if (FAILED(hr = MergeTableCells(srpTable, selinfo[0].cRowIndex, selinfo[0].cCellIndex, cCells-1)))
            goto Fail;

        bstrMergedText.Empty();
        for (i = selinfo[0].cRowIndex; i <= selinfo[1].cRowIndex; i++)
        {
            srpRows.Release();
            if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
                goto Fail;

            srpRow.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, selinfo[0].cRowIndex, &srpRow)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, 0, &srpCell)))
                goto Fail;

            bstrText.Empty();
            if (FAILED(hr = GetDispatchProperty(srpCell, L"innerHTML", VT_BSTR, &bstrText)))
                goto Fail;
            bstrMergedText += L"<P>";
            bstrMergedText += bstrText;
            bstrMergedText += L"</P>";

            if (i != selinfo[1].cRowIndex)
            {
                if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
                    goto Fail;
            }
        }
        if (FAILED(hr = PutDispatchProperty(srpCell, L"innerHTML", VT_BSTR, bstrMergedText)))
            goto Fail;
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SplitTableCell 
//
// Split the indicated table cell in to two cells and adjust the colSpan
// of the relevant cells in the other rows as needed. The entire operation is
// a single undo unit. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::SplitTableCell(IDispatch *srpTable, INT iRow, INT index)
{
    CComPtr<IDispatch>       srpCellSplit, srpCells,srpCell,srpElement,srpRows,srpRow,srpCurRow,srpCellNew;
    INT cRows=0,i=0,j=0,ccolSpan=0,ccolSpanCur=0,crowSpan=0, cCells=0;
    HRESULT      hr=0;
    CComBSTR    bstrText;
    INT *pccolFix = NULL;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();
    
    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, iRow, &srpCurRow)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpCurRow, L"insertCell", VTS_I4, index+1)))
        goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(srpCurRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    srpCellNew.Release();
    if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, index+1, &srpCellNew)))
        goto Fail;
                
    srpCellSplit.Release();
    if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, index, (void**)&srpCellSplit)))
        goto Fail;

    ccolSpan=0;
    if (FAILED(hr = GetDispatchProperty(srpCellSplit, L"colSpan", VT_I4, &ccolSpan)))
        goto Fail;

    CopyStyle(srpCellSplit, srpCellNew);
    CopyProperty(srpCellSplit, srpCellNew);
    
    if (ccolSpan == 1)
    {
        INT ccolSpanStart = 0,ccolSpanEnd=0;
        INT ccolSpanTmp = 0, cRowSpan = 0;

        pccolFix = new INT[cRows];
        for (j=0; j < cRows; j++)
            *(pccolFix+j) = 0;

        for (j=0; j<index;j++)
        {
            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, (void**)&srpCell)))
                goto Fail;

            ccolSpanTmp = 0;
            if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpanTmp)))
                goto Fail;
            ccolSpanStart += ccolSpanTmp;

            if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &cRowSpan)))
                goto Fail;

            if (cRowSpan > 1)
                for (i = index+1; i < index+cRowSpan; i++)
                    *(pccolFix+i) += ccolSpanTmp;
        }

        ccolSpanEnd = ccolSpanStart + ccolSpan;

        for (j=0; j < cRows; j++)
        {
            if (j == iRow)
                continue;

            srpRow.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpRow)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            ccolSpanCur = *(pccolFix+j);
            for(i=0 ; i < cCells; i++)
            {
                srpCell.Release();
                if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
                    goto Fail;

                ccolSpan=0;
                if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpan)))
                    goto Fail;

                if (ccolSpanStart <= ccolSpanCur && ccolSpanCur < ccolSpanEnd)
                {
                    if (FAILED(hr = PutDispatchProperty(srpCell, L"colSpan", VT_I4, ccolSpan+1)))
                        goto Fail;
                }

                if (ccolSpanCur >= ccolSpanEnd)
                    break;

                ccolSpanCur += ccolSpan;
            }
         }
     }
     else
     {
         if (FAILED(hr = PutDispatchProperty(srpCellNew, L"colSpan", VT_I4, ccolSpan/2)))
             goto Fail;

         if (FAILED(hr = PutDispatchProperty(srpCellSplit, L"colSpan", VT_I4, ccolSpan-ccolSpan/2)))
             goto Fail;
     }

    
      // now copy row span
     if (FAILED(hr = GetDispatchProperty(srpCellSplit, L"rowSpan", VT_I4, &crowSpan)))
         goto Fail;

     if (FAILED(hr = PutDispatchProperty(srpCellNew, L"rowSpan", VT_I4, crowSpan)))
         goto Fail;

Fail:
     if (pccolFix != NULL)
     {
         delete [] pccolFix;
      }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SplitTableCell 
//
// Split the table cell in the Trident selection in to two cells and adjust the
// colSpan of the relevant cells in the other rows as needed. The entire operation
// is a single undo unit. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::SplitTableCell(void)
{
    CComPtr<IDispatch>       srpCell, srpTable,srpCells,srpElement,srpRows,srpRow;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG i=0, j=0,cCells=0;
    HRESULT      hr=0;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable(&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex)
    {
        for (i = selinfo[1].cCellIndex; i >= selinfo[0].cCellIndex; i--)
        {
           if (FAILED(hr = SplitTableCell(srpTable, selinfo[0].cRowIndex, i)))
               goto Fail;
        }
    }
    else
    {
        for (i = selinfo[1].cCellIndex; i >= 0; i--)
        {
            if (FAILED(hr = SplitTableCell(srpTable, selinfo[1].cRowIndex, i)))
               goto Fail;
        }

        for (i = selinfo[1].cRowIndex-1; i > selinfo[0].cRowIndex; i--)
        {
            srpElement.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpElement)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpElement, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            for (j = cCells-1; j >= 0; j--)
            {
                if (FAILED(hr = SplitTableCell(srpTable, i, j)))
                    goto Fail;
            }
        }

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        for (i = cCells-1; i >= selinfo[0].cCellIndex; i--)
        {
            if (FAILED(hr = SplitTableCell(srpTable, selinfo[0].cRowIndex, i)))
               goto Fail;
        }
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTable
//
// Insert a table in to the document at the selection point. All parameters
// are optional and taken from members of pvarargIn as follows:
//
//      pvarargIn[0]    I4   - Number of rows; default 0.
//      pvarargIn[1]    I4   - Number of columns; default 0.
//      pvarargIn[2]    BSTR - Table tag attributes; default "".
//      pvarargIn[3]    BSTR - Table cell attributes; default "".
//      pvarargIn[4]    BSTR - Table caption; default "".
//
// pvarArgIn must be sipplied even if the default values are to be used for
// all parameters. The entire operation is a single undo unit. The wait cursor
// is displayed since this can be a fairly time-consuming operation. Returns S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::InsertTable(VARIANTARG *pvarargIn)
{
    HRESULT    hr=0;
    CComPtr<IHTMLSelectionObject>    srpSel;
    CComPtr<IDispatch> srpRange;
    CComPtr<IDispatch>    srpCell;
    CComPtr<IHTMLDocument2>    srpiHTMLDoc;
    CComBSTR    bstrHtml;
    CComBSTR    bstrTblAttr;
    CComBSTR    bstrTCellAttr;
    CComBSTR    bstrCaption;
    int i=0, j=0, iRow=0, iCol=0;
    VARIANT rgvar[5];
    HCURSOR hOldCursor;

    if (pvarargIn == NULL)
        return E_FAIL;

    hOldCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

    for(i = 0; i < sizeof(rgvar)/sizeof(VARIANT); i++)
        VariantInit(&rgvar[i]);

    // default
    iRow=1;
    iCol=1;
    bstrTCellAttr.Empty();
    bstrTblAttr.Empty();

    if (pvarargIn != NULL)
    {
        LONG lLBound=0, lUBound=0,lIndex=0;
        SAFEARRAY *psa;
        LONG cParam; // number of parameters host passes in

        psa = V_ARRAY(pvarargIn);
        SafeArrayGetLBound(psa, 1, &lLBound);
        SafeArrayGetUBound(psa, 1, &lUBound);
        cParam = 0;
        _ASSERTE(lLBound == 0);
        _ASSERTE(lUBound -  lLBound < 5);
        for (lIndex = lLBound; lIndex <= lUBound && cParam < sizeof(rgvar)/sizeof(VARIANT); lIndex++)
        {
             SafeArrayGetElement(psa, &lIndex, &rgvar[cParam++]);
        }

        // first element: number of rows
        if (cParam >= 1)
            iRow = V_I4(&rgvar[0]);
        // 2'rd element: number of columns
        if (cParam >= 2)
            iCol = V_I4(&rgvar[1]);
        // 3'rd element: table tag attributes
        if (cParam >= 3)
            bstrTblAttr = V_BSTR(&rgvar[2]);
        // 4'th element: table cell tag attributes
        if (cParam >= 4)
            bstrTCellAttr = V_BSTR(&rgvar[3]);
        if (cParam >= 5)
            bstrCaption = V_BSTR(&rgvar[4]);
    }

    if (iRow < 0 || iCol < 0)
        goto Fail;

    bstrHtml.Empty();
    bstrHtml += "<TABLE ";
    if (bstrTblAttr != NULL)
        bstrHtml += bstrTblAttr;
    bstrHtml += ">";

    if (bstrCaption != NULL)
    {
         bstrHtml += "<CAPTION>";
         bstrHtml += bstrCaption;
         bstrHtml += "</CAPTION>";
    }

    bstrHtml +="<TBODY>";

    for (i=0; i<iRow; i++)
    {
        bstrHtml += "<TR>";
        for (j=0; j<iCol; j++)
        {
            bstrHtml += "<TD ";
            if (bstrTCellAttr != NULL)
                bstrHtml += bstrTCellAttr;
            bstrHtml +="></TD>";
        }
        bstrHtml += "</TR>";
    }
    bstrHtml += "</TBODY></TABLE>";

    if (FAILED(hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(hr = srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpRange)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRange, L"pasteHTML", VTS_BSTR, bstrHtml)))
        goto Fail;

Fail:

    for(i = 0; i < sizeof(rgvar)/sizeof(VARIANT); i++)
        VariantClear(&rgvar[i]);

    ::SetCursor(hOldCursor);
    return hr;

}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DoVerb
//
// Execute the verb in pvarargIn (or OLEIVERB_PRIMARY if pvarargIn is NULL)
// on the current object (which must QI for IHTMLObjectElement). Return E_FAIL
// or the code returned as a result of executing the verb,
//

HRESULT CTriEditDocument::DoVerb(VARIANTARG *pvarargIn, BOOL fQueryStatus)
{
    LONG iVerb;
    IHTMLObjectElement *piHTMLObjectElement = NULL;
    IDispatch *pDisp = NULL;
    IOleObject *pOleObj = NULL;
    HRESULT hr = E_FAIL;

    _ASSERTE(m_pihtmlElement != NULL);

    if (SUCCEEDED(m_pihtmlElement->QueryInterface(IID_IHTMLObjectElement, (void **)&piHTMLObjectElement)) && piHTMLObjectElement)
    {
        if (SUCCEEDED(piHTMLObjectElement->get_object(&pDisp)) && pDisp)
        {
            if (SUCCEEDED(pDisp->QueryInterface(IID_IOleObject, (void **)&pOleObj)) && pOleObj)
            {
                if (fQueryStatus) // In the query status case, we're done
                    hr = S_OK;
                else
                {
                    if (pvarargIn == NULL)
                        iVerb = OLEIVERB_PRIMARY;
                    else if (pvarargIn->vt == VT_I4)
                        iVerb = V_I4(pvarargIn);    
                    else
                    {
                        hr = E_INVALIDARG;
                        goto LSkipDoVerb;
                    }

                    GetTridentWindow();
                    _ASSERTE(m_hwndTrident != NULL);

                    hr = pOleObj->DoVerb(iVerb, NULL, NULL, 0, m_hwndTrident, NULL);
                }
LSkipDoVerb:
                pOleObj->Release();
            }
            pDisp->Release();
        }
        piHTMLObjectElement->Release();
    }

    return hr;

}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetDocument
//
// Return the IHTMLDocument pointer (under *ppihtmlDocument) and S_OK, or
// E_FAIL/E_POINTER.
//

STDMETHODIMP CTriEditDocument::GetDocument(IHTMLDocument2** ppihtmlDocument)
{
    _ASSERTE(ppihtmlDocument);
    if (ppihtmlDocument)
    {
        if (m_pUnkTrident)
        {
            return m_pUnkTrident->QueryInterface(IID_IHTMLDocument2,
                        (LPVOID*)ppihtmlDocument);
        }
        return E_FAIL;
    }
    return E_POINTER;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetAllColllection
//
// Return the all collection of the HTML document (under *ppihtmlCollection),
// or E_FAIL.
//

STDMETHODIMP CTriEditDocument::GetAllCollection(IHTMLElementCollection** ppihtmlCollection)
{
    IHTMLDocument2* pihtmlDoc2;
    HRESULT hr=E_FAIL;

    _ASSERTE(ppihtmlCollection);
    if (ppihtmlCollection && SUCCEEDED(GetDocument(&pihtmlDoc2)))
    {
        _ASSERTE(pihtmlDoc2);
        hr = pihtmlDoc2->get_all(ppihtmlCollection);
        pihtmlDoc2->Release();
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetCollectionElement
//
// Return the indicated element from the given collection under *ppihtmlElement.
// Return S_OK if all goes well,or E_FAIL or a Triedent error on error.
//

STDMETHODIMP CTriEditDocument::GetCollectionElement(
    IHTMLElementCollection* pihtmlCollection,
    LONG iElem, IHTMLElement** ppihtmlElement)
{
    VARIANT var;
    VARIANT varEmpty;
    IDispatch* pidispElement=NULL;
    HRESULT hr = E_FAIL;

    _ASSERTE(pihtmlCollection && iElem >= 0 && ppihtmlElement);
    if (!pihtmlCollection || iElem < 0 || !ppihtmlElement)
        return E_POINTER;

    *ppihtmlElement = NULL;     //initialize [out] parameter

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = iElem;

    VariantInit(&varEmpty);
    varEmpty.vt = VT_EMPTY;

    hr = pihtmlCollection->item(var, varEmpty, &pidispElement);
    if (SUCCEEDED(hr))
    {
        if (pidispElement)
        {
            hr = pidispElement->QueryInterface(IID_IHTMLElement, (LPVOID*)ppihtmlElement);
            pidispElement->Release();
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::Is2DCapable
//
// Return (under *pfBool) TRUE if the given HTML element can be positioned
// out of the flow as a 2D element, or FALSE if not. Return S_OK in either
// case. Return E_FAIL or a Trident error if something goes wrong.
// 

STDMETHODIMP CTriEditDocument::Is2DCapable(IHTMLElement* pihtmlElement, BOOL* pfBool)
{
    HRESULT hr= E_FAIL;
    CComBSTR bstrTag;

    _ASSERTE(pihtmlElement);

    if (!pihtmlElement || !pfBool)
        return E_POINTER;

    *pfBool = FALSE;

     bstrTag.Empty();
     if (FAILED(hr = GetDispatchProperty(pihtmlElement, L"tagName", VT_BSTR, &bstrTag)))
            return E_FAIL;

     if (lstrcmpi(_T("APPLET"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("BUTTON"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("DIV"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("EMBED"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("FIELDSET"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("HR"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("IFRAME"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("IMG"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("INPUT"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("MARQUEE"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("OBJECT"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("SELECT"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("SPAN"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("TABLE"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("TEXTAREA"), OLE2T(bstrTag)) == 0 )
    {
        *pfBool = TRUE;
        return S_OK;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SelectElement
//
// Select the given element within Trident as a site selection. Return S_OK or
// a Trident error.
//

STDMETHODIMP CTriEditDocument::SelectElement(IHTMLElement* pihtmlElement, IHTMLElement* pihtmlElementParent)
{
    IHTMLControlElement* picont=NULL;
    IHTMLElement* piParent=NULL;
    IDispatch* pidisp=NULL;
    IHTMLTextContainer* pitext=NULL;
    IHTMLControlRange* pirange=NULL;
    HRESULT hr;
    CComBSTR bstrTag;

    if ( !pihtmlElement || !pihtmlElementParent )
        return E_FAIL;
    
    hr = pihtmlElement->QueryInterface(IID_IHTMLControlElement, (LPVOID*)&picont);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(picont);

    hr = pihtmlElementParent->QueryInterface(IID_IHTMLTextContainer, (LPVOID*)&pitext);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(pitext);

    hr = pitext->createControlRange(&pidisp);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(pitext);

    hr = pidisp->QueryInterface(IID_IHTMLControlRange, (LPVOID*)&pirange);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(pirange);

    hr = pirange->add(picont);

    if ( FAILED(hr) )
        goto CleanUp;

    hr = pirange->select();

CleanUp:
    SAFERELEASE(picont);
    SAFERELEASE(piParent);
    SAFERELEASE(pidisp);
    SAFERELEASE(pitext);
    SAFERELEASE(pirange);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsElementDTC
//
// Return S_OK if the given element is a DTC (Design-Time Control) or E_FAIL 
// if not.
//

HRESULT CTriEditDocument::IsElementDTC(IHTMLElement *pihtmlElement)
{
    IHTMLObjectElement *piHTMLObjectElement = NULL;
    IDispatch *pDisp = NULL;
    IActiveDesigner *piActiveDesigner = NULL;
    IUnknown *piUnk = NULL;

    if (SUCCEEDED(pihtmlElement->QueryInterface(IID_IHTMLObjectElement, (void **)&piHTMLObjectElement)) && piHTMLObjectElement)
    {
        if (SUCCEEDED(piHTMLObjectElement->get_object(&pDisp)) && pDisp)
        {
            if (SUCCEEDED(pDisp->QueryInterface(IID_IUnknown, (void **)&piUnk)) && piUnk)
            {
                if (SUCCEEDED(piUnk->QueryInterface(IID_IActiveDesigner, (void **)&piActiveDesigner)) && piActiveDesigner)
                {
                    piHTMLObjectElement->Release();
                    pDisp->Release();
                    piUnk->Release();
                    piActiveDesigner->Release();
                    return S_OK;
                }
                piUnk->Release();
            }
            pDisp->Release();
        }
        piHTMLObjectElement->Release();
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\ioleobj.cpp ===
//------------------------------------------------------------------------------
// ioleobj.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      6-27-97      created     (bash)
//
// Implementation of IOleObject.
//
// We mostly just delegate to Trident's IOleObject, except
// for GetUserClassID and GetUserType.  We also cache the
// host's clientsite and uihandler interfaces in SetClientSite.
//------------------------------------------------------------------------------

#include "stdafx.h"

#include "triedit.h"
#include "document.h"

STDMETHODIMP CTriEditDocument::SetClientSite(IOleClientSite *pClientSite)
{
    ATLTRACE(_T("IOleObjectImpl::SetClientSite\n"));

    HRESULT hr;
    ICustomDoc *pCustomDoc = NULL;

    _ASSERTE(m_pOleObjTrident);
    
    SAFERELEASE(m_pClientSiteHost);
    SAFERELEASE(m_pUIHandlerHost);
    SAFERELEASE(m_pDragDropHandlerHost);

    m_pClientSiteHost = pClientSite;
    if (NULL != m_pClientSiteHost)
    {
        m_pClientSiteHost->AddRef(); 
        m_pClientSiteHost->QueryInterface(IID_IDocHostUIHandler, (void **) &m_pUIHandlerHost);
        m_pClientSiteHost->QueryInterface(IID_IDocHostDragDropHandler, (void **) &m_pDragDropHandlerHost);
    }

    hr = m_pOleObjTrident->SetClientSite(pClientSite);

    if (!m_fUIHandlerSet)
    {
        // Give Trident the pointer to our IDocHostUIHandler
        // This has to be done after the SetClientSite call due to a Trident bug

        hr = m_pUnkTrident->QueryInterface(IID_ICustomDoc, (void **) &pCustomDoc);
        if (SUCCEEDED(hr) && m_pUIHandler)
        {
            hr = pCustomDoc->SetUIHandler(static_cast<IDocHostUIHandler*>(m_pUIHandler));

            pCustomDoc->Release();
        }

    m_fUIHandlerSet = TRUE;

    // We can only call this after SetClientSite or else Trident will crash
    SetUpDefaults();
    }

#ifdef IE5_SPACING
    // instantiate the sink
    if (NULL != m_pClientSiteHost)
    {
        CComPtr<IHTMLDocument2> pHTMLDocument2;

        m_pTridentEventSink = NULL;
        hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&pHTMLDocument2);
        if (hr == S_OK && pHTMLDocument2 != NULL)
        {
            m_pTridentEventSink = new CComObject<CTridentEventSink>;
            if (m_pTridentEventSink != NULL)
            {
                m_pTridentEventSink->m_pHTMLDocument2 = pHTMLDocument2;
                m_pTridentEventSink->m_pTriEditDocument = this;
                hr = m_pTridentEventSink->AddRef();
                hr = m_pTridentEventSink->Advise(m_pTridentEventSink->m_pHTMLDocument2, DIID_HTMLDocumentEvents);
            }
        }
    }
    else
    {
        if (m_pTridentEventSink)
        {
            m_pTridentEventSink->Unadvise();
            hr = m_pTridentEventSink->Release();
        }
    }
#endif //IE5_SPACING

    return hr;
}

STDMETHODIMP CTriEditDocument::GetClientSite(IOleClientSite **ppClientSite)
{
    ATLTRACE(_T("IOleObjectImpl::GetClientSite\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetClientSite(ppClientSite);
}

STDMETHODIMP CTriEditDocument::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    ATLTRACE(_T("IOleObjectImpl::SetHostNames\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetHostNames(szContainerApp, szContainerObj);
}

STDMETHODIMP CTriEditDocument::Close(DWORD dwSaveOption)
{
    ATLTRACE(_T("IOleObjectImpl::Close\n"));

    _ASSERTE(m_pOleObjTrident);

    ReleaseElement();

    return m_pOleObjTrident->Close(dwSaveOption);
}

STDMETHODIMP CTriEditDocument::SetMoniker(DWORD dwWhichMoniker, IMoniker* pmk)
{
    ATLTRACE(_T("IOleObjectImpl::SetMoniker\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetMoniker(dwWhichMoniker, pmk);
}

STDMETHODIMP CTriEditDocument::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk )
{
    ATLTRACE(_T("IOleObjectImpl::GetMoniker\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
}

STDMETHODIMP CTriEditDocument::InitFromData(IDataObject*  pDataObject, BOOL fCreation, DWORD dwReserved)
{
    ATLTRACE(_T("IOleObjectImpl::InitFromData\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->InitFromData(pDataObject,  fCreation,  dwReserved );
}

STDMETHODIMP CTriEditDocument::GetClipboardData(DWORD dwReserved, IDataObject** ppDataObject)
{
    ATLTRACE(_T("IOleObjectImpl::GetClipboardData\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetClipboardData(dwReserved, ppDataObject);
}


STDMETHODIMP CTriEditDocument::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite , LONG lindex ,
                                 HWND hwndParent, LPCRECT lprcPosRect)
{
    ATLTRACE(_T("IOleObjectImpl::DoVerb\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
}

STDMETHODIMP CTriEditDocument::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    ATLTRACE(_T("IOleObjectImpl::EnumVerbs\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->EnumVerbs(ppEnumOleVerb);
}

STDMETHODIMP CTriEditDocument::Update(void)
{
    ATLTRACE(_T("IOleObjectImpl::Update\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->Update();
}

STDMETHODIMP CTriEditDocument::IsUpToDate(void)
{
    ATLTRACE(_T("IOleObjectImpl::IsUpToDate\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->IsUpToDate();
}

STDMETHODIMP CTriEditDocument::GetUserClassID(CLSID *pClsid)
{
    ATLTRACE(_T("IOleObjectImpl::GetUserClassID\n"));

    _ASSERTE(m_pOleObjTrident);

    *pClsid = GetObjectCLSID();

    return S_OK;
}

STDMETHODIMP CTriEditDocument::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    ATLTRACE(_T("IOleObjectImpl::GetUserType\n"));

    _ASSERTE(m_pOleObjTrident);

    return OleRegGetUserType(GetObjectCLSID(), dwFormOfType, pszUserType);
}

STDMETHODIMP CTriEditDocument::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    ATLTRACE(_T("IOleObjectImpl::SetExtent\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CTriEditDocument::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    ATLTRACE(_T("IOleObjectImpl::GetExtent\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CTriEditDocument::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    ATLTRACE(_T("IOleObjectImpl::Advise\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP CTriEditDocument::Unadvise(DWORD dwConnection)
{
    ATLTRACE(_T("IOleObjectImpl::Unadvise\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->Unadvise(dwConnection);
}

STDMETHODIMP CTriEditDocument::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    ATLTRACE(_T("IOleObjectImpl::EnumAdvise\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP CTriEditDocument::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    ATLTRACE(_T("IOleObjectImpl::GetMiscStatus\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetMiscStatus(dwAspect, pdwStatus);
}

STDMETHODIMP CTriEditDocument::SetColorScheme(LOGPALETTE* pLogpal)
{
    ATLTRACE(_T("IOleObjectImpl::SetColorScheme\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetColorScheme(pLogpal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\lex.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __LEX__
#define __LEX__

#include <tchar.h>

#include "fmtinfo.h"
#include "token.h"

#define P_IN(x)     const x &
#define P_OUT(x)    x &
#define P_IO(x)     x &
#define PURE        = 0

// Lex state, kept at the beginning of every line (lxsBOL) from
// previous line's state at its end (lxsEOL). Must fit all bits
// necessary to restart lexing on a line by line basis.

typedef DWORD   LXS;
typedef LXS *   PLXS;

// Lexer and language Metrics
const unsigned ctchUserTokenPhrase = 100;
struct USERTOKENS
{
    INT         token;      // preassigned in the user range
    TCHAR       szToken[ctchUserTokenPhrase+1]; // token class name exposed to user
    COLORREF    RGBText;
    COLORREF    RGBBackground;
    AUTO_COLOR  autocolorFore;
    AUTO_COLOR  autocolorBack;
};
typedef USERTOKENS *        PUSERTOKENS;
typedef const USERTOKENS *  PCUSERTOKENS;


// Alternate way of looking at a token, editor will only look at tokUser.
// Other clients of the lexer (like the parser or the EE) may want to look
// at the actual token in tokAct.  If any of tokAct is set, then it is expected
// that the actual token is different than the meta token it passed back.
// The status bits are only used by the lexer for whatever it wants.

union TOK_ALT  {
    TOKEN   tok;
    struct {
        unsigned        tokUser : 12;
        unsigned        tokUserStatus : 4;
        unsigned        tokAct : 12;
        unsigned        tokActStatus : 4;
    };
};


// A SUBLANG structure was originally used for identifying different
// dialects of the same language (like fortran fixed and fortran free)
// that use the same lexer, can be treated as two languages in the editor,
// and share all the same color/font info in the format dialog.
//
// We've extended it to be a general descriptor for a type of text file.
//
struct SUBLANG
{
    LPCTSTR szSubLang;
    LXS     lxsInitial;
    UINT    nIdTemplate; // Icon and MFC doc template string resource id
    CLSID   clsidTemplate;
};
typedef SUBLANG * PSUBLANG;
typedef const SUBLANG * PCSUBLANG;

#define MAX_LANGNAMELEN (50)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\tried\triedit\htmparse.cpp ===
// HtmParse.cpp : Implementation of CHtmParse
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
#include "stdafx.h"

#include <designer.h>
#include <time.h> // for random number generation

#include "triedit.h"
#include "HtmParse.h"
#include "table.h"
#include "lexer.h"
#include "guids.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CTriEditParse
#undef ASSERT
#define ASSERT(b) _ASSERTE(b)

#ifdef NEEDED
inline int 
indexPrevtokTagStart(int index, TOKSTRUCT *pTokArray)
{
    while (    (index >= 0)
            && (pTokArray[index].token.tokClass != tokTag)
            && (pTokArray[index].token.tok != TokTag_START)
            )
    {
            index--;
    }
    return(index);
}

inline int
indexPrevTokElem(int index, TOKSTRUCT *pTokArray)
{
    while (    (index >= 0)
            && (pTokArray[index].token.tokClass != tokElem)
            )
    {
            index--;
    }
    return(index);
}
#endif //NEEDED

BOOL
FIsWhiteSpaceToken(WCHAR *pwOld, int indexStart, int indexEnd)
{
    BOOL fWhiteSpace = TRUE;
    int index;

    for (index = indexStart; index < indexEnd; index++)
    {
        if (   pwOld[index] != ' '
            && pwOld[index] != '\t'
            && pwOld[index] != '\r'
            && pwOld[index] != '\n'
            )
        {
            fWhiteSpace = FALSE;
            break;
        }
    }
    return (fWhiteSpace);
} /* FIsWhiteSpaceToken() */

inline void GlobalUnlockFreeNull(HGLOBAL *phg)
{
    GlobalUnlock(*phg); // do we need to check if this was already Unlocked?
    GlobalFree(*phg);
    *phg = NULL;
}

BOOL
FIsAbsURL(LPOLESTR pstr)
{
    LPCWSTR szHttp[] = {L"http:"};
    LPCWSTR szFile[] = {L"file:"};
    BOOL fRet = FALSE;

    if (pstr == NULL)
        goto LRet;

    if (   0 == _wcsnicmp(szHttp[0], pstr, wcslen(szHttp[0]))
        || 0 == _wcsnicmp(szFile[0], pstr, wcslen(szFile[0]))
        )
    {
        fRet = TRUE;
        goto LRet;
    }
LRet:
    return(fRet);
}

BOOL
FURLNeedSpecialHandling(TOKSTRUCT *pTokArray, int iArray, LPWSTR pwOld, int cMaxToken, int *pichURL, int *pcchURL)
{
    int index = iArray+1;
    int iHref = -1;
    int iURL = -1;
    BOOL fRet = FALSE;
    BOOL fCodeBase = FALSE;

    while (    index < cMaxToken
            && pTokArray[index].token.tok != TokTag_CLOSE
            && pTokArray[index].token.tokClass != tokTag
            ) // look for TokAttrib_HREF
    {
        if (   iHref == -1
            && (   pTokArray[index].token.tok == TokAttrib_HREF
                || pTokArray[index].token.tok == TokAttrib_SRC
                || pTokArray[index].token.tok == TokAttrib_CODEBASE
                )
            && pTokArray[index].token.tokClass == tokAttr
            )
        {
            iHref = index;
            // special case - if we have CODEBASE attribute, we always want special processing
            if (pTokArray[index].token.tok == TokAttrib_CODEBASE)
                fCodeBase = TRUE;
        }
        if (   iHref != -1
            && pTokArray[index].token.tok == 0
            && (pTokArray[index].token.tokClass == tokString || pTokArray[index].token.tokClass == tokValue)
            )
        {
            iURL = index;
            break;
        }
        index++;
    }
    if (iURL != -1) // its set properly
    {
        int cchURL;
        WCHAR *pszURL;
        BOOL fQuote = (pwOld[pTokArray[iURL].token.ibTokMin] == '"');

        cchURL = (fQuote)
                ? pTokArray[iURL].token.ibTokMac-pTokArray[iURL].token.ibTokMin-2
                : pTokArray[iURL].token.ibTokMac-pTokArray[iURL].token.ibTokMin;
        *pichURL = (fQuote)
                ? pTokArray[iURL].token.ibTokMin+1
                : pTokArray[iURL].token.ibTokMin;
        // special case - if the quoted value happens to be a serverside script,
        // we can ignore it here and decalre that we don't need to do any special 
        // processing.
        if (   ((pTokArray[iURL].token.ibTokMac-pTokArray[iURL].token.ibTokMin) == 1)
            || (cchURL < 0)
            )
        {
            *pcchURL = 0;
            goto LRet;
        }
        *pcchURL = cchURL;
        // special case - if we have CODEBASE attribute, we always want special processing
        // we don't need to see if its URL is absolute or not...
        if (fCodeBase)
        {
            fRet = TRUE;
            goto LRet;
        }

        pszURL = new WCHAR [cchURL+1];

        ASSERT(pszURL != NULL);
        memcpy( (BYTE *)pszURL,
                (BYTE *)&pwOld[pTokArray[iURL].token.ibTokMin + ((fQuote)? 1 : 0)],
                (cchURL)*sizeof(WCHAR));
        pszURL[cchURL] = '\0';
        if (!FIsAbsURL((LPOLESTR)pszURL))
            fRet = TRUE;
        delete pszURL;
    } // if (iURL != -1)

LRet:
    return(fRet);
}


// Copied from hu_url.cpp 
//-----------------------------------------------------------------------------
// Useful directory separator check
//-----------------------------------------------------------------------------
inline BOOL IsDirSep(CHAR ch)
{
    return ('\\' == ch || '/' == ch);
}

inline BOOL IsDirSep(WCHAR ch)
{
    return (L'\\' == ch || L'/' == ch);
}



//-----------------------------------------------------------------------------
//  UtilConvertToRelativeURL
//
//  Returns an item-relative URL.
//      The URL is returned identical if
//          the projects don't match
//          the protocols don't match
//
//  Assumes that protocol-less URLs are "http:". Must specify "file:" explicitly
//  to play with file URLs. 
//-----------------------------------------------------------------------------

static LPOLESTR
SkipServer(LPOLESTR pstr)
{
    pstr = wcschr(pstr, L'/');
    if (pstr == NULL)
        return NULL;
    pstr = wcschr(pstr+1, L'/');
    if (pstr == NULL)
        return NULL;
    pstr = wcschr(pstr+1, L'/');

    return pstr;            // positioned on the slash if there was one.
}

static LPOLESTR
SkipFile(LPOLESTR pstr)
{
    LPOLESTR    pstrT;

    pstrT = wcspbrk(pstr, L":\\/");
    if (pstr == NULL || pstrT == NULL)
        return pstr;

    // Guard against the case "//\\".

    if (pstrT == pstr &&
            IsDirSep(pstr[0]) &&
            IsDirSep(pstr[1]))
    {
        if (IsDirSep(pstr[2]) && IsDirSep(pstr[3]))
        {
            pstrT = pstr + 2;           // saw a "//\\"
        }
        else if (pstr[2] != L'\0'  && pstr[3] == L':')
        {
            pstrT = pstr + 3;           // saw a "//c:"
        }
    }

    ASSERT(!wcschr(pstrT + 1, ':')); // better not be more colons!
    if (*pstrT == ':')  // drive letter possibility
    {
        return pstrT + 1;               // point at the character after the colon
    }
    if (pstrT[0] == pstrT[1])           // double slash?
    {
        // Skip server part. 

        pstrT = wcspbrk(pstrT + 2, L"\\/");
        if (pstrT == NULL)
            return pstr;                // malformed!

        // Skip share part.

        pstrT = wcspbrk(pstrT + 1, L"\\/");
        if (pstrT == NULL)
            return pstr;                // malformed!

        return pstrT;
    }

    return pstr;
}

static LPOLESTR
FindLastSlash(LPOLESTR pstr)
{
    LPOLESTR    pstrSlash;      // '/'
    LPOLESTR    pstrWhack;      // '\'

    pstrSlash = wcsrchr(pstr, L'/');
    pstrWhack = wcsrchr(pstr, L'\\');

    return pstrSlash > pstrWhack
            ? pstrSlash
            : pstrWhack;
}

HRESULT
UtilConvertToRelativeURL(
    LPOLESTR    pstrDestURL,        // URL to 'relativize'
    LPOLESTR    pstrDestFolder,     // URL to be relative to.
    LPOLESTR    pstrDestProject,    // Project to be relative to.
    BSTR *      pbstrRelativeURL)
{
    HRESULT     hr = S_OK;
    LPOLESTR    pstrFolder;
    LPOLESTR    pstrURL;
    LPOLESTR    pchLastSlash;
    CComBSTR    strWork;
    int         cch;
    int         cchFolder;
    int         i;
    int         ichLastSlash;
    bool        fAbsoluteURL = false;
    bool        fAbsoluteFolder = false;
    bool        fFileURL = false;

    // If there's a ':' in the URL we're relativizing, it's assumed
    // to contain a protocol. If the protocol isn't "http:".

    if (!FIsAbsURL(pstrDestURL)) // VID6 - bug 22895
        goto Copy;

    pstrURL = pstrDestURL;
    if (wcschr(pstrDestURL, L':'))
    {
        // Check the protocol against the two we understand. If it is some other thing,
        // we punt.

        if (wcsncmp(pstrDestURL, L"http:", 5) != 0)
        {
            if (wcsncmp(pstrDestURL, L"file:", 5) != 0)
                goto Copy;

            // File URLs are normalized by skipping any '\\server\share' part.

            fFileURL = true;
            pstrURL = SkipFile(pstrDestURL + 5); // 5 skips the 'file:' prefix
        }
        else if (pstrDestProject != NULL)
        {
            // Project-relative URLs had better match the project prefix.

            cch = wcslen(pstrDestProject);
            if (_wcsnicmp(pstrDestURL, pstrDestProject, cch) != 0)
                goto Copy;

            // Project-relative URLs are normalized by skipping the project prefix.

            pstrURL = pstrDestURL + cch - 1;
            ASSERT(*pstrURL == '/');
        }
        else
        {
            // Generic 'http:' URLs skip the server part only.

            pstrURL = SkipServer(pstrDestURL);
            ASSERT(*pstrURL == '/');
        }

        if (!pstrURL)
            goto Copy;
        fAbsoluteURL = true;
    }

    // If the folder contains an 'http:' prefix, then find the server and skip that part.
    // otherwise it's assumed the folder is already in a project-relative format.

    pstrFolder = pstrDestFolder;

    if (NULL == pstrFolder)
        goto Copy;

    if (wcsncmp(pstrDestFolder, L"file://", 7) == 0)
    {
        if (!fFileURL)
            goto Copy;

        pstrFolder = SkipFile(pstrDestFolder + 5);
        fAbsoluteFolder = true;
    }
    else if (wcsncmp(pstrDestFolder, L"http://", 7) == 0)
    {
        if (pstrDestProject != NULL)
        {
            // If a project was passed in, make sure the place we're relativizing to has the same path.
            // If they don't match, we're in trouble.

            cch = wcslen(pstrDestProject);
            if (_wcsnicmp(pstrDestFolder, pstrDestProject, cch) != 0)
                goto Copy;
            pstrFolder = pstrDestFolder + cch - 1;
        }
        else
        {
            pstrFolder = SkipServer(pstrDestFolder);
        }
        ASSERT(pstrFolder);
        ASSERT(*pstrFolder == '/');
        fAbsoluteFolder = true;
    }

    // If both the URL and the folder had absolute paths, we need to ensure
    // that the servers are the same.

    if (fAbsoluteFolder && fAbsoluteURL)
    {
        if (pstrURL - pstrDestURL != pstrFolder - pstrDestFolder ||
                _wcsnicmp(pstrDestURL, pstrDestFolder, SAFE_PTR_DIFF_TO_INT(pstrURL - pstrDestURL)) != 0)
            goto Copy;
    }

    // From now on, ignore the item at the end of pstrFolder

    pchLastSlash = FindLastSlash(pstrFolder);
    ASSERT(pchLastSlash);
    cchFolder = 1 + SAFE_PTR_DIFF_TO_INT(pchLastSlash - pstrFolder);

    // Both folder and item are now relative to the server root.

    // Locate the last slash in the URL. 

    pchLastSlash = FindLastSlash(pstrURL);

    if (pchLastSlash == NULL)
        ichLastSlash = 0;
    else
        ichLastSlash = 1 + SAFE_PTR_DIFF_TO_INT(pchLastSlash - pstrURL);

    // Find any common directories. 

    cch = min(cchFolder, ichLastSlash);
    ichLastSlash = -1;
    for (i = 0; i < cch && pstrFolder[i] == pstrURL[i]; ++i)
    {
        if (IsDirSep(pstrFolder[i]))
            ichLastSlash = i;
    }

    // ichLastSlash should point beyond at last slash of the last common folder.

    // For each remaining slash, append a ../ to the path.

    for (; i < cchFolder; ++i)
    {
        if (IsDirSep(pstrFolder[i]))
        {
            strWork += (fFileURL ? L"..\\" : L"../");
        }
    }

    if (-1 == ichLastSlash)
    {   // no common parts, append all of the destination
        strWork += pstrURL;
    }
    else
    {   // append only the non-match part of the destination

        strWork += (pstrURL + ichLastSlash + 1);
    }


Cleanup:
    *pbstrRelativeURL = strWork.Copy();
    if (!*pbstrRelativeURL && ::wcslen(strWork) > 0)
        hr = E_OUTOFMEMORY;

    return hr;

Copy:
    strWork = pstrDestURL;
    goto Cleanup;
}




long CTriEditParse::m_bInit = 0;

CTriEditParse::CTriEditParse()
{
    m_rgSublang = 0;
    m_fHasTitleIn = FALSE;
    m_hgPTDTC = NULL;
    m_cchPTDTC = 0;
    m_ichBeginHeadTagIn = -1;
    m_ispInfoBase = 0;

    if(0 == m_bInit++)
        InitSublanguages();
}

CTriEditParse::~CTriEditParse()
{
    // save last variant as default if it's not ASP
    if (NULL != m_rgSublang)
    {
        for( int i= 0; NULL != m_rgSublang[i].szSubLang; i++)
        {
            delete [] (LPTSTR)(m_rgSublang[i].szSubLang);
        }
        delete [] m_rgSublang;
    }
    ASSERT(0 != m_bInit);

    if(0 == --m_bInit)
    {
        ATLTRACE(_T("Releasing tables\n"));

        // delete dynamically allocated tables
        for (int i = 0; NULL != g_arpTables[i]; i++)
            delete g_arpTables[i];
        delete g_pTabDefault;

        m_bInit = 0;
    }

}


// copied from CColorHtml::NextToken
STDMETHODIMP CTriEditParse::NextToken
(
    LPCWSTR pszText,
    UINT    cbText,
    UINT*   pcbCur,
    DWORD*  pLXS,
    TXTB*   pToken
)
{
    ASSERT(pszText != NULL);
    ASSERT(pcbCur != NULL);
    ASSERT(pLXS != NULL);
    ASSERT(pToken != NULL);
    USES_CONVERSION;

    if(pszText == NULL || pcbCur == NULL || pLXS == NULL || pToken == NULL)
        return E_INVALIDARG;

    if(0 == cbText)
        return S_FALSE;

    SetTable(*pLXS); // set g_pTable according to state

#ifdef _UNICODE
    *pcbCur = GetToken(pszText, cbText, *pcbCur, pLXS, *pToken);
#else   // _UNICODE
    int     cch;
    LPTSTR  pszTemp;

    // get the converted length
    cch = WideCharToMultiByte(CP_ACP, 0, pszText, cbText,
        NULL, 0, NULL, NULL);
    pszTemp = new char[cch + 1];

    ZeroMemory(pszTemp, cch + 1);
    // copy the wide char to multibyte
    WideCharToMultiByte(CP_ACP, 0, pszText, cbText, pszTemp, cch,
        NULL, NULL);

    *pcbCur = GetToken(pszTemp, cch, *pcbCur, pLXS, *pToken);

    delete [] pszTemp;
#endif  // _UNICODE

    return (*pcbCur < cbText) ? NOERROR : S_FALSE;
}



// set g_pTable according to state
void CTriEditParse::SetTable(DWORD lxs)
{
    ASSERT(SubLangIndexFromLxs(lxs) < sizeof g_arpTables/sizeof g_arpTables[0]);
    g_pTable = g_arpTables[SubLangIndexFromLxs(lxs)];

    ASSERT(g_pTable != NULL);
}

void CTriEditParse::InitSublanguages()
{
	#define cHTML2Len 2048

    g_pTabDefault = new CStaticTableSet(ALL, IDS_HTML);
    int cl = CV_FIXED;
    CTableSet * rgpts[CV_MAX +1];
    memset(rgpts, 0, sizeof rgpts);

    CTableSet* ptabset; // current
    CTableSet* ptabBackup; // backup default

    memset(g_arpTables, 0, sizeof g_arpTables);

    m_rgSublang = new SUBLANG[cl+2]; // 0th + list + empty terminator
    ASSERT(NULL != m_rgSublang);
	if (NULL != m_rgSublang)
		memset(m_rgSublang, 0, (cl+2)*sizeof SUBLANG);

    UINT iLang = 1;
    TCHAR strDefault[cHTML2Len];

    // Microsoft browsers
    // Internet Explorer 3
    ptabset = MakeTableSet(rgpts, IEXP3, IDS_IEXP3);
    SetLanguage( strDefault, m_rgSublang, ptabset, iLang, IDR_HTML, CLSID_NULL );

    // Set backup default as IE 3
    ptabBackup = ptabset;
    if (lstrlen(strDefault) == 0)
    {
        ASSERT(lstrlen(ptabBackup->Name()) != 0);
        lstrcpy(strDefault, ptabBackup->Name());
    }

    // User's additions

    for (int n = 0; rgpts[n]; n++)
    {
        ptabset = rgpts[n];
        SetLanguage( strDefault, m_rgSublang, ptabset, iLang, 0, CLSID_NULL );
        ptabBackup = ptabset;
    }

    // HTML 2.0 base (if not overridden)
    {
        TCHAR strHTML2[cHTML2Len];
        ::LoadString(   _Module.GetModuleInstance(),
                        IDS_RFC1866,
                        strHTML2,
                        cHTML2Len
                        );
        if (!FindTable(rgpts,strHTML2))
        {
            ptabset = new CStaticTableSet(HTML2, IDS_RFC1866);
            SetLanguage( strDefault, m_rgSublang, ptabset, iLang, 0, CLSID_NULL);
        }
    }

    if (NULL == g_arpTables[0])
    {
        ASSERT(NULL != ptabBackup); // error: didn't get a default!

        //Find the backup in the tables
        int i;
        for (i = 1; NULL != g_arpTables[i]; i++)
        {
            if (g_arpTables[i] == ptabBackup)
                break;
        }

        ASSERT(NULL != g_arpTables[i]); // must be in table

        // Set default
        g_arpTables[0] = g_pTable = g_arpTables[i];
        m_rgSublang[0] = m_rgSublang[i];
        m_rgSublang[0].lxsInitial = LxsFromSubLangIndex(0);

        // Move the rest down to fill the hole
        for (; g_arpTables[i]; i++)
        {
            g_arpTables[i] = g_arpTables[i+1];
            m_rgSublang[i] = m_rgSublang[i+1];
            m_rgSublang[i].lxsInitial = LxsFromSubLangIndex(i);
        }
    }
    ASSERT(NULL != g_arpTables[0]);

    // set global ASP sublang ptr
    // start at 1, since the default is at 0, and should never be ASP
    for (int i = 1; NULL != m_rgSublang[i].szSubLang; i++)
    {
        if (m_rgSublang[i].nIdTemplate == IDR_ASP)
        {
            g_psublangASP = &m_rgSublang[i];
            break;
        }
    }
}

// Reallocs are expensive, so when we Realloc, should we add some more pad so that 
// we wont have to call Realloc very often?

HRESULT
ReallocBuffer(HGLOBAL *phg, DWORD cbNew, UINT uFlags)
{
    HRESULT hr = S_OK;
    HGLOBAL hg;

    ASSERT(*phg != NULL);
    ASSERT(cbNew != 0); // will we ever get this?
    GlobalUnlock(*phg);
    hg = *phg;
#pragma prefast(suppress:308, "noise")
    *phg = GlobalReAlloc(*phg, cbNew, uFlags);
    if (*phg == NULL)
    {
#ifdef DEBUG
        hr = GetLastError();
#endif // DEBUG
        GlobalFree(hg);
        hr = E_OUTOFMEMORY;
    }

    return(hr);
} /* ReallocBuffer() */

HRESULT
ReallocIfNeeded(HGLOBAL *phg, WCHAR **ppwNew, UINT cbNeed, UINT uFlags)
{
    HRESULT hr = S_OK;

    ASSERT(*phg != NULL);
    if (GlobalSize(*phg) < cbNeed)
    {
        hr = ReallocBuffer(phg, cbNeed, uFlags);
        if (hr == E_OUTOFMEMORY)
            goto LRet;
        ASSERT(*phg != NULL);
        *ppwNew = (WCHAR *)GlobalLock(*phg);
    }
LRet:
    return(hr);

} /* ReallocIfNeeded() */

void
CTriEditParse::fnRestoreSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
             TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft, 
             INT *pcSSSOut, UINT *pichNewCur, UINT *pichBeginCopy,
             DWORD /*dwFlags*/)
{
    // Server Side Script case
    // This occurs inside <%  %>. we assume simple SSS
    // remove the added <SCRIPT LANGUAGE=SERVERASP> & </SCRIPT> text around it
    UINT iArray = *piArrayStart;
    INT i;
    UINT ichScrStart, ichScrEnd, indexScrStart, indexScrEnd;
    UINT ichSSSStart, ichSSSEnd;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT cSSSOut = *pcSSSOut;
    LPCWSTR szSSS[] = {L"SERVERASP", L"\"SERVERASP\""};
    LPCWSTR szSSSSp[] = {L"SERVERASPSP"};
    BOOL fSpecialSSS = FALSE;
    LPWSTR pwNew = *ppwNew;
    INT iMatchMax;
    UINT cbNeed;
    UINT ichScrWspBegin, ichScrWspEnd, ichSp;

    ASSERT(cSSSOut >= 0); // make sure that this was initilized
    if (cSSSOut == 0)
        goto LRetOnly;

    //{TokTag_START, TokElem_SCRIPT, TokTag_CLOSE, TokElem_SCRIPT, fnRestoreSSS}
    ichScrStart = ichScrEnd = indexScrStart = indexScrEnd = ichSSSStart = ichSSSEnd = 0;
    ichScrWspBegin = ichScrWspEnd = 0;
    while (cSSSOut > 0)
    {
        // start at iArray of pTokArray and look for TokElem_SCRIPT
        //while (pTokArray[iArray].token.tok != ft.tokBegin2)
        //  iArray++;
        ASSERT(iArray < ptep->m_cMaxToken);
        if (pTokArray[iArray].token.tok != TokElem_SCRIPT)
            goto LRet;

        // Here's the deal - we have to ignore all SSS that appear
        // as values inside client scripts or insize objects/dtcs
        // so, we need to skip this TokElem_SCRIPT tag if we found '</' before TokElem_SCRIPT
        if (   pTokArray[iArray].token.tok == TokElem_SCRIPT
            && pTokArray[iArray-1].token.tok != TokTag_START
            )
        {
            ASSERT(pTokArray[iArray].token.tokClass == tokElem);
            iArray++; // so that we don't come here again with the same iArray
            ptep->m_fDontDeccItem = TRUE; // we can do things differently here next time around
            ptep->m_cSSSOut++;
            goto LRet;
        }

        //ASSERT(pTokArray[iArray].token.tok == TokElem_SCRIPT);
        i = iArray; // the position at which we found ft.tokBegin2
        // look for the special LANGUAGE arrtibute that we had set.
        // if that doesn't exist, this is not the SSS we want
        // we don't really need to look for this till ptep->m_cMaxToken,
        // but this will cover boundary cases
        iMatchMax = (pTokArray[iArray].iNextprev == -1)? ptep->m_cMaxToken : pTokArray[iArray].iNextprev;
        while (i < iMatchMax)
        {
            if (pTokArray[i].token.tok == TokAttrib_LANGUAGE)
            {
                ASSERT(pTokArray[i].token.tokClass == tokAttr);
                break;
            }
            i++;
        }
        if (i < iMatchMax)
        {
            // make sure that the next one is tokOpEqual
            ASSERT(pTokArray[i+1].token.tokClass == tokOp);
            //ASSERT(((pwOld+pTokArray[i+1].token.ibTokMin)*sizeof(WCHAR)) == '=');
            // get the next value and compare it with szSSS[]
            // note that this may also match with szSSSSp[]
            if (   0 != _wcsnicmp(szSSS[0], &pwOld[pTokArray[i+2].token.ibTokMin], wcslen(szSSS[0]))
                && 0 != _wcsnicmp(szSSS[1], &pwOld[pTokArray[i+2].token.ibTokMin], wcslen(szSSS[1]))
                )
            {
                iArray = i;
                goto LNextSSS; // not this one
            }
        }
        else // error case
        {
            iArray++;
            goto LRet;
        }
        // compare with szSSSSp[] and set fSpecialSSS
        if (0 == _wcsnicmp(szSSSSp[0], &pwOld[pTokArray[i+2].token.ibTokMin], wcslen(szSSSSp[0])))
            fSpecialSSS = TRUE;
        i = iArray; // we are OK, so lets look for < before SCRIPT tag
        while (i >= 0)
        {
            // do we need to do anything else here?
            if (pTokArray[i].token.tok == ft.tokBegin)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_START);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            i--;
        }
        if (i >= 0) // found TokTag_START token
        {
            ichScrStart = pTokArray[i].token.ibTokMin;
            indexScrStart = i;
        }
        else // error case
        {
            // we found SCRIPT, but didn't find < of <SCRIPT
            // we can't process this SSS, so quit
            goto LRet;
        }

        // now lets look for <! that would be after <SCRIPT LANGUAGE = SERVERASP>
        while (i < (int)ptep->m_cMaxToken)
        {
            if (   pTokArray[i].token.tok == TokTag_CLOSE
                && pTokArray[i].token.tokClass == tokTag
                )
                ichScrWspBegin = pTokArray[i].token.ibTokMac; // if we had saved white space, it would begin here

            if (pTokArray[i].token.tok == TokTag_BANG)
            {
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                ASSERT(pTokArray[i+1].token.tokClass == tokComment);
                //we can assert for next 2 chars as --
                ichSSSStart = pTokArray[i].token.ibTokMin;
                break;
            }
            i++;
        }
        if (i >= (int)ptep->m_cMaxToken) // didn't find <!
        {
            goto LRet;
        }
        // look for ending -->
        while (i < (int)ptep->m_cMaxToken)
        {
            if (pTokArray[i].token.tok == TokTag_CLOSE && pTokArray[i].token.tokClass == tokTag)
            {
                //we can assert for next 2 chars as --
                ASSERT(*(pwOld+pTokArray[i].token.ibTokMin-1) == '-');
                ASSERT(*(pwOld+pTokArray[i].token.ibTokMin-2) == '-');
                ichSSSEnd = pTokArray[i].token.ibTokMac;
                break;
            }
            i++;
        }
        if (i >= (int)ptep->m_cMaxToken) // didn't find >
        {
            goto LRet;
        }

        // now look for ft.tokEnd2 & ft.tokEnd (i.e. TokElem_SCRIPT & >)
        while (pTokArray[i].token.tok != ft.tokEnd2)
        {
            if (pTokArray[i].token.tok == TokTag_END && pTokArray[i].token.tokClass == tokTag)
                ichScrWspEnd = pTokArray[i].token.ibTokMin; // past the last white space
            i++;
        }
        ASSERT(i < (int)ptep->m_cMaxToken);
        ASSERT(pTokArray[i].token.tok == TokElem_SCRIPT);
        ASSERT(pTokArray[i].token.tokClass == tokElem);
        // go forward and look for > of SCRIPT>
        // as additional check, we can also check that previous token is </
        while (i < (int)ptep->m_cMaxToken)
        {
            if (pTokArray[i].token.tok == ft.tokEnd)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_CLOSE);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            i++;
        }
        if (i < (int)ptep->m_cMaxToken) // found TokTag_CLOSE
        {
            ichScrEnd = pTokArray[i].token.ibTokMac;
            indexScrEnd = i;
        }
        else // error case
        {
            // we found SCRIPT, but didn't find > of SCRIPT>
            // we can't process this SSS, so quit
            goto LRet;
        }
        iArray = i+1; // set it for next run

        cbNeed = (ichNewCur+(ichScrStart-ichBeginCopy)+(ichSSSEnd-ichSSSStart))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        // do the Blts
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of SSS
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichScrStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichScrStart-ichBeginCopy);
        ichBeginCopy = ichScrEnd; // make it ready for next copy

        if (fSpecialSSS)
        {
            // in special case, we need to make space for the <%@...%> at the begining of pwNew
            // so, we move all the above stuff (ichNewCur chars) by (ichSSSEnd-ichSSSStart-3).
            memmove((BYTE *)(&pwNew[ichSSSEnd-ichSSSStart-3]),
                    (BYTE *)pwNew,
                    (ichNewCur)*sizeof(WCHAR)
                    );
            // we now copy <%@...%> at the begining of the doc instead of at ichNewCur
            // now skip <SCRIPT LANGUAGE=SERVERASP> & only copy <% ....%>
            // note that we have to get rid of 3 extra chars we had added when we converted going in Trident
            memcpy( (BYTE *)(pwNew),
                    (BYTE *)&pwOld[ichSSSStart+2],/*get rid of 2 extra chars we had added at the begining*/
                    (ichSSSEnd-ichSSSStart-3)*sizeof(WCHAR));
            pwNew[0] = '<'; pwNew[1] = '%'; // note that we have moved the SSS to the begining of the doc
            ichNewCur += ichSSSEnd-ichSSSStart-3; // here we got rid of 1 extra char that was added
            pwNew[(ichSSSEnd-ichSSSStart-3)-2] = '%';
            pwNew[(ichSSSEnd-ichSSSStart-3)-1] = '>';
            // change <!-- to <% and --> to %>
        }
        else
        {
            // in pwNew get rid of white space characters from ichNewCur backwards
            ichSp = ichNewCur-1;
            while (    (   pwNew[ichSp] == ' '  || pwNew[ichSp] == '\r' 
                        || pwNew[ichSp] == '\n' || pwNew[ichSp] == '\t'
                        )
                    )
            {
                ichSp--;
            }
            ichSp++; // compensate for the last decrement, ichSp points to the 1st white-space character
            ichNewCur = ichSp;
            // copy pre-script white space
            if (ichScrWspBegin > 0 && ichSSSStart > ichScrWspBegin) // has been set
            {
                memcpy( (BYTE *)&pwNew[ichNewCur], 
                        (BYTE *)&pwOld[ichScrWspBegin],
                        (ichSSSStart-ichScrWspBegin)*sizeof(WCHAR));
                ichNewCur += ichSSSStart-ichScrWspBegin;
            }
            // now skip <SCRIPT LANGUAGE=SERVERASP> & only copy <% ....%>
            // note that we have to get rid of 3 extra chars we had added when we converted going in Trident
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichSSSStart+2]),/*get rid of 2 extra chars we had added at the begining*/
                    (ichSSSEnd-ichSSSStart-3)*sizeof(WCHAR));
            pwNew[ichNewCur] = '<';
            pwNew[ichNewCur+1] = '%'; 
            ichNewCur += ichSSSEnd-ichSSSStart-3; // here we got rid of 1 extra char that was added
            pwNew[ichNewCur-2] = '%';
            pwNew[ichNewCur-1] = '>';
            // copy post-script white space
            if (ichScrWspEnd > 0 && ichScrWspEnd > ichSSSEnd) // has been set
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[ichSSSEnd],
                        (ichScrWspEnd-ichSSSEnd)*sizeof(WCHAR));
                ichNewCur += ichScrWspEnd-ichSSSEnd;
            }

            // increment iArray & ichBeginCopy till the next non-whitespace token
            while (iArray < (int)ptep->m_cMaxToken)
            {
                UINT ich;
                BOOL fNonWspToken = FALSE; // assume the next token to be whitespace
                // scan entire token and see if it has all white-space characters
                for (ich = pTokArray[iArray].token.ibTokMin; ich < pTokArray[iArray].token.ibTokMac; ich++)
                {
                    if (   pwOld[ich] != ' '    && pwOld[ich] != '\t'
                        && pwOld[ich] != '\r'   && pwOld[ich] != '\n'
                        )
                    {
                        fNonWspToken = TRUE;
                        break;
                    }
                }
                if (fNonWspToken)
                {
                    ichBeginCopy = pTokArray[iArray].token.ibTokMin;
                    break;
                }
                iArray++;
            }
        }

        cSSSOut--;
    } // while (cSSSOut > 0)

LNextSSS:
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;

} /* fnRestoreSSS() */

void
CTriEditParse::fnSaveSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
             TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft, 
             INT *pcSSSIn, UINT *pichNewCur, UINT *pichBeginCopy,
             DWORD /*dwFlags*/)
{
    // Server Side Script case
    // This occur inside <%  %>. We assume simple SSS
    // add <SCRIPT LANGUAGE=SERVERASP> & </SCRIPT> around it
    // tag used for saving the SSS.
    /* 2 spaces at the end of 1st element are important */
    LPCWSTR rgSSSTags[] =
    {
        L"\r\n<SCRIPT LANGUAGE=\"SERVERASP\">",
        L"\r\n<SCRIPT LANGUAGE=\"SERVERASPSP\">",
        L"</SCRIPT>\r\n"
    };
    UINT iArray = *piArrayStart;
    UINT i;
    UINT ichSSSStart, ichSSSEnd, indexSSSStart, indexSSSEnd;
    HGLOBAL hgSSS = NULL;
    WCHAR *pSSS;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT cSSSIn = *pcSSSIn;
    LPWSTR pwNew = *ppwNew;
    int indexSSSTag;
    UINT cbNeed;
    UINT ichSp;

    ASSERT(cSSSIn >= 0); // make sure that this was initilized
    if (cSSSIn == 0)
        goto LRetOnly;
    
    ichSSSStart = ichSSSEnd = indexSSSStart = indexSSSEnd = 0;

    while (cSSSIn > 0)
    {
        INT cbMin = 0x4fff; // init & increment size of hgSSS
        INT cchCurSSS = 0;
        int index;

        // handle special case here - if the script is inside <xmp> tag, we shouldn't convert the script
        // NOTE that we are only handling <xmp> <%...%> </xmp> case here
        // we don't have to worry about nested xmp's because its not valid html.
        // such invalid cases are <xmp>...<xmp> </xmp> <% %> </xmp> OR <xmp>...<xmp> <% %> </xmp> </xmp>
        // handle TokElem_PLAINTEXT as well
        index = iArray;
        while (index >= 0)
        {
            if (   (pTokArray[index].token.tok == TokElem_XMP || pTokArray[index].token.tok == TokElem_PLAINTEXT)
                && pTokArray[index].token.tokClass == tokElem
                && pTokArray[index].iNextprev > iArray
                )
            {
                iArray++;
                goto LRet;
            }
            index--;
        }

        // start at the begining of pTokArray and look for first <%
        ASSERT(ft.tokBegin2 == -1);
        ASSERT(ft.tokEnd2 == -1);
        // Here both supporting tokens are -1, so we simply look for main tokens.
        i = iArray;
        while (i < ptep->m_cMaxToken)
        {
            // do we need to do anything else here?
            if (pTokArray[i].token.tok == ft.tokBegin)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_SSSOPEN);
                ASSERT(pTokArray[i].token.tokClass == tokSSS);
                break;
            }
            i++;
        }
        if (i < ptep->m_cMaxToken) // found TokTag_SSSOPEN token
        {
            ichSSSStart = pTokArray[i].token.ibTokMin;
            indexSSSStart = i;
        }

        // look for ft.tokEnd
        if (pTokArray[i].iNextprev != -1)
        {
            // NOTE that this will give us topmost nested level of the SSS
            indexSSSEnd = pTokArray[i].iNextprev;
            ichSSSEnd = pTokArray[indexSSSEnd].token.ibTokMac;
            ASSERT(indexSSSEnd < ptep->m_cMaxToken);
            // this will be a wierd case where the iNextprev is incorrectly pointing to another token
            // but lets handle that case.
            if (pTokArray[indexSSSEnd].token.tok != TokTag_SSSCLOSE)
                goto LFindSSSClose; // find it by looking at each token
        }
        else // actually, this is an error case, but rather than just giving assert, try to find the token
        {
LFindSSSClose:
            while (i < ptep->m_cMaxToken)
            {
                if (pTokArray[i].token.tok == ft.tokEnd)
                {
                    ASSERT(pTokArray[i].token.tok == TokTag_SSSCLOSE);
                    ASSERT(pTokArray[i].token.tokClass == tokSSS);
                    break;
                }
                i++;
            }
            if (i < ptep->m_cMaxToken) // found TokTag_SSSCLOSE token
            {
                ichSSSEnd = pTokArray[i].token.ibTokMac;
                indexSSSEnd = i;
            }
            else // error case 
            {
                goto LRet; // didn't find %>, but exhausted the token array
            }
        }
        iArray = indexSSSEnd; // set for for next SSS

        // now insert text from rgSSSTags[] into the source
        // 0. Allocate a local buffer
		cbNeed =	wcslen(rgSSSTags[0]) + wcslen(rgSSSTags[0]) + wcslen(rgSSSTags[2])
					+ (ichSSSEnd-ichSSSStart) + cbMin;
		hgSSS = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbNeed*sizeof(WCHAR));
        if (hgSSS == NULL)
            goto LErrorRet;
        pSSS = (WCHAR *) GlobalLock(hgSSS);
        ASSERT(pSSS != NULL);

        // NOTE - This flag would have been set to TRUE only if, 
        // we have found <%@ as the 1st SSS in the document
        indexSSSTag = 0;
        if (ptep->m_fSpecialSSS)
        {
            ptep->m_fSpecialSSS = FALSE;
            indexSSSTag = 1;
        }

        //-------------------------------------------------------------------------------
        // ASSUMPTION - The big assumption we are making is that IE5 doesn't change 
        // anything inside the client sctipt. So far we have seen that.
        // In the worst case, if they start mucking with the contents of client script, 
        // we will loose the spacing, but there will be NO DATA LOSS.
        // 
        // Based on this assumption, we simply save the pre-post script spacing as is
        // and expect to restore it on the way out.
        //-------------------------------------------------------------------------------

        // 1. Insert <SCRIPT> from rgSSSTags[indexSSSTag]
        wcscpy(&pSSS[cchCurSSS], rgSSSTags[indexSSSTag]);
        cchCurSSS += wcslen(rgSSSTags[indexSSSTag]);
        // insert the white space as it occurs in pwOld, ichSSSStart is '<' of '<%', walk backwards
        ichSp = ichSSSStart-1;
        while (    (   pwOld[ichSp] == ' '  || pwOld[ichSp] == '\r' 
                    || pwOld[ichSp] == '\n' || pwOld[ichSp] == '\t'
                    )
                )
        {
            ichSp--;
        }
        ichSp++; // compensate for the last decrement
        if ((int)(ichSSSStart-ichSp) > 0)
        {
            wcsncpy(&pSSS[cchCurSSS], &pwOld[ichSp], ichSSSStart-ichSp);
            cchCurSSS += ichSSSStart-ichSp;
        }
        // now add TokTag_BANG '<!'
        pSSS[cchCurSSS++] = '<';
        pSSS[cchCurSSS++] = '!';
        // 2. copy the script from pwOld
        wcsncpy(&pSSS[cchCurSSS], &pwOld[ichSSSStart], ichSSSEnd-ichSSSStart);
        pSSS[cchCurSSS] = '-';
        pSSS[cchCurSSS+1] = '-';
        cchCurSSS += (ichSSSEnd-ichSSSStart);
        pSSS[cchCurSSS] = pSSS[cchCurSSS-1]; //note : -1 is '>'
        pSSS[cchCurSSS-2] = '-';
        pSSS[cchCurSSS-1] = '-';
        cchCurSSS++; // we are adding one extra character
        // insert the white space as it occurs in pwOld, ichSSSEnd is past '%>', walk forward
        ichSp = ichSSSEnd;
        while (    (ichSp < pTokArray[ptep->m_cMaxToken-1].token.ibTokMac-1)
                && (   pwOld[ichSp] == ' '  || pwOld[ichSp] == '\r' 
                    || pwOld[ichSp] == '\n' || pwOld[ichSp] == '\t'
                    )
                )
        {
            ichSp++;
        }
        if ((int)(ichSp-ichSSSEnd) > 0)
        {
            wcsncpy(&pSSS[cchCurSSS], &pwOld[ichSSSEnd], ichSp-ichSSSEnd);
            cchCurSSS += ichSp-ichSSSEnd;
        }
        // 3. Insert </SCRIPT> from rgSSSTags[2]
        wcscpy(&pSSS[cchCurSSS], rgSSSTags[2]);
        cchCurSSS += wcslen(rgSSSTags[2]);



        /* REALLOCATE pwNew IF NEEDED here, use cache value for GlobalSize(*phgNew) and don't forget to update it too */
        cbNeed = (ichNewCur+(ichSSSStart-ichBeginCopy)+(cchCurSSS))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;

                    
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew

        if ((int)(ichSSSStart-ichBeginCopy) >= 0)
        {
            // copy till begining of the <%
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichBeginCopy]),
                    (ichSSSStart-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += ichSSSStart-ichBeginCopy;
            ichBeginCopy = ichSSSEnd; // set it for next script

            // copy the converted SSS
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(pSSS),
                    cchCurSSS*sizeof(WCHAR));
            ichNewCur += cchCurSSS;
        }

        if (hgSSS != NULL)
            GlobalUnlockFreeNull(&hgSSS);

        cSSSIn--;
    } // while(cSSSIn > 0)

LErrorRet:
    if (hgSSS != NULL)
        GlobalUnlockFreeNull(&hgSSS);
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

LRetOnly:   
    return;

} /* fnSaveSSS() */

void
CTriEditParse::fnRestoreDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
             TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft, 
             INT *piObj, UINT *pichNewCur, UINT *pichBeginCopy,
             DWORD dwFlags)
{
    // OBJECTS case - (These were converted from DTCs in modeInput
    // if we get OBJECT, search backwards (carefully) for tokTag/TokTag_START (<) in pTokArray
    // once we find that, remember the ibTokMin for Object conversion
    // look for the /OBJECT (i.e. look for OBJECT and look for previous /) and
    // once we get those two next to each other, wait for upcoming toktag_CLOSE which will end that Object
    // remember ibTokMac at that position. This is the OBJECT range.
    // First, insert the startspan text
    // Then generate and insert the endspan text (note that we may have to extend our
    // buffer becausethe generated text mey not fit.
    // Do the appropriate Blts to adjust the buffer.

    UINT cchObjStart, indexObjStart, cchObjEnd, indexObjEnd;
    HGLOBAL hgDTC = NULL;
    WCHAR *pDTC;
    UINT iArray = *piArrayStart;
    INT i;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    HRESULT hr;
    LPWSTR pwNew = *ppwNew;
    UINT cbNeed;

    long iControlMac;
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IHTMLElementCollection> pHTMLColl;
    CComPtr<IDispatch> pDispControl;
    CComPtr<IActiveDesigner> pActiveDesigner;
    VARIANT vaName, vaIndex;
    // DTC tag used for saving the DTC.
    LPCWSTR rgDTCTags[] =
    {
        L"<!--METADATA TYPE=\"DesignerControl\" startspan\r\n",
        L"\r\n-->\r\n",
        L"\r\n<!--METADATA TYPE=\"DesignerControl\" endspan-->"
    };
    LPCWSTR rgCommentRT[] =
    {
        L"DTCRUNTIME",
        L"--DTCRUNTIME ",
        L" DTCRUNTIME--",
    };
    int ichRT, cchRT, ichRTComment, cchRTComment, indexRTComment;

    ichRTComment = ichRT = -1;
    indexRTComment = -1;
    cchRT = cchRTComment = 0;

    cchObjStart = indexObjStart = cchObjEnd = indexObjEnd = 0;

    // start at the begining of pTokArray and look for first OBJECT
    //while (pTokArray[iArray].token.tok != ft.tokBegin2)
    //  iArray++;
    ASSERT(iArray < ptep->m_cMaxToken);

    if (pTokArray[iArray].token.tok != TokElem_OBJECT)
        goto LRet;

    //ASSERT(pTokArray[iArray].token.tok == TokElem_OBJECT);
    i = iArray; // the position at which we found ft.tokBegin2
    while (i >=0)
    {
        // do we need to do anything else here?
        if (pTokArray[i].token.tok == ft.tokBegin)
        {
            ASSERT(pTokArray[i].token.tok == TokTag_START);
            ASSERT(pTokArray[i].token.tokClass == tokTag);
            break;
        }
        i--;
    }
    if (i >= 0) // found TokTag_START token
    {
        cchObjStart = pTokArray[i].token.ibTokMin;
        indexObjStart = i;
    }
    i = pTokArray[iArray].iNextprev;
    if (i == -1) // no matching end, skip this <OBJECT>
        goto LRet;
    ASSERT(pTokArray[pTokArray[iArray].iNextprev].token.tok == TokElem_OBJECT);
    ASSERT(pTokArray[pTokArray[iArray].iNextprev].token.tokClass == tokElem);
    ASSERT(pTokArray[i-1].token.tok == TokTag_END);
    // from this ith position, look for ft.tokEnd
    while (i < (int)ptep->m_cMaxToken)
    {
        if (pTokArray[i].token.tok == ft.tokEnd)
        {
            ASSERT(pTokArray[i].token.tok == TokTag_CLOSE);
            ASSERT(pTokArray[i].token.tokClass == tokTag);
            break;
        }
        i++;
    }
    if (i < (int)ptep->m_cMaxToken) // found TokTag_CLOSE token
    {
        cchObjEnd = pTokArray[i].token.ibTokMac;
        indexObjEnd = i;
    }
    
    // look for the special comment that has the runtime text saved
    // we will need it if SaveRuntimeText() failed
    i = indexObjStart;
    while (i < (int)indexObjEnd)
    {
        if (   pTokArray[i].token.tok == TokTag_BANG
            && pTokArray[i].token.tokClass == tokTag)
        {
            // found the comment, now make sure that this is the comment with DTCRUNTIME
            if (   (pwOld[pTokArray[i+1].token.ibTokMin] == '-')
                && (pwOld[pTokArray[i+1].token.ibTokMin+1] == '-')
                && (0 == _wcsnicmp(rgCommentRT[0], &pwOld[pTokArray[i+1].token.ibTokMin+2], wcslen(rgCommentRT[0])))
                && (pwOld[pTokArray[i+1].token.ibTokMac-1] == '-')
                && (pwOld[pTokArray[i+1].token.ibTokMac-2] == '-')
                && (0 == _wcsnicmp(rgCommentRT[0], &pwOld[pTokArray[i+1].token.ibTokMac-2-wcslen(rgCommentRT[0])], wcslen(rgCommentRT[0])))
                )
            {
                ichRT = pTokArray[i+1].token.ibTokMin + wcslen(rgCommentRT[1]);
                cchRT = pTokArray[i+1].token.ibTokMac-pTokArray[i+1].token.ibTokMin - wcslen(rgCommentRT[2]) - wcslen(rgCommentRT[1]);
                indexRTComment = i;
                ichRTComment = pTokArray[i].token.ibTokMin;
                cchRTComment = pTokArray[i+2].token.ibTokMac-pTokArray[i].token.ibTokMin;
                break;
            }
        }
        i++;
    }

    iArray = indexObjEnd; // set it for the next Object

    // now, replace the OBJECT - Insert startspan and endspan stuff
    pHTMLDoc = NULL;
    hr = ptep->m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void **) &pHTMLDoc);
    if (hr != S_OK)
        goto LErrorRet;

    pHTMLColl = NULL;
    hr = pHTMLDoc->get_applets(&pHTMLColl);
    if (hr != S_OK)
    {
        goto LErrorRet;
    }

    pHTMLColl->get_length(&iControlMac);
    ASSERT(*piObj <= iControlMac);

    hr = S_FALSE;
    VariantInit(&vaName);
    VariantInit(&vaIndex);

    V_VT(&vaName) = VT_ERROR;
    V_ERROR(&vaName) = DISP_E_PARAMNOTFOUND;

    V_VT(&vaIndex) = VT_I4;
    V_I4(&vaIndex) = *piObj;
    *piObj += 1; // get it ready for the next control
    ptep->m_iControl = *piObj; // get it ready for the next control

    pDispControl = NULL;
    hr = pHTMLColl->item(vaIndex, vaName, &pDispControl);
    // Trident has a bug that if the object was nested inside <scripts> tags,
    // it returns S_OK with pDispControl as NULL. (See VID BUG 11303)
    if (hr != S_OK || pDispControl == NULL)
    {
        goto LErrorRet;
    }
    pActiveDesigner = NULL;
    hr = pDispControl->QueryInterface(IID_IActiveDesigner, (void **) &pActiveDesigner);
    if (hr != S_OK) // release pActiveDesigner
    {
        pActiveDesigner.Release();
        pDispControl.Release();
    }

    if (hr == S_OK) // Found the control!
    {        
        // This is a DTC
        IStream *pStm;
        HGLOBAL hg = NULL;
        INT cbMin = 0x8fff; // init & increment size of hgDTC
        INT cchCurDTC = 0;

#ifdef DEBUG
        CComPtr<IHTMLElement> pHTMLElem = NULL;

        hr = pDispControl->QueryInterface(IID_IHTMLElement, (void **) &pHTMLElem);
        if (hr != S_OK)
        {   
            goto LErrorRet;
        }

        // get the index for TokAttrib_ID from pTokArray
        // from here get the actual value for future comparison

        i = indexObjStart;
        // actually, this has to exist before TokElem_PARAM,
        // but this takes care of boundary cases
        while (i < (int)indexObjEnd)
        {
            if (pTokArray[i].token.tok == TokAttrib_CLASSID)
            {
                ASSERT(pTokArray[i].token.tokClass == tokAttr);
                break;
            }
            i++;
        }

        if (i < (int)indexObjEnd -1) // found TokAttrib_CLASSID
        {
            CComPtr<IPersistPropertyBag> pPersistPropBag;
            INT ichClsid;

            // make sure that the next one is tokOpEqual
            ASSERT(pTokArray[i+1].token.tokClass == tokOp);
            // make sure that the next one is the id and get that value
            //ASSERT(pTokArray[i].token.tok == );

            // Is there any other way to skip "clsid:" string that appears before the clsid?
            ichClsid = pTokArray[i+2].token.ibTokMin + strlen("clsid:");

            pPersistPropBag = NULL;
            hr = pDispControl->QueryInterface(IID_IPersistPropertyBag, (void **) &pPersistPropBag);
            if (hr == S_OK)
            {
                CLSID clsid;
                LPOLESTR szClsid;

                if (S_OK == pPersistPropBag->GetClassID(&clsid))
                {
                    if (S_OK == StringFromCLSID(clsid, &szClsid))
                        ASSERT(0 == _wcsnicmp(szClsid+1/* for {*/, &pwOld[ichClsid], sizeof(CLSID)));
                    ::CoTaskMemFree(szClsid);
                }
            }

        }
#endif // DEBUG

        ASSERT(*piObj <= iControlMac);
        // Do the Blts. 
        // 0. Allocate a local buffer
        hgDTC = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, ((cchObjEnd-cchObjStart)+cbMin)*sizeof(WCHAR)); // stack
        if (hgDTC == NULL)
            goto LErrorRet;
        pDTC= (WCHAR *) GlobalLock(hgDTC);
        ASSERT(pDTC != NULL);

        if (!(dwFlags & dwFilterDTCsWithoutMetaTags))
        {
            INT indexTokOp = -1;
            INT indexClsId = -1;

            // 1. Insert MetaData1 tag from rgDTCTags[0]
            wcscpy(&pDTC[cchCurDTC], rgDTCTags[0]);
            cchCurDTC += wcslen(rgDTCTags[0]);

            // 2. copy the <OBJECT> </OBJECT> from pwOld

            // Split the copy into 3 parts...
            // part 1 - copy from cchObjStart till = following the ClassId
            // part 2 - add a quote around the classId value (if needed) and copy the value
            // part 3 - copy rest of the object till cchObjEnd

            // VID98-BUG 5649 - Fix DaVinci bug by adding quote around classId's.
            // NOTE - we want to make sure that the classId value is inside quotes,
            // if there is one for this <OBJECT> tag,

            // we actually don't need to go this far, but thats the indexObjEnd is the 
            // only index know
            for (i = indexObjStart; i < (INT)indexObjEnd; i++)
            {
                if (   pTokArray[i].token.tok == TokAttrib_CLASSID
                    && pTokArray[i].token.tokClass == tokAttr)
                {
                    indexClsId = i;
                }
                if (   pwOld[pTokArray[i].token.ibTokMin] == '='
                    && pTokArray[i].token.tokClass == tokOp
                    && indexTokOp == -1)
                {
                    indexTokOp = i;
                }
            } // for ()
            // following are simply error cases, we won't run into them unless we have
            // incomplete HTML
            if (   indexClsId == -1 /* we didn't have clsid for this <OBJECT> */
                || indexTokOp == -1 /* rare but possible error case of incomplete HTML */
                )
            {
                if (ichRTComment == -1)
                {
                    wcsncpy(&pDTC[cchCurDTC], &pwOld[cchObjStart], cchObjEnd - cchObjStart);
                    cchCurDTC += cchObjEnd - cchObjStart;
                }
                else
                {
                    wcsncpy(&pDTC[cchCurDTC], &pwOld[cchObjStart], ichRTComment - cchObjStart);
                    cchCurDTC += ichRTComment - cchObjStart;

                    wcsncpy(&pDTC[cchCurDTC], &pwOld[ichRTComment+cchRTComment], cchObjEnd - (ichRTComment+cchRTComment));
                    cchCurDTC += cchObjEnd - (ichRTComment+cchRTComment);
                }
            }
            else
            {
                LPCWSTR szClsId[] =
                {
                    L"clsid:",
                };
    
                ASSERT(indexTokOp != -1);
                // copy till '=' of 'classid=clsid:XXXX'
                memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                        (BYTE *)(&pwOld[cchObjStart]),
                        (pTokArray[indexTokOp].token.ibTokMac-cchObjStart)*sizeof(WCHAR));
                cchCurDTC += (pTokArray[indexTokOp].token.ibTokMac-cchObjStart);

                if (0 == _wcsnicmp(szClsId[0], &pwOld[pTokArray[indexTokOp+1].token.ibTokMin], wcslen(szClsId[0])))
                {
                    ASSERT(pwOld[pTokArray[indexTokOp+1].token.ibTokMin] != '"');
                    pDTC[cchCurDTC] = '"';
                    cchCurDTC++;

                    memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                            (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMin]),
                            (pTokArray[indexTokOp+1].token.ibTokMac - pTokArray[indexTokOp+1].token.ibTokMin)*sizeof(WCHAR));
                    cchCurDTC += pTokArray[indexTokOp+1].token.ibTokMac - pTokArray[indexTokOp+1].token.ibTokMin;

                    pDTC[cchCurDTC] = '"';
                    cchCurDTC++;

                    if (ichRTComment == -1)
                    {
                        ASSERT((int)(cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMac) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMac]),
                                (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMac)*sizeof(WCHAR));
                        cchCurDTC += (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMac);
                    }
                    else
                    {
                        if (indexRTComment == -1)
                        {
                            ASSERT((int)(ichRTComment-pTokArray[indexTokOp+1].token.ibTokMac) >= 0);
                            memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                    (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMac]),
                                    (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMac)*sizeof(WCHAR));
                            cchCurDTC += (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMac);

                            ASSERT((int)(cchObjEnd-(ichRTComment+cchRTComment)) >= 0);
                            memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                    (BYTE *)(&pwOld[ichRTComment+cchRTComment]),
                                    (cchObjEnd-(ichRTComment+cchRTComment))*sizeof(WCHAR));
                            cchCurDTC += (cchObjEnd-(ichRTComment+cchRTComment));
                        }
                        else
                        {
                            // format and copy from indexTokOp+2 till indexRTComment
                            for (i = indexTokOp+2; i < indexRTComment; i++)
                            {
                                memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                        (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                                cchCurDTC += pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin;
                                if (pTokArray[i].token.tok == TokTag_CLOSE && pTokArray[i].token.tokClass == tokTag)
                                {
                                    // Don't bother checking for existing EOLs...
                                    // add \r\n
                                    pDTC[cchCurDTC++] = '\r';
                                    pDTC[cchCurDTC++] = '\n';
                                    pDTC[cchCurDTC++] = '\t';
                                }

                            }

                            // copy from end of the comment till </object>
                            ASSERT((int)(cchObjEnd-(ichRTComment+cchRTComment)) >= 0);
                            memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                    (BYTE *)(&pwOld[ichRTComment+cchRTComment]),
                                    (cchObjEnd-(ichRTComment+cchRTComment))*sizeof(WCHAR));
                            cchCurDTC += (cchObjEnd-(ichRTComment+cchRTComment));
                        }
                    }
                }
                else
                {
                    if (ichRTComment == -1)
                    {
                        ASSERT((int)(cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMin) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMin]),
                                (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMin)*sizeof(WCHAR));
                        cchCurDTC += (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMin);
                    }
                    else
                    {
                        ASSERT((int)(ichRTComment-pTokArray[indexTokOp+1].token.ibTokMin) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMin]),
                                (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMin)*sizeof(WCHAR));
                        cchCurDTC += (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMin);

                        ASSERT((int)(cchObjEnd-(ichRTComment+cchRTComment)) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[ichRTComment+cchRTComment]),
                                (cchObjEnd-(ichRTComment+cchRTComment))*sizeof(WCHAR));
                        cchCurDTC += (cchObjEnd-(ichRTComment+cchRTComment));
                    }
                }
            }

            // 3. Insert MetaData2 tag from rgDTCtags[1]
            wcscpy(&pDTC[cchCurDTC], rgDTCTags[1]);
            cchCurDTC += wcslen(rgDTCTags[1]);
        }

        // 4. Add runtime text (copy code from old stuff)
        if ((hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm)) != S_OK)
            goto LErrorRet;
    
        ASSERT(pActiveDesigner != NULL);
        if ((hr = pActiveDesigner->SaveRuntimeState(IID_IPersistTextStream, IID_IStream, pStm)) == S_OK)
        {
            if ((hr = GetHGlobalFromStream(pStm, &hg)) != S_OK)
                goto LErrorRet;

            STATSTG stat;
            if ((hr = pStm->Stat(&stat, STATFLAG_NONAME)) != S_OK)
                goto LErrorRet;
        
            int cch = stat.cbSize.LowPart / sizeof(WCHAR);

            // before we put stuff from hg into pDTC, 
            // lets make sure that its big enough
            cbNeed = (cchCurDTC+cch)*sizeof(WCHAR)+cbBufPadding;
            if (GlobalSize(hgDTC) < cbNeed)
            {
                hr = ReallocBuffer( &hgDTC, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT);
                if (hr == E_OUTOFMEMORY)
                    goto LErrorRet;
                ASSERT(hgDTC != NULL);
                pDTC = (WCHAR *)GlobalLock(hgDTC);
            }

            wcsncpy(&pDTC[cchCurDTC], (LPCWSTR) GlobalLock(hg), cch);
            cchCurDTC += cch;
            
            // HACK - BUG fix 9844
            // Some DTCs add a NULL at the end of their runtime text
            if (pDTC[cchCurDTC-1] == '\0')
                cchCurDTC--;

            GlobalUnlock(hg);
        }
        else if (hr == S_FALSE)
        {
            // copy the commented runtime text into pDTC & incremtn cchCurDTC
            if (ichRTComment != -1 && ichRT != -1) // we have the runtime text
            {
                ASSERT(cchRT >= 0);
                cbNeed = (cchCurDTC+cchRT)*sizeof(WCHAR)+cbBufPadding;
                if (GlobalSize(hgDTC) < cbNeed)
                {
                    hr = ReallocBuffer( &hgDTC, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT);
                    if (hr == E_OUTOFMEMORY)
                        goto LErrorRet;
                    ASSERT(hgDTC != NULL);
                    pDTC = (WCHAR *)GlobalLock(hgDTC);
                }
                wcsncpy(&pDTC[cchCurDTC], &pwOld[ichRT], cchRT);
                cchCurDTC += cchRT;
            }
        }

        if (!(dwFlags & dwFilterDTCsWithoutMetaTags))
        {
            // 5. Insert MetaData2 tag from rgDTCtags[2]
            wcscpy(&pDTC[cchCurDTC], rgDTCTags[2]);
            cchCurDTC += wcslen(rgDTCTags[2]);
        }
        
        // now insert/replace contents of pDTC into pwNew
        // we are insert/replacing (cchObjEnd-cchObjStart) wchars
        // by cchCurDTC wchars, so realloc pwNew first

        
        
        /* Reallocate pwNew IF NEEDED here use cache value for GlobalSize(*phgNew) and don't forget to update it too */
        cbNeed = (ichNewCur+(cchObjStart-ichBeginCopy)+(cchCurDTC))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;

        
        // cchObjStart/End are actually ich's
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew

        // copy till begining of the <OBJECT>
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (cchObjStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += cchObjStart-ichBeginCopy;
        ichBeginCopy = cchObjEnd; // set it for next object

        CComPtr<IPersistPropertyBag> pPersistPropBag = NULL;

        hr = pDispControl->QueryInterface(IID_IPersistPropertyBag, (void **) &pPersistPropBag);
        if (hr == S_OK)
        {
            CLSID clsid;

            if (S_OK == pPersistPropBag->GetClassID(&clsid))
            {
                if (IsEqualCLSID(clsid, CLSID_PageTr))
                {
                    if (ptep->m_cchPTDTC != 0)
                    {
                        // Note that there is no need to realloc here since our buffer will already be bigger than we need it to be.
                        if (cchCurDTC != ptep->m_cchPTDTC)
                        {
                            memmove((BYTE *)(pwNew+ptep->m_ichPTDTC+cchCurDTC),
                                    (BYTE *)(pwNew+ptep->m_ichPTDTC+ptep->m_cchPTDTC),
                                    (ichNewCur-ptep->m_ichPTDTC-ptep->m_cchPTDTC)*sizeof(WCHAR));

                            ichNewCur += cchCurDTC-ptep->m_cchPTDTC;
                        }

                        memcpy( (BYTE *)(pwNew+ptep->m_ichPTDTC),
                                (BYTE *)(pDTC),
                                cchCurDTC*sizeof(WCHAR));
                
                        ptep->m_cchPTDTC = 0; 
                        ptep->m_ichBeginHeadTagIn = 0;  // reset, so that if we had multiple PTDTCs, 
                                                        //we won't try to stuff them inside HEAD
                        goto LSkipDTC;
                    }
                    else // this is the case where the PTDTC didn't exist before going to Trident
                    {
                        // we need to move this between <head> </head> tags if they exist
                        if (ptep->m_ichBeginHeadTagIn > 0) // we had HEAD tag in Source view
                        {
                            int ichInsertPTDTC = ptep->m_ichBeginHeadTagIn;

                            // insert the control immediately after the <HEAD> tag
                            //in pwNew look for '>' after ichInsertPTDTC
                            while (pwNew[ichInsertPTDTC] != '>')
                                ichInsertPTDTC++;
                            ichInsertPTDTC++; // skip '>'

                            ASSERT(ichInsertPTDTC < (INT)ichNewCur);
                            memmove((BYTE *)(pwNew+ichInsertPTDTC+cchCurDTC),
                                    (BYTE *)(pwNew+ichInsertPTDTC),
                                    (ichNewCur-ichInsertPTDTC)*sizeof(WCHAR));
                            ichNewCur += cchCurDTC;
                            memcpy( (BYTE *)(pwNew+ichInsertPTDTC),
                                    (BYTE *)(pDTC),
                                    cchCurDTC*sizeof(WCHAR));

                            ptep->m_ichBeginHeadTagIn = 0;
                            goto LSkipDTC;
                        }
                    }

                } // else if (IsEqualCLSID(clsid, CLSID_PageTr))
            } // if (S_OK == pPersistPropBag->GetClassID(&clsid))
        } // if (hr == S_OK)

        // copy the converted DTC
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(pDTC),
                cchCurDTC*sizeof(WCHAR));
        ichNewCur += cchCurDTC;

LSkipDTC:

        if (hgDTC != NULL)
            GlobalUnlockFreeNull(&hgDTC);

    } // if (hr == S_OK)
    else // this object was not a DTC
    {
        // we don't need to do the same for DTC's, but lets visit this in next release
        LPCWSTR rgComment[] =
        {
            L"ERRORPARAM",
            L"--ERRORPARAM ",
            L" ERRORPARAM--",
        };
        BOOL fFoundParam = FALSE;
        INT iParam = -1;
        INT ichObjStartEnd, iCommentStart, iCommentEnd;
        UINT iObjTagEnd;
        INT cComment, iFirstComment, iComment;

        iCommentStart = iCommentEnd = iComment = -1;
        // loop through indexObjStart till indexObjEnd to see if we have any <PARAM> tags
        for (i = indexObjStart; i < (INT)indexObjEnd; i++)
        {
            if (   pTokArray[i].token.tok == TokElem_PARAM
                && pTokArray[i].token.tokClass == tokElem)
            {
                fFoundParam = TRUE;
                iParam = i;
                break;
            }
        } // for ()
        if (fFoundParam)
            ASSERT(iParam != -1);

        // We need to copy till end of <OBJECT...> irrespective of if we find <PARAM>s or not.
        // copy till end of <OBJECT...> tag and set ichBeginCopy to be after the commented <PARAM> tags
        // calculate ichObjStartEnd
        iObjTagEnd = indexObjStart;
        while (iObjTagEnd < indexObjEnd)
        {
            if (   pTokArray[iObjTagEnd].token.tok == TokTag_CLOSE
                && pTokArray[iObjTagEnd].token.tokClass == tokTag)
                break;
            iObjTagEnd++;
        }
        if (iObjTagEnd >= indexObjEnd) // error case
            goto LErrorRet;
        ichObjStartEnd = pTokArray[iObjTagEnd].token.ibTokMac;
        
        cbNeed = (ichNewCur+ichObjStartEnd-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        ASSERT((INT)(ichObjStartEnd-ichBeginCopy) >= 0);
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichObjStartEnd-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichObjStartEnd-ichBeginCopy);
        ichBeginCopy = ichObjStartEnd;
        iArray = iObjTagEnd + 1;

        // generally, we don't expect Trident to move the comment from where it was put
        // but if it does, be prepared.
        // NOTE - Lets not worry about the following case for this release becasue prior assumption
        // Also, should we look for more comments if the first one wasn't the magic one?
        // Would Trident move it form where it originally inserted? 
        
        // ASSUMPTION - that Trident doesn't muck with the contents inside a comment block
        // if rgComment[0] matches and rgComment[1] does not, Trident may have mucked with the 
        // comment contents. This invalidates our original assumption.
        // NOTE - We can get away with ignoring this case for thie release
        i = iObjTagEnd;
        cComment = 0;
        iFirstComment = -1;
        while ((UINT)i < indexObjEnd)
        {
            if (   pTokArray[i].token.tok == TokTag_BANG
                && pTokArray[i].token.tokClass == tokTag)
            {
                cComment++;
                if (iFirstComment == -1)
                    iFirstComment = i;
            }
            i++;
        }
        if (cComment == 0) // error, didn't find the comment
            goto LErrorRet;

        // early return cases
        // 1. see if these are comments or not.They could be anything that start with '<!'
        // e.g. <!DOCTYPE
        i = iFirstComment;
        while (i < (INT)indexObjEnd)
        {
            if (   (i < (INT)ptep->m_cMaxToken)
                && (pwOld[pTokArray[i].token.ibTokMin] == '-')
                && (pwOld[pTokArray[i].token.ibTokMin+1] == '-')
                && (0 == _wcsnicmp(rgComment[0], &pwOld[pTokArray[i].token.ibTokMin+2], wcslen(rgComment[0])))
                )
            {
                ASSERT(i-1 >= 0);
                iCommentStart = i-1; // this is a comment we are interested in
            }
            else
                goto LNextComment;

            // The first part matched, look at the end of the comment
            if (   (pwOld[pTokArray[i].token.ibTokMac-1] == '-')
                && (pwOld[pTokArray[i].token.ibTokMac-2] == '-')
                && (0 == _wcsnicmp( rgComment[0], 
                                    &pwOld[pTokArray[i].token.ibTokMac-(wcslen(rgComment[0])+2)], 
                                    wcslen(rgComment[0])
                                    )
                                )
                )
            {
                iCommentEnd = i + 1;
                iComment = i;
                ASSERT(iCommentEnd < (INT)ptep->m_cMaxToken);
                break;
            }
            else // error case (our assumption was not valid). ignore and return with iArraySav+1
                goto LNextComment;
LNextComment:
            i++;
        } // while ()


        // HANDLE THIS CASE - WHAT IF WE DIDN'T FIND A SINGLE COMMENT????


        if (fFoundParam)
        {
            if (iCommentStart != -1 && iCommentEnd != -1)
            {
                cbNeed = (ichNewCur+(pTokArray[iCommentEnd].token.ibTokMac-pTokArray[iObjTagEnd].token.ibTokMin)+(iCommentStart-iObjTagEnd)*3/*for eol,tab*/+(pTokArray[iObjTagEnd].token.ibTokMac-ichBeginCopy))*sizeof(WCHAR)+cbBufPadding;
                if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                    goto LErrorRet;

                // we need to format the param tags because trident puts them on one line
                // copy till the first param tag
                memcpy( (BYTE *)(&pwNew[ichNewCur]),
                        (BYTE *)(&pwOld[ichBeginCopy]),
                        (pTokArray[iObjTagEnd].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
                ichNewCur += (pTokArray[iObjTagEnd].token.ibTokMac-ichBeginCopy);
                // From here, copy each param tag and insert an EOL after each. 
                // Stop at iCommentStart
                for (i = iObjTagEnd+1; i < iCommentStart; i++)
                {
                    // if its TokTag_START, insert EOL
                    if (   pTokArray[i].token.tok == TokTag_START
                        && pTokArray[i].token.tokClass == tokTag
                        )
                    {
                        pwNew[ichNewCur] = '\r';
                        ichNewCur++;
                        pwNew[ichNewCur] = '\n';
                        ichNewCur++;
                        pwNew[ichNewCur] = '\t'; // replace this with appropriate alignment
                        ichNewCur++;
                    }
                    // copy the tag
                    memcpy( (BYTE *)(&pwNew[ichNewCur]),
                            (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                } // for ()

                // from here, look for extra spaces/tabs/eols that trident has accumulated
                // at the end of the PARAM tags and remove them.
                for (i = iCommentEnd+1; i <= (int)indexObjEnd; i++)
                {
                    if (   (pTokArray[i].token.tokClass == tokIDENTIFIER && pTokArray[i].token.tok == 0)
                        || (   pTokArray[i].token.tokClass == tokOp 
                            && pTokArray[i].token.tok == 0 
                            && pwOld[pTokArray[i].token.ibTokMin] == 0x0a
                            && pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 1
                            )
                        )
                    {
                        int iChar;
                        BOOL fCopy = FALSE;

                        // see if all the characters in this token are spaces/tabs/eols
                        for (iChar = pTokArray[i].token.ibTokMin; iChar < (int)pTokArray[i].token.ibTokMac; iChar++)
                        {
                            if (   pwOld[iChar] != ' '
                                && pwOld[iChar] != '\r'
                                && pwOld[iChar] != '\n'
                                && pwOld[iChar] != '\t'
                                )
                            {
                                // we need to copy this token
                                fCopy = TRUE;
                                break;
                            }
                        } // for (iChar)
                        if (fCopy)
                        {
                            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                                    (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                                    (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                            ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                        }
                    }
                    else
                    {
                        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                                (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                        if (pTokArray[i].token.tok == TokTag_CLOSE && pTokArray[i].token.tokClass == tokTag)
                        {
                            pwNew[ichNewCur++] = '\r';
                            pwNew[ichNewCur++] = '\n';
                        }
                    }
                } // for ()
                ichBeginCopy = pTokArray[indexObjEnd].token.ibTokMac;
                iArray = indexObjEnd + 1;
            }
        }
        else
        {
            if (iCommentStart != -1 && iCommentEnd != -1 && iComment != -1)
            {
                INT cchComment1, cchComment2;
                INT ichCommentStart, ichParamStart, cchCommentToken;

                // We didn't have any <PARAM> for this object. It means one of the following
                // (a)Trident deleted those or (b)it didn't have any before going to Trident
                // If Trident deleted those, we should have them in form of a comment.
                // If we didn't have those  before doing to Trident, we won't have that magic comment
                // BUT by the time we come here, we are sure that we have found the magic comment

                // ASSUME that trident won't move the comment from its original place
                // NOTE - In this release, we don't need to handle the case of Trident moving the comment location
                // which was originally placed just after <OBJECT ...>

                // remove the comment tokens surrounding the <PARAM>s.
                cchComment1 = wcslen(rgComment[1]);
                cchComment2 = wcslen(rgComment[2]);
                // remove cchComment1 chars from begining of pwOld[pTokArray[i+1].token.ibTokMin
                // remove cchComment2 chars from the end of pwOld[pTokArray[i+1].token.ibTokMac
                // and copy the rest into pwNew

                ichCommentStart = pTokArray[iCommentStart].token.ibTokMin;
                ichParamStart = pTokArray[iCommentStart+1].token.ibTokMin+cchComment1;
                ASSERT((INT)(ichCommentStart-ichBeginCopy) >= 0);
                cbNeed = (ichNewCur+ichCommentStart-ichBeginCopy+pTokArray[iComment].token.ibTokMac-pTokArray[iComment].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
                if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                    goto LRet;
                // copy till begining of the comment
                memcpy( (BYTE *)(pwNew+ichNewCur),
                        (BYTE *)(pwOld+ichBeginCopy),
                        (ichCommentStart-ichBeginCopy)*sizeof(WCHAR));
                ichNewCur += ichCommentStart-ichBeginCopy;
                ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;

                cchCommentToken = pTokArray[iComment].token.ibTokMac-pTokArray[iComment].token.ibTokMin;
                ASSERT((INT)(cchCommentToken-cchComment1-cchComment2) >= 0);
                memcpy( (BYTE *)(&pwNew[ichNewCur]),
                        (BYTE *)&(pwOld[ichParamStart]),
                        (cchCommentToken-cchComment1-cchComment2)*sizeof(WCHAR));
                ichNewCur += pTokArray[iComment].token.ibTokMac-pTokArray[iComment].token.ibTokMin-cchComment1-cchComment2;
                iArray = iCommentEnd + 1;
            }
        } // if (!fFoundParam)
    } // else of if (hr == S_OK)

LErrorRet:
    //free hgDTC if its not NULL
    if (hgDTC != NULL)
        GlobalUnlockFreeNull(&hgDTC);

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

//LRetOnly:   
    return;

} /* fnRestoreDTC() */

void
CTriEditParse::fnSaveDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
          INT *pcDTC, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    // DTC case -
    // if we get STARTSPAN, search backwords (carefully) for tokTag_BANG in pTokArray
    // once we find that, remember the ibTokMin for DTC replacement
    // once we get a ENDSPAN tagID, wait for upcoming toktag_CLOSE which will end DTC
    // remember ibTokMac at that position. This is the DTC range.
    // In pTokArray, start at METADATA and look for matching OBJECT & /OBJECT tokIDs
    // Blt the OBJECT block over to ibTokMin and NULL remaining area in DEBUG build

    UINT indexDTCStart, indexDTCEnd, cchDTCStart, cchDTCEnd;
    UINT indexObjectStart, indexObjectEnd, cchObjectStart, cchObjectEnd;
    BOOL fFindFirstObj;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    INT cDTC = *pcDTC;
    INT i;
    INT ichClsid = 0; // init
    LPOLESTR szClsid;
    UINT iStartSpan;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR rgCommentRT[] =
    {
        L" <!--DTCRUNTIME ",
        L" DTCRUNTIME--> ",
        L"-->",
    };
    LPCWSTR szDesignerControl[] =
    {
        L"\"DesignerControl\"",
        L"DesignerControl",
    };
    BOOL fDesignerControlFound;
    UINT iArraySav = iArray;

    UINT ichObjectEndBegin, indexRTMac, indexRTStart;
    BOOL fFirstDash;
    UINT cbNeed;

    indexDTCStart = indexDTCEnd = cchDTCStart = cchDTCEnd = 0;
    indexObjectStart = indexObjectEnd = cchObjectStart = cchObjectEnd = 0;

    ASSERT(cDTC >= 0); // make sure that this was initilized
    if (cDTC == 0)
        goto LRetOnly;
    while (cDTC > 0)
    {
        // start at iArray of pTokArray and look for STARTSPAN
        //while (pTokArray[iArray].token.tok != ft.tokBegin2)
        //  iArray++;
        ASSERT(iArray < ptep->m_cMaxToken);
        
        if (pTokArray[iArray].token.tok != TokAttrib_STARTSPAN)
            goto LRet; // something is wrong

        iStartSpan = iArray;
        ASSERT(pTokArray[iArray].token.tok == TokAttrib_STARTSPAN);
        ASSERT(pTokArray[iArray].token.tokClass == tokAttr);
        i = iArray; // the position at which we found ft.tokBegin2
        fDesignerControlFound = FALSE;
        while (i >= 0)
        {
            // do we need to do anything else here?
            if (pTokArray[i].token.tok == ft.tokBegin)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_BANG);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            if (   (   pTokArray[i].token.tokClass == tokString
                    && 0 == _wcsnicmp(szDesignerControl[0], &pwOld[pTokArray[i].token.ibTokMin], wcslen(szDesignerControl[0]))
                    )
                || (   pTokArray[i].token.tokClass == tokValue
                    && 0 == _wcsnicmp(szDesignerControl[1], &pwOld[pTokArray[i].token.ibTokMin], wcslen(szDesignerControl[1]))
                    )
                )
            {
                fDesignerControlFound = TRUE;
            }

            i--;
        }
        if (i >= 0) // found TokTag_BANG token
        {
            cchDTCStart = pTokArray[i].token.ibTokMin;
            indexDTCStart = i;
        }
        else // error case 
        {
            // we found STARTSPAN, but didn't find <! of <!--METADATA
            // we can't process this DTC, so quit
            goto LRet;
        }
        if (!fDesignerControlFound)
        {
            // we didn't find DesignerControl for the DTC, which means this is not the DTC we care about
            // we can't process this DTC, so quit
            iArray = iArraySav + 1;
            goto LRet;
        }

        // now, look for ft.tokEnd2 i.e. TokAttrib_ENDSPAN
        if (   pTokArray[iStartSpan].iNextprev != -1 /* validate */
            && pTokArray[pTokArray[iStartSpan].iNextprev].token.tok == ft.tokEnd2)
        {
            ASSERT(pTokArray[pTokArray[iStartSpan].iNextprev].token.tokClass == tokAttr);
            i = iStartSpan;
            while (i < (int)ptep->m_cMaxToken && pTokArray[i].token.tok != TokElem_OBJECT)
                i++;
            if (i < (int)ptep->m_cMaxToken) // found the first <OBJECT> tag
                indexObjectStart = i;
            i = pTokArray[iStartSpan].iNextprev;
        }
        else // actually, we should have found ft.tokEnd2 in the if case, but if stack unwinding didn't happen correctly...
        {
            // on the way, look for 1st <OBJECT> tag
            fFindFirstObj = TRUE;
            i = iArray;
            while (pTokArray[i].token.tok != ft.tokEnd2)
            {
                if (fFindFirstObj && pTokArray[i].token.tok == TokElem_OBJECT)
                {
                    ASSERT(pTokArray[i].token.tokClass == tokElem);
                    indexObjectStart = i;
                    fFindFirstObj = FALSE;
                }
                i++;
                if (i >= (int)ptep->m_cMaxToken)
                    break;
            }
            if (i >= (int)ptep->m_cMaxToken)
            {
                // we didn't find ENDSPAN before hitting ptep->m_cMaxToken
                // we can't process this DTC, so quit
                goto LRet;
            }
        }
        ASSERT(pTokArray[i].token.tok == TokAttrib_ENDSPAN);
        ASSERT(pTokArray[i].token.tokClass == tokAttr);

        // from this i'th  position, look backwards to find '<!' of '<!--METADATA ...endspan...'
        indexRTMac = i;
        while (indexRTMac > indexObjectStart)
        {
            if (   pTokArray[indexRTMac].token.tok == TokTag_BANG
                && pTokArray[indexRTMac].token.tokClass == tokTag
                )
            {
                break;
            }
            indexRTMac--;
        }
        if (indexRTMac <= indexObjectStart) // error case
            goto LRet;
        
        // save this ith position to find last </OBJECT> tag
        indexObjectEnd = indexObjectStart;
        // from this ith poistion, look for ft.tokEnd
        while (i < (int)ptep->m_cMaxToken)
        {
            if (pTokArray[i].token.tok == ft.tokEnd)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_CLOSE);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            i++;
        }
        if (i < (int)ptep->m_cMaxToken) // found TokTag_CLOSE token
        {
            cchDTCEnd = pTokArray[i].token.ibTokMac;
            indexDTCEnd = i;
        }
        else
        {
            // we didn't find TokTag_CLOSE after ENDSPAN,
            // we can't process this DTC, so quit
            goto LRet;
        }
        // look forward from indexObjectEnd for the </OBJECT> tag
        while (indexObjectEnd < ptep->m_cMaxToken)
        {
            if (   pTokArray[indexObjectEnd].token.tok == TokElem_OBJECT
                && pTokArray[indexObjectEnd].token.tokClass == tokElem
                && pTokArray[indexObjectEnd-1].token.tok == TokTag_END /* </ */
                )
                break;
            indexObjectEnd++;
        }
        if (indexObjectEnd >= ptep->m_cMaxToken) // didn't find </OBJECT>, error case
        {
            goto LRet;
        }
        if (indexObjectEnd > indexObjectStart) // </OBJECT> found
        {
            // get ibTokMin of the previous < tag for indexObjectStart
            i = indexObjectStart;
            // generally, the previous tag should be the one we want, 
            // but this covers the boundary cases
            while (i > (int)indexDTCStart) 
            {
                if (pTokArray[i].token.tok == TokTag_START)
                {
                    ASSERT(pTokArray[i].token.tokClass == tokTag);
                    break;
                }
                i--;
            }
            //ASSERT(i > (int)indexDTCStart+1); // atleast
            cchObjectStart = pTokArray[i].token.ibTokMin;
            // get ibTokMac of the next > tag for indexObjectEnd
            i = indexObjectEnd;
            // generally, the next tag should be the one we want, 
            // but this covers the boundary cases
            while (i < (int)indexDTCEnd)
            {
                if (pTokArray[i].token.tok == TokTag_CLOSE)
                {
                    ASSERT(pTokArray[i].token.tokClass == tokTag);
                    break;
                }
                i++;
            }
            ASSERT(i < (int)indexDTCEnd -1); // atleast
            cchObjectEnd = pTokArray[i].token.ibTokMac; // do we need -1 here?
        }
        else
            goto LRet;

        // from indexObjectEnd look backwards to get tokTag_END
        indexRTStart = i+1;
        i = indexObjectEnd;
        while (i > (int)indexObjectStart) // we don't have to go this far
        {
            if (   pTokArray[i].token.tok == TokTag_END
                && pTokArray[i].token.tokClass == tokTag
                )
            {
                break;
            }
            i--;
        }
        if (i <= (int)indexObjectStart) // error case, do we care?
            goto LRet;
        ichObjectEndBegin = pTokArray[i].token.ibTokMin;

        iArray = indexDTCEnd; // set it for next DTC entry
        
        // now Replace the DTC

        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of DTC
        if ((int)(cchDTCStart-ichBeginCopy) >= 0)
        {
            cbNeed = (ichNewCur+cchDTCStart-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LSkipCopy;
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichBeginCopy]),
                    (cchDTCStart-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (cchDTCStart-ichBeginCopy);
            ichBeginCopy = cchDTCEnd; // make it ready for next copy
        }

        i = indexObjectStart;

        while (i < (int)indexObjectEnd)
        {
            if (pTokArray[i].token.tok == TokAttrib_CLASSID)
            {
                ASSERT(pTokArray[i].token.tokClass == tokAttr);
                break;
            }
            i++;
        }

        if (i < (int)indexObjectEnd -1) // found TokAttrib_CLASSID
        {
            // make sure that the next one is tokOpEqual
            ASSERT(pTokArray[i+1].token.tokClass == tokOp);
            // make sure that the next one is the id and get that value
            //ASSERT(pTokArray[i].token.tok == );

            // Is there any other way to skip "clsid:" string that appears before the clsid?
            ichClsid = pTokArray[i+2].token.ibTokMin + strlen("clsid:");
            // This is a HACK to fix DaVinci's bug, where they can't handle non-quoted
            // classId
            if (pwOld[pTokArray[i+2].token.ibTokMin] == '"')
                ichClsid++;
        }

        if (ptep->m_fInHdrIn)
        {
            if (       (S_OK == StringFromCLSID(CLSID_PageTr, &szClsid))
                        && (0 == _wcsnicmp(szClsid+1/* for {*/, &pwOld[ichClsid], sizeof(CLSID)))
                        )
            {
                // copy the object part of the DTC into m_pPTDTC
                if (ptep->m_pPTDTC != NULL) // means that we have more than one PTDTC on the page
                    goto LMultPTDTC;

                ptep->m_hgPTDTC = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, (cchObjectEnd-cchObjectStart)*sizeof(WCHAR));
                // if the allocation failed, just don't copy into ptep->m_hgPTDTC
                if (ptep->m_hgPTDTC != NULL)
                {
                    ptep->m_pPTDTC = (WORD *) GlobalLock(ptep->m_hgPTDTC);
                    ASSERT(ptep->m_pPTDTC != NULL);
                    memcpy( (BYTE *)(ptep->m_pPTDTC),
                            (BYTE *)(&pwOld[cchObjectStart]),
                            (cchObjectEnd-cchObjectStart)*sizeof(WCHAR));
                    ptep->m_cchPTDTCObj = cchObjectEnd-cchObjectStart;
                    ptep->m_ichPTDTC = cchDTCStart; // with respect to the saved header
                    ptep->m_cchPTDTC = cchDTCEnd - cchDTCStart;

                    ::CoTaskMemFree(szClsid);
                    goto LSkipCopy;
                }
            }
LMultPTDTC:
            ::CoTaskMemFree(szClsid);
        }

        cbNeed = (ichNewCur+(cchObjectEnd-cchObjectStart)+(pTokArray[indexRTMac].token.ibTokMin-cchObjectEnd)+wcslen(rgCommentRT[0])+wcslen(rgCommentRT[1]))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LSkipCopy;
        // STEP 1 - copy till the begining of </OBJECT>
        ASSERT((int)(ichObjectEndBegin-cchObjectStart) >= 0);
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[cchObjectStart]),
                (ichObjectEndBegin-cchObjectStart)*sizeof(WCHAR));
        ichNewCur += ichObjectEndBegin-cchObjectStart;

        // STEP 2 - Insert the runtime text as a comment
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgCommentRT[0]),
                wcslen(rgCommentRT[0])*sizeof(WCHAR));
        ichNewCur += wcslen(rgCommentRT[0]);

        // we need to loop thr indexRTStart & indexRTMac and copy token by token
        // and modify TokTag_BANG on the way
        fFirstDash = TRUE;
        while (indexRTStart < indexRTMac)
        {
            // (4/14/98)
            // VID-BUG 17453 Fotm Manager DTC puts in 0x0d (\r) as an end of line instead of
            // putting 0x0d 0xa (\r\n) as an end of line. 
            // In this case, the token thats generated is tokIdentifier => "0x0d - - >" 
            // instead of getting 3 separate tokens for the normal case as "0x0d 0x0a"
            // & "- -" & ">".
            // Two ways to fix this problem ...
            // 1. Handle this would be in our tokenizer that treats "0x0d" as an
            //    end of line as well. But at this time, its not a safe change to do.
            // 2. In the below if condition, add the fact that we may have "0x0d" followed
            //    by "-->" for end of metadata comment.
            if (   fFirstDash
                && (   (0 == _wcsnicmp(rgCommentRT[2], &pwOld[pTokArray[indexRTStart].token.ibTokMin], wcslen(rgCommentRT[2])))
                    || (   (0 == _wcsnicmp(rgCommentRT[2], &pwOld[pTokArray[indexRTStart].token.ibTokMin+1], wcslen(rgCommentRT[2])))
                        && (pwOld[pTokArray[indexRTStart].token.ibTokMin] == 0x0d)
                        )
                    )
                )
            {
                indexRTStart++;
                fFirstDash = FALSE;
                continue;
            }

            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[indexRTStart].token.ibTokMin],
                    (pTokArray[indexRTStart].token.ibTokMac-pTokArray[indexRTStart].token.ibTokMin)*sizeof(WCHAR)
                    );
            ichNewCur += pTokArray[indexRTStart].token.ibTokMac-pTokArray[indexRTStart].token.ibTokMin;
            if (   pTokArray[indexRTStart].token.tok == TokTag_BANG 
                && pTokArray[indexRTStart].token.tokClass == tokTag
                )
            {
                pwNew[ichNewCur-2] = '?';
            }
            if (   pTokArray[indexRTStart].token.tok == TokTag_CLOSE 
                && pTokArray[indexRTStart].token.tokClass == tokTag
                && pwOld[pTokArray[indexRTStart-1].token.ibTokMac-1] == '-'
                && pwOld[pTokArray[indexRTStart-1].token.ibTokMac-2] == '-'
                )
            {
                pwNew[ichNewCur-1] = '?';
            }
            // following is a hack for the NavBar DTC
            if (   pTokArray[indexRTStart].token.tok == TokElem_METADATA
                && pTokArray[indexRTStart].token.tokClass == tokElem
                )
            {
                pwNew[ichNewCur-1] = '?';
            }
            indexRTStart++;
        } // while ()

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgCommentRT[1]),
                wcslen(rgCommentRT[1])*sizeof(WCHAR));
        ichNewCur += wcslen(rgCommentRT[1]);

        // STEP 3 - copy the rest of the object, i.e. the </OBJECT> tag
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichObjectEndBegin]),
                (cchObjectEnd-ichObjectEndBegin)*sizeof(WCHAR));
        ichNewCur += cchObjectEnd-ichObjectEndBegin;

LSkipCopy:
        cDTC--;
    } // while (cDTC > 0)

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;
} /* fnSaveDTC() */

void
CTriEditParse::fnSaveHtmlTag(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    BOOL fFoundTag, fFoundHtmlBegin;
    INT i;
    UINT cchHtml, iHtmlBegin, iHtmlEnd;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT cbNeed;

    // assert that iArray'th element in pTokArry is TokTag_HTML
    // Look for any non -1 tags before iArray
    // if we find any, it indicates that we have some stuff before <HTML> that trident doesn't like
    // in pwNew, move all ichNewCur bytes (copied so far) to make space for <HTML> at the begining
    // copy from pwOld <HTML location=> tag
    // adjust ichNewCur and ichBeginCopy

    // **** don't bother about maintaning info about <HTML> tag's location for Restore
    ASSERT(pTokArray[iArray].token.tok == TokElem_HTML);
    iHtmlBegin = i = iArray-1; // init
    fFoundTag = fFoundHtmlBegin = FALSE;
    while (i >= 0)
    {
        if (pTokArray[i].token.tokClass == tokElem || pTokArray[i].token.tokClass == tokSSS)
        {
            fFoundTag = TRUE;
            break;
        }
        if (!fFoundHtmlBegin && pTokArray[i].token.tok == ft.tokBegin) // look for < of <HTML>
        {
            fFoundHtmlBegin = TRUE;
            iHtmlBegin = i; // generally, this should be the right before TokElem_HTML
        }
        i--;
    }
    if (!fFoundHtmlBegin) // we didn't find < for <HTML>, so we are in deep trouble, lets quit here
    {
        goto LRet;
    }
    if (!fFoundTag) // we didn't find any tag before TokElem_HTML, so we don't need to do anything, quit
    {
        goto LRet;
    }

    // move <HTML> tag at the begining of pwNew
    i = iHtmlBegin; // iArray;
    ASSERT(pTokArray[i].token.tok == TokTag_START);
    ASSERT(pTokArray[i].token.tokClass == tokTag);
    
    // look for > of <HTML>
    while (i < (int)ptep->m_cMaxToken) // generally, this will be the very next tag, but this covers boundary cases
    {
        if (pTokArray[i].token.tok == ft.tokEnd)
            break;
        i++;
    }
    if (i >= (int)ptep->m_cMaxToken) // error case, didn't find > of <HTML>, so quit
    {
        iArray++; // so that we won't come back here for the same token
        goto LRet;
    }
    iHtmlEnd = i; // found > of <HTML>
    iArray = i; // set it after > of <HTML>

    cbNeed = (ichNewCur+pTokArray[iHtmlBegin].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    // copy till begining of the <HTML>
    memcpy( (BYTE *)(&pwNew[ichNewCur]),
            (BYTE *)(&pwOld[ichBeginCopy]),
            (pTokArray[iHtmlBegin].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += pTokArray[iHtmlBegin].token.ibTokMin-ichBeginCopy;
    ichBeginCopy = pTokArray[iHtmlEnd].token.ibTokMac; // set it for next thing

    // move all the stuff from pwNew+0 till pwNew+ichNewCur by cchHtml (make space for <HTML>)
    cchHtml = pTokArray[iHtmlEnd].token.ibTokMac-pTokArray[iHtmlBegin].token.ibTokMin;
    memmove((BYTE *)(&pwNew[cchHtml]),
            (BYTE *)pwNew,
            ichNewCur*sizeof(WCHAR));
    ichNewCur += cchHtml;

    // copy <HTML>
    memcpy( (BYTE *)pwNew,
            (BYTE *)(&pwOld[pTokArray[iHtmlBegin].token.ibTokMin]), 
            cchHtml*sizeof(WCHAR));

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

} /* fnSaveHtmlTag() */

void
CTriEditParse::fnRestoreHtmlTag(CTriEditParse* /*ptep*/, LPWSTR /*pwOld*/,
          LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT* /*piArrayStart*/, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    // **** 
    // because we didn't save any info about <HTML> tag's location for Restore, we just return
    return;

} /* fnRestoreHtmlTag() */

void
CTriEditParse::fnSaveNBSP(CTriEditParse* /*ptep*/, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR szNBSP[] = {L"&NBSP"};
    LPCWSTR szNBSPlower[] = {L"&nbsp;"};
    INT ichNbspStart, ichNbspEnd;
    UINT cbNeed;

    // see if pwOld[pTokArray->token.ibtokMin] matches with "&nbsp", 
    // and convert it to lower case
    ASSERT(pTokArray[iArray].token.tokClass == tokEntity);
    if (0 == _wcsnicmp(szNBSP[0], &pwOld[pTokArray[iArray].token.ibTokMin], wcslen(szNBSP[0])))
    {
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of &nbsp

        // check if we have enough memory - If not, realloc
        ichNbspStart = pTokArray[iArray].token.ibTokMin;
        ichNbspEnd = pTokArray[iArray].token.ibTokMac;
        cbNeed = (ichNewCur+ichNbspStart-ichBeginCopy+wcslen(szNBSPlower[0]))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichNbspStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichNbspStart-ichBeginCopy);
        ichBeginCopy = ichNbspEnd; // make it ready for next copy
        
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(szNBSPlower[0]),
                (wcslen(szNBSPlower[0]))*sizeof(WCHAR));
        ichNewCur += wcslen(szNBSPlower[0]);
    }
LErrorRet:
    iArray++; // so that we won't look at the same token again

//LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

} /* fnSaveNBSP() */

void
CTriEditParse::fnRestoreNBSP(CTriEditParse* /*ptep*/, LPWSTR /*pwOld*/,
          LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT* /*piArrayStart*/, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    return;
} /* fnRestoreNBSP() */


BOOL
FIsSpecialTag(TOKSTRUCT *pTokArray, int iTag, WCHAR* /*pwOld*/)
{
    BOOL fRet = FALSE;

    if (   (   pTokArray[iTag].token.tokClass == tokSpace
			|| pTokArray[iTag].token.tokClass == tokComment)
        && pTokArray[iTag].token.tok == 0
        && iTag > 0
        && (   pTokArray[iTag-1].token.tok == TokTag_START 
            || pTokArray[iTag-1].token.tok == TokTag_PI
			|| (   pTokArray[iTag-1].token.tok == TokTag_BANG
				&& pTokArray[iTag+1].token.tok == TokTag_CLOSE
				&& pTokArray[iTag+1].token.tokClass == tokTag
				)
			)
        && pTokArray[iTag-1].token.tokClass == tokTag
        )
    {
        fRet = TRUE;
#ifdef WFC_FIX
        int cch = pTokArray[iTag].token.ibTokMac-pTokArray[iTag].token.ibTokMin;
        WCHAR *pStr = new WCHAR[cch+1];
        WCHAR *pFound = NULL;

        // see if this is xml tag
        // for now we will check tags that have a ':' in them.
        // NOTE - This will get changed when parser change to recognise xml tags is made
        if (pStr != NULL)
        {
            memcpy( (BYTE *)pStr, 
                    (BYTE *)&pwOld[pTokArray[iTag].token.ibTokMin],
                    cch*sizeof(WCHAR));
            pStr[cch] = '\0';
            pFound = wcschr(pStr, ':');
            if (pFound)
                fRet = TRUE;

            delete pStr;
        }
#endif //WFC_FIX
    }
    return(fRet);
}

void
GetTagRange(TOKSTRUCT *pTokArray, int iArrayLast, int *piTag, int *pichTokTagClose, BOOL fMatch)
{
    int index = *piTag;
    int iTokTagClose = -1;

    if (fMatch) // we should look fot pTokArray[iTag].iNextprev
    {
        if (pTokArray[*piTag].iNextprev == -1)
            goto LRet;
        index = pTokArray[*piTag].iNextprev; // that way, we will look for '>' after matching end
    }
    // look for TokTag_CLOSE, from iTag onwards
    while (index < iArrayLast)
    {
        if (   pTokArray[index].token.tokClass == tokTag
            && pTokArray[index].token.tok == TokTag_CLOSE)
        {
            iTokTagClose = index;
            break;
        }
        index++;
    }
    if (iTokTagClose != -1) // we found it
    {
        *pichTokTagClose = pTokArray[iTokTagClose].token.ibTokMac;
        *piTag = iTokTagClose + 1;
    }
LRet:
    return;
} /* GetTagRange() */


void CTriEditParse::fnSaveHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchBeforeBody = 0;
    UINT i, iFound;
    WCHAR *pHdr;
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock
    pHdr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pHdr != NULL);

    // look forward to make sure that we don't have multiple <BODY> tags
    // this may be a result of a typo in user's document or trident inserting it
    i = iArray+1;
    iFound = iArray;
    while (i < ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == TokElem_BODY)
            && (pTokArray[i].token.tokClass == tokElem)
            && (pTokArray[i-1].token.tok == TokTag_START)
            && (pTokArray[i-1].token.tokClass == tokTag)
            )
        {
            iFound = i;
            break;
        }
        i++;
    }
    if (iFound > iArray) // this means that we found the last <BODY> tag Trident inserted
        iArray = iFound;

    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    // what if we DON'T have a <BODY> tag at all. We would have found </BODY> here.
    // If thats the case, we just don't save anything
    ASSERT(iArray-1 >= 0);
    if (pTokArray[iArray-1].token.tok != TokTag_START)
        cchBeforeBody = 0;
    else
        cchBeforeBody = pTokArray[iArray].token.ibTokMin;

    // realloc if needed
    if (cchBeforeBody*sizeof(WCHAR)+sizeof(int) > GlobalSize(ptep->m_hgDocRestore))
    {
        HGLOBAL hgDocRestore;
        GlobalUnlock(ptep->m_hgDocRestore);
        hgDocRestore = ptep->m_hgDocRestore;
#pragma prefast(suppress:308, "noise")
        ptep->m_hgDocRestore = GlobalReAlloc(ptep->m_hgDocRestore, cchBeforeBody*sizeof(WCHAR)+sizeof(int), GMEM_MOVEABLE|GMEM_ZEROINIT);
        // if this alloc failed, we may still want to continue
        if (ptep->m_hgDocRestore == NULL)
        {
            GlobalFree(hgDocRestore);
            goto LRet;
        }
        else
        {
            pHdr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore); // do we need to unlock this first?
            ASSERT(pHdr != NULL);
        }
    }

    // copy from pwOld
    memcpy( (BYTE *)pHdr,
            (BYTE *)&cchBeforeBody,
            sizeof(INT));
    memcpy( (BYTE *)(pHdr)+sizeof(INT),
            (BYTE *)pwOld,
            cchBeforeBody*sizeof(WCHAR));

    // reconstruct the pre_BODY part of the document
    // NOTE  - for next time around ...
    // If we get the title & body tags from pwNew instead of pwOld, we won't
    // loose the DESIGNTIMESPs for those 2 tags
    if (cchBeforeBody > 0)
    {
        int iTag = 0;
        int ichTokTagClose = -1;
        BOOL fMatch = FALSE;
        LPCWSTR rgSpaceTags[] =
        {
            L" DESIGNTIMESP=",
            L" designtimesp=",
        };
        WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?

        int index = iArray;
        int ichBodyTokenStart, ichBodyTokenEnd;
        LPCWSTR rgPreBody[] = {L"<BODY",};

        memset((BYTE *)pwNew, 0, ichNewCur*sizeof(WCHAR));
        // if we have a unicode stream, we should preserve 0xff,0xfe that occurs at the
        // beginning of the file
        ichNewCur = 0;
        if (ptep->m_fUnicodeFile)
        {
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, sizeof(WCHAR));
            ichNewCur = 1;
        }

        // loop through all tags starting from index of '<' of <html> till iArray
        // if the tag we see is one of the following, then copy that tag into pwNew
        // ------------------------------------------------------------------------
        // <HTML>, <HEAD>..</HEAD>, <TITLE>..</TITLE>, <STYLE>..</STYLE>, 
        // <LINK>, <BASE>, <BASEFONT>
        // ------------------------------------------------------------------------
        iTag = 0;
        ichTokTagClose = -1;
        while (iTag < (int)iArray)
        {
            if (   pTokArray[iTag].token.tokClass == tokAttr
                && pTokArray[iTag].token.tok == TokAttrib_STARTSPAN)
            {
                GetTagRange(pTokArray, iArray, &iTag, &ichTokTagClose, TRUE);
            }
            else if (   (   (pTokArray[iTag].token.tokClass == tokElem)
                    && (   pTokArray[iTag].token.tok == TokElem_HTML
                        || pTokArray[iTag].token.tok == TokElem_HEAD
                        || pTokArray[iTag].token.tok == TokElem_META
                        || pTokArray[iTag].token.tok == TokElem_LINK
                        || pTokArray[iTag].token.tok == TokElem_BASE
                        || pTokArray[iTag].token.tok == TokElem_BASEFONT
                        || pTokArray[iTag].token.tok == TokElem_TITLE
                        || pTokArray[iTag].token.tok == TokElem_STYLE
                        || pTokArray[iTag].token.tok == TokElem_OBJECT
                        )
                    )
                || (FIsSpecialTag(pTokArray, iTag, pwOld))
                )
            {
                int iTagSav = iTag;

                fMatch = FALSE;
                ichTokTagClose = -1;
                if (   pTokArray[iTag].token.tok == TokElem_TITLE
                    || pTokArray[iTag].token.tok == TokElem_STYLE
                    || pTokArray[iTag].token.tok == TokElem_OBJECT
                    )
                    fMatch = TRUE;
                GetTagRange(pTokArray, iArray, &iTag, &ichTokTagClose, fMatch);
                if (ichTokTagClose != -1)
                {
                    // copy the stuff into pwNew
                    pwNew[ichNewCur++] = '<';
                    if (   pTokArray[iTagSav-1].token.tok == TokTag_END
                        && pTokArray[iTagSav-1].token.tokClass == tokTag)
                    {
                        pwNew[ichNewCur++] = '/';
                    }
					else if (	   pTokArray[iTagSav-1].token.tok == TokTag_PI
								&& pTokArray[iTagSav-1].token.tokClass == tokTag)
					{
						pwNew[ichNewCur++] = '?';
					}
					else if (	   pTokArray[iTagSav-1].token.tok == TokTag_BANG
								&& pTokArray[iTagSav-1].token.tokClass == tokTag)
					{
						pwNew[ichNewCur++] = '!';
					}
                    memcpy( (BYTE *)&pwNew[ichNewCur], 
                            (BYTE *)&pwOld[pTokArray[iTagSav].token.ibTokMin],
                            (ichTokTagClose-pTokArray[iTagSav].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += ichTokTagClose-pTokArray[iTagSav].token.ibTokMin;
                    // do we want to add \r\n after each tag we copy?
                }
                else
                    goto LNext;
            }
            else
            {
LNext:
                iTag++;
            }
        } // while (iTag < (int)iArray)


        // we know that iArray is currently pointing to tokElem_BODY
        // go backwards and look for '<', so that we can copy from that point
        ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
        ASSERT(pTokArray[iArray].token.tokClass == tokElem);
        index = iArray;
        while (index >= 0)
        {
            if (   pTokArray[index].token.tok == TokTag_START
                && pTokArray[index].token.tokClass == tokTag)
            {
                break;
            }
            index--;
        }
        if (index < 0) // error case, we didn't find '<' before BODY
            goto LSkipBody;
        ichBodyTokenStart = pTokArray[index].token.ibTokMin;

        // now go forward till we get the '>' of <BODY>, we don't have to go this far, 
        // but this covers boundary cases
        index = iArray;
        while (index < (int)ptep->m_cMaxToken)
        {
            if (   pTokArray[index].token.tok == TokTag_CLOSE
                && pTokArray[index].token.tokClass == tokTag)
            {
                break;
            }
            index++;
        }
        if (index > (int)ptep->m_cMaxToken) // error case, we didn't find '>' before BODY
            goto LSkipBody;
        ichBodyTokenEnd = pTokArray[index-1].token.ibTokMac; // BUG 15391 - don't copy TokTag_CLOSE here, it gets added later
    
        // blt part of the <BODY> tag into pwNew. (BUG 15391 - excluding the ending >)
        ASSERT(ichBodyTokenEnd-ichBodyTokenStart >= 0);
        memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)&pwOld[ichBodyTokenStart], (ichBodyTokenEnd-ichBodyTokenStart)*sizeof(WCHAR));
        ichNewCur += (ichBodyTokenEnd-ichBodyTokenStart); 

        // only if spacing flag is set
        if (dwFlags & dwPreserveSourceCode)
        {
            // BUG 15391 - insert DESIGNTIMESP with (ptep->m_ispInfoBlock+ptep->m_ispInfoBase-1) & add '>' at the end
            ASSERT(wcslen(rgSpaceTags[1]) == wcslen(rgSpaceTags[0]));
            if (iswupper(pwOld[pTokArray[iArray].token.ibTokMin]) != 0) // upper case  - BUG 15389
            {
                memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgSpaceTags[0], wcslen(rgSpaceTags[0])*sizeof(WCHAR));
                ichNewCur += wcslen(rgSpaceTags[0]);
            }
            else
            {
                memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgSpaceTags[1], wcslen(rgSpaceTags[1])*sizeof(WCHAR));
                ichNewCur += wcslen(rgSpaceTags[1]);
            }
            (WCHAR)_itow(ptep->m_ispInfoBlock+ptep->m_ispInfoBase-1, szIndex, 10);
            ASSERT(wcslen(szIndex) < sizeof(szIndex));
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(szIndex),
                    wcslen(szIndex)*sizeof(WCHAR));
            ichNewCur += wcslen(szIndex);
        }
        goto LBodyCopyDone;

LSkipBody:
        // if we skipped copying <BODY> tag, we must put in a dummy <BODY> at ichNewCur
        memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgPreBody[0], wcslen(rgPreBody[0])*sizeof(WCHAR));
        ichNewCur = wcslen(rgPreBody[0]);

LBodyCopyDone:
        pwNew[ichNewCur++] = '>'; //ending '>' that we skipped copying before
        // set ichBeginCopy and iArray appropriately
        iArray = index+1;
        ichBeginCopy = pTokArray[iArray].token.ibTokMin;
    }

    // Copy everything upto and including <BODY>

//LSkipCopy:

    if (ptep->m_pPTDTC != NULL) // we had saved PageTransitionDTC in a temporary
    {
        ASSERT(ptep->m_cchPTDTCObj >= 0);
        cbNeed = (ichNewCur+ptep->m_cchPTDTCObj)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        memcpy( (BYTE *)&pwNew[ichNewCur],
                (BYTE *)ptep->m_pPTDTC,
                ptep->m_cchPTDTCObj*sizeof(WCHAR));
        ichNewCur += ptep->m_cchPTDTCObj;
        GlobalUnlockFreeNull(&(ptep->m_hgPTDTC));
    }

    ptep->m_fInHdrIn = FALSE;

LRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

LRetOnly:
    return;

} /* fnSaveHdr() */

void 
CTriEditParse::fnRestoreHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchBeforeBody = 0;
    WCHAR *pHdr;
    INT ichBodyStart, ichBodyEnd;
    UINT i, iFound;
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock, copy, unlock
    pHdr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pHdr != NULL);

    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    
    // HACK to fix a TRIDENT misbehaviour
    // If we had any text before <BODY> tag going into Trident, it will add 2nd <BODY>
    // tag before this text comming out of Trident without looking forward and 
    // recognizing that a <BODY> tag already exists. Ideally, Trident should move teh
    // <BODY> tag at appropriate place rather than inserting a 2nd one.
    // Lets assume that Trident will insert only one extra <BODY> tag.
    i = iArray + 1; // we know iArray is the 1st <BODY> tag
    iFound = iArray;
    while (i < ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == ft.tokBegin2) /*TokElem_BODY*/
            && (pTokArray[i-1].token.tok == TokTag_START)
            )
        {
            iFound = i;
            break;
        }
        i++;
    }
    if (iFound > iArray) // this means that we found the last <BODY> tag Trident inserted
        iArray = iFound;

    memcpy((BYTE *)&cchBeforeBody, (BYTE *)pHdr, sizeof(INT));

    // realloc if needed
    ichBodyStart = pTokArray[iArray].token.ibTokMin;
    ichBodyEnd = pTokArray[iArray].token.ibTokMac;
    cbNeed = (ichNewCur+cchBeforeBody+ichBodyEnd-ichBodyStart)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LErrorRet;

    if (cchBeforeBody > 0)
    {
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of &nbsp
        memcpy( (BYTE *)(pwNew),
                (BYTE *)(pHdr)+sizeof(INT),
                cchBeforeBody*sizeof(WCHAR));
        
        // fill 0s from pwNew+cchBeforeBody till pwNew+ichNewCur-1 (inclusive)
        if ((int)ichNewCur-cchBeforeBody > 0)
            memset((BYTE *)(pwNew+cchBeforeBody), 0, (ichNewCur-cchBeforeBody)*sizeof(WCHAR));

        ichNewCur = cchBeforeBody; // note that we are initializing ichNewCur here ***
        ichBeginCopy = ichBodyEnd; // make it ready for next copy
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBodyStart]),
                (ichBodyEnd-ichBodyStart)*sizeof(WCHAR));
        ichNewCur += (ichBodyEnd-ichBodyStart);  
    }
    else // if we didn't save anything, it means that we had no pre-BODY stuff in the doc (bug 15393)
    {
        if (ptep->m_fUnicodeFile && ichNewCur == 0)
        {
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, sizeof(WCHAR));
            ichNewCur = ichBeginCopy = 1;
        }
        // actually, we should get the '>' of <body> tag instead of using iArray+1
        if (dwFlags & dwFilterSourceCode)
            ichBeginCopy = pTokArray[iArray+1].token.ibTokMac; // '>' of <BODY> tag
        else
        {
#ifdef NEEDED // VID6 - bug 22781 (This is going to generate some debate, so #ifdef instead of removing.
            LPCWSTR rgPreBody[] =
            {
                L"<HTML>\r\n<HEAD><TITLE></TITLE></HEAD>\r\n",
            };
            ASSERT(ichNewCur >= 0); // make sure its not invalid
            memcpy( (BYTE *)&pwNew[ichNewCur], (BYTE *)rgPreBody[0], wcslen(rgPreBody[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgPreBody[0]);
#endif //NEEDED
            // Note that we had not saved any thing before going to design view because there was
            // no <BODY> tag. we should now copy from current pwOld[ichBeginCopy] till 
            // the new pwOld[ichBeginCopy] into pwNew[ichNewCur] and then set ichBeginCopy.
            if (pTokArray[iArray-1].token.ibTokMin > ichBeginCopy)
            {
                memcpy( (BYTE *)&pwNew[ichNewCur], 
                        (BYTE *)&pwOld[ichBeginCopy], 
                        (pTokArray[iArray-1].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
                ichNewCur += pTokArray[iArray-1].token.ibTokMin-ichBeginCopy;
            }
            ichBeginCopy = pTokArray[iArray-1].token.ibTokMin; // '<' of <BODY> tag
        }
    }

LErrorRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;

} /* fnRestoreHdr() */


void CTriEditParse::fnSaveFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchAfterBody = 0;
    INT cchBeforeBody = 0;
    INT cchPreEndBody = 0;
    WCHAR *pFtr;
    INT ichStart, ichEnd;
    UINT iArraySav = iArray;
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock
    pFtr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pFtr != NULL);
    ichStart = pTokArray[iArray-1].token.ibTokMin; // init
    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    ASSERT(pTokArray[iArray-1].token.tok == TokTag_END);
    // what if we DON'T have a </BODY> tag at all. Lets handle the error case here
    // If thats the case, we just don't save anything
    ASSERT(iArray-1 >= 0);
    if (pTokArray[iArray-1].token.tok != TokTag_END)
    {
        cchAfterBody = 0;
        cchPreEndBody = 0;
    }
    else
    {
        // following was added for Bug fix for 7542
        cchAfterBody = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac-pTokArray[iArray].token.ibTokMac;
        
        // now calculate the space required to save stuff from before </BODY> 
        // till the previous meaningful token
        ichStart = ichEnd = pTokArray[iArray-1].token.ibTokMin;
        ichStart--; // now ichStart is pointing to a character before </BODY>
        while (    (ichStart >= 0)
                && (   pwOld[ichStart] == ' '
                    || pwOld[ichStart] == '\r'
                    || pwOld[ichStart] == '\n'
                    || pwOld[ichStart] == '\t'
                    )
                )
        {
            ichStart--;
        }
        ichStart++; // the current char is not one of the above, so increment
        if (ichStart == ichEnd) // we didn't have anyspace, eol, tab between </BODY> & previous token
        {
            cchPreEndBody = 0;
        }
        else
        {
            ASSERT(ichEnd - ichStart > 0);
            cchPreEndBody = ichEnd - ichStart;
        }
    }

    // get cchBeforeBody if pre-BODY part was saved, and adjust pFtr for saving
    memcpy((BYTE *)&cchBeforeBody, (BYTE *)pFtr, sizeof(INT));
    pFtr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);

    // realloc if needed
    if ((cchPreEndBody+cchAfterBody+cchBeforeBody)*sizeof(WCHAR)+3*sizeof(int) > GlobalSize(ptep->m_hgDocRestore))
    {
        HGLOBAL hgDocRestore;
        GlobalUnlock(ptep->m_hgDocRestore);
        hgDocRestore = ptep->m_hgDocRestore;
#pragma prefast(suppress:308, "noise")
        ptep->m_hgDocRestore = GlobalReAlloc(ptep->m_hgDocRestore, (cchPreEndBody+cchAfterBody+cchBeforeBody)*sizeof(WCHAR)+3*sizeof(int), GMEM_MOVEABLE|GMEM_ZEROINIT);
        // if this alloc failed, we may still want to continue
        if (ptep->m_hgDocRestore == NULL)
        {
            GlobalFree(hgDocRestore);
            goto LRet;
        }
        else
        {
            pFtr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore); // do we need to unlock this first?
            ASSERT(pFtr != NULL);
            // remember to set pFtr to be after cchBeforeBody
            pFtr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);
        }
    }

    // copy from pwOld
    memcpy( (BYTE *)pFtr,
            (BYTE *)&cchAfterBody,
            sizeof(INT));
    memcpy( (BYTE *)(pFtr)+sizeof(INT),
            (BYTE *)(pwOld+pTokArray[iArray].token.ibTokMac),
            cchAfterBody*sizeof(WCHAR));
    pFtr += cchAfterBody + sizeof(INT)/sizeof(WCHAR);

    memcpy( (BYTE *)pFtr,
            (BYTE *)&cchPreEndBody,
            sizeof(INT));
    memcpy( (BYTE *)(pFtr)+sizeof(INT),
            (BYTE *)&(pwOld[ichStart]),
            cchPreEndBody*sizeof(WCHAR));

    // the very next token from TokElem_BODY will be TokTag_CLOSE in most cases, but just in case...
    while (iArray < ptep->m_cMaxToken)
    {
        if (pTokArray[iArray].token.tok == TokTag_CLOSE && pTokArray[iArray].token.tokClass == tokTag)
            break;
        iArray++;
    }
    if (iArray >= ptep->m_cMaxToken)
    {
        iArray = iArraySav+1; // atleast copy till that point
        goto LRet;
    }

    // copy till '>' of </BODY> from pwOld into pwNew
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);

    cbNeed = (ichNewCur+pTokArray[iArray].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    memcpy( (BYTE *)&(pwNew[ichNewCur]),
            (BYTE *)&(pwOld[ichBeginCopy]),
            (pTokArray[iArray].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += pTokArray[iArray].token.ibTokMac-ichBeginCopy;
    ichBeginCopy = pTokArray[iArray].token.ibTokMac;

    iArray = ptep->m_cMaxToken - 1;
    ichBeginCopy = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac; // we don't want to copy anything after this

LRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

LRetOnly:
    return;

} /* fnSaveFtr() */

void CTriEditParse::fnRestoreFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchAfterBody = 0;
    INT cchBeforeBody = 0;
    WCHAR *pFtr;
    INT ichBodyEnd;
    UINT i, iFound;
    INT ichInsEOL = -1; // initilize
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock, copy, unlock
    pFtr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pFtr != NULL);

    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    
    // HACK to fix a TRIDENT misbehaviour
    // If we had any text before <BODY> tag going into Trident, it will add 2nd <BODY>
    // tag before this text comming out of Trident without looking forward and 
    // recognizing that a <BODY> tag already exists. Ideally, Trident should move teh
    // <BODY> tag at appropriate place rather than inserting a 2nd one.
    // Lets assume that Trident will insert only one extra <\BODY> tag.
    i = iArray + 1; // we know iArray is the 1st <\BODY> tag
    iFound = iArray;
    while (i < ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == ft.tokBegin2) /*TokElem_BODY*/
            && (pTokArray[i-1].token.tok == TokTag_END)
            )
        {
            iFound = i;
            break;
        }
        i++;
    }
    if (iFound > iArray) // this means that we found the last <BODY> tag Trident inserted
        iArray = iFound;

    memcpy((BYTE *)&cchBeforeBody, (BYTE *)pFtr, sizeof(INT));
    pFtr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);
    memcpy((BYTE *)&cchAfterBody, (BYTE *)pFtr, sizeof(INT));
    pFtr += sizeof(INT)/sizeof(WCHAR);
    ichBodyEnd = pTokArray[iArray].token.ibTokMac;
    // if (cchAfterBody == 0) // get the size of our own header

    // realloc if needed
    cbNeed = (ichNewCur+cchAfterBody+(ichBodyEnd-ichBeginCopy)+2/* for EOL*/)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LErrorRet;

    if (cchAfterBody > 0)
    {
        LPCWSTR rgSpaceTags[] = {L"DESIGNTIMESP"};
        int cchTag, index, indexDSP;

        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to end of HTML document
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichBodyEnd-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichBodyEnd-ichBeginCopy);
        ichBeginCopy = ichBodyEnd;

        // now that we have copied 'BODY' of </BODY> tag, lets make sure its of correct case (bug 18248)
        indexDSP = -1;
        index = pTokArray[iArray].iNextprev;
        cchTag = wcslen(rgSpaceTags[0]);
        if (index != -1 && index < (int)iArray) // we have matching <BODY> tag prior to this one
        {
            // get the designtimesp attribute
            while (index < (int)iArray) // we will never come this far, but thats the only known position at this point
            {
                if (pTokArray[index].token.tok == TokTag_CLOSE)
                    break;
                if (   (pTokArray[index].token.tok == 0)
                    && (pTokArray[index].token.tokClass == tokSpace)
                    && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[index].token.ibTokMin], cchTag))
                    )
                {
                    indexDSP = index;
                    break;
                }
                index++;
            } // while
            if (indexDSP != -1) // we found DESIGNTIMESP attribute
            {
                // look for the case of designtimesp
                if (iswupper(pwOld[pTokArray[indexDSP].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                    _wcsupr(&pwNew[ichNewCur-4]); // length of BODY tag name
                else
                    _wcslwr(&pwNew[ichNewCur-4]); // length of BODY tag name
            }
        }

        // we know that the following condition will be met most of the times, but just to cover
        // incomplete HTML cases...
        if (   (pTokArray[iArray].token.tok == ft.tokBegin2) /*TokElem_BODY*/
            && (pTokArray[iArray-1].token.tok == TokTag_END)
            )
        {
            ichInsEOL = ichNewCur - (pTokArray[iArray].token.ibTokMac - pTokArray[iArray-1].token.ibTokMin);
        }

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)pFtr,
                (cchAfterBody)*sizeof(WCHAR));
        ichNewCur += (cchAfterBody);

        // we had saved spacing info before </BODY>
        if (ichInsEOL != -1)
        {
            INT cchPreEndBody = 0;

            pFtr += cchAfterBody;
            cchPreEndBody = *(int *)pFtr;
            if (cchPreEndBody > 0)
            {
                INT ichT = ichInsEOL-1;
                WCHAR *pw = NULL;
                INT cchSubStr = 0;
                WCHAR *pwStr = NULL;
                WCHAR *pwSubStr = NULL;

                pFtr += sizeof(INT)/sizeof(WCHAR); // pFtr now points to Pre </BODY> stuff
                // This is kind of hacky - but I don't see a way out, atleast 
                // If the contents in pFtr at cchPreEndBody are subset of the
                // contents before </BODY> and after any previous text/tokens,
                // then we shouldn't do the following memcpy()
                while (    ichT >= 0 /* validation */
                        && (       pwNew[ichT] == ' '
                                || pwNew[ichT] == '\n'
                                || pwNew[ichT] == '\r'
                                || pwNew[ichT] == '\t'
                                )
                            )
                {
                    ichT--;
                    cchSubStr++;
                }
                ichT++; // compensate the last decrement
                if (cchSubStr > 0)
                {
                    ASSERT(ichT >= 0);
                    pwStr = new WCHAR [cchSubStr+1];
                    memcpy((BYTE *)pwStr, (BYTE *)(&pwNew[ichT]), cchSubStr*sizeof(WCHAR));
                    pwStr[cchSubStr] = '\0';
                    pwSubStr = new WCHAR [cchPreEndBody+1];
                    memcpy((BYTE *)pwSubStr, (BYTE *)pFtr, cchPreEndBody*sizeof(WCHAR));
                    pwSubStr[cchPreEndBody] = '\0';
                    pw = wcsstr(pwStr, pwSubStr);
                }
                if (pw == NULL) // means that the substring wasn't found
                {
                    // allocate more memory if needed
                    cbNeed = (ichNewCur+cchPreEndBody)*sizeof(WCHAR)+cbBufPadding;
                    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                        goto LErrorRet;


                    memmove((BYTE *)(&pwNew[ichInsEOL+cchPreEndBody]),
                            (BYTE *)(&pwNew[ichInsEOL]),
                            (ichNewCur-ichInsEOL)*sizeof(WCHAR));
                    memcpy( (BYTE *)(&pwNew[ichInsEOL]),
                            (BYTE *)(pFtr),
                            (cchPreEndBody)*sizeof(WCHAR));
                    ichNewCur += cchPreEndBody;
                }
                if (pwStr != NULL)
                    delete pwStr;
                if (pwSubStr != NULL)
                    delete pwSubStr;
            } // if (cchPreEndBody > 0)
        } // if (ichInsEOL != -1)

        ichBeginCopy = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac; // we don't want to copy anything after this
        iArray = ptep->m_cMaxToken - 1;

        // WISH LIST Item for space preservation        
        // we know that ptep->m_ispInfoBlock was the last spacing block that was recovered.
        // This block (like all others) has 4 parts (1)pre '<' (2)between '<>' & order info
        // (3)post '>' (4)pre matching '</'
        // At this point we care about (3) & (4)
        // first of all, get ichBeginNext (ich past '>') & ichBeginMatch (ich before '</')
        // apply the saved spacing info to the contents of pwNew

        // The difficult part is to get these ich's without parsing pwNew.
    }
    else
    {
        // copy our own Footer
        if (dwFlags & dwFilterSourceCode)
        {
            int ichBodyStart, index, ichBodyTagEnd;

            // get the '</' of </body>
            index = iArray;
            while (index >= 0) // we won't go this far, but just in case we have invalid html
            {
                if (   pTokArray[index].token.tok == TokTag_END
                    && pTokArray[index].token.tokClass == tokTag
                    )
                {
                    break;
                }
                index--;
            }
            if (index >= 0)
            {
                ichBodyStart = pTokArray[index].token.ibTokMin;
                // copy till the current token's begining, see if we have enough space
                if (ichBodyStart > (int)ichBeginCopy)
                {
                    cbNeed = (ichNewCur+ichBodyStart-ichBeginCopy+1/*for null at the end*/)*sizeof(WCHAR)+cbBufPadding;
                    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                        goto LErrorRet;
                    memcpy( (BYTE *)(&pwNew[ichNewCur]),
                            (BYTE *)(&pwOld[ichBeginCopy]),
                            (ichBodyStart-ichBeginCopy)*sizeof(WCHAR));
                    ichNewCur += (ichBodyStart-ichBeginCopy);
                    ichBeginCopy = ichBodyStart; // setting this is redundant, but it makes the code readable.
                }
                else if (ichBodyEnd > (int)ichBeginCopy)
                {
                    index = iArray;
                    while (index <= (int)ptep->m_cMaxToken) // we won't go this far, but just in case we have invalid html
                    {
                        if (   pTokArray[index].token.tok == TokTag_CLOSE
                            && pTokArray[index].token.tokClass == tokTag
                            )
                        {
                            break;
                        }
                        index++;
                    }
                    if (index < (int)ptep->m_cMaxToken)
                    {
                        ichBodyTagEnd = pTokArray[index].token.ibTokMac;
                        cbNeed = (ichNewCur+ichBodyTagEnd-ichBeginCopy+1/*for null at the end*/)*sizeof(WCHAR)+cbBufPadding;
                        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                            goto LErrorRet;
                        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                                (BYTE *)(&pwOld[ichBeginCopy]),
                                (ichBodyTagEnd-ichBeginCopy)*sizeof(WCHAR));
                        ichNewCur += (ichBodyTagEnd-ichBeginCopy);
                        ichBeginCopy = ichBodyTagEnd; // setting this is redundant, but it makes the code readable.
                    }
                }

                // add a null at the end 
                // to keep the code in ssync with the if (cchAfterBody > 0) case
                pwNew[ichNewCur++] = '\0';

                ichBeginCopy = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac; // we don't want to copy anything after this
                iArray = ptep->m_cMaxToken - 1;
            } // if (index >= 0)
        } // if (dwFlags & dwFilterSourceCode)
    }


    if (ptep->m_cchPTDTC != 0)
    {
        // this means that we didn't encounter the DTC on way out from Trident
        // but they were there when we went to Trident. The user must have deleted
        // the DTCs while in Design view
        ASSERT(ptep->m_ichPTDTC != 0);
        // remove m_cchPTDTC WCHARS from m_ichPTDTC
        memset( (BYTE *)&pwNew[ptep->m_ichPTDTC],
                0,
                ptep->m_cchPTDTC*sizeof(WCHAR)
                );
        memmove((BYTE *)&pwNew[ptep->m_ichPTDTC],
                (BYTE *)&pwNew[ptep->m_ichPTDTC+ptep->m_cchPTDTC],
                (ichNewCur-(ptep->m_ichPTDTC+ptep->m_cchPTDTC))*sizeof(WCHAR)
                );
        ichNewCur -= ptep->m_cchPTDTC;
        ptep->m_cchPTDTC = 0;
    }

LErrorRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;

} /* fnRestoreFtr() */


void CTriEditParse::fnSaveObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    // scan till the end of the object. 
    // If we find '<% %>' blocks inside, put a comment with a special tag around it,
    // else simply copy that object as is and exit
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT ichObjectStart, ichObjectEnd, iObjectStart, iObjectEnd, i;
    BOOL fSSSFound = FALSE;
    UINT iArraySav = iArray;
    UINT cbNeed;

    ichObjectStart = ichObjectEnd = iObjectStart = iObjectEnd = 0;
    
    if (       pTokArray[iArray-1].token.tok == TokTag_END
            && pTokArray[iArray-1].token.tokClass == tokTag
            )
    {
        iArray++;
        goto LRet;
    }
    ASSERT(pTokArray[iArray].token.tok == TokElem_OBJECT); // we should be at the object tag
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    iObjectStart = iArray;

    if (pTokArray[iArray].iNextprev != -1)
    {
        // NOTE that this will give us topmost nested level of the OBJECT, if we had nested objects
        iObjectEnd = pTokArray[iArray].iNextprev;
        ASSERT(iObjectEnd < (INT)ptep->m_cMaxToken);
        ASSERT((iObjectEnd-1 >= 0) && pTokArray[iObjectEnd-1].token.tok == TokTag_END);

        // this will be a wierd case where the iNextprev is incorrectly pointing to another token
        // but lets handle that case.
        if (pTokArray[iObjectEnd].token.tok != TokElem_OBJECT)
            goto LFindObjectClose; // find it by looking at each token
    }
    else // actually, this is an error case, but rather than just giving assert, try to find the token
    {
LFindObjectClose:
        i = iObjectStart+1;
        while (i < (INT)ptep->m_cMaxToken)
        {
            // this may not give us the correct matching </OBJECT> if we had nested objects.
            // but we don't have that knowledge at this point any way.
            if (   pTokArray[i].token.tok == TokElem_OBJECT
                && pTokArray[i].token.tokClass == tokElem
                && (i-1 >= 0) /* validation */
                && pTokArray[i-1].token.tok == TokTag_END
                )
            {
                break;
            }
            i++;
        }
        if (i < (INT)ptep->m_cMaxToken) // found TokElem_OBJECT token
            iObjectEnd = i;
        else // error case 
            goto LRet; // didn't find OBJECT, but exhausted the token array
    }
    // at this point iObjectStart & iObjectEnd point to OBJECT of <OBJECT> and iObjectEnd respectively
    // look for '<' in <OBJECT> & and '>' in </OBJECT>
    i = iObjectStart;
    while (i >= 0)
    {
        if (   pTokArray[i].token.tok == TokTag_START
            && pTokArray[i].token.tokClass == tokTag
            )
            break;
        i--;
    }
    if (i < 0) // error case
        goto LRet;
    iObjectStart = i;
    ichObjectStart = pTokArray[iObjectStart].token.ibTokMin;

    i = iObjectEnd;
    while (i <= (INT)ptep->m_cMaxToken)
    {
        if (   pTokArray[i].token.tok == TokTag_CLOSE
            && pTokArray[i].token.tokClass == tokTag
            )
            break;
        i++;
    }
    if (i >= (INT)ptep->m_cMaxToken) // error case
        goto LRet;
    iObjectEnd = i;
    ichObjectEnd = pTokArray[iObjectEnd].token.ibTokMac;
    ASSERT(ichObjectEnd > ichObjectStart);

    // look for <% %> between iObjectStart & iObjectEnd
    for (i = iObjectStart; i <= iObjectEnd; i++)
    {
        if (   pTokArray[i].token.tok == TokTag_SSSOPEN
            && pTokArray[i].token.tokClass == tokSSS
            )
        {
            fSSSFound = TRUE;
            break;
        }
    }
    if (fSSSFound) // this object can't be displayed in Trident, so convert it
    {
        LPCWSTR rgComment[] =
        {
            L"<!--ERROROBJECT ",
            L" ERROROBJECT-->",
        };

        //if (dwFlags & dwPreserveSourceCode)
        //{
            // in this case, we would have already copied <OBJECT ... DESIGNTIMESP=x>
            // and ichNewCur is adjusted accordingly
            // get ich that points after <OBJECT> in pwOld

            // I don't like this, but don't see a way out...
            // look back in pwNew and get ich that points to '<' of <OBJECT ... DESIGNTIMESP=x>
            // insert the comment there
        //}
        //else
        //{
            ASSERT((INT)(ichObjectStart-ichBeginCopy) > 0);
            cbNeed = (ichNewCur+ichObjectEnd-ichBeginCopy+wcslen(rgComment[0])+wcslen(rgComment[1]))*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LNoCopy;

            // copy till begining of <OBJECT>
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichBeginCopy]),
                    (ichObjectStart-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += ichObjectStart-ichBeginCopy;

            // copy the comment begining
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(rgComment[0]),
                    wcslen(rgComment[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgComment[0]);
            
            // copy from <OBJECT> to </OBJECT>
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichObjectStart]),
                    (ichObjectEnd-ichObjectStart)*sizeof(WCHAR));
            ichNewCur += ichObjectEnd-ichObjectStart;
            
            // copy the comment end
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(rgComment[1]),
                    wcslen(rgComment[1])*sizeof(WCHAR));
            ichNewCur += wcslen(rgComment[1]);
        //}
    }
    else
    {
        // We always save its contents into our buffer and replace it on the way back if need be
        // save cchClsId, clsId, cchParam, PARAM_Tags
        INT cchParam, ichParam, iParamStart, iParamEnd;
        INT ichObjStartEnd; // ich at the end of <OBJECT .....>
        LPCWSTR rgComment[] =
        {
            L"<!--ERRORPARAM ",
            L" ERRORPARAM-->",
        };
        INT iObjTagEnd = -1;

        iParamStart = iObjectStart;
        while (iParamStart < iObjectEnd)
        {
            //if (   pTokArray[iParamStart].token.tok == TokAttrib_CLASSID
            //  && pTokArray[iParamStart].token.tokClass == tokAttr)
            //  iClsId = iParamStart;
            if (   pTokArray[iParamStart].token.tok == TokElem_PARAM
                && pTokArray[iParamStart].token.tokClass == tokElem)
                break;
            iParamStart++;
        }
        if (iParamStart >= iObjectEnd) // don't see any <PARAM> tags, so don't save
            goto LSkipSave;

        while (iParamStart > iObjectStart) // generally this will the previous token, but cover all cases
        {
            if (   pTokArray[iParamStart].token.tok == TokTag_START
                && pTokArray[iParamStart].token.tokClass == tokTag)
                break;
            iParamStart--;
        }
        if (iParamStart <= iObjectStart) // error
            goto LSkipSave;
        ichParam = pTokArray[iParamStart].token.ibTokMin;

        iParamEnd = iObjectEnd;
        while (iParamEnd > iObjectStart)
        {
            if (   pTokArray[iParamEnd].token.tok == TokElem_PARAM
                && pTokArray[iParamEnd].token.tokClass == tokElem)
                break;
            iParamEnd--;
        }
        while (iParamEnd < iObjectEnd) // generally this will the previous token, but cover all cases
        {
            if (   pTokArray[iParamEnd].token.tok == TokTag_CLOSE
                && pTokArray[iParamEnd].token.tokClass == tokTag)
                break;
            iParamEnd++;
        }
        if (iParamEnd >= iObjectEnd) // error
            goto LSkipSave;
        cchParam = pTokArray[iParamEnd].token.ibTokMac - ichParam;
        ASSERT(cchParam > 0);

        // calculate ichObjStartEnd
        iObjTagEnd = iObjectStart;
        while (iObjTagEnd < iParamStart)
        {
            if (   pTokArray[iObjTagEnd].token.tok == TokTag_CLOSE
                && pTokArray[iObjTagEnd].token.tokClass == tokTag)
                break;
            iObjTagEnd++;
        }
        if (iObjTagEnd >= iParamStart) // error case
            goto LSkipSave;
        ichObjStartEnd = pTokArray[iObjTagEnd].token.ibTokMac;

        // realloc if needed
        cbNeed = (ichNewCur+cchParam+(ichObjStartEnd-ichBeginCopy)+wcslen(rgComment[0])+wcslen(rgComment[1]))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LSkipSave;

        // 1. copy <OBJECT ...> tag into pwNew
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichObjStartEnd-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichObjStartEnd-ichBeginCopy);
        ichBeginCopy = ichObjStartEnd;
#ifdef ERROR_PARAM
        // 2. now insert the <PARAM> tags as a comment at pwNew[ichNewCur]
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgComment[0]),
                wcslen(rgComment[0])*sizeof(WCHAR));
        ichNewCur += wcslen(rgComment[0]);

        // we should copy <PARAM> tags ONLY. We may have things other than the tags 
        // in between. e.g. comments
        // Look for TokElem_PARAM between iParamStart & iParamEnd
        ASSERT(pTokArray[iParamStart].token.tok == TokTag_START);
        ASSERT(pTokArray[iParamEnd].token.tok == TokTag_CLOSE);
        // Find PARAM tag, get the '<' & '>' for that PARAM and copy that to pwNew
        // repeat
        index = iParamStart;
        iPrev = iParamStart;
        while (index <= iParamEnd)
        {
            INT iStart, iEnd;

            iStart = iEnd = -1; // that way, its easy to make sure that this is initilized
            // get PARAM
            while (    (       pTokArray[index].token.tok != TokElem_PARAM
                            || pTokArray[index].token.tokClass != tokElem)
                    && (index <= iParamEnd)
                    )
                    index++;
            if (index > iParamEnd)
                goto LDoneCopy;
            // get '<' before the PARAM
            while (    (       pTokArray[index].token.tok != TokTag_START
                            || pTokArray[index].token.tokClass != tokTag)
                    && (index >= iPrev)
                    )
                    index--;
            if (index < iPrev)
                goto LDoneCopy;
            iStart = index;

            // get matching '>'
            while (    (       pTokArray[index].token.tok != TokTag_CLOSE
                            || pTokArray[index].token.tokClass != tokTag)
                    && (index <= iParamEnd)
                    )
                index++;

            if (index > iParamEnd)
                goto LDoneCopy;
            iEnd = index;
            ASSERT(iEnd > iStart);
            ASSERT(iStart != -1);
            ASSERT(iEnd != -1);
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[pTokArray[iStart].token.ibTokMin]),
                    (pTokArray[iEnd].token.ibTokMac-pTokArray[iStart].token.ibTokMin)*sizeof(WCHAR));
            ichNewCur += (pTokArray[iEnd].token.ibTokMac-pTokArray[iStart].token.ibTokMin);
            iPrev = iEnd + 1;
        }
LDoneCopy:

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgComment[1]),
                wcslen(rgComment[1])*sizeof(WCHAR));
        ichNewCur += wcslen(rgComment[1]);
#endif //ERROR_PARAM

        // fake iArraySav to be iObjTagEnd, that way we will st iArray correctly before we leave
        ASSERT(iObjTagEnd != -1);
        iArraySav = (UINT)iObjTagEnd;

LSkipSave:
        iArray = iArraySav + 1;
        goto LRet;
    }

LNoCopy:
    ichBeginCopy = ichObjectEnd; // set it for next copy
    iArray = iObjectEnd+1; // set it after </OBJECT>

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

//LRetOnly:
    return;

} /* fnSaveObject() */

void 
CTriEditParse::fnRestoreObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    // look for the special tag after the '<!--'
    // if we find it, this was an object, remove the comments around it
    // else simply copy the comment and return
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT iArraySav = iArray;
    INT ichCommentStart, ichCommentEnd, iCommentStart, iCommentEnd, cchComment1, cchComment2;
    INT ichObjectStart;
    LPCWSTR rgComment[] =
    {
        L"ERROROBJECT",
        L"--ERROROBJECT ",
        L" ERROROBJECT--",
        L"TRIEDITCOMMENT-",
        L"TRIEDITCOMMENTEND-",
        L"TRIEDITPRECOMMENT-",
    };
    BOOL fSimpleComment = FALSE;
    UINT cbNeed;

    ichCommentStart = ichCommentEnd = iCommentStart = iCommentEnd = 0;
    ASSERT(pTokArray[iArray].token.tok == TokTag_BANG); // we should be at the comment
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);

    // ASSUMPTION - that Trident doesn't muck with the contents inside a comment block

    // if rgComment[0] matches and rgComment[1] does not, Trident may have mucked with the 
    // comment contents. This invalidates our original assumption.
    // NOTE - In this version, we can get away by assuming that trident doesn't muck with the comments

    // early return cases
    // 1. see if this is a comment or not. It could be anything that starts with '<!'
    // e.g. <!DOCTYPE
    if (   (iArray+1 < (INT)ptep->m_cMaxToken)
        && (pwOld[pTokArray[iArray+1].token.ibTokMin] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+1] == '-')
        && (0 == _wcsnicmp(rgComment[0], &pwOld[pTokArray[iArray+1].token.ibTokMin+2], wcslen(rgComment[0])))
        )
    {
        iCommentStart = iArray; // this is a comment we are interested in
    }
    else if (      (iArray+1 < (INT)ptep->m_cMaxToken)
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] == '-')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin+1] == '-')
                && (0 == _wcsnicmp(rgComment[3], &pwOld[pTokArray[iArray+1].token.ibTokMin+2], wcslen(rgComment[3])))
                )
    {
        fSimpleComment = TRUE; // BUG 14056 - Instead of going to LRet, process the comment for space preservation. We will save 3 strings that look similar to text run
    }
    else
    {
        iArray = iArraySav + 1; // not this one
        goto LRet;
    }
    // The first part matched, look at the end of the comment
    if (   (pwOld[pTokArray[iArray+1].token.ibTokMac-1] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMac-2] == '-')
        && (0 == _wcsnicmp( rgComment[0], 
                            &pwOld[pTokArray[iArray+1].token.ibTokMac-(wcslen(rgComment[0])+2)], 
                            wcslen(rgComment[0])
                            )
                        )
        )
    {
        iCommentEnd = iArray + 2;
        ASSERT(iCommentEnd < (INT)ptep->m_cMaxToken);
    }
    else // error case (our assumption was not valid). ignore and return with iArraySav+1
    {
        if (!fSimpleComment)
        {
            iArray = iArraySav + 1; // not this one
            goto LRet;
        }
    }

    if (!fSimpleComment)
    {
        // found the correct one
        cchComment1 = wcslen(rgComment[1]);
        cchComment2 = wcslen(rgComment[2]);
        // remove cchComment1 chars from begining of pwOld[pTokArray[iArray+1].token.ibTokMin
        // remove cchComment2 chars from the end of pwOld[pTokArray[iArray+1].token.ibTokMac
        // and copy the rest into pwNew

        // copy till begining of the comment
        ichCommentStart = pTokArray[iCommentStart].token.ibTokMin;
        ichObjectStart = pTokArray[iCommentStart+1].token.ibTokMin+cchComment1;
        ASSERT((INT)ichCommentStart-ichBeginCopy >= 0);

        cbNeed = (ichNewCur+(ichCommentStart-ichBeginCopy)+(pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(pwOld+ichBeginCopy),
                (ichCommentStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += ichCommentStart-ichBeginCopy;
        ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;

        ASSERT((INT)(pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin-cchComment1-cchComment2) >= 0);
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)&(pwOld[ichObjectStart]),
                (pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin-cchComment1-cchComment2)*sizeof(WCHAR));
        ichNewCur += pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin-cchComment1-cchComment2;
        iArray = iCommentEnd + 1;
    }
    else
    {
        int ichspBegin, ichspEnd, ichCopy;
        WCHAR *pwstr = NULL;

        // part 1 - copy till begining of the comment & apply spacing
        iCommentStart = iArraySav;
        ASSERT(pTokArray[iArraySav].token.tok == TokTag_BANG);
        ASSERT(pTokArray[iArraySav].token.tokClass == tokTag);

        iCommentEnd = iCommentStart + 2;
        ASSERT(pTokArray[iCommentEnd].token.tok == TokTag_CLOSE);
        ASSERT(pTokArray[iCommentEnd].token.tokClass == tokTag);

        ichCommentStart = pTokArray[iCommentStart].token.ibTokMin;
        ASSERT((INT)ichCommentStart-ichBeginCopy >= 0);
        cbNeed = (ichNewCur+ichCommentStart-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        memcpy( (BYTE *)&pwNew[ichNewCur],
                (BYTE *)&pwOld[ichBeginCopy],
                (ichCommentStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += ichCommentStart-ichBeginCopy;

        // make sure that we have enough space
        // to make this calculation simple, we assume the extreme case where every
        // character in the comment had end of line after it. i.e. we will insert
        // 2 characters ('\r\n') after each character in the comment when we restore 
        // the spacing. That means, as long as we have enough space for
        // (pTokArray[iCommentEnd].token.ibTokMac-pTokArray[iCommentStart].token.ibTokMin)*3
        // we are fine
        cbNeed = (ichNewCur+3*(pTokArray[iCommentEnd].token.ibTokMac-pTokArray[iCommentStart].token.ibTokMin))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        
        // apply spacing for pre comment part
        // remove extsting spacing before the comment & add the saved spacing
        // note that we already have copied till the begining of the comment
        ichNewCur--;
        while (    (   pwNew[ichNewCur] == ' '  || pwNew[ichNewCur] == '\t'
                    || pwNew[ichNewCur] == '\r' || pwNew[ichNewCur] == '\n'
                    )
                )
        {
            ichNewCur--;
        }
        ichNewCur++; // compensate, ichNewCur points to non-white space characher
        // now, start writing out the saved spacing
        // look for rgComment[4] & rgComment[5]
        ichspBegin = pTokArray[iCommentStart+1].token.ibTokMin + 2/*for --*/ + wcslen(rgComment[3]);
        pwstr = wcsstr(&pwOld[ichspBegin], rgComment[4]);// pwstr points just after the spacing info block
        if (pwstr == NULL) // didn't find the substring
        {
            // copy the entire comment as is
            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin],
                    (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
            ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;
            goto LCommentEnd;
        }
        ichspBegin = SAFE_PTR_DIFF_TO_INT(pwstr+wcslen(rgComment[4])-pwOld);
        pwstr = wcsstr(&pwOld[ichspBegin], rgComment[5]);// pwstr points just after the spacing info block
        if (pwstr == NULL) // didn't find the substring
        {
            // copy the entire comment as is
            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin],
                    (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
            ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;
            goto LCommentEnd;
        }
        ichCopy = SAFE_PTR_DIFF_TO_INT(pwstr-pwOld) + wcslen(rgComment[5]); // actual comment begins at ichCopy
        ichspEnd = SAFE_PTR_DIFF_TO_INT(pwstr-pwOld);
        ASSERT(ichspEnd >= ichspBegin);
        while (ichspBegin < ichspEnd)
        {
            switch(pwOld[ichspBegin])
            {
            case chCommentSp:
                pwNew[ichNewCur++] = ' ';
                break;
            case chCommentTab:
                pwNew[ichNewCur++] = '\t';
                break;
            case chCommentEOL:
                pwNew[ichNewCur++] = '\r';
                pwNew[ichNewCur++] = '\n';
                break;
            case ',':
                ASSERT(FALSE);
                break;
            }
            ichspBegin++;
        }
        // now pre comment spacing is restored
        

        pwNew[ichNewCur++] = '<';
        pwNew[ichNewCur++] = '!';
        pwNew[ichNewCur++] = '-';
        pwNew[ichNewCur++] = '-';

        // part 2 - copy the comment and apply spacing
        // from pTokArray[iCommentStart+1].token,ibTokMIn, look for rgComment[4]
        // thats where we keep our spacing info. Exclude this stuff while copying the comment
        ichspBegin = pTokArray[iCommentStart+1].token.ibTokMin + 2/*for --*/ + wcslen(rgComment[3]);
        // locate rgComment[4] that will be somewhere in iCommentStart'th token
        pwstr = wcsstr(&pwOld[ichspBegin], rgComment[4]);// pwstr points just after the spacing info block
        if (pwstr == NULL) // didn't find the substring
        {
            // copy the entire comment as is
            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin],
                    (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
            ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;
            goto LCommentEnd;
        }
        ichspEnd = SAFE_PTR_DIFF_TO_INT(pwstr - pwOld);
        ASSERT(ichspEnd >= ichspBegin);

        while (ichspBegin < ichspEnd)
        {
            switch(pwOld[ichspBegin])
            {
            case chCommentSp:
                pwNew[ichNewCur++] = ' ';
                break;
            case chCommentTab:
                pwNew[ichNewCur++] = '\t';
                break;
            case chCommentEOL:
                pwNew[ichNewCur++] = '\r';
                pwNew[ichNewCur++] = '\n';
                break;
            case ',':
                while (    pwOld[ichCopy] == ' '    || pwOld[ichCopy] == '\t'
                        || pwOld[ichCopy] == '\r'   || pwOld[ichCopy] == '\n'
                        )
                {
                    if (ichCopy >= (int)(pTokArray[iCommentStart+1].token.ibTokMac-2)) // we are done with copying
                        goto LCommentEnd;
                    ichCopy++;
                }
                while (    pwOld[ichCopy] != ' '    && pwOld[ichCopy] != '\t'
                        && pwOld[ichCopy] != '\r'   && pwOld[ichCopy] != '\n'
                        )
                {
                    if (ichCopy >= (int)(pTokArray[iCommentStart+1].token.ibTokMac-2)) // we are done with copying
                        goto LCommentEnd;
                    pwNew[ichNewCur++] = pwOld[ichCopy++];
                }
                break;
            }
            ichspBegin++;
        }

LCommentEnd:
        // part 3 - copy the end of comment
        pwNew[ichNewCur++] = '-';
        pwNew[ichNewCur++] = '-';
        pwNew[ichNewCur++] = '>';

        // set iArray & ichBeginCopy for next run
        ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;
        iArray = iCommentEnd + 1;
    }

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

//LRetOnly:
    return;

} /* fnRestoreObject()*/


void 
CTriEditParse::fnSaveSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    INT ichEnd, ichBegin;
    LPWSTR pwNew = *ppwNew;
    INT iArraySav = iArray;
    LPCWSTR rgSpaceTags[] =
    {
        L" DESIGNTIMESP=",
        L" DESIGNTIMESP1=",
        L" designtimesp=",
    };
    INT iArrayElem = -1;
    INT iArrayMatch, iArrayPrevTag;
    INT ichEndMatch, ichBeginMatch, ichEndPrev, ichBeginPrev, ichEndNext, ichBeginNext, ichEndTag, ichBeginTag;
    WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?
    UINT cbNeed;
    int cchURL = 0;
    int ichURL = 0;

    //  {-1, TokTag_START, tokTag, TokTag_CLOSE, -1, tokClsIgnore, fnSaveSpace},

    ASSERT(dwFlags &dwPreserveSourceCode);

    // special cases where we don't need to save spacing, because Trident doesn't muck with 
    // the spacing in these cases. If this changes in future, remove these cases.
    // If this case is removed, then make sure that fnSaveObject() changes accordingly
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_OBJECT)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an OBJECT tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // trident munges custom attributes inside STYLE tag, so DESIGNTIMESP gets out of place
    // so lets not save any spacing info for TokElem_STYLE
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_STYLE)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an STYLE tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // trident overwrites PARAM tags, so we can skip saving spacing info
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_PARAM)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an PARAM tag
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we should skip saving for <applet>
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (   pTokArray[iArray+1].token.tok == TokElem_APPLET
            )
            && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an APPLET tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // we special case textarea tags, so we should skip saving spacing info
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_TEXTAREA)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is TEXTAREA tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // we special case A/IMG/LINK tags with Relative URLs ONLY, so we should skip saving spacing info
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (   pTokArray[iArray+1].token.tok == TokElem_A
            || pTokArray[iArray+1].token.tok == TokElem_IMG
            || pTokArray[iArray+1].token.tok == TokElem_LINK
            )
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        && (FURLNeedSpecialHandling(pTokArray, iArray, pwOld, (int)ptep->m_cMaxToken, &ichURL, &cchURL))
        )
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // step 1
    // look for > that matches with <. we already are at ft.tokBegin2 i.e. <
    ASSERT(pTokArray[iArray].token.tok == TokTag_START);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ichBeginTag = pTokArray[iArray].token.ibTokMac;
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (pTokArray[iArray].token.tok == ft.tokEnd && pTokArray[iArray].token.tokClass == tokTag) // ft.tokEnd2 is -1
            break;
        if (pTokArray[iArray].token.tokClass == tokElem)
            iArrayElem = iArray;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find >
    {
        goto LRet;
    }
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE); // found >
    ASSERT(pTokArray[iArray].token.tokClass == tokTag); // found >
    ichEndTag = ichBegin = pTokArray[iArray].token.ibTokMin;
    ichEnd = pTokArray[iArray].token.ibTokMac;

    // step 2
    // look for > before iArraySav. Boundary case will be for the first < in the document
    // save the spacing info
    ASSERT(pTokArray[iArraySav].token.tok == TokTag_START);
    ASSERT(pTokArray[iArraySav].token.tokClass == tokTag);
    ichEndPrev = pTokArray[iArraySav].token.ibTokMin;
    ichBeginPrev = ichEndPrev-1;
    // look for previous TokTag_CLOSE
    // if the tag ending tag, ichBeginPrev becomes ibTokMac of '>' tag
    // if the tag is starting tag, ichBeginPrev becomes ibTokMac+(white space just after that tag)
    iArrayPrevTag = iArraySav; // this is TokTag_START
    while (iArrayPrevTag >= 0)
    {
        if (       (   pTokArray[iArrayPrevTag].token.tokClass == tokTag 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_CLOSE
                    )
                || (   pTokArray[iArrayPrevTag].token.tokClass == tokSSS 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_SSSCLOSE
                    )/* VID6 - bug 22787 */
                )
        {
            break;
        }
        iArrayPrevTag--;
    }
    if (iArrayPrevTag < 0) // handle error case
    {
        // leave the old behaviour as is for V1
        while (ichBeginPrev >= 0)
        {
            if (   pwOld[ichBeginPrev] != ' '
                && pwOld[ichBeginPrev] != '\r'
                && pwOld[ichBeginPrev] != '\n'
                && pwOld[ichBeginPrev] != '\t'
                )
                break;
            ichBeginPrev--;
        }
        goto LGotEndNext;
    }
    ichBeginPrev = pTokArray[iArrayPrevTag].token.ibTokMac - 1;

LGotEndNext:
    if (ichBeginPrev < 0)
        ichBeginPrev = 0;
    else
        ichBeginPrev++;


    // step 3
    // look for TokTag_START after iArray(which currently is TokTag_CLOSE)
    // save spacing info
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    //iArrayNextStart = iArray;
    ichBeginNext = pTokArray[iArray].token.ibTokMac;
    ASSERT(ichBeginNext == ichEnd);
    ichEndNext = ichBeginNext;
    while (ichEndNext < (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
    {
        if (   pwOld[ichEndNext] != ' '
            && pwOld[ichEndNext] != '\r'
            && pwOld[ichEndNext] != '\n'
            && pwOld[ichEndNext] != '\t'
            )
            break;
        ichEndNext++;
    }

    if (ichEndNext >= (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
        ichEndNext = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac;

    // step 4
    // if iArrayElem != -1, look for pTokArray[iArrayElem].iNextprev. If its not -1, set iArrayMatch
    // look for previous TokTag_START/TokTag_END. look for previous TokTag_CLOSE
    // save spacing info
    if (iArrayElem == -1) // this can happen if we have incomplete HTML
    {
        ichEndMatch = ichBeginMatch = 0;
        goto LSkipMatchCalc;
    }
    iArrayMatch = pTokArray[iArrayElem].iNextprev;
    if (iArrayMatch != -1) // match was set while tokenizing
    {
        ichBeginMatch = ichEndMatch = 0; //init
        ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
        ASSERT(pTokArray[iArray].token.tokClass == tokTag);
        while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
        {
            if (   pTokArray[iArrayMatch].token.tokClass == tokTag
                && (   pTokArray[iArrayMatch].token.tok == TokTag_START
                    || pTokArray[iArrayMatch].token.tok == TokTag_END
                    )
                )
                break;
            iArrayMatch--;
        }
        if (iArrayMatch > iArray) // did find '</' or '<' after the current tag
        {
            ichEndMatch = pTokArray[iArrayMatch].token.ibTokMin;
            ichBeginMatch = ichEndMatch; // init
            // look for '>' and set ichBeginMatch
            while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
            {
                if (   (   pTokArray[iArrayMatch].token.tokClass == tokTag
                        && pTokArray[iArrayMatch].token.tok == TokTag_CLOSE
                        )
                    || (   pTokArray[iArrayMatch].token.tokClass == tokSSS
                        && pTokArray[iArrayMatch].token.tok == TokTag_SSSCLOSE
                        )/* VID6 - bug 22787 */
                    )
                    break;
                iArrayMatch--;
            }
            if (iArrayMatch >= iArray) // they may very well be the same
            {
                ichBeginMatch = pTokArray[iArrayMatch].token.ibTokMac;
                ASSERT(ichBeginMatch <= ichEndMatch);
                ASSERT(ichBeginMatch >= ichEnd);
            }
        }
    }
    else
    {
        // don't bother saving any info from here
        ichEndMatch = ichBeginMatch = 0;
    }
LSkipMatchCalc:
    if (ichEndPrev > ichBeginPrev)
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichBeginPrev);
    else
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichEndPrev);

    if (ichEndTag > ichBeginTag)
    {
        INT ichBeginTagSav = ichBeginTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichBeginTag);
        // iArray'th token is TokTag_CLOSE & iArraySav is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArraySav, iArray, ichEndTag, &ichBeginTagSav);
    }
    else
    {
        INT ichEndTagSav = ichEndTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichEndTag);
        // iArray'th token is TokTag_CLOSE & iArraySav is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArraySav, iArray, ichEndTagSav, &ichEndTagSav);
    }

    if (ichEndNext > ichBeginNext)
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichBeginNext);
    else
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichEndNext);

    if (ichEndMatch > ichBeginMatch)
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichBeginMatch);
    else
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichEndMatch);



    // realloc if needed
    cbNeed = (ichNewCur+ichBegin-ichBeginCopy+3*wcslen(rgSpaceTags[0])+(ichEnd-ichBegin))*sizeof(WCHAR);
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LErrorRet;
    // ichBeginCopy is a position in pwOld and
    // ichNewCur is a position in pwNew
    // copy from ichBeginCopy to >
    ASSERT((INT)(ichBegin-ichBeginCopy) >= 0);
    if ((INT)(ichBegin-ichBeginCopy) > 0)
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(pwOld+ichBeginCopy),
                (ichBegin-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichBegin-ichBeginCopy);
    }
    ichBeginCopy = ichEnd; // make it ready for next copy

    // BUG 15389 - Ideal fix will be to save the exact tag and restore it when we switch back,
    // but it will be a bigger change at this point, So we simply look at first character of the tag.
    // If it is uppercase, write DESIGNTIMESP, else write designtimesp
    // ASSUMPTION is that Trident doesn't change the case of unknown attribute & so far its TRUE.
    // ASSUMPTION is that we don't have extra spaces between '<' & the tag name.
    ASSERT(wcslen(rgSpaceTags[0]) == wcslen(rgSpaceTags[2]));
    if (iswupper(pwOld[pTokArray[iArraySav+1].token.ibTokMin]) != 0) // upper case
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[0]),
                (wcslen(rgSpaceTags[0]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[0]);
    }
    else
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[2]),
                (wcslen(rgSpaceTags[2]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[2]);
    }

    (WCHAR)_itow(ptep->m_ispInfoBlock+ptep->m_ispInfoBase, szIndex, 10);
    ptep->m_ispInfoBlock++;

    ASSERT(wcslen(szIndex) < sizeof(szIndex));
    ASSERT(sizeof(szIndex) == cchspBlockMax*sizeof(WCHAR));
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(szIndex),
            wcslen(szIndex)*sizeof(WCHAR));
    ichNewCur += wcslen(szIndex);


    // if (m_ispInfoIn == 0), then we have the last block of SPINFO, lets save it here
    if (ptep->m_ispInfoIn == 0)
    {
        ASSERT(FALSE);
        // realloc if needed
        cbNeed = (ichNewCur+ichBegin-ichBeginCopy+2*wcslen(rgSpaceTags[1]))*sizeof(WCHAR);
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[1]),
                (wcslen(rgSpaceTags[1]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[1]);

        *(WCHAR *)(pwNew+ichNewCur) = 'Z'; // ptep->m_ispInfoIn;
        ichNewCur++;
    }

    ASSERT((INT)(ichEnd-ichBegin) > 0);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+ichBegin),
            (ichEnd-ichBegin)*sizeof(WCHAR));
    ichNewCur += (ichEnd-ichBegin);

    // restore iArray
    iArray = iArraySav+1;

LErrorRet:
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = (UINT)iArray;
} /* fnSaveSpace() */


void
CTriEditParse::fnRestoreSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    UINT ichBegin, ichspInfoEndtagEnd;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
        L"DESIGNTIMESP1",
    };
    INT iArraySav = iArray;
    WORD *pspInfoEnd, *pspInfoOrder;
    INT cchwspInfo; // spInfo block size in wide chars
    INT cchRange; // number of char for which this spInfo was saved
    BOOL fMatch = FALSE;
    BOOL fMatchLast = FALSE;
    INT cchtok, cchtag, itoktagStart, ichtoktagStart, iArrayValue, index;
    WCHAR szIndex[cchspBlockMax];
    INT cwOrderInfo = 0;
    UINT cbNeed;
    INT ichNewCurSav = -1; // init to -1 so that we will know when its set.
    int ichNewCurAtIndex0 = -1; // we need to adjust the saved ichNewCur because it gets invalidated
                                // as soon as the tag moves as a result of restoring pre-tag spaces.
    
    ASSERT(dwFlags & dwPreserveSourceCode);

    // take care of the matching end token's spacing
    if (       pTokArray[iArray].token.tok == ft.tokBegin2
            && pTokArray[iArray].token.tokClass == tokTag
            )
    {
        ASSERT(ft.tokBegin2 == TokTag_END);
        fnRestoreSpaceEnd(  ptep, pwOld, ppwNew, pcchNew, phgNew, pTokArray, piArrayStart, 
                            ft, pcHtml, pichNewCur, pichBeginCopy, dwFlags);
        goto LRetOnly;

    }

    // we already are at (token.tok == tokSpace), which may be DESIGNTIMESPx
    ASSERT(pTokArray[iArray].token.tok == 0);
    ASSERT(pTokArray[iArray].token.tokClass == tokSpace);
    cchtok = pTokArray[iArray].token.ibTokMac - pTokArray[iArray].token.ibTokMin;
    cchtag = wcslen(rgSpaceTags[0]);
    if (cchtag == cchtok)
    {
        if (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iArray].token.ibTokMin], cchtag))
        {
            fMatch = TRUE;// match
        }
        else
            goto LNoMatch;
    }
    else if (cchtag+1 == cchtok)
    {
        if (0 == _wcsnicmp(rgSpaceTags[1], &pwOld[pTokArray[iArray].token.ibTokMin], cchtag+1))
        {
            fMatchLast = TRUE;// match
        }
        else
            goto LNoMatch;
    }
    else
    {
LNoMatch:
        iArray = iArraySav + 1;
        goto LRet;
    }

    ASSERT(fMatch || fMatchLast); // one of them has to be TRUE
    // found DESIGNTIMESPx. Now, go backwords and look for ft.tokBegin
    itoktagStart = iArray;
    ASSERT(ft.tokBegin == TokTag_START);
    while (itoktagStart >= 0)
    {
        if (       pTokArray[itoktagStart].token.tok == ft.tokBegin
                && pTokArray[itoktagStart].token.tokClass == tokTag
                )
        {
            break;
        }
        itoktagStart--;
    }
    if (itoktagStart < 0) // didn't find '<' before DESIGNTIMESPx
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // found '<' before DESIGNTIMESPx
    // the spacing info saved was for the portion of the document before the '<'
    ASSERT(pTokArray[itoktagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[itoktagStart].token.tokClass == tokTag);
    // we already know that iArray'th token is DESIGNTIMESPx, so get past the '=' that follows it
    // ASSUMPTION - the value of attribute DESIGNTIMESPx will NOT get munged by Trident.
    // NOTE - the above assumption is correct for this release of Trident
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '=')
        {
            ASSERT(pTokArray[iArray].token.tokClass == tokOp);
            break;
        }
        else if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>') // gone too far
            goto LSkip1;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find = after DESIGNTIMESPx
    {
LSkip1:
        iArray = iArraySav + 1;
        goto LRet;
    }
    iArrayValue = -1;
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (iArrayValue == -1)
            && (   (pTokArray[iArray].token.tokClass == tokValue)
                || (pTokArray[iArray].token.tokClass == tokString)
                )
            )
            iArrayValue = iArray;
        else if (      pTokArray[iArray].token.tok == TokTag_CLOSE
                    && pTokArray[iArray].token.tokClass == tokTag
                    )
        {
            ASSERT(*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>');
            break;
        }
        iArray++;
    }
    if (iArrayValue == -1 || iArray >= (int)ptep->m_cMaxToken) // didn't find tokValue after DESIGNTIMESPx
    {
        // BUG 9040
        //if (iArray >= (int)ptep->m_cMaxToken && iArrayValue != -1)
        //{
            // SOLUTION 1
            // overwrite the stuff from pwOld[pTokArray[iArraySav].token.ibTokMin]
            // to pwOld[pTokArray[iArrayValue].token.ibTokMac - 1]
            // SOLUTION 2
            // look for DESIGNTIMESP from pwOld[pTokArray[itokTagStart].token.ibTokMac - 1]
            // to pwOld[pTokArray[iArray].token.ibTokMac - 1] and overwrite all of those 
            // strings with spaces. We could NULL those and do the blts, but why bother
            // when the html isn't valid! 

            // make sure that all DESIGNTIMESPs are stripped off if we encountered this error case
        //}
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we know that 4 blocks of info was saved for each DESIGNTIMESPx attribute
    // before tag, within tag, after tag, before matching end-tag
    // even if no info was saved, the block will still exist with 2 words (size,# of char)
    ichspInfoEndtagEnd = pTokArray[iArray].token.ibTokMac;

    // first copy the document till DESIGNTIMESPx
    // skip DESIGNTIMESPx and its value and set ichBeginCopy to be after that

    // NOTE - token before iArraySav'th one should be tokSpace with lenght 1 
    // and with a value of chSpace (unless Trident has modified it). If thats TRUE,
    // we should skip that too, because we added it when we put in DESIGNTIMESPx.
    
    // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
    // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
    // and Trident would have inserted EOL. If thats not the case, we will ignore it.
    if (   (iArraySav-1 > 0) /* validation */
        && (    (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 1)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    )
            ||  (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 3)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+1] == '\r')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+2] == '\n')
                    )
                )
        )
    {
        ichBegin = pTokArray[iArraySav-1].token.ibTokMin;
    }
    else
        ichBegin = pTokArray[iArraySav].token.ibTokMin;
    ASSERT(ichBegin >= ichBeginCopy);

    cbNeed = (ichNewCur+(ichBegin-ichBeginCopy))*sizeof(WCHAR) + cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // BUG 15389 - look at the case of DESIGNTIMESP & convert the tag into upper/lower case...
    //memcpy(   (BYTE *)(pwNew+ichNewCur),
    //      (BYTE *)(pwOld+ichBeginCopy),
    //      (ichBegin-ichBeginCopy)*sizeof(WCHAR));
    //ichNewCur += (ichBegin-ichBeginCopy);
    if (ichBegin >= ichBeginCopy )
    {
        // step 1 - copy from ichBeginCopy to '<' of the current tag
        if ((int)(pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+ichBeginCopy),
                    (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy);
            ichNewCurSav = ichNewCur+1; // used as a peg to get preceding tokTag_START i.e. '<'
        }
        // step 2 - convert current tag into upper/lower case & copy it
        if (ichBeginCopy < pTokArray[itoktagStart+1].token.ibTokMin)
        {
            ASSERT((int)(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin) > 0);
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMin),
                    (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)*sizeof(WCHAR));
            if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
            {
                // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                _wcsupr(&pwNew[ichNewCur]);
            }
            else
            {
                // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                _wcslwr(&pwNew[ichNewCur]);
            }
            ichNewCur += (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin);
        }
        else // this tag is alreay been copied
        {
            // hack
            if (pTokArray[itoktagStart+1].token.ibTokMac == ichBeginCopy) // means we are just past the current tag
            {
                if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                    _wcsupr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
                else
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                    _wcslwr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
            }
        }
        // step 3 - copy from after the tag (which is at ichtoktagStart+1) to ichBegin
        if ((int)(ichBegin-pTokArray[itoktagStart+1].token.ibTokMac) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMac),
                    (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac)*sizeof(WCHAR));
            ichNewCur += (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac);
        }
    }
    // set ichBeginCopy
    ichBeginCopy = ichspInfoEndtagEnd; // make it ready for next copy

    // copy the rest of the tag (skipping DESIGNTIMESPx = value)
    ASSERT((INT)(ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac) >= 0);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMac),
            (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac)*sizeof(WCHAR));
    ichNewCur += (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
    
    memset((BYTE *)szIndex, 0, sizeof(szIndex));
    // check if the value has quotes around it and don't copy them to szIndex
    if (   pwOld[pTokArray[iArrayValue].token.ibTokMin] == '"'
        && pwOld[pTokArray[iArrayValue].token.ibTokMac-1] == '"'
        )
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin+1),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin-2)*sizeof(WCHAR));
    }
    else
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin)*sizeof(WCHAR));
    }
    ptep->m_ispInfoBlock = _wtoi(szIndex);
    ptep->m_ispInfoBlock -= ptep->m_ispInfoBase;
    if (ptep->m_ispInfoBlock < 0)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // NOTE - we can cache this info in a link list at the begining
    // get to the ptep->m_ispInfoBlock'th block from ptep->m_pspInfoOutStart
    ASSERT(ptep->m_cchspInfoTotal >= 0);
    pspInfoEnd = ptep->m_pspInfoOutStart + ptep->m_cchspInfoTotal;
    ptep->m_pspInfoOut = ptep->m_pspInfoOutStart;
    for (index = 0; index < ptep->m_ispInfoBlock; index++)
    {
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before <
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // between <>
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // Order Info
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // after >
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before matching </

        // we somehow have gone beyond the data that was saved for spacing
        if (ptep->m_pspInfoOut >= pspInfoEnd)
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    }

    // get the Order Info
    pspInfoOrder = ptep->m_pspInfoOut;
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing before '<'
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing between '<>'
    // now pspInfoOrder is at correct place
    cwOrderInfo = *(WORD *)pspInfoOrder++;
    ASSERT(cwOrderInfo >= 1);
    // process this info
    if (cwOrderInfo > 1) // means that we saved some info
    {
        INT cchNewCopy;

        cchNewCopy = (ichBegin-pTokArray[itoktagStart].token.ibTokMin) + (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
        ptep->FRestoreOrder(pwNew, pwOld, pspInfoOrder, &ichNewCur, cwOrderInfo, pTokArray, itoktagStart, iArray, iArraySav, iArrayValue, cchNewCopy, phgNew);
    }
    ichtoktagStart = ichNewCur; // init
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    for (index = 0; index < 4; index++)
    {
        BOOL fLookback = FALSE;

        cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
        cchRange = *(WORD *)ptep->m_pspInfoOut++;
        if (cchwspInfo == 2) // we didn't save any spacing info
        {
            if (index == 0) // special case BUG 8741
            {
                // Note that we didn't save anything before this tag. which means that
                // we had '>' or some text immediately before the < tag. 
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '<')
                    {
                        ichtoktagStart--;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart >= 0)
                {
                    int cws = 0;
                    int ichtagStart = ichtoktagStart;

                    // remove any such white space trident inserts.
                    while (    pwNew[ichtoktagStart] == ' '
                            || pwNew[ichtoktagStart] == '\r'
                            || pwNew[ichtoktagStart] == '\n'
                            || pwNew[ichtoktagStart] == '\t')
                    {
                        cws++;
                        ichtoktagStart--;
                    }
                    if (cws > 0)
                    {
                        ASSERT((int)(ichNewCur-ichtagStart-1) >= 0);
                        //ichtokTagStart now points to either '>' or a non-whitespace char
                        memmove((BYTE*)&pwNew[ichtoktagStart+1],
                                (BYTE*)&pwNew[ichtoktagStart+1+cws],
                                (ichNewCur-ichtagStart-1)*sizeof(WCHAR));
                        ichNewCur -= cws;
                    }
                } // if (ichtoktagStart >= 0)
            } // if (index == 0)
            goto LNext;
        }

        // note that ichtoktagStart is a position in pwNew
        switch (index)
        {
        case 0: // before < of the tag
            fLookback = TRUE;
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            ichNewCurAtIndex0 = ichNewCur; // lets save the ichNewCur before we restore pre-tag spacing
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart--;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2;
                continue;
            }
            break;
        case 1: // between <> of the tag
            fLookback = FALSE;
            // NOTE - we can assume that in 'case 0' we had put ichtoktagStart is just before '<'
            // so that we can avoid this while loop. but what if we skipped case '0'?

            // adjust ichNewCurSav to reflect the pre-tag spacing so that it doesn't become invalid
            // we may need to adjust it in ichNewCur-ichNewCurAtIndex0 < 0 case as well, but lets not
            // add code at this stage that we don't have to. (4/30/98)
            if (ichNewCurAtIndex0 != -1 && ichNewCurSav != -1 && ichNewCur-ichNewCurAtIndex0 > 0)
                ichNewCurSav = ichNewCurSav + (ichNewCur-ichNewCurAtIndex0);
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart++;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // for spacing info
                ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // for Order Info
                continue;
            }
            break;
        case 2: // after > of the tag
            // Observation - Trident messes up the document in following way - 
            //    If we had an EOL after '>' which is followed by HTML text, 
            //    trident eats that EOL
            // BUT
            //    If we had a space/tab before that EOL trident doesn't eat it!!!
            // so I have added the conditions
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')

            // here is the deal - If the next tone happens to be plain text, there is no danger
            // of applying the same format twice.( i.e. once for after '>' and the next time for
            // before the next '<')
            if (   (iArray+1 < (INT)ptep->m_cMaxToken) /*validation*/
                && pTokArray[iArray+1].token.tok == 0
                && pTokArray[iArray+1].token.tokClass == tokIDENTIFIER
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\r')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')
                )
            {
                fLookback = FALSE;
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '>')
                    {
                        ichtoktagStart++;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
                {
                    ptep->m_pspInfoOut += cchwspInfo-2;
                    continue;
                }
            }
            else
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
                continue;
            }
            break;
        case 3: // before matching end tag
            ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
            continue;
            //fLookback = TRUE;
            //ichtoktagStart = 0; // we ignore this info
            break;
        }

        if (index == 3) // skip this info, because we have not reached matching end tag yet
            ptep->m_pspInfoOut += cchwspInfo-2;
        //else if (index == 0)
        //  ptep->FRestoreSpacingInHTML(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);
        else
            ptep->FRestoreSpacing(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);

LNext:
        if (index == 1) // we have already processed this info, just move the pointer ahead
            ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut;

    } // for ()

    iArray++; // go part > of this tag for the next round

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = (UINT)iArray;

LRetOnly:
    return;

} /* fnRestoreSpace() */




void
CTriEditParse::fnRestoreSpaceEnd(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
    };
    INT iArraySav = iArray;
    INT iArrayMatch, i, itoktagStart;
    BOOL fMatch = FALSE;
    INT cchtag;
    WORD *pspInfoEnd;
    INT cchwspInfo; // spInfo block size in wide chars
    INT cchRange; // number of char for which this spInfo was saved
    INT ichtoktagStart, iArrayValue, index;
    WCHAR szIndex[cchspBlockMax];
    int iDSP = -1;
    UINT cbNeed;
    
    ASSERT(dwFlags & dwPreserveSourceCode);

    // take care of the matching end token's spacing
    ASSERT(pTokArray[iArray].token.tok == ft.tokBegin2);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ASSERT(ft.tokBegin2 == TokTag_END);

    // We already are at (token.tok == TokTag_END)
    // Get the tokElem after the current token and find its matching begin token
    // If we don't find the begin token, we don't have spacing for this end token, return
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (pTokArray[iArray].token.tokClass == tokElem) // generally this will be the next token
            break;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    
    if (pTokArray[iArray].iNextprev == -1)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    iArrayMatch = pTokArray[iArray].iNextprev;
    // look for 'DESIGNTIMESP' from iArrayMatch till the next '>'
    // If we don't find 'DESIGNTIMESP', this is an error case, return.
    i = iArrayMatch;
    cchtag = wcslen(rgSpaceTags[0]);
    while (    i < iArraySav /* boundary case */
            && (   pTokArray[i].token.tokClass != tokTag
                || pTokArray[i].token.tok != TokTag_CLOSE
                )
            )
    {

        if (   pTokArray[i].token.tokClass == tokSpace
            && cchtag == (int)(pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin)
            && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[i].token.ibTokMin], cchtag))
            )
        {
            fMatch = TRUE;
            break;
        }
        i++;
    }
    if (!fMatch)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // at this point pTokArray[i] is 'DESIGNTIMESP'
    iDSP = i; // save for later use when we convert the tokElem to upper/lower case
    itoktagStart = i;
    while (itoktagStart >= 0)
    {
        if (       pTokArray[itoktagStart].token.tok == ft.tokBegin
                && pTokArray[itoktagStart].token.tokClass == tokTag
                )
        {
            break;
        }
        itoktagStart--;
    }
    if (itoktagStart < 0) // didn't find '<' before DESIGNTIMESPx
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // found '<' before DESIGNTIMESPx
    ASSERT(pTokArray[itoktagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[itoktagStart].token.tokClass == tokTag);
    // we already know that i'th token is DESIGNTIMESPx, so get past the '=' that follows it
    // ASSUMPTION - the value of attribute DESIGNTIMESPx will NOT get munged by Trident.
    // NOTE - The above assumption is correct for this Trident release.
    while (i < iArraySav)
    {
        if (*(WORD *)(pwOld+pTokArray[i].token.ibTokMin) == '=')
        {
            ASSERT(pTokArray[i].token.tokClass == tokOp);
            break;
        }
        else if (*(WORD *)(pwOld+pTokArray[i].token.ibTokMin) == '>') // gone too far
            goto LSkip1;
        i++;
    }
    if (i >= iArraySav) // didn't find = after DESIGNTIMESPx
    {
LSkip1:
        iArray = iArraySav + 1;
        goto LRet;
    }
    iArrayValue = -1;
    while (i < iArraySav)
    {
		if (   (iArrayValue == -1)
			&& (   pTokArray[i].token.tokClass == tokValue 
				|| pTokArray[i].token.tokClass == tokString)
			)
            iArrayValue = i;
        else if (      pTokArray[i].token.tok == TokTag_CLOSE
                    && pTokArray[i].token.tokClass == tokTag
                    )
        {
            ASSERT(*(WORD *)(pwOld+pTokArray[i].token.ibTokMin) == '>');
            break;
        }
        i++;
    }
    if (iArrayValue == -1)/*BUG 7951 || i >= iArraySav)*/ // didn't find tokValue after DESIGNTIMESPx
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we know that iArraySav'th token is '</', copy till that token and apply spacing
    cbNeed = (ichNewCur+pTokArray[iArraySav].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    ASSERT(pTokArray[iArraySav].token.ibTokMin >= ichBeginCopy);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+ichBeginCopy),
            (pTokArray[iArraySav].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += (pTokArray[iArraySav].token.ibTokMin-ichBeginCopy);
    ichtoktagStart = ichNewCur-1;
    
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+pTokArray[iArraySav].token.ibTokMin),
            (pTokArray[iArraySav].token.ibTokMac-pTokArray[iArraySav].token.ibTokMin)*sizeof(WCHAR));
    ichNewCur += (pTokArray[iArraySav].token.ibTokMac-pTokArray[iArraySav].token.ibTokMin);
    ichBeginCopy = pTokArray[iArraySav].token.ibTokMac; // make it ready for next copy

    // we know that 4 blocks of info was saved for each DESIGNTIMESPx attribute
    // before tag, within tag, after tag, before matching end-tag
    // even if no info was saved, the block will still exist with 2 words (size,# of char)
    memset((BYTE *)szIndex, 0, sizeof(szIndex));
	// check if the value has quotes around it and don't copy them to szIndex
	if (   pwOld[pTokArray[iArrayValue].token.ibTokMin] == '"'
		&& pwOld[pTokArray[iArrayValue].token.ibTokMac-1] == '"'
		)
	{
		memcpy( (BYTE *)szIndex,
				(BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin+1),
				(pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin-2)*sizeof(WCHAR));
	}
	else
	{
		memcpy( (BYTE *)szIndex,
				(BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin),
				(pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin)*sizeof(WCHAR));
	}
    ptep->m_ispInfoBlock = _wtoi(szIndex);
    ptep->m_ispInfoBlock -= ptep->m_ispInfoBase;
    if (ptep->m_ispInfoBlock < 0)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // NOTE - we can cache this info in a link list at the begining
    // get to the ptep->m_ispInfoBlock'th block from ptep->m_pspInfoOutStart
    ASSERT(ptep->m_cchspInfoTotal >= 0);
    pspInfoEnd = ptep->m_pspInfoOutStart + ptep->m_cchspInfoTotal;
    ptep->m_pspInfoOut = ptep->m_pspInfoOutStart;
    for (index = 0; index < ptep->m_ispInfoBlock; index++)
    {
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before <
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // between <>
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // Order Info
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // after >
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before matching </

        // we somehow have gone beyond the data that was saved for spacing
        if (ptep->m_pspInfoOut >= pspInfoEnd)
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    }

    // skip pre '<' data
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    ptep->m_pspInfoOut += cchwspInfo - 2;
    // skip '<...>' data
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    ptep->m_pspInfoOut += cchwspInfo - 2;
    ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // for Order Info
    // skip post '>' data
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    ptep->m_pspInfoOut += cchwspInfo - 2;
    // now we are at matching </...> of the token
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    if (cchwspInfo == 2) // we didn't save any spacing info
    {
        // here is a little story. If we didn't save any spacing information for this end
        // tag, that means we didn't have any white-space before it. Lets go back from
        // pwNew[ichNewCur-1] and remove the white-space.
        // NOTE - Ideally, this needs to get folded into FRestoreSpacing, but 
        // FRestorespacing gets called from other places too so this is late in
        // the game to that kind of change.
        // we know that pwNew[ichNewCur-1] is '/' & pwNew[ichNewCur-2] is '<'
        if ((int)(ichNewCur-2) >= 0 && pwNew[ichNewCur-1] == '/' && pwNew[ichNewCur-2] == '<')
        {
            ichNewCur = ichNewCur - 3;
            while (    (   pwNew[ichNewCur] == ' '  || pwNew[ichNewCur] == '\t'
                        || pwNew[ichNewCur] == '\r' || pwNew[ichNewCur] == '\n'
                        )
                    )
            {
                ichNewCur--;
            }
            ichNewCur++; // compensate, ichNewCur points to non-white space characher
            pwNew[ichNewCur++] = '<';
            pwNew[ichNewCur++] = '/';
        }

        iArray = iArraySav + 1;
        goto LRestoreCaseAndRet;
    }
    ptep->FRestoreSpacing(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, /*fLookback*/TRUE, /*index*/3);

    iArray = iArraySav + 1; // go past '</', we have already copied the doc till this point
    
LRestoreCaseAndRet:
    // BUG 15389 - we need to start copying the tokElem as well with proper upper/lower case
    // we should combine this memcpy with the above ones, but I want to keep the
    // code separate
    if (pTokArray[iArray].token.tokClass == tokElem && iDSP != -1)
    {
        // except for </BODY> tag because we need to restore post-end-BODY stuff in fnRestoreFtr()
        if (pTokArray[iArray].token.tok != TokElem_BODY && pTokArray[iArray].token.tok != tokElem)
        {
        cbNeed = (ichNewCur+pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(pwOld+pTokArray[iArray].token.ibTokMin),
                (pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin)*sizeof(WCHAR));
        // convert into upper/lower case appropriately to match the opening tag's case
        if (iswupper(pwOld[pTokArray[iDSP].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
        {
            _wcsupr(&pwNew[ichNewCur]);
        }
        else
        {
            _wcslwr(&pwNew[ichNewCur]);
        }
        ichNewCur += (pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin);

        // set ichBeginCopy & iArray for next run
        ichBeginCopy = pTokArray[iArray].token.ibTokMac;
        iArray++;
        }
    }




LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = (UINT)iArray;

//LRetOnly:
    return;

} /* fnRestoreSpaceEnd() */



void
CTriEditParse::fnSaveTbody(CTriEditParse* /*ptep*/,
          LPWSTR /*pwOld*/, LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*hBeginCopy*/,
          DWORD /*dwFlags*/)
{
    UINT iArray = *piArrayStart;

    ASSERT(pTokArray[iArray].token.tok == TokElem_TBODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    iArray++;

    *piArrayStart = iArray;
    return;

} /* fnSaveTbody() */

void
CTriEditParse::fnRestoreTbody(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    // see if we have DESIGNTIMESP as an attribute for <TBODY>. If we do, ignore this one because
    // we know it existed before going to trident. Else, remove this one because trident inserted 
    // it.
    // NOTE - If Trident inserted it, we also have to remove the matching </TBODY>

    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT ichTBodyStart, ichTBodyEnd;
    BOOL fFoundDSP = FALSE;
    INT iArraySav = iArray;
    INT cchtag;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
    };
    BOOL fBeginTBody = FALSE;
    UINT cbNeed;

    ichTBodyStart = pTokArray[iArray].token.ibTokMin; // init
    ASSERT(pTokArray[iArray].token.tok == TokElem_TBODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    // look for '<' or '</' before TBODY
    while (iArray >= 0) // generally, it will be the previous token, but just in case...
    {
        if (   (pTokArray[iArray].token.tok == TokTag_START)
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            fBeginTBody = TRUE;
            ichTBodyStart = pTokArray[iArray].token.ibTokMin;
            break;
        }
        else if (      (pTokArray[iArray].token.tok == TokTag_END)
                    && (pTokArray[iArray].token.tokClass == tokTag)
                    )
        {
            if (ptep->m_iTBodyMax > 0) // we have atleast one saved <TBODY>
            {
                ASSERT(ptep->m_pTBodyStack != NULL);
                if (ptep->m_pTBodyStack[ptep->m_iTBodyMax-1] == (UINT)iArraySav) // this was the matching </TBODY>
                {
                    // we want to remove it
                    ichTBodyStart = pTokArray[iArray].token.ibTokMin;
                    break;
                }
                else // this one doesn't match with the saved one, so quit
                {
                    iArray = iArraySav + 1;
                    goto LRet;
                }
            }
            else // we don't have any saved <TBODY>, so quit
            {
                iArray = iArraySav + 1;
                goto LRet;
            }
        }
        iArray--;
    } // while ()
    if (iArray < 0) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    ichTBodyEnd = pTokArray[iArraySav].token.ibTokMac; // init
    iArray = iArraySav;
    ASSERT(pTokArray[iArray].token.tok == TokElem_TBODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    cchtag = wcslen(rgSpaceTags[0]);
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[iArray].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            ichTBodyEnd = pTokArray[iArray].token.ibTokMac;
            break;
        }
        // look for DESIGNTIMESP
        if (   (pTokArray[iArray].token.tok == 0)
            && (pTokArray[iArray].token.tokClass == tokSpace)
            && (cchtag == (INT)(pTokArray[iArray].token.ibTokMac - pTokArray[iArray].token.ibTokMin))
            && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iArray].token.ibTokMin], cchtag))
            )
        {
            fFoundDSP = TRUE; 
            break;
        }
        else if (pTokArray[iArray].token.tokClass == tokAttr)
        {
            // look for any attribute before '>'
            // Even if Trident inserted this <TBODY>, the user may have set some TBODY properties
            // If thats the case, we don't want to remove this <TBODY>
            fFoundDSP = TRUE; // fake it to be fFoundDSP
            break;
        }

        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    if (fFoundDSP)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we found '>', but didn't find DESIGNTIMESP
    // At this point we are sure that this was added by trident
    ASSERT(iArray < (int)ptep->m_cMaxToken);
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ASSERT(!fFoundDSP);

    if (fBeginTBody)
    {
        // copy till ichTBodyStart, skip from ichTBodyStart till ichTBodyEnd, set ichBeginCopy accordingly
        // get the iArray for the matching </TBODY> and save it on stack
        
        if (ptep->m_pTBodyStack == NULL) // first time, so allocate it
        {
            ASSERT(ptep->m_hgTBodyStack == NULL);
            ptep->m_hgTBodyStack = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cTBodyInit*sizeof(UINT));
            if (ptep->m_hgTBodyStack == NULL)
            {
                // not enough memory, so lets keep all <TBODY> elements
                goto LRet;
            }
            ptep->m_pTBodyStack = (UINT *)GlobalLock(ptep->m_hgTBodyStack);
            ASSERT(ptep->m_pTBodyStack != NULL);
            ptep->m_iMaxTBody = cTBodyInit;
            ptep->m_iTBodyMax = 0;
        }
        else
        {
            ASSERT(ptep->m_hgTBodyStack != NULL);
            // see if we need to realloc it
            if (ptep->m_iTBodyMax+1 >= ptep->m_iMaxTBody)
            {
                HRESULT hrRet;

                hrRet = ReallocBuffer(  &ptep->m_hgTBodyStack,
                                        (ptep->m_iMaxTBody+cTBodyInit)*sizeof(UINT),
                                        GMEM_MOVEABLE|GMEM_ZEROINIT);
                if (hrRet == E_OUTOFMEMORY)
                    goto LRet;
                ptep->m_iMaxTBody += cTBodyInit;
                ptep->m_pTBodyStack = (UINT *)GlobalLock(ptep->m_hgTBodyStack);
                ASSERT(ptep->m_pTBodyStack != NULL);
            }
        }
        if (pTokArray[iArraySav].iNextprev != -1) // handle error case
        {
            ptep->m_pTBodyStack[ptep->m_iTBodyMax] = pTokArray[iArraySav].iNextprev;
            ptep->m_iTBodyMax++;
        }
        else
        {
            // don't delete this <TBODY> and its matching </TBODY>
            goto LRet;
        }
    }
    else
    {
        // if this was a matching </TBODY> for the one trident inserted, we don't copy it to pwNew
        ASSERT(ptep->m_iTBodyMax > 0);
        // look in ptep->m_pTBodyStack and see if you find this iArray
        ASSERT(ptep->m_pTBodyStack[ptep->m_iTBodyMax-1] == (UINT)iArraySav);
        // assume that we never can have tangled TBODY's
        ptep->m_pTBodyStack[ptep->m_iTBodyMax-1] = 0;
        ptep->m_iTBodyMax--;
    }
    // now do the actual skipping
    cbNeed = (ichNewCur+ichTBodyStart-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    if ((INT)(ichTBodyStart-ichBeginCopy) > 0)
    {
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichTBodyStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichTBodyStart-ichBeginCopy);
    }
    ichBeginCopy = ichTBodyEnd;
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    iArray++; // iArray was at '>' of TBODY, so set it to be the next one. 


LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnRestoreTbody() */

void
CTriEditParse::fnSaveApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    int indexAppletEnd, ichAppletEnd, indexAppletTagClose, index;
    UINT cbNeed;
    int cchURL = 0;
    int ichURL = 0;
    LPCWSTR rgDspURL[] = 
    {
        L" DESIGNTIMEURL=",
        L" DESIGNTIMEURL2=",
    };

    indexAppletTagClose = -1;
    ASSERT(pTokArray[iArray].token.tok == TokElem_APPLET);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    // get the ending '>' of the </applet>
    indexAppletEnd = pTokArray[iArraySav].iNextprev;
    if (indexAppletEnd == -1) // error case, we don't have matching </applet> tag
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // validity check - the matching tag is not '</applet>'
    if (indexAppletEnd-1 >= 0 && pTokArray[indexAppletEnd-1].token.tok != TokTag_END)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // get ending '>' of the <applet ...>
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[iArray].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            indexAppletTagClose = iArray;
            break;
        }
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // invalid case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    iArray = indexAppletEnd;
    while (iArray < (int)ptep->m_cMaxToken) // generally, it will be the next token, but just in case...
    {
        if (   (pTokArray[iArray].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            break;
        }
        iArray++;
    }
    indexAppletEnd = iArray;
    ichAppletEnd = pTokArray[indexAppletEnd].token.ibTokMac;

    // step 1 - if the applet needs special URL processing, act on it.
    if (!FURLNeedSpecialHandling(pTokArray, iArraySav, pwOld, (int)ptep->m_cMaxToken, &ichURL, &cchURL))
        goto LStep2;
    else // save the URL as an attribute value of DESIGNTIMEURL
    {
        // make sure we have enough space in pwNew.
        // copy from ichBeginCopy till current token's ending '>'.
        // index points to APPLET
        index = indexAppletTagClose;
        cbNeed = (ichNewCur+pTokArray[index].token.ibTokMin-ichBeginCopy+wcslen(rgDspURL[0])+cchURL+3/*eq,quotes*/)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
        // index points to '>'
        if ((int) (pTokArray[index].token.ibTokMin-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[index].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[index].token.ibTokMin-ichBeginCopy);
        }

        if (cchURL != 0)
        {
            // add 'DESIGNTIMEURL=' followed by the current URL as quoted value
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)rgDspURL[0], 
                    wcslen(rgDspURL[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgDspURL[0]);

            pwNew[ichNewCur++] = '"';
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichURL], 
                    cchURL*sizeof(WCHAR));
            ichNewCur += cchURL;
            pwNew[ichNewCur++] = '"';
        }

        if (dwFlags & dwPreserveSourceCode)
            ptep->SaveSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, iArraySav-1, &ichNewCur);

        // add ending '>' and set ichBeginCopy, iArray, ichNewCur appropriately
        memcpy( (BYTE *)&pwNew[ichNewCur], 
                (BYTE *)&pwOld[pTokArray[index].token.ibTokMin], 
                (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin)*sizeof(WCHAR));
        ichNewCur += (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin);

        iArray = index+1; // redundant, but makes code more understandable
        ichBeginCopy = pTokArray[index].token.ibTokMac;
    }

    // step2 - copy the applet
LStep2:
    cbNeed = (ichNewCur+ichAppletEnd-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    memcpy( (BYTE *)(&pwNew[ichNewCur]),
            (BYTE *)(&pwOld[ichBeginCopy]),
            (ichAppletEnd-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += (ichAppletEnd-ichBeginCopy);
    ichBeginCopy = ichAppletEnd;
    iArray = indexAppletEnd;

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnSaveApplet() */


void
CTriEditParse::fnRestoreApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
        L"DESIGNTIMEURL",
    };
    int indexAppletStart, ichAppletStart, indexAppletEnd, i, indexAppletTagClose;
    UINT cchtag, cbNeed, cchURL;
    int indexDSU = -1; // init
    int indexDSUEnd = -1; // init
    int indexDSP = -1; // init
    int indexDSPEnd = -1; // init
    int indexCB = -1; // init (CODEBASE index)
    int indexCBEnd = -1; // init (CODEBASE index)
    BOOL fCodeBaseFound = FALSE;

    ASSERT(pTokArray[iArray].token.tok == TokElem_APPLET);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    indexAppletTagClose = iArraySav;
    // get the matching </applet> tag
    indexAppletEnd = pTokArray[iArraySav].iNextprev;
    if (indexAppletEnd == -1) // error case, we don't have matching </applet> tag
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // get ending '>' of the <applet ...>
    i = iArraySav;
    while (i < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[i].token.tokClass == tokTag)
            )
        {
            indexAppletTagClose = i;
            break;
        }
        i++;
    }
    if (i >= (int)ptep->m_cMaxToken) // invalid case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // look for DESIGNTIMESP & DESIGNTIMEURL inside the <applet> tag
    cchtag = wcslen(rgSpaceTags[0]);
    cchURL = wcslen(rgSpaceTags[1]);
    for (i = iArraySav; i < indexAppletTagClose; i++)
    {
        if (       pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchtag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[i].token.ibTokMin], cchtag))
                )
        {
            indexDSP = i;
        }
        else if (      pTokArray[i].token.tok == 0
                    && pTokArray[i].token.tokClass == tokSpace
                    && cchURL == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                    && (0 == _wcsnicmp(rgSpaceTags[1], &pwOld[pTokArray[i].token.ibTokMin], cchURL))
                    )
        {
            indexDSU = i;
        }
        else if (      pTokArray[i].token.tok == TokAttrib_CODEBASE
                    && pTokArray[i].token.tokClass == tokAttr
                    )
        {
            indexCB = i;
        }
    } // for ()

    // look for '<' before APPLET
    i = iArraySav;
    while (i >= 0) // generally, it will be the previous token, but just in case...
    {
        if (   (pTokArray[i].token.tok == TokTag_START)
            && (pTokArray[i].token.tokClass == tokTag)
            )
        {
            break;
        }
        i--;
    } // while ()
    if (i < 0) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    indexAppletStart = i;
    ichAppletStart = pTokArray[indexAppletStart].token.ibTokMin;

    // look for '>' of </applet>
    i = indexAppletEnd;
    while (i < (int)ptep->m_cMaxToken) // generally, it will be the next token, but just in case...
    {
        if (   (pTokArray[i].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[i].token.tokClass == tokTag)
            )
        {
            break;
        }
        i++;
    }
    if (i >= (int)ptep->m_cMaxToken) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    indexAppletEnd = i;

    // step 1 - copy till indexAppletStart
    cbNeed = (ichNewCur+ichAppletStart-ichBeginCopy+3*(indexAppletEnd-indexAppletStart))*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    memcpy( (BYTE *)(&pwNew[ichNewCur]),
            (BYTE *)(&pwOld[ichBeginCopy]),
            (ichAppletStart-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += (ichAppletStart-ichBeginCopy);

    // step 2 - if (indexDSU != -1), we need to go and restore the CODEBASE atrtribute
    // if (indexDSU == -1), we need to remove CODEBASE attribute
    ASSERT(indexAppletTagClose != -1);

    // get indexDSUEnd
    if (indexDSU != -1)
    {
        i = indexDSU;
        while (i < indexAppletTagClose)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSUEnd = i;
                break;
            }
            i++;
        }
        if (indexDSUEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    } /* if (indexDSU != -1)*/
    
    // get indexDSPEnd
    if (indexDSP != -1)
    {
        i = indexDSP;
        indexDSPEnd = -1;
        while (i < indexAppletTagClose)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSPEnd = i;
                break;
            }
            i++;
        }
        if (indexDSPEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    } /* if (indexDSP != -1) */

    // get indexCBEnd
    if (indexCB != -1)
    {
        i = indexCB;
        while (i < indexAppletTagClose)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexCBEnd = i;
                break;
            }
            i++;
        }
        if (indexCBEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    } /* if (indexCB != -1) */

    // if we didn't find DESIGNTIMEURL attribute, that means CODEBASE attribute
    // should be removed because it didn't exist in source view
    i = indexAppletStart;
    while (i <= indexAppletTagClose)
    {
        if (   (indexDSU != -1)
            && (i >= indexDSU && i <= indexDSUEnd)
            )
        {
            i++; // don't copy this token
        }
        else if (      (indexDSP != -1)
                    && (i >= indexDSP && i <= indexDSPEnd)
                    )
        {
            i++; // don't copy this token
        }
        else if (      pTokArray[i].token.tok == TokAttrib_CODEBASE
                    && pTokArray[i].token.tokClass == tokAttr
                    && !fCodeBaseFound
                    )
        {
            if (indexDSU == -1) // DESIGNTIMEURL not found, so skip CODEBASE
            {
                ASSERT(i == indexCB);
                i = indexCBEnd+1;
            }
            else
            {
                fCodeBaseFound = TRUE;
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
        }
        else if (      pTokArray[i].token.tok == 0 
                    && pTokArray[i].token.tokClass == tokString || pTokArray[i].token.tokClass == tokValue
                    && fCodeBaseFound
                    )
        {
            int ichURL, ichURLEnd, ichDSURL, ichDSURLEnd;
            // if the url is now absloute and is just an absolute version of 
            // the one at indexDSUEnd, we need to replace it.
            ichURL = (pwOld[pTokArray[i].token.ibTokMin] == '"')
                    ? pTokArray[i].token.ibTokMin+1
                    : pTokArray[i].token.ibTokMin;
            ichURLEnd = (pwOld[pTokArray[i].token.ibTokMac-1] == '"')
                    ? pTokArray[i].token.ibTokMac-1
                    : pTokArray[i].token.ibTokMac;
            if (FIsAbsURL((LPOLESTR)&pwOld[ichURL]))
            {
                WCHAR *pszURL1 = NULL;
                WCHAR *pszURL2 = NULL;
                int ich;

                ichDSURL = (pwOld[pTokArray[indexDSUEnd].token.ibTokMin] == '"')
                        ? pTokArray[indexDSUEnd].token.ibTokMin+1
                        : pTokArray[indexDSUEnd].token.ibTokMin;
                ichDSURLEnd = (pwOld[pTokArray[indexDSUEnd].token.ibTokMac-1] == '"')
                        ? pTokArray[indexDSUEnd].token.ibTokMac-1
                        : pTokArray[indexDSUEnd].token.ibTokMac;

                // just for comparison purposes, don't look at '/' or '\' separators
                // between filenames & directories...
                pszURL1 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                pszURL2 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                if (pszURL1 == NULL || pszURL2 == NULL)
                    goto LResumeCopy;
                memcpy((BYTE *)pszURL1, (BYTE *)&pwOld[ichDSURL], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                memcpy((BYTE *)pszURL2, (BYTE *)&pwOld[ichURLEnd-(ichDSURLEnd-ichDSURL)], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                pszURL1[ichDSURLEnd-ichDSURL] = '\0';
                pszURL2[ichDSURLEnd-ichDSURL] = '\0';
                for (ich = 0; ich < ichDSURLEnd-ichDSURL; ich++)
                {
                    if (pszURL1[ich] == '/')
                        pszURL1[ich] = '\\';
                    if (pszURL2[ich] == '/')
                        pszURL2[ich] = '\\';
                }

                if (0 == _wcsnicmp(pszURL1, pszURL2, ichDSURLEnd-ichDSURL))
                {
                    pwNew[ichNewCur++] = '"';
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[ichDSURL],
                            (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                    ichNewCur += (ichDSURLEnd-ichDSURL);
                    pwNew[ichNewCur++] = '"';
                }
                else // copy it as it is
                {
LResumeCopy:
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                if (pszURL1 != NULL)
                    delete pszURL1;
                if (pszURL2 != NULL)
                    delete pszURL2;
            }
            else // its realtive, simply copy it
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
            }
            i++;
        }
        else // all other tokens
        {
            // ****NOTE - we can actually do pretty printing here 
            // instead of fixing the special cases****

            // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
            // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
            // and Trident would have inserted EOL. If thats not the case, we will ignore it.
            if (   (pTokArray[i].token.tokClass == tokSpace)
                && (pTokArray[i].token.tok == 0)
                && (FIsWhiteSpaceToken(pwOld, pTokArray[i].token.ibTokMin, pTokArray[i].token.ibTokMac))
                )
            {
                if (i != indexDSU-1) // else skip the copy
                    pwNew[ichNewCur++] = ' '; // convert space+\r+\n into space
                i++;
            }
            else
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
        }
    } // while ()

    // we have spacing save dfor this tag, lets restore it
    if (   (indexDSP != -1)
        && (dwFlags & dwPreserveSourceCode)
        ) 
        ptep->RestoreSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, indexDSP, &ichNewCur);

    // step 3 - format all stuff between <applet> ... </applet>
    pwNew[ichNewCur] = '\r';
    ichNewCur++;
    pwNew[ichNewCur] = '\n';
    ichNewCur++;
    pwNew[ichNewCur] = '\t'; // replace this with appropriate alignment
    ichNewCur++;
    for (i = indexAppletTagClose+1; i <= indexAppletEnd; i++)
    {
        // copy the tag
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
        // if its was TokTag_CLOSE, insert EOL
        if (   pTokArray[i].token.tok == TokTag_CLOSE
            && pTokArray[i].token.tokClass == tokTag)
        {
            pwNew[ichNewCur] = '\r';
            ichNewCur++;
            pwNew[ichNewCur] = '\n';
            ichNewCur++;
            pwNew[ichNewCur] = '\t'; // replace this with appropriate alignment
            ichNewCur++;
        }
    } // for ()

    // remember to set iArray appropriately
    iArray = indexAppletEnd + 1;
    ichBeginCopy = pTokArray[indexAppletEnd].token.ibTokMac;

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnRestoreApplet() */

void
CTriEditParse::RestoreSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL* /*phgNew*/,
            TOKSTRUCT *pTokArray, UINT iArray, UINT *pichNewCur)
{
    LPWSTR pwNew = *ppwNew;
    UINT ichNewCur = *pichNewCur;
    UINT iArraySav = iArray;
    UINT ichspInfoEndtagEnd, ichBegin;
    WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?
    WORD *pspInfoEnd, *pspInfoOrder;
    INT cwOrderInfo = 0;
    UINT ichNewCurSav = 0xFFFFFFFF;
    INT cchwspInfo; // spInfo block size in wide chars
    INT cchRange; // number of char for which this spInfo was saved
    INT ichtoktagStart, iArrayValue, index, itoktagStart;
    int ichNewCurAtIndex0 = -1; // we need to adjust the saved ichNewCur because it gets invalidated
                                // as soon as the tag moves as a result of restoring pre-tag spaces.

    itoktagStart = iArray; // init
    // found DESIGNTIMESPx. Now, go backwords and look for TokTag_START
    while (itoktagStart >= 0)
    {
        if (       pTokArray[itoktagStart].token.tok == TokTag_START
                && pTokArray[itoktagStart].token.tokClass == tokTag
                )
        {
            break;
        }
        itoktagStart--;
    }
    if (itoktagStart < 0) // didn't find '<' before DESIGNTIMESPx
        goto LRet;

    // found '<' before DESIGNTIMESPx
    // the spacing info saved was for the portion of the document before the '<'
    ASSERT(pTokArray[itoktagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[itoktagStart].token.tokClass == tokTag);
    // we already know that iArray'th token is DESIGNTIMESPx, so get past the '=' that follows it
    // ASSUMPTION - the value of attribute DESIGNTIMESPx will NOT get munged by Trident.
    // NOTE - the above assumption is correct for this release of Trident
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '=')
        {
            ASSERT(pTokArray[iArray].token.tokClass == tokOp);
            break;
        }
        else if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>') // gone too far
            goto LSkip1;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find = after DESIGNTIMESPx
    {
LSkip1:
        goto LRet;
    }
    iArrayValue = -1; // init
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (iArrayValue == -1)
            && (   (pTokArray[iArray].token.tokClass == tokValue)
                || (pTokArray[iArray].token.tokClass == tokString)
                )
            )
            iArrayValue = iArray;
        else if (      pTokArray[iArray].token.tok == TokTag_CLOSE
                    && pTokArray[iArray].token.tokClass == tokTag
                    )
        {
  