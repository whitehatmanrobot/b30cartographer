      DeletePacketPool((PPACKET_POOL*)(p))

#endif  // NO_POOLS

#define VALIDATE_OBJECT(p, t)

#define LINK_MEMORY_USAGE(p)
#define UNLINK_MEMORY_USAGE(p)
#define UNLINK_STRING_USAGE(p)

#endif  // DBG

//
// Prototypes for memory allocators and pool and object functions
//

PVOID
AllocatePacket(
    IN PPACKET_POOL pPacketPool
    );

VOID
DeallocatePacket(
    IN PPACKET_POOL pPacketPool,
    IN PVOID pPacket
    );

#if defined(NO_POOLS)

#define CREATE_PACKET_POOL_DRIVER(t, s, n)  (PVOID)0x12345678
#define CREATE_PACKET_POOL_ADAPTER(t, s, n) (PVOID)0x12345679
#define CREATE_PACKET_POOL_FILE(t, s, n)    (PVOID)0x1234567A

#define DELETE_PACKET_POOL_DRIVER(p)    *p = NULL
#define DELETE_PACKET_POOL_ADAPTER(p)   *p = NULL
#define DELETE_PACKET_POOL_FILE(p)      *p = NULL

#if defined(BUF_USES_POOL)

#if DBG

#define CREATE_BUFFER_POOL_FILE(t, s, n) \
    CreatePacketPool(&pFileContext->MemoryUsage,\
                    (PVOID)pFileContext,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

#define DELETE_BUFFER_POOL_FILE(p) \
    DeletePacketPool(&pFileContext->MemoryUsage, (PPACKET_POOL*)(p))

#define ALLOCATE_PACKET_DLC_BUF(p)  AllocatePacket(p)
#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocatePacket(pool, p)

#else   // !DBG

#define CREATE_BUFFER_POOL_FILE(t, s, n)    CreatePacketPool((ULONG)(s), (ULONG)(n))
#define DELETE_BUFFER_POOL_FILE(p)  DeletePacketPool((PPACKET_POOL*)(p))
#define ALLOCATE_PACKET_DLC_BUF(p)  ALLOCATE_ZEROMEMORY_FILE(sizeof(DLC_BUFFER_HEADER))
#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  FREE_MEMORY_FILE(p)

#endif  // DBG

#else   // !BUF_USES_POOL

#define CREATE_BUFFER_POOL_FILE(t, s, n)    (PVOID)0x1234567B
#define DELETE_BUFFER_POOL_FILE(p)          *p = NULL
#define ALLOCATE_PACKET_DLC_BUF(p)          AllocateZeroMemory(sizeof(DLC_BUFFER_HEADER))
#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocateMemory(p)

#endif  // BUF_USES_POOL

#if DBG

#define ALLOCATE_PACKET_DLC_PKT(p)  ALLOCATE_ZEROMEMORY_FILE(sizeof(DLC_PACKET))
#define ALLOCATE_PACKET_DLC_OBJ(p)  ALLOCATE_ZEROMEMORY_FILE(sizeof(DLC_OBJECT))
#define ALLOCATE_PACKET_LLC_PKT(p)  ALLOCATE_ZEROMEMORY_ADAPTER(sizeof(UNITED_PACKETS))
#define ALLOCATE_PACKET_LLC_LNK(p)  ALLOCATE_ZEROMEMORY_ADAPTER(sizeof(DATA_LINK) + 32)

#define DEALLOCATE_PACKET_DLC_PKT(pool, p)  FREE_MEMORY_FILE(p)
#define DEALLOCATE_PACKET_DLC_OBJ(pool, p)  FREE_MEMORY_FILE(p)
#define DEALLOCATE_PACKET_LLC_PKT(pool, p)  FREE_MEMORY_ADAPTER(p)
#define DEALLOCATE_PACKET_LLC_LNK(pool, p)  FREE_MEMORY_ADAPTER(p)

#else   // !DBG

#define CREATE_BUFFER_POOL_FILE(t, s, n)    CREATE_PACKET_POOL_FILE(t, s, n)
#define DELETE_BUFFER_POOL_FILE(p)  DELETE_PACKET_POOL_FILE(p)

#define ALLOCATE_PACKET_DLC_BUF(p)  AllocateZeroMemory(sizeof(DLC_BUFFER_HEADER))
#define ALLOCATE_PACKET_DLC_PKT(p)  AllocateZeroMemory(sizeof(DLC_PACKET))
#define ALLOCATE_PACKET_DLC_OBJ(p)  AllocateZeroMemory(sizeof(DLC_OBJECT))
#define ALLOCATE_PACKET_LLC_PKT(p)  AllocateZeroMemory(sizeof(UNITED_PACKETS))
#define ALLOCATE_PACKET_LLC_LNK(p)  AllocateZeroMemory(sizeof(DATA_LINK) + 32)

#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_DLC_PKT(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_DLC_OBJ(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_LLC_PKT(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_LLC_LNK(pool, p)  DeallocateMemory(p)

#endif  // DBG

#else   // !NO_POOLS

#define CREATE_BUFFER_POOL_FILE(t, s, n)    CREATE_PACKET_POOL_FILE(t, s, n)
#define DELETE_BUFFER_POOL_FILE(p)  DELETE_PACKET_POOL_FILE(p)

#define ALLOCATE_PACKET_DLC_BUF(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_DLC_PKT(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_DLC_OBJ(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_LLC_PKT(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_LLC_LNK(p)  AllocatePacket(p)

#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_DLC_PKT(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_DLC_OBJ(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_LLC_PKT(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_LLC_LNK(pool, p)  DeallocatePacket(pool, p)

#endif  // NO_POOLS

#endif  // _LLCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcmain.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcmain.c

Abstract:

    This module implements data link object for NDIS 3.0.
    Data link driver provides 802.2 LLC Class I and II services
    and also interface to send and receive direct network data.
    This module may later be used as general packet router
    for the protocol modules => smaller system overhead, when
    the NDIS packet header is checked only once.  LLC interface
    is also much easier to use than NDIS.

    Its main tasks are:
        - implement simple and realiable LLC Class II
          connection-oriented services for the other drivers
    - provide network independent interface 802.2 interface
    - remove the system overhead of the packet and indication
      routing to all protocol modules
        - provide transmit packet queueing for the protocol drivers
        - provide 802.2 compatible connect, disconnect and close
          services, that calls back, when the transmit queue is
          empty.

    The services provides the module are somewhat extended
    802.2 services, because the protocol engine is a IBM version
    of ISO-HDLC ABM.  LlcDisconnet and LlcConnect primitives
    implements both Request and Confirm  of Connect/Disconnect

    Data link driver does not make any buffering for the data.
    All data buffer except the LLC header and lan header with the
    I-frames must be provided by the calling protocol driver.


    *********************** SPINLOCK RULES *************************

    DataLink driver uses extensively several spin locks to make it
    as re-entrant as possible with multiple processors and to
    minimize unnecessary spin locking calls.
    The main problem with multiple spin locks are the dead locks.
    The spin locks must always be acquired the same order (and
    released in a reverse order):

    This is the order used with DataLink spin locks:

    1. Adapter->ObjectDataBase
        Protects objects from close/delete. This is always locked in
        the receive indication routine.

    2. Link->SpinLock
        Protects the link.  This lock is needed to prevent to upper
        protocol to call the link station, when we are changing it state.
        SendSpinLock cannot protect it, because it must be switched off,
        when the pending commands are executed.  (But could we keep
        SendSpinLock locked, when the transmit commands are completed).
        There will occure a dead lock in any way, if the upper protocol
        is waiting the last transmit to complete before it disconnects
        a link  station.


    3. Adapter->SendSpinLock            // protects queues and packet pools

    ---
    Timer spin locks is used only by timer servives:
    4. TimerSpinLock                    // protects the timer queues

    ****************************************************************

    Contents:
        LlcInitialize
        LlcTerminate

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

//
// This define enables the private DLC function prototypes
// We don't want to export our data types to the dlc layer.
// MIPS compiler doesn't accept hiding of the internal data
// structures by a PVOID in the function prototype.
// i386 will check the type defines
//

#ifndef i386

#define LLC_PUBLIC_NDIS_PROTOTYPES

#endif

#include <llc.h>
#include "dbgmsg.h"

//
// These are the defaults defined in the IBM LAN Architecture reference,
// this may be set by a DLC application, if it want to change the defaults.
//

DLC_LINK_PARAMETERS DefaultParameters = {
    3,      // T1 600 milliseconds (3 * 5 * 40)
    2,      // T2  80 milliseconds (2 * 1 * 40)
    10,     // Ti 25 seconds  ((10 - 5) * 125 * 4)
    127,    // TW: maximum transmit window size
    127,    // RW: The maximum receive window size
    20,     // Nw: number of LPDUs acknowledged, before Ww is incr.)
    5,      // N2: Number of retires allowed (both Polls and I LPDSs)
    0,      // lowest proirity by default
    600     // default for info field length by default
};

KMUTEX NdisAccessMutex;
KSEMAPHORE OpenAdapterSemaphore;

#define LLC_PROTOCOL_NAME   L"DLC"

#ifdef NDIS40
extern ULONG gWaitForAdapter;
#endif // NDIS40


DLC_STATUS
LlcInitialize(
    VOID
    )

/*++

Routine Description:

    The routines initializes the protocol module and
    does the minimal stuff, that must be done in the
    serialized initialization routine.

Arguments:

    None.

Return Value:

    NDIS_STATUS

--*/

{
    NDIS_STATUS Status;
	NDIS_PROTOCOL_CHARACTERISTICS LlcChars;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // We must build a MDL for the XID information used
    // when the link level takes care of XID handling.
    //

    pXidMdl = IoAllocateMdl(&Ieee802Xid,
                            sizeof(Ieee802Xid),
                            FALSE,
                            FALSE,
                            NULL
                            );
    if (pXidMdl == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

#ifdef NDIS40
    //
    // Event to signal all adapters have been bound - OK for LlcOpenAdapter
    // to bind.
    //

    NdisInitializeEvent(&PnPBindsComplete);
    NdisResetEvent(&PnPBindsComplete);
#endif // NDIS40

#if LLC_DBG

    ALLOCATE_SPIN_LOCK(&MemCheckLock);

#endif

    MmBuildMdlForNonPagedPool(pXidMdl);
    LlcInitializeTimerSystem();

    NdisZeroMemory(&LlcChars, sizeof(LlcChars));
	NdisInitUnicodeString(&LlcChars.Name, LLC_PROTOCOL_NAME);

#ifdef NDIS40
	LlcChars.MajorNdisVersion               = 4;
	LlcChars.MinorNdisVersion               = 0;
	LlcChars.OpenAdapterCompleteHandler     = LlcNdisOpenAdapterComplete;
	LlcChars.CloseAdapterCompleteHandler    = LlcNdisCloseComplete;
	LlcChars.SendCompleteHandler            = LlcNdisSendComplete;
	LlcChars.TransferDataCompleteHandler    = LlcNdisTransferDataComplete;
	LlcChars.ResetCompleteHandler           = LlcNdisResetComplete;
	LlcChars.RequestCompleteHandler         = LlcNdisRequestComplete;
	LlcChars.ReceiveHandler                 = LlcNdisReceiveIndication;
	LlcChars.ReceiveCompleteHandler         = LlcNdisReceiveComplete;
	LlcChars.StatusHandler                  = NdisStatusHandler;
	LlcChars.StatusCompleteHandler          = LlcNdisReceiveComplete;
    // DLC supports bind/unbind/pnp, but not unload.
    LlcChars.UnloadHandler                  = NULL;
    LlcChars.PnPEventHandler                = LlcPnPEventHandler;
    LlcChars.BindAdapterHandler             = LlcBindAdapterHandler;
    LlcChars.UnbindAdapterHandler           = LlcUnbindAdapterHandler;

    //
    // Need to get value for waiting on uninitialized adapters.
    //

    if (!NT_SUCCESS(GetAdapterWaitTimeout(&gWaitForAdapter)))
    {
        ASSERT(FALSE);
        gWaitForAdapter = 15; // Default.
    }

    DEBUGMSG(DBG_WARN, (TEXT("WaitForAdapter delay = %d sec\n"), gWaitForAdapter));
    
#else // NDIS40
	LlcChars.MajorNdisVersion = 3;
	LlcChars.MinorNdisVersion = 0;
	LlcChars.OpenAdapterCompleteHandler = LlcNdisOpenAdapterComplete;
	LlcChars.CloseAdapterCompleteHandler = LlcNdisCloseComplete;
	LlcChars.SendCompleteHandler = LlcNdisSendComplete;
	LlcChars.TransferDataCompleteHandler = LlcNdisTransferDataComplete;
	LlcChars.ResetCompleteHandler = LlcNdisResetComplete;
	LlcChars.RequestCompleteHandler = LlcNdisRequestComplete;
	LlcChars.ReceiveHandler = LlcNdisReceiveIndication;
	LlcChars.ReceiveCompleteHandler = LlcNdisReceiveComplete;
	LlcChars.StatusHandler = NdisStatusHandler;
	LlcChars.StatusCompleteHandler = LlcNdisReceiveComplete;
#endif // !NDIS40

	NdisRegisterProtocol(&Status,
                         &LlcProtocolHandle,
                         &LlcChars,
                         sizeof(LlcChars));

    KeInitializeSpinLock(&LlcSpinLock);

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeInitializeMutex(&NdisAccessMutex, 1);

    //
    // We use the OpenAdapterSemaphore in the LlcOpenAdapter function. We really
    // want a mutex, but a mutex causes us problems on a checked build if we
    // make a call into NTOS. In either case, we just need a mechanism to ensure
    // only one thread is creating the ADAPTER_CONTEXT & opening the adapter at
    // NDIS level
    //

    KeInitializeSemaphore(&OpenAdapterSemaphore, 1, 1);

    if (Status != STATUS_SUCCESS) {
        IoFreeMdl(pXidMdl);
    }
    return Status;
}


VOID
LlcTerminate(
    VOID
    )

/*++

Routine Description:

    The routines terminates the LLC protocol module and frees its global
    resources. This assumes all adapter bindings to be closed.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NDIS_STATUS Status;

    ASSUME_IRQL(PASSIVE_LEVEL);

    DEBUGMSG(DBG_INIT, (TEXT("+LlcTerminate()\n")));
    
    LlcTerminateTimerSystem();
#ifdef NDIS40
    CloseAllAdapters();
#endif // NDIS40
    NdisDeregisterProtocol(&Status, LlcProtocolHandle);
    IoFreeMdl(pXidMdl);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llclink.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems Ab

Module Name:

    llclink.c

Abstract:

    The module implements the open, connect and close primitives
    for a link station object. The link stations have also been
    initialized within this module.

    Contents:
        LlcOpenLinkStation
        LlcConnectStation
        InitiateAsyncLinkCommand
        LlcDisconnectStation
        LlcFlowControl
        LinkFlowControl
        SearchLinkAddress
        SetLinkParameters
        CheckLinkParameters
        CopyLinkParameters
        CopyNonZeroBytes
        RunInterlockedStateMachineCommand

Author:

    Antti Saarenheimo (o-anttis) 28-MAY-1991

Revision History:

--*/

#include <llc.h>


DLC_STATUS
LlcOpenLinkStation(
    IN PLLC_SAP pSap,
    IN UCHAR DestinationSap,
    IN PUCHAR pDestinationAddress OPTIONAL,
    IN PUCHAR pReceivedLanHeader OPTIONAL,
    IN PVOID hClientStation,
    OUT PVOID* phLlcHandle
    )

/*++

Routine Description:

    creates a DATA_LINK structure and fills it in. Called either as a result
    of receiving a SABME, or via DLC.OPEN.STATION

    This operation is the same as ACTIVATE_LS primitive in IBM TR Arch. ref.

Arguments:

    pSap                - pointer to SAP
    DestinationSap      - remote SAP number
    pDestinationAddress - remote node address. If this function is being called
                          as a result of receiving a SABME for a new link then
                          this parameter is NULL
    pReceivedLanHeader  - LAN header as received off the wire, containing source
                          and destination adapter addresses, optional source
                          routing and source and destination SAPs
    hClientStation      - handle (address) of LLC client's link station object
    phLlcHandle         - pointer to returned handle (address) to LLC DATA_LINK
                          object

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
                    link station has been opened successfully
        Failure - DLC_STATUS_INVALID_SAP_VALUE
                    the link station already exists or the SAP is really invalid.
                  DLC_NO_MEMORY
                    there was no free preallocated link station

--*/

{
    PDATA_LINK pLink;
    PDATA_LINK* ppLink;
    PADAPTER_CONTEXT pAdapterContext = pSap->Gen.pAdapterContext;
    DLC_STATUS LlcStatus = STATUS_SUCCESS;
    UINT AddressTranslation;

    //
    // We need a temporary buffer to build lan header for link,
    // because user may use different ndis medium from network.
    //

    UCHAR auchTempBuffer[32];

    ASSUME_IRQL(DISPATCH_LEVEL);

    LlcZeroMem(auchTempBuffer, sizeof(auchTempBuffer));

    if (pSap->Gen.ObjectType != LLC_SAP_OBJECT) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);
    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    pLink = (PDATA_LINK)ALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool);

    if (pLink == NULL) {
        LlcStatus = DLC_STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    //
    // This reference keeps the object alive, until it is dereferenced
    // in the delete.
    //

    ReferenceObject(pLink);

    //
    // LLC driver have two different address formats:
    //
    // 1. External format of the binding (ethernet or token-ring,
    //    DLC driver uses always token-ring format, the ethernet
    //    support is compiled in conditionally.
    //
    // 2. Internal send format (always the actual lan type,
    //    ethernet, dix or tokenring).  The user provides link
    //    address in its own mode and we must build the actual
    //    lan link header from it.
    //

    if (pDestinationAddress != NULL) {

        //
        // link created by DLC.CONNECT.STATION
        //

        AddressTranslation = pSap->Gen.pLlcBinding->AddressTranslation;
        LlcBuildAddress(pSap->Gen.pLlcBinding->NdisMedium,
                        pDestinationAddress,
                        NULL,
                        auchTempBuffer
                        );
    } else {

        //
        // link created by incoming SABME
        //

        pLink->Flags |= DLC_ACTIVE_REMOTE_CONNECT_REQUEST;
        AddressTranslation = pAdapterContext->AddressTranslationMode;
        LlcBuildAddressFromLanHeader(pAdapterContext->NdisMedium,
                                     pReceivedLanHeader,
                                     auchTempBuffer
                                     );
    }

    //
    // We want to use always DIX lan headers in the token-ring case
    //

    if (AddressTranslation == LLC_SEND_802_5_TO_802_3) {
        AddressTranslation = LLC_SEND_802_5_TO_DIX;
    } else if (AddressTranslation == LLC_SEND_802_3_TO_802_3) {
        AddressTranslation = LLC_SEND_802_3_TO_DIX;
    }

    //
    // Now we can build the actual network header for the sending
    // (this same routine build lan header also for all
    // other packet types)
    //

    pLink->cbLanHeaderLength = CopyLanHeader(AddressTranslation,
                                             auchTempBuffer,
                                             pAdapterContext->NodeAddress,
                                             pLink->auchLanHeader,
                                             pAdapterContext->ConfigInfo.SwapAddressBits
                                             );

    //
    // We always build a DIX header but it is only used when the Ethernet type
    // is actually DIX
    //

    if (pAdapterContext->NdisMedium == NdisMedium802_3
    && pSap->Gen.pLlcBinding->EthernetType != LLC_ETHERNET_TYPE_DIX) {
        pLink->cbLanHeaderLength = 14;
    }

    //
    // Save the client handle, but reset and initailize everything else.
    // The link must be ready for any kind extrnal inputs when
    // we will connenct it to the hash table of the link stations.
    // (actually that's not true now, because we init the link to
    // LINK_CLOSED state, but we may change the state machine.
    // It would be a different thing with a 802.2 state machine)
    //

    pLink->Gen.ObjectType = LLC_LINK_OBJECT;

    //
    // RLF 07/22/92. The link state should be DISCONNECTED so that we can
    // accept incoming SABMEs for this SAP/link station. This is also
    // according to IBM LAN Tech. Ref. p. 2-33. It is safe to set the
    // DISCONNECTED state now because we have the send and object database
    // spin locks, so we can't get interrupted by NDIS driver
    //

    //
    // RLF 08/13/92. Ho Hum. This still isn't correct - we must put the link
    // into different states depending on how its being opened - DISCONNECTED
    // if the upper layers are creating the link, or LINK_CLOSED if we're
    // creating the link as a result of receiving a SABME. Use pReceivedLanHeader
    // as a flag: DLC calls this routine with this parameter set to NULL
    //

    ////pLink->State = LINK_CLOSED;
    //pLink->State = DISCONNECTED;

    pLink->State = pReceivedLanHeader ? LINK_CLOSED : DISCONNECTED;

    //
    // RLF 10/01/92. We need some way of knowing that the link station was
    // created by receiving a SABME. We need this to decide what to do with
    // the source routing info in a subsequent DLC.CONNECT.STATION command.
    // This field used to be Reserved
    //

    pLink->RemoteOpen = hClientStation == NULL;

    //
    // RLF 05/09/94
    //
    // We set the framing type to unspecified. This field is only used if the
    // adapter was opened in AUTO mode. It will be set to 802.3 or DIX by the
    // SABME received processing (new link created by remote station) or when
    // the first UA is received in response to the 2 SABMEs we send out (802.3
    // and DIX)
    //

    pLink->FramingType = (ULONG)LLC_SEND_UNSPECIFIED;

    pLink->Gen.hClientHandle = hClientStation;
    pLink->Gen.pAdapterContext = pAdapterContext;
    pLink->pSap = pSap;
    pLink->Gen.pLlcBinding = pSap->Gen.pLlcBinding;

    //
    // Save the node addresses used in link station
    //

    pDestinationAddress = pLink->auchLanHeader;
    if (pAdapterContext->NdisMedium == NdisMedium802_5) {
        pDestinationAddress += 2;
    } else if (pAdapterContext->NdisMedium == NdisMediumFddi) {
        ++pDestinationAddress;
    }

    memcpy(pLink->LinkAddr.Node.auchAddress, pDestinationAddress, 6);

    //
    // RLF 03/24/93
    //
    // if we're talking Ethernet or DIX, we need to report the bit-flipped
    // address at the DLC interface
    //

    SwapMemCpy((BOOLEAN)((AddressTranslation == LLC_SEND_802_3_TO_DIX)
               || (pAdapterContext->NdisMedium == NdisMediumFddi)),
               pLink->DlcStatus.auchRemoteNode,
               pDestinationAddress,
               6
               );

    //
    // Four different local saps: my code would need a cleanup
    // (four bytes doesn't use very much memory on the other hand)
    //

    pLink->LinkAddr.Address.DestSap = pLink->DlcStatus.uchRemoteSap = pLink->Dsap = DestinationSap;
    pLink->LinkAddr.Address.SrcSap = pLink->DlcStatus.uchLocalSap = pLink->Ssap = (UCHAR)pSap->SourceSap;
    pLink->DlcStatus.hLlcLinkStation = (PVOID)pLink;
    pLink->SendQueue.pObject = pLink;
    InitializeListHead(&pLink->SendQueue.ListHead);
    InitializeListHead(&pLink->SentQueue);
    pLink->Flags |= DLC_SEND_DISABLED;

    //
    // The next procedure returns the pointer of the slot for the
    // new link station pointer. The address may be in the
    // hash table or it may be the address of pRigth or pLeft
    // field within another link station structure.
    //

    ppLink = SearchLinkAddress(pAdapterContext, pLink->LinkAddr);

    //
    // this link station must not yet be in the table
    // of active link stations. If its slot is
    // empty, then save the new link station to the
    // list of the active link stations.
    //

    if (*ppLink != NULL) {
        LlcStatus = DLC_STATUS_INVALID_SAP_VALUE;

        DEALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool, pLink);

    } else {
        pLink->Gen.pNext = (PLLC_OBJECT)pSap->pActiveLinks;
        pSap->pActiveLinks = pLink;

        //
        // Set the default link parameters,
        // Note: This creates the timer ticks.  They must
        // be deleted with the terminate timer function,
        // when the link station is closed.
        //

        LlcStatus = SetLinkParameters(pLink, (PUCHAR)&pSap->DefaultParameters);
        if (LlcStatus != STATUS_SUCCESS) {

            //
            // We may have been started T1 and T2 timers.
            //

            TerminateTimer(pAdapterContext, &pLink->T1);
            TerminateTimer(pAdapterContext, &pLink->T2);

            DEALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool, pLink);

        } else {

            //
            // N2 is never initilaized by IBM state machine, when
            // the link is created by a remote connect request.
            // The link can be killed by this combination of state
            // transmitions:
            //  (LINK_OPENED),
            //  (RNR-r => REMOTE_BUSY),
            //  (RR-c => CHECKPOINTING)
            //  (T1 timeout => DISCONNECTED) !!!!!
            //
            // This will fix the bug in IBM state machine:
            //

            pLink->P_Ct = pLink->N2;
            *ppLink = *phLlcHandle = (PVOID)pLink;
            pAdapterContext->ObjectCount++;
        }
    }

ErrorExit:

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    return LlcStatus;
}


VOID
LlcBindLinkStation(
    IN PDATA_LINK pStation,
    IN PVOID hClientHandle
    )
{
    pStation->Gen.hClientHandle = hClientHandle;
}


VOID
LlcConnectStation(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket,
    IN PVOID pSourceRouting OPTIONAL,
    IN PUSHORT pusMaxInformationField
    )

/*++

Routine Description:

    The upper level protocol may call this primitive to initiate
    the connection negotiation with a remote link station,
    to accept the connection request or to reconnect a link station
    that have been disconnected for some reason with a new source
    routing information.
    The command is completed asynchronously and the status
    is returned as an event.

    The primitive is the same as SET_ABME primitive in "IBM TR Architecture
    reference".
    The function implements also CONNECT_REQUEST and CONNECT_RESPONSE
    primitives of IEEE 802.2.

Arguments:

    pStation                - address of link station
    pPacket                 - command completion packet
    pSourceRouting          - optional source routing information. This must
                              be NULL if the source routing information is not
                              used
    pusMaxInformationField  - the maximum data size possible to use with this
                              connection.  The source routing bridges may
                              decrease the maximum information field size.
                              Otherwise the maximum length is used

Return Value:

    None.

--*/

{
    NDIS_MEDIUM NdisMedium = pStation->Gen.pAdapterContext->NdisMedium;

    if (pSourceRouting) {

        //
        // We first read the destination address from the
        // lan header and then extend the source routing
        // field in the LAN header of link.
        //

        if (NdisMedium == NdisMedium802_5) {

            //
            // RLF 10/01/92. If RemoteOpen is TRUE then the link was opened
            // due to receiving a SABME and we ignore the source routing info
            // (we already got it from the SABME packet)
            //

            if (!pStation->RemoteOpen) {
                pStation->cbLanHeaderLength = (UCHAR)LlcBuildAddress(
                                                    NdisMedium,
                                                    &pStation->auchLanHeader[2],
                                                    pSourceRouting,
                                                    pStation->auchLanHeader
                                                    );
            }
        } else {
            pSourceRouting = NULL;
        }
    }
    *pusMaxInformationField = LlcGetMaxInfoField(NdisMedium,
                                                 pStation->Gen.pLlcBinding,
                                                 pStation->auchLanHeader
                                                 );
    pStation->MaxIField = *pusMaxInformationField;
    pStation->Flags &= ~DLC_ACTIVE_REMOTE_CONNECT_REQUEST;

    //
    // Activate the link station at first, the remotely connected
    // link station is already active and in that case the state
    // machine return logical error from ACTIVATE_LS input.
    //

    RunInterlockedStateMachineCommand(pStation, ACTIVATE_LS);
    InitiateAsyncLinkCommand(pStation, pPacket, SET_ABME, LLC_CONNECT_COMPLETION);
}

VOID
InitiateAsyncLinkCommand(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket,
    IN UINT StateMachineCommand,
    IN UINT CompletionCode
    )

/*++

Routine Description:

    Initiates or removes an LLC link. We have a link station in the DISCONNECTED
    state. We are either sending a SABME or DISC

Arguments:

    pLink               - pointer to LLC link station structure ('object')
    pPacket             - pointer to packet to use for transmission
    StateMachineCommand - command given to the state machine
    CompletionCode      - completion command type returned asynchronously

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;
    UINT Status;

    //
    // link will return an error status if it is already connected.
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    AllocateCompletionPacket(pLink, CompletionCode, pPacket);

    //
    // After RunStateMachineCommand
    // the link may be deleted in any time by an NDIS command completion
    // indication (send or receive) => we must not use link after this
    //

    Status = RunStateMachineCommand(pLink, StateMachineCommand);

    //
    // IBM state machine does not stop the send process => we
    // must do it here we will get a system bug check.
    //

    if (StateMachineCommand == SET_ADM) {
        DisableSendProcess(pLink);
    }

    //
    // disconnect or connect commands may fail, because there are
    // not enough memory to allocate packets for them.
    // In that case we must complete the command here with an error code.
    //

    if (Status != STATUS_SUCCESS) {
        QueueCommandCompletion((PLLC_OBJECT)pLink, CompletionCode, Status);
    }

    BackgroundProcessAndUnlock(pAdapterContext);
}


VOID
LlcDisconnectStation(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The primtive initiates the disconnection handshaking. The upper
    protocol must wait LLC_EVENT_DISCONNECTED event before it can close
    the link station. The link station must either be closed or
    reconnected after a disconnection event.  The DLC driver
    disconnects the link only when it is closed.

    This operation is the same as SET_ADM primitive in IBM TR Arch. ref.

Arguments:

    hStation - link station handle.

    hRequestHandle - opaque handle returned when the command completes

Return Value:

    None
        Complete always asynchronously by calling the
        command completion routine.

--*/

{
    //
    // We don't want send yet another DM, if the link station has
    // already disconnected.  We don't modify the state machine,
    // because the state machine should be as orginal as possible.
    //

    if (pLink->State == DISCONNECTED) {
        pPacket->Data.Completion.CompletedCommand = LLC_DISCONNECT_COMPLETION;
        pPacket->Data.Completion.Status = STATUS_SUCCESS;
        pLink->Gen.pLlcBinding->pfCommandComplete(
            pLink->Gen.pLlcBinding->hClientContext,
            pLink->Gen.hClientHandle,
            pPacket
            );
    } else {
        InitiateAsyncLinkCommand(
            pLink,
            pPacket,
            SET_ADM,
            LLC_DISCONNECT_COMPLETION
            );
    }
}


DLC_STATUS
LlcFlowControl(
    IN PLLC_OBJECT pStation,
    IN UCHAR FlowControlState
    )

/*++

Routine Description:

    The primitive sets or resets the local busy state of a single
    link station or all link stations of a sap.
    The routine also maintains the local busy user
    and local busy buffer states, that are returned in link station
    status query, because the IBM state machine support only one buffer
    busy state.


Arguments:

    pStation            - link station handle.
    FlowControlState    - new flow control command bits set for the link station.
                          The parameter is a bit field:
                            0       => Sets LOCAL_BUSY_USER state
                            0x80    => resets LOCAL_BUSY_USER state
                            0x40    => resets LOCAL_BUSY_BUFFER state
                            0xC0    => resets both local busy states

Return Value:

    STATUS_SUCCESS

--*/

{
    PDATA_LINK pLink;
    UINT Status = STATUS_SUCCESS;
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We must prevent any LLC object to be deleted, while we
    // are updating the flow control states
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    if (pStation->Gen.ObjectType != LLC_LINK_OBJECT) {
        if (pStation->Gen.ObjectType == LLC_SAP_OBJECT) {
            for (pLink = pStation->Sap.pActiveLinks;
                 pLink != NULL;
                 pLink = (PDATA_LINK)pLink->Gen.pNext) {
                Status |= LinkFlowControl(pLink, FlowControlState);
            }
        } else {
            Status = DLC_STATUS_INVALID_STATION_ID;
        }
    } else {
        Status = LinkFlowControl((PDATA_LINK)pStation, FlowControlState);
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    BackgroundProcess(pAdapterContext);
    return Status;
}


DLC_STATUS
LinkFlowControl(
    IN PDATA_LINK pLink,
    IN UCHAR FlowControlState
    )

/*++

Routine Description:

    The primitive sets or resets the local busy state for a
    single link.  The routine also maintains the local busy user
    and local busy buffer states.
    This level do not care about the interlocking.
    It is done  on the upper level.

Arguments:

    hStation            - link station handle.
    FlowControlState    - new flow control command bits set for the link station.

Return Value:

    STATUS_SUCCESS

--*/

{
    if ((FlowControlState & 0x80) == 0) {

        //
        // Bit5 is used as an undocumented flag, that sets
        // the link local busy buffer state.  We need this
        // in the DOS DLC emulation.
        //

        ACQUIRE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

        if (FlowControlState == LLC_SET_LOCAL_BUSY_BUFFER) {
            pLink->Flags |= DLC_LOCAL_BUSY_BUFFER;
        } else {
            pLink->Flags |= DLC_LOCAL_BUSY_USER;
        }

        RELEASE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

        return RunInterlockedStateMachineCommand(pLink, ENTER_LCL_Busy);
    } else {

        //
        // Optimize the buffer enabling, because RECEICE for a
        // SAP station should disable any non user busy states of
        // all link stations defined for sap (may take a long
        // time if a sap has very may links)
        //

        if (FlowControlState == LLC_RESET_LOCAL_BUSY_BUFFER) {
            FlowControlState = DLC_LOCAL_BUSY_BUFFER;
        } else {
            FlowControlState = DLC_LOCAL_BUSY_USER;
        }
        if (pLink->Flags & FlowControlState) {

            ACQUIRE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

            pLink->Flags &= ~FlowControlState;

            RELEASE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

            if ((pLink->Flags & (DLC_LOCAL_BUSY_USER | DLC_LOCAL_BUSY_BUFFER)) == 0) {
                return RunInterlockedStateMachineCommand(pLink, EXIT_LCL_Busy);
            }
        } else {
            return DLC_STATUS_LINK_PROTOCOL_ERROR;
        }
    }
    return STATUS_SUCCESS;
}


#if LLC_DBG >= 2

PDATA_LINK
SearchLink(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    )
/*++

Routine Description:

    The routine searches a link from the hash table.
    All links in the same hash node has been saved to a simple
    link list.

    Note: the full link address is actually 61 bits long =
    7 (SSAP) + 7 (DSAP) + 47 (any non-broadcast source address).
    We save the address information into two ULONGs, that are used
    in the actual search. The hash key will be calculated by xoring
    all 8 bytes in the address.

Arguments:

    pAdapterContext - MAC adapter context of data link driver

    LanAddr - the complete 64 bit address of link (48 bit source addr + saps)

Return Value:
    PDATA_LINK - pointer to LLC link object or NULL if not found

--*/
{
    USHORT      usHash;
    PDATA_LINK  pLink;

    // this is a very simple hash algorithm, but result is modified
    // by all bits => it should be good enough for us.
    usHash =
        LanAddr.aus.Raw[0] ^ LanAddr.aus.Raw[1] ^
        LanAddr.aus.Raw[2] ^ LanAddr.aus.Raw[3];

    pLink =
        pAdapterContext->aLinkHash[
            ((((PUCHAR)&usHash)[0] ^ ((PUCHAR)&usHash)[1]) % LINK_HASH_SIZE)];

    //
    //  Search the first matching link in the link list.
    //
    while (pLink != NULL &&
           (pLink->LinkAddr.ul.Low != LanAddr.ul.Low ||
            pLink->LinkAddr.ul.High != LanAddr.ul.High))
    {
        pLink = pLink->pNextNode;
    }
    return pLink;
}
#endif

PDATA_LINK*
SearchLinkAddress(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    )

/*++

Routine Description:

    The routine searches the address of a link pointer in the hash table.
    All links in the same hash node has been saved to a simple
    link list.

    Note: the full link address is actually 61 bits long =
    7 (SSAP) + 7 (DSAP) + 47 (any non-broadcast source address).
    We save the address information into two ULONGs, that are used
    in the actual search. The hash key will be calculated by xoring
    all 8 bytes in the address.

Arguments:

    pAdapterContext - MAC adapter context of data link driver
    LanAddr         - the complete 64 bits address of link (48 bit source addr + saps)

Return Value:

    PDATA_LINK - pointer to LLC link object or NULL if not found

--*/

{
    USHORT usHash;
    PDATA_LINK *ppLink;

    //
    // this is a very simple hash algorithm, but result is modified
    // by all bits => it should be quite good enough
    //

    usHash = LanAddr.aus.Raw[0]
           ^ LanAddr.aus.Raw[1]
           ^ LanAddr.aus.Raw[2]
           ^ LanAddr.aus.Raw[3];

    ppLink = &pAdapterContext->aLinkHash[((((PUCHAR)&usHash)[0]
                                         ^ ((PUCHAR)&usHash)[1])
                                         % LINK_HASH_SIZE)];

    //
    // BUG-BUG-BUG Check, that the C- compliler produces optimal
    // dword compare for this.
    //

    while (*ppLink != NULL
    && ((*ppLink)->LinkAddr.ul.Low != LanAddr.ul.Low
    || (*ppLink)->LinkAddr.ul.High != LanAddr.ul.High)) {
        ppLink = &(*ppLink)->pNextNode;
    }
    return ppLink;
}

DLC_STATUS
SetLinkParameters(
    IN OUT PDATA_LINK pLink,
    IN PUCHAR pNewParameters
    )

/*++

Routine Description:

    Updates new parameters for a link station and reinitializes the
    timers and window counters.

Arguments:

    pLink           - LLC link station object
    pNewParameters  - new parameters set to a link station

Return Value:

    None.

--*/

{
    DLC_STATUS LlcStatus;
    USHORT MaxInfoField;

    CopyLinkParameters((PUCHAR)&pLink->TimerT1,
                       pNewParameters,
                       (PUCHAR)&pLink->pSap->DefaultParameters
                       );

    //
    // The application cannot set bigger information field than
    // supported by adapter and source routing bridges.
    //

    MaxInfoField = LlcGetMaxInfoField(pLink->Gen.pAdapterContext->NdisMedium,
                                      pLink->Gen.pLlcBinding,
                                      pLink->auchLanHeader
                                      );
    if (pLink->MaxIField > MaxInfoField) {
        pLink->MaxIField = MaxInfoField;
    }

    //
    // The initial transmit and receive window size (Ww) has
    // a fixed initial value, because it is dynamic, but we must
    // set  it always smaller than maxout.
    // The maxin value is fixed.  The dynamic management of N3
    // is not really worth of the effort.  By default, when it is
    // set to maximum 127, the sender searches the optimal window
    // size using the pool-bit.
    //

    pLink->N3 = pLink->RW;
    pLink->Ww = 16;          // 8 * 2;
    pLink->MaxOut *= 2;
    pLink->TW = pLink->MaxOut;
    if (pLink->TW < pLink->Ww) {
        pLink->Ww = pLink->TW;
    }
    LlcStatus = InitializeLinkTimers(pLink);
    return LlcStatus;
}

DLC_STATUS
CheckLinkParameters(
    PDLC_LINK_PARAMETERS pParms
    )

/*++

Routine Description:

    Procedure checks the new parameters to be set for a link and returns
    error status if any of them is invalid.

Arguments:

    pLink - LLC link station object

    pNewParameters - new parameters set to a link station

Return Value:

    None

--*/

{
    //
    // These maximum values have been defined in IBM LAN Tech-Ref
    //

    if (pParms->TimerT1 > 10
    || pParms->TimerT2 > 10
    || pParms->TimerTi > 10
    || pParms->MaxOut > 127
    || pParms->MaxIn > 127
    || pParms->TokenRingAccessPriority > 3) {
        return DLC_STATUS_PARMETERS_EXCEEDED_MAX;
    } else {
        return STATUS_SUCCESS;
    }
}

//
// Copies all non-null new link parameters, the default values are
// used when the new values are nul.  Used by SetLinkParameters and
// and SetInfo call of sap station.
//

VOID
CopyLinkParameters(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters
    )
{
    //
    // We must use the default value, if somebody has set nul.
    // All parameters are UCHARs => we can do the check for a byte stream
    //

    CopyNonZeroBytes(pOldParameters,
                     pNewParameters,
                     pDefaultParameters,
                     sizeof(DLC_LINK_PARAMETERS) - sizeof(USHORT)
                     );

    //
    // The information field is the only non-UCHAR value among the
    // link station parameters.
    //

    if (((PDLC_LINK_PARAMETERS)pNewParameters)->MaxInformationField != 0) {
        ((PDLC_LINK_PARAMETERS)pOldParameters)->MaxInformationField =
            ((PDLC_LINK_PARAMETERS)pNewParameters)->MaxInformationField;
    } else if (((PDLC_LINK_PARAMETERS)pOldParameters)->MaxInformationField == 0) {
        ((PDLC_LINK_PARAMETERS)pOldParameters)->MaxInformationField =
            ((PDLC_LINK_PARAMETERS)pDefaultParameters)->MaxInformationField;
    }
}


VOID
CopyNonZeroBytes(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters,
    IN UINT Length
    )

/*++

Routine Description:

    Copies and filters DLC parameter values. If the value is 0, the corresponding
    default is used, else the supplied value

Arguments:

    pOldParameters      - pointer to set of UCHAR values
    pNewParameters      - pointer to array of output values
    pDefaultParameters  - pointer to corresponding default values
    Length              - size of values in bytes (UCHARs)

Return Value:

    None.

--*/

{
    UINT i;

    for (i = 0; i < Length; i++) {
        if (pNewParameters[i] != 0) {
            pOldParameters[i] = pNewParameters[i];
        } else if (pOldParameters[i] == 0) {
            pOldParameters[i] = pDefaultParameters[i];
        }
    }
}


UINT
RunInterlockedStateMachineCommand(
    IN PDATA_LINK pStation,
    IN USHORT Command
    )

/*++

Routine Description:

    Runs the state machine for a link, within the adapter's SendSpinLock (&
    therefore at DPC)

Arguments:

    pStation    - pointer to DATA_LINK structure describing this link station
    Command     - state machine command to be run

Return Value:

    UINT
        Status from RunStateMachineCommand

--*/

{
    UINT Status;

    ACQUIRE_SPIN_LOCK(&pStation->Gen.pAdapterContext->SendSpinLock);

    Status = RunStateMachineCommand(pStation, Command);

    RELEASE_SPIN_LOCK(&pStation->Gen.pAdapterContext->SendSpinLock);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcrcv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcrcv.c

Abstract:

    The module implements the NDIS receive indication handling and
    its routing to upper protocol modules or to link state machines.

    To understand the link related procedure of this module, you should read
    Chapters 11 and 12 in IBM Token-Ring Architecture Reference.

    Contents:
        LlcNdisReceiveIndication
        LlcNdisReceiveComplete
        ProcessType1_Frames
        MakeRcvIndication
        ProcessType2_Frames
        ProcessNewSabme
        LlcTransferData
        LlcNdisTransferDataComplete
        safe_memcpy
        FramingDiscoveryCacheHit

Author:

    Antti Saarenheimo (o-anttis) 18-MAY-1991

Revision History:

    19-Nov-1992 rfirth
        RtlMoveMemory on MIPS, copying from shared TR buffer fails (see rubric
        for safe_memcpy). Changed to private memory mover for this particular
        case

    02-May-1994 rfirth
        Added caching for auto-framing discovery (TEST/XID/SABME-UA)

--*/

#include <dlc.h>
#include <llc.h>

//
// private prototypes...
//

VOID
safe_memcpy(
    OUT PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Length
    );

BOOLEAN
FramingDiscoveryCacheHit(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PBINDING_CONTEXT pBindingContext
    );

#define MIN(a,b)    ((a) < (b) ? (a) : (b))

//
// Local lookup tables to receive the correct frames for a direct station
//

static USHORT ReceiveMasks[LLC_PACKET_MAX] = {
    DLC_RCV_8022_FRAMES,
    DLC_RCV_MAC_FRAMES,
    DLC_RCV_DIX_FRAMES,
    DLC_RCV_OTHER_DESTINATION
};

static UCHAR FrameTypes[LLC_PACKET_MAX] = {
    LLC_DIRECT_8022,
    LLC_DIRECT_MAC,
    LLC_DIRECT_ETHERNET_TYPE,
    (UCHAR)(-1)
};

//
// functions
//


NDIS_STATUS
LlcNdisReceiveIndication(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID pHeadBuf,
    IN UINT cbHeadBuf,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf,
    IN UINT cbPacketSize
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link
    endpoint (That was from SteveJ's NBF, the guy must have a degree in
    the english literature).  This routine is very time critical!

    We first check the frame type (token-ring, 802.3 ethernet or dix),
    then check its data link address (802.2 saps or ethernet type)
    and then we route it to the upper protocol that has opened the
    address, that the frame was sent to.  The link level frames
    are first run through the protocol state machine, and only
    the accepted I- frames are indicated to upper level.

Arguments:

    pAdapterContext     - The Adapter Binding specified at initialization time

    MacReceiveContext   - Note: different from binding handle, mac needs this
                          to support re-entrant receive indications

    pHeadBuf            - pointer to a buffer containing the packet header

    cbHeadBuf           - size of the header

    pLookBuf            - pointer to a buffer containing the negotiated minimum
                          amount of buffer I get to look at, not including header

    cbLookBuf           - the size of the above. May be less than asked for, if
                          that's all there is

    cbPacketSize        - Overall size of the packet, not including the header

Assumes:

    pHeadBuf contains all the header information:

        802.3   6 bytes destination address
                6 bytes source address
                2 bytes big-endian length or packet type (DIX frames)

        802.5   1 byte Access Control
                1 byte Frame Control
                6 bytes destination address
                6 bytes source address
                0-18 bytes source routing

        FDDI    1 byte Frame Control
                6 bytes destination address
                6 bytes source address

    From this we can assume for Token Ring that if cbHeadBuf is >14 (decimal)
    then there IS source routing information in the packet

Return Value:

    NDIS_STATUS:

        NDIS_STATUS_SUCCESS
            Packet accepted

        NDIS_STATUS_NOT_RECOGNIZED
            Packet not recognized by protocol

        NDIS_any_other_thing if I understand, but can't handle.

--*/

{
    LLC_HEADER llcHdr;
    LAN802_ADDRESS Source;
    LAN802_ADDRESS Destination;
    USHORT EthernetTypeOrLength;
    PDATA_LINK pLink;
    PLLC_SAP pSap;
    UCHAR PacketType = LLC_PACKET_8022;
    UCHAR cbLanHeader = 14;
    KIRQL OldIrql;
    UCHAR packet[36];   // enough space for 14-byte header, 18-byte source
                        // routing, 1-byte DSAP, 1-byte SSAP & 2-byte LPDU
    PLLC_OBJECT pObject;
    UINT cbCopy;

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'rvcR');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {                                           
        REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
        return (NDIS_STATUS_ADAPTER_NOT_OPEN);
    }
#endif // NDIS40
    
    UNREFERENCED_PARAMETER(OldIrql);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // we assume at least 13 bytes in the header for all media types. Also
    // assume that the header is no larger than the packet buffer
    //

    ASSERT(cbHeadBuf >= 13);
    ASSERT(cbHeadBuf <= sizeof(packet));

    if ( cbHeadBuf > LLC_MAX_LAN_HEADER ) {
#ifdef NDIS40
        REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
#endif // NDIS40
      return NDIS_STATUS_INVALID_PACKET;
    }
    
    if ( (cbHeadBuf < 13) || (cbHeadBuf > sizeof(packet)) ) {
#ifdef NDIS40
        REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
#endif // NDIS40
      return NDIS_STATUS_INVALID_PACKET;
    }

    LlcMemCpy(packet, pHeadBuf, cbHeadBuf);
    
    cbCopy = MIN(sizeof(packet) - cbHeadBuf, cbLookBuf);
    LlcMemCpy(packet+cbHeadBuf, pLookBuf, cbCopy);

    cbPacketSize += cbHeadBuf;

    //
    // First we do the inital checking for the frame and read
    // the destination and source address and LLC header to
    // DWORD aligned addresses. We avoid any bigendiand/
    // small endiand problematic by forgotting the second high
    // byte in the addresses. The lowest ULONG is used only as
    // an raw data. The bytes can be accesses in any way.
    // The macros read LLC header in a small endiand safe way.
    //

    switch (pAdapterContext->NdisMedium) {
    case NdisMedium802_3:
        LlcMemCpy(Destination.Node.auchAddress, packet, 6);
        LlcMemCpy(Source.Node.auchAddress, packet + 6, 6);

        //
        // The 802.3 LLC frames have always the length field!
        // A 802.3 MAC should discard all Ethernet frames
        // longer than 1500 bytes.
        //
        // X'80D5 is a special ethernet type used when 802.2 frame
        // is encapsulated inside a ethernet type header.
        // (Ethernet type/size is in a reverse order for
        // Intel architecture)
        //

        EthernetTypeOrLength = (USHORT)packet[12] * 256 + (USHORT)packet[13];

        if (EthernetTypeOrLength < 3) {
        #ifdef NDIS40
            REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
        #endif // NDIS40
            return NDIS_STATUS_INVALID_PACKET;
        }

        //
        // If the ethernet length/type field is more than 1500, the
        // frame is dix frame and the length field is a dix ethernet
        // address.  Otherwise the frame is a normal 802.3 frame,
        // that has always LLC header inside it.
        //

        if (EthernetTypeOrLength > 1500) {
            if (EthernetTypeOrLength == 0x80D5) {

                //
                // This is a special 'IBM SNA over ethernet' type,
                // that consists of the length field, 1 byte padding
                // and complete 802.2 LLC header (including the info field).
                //
              
                if ( cbLookBuf < 3 ) {
                #ifdef NDIS40
                    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
                #endif // NDIS40
                  return NDIS_STATUS_NOT_RECOGNIZED;
                }
	      
                cbLanHeader = 17;
                (PUCHAR)pLookBuf += 3;
                cbLookBuf -= 3;

                //
                // The DIX frame size is stored as a big-endian USHORT at offset
                // 15 in the LAN header. Add 17 for the DIX LAN header:
                //
                //      6 bytes destination address
                //      6 bytes source address
                //      2 bytes DIX identifier (0x80D5)
                //      2 byte big-endian information frame length
                //      1 byte pad
                //

                pAdapterContext->cbPacketSize = (USHORT)packet[14] * 256
                                              + (USHORT)packet[15]
                                              + 17;

                if ( pAdapterContext->cbPacketSize > cbPacketSize ) {
                #ifdef NDIS40
                    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
                #endif // NDIS40
                  return NDIS_STATUS_INVALID_PACKET;
                }

                //
                // we now keep an indicator which explicitly defines that this
                // frame has (SNA) DIX framing
                //

                pAdapterContext->IsSnaDixFrame = TRUE;
            } else {

                //
                // This is some other DIX format frame. We don't know what the
                // format of this is (app-specific). We hand the entire packet
                // to the app and let it sort out the format. The frame may be
                // padded in which case the app gets the padding too
                //

                //
                // This is still Ethernet, so cbHeadBuf is 14, even though
                // the actual LAN header is only 12
                //

                PacketType = LLC_PACKET_DIX;
                pAdapterContext->cbPacketSize = cbPacketSize;

                //
                // this frame is not SNA DIX, although it is generically a DIX
                // frame. It will be indicated via a specific DIX SAP, not as
                // a general ethernet frame
                //

                pAdapterContext->IsSnaDixFrame = FALSE;
            }
        } else {

            //
            // Ethernet packets include always the padding,
            // we use the actual size saved in 802.3 header.
            // Include also the header: 6 + 6 + 2
            //

            pAdapterContext->cbPacketSize = EthernetTypeOrLength + 14;

            //
            // this is an 802.3 frame - not DIX at all
            //

            pAdapterContext->IsSnaDixFrame = FALSE;
        }
        break;

    case NdisMedium802_5:
        LlcMemCpy(Destination.Node.auchAddress, packet + 2, 6);
        LlcMemCpy(Source.Node.auchAddress, packet + 8, 6);

        //
        // cbHeadBuf always has the correct LAN header length for Token Ring
        //

        cbLanHeader = (UCHAR)cbHeadBuf;

        pAdapterContext->cbPacketSize = cbPacketSize;

        //
        // bit7 and bit6 in FC byte defines the frame type in token ring.
        // 00 => MAC frame (no LLC), 01 => LLC, 10,11 => reserved.
        // We send all other frames to direct except 01 (LLC)
        //

        if ((packet[1] & 0xC0) == 0x40) {

            //
            // check if we have routing info?
            //

            if (Source.Node.auchAddress[0] & 0x80) {

                //
                // reset the source routing indicator in the
                // source address (it would mess up the link search)
                //

                Source.Node.auchAddress[0] &= 0x7f;

                //
                // Discard all invalid TR frames, they'd corrupt the memory
                //

                if (cbLanHeader > MAX_TR_LAN_HEADER_SIZE) {
                #ifdef NDIS40
                    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
                #endif // NDIS40
                    return NDIS_STATUS_NOT_RECOGNIZED;
                }
            }
        } else {

            //
            // this is a MAC frame destined to direct station
            //

            PacketType = LLC_PACKET_MAC;
        }
        break;

    case NdisMediumFddi:
        LlcMemCpy(Destination.Node.auchAddress, packet + 1, 6);
        LlcMemCpy(Source.Node.auchAddress, packet + 7, 6);

        //
        // cbHeadBuf always has the correct LAN header length for FDDI
        //

        cbLanHeader = (UCHAR)cbHeadBuf;

        pAdapterContext->cbPacketSize = cbPacketSize;

        //
        // bit5 and bit4 in FC byte define the FDDI frame type:
        //
        //      00 => MAC or SMT
        //      01 => LLC
        //      10 => implementer (?)
        //      11 => reserved
        //
        // do same as TR: LLC frames to link/SAP, everything else to direct
        // station
        //

        if ((packet[0] & 0x30) != 0x10) {
            PacketType = LLC_PACKET_MAC;
        }
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif

    }

    pAdapterContext->FrameType = FrameTypes[PacketType];

    //
    // Direct interface gets all non LLC frames and also all LLC frames
    // that were not sent to this station (ie. different destination
    // address field and having no broadcast bit (bit7) set in
    // destination address)).  Ie. promiscuous mode, this data link
    // version does not support promiscuous mode.
    //

    if (Destination.Node.auchAddress[0] & pAdapterContext->IsBroadcast) {
        pAdapterContext->ulBroadcastAddress = Destination.Address.ulLow;
        pAdapterContext->usBroadcastAddress = Destination.Address.usHigh;
    } else {
        pAdapterContext->ulBroadcastAddress = 0;

        //
        // We must also be able to handle the promiscuous packets
        //

        if (Destination.Address.ulLow != pAdapterContext->Adapter.Address.ulLow
        && Destination.Address.usHigh != pAdapterContext->Adapter.Address.usHigh) {
            PacketType = LLC_PACKET_OTHER_DESTINATION;
        }
    }

    //
    // Setup the current receive indication context,
    // there can be only one simultaneous receive indication from
    // a network adapter simultaneously.  We save the necessary
    // data into adapter context to save unnecessary stack operations
    //

    pAdapterContext->NdisRcvStatus = NDIS_STATUS_NOT_RECOGNIZED;
    pAdapterContext->LinkRcvStatus = STATUS_SUCCESS;
    pAdapterContext->pHeadBuf = (PUCHAR)pHeadBuf;
    pAdapterContext->cbHeadBuf = cbHeadBuf;
    pAdapterContext->pLookBuf = (PUCHAR)pLookBuf;
    pAdapterContext->cbLookBuf = cbLookBuf;
    pAdapterContext->RcvLanHeaderLength = (USHORT)cbLanHeader;

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    switch(PacketType) {
    case LLC_PACKET_8022:

        //
        // Read the whole LLC frame (a maybe an extra byte,
        // if this is a U frame).
        // Note: Source and destination saps are swapped in
        //       the received frames
        //

        Source.Address.SrcSap = llcHdr.S.Dsap = packet[cbLanHeader];
        llcHdr.S.Ssap = packet[cbLanHeader + 1];
        Source.Address.DestSap = llcHdr.S.Ssap & (UCHAR)0xfe;
        llcHdr.S.Command = packet[cbLanHeader + 2];
        llcHdr.S.Nr = packet[cbLanHeader + 3];

        if (pSap = pAdapterContext->apSapBindings[llcHdr.U.Dsap]) {

            //
            // The broadcast addresses cannot be destined to link stations
            //

            if (pAdapterContext->ulBroadcastAddress == 0) {
                SEARCH_LINK(pAdapterContext, Source, pLink);
                if (pLink) {

                    //
                    // Process all connection oriented frames, the procedure
                    // will call ProcessType1_Frames, if it finds that the
                    // frame is connectionless.
                    // (We should bring the whole subprocedure here,
                    // because it isn't called elsewhere).
                    //

                    ProcessType2_Frames(pAdapterContext, MacReceiveContext, pLink, llcHdr);
                } else {

                    //
                    // Process all connectionless frames and
                    // SABMEs (connection requests to create a
                    // new link station)
                    //

                    ProcessType1_Frames(pAdapterContext, MacReceiveContext, pSap, llcHdr);
                }
            } else {

                //
                // Process the broadcasts, this cannot have
                // nothing to do with the links
                //

                ProcessType1_Frames(pAdapterContext, MacReceiveContext, pSap, llcHdr);
            }
        } else {

            //
            // The SAP has not been defined, but we must still respond
            // to the TEST and XID commands sent to the NULL SAP.
            // They must be echoed back to the sender
            //

            if ((llcHdr.U.Dsap == LLC_SSAP_NULL)
            && !(llcHdr.U.Ssap & LLC_SSAP_RESPONSE)) {

                //
                // if the remote machine is already in the framing discovery
                // cache but is using the other framing type then discard this
                // TEST/XID command/response
                //

//                if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
//                    break;
//                }

                RespondTestOrXid(pAdapterContext, MacReceiveContext, llcHdr, LLC_SSAP_NULL);
            } else if (pAdapterContext->pDirectStation != NULL) {
                pAdapterContext->usRcvMask = ReceiveMasks[PacketType];
                MakeRcvIndication(pAdapterContext, MacReceiveContext, (PLLC_OBJECT)pAdapterContext->pDirectStation);
            }
        }
        break;

    case LLC_PACKET_DIX:

        //
        // Search the DIX packet from the database
        //

        pObject = (PLLC_OBJECT)pAdapterContext->aDixStations[EthernetTypeOrLength % MAX_DIX_TABLE];
        if (pObject) {
            pAdapterContext->EthernetType = EthernetTypeOrLength;
        } else {
            pObject = (PLLC_OBJECT)pAdapterContext->pDirectStation;
            if (pObject) {
                pAdapterContext->usRcvMask = ReceiveMasks[PacketType];
            }
        }
        if (pObject) {
            MakeRcvIndication(pAdapterContext, MacReceiveContext, pObject);
        }
        break;

    case LLC_PACKET_OTHER_DESTINATION:
    case LLC_PACKET_MAC:

        //
        // discard the return status of the direct stations!
        // The combining of the returns statuses would take too much time
        // NDIS 3.0 isn't actually any more intrested if frame is copied.
        //

        if (pObject = (PLLC_OBJECT)pAdapterContext->pDirectStation) {
            pAdapterContext->usRcvMask = ReceiveMasks[PacketType];
            MakeRcvIndication(pAdapterContext, MacReceiveContext, pObject);
        }
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif

    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
#endif // NDIS40
    
    return pAdapterContext->NdisRcvStatus;
}


VOID
LlcNdisReceiveComplete(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    The routine handles the receive complete indications.  The receive
    completion is made by NDIS when the network hardware have been
    enabled again for receive. In a UP Nt this does mean, that a
    new frame could be received, because we are still on DPC level and
    the receive indication is still in DPC queue to wait us to complete.
    Actually that is OK, because otherwise the stack would overflow,
    if there would be too many received packets.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'pCxR');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {
        // 
        // Must be in the middle of an unbind, otherwise NDIS would have never
        // called the receive handler.
        //

        REFDEL(&pAdapterContext->AdapterRefCnt, 'pCxR');
        return;
    }
#endif // NDIS40

    //
    // seems that 3Com FDDI card is calling this at PASSIVE_LEVEL
    //

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    //
    // Skip the whole background process if there is nothing to do.
    // its the default case, when we are receiving I or UI data.
    //

    if (pAdapterContext->LlcPacketInSendQueue
    || !IsListEmpty(&pAdapterContext->QueueCommands)
    || !IsListEmpty(&pAdapterContext->QueueEvents)) {

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        BackgroundProcessAndUnlock(pAdapterContext);
    }

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'pCxR');
#endif // NDIS40
}


VOID
ProcessType1_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    )

/*++

Routine Description:

    Route UI, TEST or XID frames to the LLC client

Arguments:

    pAdapterContext - The Adapter Binding specified at initialization time.
    pSap            - pointer to the SAP object of data link driver
    LlcHeader       - 802.2 header is copied to stack to make its access fast

Return Value:

    None.

--*/

{
    UCHAR DlcCommand;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Update the counter, we must later check the lost frames
    // (no buffers available for the received UI- frames)
    //

    pSap->Statistics.FramesReceived++;

    //
    // We must use the link station state machine with any other
    // command except UI frames and broadcasts, if the link exists.
    //

    if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_UI) {
        pAdapterContext->FrameType = LLC_UI_FRAME;
        MakeRcvIndication(pAdapterContext, MacReceiveContext, (PLLC_OBJECT)pSap);
        return;

        //
        // Check next if the frame is a XID or TEST frame
        //

    } else if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_TEST) {

        //
        // if the remote machine is already in the framing discovery cache but
        // is using the other framing type then discard this TEST command/response
        //

        //
        // RLF 06/23/94
        //
        // If this is a Response from SAP 0 then don't check the cache. The
        // reason is that currently DLC will automatically generate responses
        // to TESTs and XIDs sent to SAP 0. It will generate 802.3 and DIX
        // irrespective of whether it is configured for DIX or not. The upshot
        // is that a DIX-only machine can currently send an 802.3 response
        // which when we run it through the cache, causes us to assume the other
        // machine is configured for 802.3, not DIX. In communicado.
        // For TEST and XIDs from SAP 0, we have to let the app receive the
        // duplicate and decide what to do with it
        //

        if (LlcHeader.U.Ssap != (LLC_SSAP_NULL | LLC_SSAP_RESPONSE)) {
            if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
                return;
            }
        }
        if (!(LlcHeader.U.Ssap & LLC_SSAP_RESPONSE)) {

            //
            // The Test commands are always echoed back
            // (the Command/Response bit was reset => this is command)
            //

            RespondTestOrXid(pAdapterContext, MacReceiveContext, LlcHeader, pSap->SourceSap);
            pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
            return;
        } else {
            DlcCommand = LLC_TEST_RESPONSE_NOT_FINAL;
        }
    } else if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_XID) {

        //
        // if the remote machine is already in the framing discovery cache but
        // is using the other framing type then discard this XID command/response
        //

        //
        // RLF 06/23/94
        //
        // If this is a Response from SAP 0 then don't check the cache. See above
        //

        if (LlcHeader.U.Ssap != (LLC_SSAP_NULL | LLC_SSAP_RESPONSE)) {
            if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
                return;
            }
        }

        //
        // The upper level protocol may ask data link driver to handle the XIDs
        //

        if (!(LlcHeader.U.Ssap & LLC_SSAP_RESPONSE)) {
            if (pSap->OpenOptions & LLC_HANDLE_XID_COMMANDS) {
                RespondTestOrXid(pAdapterContext, MacReceiveContext, LlcHeader, pSap->SourceSap);
                pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
                return;
            } else {
                DlcCommand = LLC_XID_COMMAND_NOT_POLL;
            }
        } else {
            DlcCommand = LLC_XID_RESPONSE_NOT_FINAL;
        }
    } else if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_SABME) {

        //
        // can't open a connection by broadcasting a SABME
        //

        if (pAdapterContext->ulBroadcastAddress != 0) {
            return;
        }

        //
        // if the remote machine is already in the framing discovery cache but
        // is using the other framing type then discard this SABME
        //

        if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
            return;
        }

        //
        // This is a remote connection request
        //

        ProcessNewSabme(pAdapterContext, pSap, LlcHeader);
        pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
        return;
    } else {
        return;
    }

    if (LlcHeader.auchRawBytes[2] & LLC_U_POLL_FINAL) {
        DlcCommand -= 2;
    }

    pAdapterContext->FrameType = DlcCommand;
    MakeRcvIndication(pAdapterContext, MacReceiveContext, (PLLC_OBJECT)pSap);
}


VOID
MakeRcvIndication(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_OBJECT pStation
    )

/*++

Routine Description:

    Procedure makes a generic receive indication for all frames
    received by SAP or direct stations.

Arguments:

    pAdapterContext - adapter context of the received packet
    pStation        - SAP or DIRECT station

Return Value:

    None.

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // SAP and direct stations can be shared by several link clients
    // (if they have been opened in shared mode).  Route the packet
    // to all clints registered to this SAP or direct station
    // A link station may have only one owner.
    //

    for (; pStation; pStation = (PLLC_OBJECT)pStation->Gen.pNext) {

        //
        // Rotate the direct frames to all direct stations except if
        // the frame has already been captured by the current client.
        // We use 32-bit client context to identify the client,
        // that had already received the frame to its SAP or link station.
        //
        // Broadcasts are indicated only when they match with the
        // group or functional address defined for this binding.
        // The global broadcast is passed through, if it is enabled.
        //

        if (

            //
            // 1. Check is this is destinated frame (broadcast is null) or
            //    if the packet is a broadcast with a matching group address
            //

            ((pAdapterContext->ulBroadcastAddress == 0)
            || (pAdapterContext->ulBroadcastAddress == 0xFFFFFFFFL)
            || ((pAdapterContext->ulBroadcastAddress & pStation->Gen.pLlcBinding->Functional.ulAddress)
            && ((pAdapterContext->ulBroadcastAddress & pStation->Gen.pLlcBinding->ulFunctionalZeroBits) == 0)
            && (pAdapterContext->usBroadcastAddress == pAdapterContext->usHighFunctionalBits))
            || ((pAdapterContext->ulBroadcastAddress == pStation->Gen.pLlcBinding->ulBroadcastAddress)
            && (pAdapterContext->usBroadcastAddress == pStation->Gen.pLlcBinding->usBroadcastAddress)))

            //
            // 2. If the station type is DIX, then the ethernet type
            //    must be the same as the station's ethernet type

            && ((pStation->Gen.ObjectType != LLC_DIX_OBJECT)
            || (pStation->Dix.ObjectAddress == pAdapterContext->EthernetType))

            //
            // 3. If the packet is a direct frame, then its receive mask
            //    must match with the received frame.
            //

            && ((pStation->Gen.ObjectType != LLC_DIRECT_OBJECT)
            || (pStation->Dir.OpenOptions & pAdapterContext->usRcvMask))) {

            UINT Status;

            //
            // Update the counter, we must later check the lost frames
            // (if no buffers available for the received frames)
            //

            pStation->Sap.Statistics.FramesReceived++;
            pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
            if (pAdapterContext->cbPacketSize < pAdapterContext->RcvLanHeaderLength) {
              return;
            }
            Status = pStation->Gen.pLlcBinding->pfReceiveIndication(
                pStation->Gen.pLlcBinding->hClientContext,
                pStation->Gen.hClientHandle,
                MacReceiveContext,
                pAdapterContext->FrameType,
                pAdapterContext->pLookBuf,
                pAdapterContext->cbPacketSize - pAdapterContext->RcvLanHeaderLength
                );

            //
            // Protocol may discard the packet and its indication.
            //

            if (Status != STATUS_SUCCESS) {
                pStation->Sap.Statistics.DataLostCounter++;
                if (Status == DLC_STATUS_NO_RECEIVE_COMMAND) {
                    pStation->Sap.Statistics.FramesDiscardedNoRcv++;
                }
            }
        }
    }
}



//
// Vs - we will be sending this next.
// Va - other side is expecting this next.
// was:
// if (pLink->Vs >= pLink->Va) {
//     if (pLink->Nr < pLink->Va || pLink->Nr > pLink->Vs) {
//         uchInput = LPDU_INVALID_r0;
//     }
// } else {
//     if (pLink->Nr > pLink->Vs && pLink->Nr < pLink->Va) {
//         uchInput = LPDU_INVALID_r0;
//     }
// }
//

int
verify_pack(
    IN      UCHAR  VsMax,        // pLink->VsMax
    IN      UCHAR  Vs,           // pLink->Vs,
    IN      UCHAR  Va,           // pLink->Va,
    IN      UCHAR  Nr,           // pLink->Nr,
    IN OUT  UCHAR *uchInput      // &uchInput
)
{
    if( Va <= VsMax ){           // Not Wrapped around 127?

        if( Nr < Va ){

            // this frame is saying it is expecting
            // Nr which is less than what it was expecting (Va)

            *uchInput = LPDU_INVALID_r0;

        }else if ( VsMax < Nr ){

            // He can't expect (Nr) beyond what we sent (Vs).

            *uchInput = LPDU_INVALID_r0;
        }
    }else{    // Vs sent is less < Acked Va, ie. wrapped. And

        if( VsMax < Nr   &&   Nr < Va ) {

            //  Eg. expecting between Va=126..0=Vs, (wrap range).
            //  and 0 ... Nr .. 126, is invalid.

            *uchInput = LPDU_INVALID_r0;
        }
    }
    return 0;
}


VOID
ProcessType2_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN OUT PDATA_LINK pLink,
    IN LLC_HEADER LlcHeader
    )

/*++

Routine Description:

    Procedure preprocess LLC Type2 frames for the actual state machine.
    Type 2 LLC frames are: I, RR, RNR, REJ, SABME, DISC, UA, DM, FRMR.
    The data is indicated to the upper protocol module, if it sequence
    number of the I- frame is valid, but the receive may still fail,
    if the data packet is discarded by the 802.2 state machine.
    The data is first indicated to the client, because we must set
    first the state machine to the local busy state, if the upper
    protocol module has not enough buffers to receive the data.

Arguments:

    pAdapterContext - The Adapter Binding specified at initialization time.
    pLink           - link station data
    LlcHeader       - LLC header

Return Value:

    None.

--*/

{
    UCHAR uchInput;
    BOOLEAN boolPollFinal;
    BOOLEAN boolInitialLocalBusyUser;
    UINT status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // The last received command is included in the DLC statistics
    //

    pLink->LastCmdOrRespReceived = LlcHeader.U.Command;

    //
    // Handle first I frames, they are the most common!
    //

    if (!(LlcHeader.U.Command & LLC_NOT_I_FRAME)) {

        //
        // Check first the sync of the I- frame: The send sequence
        // number should be what we are expected or some packets sare lost.
        //

        uchInput = IS_I_r0;     // In Sequence Information frame by default

        //
        // we discard all I-frames, that are bigger than the
        // maximum defined for this link station.
        // This must be the best way to solve wrong packet size.
        // FRMR disconnects the packets and the invalid transmit
        // command should fail in the sending side.
        //

        pLink->Nr = LlcHeader.I.Nr & (UCHAR)0xfe;
        if (pLink->MaxIField + pAdapterContext->RcvLanHeaderLength
        + sizeof(LLC_HEADER) < pAdapterContext->cbPacketSize) {
            uchInput = LPDU_INVALID_r0;
        } else if ((LlcHeader.I.Ns & (UCHAR)0xfe) != pLink->Vr) {

            //
            // Out of Sequence Information frame (we didn't expect this!)
            //

            uchInput = OS_I_r0;

            //
            // When we are out of receive buffers, we want to know
            // the buffer space required by all expected frames.
            // There may be several coming I-frames in the send queues,
            // bridges and in the receive buffers of the adapter when a
            // link enters a local busy state.  We save the size of
            // all received sequential I-frames during a local busy state
            // to know how much buffer space we must commit before we
            // can clear the local busy state.
            //

            if ((pLink->Flags & DLC_LOCAL_BUSY_BUFFER)
            && (LlcHeader.I.Ns & (UCHAR)0xfe) == pLink->VrDuringLocalBusy){
                pLink->VrDuringLocalBusy += 2;
                pLink->BufferCommitment  += BufGetPacketSize(pAdapterContext->cbPacketSize);
            }

            //
            // The valid frames has modulo: Va <= Nr <= Vs,
            // Ie. the Receive sequence number should belong to
            // a frame that has been sent but not acknowledged.
            // The extra check in the beginning makes the most common
            // code path faster: usually the other is waiting the next frame.
            //
            
        } else if (pLink->Nr != pLink->Vs) {
          
            //
            // There may by something wrong with the receive sequence number
            //

            verify_pack( pLink->VsMax,
                         pLink->Vs,
                         pLink->Va,
                         pLink->Nr,
                         &uchInput    );

        }

        //
        // We must first indcate the frame to the upper protocol and
        // then check, if it was accepted by the state machine.
        // If a I- frame cannot be received by the upper protocol
        // driver, then it must be dropped to the floor and be not
        // indicated to the state machine (=> the frame will be lost
        // for the LLC protocol)
        //

        //
        // RLF 04/13/93
        //
        // if the link is in local busy (user) state then don't indicate the
        // frame, but RNR it
        //

        // bug #193762
        //
        // AK 06/20/98
        //
        // Save the current user local busy flag. The receive indication
        // may release the driver lock (the ACQUIRE_SPIN_LOCK is a no-op because
        // the DLC_UNILOCK=1 in the sources file) it is possible that the link
        // state is different after the indication returns.
        //
        boolInitialLocalBusyUser = (pLink->Flags & DLC_LOCAL_BUSY_USER);

        if ((uchInput == IS_I_r0) && !(pLink->Flags & DLC_LOCAL_BUSY_USER)) {

            DLC_STATUS Status;

            pAdapterContext->LinkRcvStatus = STATUS_PENDING;

            if (pAdapterContext->cbPacketSize < pAdapterContext->RcvLanHeaderLength) {
              return;
            }

            Status = pLink->Gen.pLlcBinding->pfReceiveIndication(
                pLink->Gen.pLlcBinding->hClientContext,
                pLink->Gen.hClientHandle,
                MacReceiveContext,
                LLC_I_FRAME,
                pAdapterContext->pLookBuf,
                pAdapterContext->cbPacketSize - pAdapterContext->RcvLanHeaderLength
                );

            //
            // We use local busy to stop the send to the link.
            // IBM link station flow control management supports
            // local busy state enabling because of "out of receive buffers"
            // or "no outstanding receive".
            //

            if (Status != STATUS_SUCCESS) {
                if (Status == DLC_STATUS_NO_RECEIVE_COMMAND
                || Status == DLC_STATUS_OUT_OF_RCV_BUFFERS) {

                    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                    //
                    // We will enter to a local busy state because of
                    // out of buffers. Save the buffer size required
                    // to receive this data.
                    //

                    pLink->VrDuringLocalBusy = pLink->Vr;
                    pLink->BufferCommitment = BufGetPacketSize(pAdapterContext->cbPacketSize);

                    //
                    // We do not need to care, if the local busy state
                    // is already set or not.  The state machine just
                    // returns an error status, but we do not care
                    // about it.  The dlc status code trigger indication
                    // to the upper levels, if the state machine accepted
                    // the command.
                    //

                    pLink->Flags |= DLC_LOCAL_BUSY_BUFFER;
                    pLink->DlcStatus.StatusCode |= INDICATE_LOCAL_STATION_BUSY;
                    RunStateMachineCommand(pLink, ENTER_LCL_Busy);

                    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
                }
            }
        }

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        //
        // The most common case is handled as a special case.
        // We can save maybe 30 instrunctions.
        //

        if (uchInput == IS_I_r0 && pLink->State == LINK_OPENED) {
            UpdateVa(pLink);
            pLink->Vr += 2;
            pAdapterContext->LinkRcvStatus = STATUS_SUCCESS;

            //
            // IS_I_c1 = Update_Va; Rcv_BTU; [Send_ACK]
            // IS_I_r|IS_I_c0 = Update_Va; Rcv_BTU; TT2; Ir_Ct=N3; [RR_r](1)
            //

            if ((LlcHeader.I.Nr & LLC_I_S_POLL_FINAL)
            && !(LlcHeader.I.Ssap & LLC_SSAP_RESPONSE)) {
                StopTimer(&pLink->T2);
                pLink->Ir_Ct = pLink->N3;
                SendLlcFrame(pLink, (UCHAR)(DLC_RR_TOKEN | DLC_TOKEN_RESPONSE | 1));
            } else {
                SendAck(pLink);
            }
        } else {

            // bug #193762
            //
            // AK 06/20/98
            //
            // If the link was not busy (user) when this function was entered but
            // it is busy (user) now but not busy (system) then the frame must have
            // been accepted by the upper layer and we must adjust Acknowledge state
            // variable (Va) and Receive state variable (Vr). Otherwise we'll send
            // wrong N(r) in the RNR frame and we'll receive this same frame again when
            // we clear the local busy.
            //
            if(uchInput == IS_I_r0 &&
               !boolInitialLocalBusyUser &&
               !(pLink->Flags & DLC_LOCAL_BUSY_BUFFER) &&
               (pLink->Flags & DLC_LOCAL_BUSY_USER))
            {
                UpdateVa(pLink);
                pLink->Vr += 2;
                pAdapterContext->LinkRcvStatus = STATUS_SUCCESS;
            }

            uchInput += (UINT)(LlcHeader.I.Nr & LLC_I_S_POLL_FINAL);

            if (!(LlcHeader.I.Ssap & LLC_SSAP_RESPONSE)) {
                uchInput += DLC_TOKEN_COMMAND;
            }

            //
            // Nr will be some garbage in the case of U commands,
            // but the Poll/Final flag is not used when the U- commands
            // are processed.
            // ----
            // If the state machine returns an error to link receive status,
            // then the receive command completion cancels the received
            // frame.
            //

            pAdapterContext->LinkRcvStatus = RunStateMachine(
                pLink,
                (USHORT)uchInput,
                (BOOLEAN)((LlcHeader.S.Nr & LLC_I_S_POLL_FINAL) ? 1 : 0),
                (BOOLEAN)(LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)
                );
        }

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        //
        // Update the error counters if something went wrong with
        // the receive.
        //

        if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {

            //
            // We will count all I frames not actually acknowledged
            // as errors (this could be counted also other way).
            //

            pLink->Statistics.I_FrameReceiveErrors++;
            if (pLink->Statistics.I_FrameReceiveErrors == 0x80) {
                pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
            }
        } else {

            //
            // update statistics: in-sequency frames OK, all others
            // must be  errors.
            // This may not be the best place to count successful I-frames,
            // because the state machine has not yet acknowledged this frame,
            // We may be in a wrong state to receive any data (eg. local busy)
            //

            pLink->Statistics.I_FramesReceived++;
            if (pLink->Statistics.I_FramesReceived == 0x8000) {
                pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
            }
            pLink->pSap->Statistics.FramesReceived++;
        }

        //
        // We may complete this only if the transfer data has
        // already completed (and there is a receive completion
        // packet built up in).
        //

        if (pLink->Gen.pLlcBinding->TransferDataPacket.pPacket != NULL
        && pLink->Gen.pLlcBinding->TransferDataPacket.pPacket->Data.Completion.Status != NDIS_STATUS_PENDING) {

            //
            // The NDIS status is saved in the completion status, we
            // will use state machine status instead, if the state
            // machine returned an error.
            //

            if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {
                pLink->Gen.pLlcBinding->TransferDataPacket.pPacket->Data.Completion.Status = pAdapterContext->LinkRcvStatus;
            }
            pLink->Gen.pLlcBinding->pfCommandComplete(
                pLink->Gen.pLlcBinding->hClientContext,
                pLink->Gen.pLlcBinding->TransferDataPacket.pPacket->Data.Completion.hClientHandle,
                pLink->Gen.pLlcBinding->TransferDataPacket.pPacket
                );
            pLink->Gen.pLlcBinding->TransferDataPacket.pPacket = NULL;
        }

        //
        // ******** EXIT ***********
        //

        return;
    } else if (!(LlcHeader.S.Command & LLC_U_TYPE_BIT)) {

        //
        // Handle S (Supervisory) commands (RR, REJ, RNR)
        //

        switch (LlcHeader.S.Command) {
        case LLC_RR:
            uchInput = RR_r0;
            break;

        case LLC_RNR:
            uchInput = RNR_r0;
            break;

        case LLC_REJ:
            uchInput = REJ_r0;
            break;

        default:
            uchInput = LPDU_INVALID_r0;
            break;
        }

        //
        // The valid frames has modulo: Va <= Nr <= Vs,
        // Ie. the Receive sequence number should belong to
        // a frame that has been sent but not acknowledged.
        // The extra check in the beginning makes the most common
        // code path faster: usually the other is waiting the next frame.
        // (keep the rest code the same as in I path, even a very
        // primitive optimizer will puts these code paths together)
        //

        pLink->Nr = LlcHeader.I.Nr & (UCHAR)0xfe;
        if (pLink->Nr != pLink->Vs) {

            //
            // Check the received sequence number
            //

            verify_pack( pLink->VsMax,
                         pLink->Vs,
                         pLink->Va,
                         pLink->Nr,
                         &uchInput    );


        }
        uchInput += (UINT)(LlcHeader.S.Nr & LLC_I_S_POLL_FINAL);
        boolPollFinal = (BOOLEAN)(LlcHeader.S.Nr & LLC_I_S_POLL_FINAL);

        if (!(LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)) {
            uchInput += DLC_TOKEN_COMMAND;
        }
    } else {

        //
        // Handle U (Unnumbered) command frames
        // (FRMR, DM, UA, DISC, SABME, XID, TEST)
        //

        switch (LlcHeader.U.Command & ~LLC_U_POLL_FINAL) {
        case LLC_DISC:
            uchInput = DISC0;
            break;

        case LLC_SABME:
            uchInput = SABME0;
            break;

        case LLC_DM:
            uchInput = DM0;
            break;

        case LLC_UA:
            uchInput = UA0;
            break;

        case LLC_FRMR:
            uchInput =  FRMR0;
            break;

        default:

            //
            // we don't handle XID and TEST frames here!
            //

            ProcessType1_Frames(pAdapterContext, MacReceiveContext, pLink->pSap, LlcHeader);
            return;
            break;
        };

        //
        // We set an uniform poll/final bit for procedure call
        //

        boolPollFinal = FALSE;
        if (LlcHeader.U.Command & LLC_U_POLL_FINAL) {
            uchInput += 1;
            boolPollFinal = TRUE;
        }
    }

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // Note: the 3rd parameter must be 0 or 1, fortunately the
    // the poll/final bit is bit0 in S and I frames.
    //

    status = RunStateMachine(pLink,
                             (USHORT)uchInput,
                             boolPollFinal,
                             (BOOLEAN)(LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)
                             );

    //
    // if this frame is a UA AND it was accepted by the FSM AND the framing type
    // is currently unspecified then set it to the type in the UA frame received.
    // If this is not an ethernet adapter or we are not in AUTO mode then the
    // framing type for this link is set to the framing type in the binding
    // context (as it was before)
    //

    if ((status == STATUS_SUCCESS)
    && ((uchInput == UA0) || (uchInput == SABME0) || (uchInput == SABME1))
    && (pLink->FramingType == LLC_SEND_UNSPECIFIED)) {

        //
        // RLF 05/09/94
        //
        // If we received a UA in response to a SABME that we sent out as DIX
        // and 802.3, then record the framing type. This will be used for all
        // subsequent frames sent on this link
        //

        pLink->FramingType = (IS_SNA_DIX_FRAME(pAdapterContext)
                           && IS_AUTO_BINDING(pLink->Gen.pLlcBinding))
                           ? LLC_SEND_802_3_TO_DIX
                           : pLink->Gen.pLlcBinding->InternalAddressTranslation
                           ;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}


VOID
ProcessNewSabme(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    )

/*++

Routine Description:

    Procedure processes the remote connection requtest: SABME.
    It allocates a new link from the pool of closed links in
    the SAP and runs the state machine.

Arguments:

    pAdapterContext - The Adapter Binding specified at initialization time.
    pSap            - the current SAP handle
    LlcHeader       - LLC header

Return Value:

    None.

--*/

{
    PDATA_LINK pLink;
    DLC_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // The destination sap cannot be a group SAP any more,
    // thus we don't need to mask the lowest bit aways
    //

    Status = LlcOpenLinkStation(
                pSap,
                (UCHAR)(LlcHeader.auchRawBytes[DLC_SSAP_OFFSET] & 0xfe),
                NULL,
                pAdapterContext->pHeadBuf,
                NULL,        // no client handle => DLC driver must create it
                (PVOID*)&pLink
                );

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // We can do nothing, if we are out of resources
    //

    if (Status != STATUS_SUCCESS) {
        return;
    }

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // RLF 05/09/94
    //
    // We need to keep a per-connection indication of the framing type if the
    // adapter was opened in AUTO mode (else we generate 802.3 UA to DIX SABME)
    // Only do this for Ethernet adapters (we only set the SNA DIX frame
    // indicator in that case)
    //

    pLink->FramingType = (IS_SNA_DIX_FRAME(pAdapterContext)
                       && IS_AUTO_BINDING(pLink->Gen.pLlcBinding))
                       ? LLC_SEND_802_3_TO_DIX
                       : pLink->Gen.pLlcBinding->InternalAddressTranslation
                       ;

    //
    // now create the Link Station by running the FSM with ACTIVATE_LS as input.
    // This just initializes the link station 'object'. Then run the FSM again,
    // this time with the SABME command as input
    //

    RunStateMachineCommand(pLink, ACTIVATE_LS);
    RunStateMachine(
        pLink,
        (USHORT)((LlcHeader.U.Command & LLC_U_POLL_FINAL) ? SABME1 : SABME0),
        (BOOLEAN)((LlcHeader.U.Command & LLC_U_POLL_FINAL) ? 1 : 0),
        (BOOLEAN)TRUE
        );

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}


VOID
LlcTransferData(
    IN PBINDING_CONTEXT pBindingContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_PACKET pPacket,
    IN PMDL pMdl,
    IN UINT uiCopyOffset,
    IN UINT cbCopyLength
    )

/*++

Routine Description:

    This function copies only the data part of the received frame - that is
    the area after the LLC and DLC headers. If NDIS handed us all the data
    in the lookahead buffer, then WE can copy it out. Otherwise we have to
    call NDIS to get the data.

    If this is a DIX format frame, then NDIS thinks that the LAN header is
    14 bytes, but we know it is 17. We have to tell NDIS to copy from 3 bytes
    further into the data part of the received frame than we would normally
    have to

Arguments:

    pBindingContext - binding handle
	MacReceiveContext - For NdisTransferData
    pPacket         - receive context packet
    pMdl            - pointer to MDL describing data to copy
    uiCopyOffset    - offset from start of mapped buffer to copy from
    cbCopyLength    - length to copy

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pBindingContext->pAdapterContext;

    pPacket->Data.Completion.CompletedCommand = LLC_RECEIVE_COMPLETION;

    //
    // if the amount of data to copy is contained within the lookahead buffer
    // then we can copy the data.
    //
    // Remember: pAdapterContext->cbLookBuf and pLookBuf have been correctly
    // adjusted in the case of a DIX format frame
    //

    if (pAdapterContext->cbLookBuf - uiCopyOffset >= cbCopyLength) {

        PUCHAR pSrcBuffer;
        UINT BufferLength;

        pSrcBuffer = pAdapterContext->pLookBuf + uiCopyOffset;

        do {
            if (cbCopyLength > MmGetMdlByteCount(pMdl)) {
                BufferLength = MmGetMdlByteCount(pMdl);
            } else {
                BufferLength = cbCopyLength;
            }

            //
            // In 386 memcpy is faster than RtlMoveMemory, it also
            // makes the full register optimization much easier, because
            // all registers are available (no proc calls within loop)
            //

            //
            // !!!! Can't use LlcMemCpy here: On mips expands to RtlMoveMemory
            //      which uses FP registers. This won't work with shared memory
            //      on TR card
            //

            safe_memcpy(MmGetSystemAddressForMdl(pMdl), pSrcBuffer, BufferLength);
            pMdl = pMdl->Next;
            pSrcBuffer += BufferLength;
            cbCopyLength -= BufferLength;
        } while (cbCopyLength);
        pPacket->Data.Completion.Status = STATUS_SUCCESS;
        pBindingContext->TransferDataPacket.pPacket = pPacket;

    } else {

        //
        // too bad: there is more data to copy than is available in the look
        // ahead buffer. We have to call NDIS to perform the copy
        //

        UINT BytesCopied;

        //
        // if this is an Ethernet adapter and the received LAN header length is
        // more than 14 bytes then this is a DIX frame. We need to let NDIS know
        // that we want to copy data from 3 bytes in from where it thinks the
        // DLC header starts
        //

        UINT additionalOffset = (pAdapterContext->NdisMedium == NdisMedium802_3)
                                    ? (pAdapterContext->RcvLanHeaderLength > 14)
                                        ? 3
                                        : 0
                                    : 0;

#if DBG
        if (additionalOffset) {
            ASSERT(pAdapterContext->RcvLanHeaderLength == 17);
        }
#endif

        //
        // Theoretically NdisTransferData may not complete
        // immediately, and we cannot add to the completion
        // list, because the command is not really complete.
        // We may save it to adapter context to wait the
        // NdisTransferData to complete.
        //

        if (pBindingContext->TransferDataPacket.pPacket != NULL) {

            //
            // BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG
            //
            // If the same LLC client tries to receive the same buffer
            // many times (eg. when receive a packet to a group sap) and
            // if NDIS would complete those commands asynchronously, then
            // we cannot receive the frame with NdisTransferData.
            // Fortunately all NDIS implemnetations completes NdisTransferData
            // synchronously.
            // Solution: We could chain new packets to the existing data transfer
            //     packet, and copy the data, when the first data transfer request
            //     completes.  This would mean a lot of code, that would never
            //     used by anyone.  We would also need MDL to MDL copy function.
            //     The first data transfer could also be a smaller that another
            //     after it => would not work in a very general case, but
            //     would work with the group saps (all receives would be the same
            //     => direct MDL -> MDL copy would be OK.
            //
            // BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG
            //

            pPacket->Data.Completion.Status = DLC_STATUS_ASYNC_DATA_TRANSFER_FAILED;

            pBindingContext->pfCommandComplete(pBindingContext->hClientContext,
                                               pPacket->Data.Completion.hClientHandle,
                                               pPacket
                                               );
        }

        pBindingContext->TransferDataPacket.pPacket = pPacket;
        pPacket->pBinding = pBindingContext;
        ResetNdisPacket(&pBindingContext->TransferDataPacket);
        NdisChainBufferAtFront((PNDIS_PACKET)&pBindingContext->TransferDataPacket, pMdl);

        //
        // ADAMBA - Removed pAdapterContext->RcvLanHeaderLength
        // from ByteOffset (the fourth param).
        //

        NdisTransferData((PNDIS_STATUS)&pPacket->Data.Completion.Status,
                         pAdapterContext->NdisBindingHandle,
                         MacReceiveContext,

                         //
                         // if this is a DIX frame we have to move the data
                         // pointer ahead by the amount in additionalOffset
                         // (should always be 3 in this case) and reduce the
                         // amount of data to copy by the same number
                         //

                         uiCopyOffset + additionalOffset,

                         //
                         // we DON'T need to account for the additionalOffset
                         // in the length to be copied though
                         //

                         cbCopyLength,
                         (PNDIS_PACKET)&pBindingContext->TransferDataPacket,
                         &BytesCopied
                         );
    }

    //
    // We must queue a packet for the final receive completion,
    // But we cannot do it until TransferData is completed
    // (it is actually always completed, but this code is just
    // for sure).
    //

    if (pPacket->Data.Completion.Status != NDIS_STATUS_PENDING
    && pAdapterContext->LinkRcvStatus != STATUS_PENDING) {

        //
        // We receive the data before it is checked by the link station.
        // The upper protocol must just setup asynchronous receive
        // and later in LLC_RECEIVE_COMPLETION handling to
        // discard the receive, if it failed or accept if
        // it was OK for NDIS and link station.
        //

        if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {
            pPacket->Data.Completion.Status = pAdapterContext->LinkRcvStatus;
        }

        ACQUIRE_DRIVER_LOCK();

        pBindingContext->pfCommandComplete(pBindingContext->hClientContext,
                                           pPacket->Data.Completion.hClientHandle,
                                           pPacket
                                           );

        RELEASE_DRIVER_LOCK();

        pBindingContext->TransferDataPacket.pPacket = NULL;
    }
}


VOID
LlcNdisTransferDataComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT uiBytesTransferred
    )

/*++

Routine Description:

    The routine handles NdisCompleteDataTransfer indication and
    queues the indication of the completed receive operation.

Arguments:

    pAdapterContext     - adapter context
    pPacket             - NDIS packet used in the data transfer
    NdisStatus          - status of the completed data transfer
    uiBytesTransferred  - who needs this, I am not interested in
                          the partially succeeded data transfers,

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(uiBytesTransferred);
    UNREFERENCED_PARAMETER(OldIrql);

    ASSUME_IRQL(DISPATCH_LEVEL);

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'xefX');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {
        REFDEL(&pAdapterContext->AdapterRefCnt, 'xefX');
        return;
    }
#endif // NDIS40
    
    ACQUIRE_DRIVER_LOCK();

    if (((PLLC_TRANSFER_PACKET)pPacket)->pPacket != NULL) {
        ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->Data.Completion.Status = NdisStatus;

        //
        // I- frames have two statuses.  The link state machine is executed
        // after the NdisDataTransfer and thus its returned status may still
        // cancel the command. There are no spin locks around the return status
        // handling, but this should still work fine. It actually does not
        // matter if we return NDIS or state machine error code
        //

        if (pAdapterContext->LinkRcvStatus != STATUS_PENDING) {
            if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {
                ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->Data.Completion.Status = pAdapterContext->LinkRcvStatus;
            }
            ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->pBinding->pfCommandComplete(
                    ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->pBinding->hClientContext,
                    ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->Data.Completion.hClientHandle,
                    ((PLLC_TRANSFER_PACKET)pPacket)->pPacket
                    );
            ((PLLC_TRANSFER_PACKET)pPacket)->pPacket = NULL;
        }
    }

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'xefX');
#endif // NDIS40
}


VOID
safe_memcpy(
    OUT PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This is here because on a MIPS machine, LlcMemCpy expands to RtlMoveMemory
    which wants to use 64-bit floating point (CP1) registers for memory moves
    where both source and destination are aligned on 8-byte boundaries and
    where the length is a multiple of 32 bytes. If the source or destination
    buffer is actually the shared memory of a TR card, then the 64-bit moves
    (saw it on read, presume same for write) can only access memory in 32-bit
    chunks and 01 02 03 04 05 06 07 08 gets converted to 01 02 03 04 01 02 03 04.
    So this function attempts to do basically the same, without all the smarts
    as the original, but doesn't employ coprocessor registers to achieve the
    move. Hence slower, but safer

Arguments:

    Destination - where we're copying to
    Source      - where we're copying from
    Length      - how many bytes to move

Return Value:

    None.

--*/

{
    ULONG difference = (ULONG)((ULONG_PTR)Destination - (ULONG_PTR)Source);
    INT i;

    if (!(difference && Length)) {
        return;
    }

    //
    // if the destination overlaps the source then do reverse copy. Add a little
    // optimization - a la RtlMoveMemory - try to copy as many bytes as DWORDS.
    // However, on MIPS, both source and destination must be DWORD aligned to
    // do this. If both aren't then fall-back to BYTE copy
    //

    if (difference < Length) {
        if (!(((ULONG_PTR)Destination & 3) || ((ULONG_PTR)Source & 3))) {
            Destination += Length;
            Source += Length;

            for (i = Length % 4; i; --i) {
                *--Destination = *--Source;
            }
            for (i = Length / 4; i; --i) {
                *--((PULONG)Destination) = *--((PULONG)Source);
            }
        } else {
            Destination += Length;
            Source += Length;

            while (Length--) {
                *--Destination = *--Source;
            }
        }
    } else {
        if (!(((ULONG_PTR)Destination & 3) || ((ULONG_PTR)Source & 3))) {
            for (i = Length / 4; i; --i) {
                *((PULONG)Destination)++ = *((PULONG)Source)++;
            }
            for (i = Length % 4; i; --i) {
                *Destination++ = *Source++;
            }
        } else {
            while (Length--) {
                *Destination++ = *Source++;
            }
        }
    }
}


BOOLEAN
FramingDiscoveryCacheHit(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    This function is called when we receive a TEST/XID/SABME frame AND the
    adapter binding was created with LLC_ETHERNET_TYPE_AUTO AND we opened an
    ethernet adapter.

    The frame has either 802.3 or DIX framing. For all command and response TEST
    and XID frames and all SABME frames received, we keep note of the MAC address
    where the frame originated and its framing type.

    The first time we receive one of the above frames from a particular MAC
    address, the info will not be in the cache. So we add it. Subsequent frames
    of the above type (all others are passed through) with the same framing type
    as that in the cache will be indicated to the higher layers. If one of the
    above frame types arrives with THE OPPOSITE framing type (i.e. DIX instead
    of 802.3) then when we look in the cache for the MAC address we will find
    that it is already there, but with a different framing type (i.e. 802.3
    instead of DIX). In this case, we assume that the frame is an automatic
    duplicate and we discard it

    NOTE: We don't have to worry about UA because we only expect one SABME to
    be accepted: either we're sending the duplicate SABME and the target machine
    is configured for 802.3 or DIX, BUT NOT BOTH, or the receiving machine is
    another NT box running this DLC (with caching enabled!) and it will filter
    out the duplicate. Hence, in both situations, only one UA response should be
    generated per the SABME 'event'

    ASSUMES: The tick count returned from the system never wraps (! 2^63/10^7
    == 29,247+ years)

Arguments:

    pAdapterContext - pointer to ADAPTER_CONTEXT which has been filled in with
                      pHeadBuf pointing to - at least - the first 14 bytes in
                      the frame header
    pBindingContext - pointer to BINDING_CONTEXT containing the EthernetType
                      and if LLC_ETHERNET_TYPE_AUTO, the address of the framing
                      discovery cache

Return Value:

    BOOLEAN
        TRUE    - the MAC address was found in the cache WITH THE OTHER FRAMING
                  TYPE. Therefore the current frame should be discarded
        FALSE   - the MAC address/framing type combination was not found. The
                  frame should be indicated to the higher layer. If caching is
                  enabled, the frame has been added to the cache

--*/

{
    ULONG i;
    ULONG lruIndex;
    LARGE_INTEGER timeStamp;
    NODE_ADDRESS nodeAddress;
    PFRAMING_DISCOVERY_CACHE_ENTRY pCache;
    UCHAR framingType;

    //
    // if the binding context was not created with LLC_ETHERNET_TYPE_AUTO (and
    // therefore by implication, adapter is not ethernet) OR framing discovery
    // caching is disabled (the value read from the registry was zero) then bail
    // out with a not-found indication
    //

    if ((pBindingContext->EthernetType != LLC_ETHERNET_TYPE_AUTO)
    || (pBindingContext->FramingDiscoveryCacheEntries == 0)) {

#if defined(DEBUG_DISCOVERY)

        DbgPrint("FramingDiscoveryCacheHit: Not AUTO or 0 cache: returning FALSE\n");

#endif

        return FALSE;
    }

#if defined(DEBUG_DISCOVERY)

    {
        //
        // even though this is debug code, we shouldn't really be
        // indexing so far into pHeadBuf. Its only guaranteed to be
        // 14 bytes long. Should be looking in pLookBuf[5] and [2]
        //

        UCHAR frame = (pAdapterContext->pHeadBuf[12] == 0x80)
                    ? pAdapterContext->pHeadBuf[19]
                    : pAdapterContext->pHeadBuf[16];

        frame &= ~0x10; // knock off Poll/Final bit

        DbgPrint("FramingDiscoveryCacheHit: Received: %02x-%02x-%02x-%02x-%02x-%02x %s %s (%02x)\n",
                 pAdapterContext->pHeadBuf[6],
                 pAdapterContext->pHeadBuf[7],
                 pAdapterContext->pHeadBuf[8],
                 pAdapterContext->pHeadBuf[9],
                 pAdapterContext->pHeadBuf[10],
                 pAdapterContext->pHeadBuf[11],
                 (pAdapterContext->pHeadBuf[12] == 0x80)
                    ? "DIX"
                    : "802.3",
                 (frame == 0xE3)
                    ? "TEST"
                    : (frame == 0xAF)
                        ? "XID"
                        : (frame == 0x6F)
                            ? "SABME"
                            : (frame == 0x63)
                                ? "UA"
                                : "???",
                 frame
                 );
    }

#endif

    //
    // set up and perform a linear search of the cache (it should be reasonably
    // small and the comparisons are ULONG & USHORT, so not time critical
    //

    lruIndex = 0;

    //
    // better make sure we don't get data misalignment on MIPS
    //

    nodeAddress.Words.Top4 = *(ULONG UNALIGNED *)&pAdapterContext->pHeadBuf[6];
    nodeAddress.Words.Bottom2 = *(USHORT UNALIGNED *)&pAdapterContext->pHeadBuf[10];
    pCache = pBindingContext->FramingDiscoveryCache;

    //
    // framingType is the type we are looking for in the cache, not the type
    // in the frame
    //

    framingType = ((pAdapterContext->pHeadBuf[12] == 0x80)
                && (pAdapterContext->pHeadBuf[13] == 0xD5))
                ? FRAMING_TYPE_802_3
                : FRAMING_TYPE_DIX
                ;

    //
    // get the current tick count for comparison of time stamps
    //

    KeQueryTickCount(&timeStamp);

    //
    // linear search the cache
    //

    for (i = 0; i < pBindingContext->FramingDiscoveryCacheEntries; ++i) {
        if (pCache[i].InUse) {
            if ((pCache[i].NodeAddress.Words.Top4 == nodeAddress.Words.Top4)
            && (pCache[i].NodeAddress.Words.Bottom2 == nodeAddress.Words.Bottom2)) {

                //
                // we found the destination MAC address. If it has the opposite
                // framing type to that in the frame just received, return TRUE
                // else FALSE. In both cases refresh the time stamp
                //

                pCache[i].TimeStamp = timeStamp;

#if defined(DEBUG_DISCOVERY)

                DbgPrint("FramingDiscoveryCacheHit: Returning %s. Index = %d\n\n",
                         (pCache[i].FramingType == framingType) ? "TRUE" : "FALSE",
                         i
                         );

#endif

                return (pCache[i].FramingType == framingType);
            } else if (pCache[i].TimeStamp.QuadPart < timeStamp.QuadPart) {

                //
                // if we need to throw out a cache entry, we throw out the one
                // with the oldest time stamp
                //

                timeStamp = pCache[i].TimeStamp;
                lruIndex = i;
            }
        } else {

            //
            // we have hit an unused entry. The destination address/framing type
            // cannot be in the cache: add the received address/framing type at
            // this unused location
            //

            lruIndex = i;
            break;
        }
    }

    //
    // the destination address/framing type combination are not in the cache.
    // Add them. Throw out an entry if necessary
    //

#if defined(DEBUG_DISCOVERY)

    DbgPrint("FramingDiscoveryCacheHit: Adding/Throwing out %d (time stamp %08x.%08x\n",
             lruIndex,
             pCache[lruIndex].TimeStamp.HighPart,
             pCache[lruIndex].TimeStamp.LowPart
             );

#endif

    pCache[lruIndex].NodeAddress.Words.Top4 = nodeAddress.Words.Top4;
    pCache[lruIndex].NodeAddress.Words.Bottom2 = nodeAddress.Words.Bottom2;
    pCache[lruIndex].InUse = TRUE;
    pCache[lruIndex].FramingType = (framingType == FRAMING_TYPE_DIX)
                                 ? FRAMING_TYPE_802_3
                                 : FRAMING_TYPE_DIX
                                 ;
    pCache[lruIndex].TimeStamp = timeStamp;

    //
    // return FALSE meaning the destination address/framing type just received
    // was not in the cache (but it is now)
    //

#if defined(DEBUG_DISCOVERY)

    DbgPrint("FramingDiscoveryCacheHit: Returning FALSE\n\n");

#endif

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcsm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  ICL Data /Personal Systems

Module Name:

    llcsm.c

Abstract:

    The module implements a IEEE 802.2 compatible state machine as
    defined in IBM Token-Ring Architectural reference.
    The most of the code in the module is compiled by the finite state
    machine compiler from the IBM state machine definition (llcsm.fsm).
    The compiler is build as a part of this product.

    DO NOT MODIFY ANY CODE INSIDE:
        - #ifdef    FSM_CONST
        - #ifdef    FSM_DATA
        - #ifdef    FSM_PREDICATE_CASES
        - #ifdef    FSM_ACTION_CASES

    That code is genereated from the definition file of the state machine.
    Any changes in the state machine must be done into 802-2.fsm definition
    file (or to the source files of finite state machine cross compiler, fsmx).


    To understand the backgroung of this state machine, you should read
    Chapters 11 and 12 in IBM Token-Ring Architecture Reference.

    The this module produces 2100H code and A00H data when compiled for 386.

    Contents:
        RunStateMachine

Author:

    Antti Saarenheimo (o-anttis) 23-MAY-1991

Revision History:

--*/

#include <llc.h>

//*********************************************************************
//
//  C- macros for LAN DLC state machine
//
enum StateMachineOperMode {
    LLC_NO_OPER = 0,
    LOCAL_INIT_PENDING = 1,
    REMOTE_INIT_PENDING = 2,
    OPER_MODE_PENDING = 4,
    IS_FRAME_PENDING = 8,
    STATE_LOCAL_BUSY = 0x10,
    STATE_REMOTE_BUSY = 0x20,
    STACKED_DISCp_CMD = 0x40
};

#define SEND_RNR_CMD( a )    SendLlcFrame( pLink, DLC_RNR_TOKEN | \
    DLC_TOKEN_COMMAND | a )
#define SEND_RR_CMD( a )     SendLlcFrame( pLink, DLC_RR_TOKEN | \
    DLC_TOKEN_COMMAND | a )
#define DLC_REJ_RESPONSE( a ) uchSendId = \
    (UCHAR)(DLC_REJ_TOKEN | DLC_TOKEN_RESPONSE) | (UCHAR)a
#if 0
#define DLC_REJ_COMMAND( a ) uchSendId = \
	 (UCHAR)(DLC_REJ_TOKEN | DLC_TOKEN_COMMAND) | (UCHAR)a
#endif	// 0
#define DLC_RNR_RESPONSE( a ) uchSendId = \
    (UCHAR)(DLC_RNR_TOKEN | DLC_TOKEN_RESPONSE) | (UCHAR)a
#define DLC_RNR_COMMAND( a )  uchSendId = \
    (UCHAR)(DLC_RNR_TOKEN | DLC_TOKEN_COMMAND) | (UCHAR)a
#define DLC_RR_RESPONSE( a )  uchSendId = \
    (UCHAR)(DLC_RR_TOKEN | DLC_TOKEN_RESPONSE) | (UCHAR)a
#define DLC_RR_COMMAND( a )   uchSendId = \
    (UCHAR)(DLC_RR_TOKEN | DLC_TOKEN_COMMAND) | (UCHAR)a
#define DLC_DISC(a)             uchSendId = (UCHAR)DLC_DISC_TOKEN | (UCHAR)a
#define DLC_DM(a)               uchSendId = (UCHAR)DLC_DM_TOKEN | (UCHAR)a
#define DLC_FRMR(a)             uchSendId = (UCHAR)DLC_FRMR_TOKEN | (UCHAR)a
#define DLC_SABME(a)            uchSendId = (UCHAR)DLC_SABME_TOKEN | (UCHAR)a
#define DLC_UA(a)               uchSendId = (UCHAR)DLC_UA_TOKEN | (UCHAR)a
#define TimerStartIf( a )       StartTimer( a )
#define TimerStart( a )         StartTimer( a )
#define TimerStop( a )          StopTimer( a )
#define EnableLinkStation( a )
#define DisableLinkStation( a )
#define SEND_ACK( a )           SendAck( a )

//
//  Stack all event indications, they must be made immediate after
//  the state machine has been run
//
#define EVENT_INDICATION( a )   pLink->DlcStatus.StatusCode |= a


UCHAR auchLlcCommands[] = {
    0,
    LLC_REJ,
    LLC_RNR,
    LLC_RR,
    LLC_DISC,
    LLC_DM,
    LLC_FRMR,
    LLC_SABME,
    LLC_UA
};


#ifdef    FSM_DATA
// Flag for the predicate switch
#define PC     0x8000
USHORT aLanLlcStateInput[21][44] = {
{     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     1,     2,     2,     2,     0,     2,
      2,     2,     2,     2},
{    13,    13,     3,     3,     3,     3,  9|PC,  9|PC,     3,     3,
      3,     3,     3,    15,     3,     3,     3,    15,     3,     3,
      3,    15,     3,     3,     3,    15,     3,     3,     3,    15,
      3,     3,     3,     3,     2,     4,     5,     6,     0,  1|PC,
   4|PC,    11,  7|PC,     2},
{    24,    24,    25,    25,     3,     3, 22|PC, 22|PC,     0, 25|PC,
  29|PC,     0, 29|PC, 32|PC, 35|PC,     0, 35|PC, 38|PC, 47|PC,     0,
  47|PC, 50|PC, 41|PC,     0, 41|PC, 44|PC, 47|PC,     0, 47|PC, 50|PC,
      3,     3,     3,     3,     2,     2,     5,     6,     0,     2,
  11|PC, 14|PC, 17|PC,     2},
{    47,    47,    48,    48,     3,     3,    49,    49,     0,    48,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     2,     2,     5,     6,     0,     2,
      2,     2, 53|PC,     2},
{    53,    53,    54,    54,    55,    55,    56,    56,     3,     3,
      3,     3,    57,    57,     3,     3,    57,    57,     3,     3,
     57,    57,     3,     3,    57,    57,     3,     3,    57,    57,
      3,     3,     3,     3,     2,     2,     5,     6,     0,    50,
     51,    52,     2,     2},
{    66,    66,    67,    67,    68,    68,    69,    69,    70,    70,
     71,    71,    71,    72,    73,    73,    73,    74, 59|PC, 59|PC,
  59|PC, 62|PC,    79,    79,    79,    80,    76,    76,    76,    81,
     59,    59,    59,    60,     2,     2,    58,     2,    61,     2,
     62,    63, 56|PC,    65},
{    89,    89,    90,    90,    91,    91,    92,    92,    93,    93,
     94,    94,    94,    95,    94,    94,    94,    95, 59|PC, 59|PC,
  59|PC, 68|PC,    97,    97,    97,    98,    76,    76,    76,    99,
     83,    83,    83,    84,     2,     2,     2,    82,    85,     2,
     86,    87, 65|PC,     2},
{    89,    89,    90,    90,    91,    91,    92,    92,   106,   106,
    107,   107,   107,   108,   109,   109,   109,   110, 59|PC, 59|PC,
  59|PC, 74|PC,   112,   112,   112,   113,    76,    76,    76,   114,
    101,   101,   101,   102,     2,     2,   100,     2,   103,     2,
     86,   104, 71|PC,     2},
{   121,   121,   122,   122,   123,   123,   124,   124, 83|PC, 83|PC,
  86|PC, 92|PC, 86|PC, 89|PC, 95|PC,101|PC, 95|PC, 98|PC,104|PC,109|PC,
 104|PC,106|PC,112|PC,118|PC,112|PC,115|PC,121|PC,109|PC,121|PC,124|PC,
    116,   116,   116,   117,     2,     2,   115,     2,     0,     2,
  77|PC,     2, 80|PC,    65},
{   156,   156,   157,   157,   158,   158,   159,   159,130|PC,130|PC,
 133|PC,139|PC,133|PC,136|PC,142|PC,145|PC,142|PC,136|PC,104|PC,151|PC,
 104|PC,148|PC,154|PC,160|PC,154|PC,157|PC,121|PC,151|PC,121|PC,163|PC,
    152,   152,   152,   153,     2,     2,     2,   151,     0,     2,
  77|PC,     2,127|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,   160,   160,
 169|PC,175|PC,169|PC,172|PC,142|PC,181|PC,142|PC,178|PC,104|PC,187|PC,
 104|PC,184|PC,112|PC,193|PC,112|PC,190|PC,196|PC,187|PC,196|PC,198|PC,
    152,   152,   152,   153,     2,     2,   180,     2,     0,     2,
  77|PC,     2,166|PC,     2},
{   198,   198,   199,   199,   200,   200,   201,   201,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     2,     2,     5,     6,     0,     8,
    197,    52,     2,     2},
{    66,    66,    67,    67,    68,    68,    69,    69,    70,    70,
     71,   204,    71,    72,   205,   207,   205,   206,204|PC,204|PC,
 204|PC,207|PC,    76,    76,    76,    81,213|PC,213|PC,213|PC,210|PC,
     59,    59,    59,    60,     2,     2,   202,     2,     0,     2,
     62,   203,201|PC,    65},
{    89,    89,    90,    90,    91,    91,    92,    92,   106,   106,
     94,    94,    94,    95,    94,    94,    94,    95,216|PC,216|PC,
 216|PC,219|PC,    76,    76,    76,    99,225|PC,225|PC,225|PC,222|PC,
     83,    83,    83,    84,     2,     2,     2,   215,     0,     2,
     86,   216,   216,     2},
{    89,    89,    90,    90,   226,   226,    92,    92,   106,   106,
    227,   227,   227,   228,   109,   109,   109,    95,   229,   229,
    229,   230,   231,   231,   231,   232,    76,    76,    76,    99,
     83,    83,    83,    84,     2,     2,     2,   223,   224,     2,
     86,   225,228|PC,     2},
{    89,    89,    90,    90,    91,    91,    92,    92,   106,   106,
    235,   235,   235,   236,   109,   109,   109,   110,234|PC,234|PC,
 234|PC,237|PC,    76,    76,    76,   114,243|PC,243|PC,243|PC,240|PC,
     83,    83,    83,    84,     2,     2,   233,     2,     0,     2,
     86,   234,231|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,   160,   160,
 249|PC,139|PC,249|PC,252|PC,142|PC,255|PC,142|PC,136|PC,258|PC,264|PC,
 258|PC,260|PC,154|PC,266|PC,154|PC,157|PC,269|PC,272|PC,269|PC,163|PC,
    152,   152,   152,   153,     2,     2,     2,246|PC,     0,     2,
  77|PC,     2,127|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,130|PC,130|PC,
 169|PC,275|PC,169|PC,172|PC,278|PC,284|PC,278|PC,281|PC,104|PC,287|PC,
 104|PC,184|PC,290|PC,296|PC,290|PC,293|PC,121|PC,296|PC,121|PC,198|PC,
    152,   152,   152,   153,     2,     2,   257,     2,     0,     2,
  77|PC,     2,166|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,   160,   160,
 169|PC,175|PC,169|PC,172|PC,299|PC,181|PC,299|PC,302|PC,104|PC,305|PC,
 104|PC,184|PC,290|PC,308|PC,290|PC,190|PC,121|PC,311|PC,121|PC,198|PC,
    152,   152,   152,   153,     2,     2,   267,     2,     0,     2,
  77|PC,     2,166|PC,     2},
{    89,    89,    90,    90,   226,   226,    92,    92,   106,   106,
    277,   277,   277,   278,   109,   109,   109,    95,   279,   279,
    279,   280,   281,   281,   281,   282,320|PC,320|PC,320|PC,317|PC,
     83,    83,    83,    84,     2,     2,     2,   275,     0,     2,
     86,   276,314|PC,     2},
{   289,   289,   290,   290,   291,   291,    56,    56,     0,     0,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     2,     2,     5,     6,     0,    50,
     51,323|PC,     2,     2}};
USHORT aLanLlcCondJump[326] = {
    0,    1,    7,    8,    1,    9,   10,    2,   12,    3,   14,    4,
   16,   17,    5,   18,   19,    6,   20,   21,   22,   23,    7,   26,
   27,    8,   28,   29,    3,    9,   30,   31,    9,   32,   33,    9,
   30,   34,    9,   35,   36,    9,   37,   38,    9,   39,   40,    9,
   41,   42,    9,   43,   44,   10,   45,   46,   11,   64,   63,   12,
   75,   76,   12,   77,   78,   11,   88,   87,   12,   96,   78,   13,
  104,  105,   12,  111,   78,   14,    2,  118,   10,  119,  120,   15,
  125,    3,   16,  126,  127,   16,  128,  129,   17,  130,  131,   16,
  132,  133,   16,  134,  135,   17,  136,  137,   18,  138,   16,  139,
  140,   17,  141,  142,   16,  143,  144,   16,  145,  146,   17,  147,
  142,   16,  148,   12,   16,  149,  150,   10,  154,  155,   15,  160,
    3,   16,  161,  162,   16,  163,  164,   17,  165,  166,   16,  167,
  168,   17,  169,  166,   16,  170,  171,   17,  172,  173,   16,  174,
  175,   16,  176,  177,   17,  178,  173,   16,  179,  171,   10,  181,
  155,   16,  182,  183,   16,  184,  185,   17,  130,  186,   16,  187,
  188,   17,  189,  186,   16,  190,  191,   17,  192,  142,   16,  193,
  194,   17,  195,  142,   18,  148,   16,  196,  191,   11,   88,  203,
   12,  208,  209,   12,  210,  211,   12,  212,  213,   12,  214,  209,
   12,  217,   76,   12,  218,   78,   12,  219,  220,   12,  221,  222,
   11,   88,  225,   11,   88,  234,   12,  237,   76,   12,  238,   78,
   12,  239,  240,   12,  241,  242,   19,  243,  244,   16,  245,  246,
   16,  247,  248,   17,  249,  166,   18,  250,   20,  251,  171,  252,
   21,  173,   17,  253,  254,   16,  255,   12,   17,  256,  173,   17,
  130,  166,   16,  258,  259,   16,  260,  261,   17,  262,  166,   17,
  263,  142,   16,  143,  264,   16,  193,  265,   17,  266,  142,   16,
  268,  269,   16,  270,  271,   17,  272,  142,   17,  273,  142,   17,
  274,  142,   11,  105,  276,   12,  283,  284,   12,  285,  286,   10,
  287,  288};
#endif


#define     usState     pLink->State


UINT
RunStateMachine(
    IN OUT PDATA_LINK pLink,
    IN USHORT usInput,
    IN BOOLEAN boolPollFinal,
    IN BOOLEAN boolResponse
    )

/*++

Routine Description:

    The function impelements the complete HDLC ABM link station as
    it has been defined in IBM Token-Ring Architecture Reference.
    The excluding of XID and TEST handling in the link station level
    should be the the only difference. The code is compiled from
    the state machine definition file with the finite state machine
    compiler.

Special:

    This procededure must be called with SendSpinLock set

Arguments:

    pLink           - link station context
    usInput         - state machine input
    boolPollFinal   - boolean flag set when the received frame had poll/final
                      bit set
    boolResponse    - boolean flag set when the received frame was response

Return Value:

    STATUS_SUCCESS  - the state machine acknowledged the next operation,
        eg. the received data or the packet was queued

    DLC_STATUS_NO_ACTION - the command was accepted and executed.
        No further action is required from caller.

    DLC_LOGICAL_ERROR - the input is invalid within this state.
        This error is returned to the upper levels.

    DLC_IGNORE_FRAME - the received frame was ignored

    DLC_DISCARD_INFO_FIELD - the received data was discarded

--*/

{
    UINT usAction;
    UINT usActionIndex;
    UCHAR uchSendId = 0;
    UINT Status = DLC_STATUS_SUCCESS;


#if LLC_DBG

    //
    // We save all last state machine inputs to a global trace table
    //

    aLast[InputIndex % LLC_INPUT_TABLE_SIZE].Input = usInput;
    aLast[InputIndex % LLC_INPUT_TABLE_SIZE].Time = (USHORT)AbsoluteTime;
    aLast[InputIndex % LLC_INPUT_TABLE_SIZE].pLink = pLink;
    InputIndex++;
#endif

    //
    // FSM condition switch
    //

#ifdef    FSM_PREDICATE_CASES
    usAction = aLanLlcStateInput[usState][usInput];
    if (usAction & 0x8000) {
        usActionIndex = usAction & 0x7fff;
        usAction = aLanLlcCondJump[usActionIndex++];
        switch (usAction) {
        case 1:
            if (pLink->Vi==0)
                ;
            else if (pLink->Vi==REMOTE_INIT_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 2:
            if (pLink->P_Ct==0)
                ;
            else
                usActionIndex = 0;
            break;
        case 3:
            if (pLink->Vi==0)
                ;
            else
                usActionIndex = 0;
            break;
        case 4:
            if (pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==REMOTE_INIT_PENDING)
                ;
            else if (pLink->Vi==OPER_MODE_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 5:
            if ((pLink->Vb&STATE_LOCAL_BUSY)!=0)
                ;
            else if ((pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 6:
            if (pLink->P_Ct!=0&&pLink->Vi==LOCAL_INIT_PENDING)
                ;
            else if (pLink->P_Ct==0&&pLink->Vi==LOCAL_INIT_PENDING)
                usActionIndex += 1;
            else if (pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING)&&(pLink->Vb&STATE_LOCAL_BUSY)!=0)
                usActionIndex += 2;
            else if (pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING)&&(pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 3;
            else
                usActionIndex = 0;
            break;
        case 7:
            if (pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING))
                ;
            else if (pLink->Vi==OPER_MODE_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 8:
            if ((pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING))&&(pLink->Vb&STATE_LOCAL_BUSY)!=0)
                ;
            else if ((pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING))&&(pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 1;
            else if ((pLink->Vi==OPER_MODE_PENDING))
                usActionIndex += 2;
            else
                usActionIndex = 0;
            break;
        case 9:
            if (pLink->Vi==OPER_MODE_PENDING&&pLink->Nr==0&&(pLink->Vb&STATE_LOCAL_BUSY)!=0)
                ;
            else if (pLink->Vi==OPER_MODE_PENDING&&pLink->Nr==0&&(pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 10:
            if (pLink->P_Ct!=0)
                ;
            else if (pLink->P_Ct==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 11:
            if (pLink->Is_Ct<=0)
                ;
            else if (pLink->Is_Ct>0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 12:
            if (pLink->Nr!=pLink->Vs)
                ;
            else if (pLink->Nr==pLink->Vs)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 13:
            if (pLink->Is_Ct>0)
                ;
            else if (pLink->P_Ct<=0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 14:
            if (pLink->Vc!=0)
                ;
            else if (pLink->Vc==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 15:
            if (pLink->Vi!=IS_FRAME_PENDING)
                ;
            else if (pLink->Vi==IS_FRAME_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 16:
            if (pLink->Va!=pLink->Nr)
                ;
            else if (pLink->Va==pLink->Nr)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 17:
            if (pLink->Vc==0)
                ;
            else if (pLink->Vc==STACKED_DISCp_CMD)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 18:
            if (pLink->Va!=pLink->Nr)
                ;
            else
                usActionIndex = 0;
            break;
        case 19:
            if (pLink->Vb==(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY))
                ;
            else if (pLink->Vb==STATE_LOCAL_BUSY)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 20:
            if (pLink->Va!=pLink->Nr)
                ;
            else if (pLink->Va==pLink->Nr)
                usActionIndex += 1;
            else if (pLink->Vc==0)
                usActionIndex += 2;
            else
                usActionIndex = 0;
            break;
        case 21:
            if (pLink->Vc==STACKED_DISCp_CMD)
                ;
            else
                usActionIndex = 0;
            break;
        };
        usAction = aLanLlcCondJump[usActionIndex];
    }
#endif


#ifdef    FSM_ACTION_CASES
    switch (usAction) {
    case 0:
            Status=DLC_STATUS_NO_ACTION;
            break;
    case 1:
            EnableLinkStation(pLink);
            pLink->Vi=pLink->Vb=pLink->Vc=0;
        label_1_1:
            pLink->State=1;
    case 11:
        label_11_1:
            TimerStart(&pLink->Ti);
            break;
    case 2:
            Status=DLC_STATUS_LINK_PROTOCOL_ERROR;
            break;
    case 3:
            Status=DLC_STATUS_IGNORE_FRAME;
            break;
    case 4:
            DisableLinkStation(pLink);
            pLink->State=0;
            break;
    case 5:
        label_5_1:
            pLink->Vb=STATE_LOCAL_BUSY;
            break;
    case 6:
        label_6_1:
            pLink->Vb=0;
            break;
    case 7:
            TimerStartIf(&pLink->T1);
            pLink->Vi=LOCAL_INIT_PENDING;
            DLC_SABME(1);
            pLink->State=2;
            TimerStop(&pLink->Ti);
        label_7_1:
            pLink->P_Ct=pLink->N2;
        label_7_2:
            pLink->Is_Ct=pLink->N2;
            break;
    case 8:
            pLink->Vi=OPER_MODE_PENDING;
            DLC_UA(pLink->Pf);
            pLink->State=2;
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Ir_Ct=pLink->N3;
            TimerStart(&pLink->Ti);
            goto label_7_2;
    case 9:
            DLC_DM(0);
        label_9_1:
            EVENT_INDICATION(CONFIRM_DISCONNECT);
        label_9_2:
            TimerStart(&pLink->Ti);
            break;
    case 10:
            DLC_DM(pLink->Pf);
            pLink->Vi=0;
            goto label_9_1;
    case 12:
        label_12_1:
            ;
            break;
    case 13:
        label_13_1:
            DLC_DM(boolPollFinal);
            break;
    case 14:
            EVENT_INDICATION(INDICATE_CONNECT_REQUEST);
        label_14_1:
            pLink->Pf=boolPollFinal;
            pLink->Vi=REMOTE_INIT_PENDING;
            goto label_9_2;
    case 15:
            DLC_DM(1);
            break;
    case 16:
            DLC_DM(0);
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(CONFIRM_DISCONNECT);
            TimerStop(&pLink->T1);
        label_16_1:
            pLink->Vi=0;
            goto label_1_1;
    case 17:
            TimerStop(&pLink->Ti);
            pLink->Vi=0;
            pLink->State=3;
            DLC_DISC(1);
        label_17_1:
            pLink->P_Ct=pLink->N2;
        label_17_2:
            TimerStart(&pLink->T1);
            break;
    case 18:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
        label_18_1:
            pLink->Vi=IS_FRAME_PENDING;
            DLC_RNR_COMMAND(1);
            pLink->State=9;
        label_18_2:
            EVENT_INDICATION(CONFIRM_CONNECT);
            goto label_17_1;
    case 19:
            pLink->Vi=IS_FRAME_PENDING;
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
        label_19_1:
            pLink->State=8;
            DLC_RR_COMMAND(1);
            goto label_18_2;
    case 20:
            DLC_SABME(1);
        label_20_1:
            pLink->P_Ct--;
            goto label_17_2;
    case 21:
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(INDICATE_LINK_LOST);
            goto label_16_1;
    case 22:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Vc=0;
            pLink->Ir_Ct=pLink->N3;
            pLink->Is_Ct=pLink->N2;
            goto label_18_1;
    case 23:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0,pLink->Vi=IS_FRAME_PENDING,pLink->Vc=0;
            pLink->Ir_Ct=pLink->N3;
            pLink->Is_Ct=pLink->N2;
            goto label_19_1;
    case 24:
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            pLink->Vi=0;
            TimerStart(&pLink->Ti);
        label_24_1:
            TimerStop(&pLink->T1);
            goto label_13_1;
    case 25:
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            TimerStop(&pLink->T1);
        label_25_1:
            pLink->Vi=0;
            goto label_9_2;
    case 26:
            pLink->Vi=(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING);
    case 47:
        label_47_1:
            DLC_UA(boolPollFinal);
            break;
    case 27:
        label_27_1:
            TimerStart(&pLink->Ti);
            goto label_47_1;
    case 28:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Vi=IS_FRAME_PENDING;
            DLC_RNR_COMMAND(1);
            pLink->State=9;
        label_28_1:
            TimerStart(&pLink->T1);
            EVENT_INDICATION(CONFIRM_CONNECT);
            pLink->Vc=0;
            pLink->Ir_Ct=pLink->N3;
            goto label_7_1;
    case 29:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Vi=IS_FRAME_PENDING;
            pLink->State=8;
            DLC_RR_COMMAND(1);
            goto label_28_1;
    case 30:
            DLC_RNR_RESPONSE(0);
        label_30_1:
            pLink->State=6;
        label_30_2:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
        label_30_3:
            EnableSendProcess(pLink);
        label_30_4:
            EVENT_INDICATION(CONFIRM_CONNECT);
            goto label_25_1;
    case 31:
            SEND_ACK(pLink);
        label_31_1:
            Status=STATUS_SUCCESS;pLink->Vr+=2;
    case 42:
        label_42_1:
            pLink->State=5;
            goto label_30_3;
    case 32:
            DLC_RNR_RESPONSE(1);
            goto label_30_1;
    case 33:
            DLC_RR_RESPONSE(1);
            goto label_31_1;
    case 34:
            DLC_REJ_RESPONSE(0);
        label_34_1:
            pLink->State=7;
            goto label_30_2;
    case 35:
            pLink->State=6;
            EVENT_INDICATION(CONFIRM_CONNECT);
            pLink->Vi=0;
            EnableSendProcess(pLink);
            TimerStart(&pLink->Ti);
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_12_1;
    case 36:
            DLC_REJ_RESPONSE(1);
            goto label_34_1;
    case 37:
        label_37_1:
            pLink->State=13;
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_37_2:
            pLink->Is_Ct=pLink->N2;
            goto label_30_4;
    case 38:
        label_38_1:
            pLink->State=12;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_37_2;
    case 39:
            DLC_RNR_RESPONSE(1);
            goto label_37_1;
    case 40:
            DLC_RR_RESPONSE(1);
            goto label_38_1;
    case 41:
        label_41_1:
            pLink->State=6;
            goto label_30_3;
    case 43:
            DLC_RNR_RESPONSE(1);
            goto label_41_1;
    case 44:
            DLC_RR_RESPONSE(1);
            goto label_42_1;
    case 45:
            DLC_DISC(1);
            goto label_20_1;
    case 46:
        label_46_1:
            EVENT_INDICATION(CONFIRM_DISCONNECT);
            goto label_1_1;
    case 48:
            TimerStop(&pLink->T1);
            goto label_46_1;
    case 49:
            EVENT_INDICATION(CONFIRM_DISCONNECT);
            pLink->State=1;
            TimerStart(&pLink->Ti);
            goto label_24_1;
    case 50:
            pLink->Vi=LOCAL_INIT_PENDING;
            DLC_SABME(1);
            pLink->State=2;
        label_50_1:
            TimerStop(&pLink->Ti);
            goto label_17_1;
    case 51:
            pLink->State=3;
            DLC_DISC(1);
            goto label_50_1;
    case 52:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_11_1;
    case 53:
        label_53_1:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
        label_53_2:
            pLink->State=1;
            goto label_27_1;
    case 54:
        label_54_1:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
        label_54_2:
            pLink->State=1;
            goto label_9_2;
    case 55:
            pLink->P_Ct=pLink->N2;
        label_55_1:
            pLink->State=20;
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            goto label_9_2;
    case 56:
        label_56_1:
            pLink->State=11;
            EVENT_INDICATION(INDICATE_RESET);
            goto label_14_1;
    case 57:
            DLC_FRMR(boolPollFinal);
        label_57_1:
            EVENT_INDICATION(INDICATE_FRMR_SENT);
            goto label_9_2;
    case 58:
            pLink->State=6;
            DLC_RNR_RESPONSE(0);
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
            goto label_5_1;
    case 59:
            DLC_FRMR(0);
        label_59_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
        label_59_2:
            TimerStop(&pLink->T2);
        label_59_3:
            pLink->State=4;
            TimerStop(&pLink->T1);
            goto label_57_1;
    case 60:
            DLC_FRMR(1);
            goto label_59_1;
    case 61:
            TimerStart(&pLink->T1);
            pLink->Is_Ct--;
            pLink->Ir_Ct=pLink->N3;
        label_61_1:
            pLink->State=8;
        label_61_2:
            pLink->Vp=pLink->Vs;
        label_61_3:
            pLink->P_Ct=pLink->N2;
            break;
    case 62:
        label_62_3:
            TimerStop(&pLink->Ti);
            TimerStart(&pLink->T1);
        label_62_1:
            pLink->State=3;
            DLC_DISC(1);
        label_62_2:
            TimerStop(&pLink->T2);
            goto label_61_3;
    case 63:
            pLink->State=8;
            DisableSendProcess(pLink);
            DLC_RR_COMMAND(1);
            pLink->Vp=pLink->Vs;
            TimerStart(&pLink->T1);
            pLink->Ir_Ct=pLink->N3;
            goto label_62_2;
    case 64:
            EVENT_INDICATION(INDICATE_LINK_LOST);
            TimerStart(&pLink->T1);
            goto label_62_1;
    case 65:
            DLC_RR_RESPONSE(0);
        label_65_1:
            pLink->Ir_Ct=pLink->N3;
            break;
    case 66:
            TimerStop(&pLink->T2);
    case 89:
//		 label_89_1:
            TimerStop(&pLink->T1);
            goto label_53_1;
    case 67:
            TimerStop(&pLink->T2);
    case 90:
//		 label_90_1:
            TimerStop(&pLink->T1);
            goto label_54_1;
    case 68:
            pLink->State=20;
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            TimerStop(&pLink->T1);
            TimerStart(&pLink->Ti);
            goto label_62_2;
    case 69:
            TimerStop(&pLink->T2);
    case 92:
//		 label_92_1:
            TimerStop(&pLink->T1);
            goto label_56_1;
    case 70:
            DLC_FRMR(0);
            goto label_59_2;
    case 71:
        label_71_1:
            SEND_ACK(pLink);
        label_71_2:
            Status=STATUS_SUCCESS;pLink->Vr+=2;
    case 76:
        label_76_1:
            UpdateVa(pLink);
            break;
    case 72:
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
        label_72_1:
            DLC_RR_RESPONSE(1);
            goto label_71_2;
    case 73:
            DLC_REJ_RESPONSE(0);
        label_73_1:
            pLink->State=7;
            pLink->Ir_Ct=pLink->N3;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
        label_73_2:
            TimerStop(&pLink->T2);
            goto label_76_1;
    case 74:
            DLC_REJ_RESPONSE(1);
            goto label_73_1;
    case 75:
        label_75_1:
            ResendPackets(pLink),UpdateVa(pLink);
        label_75_2:
            pLink->Is_Ct--;
            break;
    case 77:
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
    case 111:
//		 label_111_1:
            DLC_RR_RESPONSE(1);
            goto label_75_1;
    case 78:
        label_78_1:
            DLC_RR_RESPONSE(1);
            goto label_73_2;
    case 79:
            pLink->Vb=STATE_REMOTE_BUSY,pLink->Is_Ct=pLink->N2;
        label_79_1:
            pLink->State=12;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
        label_79_2:
            DisableSendProcess(pLink);
            goto label_76_1;
    case 80:
            pLink->Vb=STATE_REMOTE_BUSY;
            pLink->Ir_Ct=pLink->N3;
            DLC_RR_RESPONSE(1);
            pLink->Is_Ct=pLink->N2;
            TimerStop(&pLink->T2);
            goto label_79_1;
    case 81:
            pLink->Ir_Ct=pLink->N3;
            goto label_78_1;
    case 82:
            TimerStop(&pLink->Ti);
            TimerStart(&pLink->T1);
            DisableSendProcess(pLink);
            pLink->Vb=0;
        label_82_1:
            DLC_RR_COMMAND(1);
            goto label_61_1;
    case 83:
            DLC_FRMR(0);
        label_83_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
            goto label_59_3;
    case 84:
            DLC_FRMR(1);
            goto label_83_1;
    case 85:
            pLink->State=9;
            pLink->Ir_Ct=pLink->N3;
        label_85_1:
            TimerStart(&pLink->T1);
            pLink->Vp=pLink->Vs;
            pLink->P_Ct=pLink->N2;
            goto label_75_2;
    case 86:
            TimerStart(&pLink->T1);
        label_86_1:
            TimerStop(&pLink->Ti);
        label_86_2:
            pLink->State=3;
            DLC_DISC(1);
            goto label_61_3;
    case 87:
            pLink->State=9;
        label_87_1:
            DLC_RNR_COMMAND(1);
        label_87_2:
            DisableSendProcess(pLink);
        label_87_3:
            TimerStart(&pLink->T1);
            goto label_61_2;
    case 88:
            TimerStop(&pLink->T2);
    case 105:
        label_105_1:
            TimerStart(&pLink->T1);
            goto label_86_2;
    case 91:
        label_91_1:
            TimerStart(&pLink->Ti);
        label_91_2:
            TimerStop(&pLink->T1);
        label_91_3:
            pLink->State=20;
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            goto label_61_3;
    case 93:
            pLink->DlcStatus.FrmrData.Reason=0x08;
    case 106:
        label_106_1:
            DLC_FRMR(0);
            goto label_59_3;
    case 94:
            DLC_RNR_RESPONSE(0);
    case 109:
        label_109_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_76_1;
    case 95:
            DLC_RNR_RESPONSE(1);
            goto label_109_1;
    case 96:
            DLC_RNR_RESPONSE(1);
            goto label_75_1;
    case 97:
        label_97_1:
            pLink->State=13;
        label_97_2:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_97_3:
            pLink->Is_Ct=pLink->N2;
            goto label_79_2;
    case 98:
            DLC_RNR_RESPONSE(1);
            goto label_97_1;
    case 99:
            DLC_RNR_RESPONSE(1);
            goto label_76_1;
    case 100:
            pLink->State=14;
            DLC_RNR_RESPONSE(0);
            goto label_5_1;
    case 101:
            pLink->DlcStatus.FrmrData.Reason=00001;
            goto label_106_1;
    case 102:
            pLink->DlcStatus.FrmrData.Reason=00001;
            DLC_FRMR(1);
            goto label_59_3;
    case 103:
            pLink->State=10;
            goto label_85_1;
    case 104:
        label_104_1:
            pLink->State=10;
            DLC_RR_COMMAND(1);
            goto label_87_2;
    case 107:
            pLink->State=5;
            goto label_71_1;
    case 108:
            pLink->State=5;
            goto label_72_1;
    case 110:
            DLC_RR_RESPONSE(1);
            goto label_109_1;
    case 112:
        label_112_1:
            pLink->State=15;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_97_3;
    case 113:
            DLC_RR_RESPONSE(1);
            goto label_112_1;
    case 114:
            DLC_RR_RESPONSE(1);
            goto label_76_1;
    case 115:
            pLink->State=9;
            pLink->Vb=STATE_LOCAL_BUSY;
        label_115_1:
            DLC_RNR_RESPONSE(0);
        label_115_2:
            TimerStop(&pLink->T2);
            goto label_65_1;
    case 116:
            DLC_FRMR(0);
        label_116_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
        label_116_2:
            pLink->State=4;
            EVENT_INDICATION(INDICATE_FRMR_SENT);
        label_116_3:
            TimerStop(&pLink->T1);
        label_116_4:
            TimerStop(&pLink->T2);
            goto label_11_1;
    case 117:
            DLC_FRMR(1);
            goto label_116_1;
    case 118:
            pLink->Vc=STACKED_DISCp_CMD;
            break;
    case 119:
            pLink->P_Ct--;
            DisableSendProcess(pLink);
        label_119_1:
            DLC_RR_COMMAND(1);
            pLink->Vp=pLink->Vs;
            TimerStart(&pLink->T1);
            goto label_115_2;
    case 120:
            if( pLink->Vc == STACKED_DISCp_CMD ) {
                goto label_62_3;
            } else {
                EVENT_INDICATION(INDICATE_LINK_LOST);
            }
        label_120_1:
            pLink->State=1;
            goto label_116_4;
    case 121:
            TimerStop(&pLink->T2);
    case 156:
//		 label_156_1:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            TimerStart(&pLink->Ti);
            TimerStop(&pLink->T1);
            goto label_47_1;
    case 122:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            TimerStop(&pLink->T1);
            goto label_120_1;
    case 123:
            pLink->Vc=0;
            TimerStop(&pLink->T2);
            goto label_91_1;
    case 124:
            pLink->State=11;
            EVENT_INDICATION(INDICATE_RESET);
            pLink->Vi=REMOTE_INIT_PENDING;
            pLink->Pf=boolPollFinal;
            goto label_116_3;
    case 125:
            DLC_FRMR(0);
            pLink->Vc=0;
            goto label_116_2;
    case 126:
            SEND_ACK(pLink);
            Status=STATUS_SUCCESS;pLink->Vr+=2;
    case 148:
        label_148_1:
            AdjustWw(pLink);
            goto label_7_2;
    case 127:
        label_127_1:
            SEND_ACK(pLink);
        label_127_2:
            Status=STATUS_SUCCESS;pLink->Vr+=2;
            break;
    case 128:
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
    case 129:
//		 label_129_1:
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
        label_128_2:
            DLC_RR_RESPONSE(1);
            goto label_127_2;
    case 130:
            pLink->State=5;
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_127_1;
    case 131:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            pLink->Vc=0;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            TimerStop(&pLink->T2);
            goto label_86_1;
    case 132:
            DLC_REJ_RESPONSE(0);
            pLink->State=10;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
        label_132_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_115_2;
    case 133:
            DLC_REJ_RESPONSE(0);
        label_133_1:
            pLink->State=10;
            goto label_132_1;
    case 134:
            DLC_REJ_RESPONSE(1);
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_133_1;
    case 135:
            DLC_REJ_RESPONSE(1);
            goto label_133_1;
    case 136:
            DLC_REJ_RESPONSE(0);
            pLink->State=7;
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_132_1;
    case 137:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            pLink->Vc=0;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            TimerStop(&pLink->T2);
            goto label_86_2;
    case 138:
        label_138_1:
            ResendPackets(pLink);
            goto label_7_2;
    case 139:
            ResendPackets(pLink);
            DLC_RR_RESPONSE(1);
            pLink->Is_Ct=pLink->N2;
            goto label_115_2;
    case 140:
        label_140_1:
            TimerStop(&pLink->T2);
    case 191:
        label_191_1:
            DLC_RR_RESPONSE(1);
            break;
    case 141:
            pLink->State=5;
        label_141_1:
            UpdateVaChkpt(pLink);
        label_141_2:
            EnableSendProcess(pLink);
            break;
    case 142:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
        label_142_1:
            pLink->Vc=0;
            goto label_86_2;
    case 143:
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_148_1;
    case 144:
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_7_2;
    case 145:
            AdjustWw(pLink);
    case 146:
//		 label_146_1:
            pLink->Vb=STATE_REMOTE_BUSY;
        label_145_2:
            pLink->Is_Ct=pLink->N2;
    case 150:
        label_150_1:
            pLink->Ir_Ct=pLink->N3;
            goto label_140_1;
    case 147:
            pLink->State=12;
        label_147_1:
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            UpdateVaChkpt(pLink);
            goto label_7_2;
    case 149:
            AdjustWw(pLink);
            goto label_145_2;
    case 151:
            pLink->State=17;
        label_151_1:
            DLC_RR_RESPONSE(0);
            goto label_6_1;
    case 152:
            DLC_FRMR(0);
        label_152_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
        label_152_2:
            pLink->State=4;
            EVENT_INDICATION(INDICATE_FRMR_SENT);
        label_152_3:
            TimerStop(&pLink->T1);
            goto label_11_1;
    case 153:
            DLC_FRMR(1);
            goto label_152_1;
    case 154:
            DLC_RNR_COMMAND(1);
        label_154_1:
            DisableSendProcess(pLink);
            pLink->Vp=pLink->Vs;
            goto label_20_1;
    case 155:
            EVENT_INDICATION(INDICATE_LINK_LOST);
            goto label_1_1;
    case 157:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            goto label_152_3;
    case 158:
            TimerStart(&pLink->Ti);
            goto label_91_2;
    case 159:
            pLink->State=11;
            EVENT_INDICATION(INDICATE_RESET);
            pLink->Vi=REMOTE_INIT_PENDING;
            pLink->Pf=boolPollFinal;
            goto label_152_3;
    case 160:
            DLC_FRMR(0);
            goto label_152_2;
    case 161:
            DLC_RNR_RESPONSE(0);
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_148_1;
    case 162:
        label_162_1:
            DLC_RNR_RESPONSE(0);
    case 168:
        label_168_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            break;
    case 163:
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
    case 164:
//		 label_164_1:
            DLC_RNR_RESPONSE(1);
            goto label_168_1;
    case 165:
            pLink->State=6;
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_162_1;
    case 166:
            UpdateVaChkpt(pLink),TimerStop(&pLink->Ti),TimerStart(&pLink->T1);
        label_166_1:
            pLink->Vc=0;
            pLink->State=3;
            DLC_DISC(1);
            pLink->P_Ct=pLink->N2;
            goto label_168_1;
    case 167:
        label_167_1:
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_168_1;
    case 169:
            pLink->State=6;
        label_169_1:
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_168_1;
    case 170:
            DLC_RNR_RESPONSE(1);
            goto label_138_1;
    case 171:
        label_171_1:
            DLC_RNR_RESPONSE(1);
            break;
    case 172:
            pLink->State=6;
            goto label_141_1;
    case 173:
            UpdateVaChkpt(pLink),TimerStop(&pLink->Ti),TimerStart(&pLink->T1);
            goto label_142_1;
    case 174:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
            goto label_148_1;
    case 175:
        label_175_1:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
            goto label_7_2;
    case 176:
            AdjustWw(pLink);
    case 177:
        label_177_1:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_176_2:
            pLink->Is_Ct=pLink->N2;
            goto label_171_1;
    case 178:
            pLink->State=13;
        label_178_1:
            UpdateVaChkpt(pLink);
            goto label_175_1;
    case 179:
            AdjustWw(pLink);
            goto label_176_2;
    case 180:
            pLink->State=16;
            goto label_5_1;
    case 181:
            DLC_RR_COMMAND(1);
            goto label_154_1;
    case 182:
            pLink->State=8;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_127_1;
    case 183:
            pLink->State=8;
            goto label_127_1;
    case 184:
            pLink->State=8;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_128_2;
    case 185:
            pLink->State=8;
            goto label_128_2;
    case 186:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            goto label_166_1;
    case 187:
            DLC_RR_RESPONSE(1);
            goto label_167_1;
    case 188:
            DLC_RR_RESPONSE(1);
            goto label_168_1;
    case 189:
        label_189_1:
            pLink->State=7;
            goto label_169_1;
    case 190:
            DLC_RR_RESPONSE(1);
            goto label_138_1;
    case 192:
            pLink->State=7;
            goto label_141_1;
    case 193:
            AdjustWw(pLink);
    case 194:
//		 label_194_1:
            pLink->Vb=STATE_REMOTE_BUSY;
        label_193_2:
            pLink->Is_Ct=pLink->N2;
            goto label_191_1;
    case 195:
            pLink->State=15;
            goto label_147_1;
    case 196:
            AdjustWw(pLink);
            goto label_193_2;
    case 197:
            DLC_DM(pLink->Pf);
            EVENT_INDICATION(CONFIRM_DISCONNECT);
        label_197_1:
            pLink->Vi=0;
            goto label_54_2;
    case 198:
            pLink->Vi=0;
            goto label_53_1;
    case 199:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            goto label_197_1;
    case 200:
            pLink->Vi=0;
            TimerStart(&pLink->Ti);
            goto label_91_3;
    case 201:
            EVENT_INDICATION(INDICATE_RESET);
            goto label_9_2;
    case 202:
            pLink->State=13;
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
            goto label_115_1;
    case 203:
            pLink->State=8;
            pLink->P_Ct=pLink->N2;
            goto label_119_1;
    case 204:
            pLink->State=5;
            pLink->Vb=0;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
        label_204_1:
            UpdateVa(pLink);
            goto label_127_1;
    case 205:
            pLink->State=15;
            pLink->Ir_Ct=pLink->N3;
        label_205_1:
            DLC_REJ_RESPONSE(0);
            UpdateVa(pLink);
            TimerStop(&pLink->T2);
            goto label_168_1;
    case 206:
            pLink->State=15;
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
        label_206_1:
            UpdateVa(pLink);
        label_206_2:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_171_1;
    case 207:
            pLink->State=7;
            pLink->Vb=0;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_205_1;
    case 208:
        label_208_1:
            ResendPackets(pLink),UpdateVa(pLink);
            pLink->Is_Ct--;
        label_208_2:
            pLink->State=5;
        label_208_3:
            pLink->Vb=0;
        label_208_4:
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_141_2;
    case 209:
        label_209_1:
            UpdateVa(pLink);
            goto label_208_2;
    case 210:
            pLink->Ir_Ct=pLink->N3;
            DLC_RR_RESPONSE(1);
            TimerStop(&pLink->T2);
            goto label_208_1;
    case 211:
        label_211_1:
            DLC_RR_RESPONSE(1);
            TimerStop(&pLink->T2);
            goto label_209_1;
    case 212:
            SEND_RR_CMD(1);
            TimerStart(&pLink->T1);
            pLink->State=8;
            pLink->Vb=0;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            UpdateVa(pLink);
            goto label_150_1;
    case 213:
            pLink->Ir_Ct=pLink->N3;
            goto label_211_1;
    case 214:
            pLink->State=8;
        label_214_1:
            TimerStart(&pLink->T1);
            pLink->Vb=0;
            DLC_RR_COMMAND(1);
        label_214_2:
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_76_1;
    case 215:
            TimerStop(&pLink->Ti);
            TimerStart(&pLink->T1);
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_82_1;
    case 216:
            pLink->State=9;
        label_216_1:
            DLC_RNR_COMMAND(1);
            goto label_87_3;
    case 217:
            ResendPackets(pLink),UpdateVa(pLink);
            pLink->Is_Ct--;
        label_217_1:
            pLink->State=6;
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_208_4;
    case 218:
            ResendPackets(pLink),UpdateVa(pLink);
            pLink->State=6;
            pLink->Is_Ct--;
            pLink->Vb=STATE_LOCAL_BUSY;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            EnableSendProcess(pLink);
            goto label_171_1;
    case 219:
            pLink->State=9;
        label_219_1:
            UpdateVa(pLink),SEND_RNR_CMD(1);
            TimerStart(&pLink->T1);
        label_219_2:
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_171_1;
    case 220:
            pLink->State=6;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            EnableSendProcess(pLink);
            UpdateVa(pLink);
            goto label_219_2;
    case 221:
            DLC_RNR_COMMAND(1);
            pLink->State=9;
            TimerStart(&pLink->T1);
        label_221_1:
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_214_2;
    case 222:
            UpdateVa(pLink);
            goto label_217_1;
    case 223:
            TimerStop(&pLink->Ti);
            pLink->Vb=0;
            goto label_104_1;
    case 224:
            pLink->State=16;
            goto label_85_1;
    case 225:
            pLink->State=16;
            goto label_87_1;
    case 226:
            TimerStop(&pLink->T1);
            goto label_55_1;
    case 227:
            pLink->State=6;
            UpdateVa(pLink);
            goto label_162_1;
    case 228:
            pLink->State=6;
            goto label_206_1;
    case 229:
        label_229_1:
            ResendPackets(pLink),UpdateVa(pLink);
            break;
    case 230:
            DLC_RNR_RESPONSE(1);
            goto label_229_1;
    case 231:
            pLink->State=19;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            goto label_97_2;
    case 232:
            pLink->State=19;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            DisableSendProcess(pLink);
            UpdateVa(pLink);
            goto label_177_1;
    case 233:
            pLink->State=19;
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_233_1:
            DLC_RNR_RESPONSE(0);
            break;
    case 234:
            DLC_RR_COMMAND(1);
            pLink->State=10;
            goto label_87_3;
    case 235:
            pLink->State=12;
            goto label_204_1;
    case 236:
            pLink->State=12;
            Status=STATUS_SUCCESS;pLink->Vr+=2;
            UpdateVa(pLink);
            goto label_191_1;
    case 237:
        label_237_1:
            pLink->State=7;
            pLink->Vb=0;
        label_237_2:
            pLink->Is_Ct--;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            EnableSendProcess(pLink);
            goto label_229_1;
    case 238:
            DLC_RR_RESPONSE(1);
            goto label_237_1;
    case 239:
            UpdateVa(pLink),SEND_RR_CMD(1);
            TimerStart(&pLink->T1);
            pLink->Vb=0;
            pLink->State=10;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_191_1;
    case 240:
            DLC_RR_RESPONSE(1);
    case 242:
//		 label_242_1:
            pLink->State=7;
            UpdateVa(pLink);
            goto label_208_3;
    case 241:
            pLink->State=10;
            goto label_214_1;
    case 243:
            pLink->State=18;
            DLC_RR_RESPONSE(0);
    case 264:
        label_264_1:
            pLink->Vb=STATE_REMOTE_BUSY;
            break;
    case 244:
            pLink->State=18;
            goto label_151_1;
    case 245:
            pLink->State=9;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
        label_245_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_233_1;
    case 246:
            pLink->State=9;
            goto label_245_1;
    case 247:
            pLink->State=9;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_206_2;
    case 248:
            pLink->State=9;
            goto label_206_2;
    case 249:
            pLink->State=14;
            goto label_169_1;
    case 250:
        label_250_1:
            ResendPackets(pLink);
            break;
    case 251:
            DLC_RNR_RESPONSE(1);
            goto label_250_1;
    case 252:
            pLink->Vs=pLink->Nr;
            pLink->State=14;
            goto label_141_1;
    case 253:
            pLink->State=19;
            goto label_178_1;
    case 254:
            UpdateVaChkpt(pLink),TimerStop(&pLink->Ti),TimerStart(&pLink->T1);
            pLink->Vc=0;
            pLink->State=3;
            DLC_DISC(1);
            pLink->P_Ct=pLink->N2;
            goto label_264_1;
    case 255:
        label_255_1:
            AdjustWw(pLink);
            break;
    case 256:
            pLink->State=14;
            UpdateVaChkpt(pLink);
            goto label_208_4;
    case 257:
            pLink->State=9;
        label_257_1:
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_233_1;
    case 258:
            DLC_REJ_RESPONSE(0);
    case 268:
        label_268_1:
            pLink->State=10;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            pLink->Is_Ct=pLink->N2;
            goto label_255_1;
    case 259:
            DLC_REJ_RESPONSE(0);
    case 269:
        label_269_1:
            pLink->State=10;
            goto label_168_1;
    case 260:
            DLC_REJ_RESPONSE(1);
            goto label_268_1;
    case 261:
            DLC_REJ_RESPONSE(1);
            goto label_269_1;
    case 262:
            DLC_REJ_RESPONSE(0);
            goto label_189_1;
    case 263:
            pLink->Vp=pLink->Nr;
        label_263_1:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            pLink->State=8;
        label_263_2:
            DLC_RR_COMMAND(1);
            break;
    case 265:
            DLC_RR_RESPONSE(1);
            goto label_264_1;
    case 266:
            pLink->Vp=pLink->Vs;
            goto label_263_1;
    case 267:
            pLink->State=16;
            goto label_257_1;
    case 270:
            DLC_RR_RESPONSE(1);
            goto label_268_1;
    case 271:
            DLC_RR_RESPONSE(1);
            goto label_269_1;
    case 272:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1),pLink->Vp=pLink->Nr;
            pLink->Is_Ct--;
        label_272_1:
            pLink->State=10;
            goto label_263_2;
    case 273:
            pLink->Is_Ct=pLink->N2;
    case 274:
//		 label_274_1:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1),pLink->Vp=pLink->Vs;
            goto label_272_1;
    case 275:
            TimerStop(&pLink->Ti);
            pLink->Vb=STATE_REMOTE_BUSY;
            pLink->Vp=pLink->Vs;
            TimerStart(&pLink->T1);
            pLink->P_Ct=pLink->N2;
            goto label_272_1;
    case 276:
            pLink->State=16;
            goto label_216_1;
    case 277:
            pLink->State=13;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            UpdateVa(pLink);
            goto label_245_1;
    case 278:
            pLink->State=13;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_206_1;
    case 279:
        label_279_1:
            pLink->State=14;
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_237_2;
    case 280:
            DLC_RNR_RESPONSE(1);
            goto label_279_1;
    case 281:
        label_281_1:
            pLink->State=14;
            goto label_76_1;
    case 282:
            pLink->State=19;
        label_282_1:
            UpdateVa(pLink);
            goto label_171_1;
    case 283:
            pLink->State=16;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_219_1;
    case 284:
            pLink->State=14;
            pLink->Vb=STATE_LOCAL_BUSY;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_282_1;
    case 285:
            pLink->State=16;
            DLC_RNR_COMMAND(1);
            goto label_221_1;
    case 286:
            pLink->Vb=STATE_LOCAL_BUSY;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_281_1;
    case 287:
            pLink->P_Ct--;
            goto label_11_1;
    case 288:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_105_1;
    case 289:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_53_2;
    case 290:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_54_2;
    case 291:
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            break;
    };
#endif

//#########################################################################

    //************************* CODE BEGINS ***************************
    //
    // Check first, if we have any events; FRMR data must be setup
    // before we can send or queue the FRMR response/command
    // frame (the status is OK whenever uchSendId != 0)
    //

    if (uchSendId != 0) {
        Status = SendLlcFrame(pLink, uchSendId);
    }

    //
    // Dynamic timer value: DLC maintains a dynamic value for the response
    // timer based on the average response times of the last poll commands.
    // This code calculates new timer values, if the last response time
    // is very different from the old values.
    // (By the way, is the reading of the absolute timer tick MP safe?,
    // it must be, otherwise you cannot implement a MP system).
    // And: 32000 * 40 ms = ~20 minutes, much longer than any sensible T1.
    //
    // What should actually happen:
    //
    //     Average Poll response time:     Response delay added to T1 and Ti:
    //
    //     40 ms                           0
    //     80 ms                           16 * 40 = 640 ms
    //     120 ms                          16 * 40 = 640 ms
    //     160 ms                          32 * 40 = 1280 ms
    //     200 ms                          32 * 40 = 1280 ms
    //     240 ms                          48 * 40 = 1920 ms
    //     ...
    //
    //     We use big jumps to avoid to the timer reinitialization
    //     after every checkpointing state.  The algorithm should react
    //     immediately, if the reponse time is raising very fast, but
    //     the lowering of reponse time is based on sliding average
    //     of the most recent response times.
    //     We have used local hardcoded number 8 and mask 0xfff0 to make
    //     this algorithm more readable (but more difficult to maintain).
    //

    if ((pLink->Flags & DLC_WAITING_RESPONSE_TO_POLL)
    && !(SecondaryStates[pLink->State] & LLC_CHECKPOINTING)) {

        SHORT LastResponseTime;
        USHORT NewAve;

        LastResponseTime = (SHORT)((USHORT)AbsoluteTime - pLink->LastTimeWhenCmdPollWasSent);

        if (LastResponseTime < 0) {
            LastResponseTime += (SHORT)0x8000;
        }
        LastResponseTime *= 8;          // Magic multiplier

        //
        // We use simple sliding average to lower the reponse time,
        // where the newest reponse values has the highest weigth (12,5%).
        // But we must also be able to raise immediately the response time,
        // when the reponse time starts to grow.  Thus the actual
        // response value is maximum of sliding average and last reponse
        // time.  The 40 ms resonse time is to notified, because it is
        // a statistical thing.
        //

        NewAve = (USHORT)((pLink->AverageResponseTime * 7 + LastResponseTime) / 8);
        NewAve = (NewAve > (USHORT)LastResponseTime ? NewAve : LastResponseTime);

        pLink->Flags &= ~DLC_WAITING_RESPONSE_TO_POLL;

        //
        // The first poll query overrides always the constant initial value.
        //

        if (pLink->Flags & DLC_FIRST_POLL) {
            pLink->Flags &= ~DLC_FIRST_POLL;
            NewAve = LastResponseTime;
        }

        //
        // We don't want to trigger too easily the reinitialization
        // of the timers, because it's quite costly operation to be
        // done in every poll.
        // Otherwise we would reinitialize timer after every time, when
        // a poll is sent just before the main timer tick expires.
        // (This is not actually a good solution, because
        // the timers are reinitialized whenever r/16 changes.
        // The same mask is used in the timer initialisation
        //

        if ((NewAve & 0xfff0) != (pLink->AverageResponseTime & 0xfff0)) {
            pLink->AverageResponseTime = NewAve;
            InitializeLinkTimers(pLink);
        } else {
            pLink->AverageResponseTime = NewAve;
        }
    }

    //
    // Now we must release the locks when we call the upper levels which may
    // call back to this data link. Note that we kept the link closed during
    // send, because the order of the sent packet must not be changed
    //

    if (pLink->DlcStatus.StatusCode != 0) {
//        if (Status == DLC_STATUS_SUCCESS) {
//
//            PADAPTER_CONTEXT pContext = pLink->Gen.pAdapterContext;

            SaveStatusChangeEvent(pLink,
                                  pLink->Gen.pAdapterContext->pLookBuf,
                                  boolResponse
                                  );
//        } else {
//            pLink->DlcStatus.StatusCode = 0;
//        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcsmsb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcsmsb.c

Abstract:

    The module implements the subroutines used by a IEEE 802.2
    compatible state machine.

    To understand the procedure of this module, you should read
    Chapters 11 and 12 in IBM Token-Ring Architecture Reference.

    The procedures in this module can be called only when
    SendSpinLock is set.

    Contents:
        SaveStatusChangeEvent
        ResendPackets
        UpdateVa
        UpdateVaChkpt
        AdjustWw
        SendAck
        QueueCommandCompletion
        (DynamicWindowAlgorithm)

Author:

    Antti Saarenheimo (o-anttis) 23-MAY-1991

Revision History:

--*/

#include <llc.h>

//
// private prototypes
//

VOID
DynamicWindowAlgorithm(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    );


//
// functions
//

VOID
SaveStatusChangeEvent(
    IN PDATA_LINK pLink,
    IN PUCHAR puchLlcHdr,
    IN BOOLEAN boolResponse
    )

/*++

Routine Description:

    Procedure saves Status Change event of the link to the event queue.
    to be indicated later to upper protocol.

Arguments:

    pLink - LLC link station object

    puchLlcHdr - the received LLC header

    boolResponse - flag set if the received frame was response

Return Value:

    None

--*/

{
    UINT Event;
    PEVENT_PACKET pEvent;
    PVOID hClientHandle;
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Set the ethernet header length (== type) the same as
    // in the current receive frame, that was either the first SABME or
    // any response to it, that opened the link connection.
    //

    if ((pLink->DlcStatus.StatusCode & (CONFIRM_CONNECT | LLC_INDICATE_CONNECT_REQUEST))
    && pAdapterContext->RcvLanHeaderLength != pLink->cbLanHeaderLength
    && pLink->Gen.pLlcBinding->EthernetType == LLC_ETHERNET_TYPE_AUTO) {
        pLink->cbLanHeaderLength = (UCHAR)pLink->Gen.pAdapterContext->RcvLanHeaderLength;
    }

    //
    // Handle first the disconnect/connect complete
    //

    if (pLink->DlcStatus.StatusCode & (CONFIRM_CONNECT | CONFIRM_DISCONNECT | CONFIRM_CONNECT_FAILED)) {

        //
        // We cannot indicate any events to non-existing stations
        //

        if (pLink->Gen.hClientHandle != NULL) {
            if (pLink->DlcStatus.StatusCode & CONFIRM_DISCONNECT) {
                 QueueCommandCompletion((PLLC_OBJECT)pLink,
                                        LLC_DISCONNECT_COMPLETION,
                                        STATUS_SUCCESS
                                        );
            }
            if (pLink->DlcStatus.StatusCode & (CONFIRM_CONNECT | CONFIRM_CONNECT_FAILED)) {

                UINT Status;

                if (pLink->DlcStatus.StatusCode & CONFIRM_CONNECT) {

                    //
                    // Set the T1 timeout for the first checkpointing state.
                    // This value will be changed when we have got the response
                    // to the first poll, but the initial value is big to
                    // be able to run DLC over a WAN connection
                    //

                    pLink->AverageResponseTime = 100;  // 100 * 40 = 4 seconds
                    pLink->Flags |= DLC_FIRST_POLL;
                    InitializeLinkTimers(pLink);
                    Status = STATUS_SUCCESS;
                } else {
                    Status = DLC_STATUS_CONNECT_FAILED;
                }
                QueueCommandCompletion((PLLC_OBJECT)pLink,
                                        LLC_CONNECT_COMPLETION,
                                        Status
                                        );
            }
        }
        pLink->DlcStatus.StatusCode &= ~(CONFIRM_CONNECT | CONFIRM_DISCONNECT | CONFIRM_CONNECT_FAILED);
    }

    if (pLink->DlcStatus.StatusCode != 0) {
        if (pLink->DlcStatus.StatusCode & INDICATE_FRMR_SENT) {

#if LLC_DBG
            PrintLastInputs("FRMR SENT!\n", pLink);
#endif

            pLink->DlcStatus.FrmrData.Command = puchLlcHdr[2];
            pLink->DlcStatus.FrmrData.Ctrl = puchLlcHdr[3];
            if ((pLink->DlcStatus.FrmrData.Command & LLC_S_U_TYPE_MASK) == LLC_U_TYPE) {
                pLink->DlcStatus.FrmrData.Ctrl = 0;
            }
            pLink->DlcStatus.FrmrData.Vs = pLink->Vs;
            pLink->DlcStatus.FrmrData.Vr = pLink->Vr | boolResponse;
        } else if (pLink->DlcStatus.StatusCode & INDICATE_FRMR_RECEIVED) {

#if LLC_DBG
            PrintLastInputs("FRMR RECEIVED!\n", pLink);
            DbgBreakPoint();
#endif

            LlcMemCpy(&pLink->DlcStatus.FrmrData,
                      &puchLlcHdr[3],
                      sizeof(LLC_FRMR_INFORMATION)
                      );
        }

        //
        // A remote connect request may have created a link station
        // in link driver.  The upper protocol must be able to separate
        // sap handle from the data link
        //

        if (pLink->Gen.hClientHandle == NULL) {

            //
            // Indicate the event on the sap, because the upper protocol
            // has not yet any link station create for this link, because
            // it has been created remotely.
            //

            hClientHandle = pLink->pSap->Gen.hClientHandle,
            Event = LLC_STATUS_CHANGE_ON_SAP;
        } else {

            //
            // Indicate the event on the link station
            //

            hClientHandle = pLink->Gen.hClientHandle,
            Event = LLC_STATUS_CHANGE;
        }

        //
        // The indications of the received SABMEs must be queued,
        // but all other events are indicated directy to
        // the upper protocol, because those indications must never
        // be lost because of an out of memory condition.
        //

        if (pLink->DlcStatus.StatusCode & INDICATE_CONNECT_REQUEST) {

            pEvent = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

            if (pEvent != NULL) {
                LlcInsertTailList(&pAdapterContext->QueueEvents, pEvent);
                pEvent->pBinding = pLink->Gen.pLlcBinding;
                pEvent->hClientHandle = hClientHandle;
                pEvent->Event = Event;
                pEvent->pEventInformation = (PVOID)&pLink->DlcStatus;

                //
                // RLF 11/18/92
                //
                // INDICATE_CONNECT_REQUEST is generated when we receive a
                // SABME for a station in the DISCONNECTED state. However,
                // we need to generate either INDICATE_CONNECT_REQUEST (0x0400)
                // or INDICATE_RESET (0x0800) depending on whether the SABME
                // created the link station or whether it was created by a
                // DLC.OPEN.STATION at this end. pLink->RemoteOpen is TRUE if
                // the link was created due to receipt of the SABME
                // This routine is only called by RunStateMachine and
                // INDICATE_CONNECT_REQUEST is never combined with any other
                // status codes
                //

                //pEvent->SecondaryInfo = pLink->DlcStatus.StatusCode;
                pEvent->SecondaryInfo = pLink->RemoteOpen
                                            ? INDICATE_CONNECT_REQUEST
                                            : INDICATE_RESET;
            }
        } else {

            //
            // We must do this with a locked SendSpinLock, because
            // otherwise somebody might delete the link, while
            // we are still using it.
            // THIS IS ACTAULLY QUITE DIRTY (callback with locked
            // spinlocks), BUT WE CANNOT USE THE PACKET POOLS WHEN
            // WE INDICATE AN EVENT, THAT MUST NOT BE LOST!
            //

            pLink->Gen.pLlcBinding->pfEventIndication(
                pLink->Gen.pLlcBinding->hClientContext,
                hClientHandle,
                Event,
                (PVOID)&pLink->DlcStatus,
                pLink->DlcStatus.StatusCode
                );
        }

        //
        // We must cancel all queued transmit commands, if the link
        // is lost, disconnected or reset.
        //

        if (pLink->DlcStatus.StatusCode
            & (INDICATE_LINK_LOST
            | INDICATE_DM_DISC_RECEIVED
            | INDICATE_FRMR_RECEIVED
            | INDICATE_FRMR_SENT
            | INDICATE_RESET)) {

            CancelTransmitCommands((PLLC_OBJECT)pLink, DLC_STATUS_LINK_NOT_TRANSMITTING);
        }

        //
        // Reset the status code!
        //

        pLink->DlcStatus.StatusCode = 0;
    }
}


VOID
ResendPackets(
    IN OUT PDATA_LINK pLink     // data link strcuture
    )

/*++

Routine Description:

    Function initializes the send process to resend the rejected
    packets and resets the adaptive working window variables.
    The operations defined in IBM state machine are:
    Vs=Nr, Ww=1, Ia_Ct=0, but this also resorts the packet queue.


Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;


    //
    // Complete all frames, that were acknowledged by the reject (if any)
    //

    if (pLink->Nr != pLink->Va) {
        DynamicWindowAlgorithm(pLink);
    }

    if ( (pLink->Vs != pLink->VsMax) &&
         (((pLink->Vs < pLink->VsMax) && (pLink->Nr >= pLink->Vs) && 
           (pLink->Nr <= pLink->VsMax)
          ) ||
          (!((pLink->Vs > pLink->VsMax) && (pLink->Nr > pLink->VsMax) &&
            (pLink->Nr < pLink->Vs))
          )
         )
       )
    {
        return;
    }

    //
    // Move all rejected packets from the queue sent packets back
    // to the send queue.  We have already completed all acknowledged
    // packets => we can take the packet from the tail and put them
    // to the head of the send queue.
    // We can trust, that the reject window is correct, because
    // Nr has been checked before the state machine was called.
    // (note: the counters are a modulo 256, but we use bytes).
    //

    for (;pLink->Vs != pLink->Nr; pLink->Vs -= 2) {

        PLLC_PACKET pPacket;

        if (!IsListEmpty(&pLink->SentQueue) ){

            pLink->Statistics.I_FrameTransmissionErrors++;
            if (pLink->Statistics.I_FrameTransmissionErrors == 0x80) {
                pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
            }

            pPacket = (PLLC_PACKET)LlcRemoveTailList(&pLink->SentQueue);

            LlcInsertHeadList(&pLink->SendQueue.ListHead, pPacket);

        }
    }

    //
    // The procedure starts the send process only if it has been
    // enabled by the state machine. Only StartSendProcessLocked
    // may start the process, if it has been locked by
    // StopSendProcess
    //

    StartSendProcess(pAdapterContext, pLink);

    //
    // Reset the current window (Vs=Nr, Ww=1, Ia_Ct=0)
    //

    pLink->Ww = 2;
    pLink->Ia_Ct = 0;
}


VOID
UpdateVa(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    )

/*++

Routine Description:

   Function updates Va (last valid Nr received) and
   makes also some other actions needed in the normal
   receive operations.

Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    //
    // Reset the initilization state variable
    //

    pLink->Vi = 0;

    //
    // Update the receive state variable Va (the last valid received
    // frame), but update some Ww variables before that.
    //

    if (pLink->Nr != pLink->Va) {
        DynamicWindowAlgorithm(pLink);

        //
        // T1 reply timer must be running as far as there are
        // out (or sent) any unacknowledged frames.
        // Ti timer must be stopped whenever T1 is running and vice versa
        //

        if (pLink->Nr != pLink->Vs) {

            //
            // There still are some unacknowledged frames,
            // start or restart the reply timer.
            //

            StartTimer(&pLink->T1);     // reply timer
            StopTimer(&pLink->Ti);
        } else {

            //
            // All sent frames have been acknowledged,
            // => We may stop the reply timer.
            //

            StopTimer(&pLink->T1);     // reply timer
            StartTimer(&pLink->Ti);
        }

        //
        // Reset the I- frame retry counter whenever we do
        // any kind of progress
        //

        pLink->Is_Ct = pLink->N2;
    }
}


VOID
UpdateVaChkpt(
    IN OUT PDATA_LINK pLink     // data link station strcuture
    )

/*++

Routine Description:

   Function updates Va (last valid Nr received) and
   makes also some other actions needed in the check
   point receive operations.

Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    UCHAR OrginalWw = pLink->Ww;

    //
    // Reset the initilization state variable
    //

    pLink->Vi = 0;

    //
    // Update the receive state variable Va (the last valid received
    // frame), but update the acknowledged frames counter before that.
    // That counter is used by the Adaptive window algorithm.
    //

    if (pLink->Nr != pLink->Va) {

        //
        // Run adaptive transmit window (TW/T1) algorithm.
        //

        if (pLink->Ww == pLink->TW) {

            //
            // Update the counters of adaptive transmit window algorithm,
            // We need (LLC_MAX_T1_TO_I_RATIO/2) successful transmit using
            // the full window size, before we again try increase the
            // maximum transmit window size.
            //

            pLink->FullWindowTransmits += pLink->Ww;
            if ((UINT)pLink->FullWindowTransmits >= LLC_MAX_T1_TO_I_RATIO) {
                pLink->FullWindowTransmits = 2;
                if (pLink->TW < pLink->MaxOut) {
                    pLink->TW += 2;
                }
            }
        }
        DynamicWindowAlgorithm(pLink);

        //
        // Reset the I- frame and Poll retry counters whenever
        // we do any kind of progress with the acknowledged I-frames.
        //

        pLink->P_Ct = pLink->N2;
        pLink->Is_Ct = pLink->N2;
    }

    //
    // Stop the reply timer, if we are not waiting
    // anything else from the other side.
    //

    if (pLink->Nr != pLink->Vs) {

        //
        // There still are some unacknowledged frames,
        // start or restart the reply timer.
        //

        StartTimer(&pLink->T1);     // reply timer
        StopTimer(&pLink->Ti);
    } else {

        //
        // All sent frames have been acknowledged,
        // => We may stop the reply timer.
        //

        StopTimer(&pLink->T1);     // reply timer
        StartTimer(&pLink->Ti);
    }

    //
    // Bugfix in 3-3-1992, Vp (!= pLInk->Vp) seems to be wrong here,
    // because in many cases it is not set when a checkpointing state is
    // entered.  In the chekpointing state Vs=Vp, because the
    // send process is always stopped in our implementation,
    // when a checkpointing state is entered.
    // Why do we actually need the Vp? A: It's needed to prevent
    // forever looping between chekpointing and open states.
    //

    if (pLink->Nr != pLink->Vs) {

        //
        // We use a very simple adaptive transmit window (TW/T1) algorithm:
        //
        //     TW is set the same as the last successful Working window
        //     size (Ww), whenever T1 has been lost.  We increase TW after
        //     a constant number of full window transmits.
        //
        // The more complicated TW/T1 algorithms usually work worse
        // produce more code and decrease the performace, but this algorithm
        // is quite vulnerable to unreliable media (=> TW=1, a lot of T1
        // timeouts).  A better algorithm could also try to increase TW,
        // if the ratio of T1 timeouts to transferred I- frames increases
        // when the TW is decreased.  I will leave this matter to my
        // successors (AS 19-MAR-1992).
        //
        // Another problem in this algorithm is the too fast increasing
        // of big working windows (Ww).  In that case Ww is incremented by
        // more than 1 => the other side may lose I-frames before I-c1.
        // This is not very serious situation, we reset working window to 1
        // and start it again.
        //

        //
        // Update the transmit window always after a T1 timeout.
        //

        if (pLink->P_Ct < pLink->N2) {

            //
            // Reset the maximum transmit window size whenever
            // we have lost the last I-C1 (poll).
            // In the first time the current windows size
            // becomes the maximum windows size (we never hit
            // the maximum tranmit window size, if the other
            // size have receive problems).  This algorithm assumes,
            // that we have otherwise very reliable network.
            //

            if (OrginalWw > 2) {
                pLink->TW = (UCHAR)(OrginalWw - 2);
            } else if (pLink->TW > 2) {

                //
                // We may have already reset Ww because of REJ of a
                // I-c0 before the actual poll, that was lost also.
                // In that case we don't have any idea of the actual
                // window size, but we decrement TW in any case.
                //

                pLink->TW -= 2;
            }
            pLink->FullWindowTransmits = 2;
        }
        ResendPackets(pLink);
    }
}


VOID
AdjustWw(
    IN OUT PDATA_LINK pLink    // data link strcuture
    )

/*++

Routine Description:

    Procedure adjust the working window of a data link station.

Arguments:

    pLink - LLC link station object

    Nr - NR of the received LLC LDPU

Return Value:

    None

--*/

{
    //
    // Update the receive state variable Va (the last valid received
    // frame), but update some Ww variables before that.
    //

    if (pLink->Nr != pLink->Va) {
        DynamicWindowAlgorithm(pLink);

        //
        // Reset the I- frame and Poll retry counters whenever
        // we do any kind of progress with the acknowledged I-frames.
        //

        pLink->P_Ct = pLink->N2;
        pLink->Is_Ct = pLink->N2;
    }
}


VOID
SendAck(
    IN OUT PDATA_LINK pLink
    )

/*++

Routine Description:

    Procedure sends the ack, if the received unacknowledged frames
    counter expires and stops the acknowledge delay timer (T2).
    Otherwise it start (or restarts) the acknowledge delay timer.

Arguments:

    pLink - LLC link station object

Return Value:

    Returns the token of the next sent command frame.

--*/

{
    pLink->Ir_Ct--;
    if (pLink->Ir_Ct == 0) {
        pLink->Ir_Ct = pLink->N3;      // MaxIn
        StopTimer(&pLink->T2);

        //
        // Send RR-r0 to acknowledge the response
        //

        SendLlcFrame(pLink, (UCHAR)DLC_RR_TOKEN);
    } else {
        StartTimer(&pLink->T2);
    }
}


VOID
QueueCommandCompletion(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN UINT Status
    )

/*++

Routine Description:

    The function queues a command completion (if there was an allcoated
    packet in the completion queue).

Arguments:

    pLlcObject      - LLC object (link, sap or direct)
    CompletionCode  - command completion code returned to upper protocol
    Status          - returned status

Return Value:

    None -

--*/

{
    PLLC_PACKET *ppPacket;

    //
    // Search the command from the completion list.
    // (use the "address of address" scanning to take the
    // searched element from the middle of one way linked list)
    //

    ppPacket = &pLlcObject->Gen.pCompletionPackets;
    while (*ppPacket != NULL
    && (*ppPacket)->Data.Completion.CompletedCommand != CompletionCode) {
        ppPacket = &(*ppPacket)->pNext;
    }
    if (*ppPacket != NULL) {

        PLLC_PACKET pPacket = *ppPacket;

        *ppPacket = pPacket->pNext;

        pPacket->pBinding = pLlcObject->Gen.pLlcBinding;
        pPacket->Data.Completion.Status = Status;
        pPacket->Data.Completion.CompletedCommand = CompletionCode;
        pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle;

#if LLC_DBG
        pPacket->pNext = NULL;
#endif
        LlcInsertTailList(&pLlcObject->Gen.pAdapterContext->QueueCommands, pPacket);
    }
}


VOID
DynamicWindowAlgorithm(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    )

/*++

Routine Description:

   The function runs the dynamic window algorithm and updates
   the dynamic window size of used by the link's send process.
   This routine also completes the acknowledged transmissions.

Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    PADAPTER_CONTEXT pAdapterContext;

    //
    // Run Dynamic Window algorithm of IBM TR Architecture Ref:
    //
    // if (Working window less that the maximum window)
    // then
    //     The Acknowledged frame count += The acknowledged frames
    //
    //     if (The Acknowledged frame count >
    //         packets to be aknowledged before next increment)
    //     then
    //         Increment the working window
    //     endif
    // endif
    //

    if (pLink->Ww < pLink->TW) {

        //
        // The Acknowledged frame count += The acknowledged frames
        // (handle the wrap around of UCHAR counters)
        //

        if (pLink->Va > pLink->Nr) {
            pLink->Ia_Ct += (256 + pLink->Nr) - pLink->Va;
        } else {
            pLink->Ia_Ct += pLink->Nr - pLink->Va;
        }

        //
        // if (The Acknowledged frame count
        //     > packets to be aknowledged before next increment)
        // then
        //     Increment the working window
        // endif
        //

        if (pLink->Ia_Ct > pLink->Nw) {

            USHORT usWw;

            usWw = (USHORT)(pLink->Ww + (pLink->Ia_Ct / pLink->Nw) * 2);
            pLink->Ia_Ct = pLink->Ia_Ct % pLink->Nw;
            if (usWw > pLink->TW) {
                pLink->Ww = pLink->TW;
            } else {
                pLink->Ww = (UCHAR)usWw;
            }
        }
    }

    //
    // Complete all acknowledged I-frame packets
    //

    pAdapterContext = pLink->Gen.pAdapterContext;
    for (; pLink->Va != pLink->Nr; pLink->Va += 2) {

        PLLC_PACKET pPacket;

        MY_ASSERT(!IsListEmpty(&pLink->SentQueue));

        if (IsListEmpty(&pLink->SentQueue)) {
           return;
        }

        pPacket = LlcRemoveHeadList(&pLink->SentQueue);

        pPacket->Data.Completion.Status = STATUS_SUCCESS;
        pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
        pPacket->Data.Completion.hClientHandle = pPacket->Data.Xmit.pLlcObject->Gen.hClientHandle;

        //
        // We use extra status bits to indicate, when I- packet has been both
        // completed by NDIS and acknowledged by the other side of the link
        // connection. An I- packet can be queued to the completion queue by
        // the second quy (either state machine or SendCompletion handler)
        // only when the first guy has set completed its work.
        // An I packet could be acknowledged by the other side before
        // its completion is indicated by NDIS.  Dlc Driver deallocates
        // the packet immediately, when Llc driver completes the acknowledged
        // packet => possible data corruption (if packet is reused before
        // NDIS has completed it).  This is probably not possible in a
        // single processor  NT- system, but very possible in multiprocessor
        // NT or systems without a single level DPC queue (like OS/2 and DOS).
        //

        pPacket->CompletionType &= ~LLC_I_PACKET_UNACKNOWLEDGED;
        if (pPacket->CompletionType == LLC_I_PACKET_COMPLETE) {
            LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
        }

        //
        // Increment counter, when the I- frame has
        // succesfully received and acknowledged by the other side.
        // We must also send status changes indication, when
        // the USHORT counter hits the half way.
        //

        pLink->Statistics.I_FramesTransmitted++;
        if (pLink->Statistics.I_FramesTransmitted == 0x8000) {
            pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
        }
        pLink->pSap->Statistics.FramesTransmitted++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llctyp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dltyp.h

Abstract:

    This module includes all internal typedefs and constats
    of data link driver.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

#include "refcnt.h"

//
// Design notes:
//     All data structures are designed at first for
//     multiple clients to make the interface very clean.
//     This implements also a simple kernel level interface
//     of data link layer to be used by somebody that needs it.
//


struct _LLC_NDIS_PACKET;
typedef struct _LLC_NDIS_PACKET LLC_NDIS_PACKET, *PLLC_NDIS_PACKET;

struct _LLC_SAP;
typedef struct _LLC_SAP LLC_SAP, *PLLC_SAP;

struct _DATA_LINK;
typedef struct _DATA_LINK DATA_LINK, *PDATA_LINK;

struct _ADAPTER_CONTEXT;
typedef struct _ADAPTER_CONTEXT ADAPTER_CONTEXT, *PADAPTER_CONTEXT;

//
// LLC_GENERIC_OBJECT - these fields are common in all LLC objects
//

struct _LLC_GENERIC_OBJECT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // pointer to singly-linked list of same-type structures
    //

    PLLC_OBJECT pNext;

    //
    // ObjectType - SAP, DIRECT or LINK
    //

    UCHAR ObjectType;

    //
    // EthernetType - if we have opened the adapter binding in AUTO mode then
    // for SAPs and Link Stations we need to determine whether to talk 802.3
    // or DIX
    //

    UCHAR EthernetType;

    //
    // usReserved - just aligns to DWORD (not necessary)
    //

    USHORT usReserved;
    PADAPTER_CONTEXT pAdapterContext;
    PBINDING_CONTEXT pLlcBinding;

    //
    // hClientHandle - handle to LINK object in upper layer
    //

    PVOID hClientHandle;
    PLLC_PACKET pCompletionPackets;
    ULONG ReferenceCount;
};

typedef struct _LLC_GENERIC_OBJECT LLC_GENERIC_OBJECT, *PLLC_GENERIC_OBJECT;

//
// LLC_U_RESPONSE - LLC header for U-type response frame
//

typedef struct _LLC_U_RESPONSE {
    UCHAR Dsap;     // Destination Service Access Point.
    UCHAR Ssap;     // Source Service Access Point.
    UCHAR Command;  // command code.
    UCHAR Info[1];  // respomse table
} LLC_U_RESPONSE, *PLLC_U_RESPONSE;

//
// QUEUE_PACKET - generic doubly-linked list header
//

typedef struct _QUEUE_PACKET {
    struct _QUEUE_PACKET* pNext;
    struct _QUEUE_PACKET* pPrev;
} QUEUE_PACKET, *PQUEUE_PACKET;

//
// LLC_QUEUE -
//

typedef struct _LLC_QUEUE {
    LIST_ENTRY ListEntry;
    LIST_ENTRY ListHead;    // the list head
    PVOID pObject;          // owner handle (used if element is linked)
} LLC_QUEUE, *PLLC_QUEUE;


//
// This information is a part of the DLC.STATISTICS
// information for a link station. The whole
// strcuture can be reseted.
//

typedef struct _LINK_STATION_STATISTICS {
    USHORT I_FramesTransmitted;
    USHORT I_FramesReceived;
    UCHAR I_FrameReceiveErrors;
    UCHAR I_FrameTransmissionErrors;
    USHORT T1_ExpirationCount;  // not in data xfer mode
} LINK_STATION_STATISTICS, *PLINK_STATION_STATISTICS;

typedef struct _SAP_STATISTICS {
    ULONG FramesTransmitted;
    ULONG FramesReceived;
    ULONG FramesDiscardedNoRcv;
    ULONG DataLostCounter;
} SAP_STATISTICS, *PSAP_STATISTICS;

struct _LLC_SAP {
    LLC_GENERIC_OBJECT Gen;
    USHORT SourceSap;           // THIS MUST OVERLAY ObjectAddress
    USHORT OpenOptions;
    SAP_STATISTICS Statistics;

    //
    // KEEP THIS SAME IN SAP STATION AND GENERIC OBJECT
    //

    DLC_LINK_PARAMETERS DefaultParameters;
    NDIS_SPIN_LOCK FlowControlLock;
    PDATA_LINK pActiveLinks;    // all link stations of this sap
};

struct _TIMER_TICK;
typedef struct _TIMER_TICK TIMER_TICK, *PTIMER_TICK;

typedef struct _LLC_TIMER {
    struct _LLC_TIMER* pNext;
    struct _LLC_TIMER* pPrev;
    PTIMER_TICK pTimerTick;
    ULONG ExpirationTime;
    PVOID hContext;

#if defined(LOCK_CHECK)

    ULONG Disabled;

#endif

} LLC_TIMER, *PLLC_TIMER;

struct _TIMER_TICK {
    struct _TIMER_TICK* pNext;
//    struct _TIMER_TICK* pPrev;
    PLLC_TIMER pFront;
    UINT DeltaTime;
    USHORT Input;
    USHORT ReferenceCount;
};

//
// DATA_LINK - these 'objects' are from a two level data storage. The hash table
// provides a very fast access to links, when there are less than 100 links
// (about 99 % of the cases). The binary tree keeps the search times still quite
// small, when there are very many connections from/to the same server.
//

struct _DATA_LINK {
    LLC_GENERIC_OBJECT Gen;

    //
    // Data link station state machine variables, *2 means the value
    // to be used as 2 increments, because modulo 256 is much easier
    // to handle than modulo 128. UCHAR wraps around automatically.
    //

    SHORT Is_Ct;        // Max number of I retries (Update_Va & xxx_Chkpt)
    USHORT Ia_Ct;       // Number of LPDU acknowledgements since Ww was incr.

    UCHAR State;        // current state of the finite state machine
    UCHAR Ir_Ct;        // LPDUs possible to send before next acknowledgement
    UCHAR Vs;           // *2, Send state variable (Ns of next sent LPDU)
    UCHAR VsMax;        // *2, Max Send state variable (Ns of next sent LPDU)
    UCHAR Vr;           // *2, Receive state variable( Nr of next sent LPDU)

    UCHAR Pf;           // value of PollFinal bit in last command
    UCHAR Va;           // *2, Last valid Nr received (ack state variable)
    UCHAR Vp;           // *2, Poll state var. (Ns of last sent cmd with P-bit)
    UCHAR Vb;           // Busy state (Vl, Vb, Vlb)

    UCHAR Vc;           // Stacked command variable (only DISC is possible)
    UCHAR Vi;           // initialization state variable

    //
    // BEGIN OF DLC_LINK_PARAMETERS (same as llc_params struct)
    // DON'T TOUCH !!!!
    //

    UCHAR TimerT1;      // Timer T1 value
    UCHAR TimerT2;      // Timer T2 value

    UCHAR TimerTi;      // Timer Ti value
    UCHAR MaxOut;       // *2, maximum transmit window size (MaxOut)
    UCHAR RW;           // maximum receive window size (MaxIn)
    UCHAR Nw;           // number of LPDUs acknowledged, before Ww is incr.)

    UCHAR N2;           // Number of retires allowed (both Polls and I LPDSs)
    UCHAR AccessPrty;   // access priority
    USHORT MaxIField;   // maximum received info field (not used in LLC)

    //
    // End of DLC_LINK_PARAMETERS
    //

    UCHAR Ww;           // *2, working window size
    UCHAR N3;           // number of I format LPDUs between acks (with Ir_Ct)
    UCHAR P_Ct;         // Poll retry count
    UCHAR Nr;           // last Nr of the received frame

    //
    // Variables needed to maintain dynamic response base time for timers.
    //

    USHORT LastTimeWhenCmdPollWasSent;
    USHORT AverageResponseTime;

    UCHAR cbLanHeaderLength;
    UCHAR VrDuringLocalBusy;
    UCHAR Flags;
    UCHAR TW;           // dynamic MaxOut value

    USHORT FullWindowTransmits; // succeeded Polls of full window xmits
    UCHAR T1_Timeouts;          // T1 timeouts after I-c1
    UCHAR RemoteOpen;

    //
    //  The link status flags contains these status bits:
    //
    //      DLC_WAITING_RESPONSE_TO_POLL
    //      DLC_FIRST_POLL
    //      DLC_ACTIVE_REMOTE_CONECT_REQUEST
    //      DLC_COMMAND_POLL_PENDING_IN_NDIS;
    //      DLC_SEND_DISABLED
    //      DLC_SEND_ACTIVE
    //      DLC_LOCAL_BUSY_BUFFER
    //      DLC_LOCAL_BUSY_USER
    //

    //
    // the timer objects
    //

    LLC_TIMER T1;
    LLC_TIMER T2;
    LLC_TIMER Ti;

    LLC_QUEUE SendQueue;    // untransmitted queue for the I frames
    LIST_ENTRY SentQueue;   // the sent but not acknowledged I- frames

    PDATA_LINK pNextNode;   // for the hash table
    LAN802_ADDRESS LinkAddr;// 64 bit lan address of the link

    PLLC_SAP pSap;          // link to the SAP object of this link

    DLC_STATUS_TABLE DlcStatus;

    //
    // Resetable link station statistics counters
    //

    LINK_STATION_STATISTICS Statistics;

    UCHAR LastCmdOrRespSent;
    UCHAR LastCmdOrRespReceived;
    UCHAR Dsap;             // Destination SAP
    UCHAR Ssap;             // Source SAP

    //
    // some link statistics (don't reset this)
    //

    ULONG BufferCommitment;

    //
    // FramingType - type of framing (802.3/DIX/don't care) that we should use
    // for this connection. Required because in AUTO mode, the actual framing
    // type may be different than that in the BINDING_CONTEXT, and since the
    // BINDING_CONTEXT is per-adapter, we cannot rely on it (this whole thing
    // is messed up)
    //

    ULONG FramingType;

    //
    // Network frame header (includes the full address information)
    //

    UCHAR auchLanHeader[1];

    //
    // LAN HEADER OVERFLOWS HERE !!!!
    //
};

typedef struct _LLC_STATION_OBJECT {
    LLC_GENERIC_OBJECT Gen;
    USHORT ObjectAddress;
    USHORT OpenOptions;
    SAP_STATISTICS Statistics;
} LLC_STATION_OBJECT, *PLLC_STATION_OBJECT;

union _LLC_OBJECT {

    //
    // KEEP THIS SAME AS DIRECT AND SAP STATIONS
    //

    LLC_GENERIC_OBJECT Gen;
    DATA_LINK Link;
    LLC_SAP Sap;
    LLC_STATION_OBJECT Group;
    LLC_STATION_OBJECT Dix;
    LLC_STATION_OBJECT Dir;
};

//*****************************************************************

typedef struct _NDIS_MAC_PACKET {
    NDIS_PACKET_PRIVATE private;
    UCHAR auchMacReserved[16];
} NDIS_MAC_PACKET;

struct _LLC_NDIS_PACKET {
    NDIS_PACKET_PRIVATE private;    // we accesss this also directly
    UCHAR auchMacReserved[16];
    PMDL pMdl;                      // MDL for LAN and LLC headers

    //
    // request handle and command completion handler are saved to
    // the packet until NDIS has completed the command
    //

    PLLC_PACKET pCompletionPacket;

#if LLC_DBG
    ULONG ReferenceCount;
#endif

    UCHAR auchLanHeader[LLC_MAX_LAN_HEADER + sizeof(LLC_U_HEADER) + sizeof(LLC_RESPONSE_INFO)];
};

typedef struct _LLC_TRANSFER_PACKET {
    NDIS_PACKET_PRIVATE private;
    UCHAR auchMacReserved[16];
    PLLC_PACKET pPacket;
} LLC_TRANSFER_PACKET, *PLLC_TRANSFER_PACKET;

typedef struct _EVENT_PACKET {
    struct _EVENT_PACKET* pNext;
    struct _EVENT_PACKET* pPrev;
    PBINDING_CONTEXT pBinding;
    PVOID hClientHandle;
    PVOID pEventInformation;
    UINT Event;
    UINT SecondaryInfo;
} EVENT_PACKET, *PEVENT_PACKET;

//
// The next structure is used only in the allocating packets to the pool
//

typedef union _UNITED_PACKETS {
    QUEUE_PACKET queue;
    EVENT_PACKET event;
    LLC_PACKET XmitPacket;
    UCHAR auchLanHeader[LLC_MAX_LAN_HEADER];
} UNITED_PACKETS, *PUNITED_PACKETS;

//
// NODE_ADDRESS - 6 byte MAC address expressed as bytes or ULONG & USHORT for
// minimal comparisons/moves on 32-bit architecture
//

typedef union {
    UCHAR Bytes[6];
    struct {
        ULONG Top4;
        USHORT Bottom2;
    } Words;
} NODE_ADDRESS, *PNODE_ADDRESS;

//
// FRAMING_DISCOVERY_CACHE_ENTRY - the solution to the LLC_ETHERNET_TYPE_AUTO
// problem (where we can end up proliferating TEST/XIDs and SABME/UAs) is to
// keep a cache of destinations we have 'ping'ed with TEST/XID/SABME. We send
// both frame types - DIX and 802.3. We indicate the first received response
// and create a cache entry, recording the remote MAC address and the framing
// type. If another response frame arrives from the cached MAC address with
// the other framing type, it is discarded
//

typedef struct {
    NODE_ADDRESS NodeAddress;   // the remote MAC address
    BOOLEAN InUse;              // TRUE if in use (could use TimeStamp == 0)
    UCHAR FramingType;          // DIX or 802.3
    LARGE_INTEGER TimeStamp;    // used for LRU throw-out
} FRAMING_DISCOVERY_CACHE_ENTRY, *PFRAMING_DISCOVERY_CACHE_ENTRY;

#define FRAMING_TYPE_DIX    0x1d    // arbitrary value
#define FRAMING_TYPE_802_3  0x83    //     "       "

//
// BINDING_CONTEXT - one of these created for each client (app/open driver
// handle instance) opening the adapter. We only perform an open adapter at
// NDIS level once, which creates the ADAPTER_CONTEXT for the NDIS open
// adapter instance. Subsequent open adapter requests from processes cause
// a BINDING_CONTEXT to be created and linked to the ADAPTER_CONTEXT
//

struct _BINDING_CONTEXT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // pointer to singly-linked list of BINDING_CONTEXT structures for this
    // ADAPTER_CONTEXT
    //

    struct _BINDING_CONTEXT* pNext;

    //
    // pointer to ADAPTER_CONTEXT structure for this BINDING_CONTEXT
    //

    PADAPTER_CONTEXT pAdapterContext;

    //
    // handle of/pointer to FILE_CONTEXT structure
    //

    PVOID hClientContext;

    //
    // pointers to command completion, receive and event indication functions
    //

    PFLLC_COMMAND_COMPLETE pfCommandComplete;
    PFLLC_RECEIVE_INDICATION pfReceiveIndication;
    PFLLC_EVENT_INDICATION pfEventIndication;

    //
    // Functional - functional address applied to this binding by the app
    //

    TR_BROADCAST_ADDRESS Functional;

    //
    // ulFunctionalZeroBits - mask of bits which should be off for functional
    // address/multicast address
    //

    ULONG ulFunctionalZeroBits;

    //
    // 0.5 second timer used for DIR.TIMER functions
    //

    LLC_TIMER DlcTimer;

    //
    // NdisMedium - the actual medium that the adapter to which we are bound talks
    //

    UINT NdisMedium;

    //
    // AddressTranslation - how the bits in addresses should be represented at
    // the top and bottom edges of LLC
    //

    USHORT AddressTranslation;

    //
    // BroadCastAddress - 6 byte broadcast address treated as USHORT and ULONG
    // entities. Used for checking promiscuous packets
    //

    USHORT usBroadcastAddress;
    ULONG ulBroadcastAddress;

    //
    // InternalAddressTranslation -
    //

    USHORT InternalAddressTranslation;

    //
    // EthernetType - value which determines the format of an Ethernet frame.
    // Different for 802.3 vs. DIX vs. ...
    //

    USHORT EthernetType;

    //
    // SwapCopiedLanAddresses - TRUE if we bit-swap LAN addresses when copying
    // up or down the layers
    //

    BOOLEAN SwapCopiedLanAddresses;

    //
    // The big substructures should be in the end
    // to produce optimal code for x86
    //

    LLC_TRANSFER_PACKET TransferDataPacket;

    //
    // FramingDiscoveryCacheEntries - maximum number of elements that can be
    // in DiscoveryFramingCache. Will be zero if the adapter is not ethernet and
    // LLC_ETHERNET_TYPE_AUTO was not requested, else number determined from
    // registry or default value. Number from registry may also be 0, indicating
    // caching is not to be used (old semantics)
    //

    ULONG FramingDiscoveryCacheEntries;

    //
    // FramingDiscoveryCache - if this EthernetType == LLC_ETHERNET_TYPE_AUTO,
    // we create a cache of destination MAC addresses and the DIX/802.3 framing
    // type they use. This array is FramingDiscoveryCacheEntries long
    //

    FRAMING_DISCOVERY_CACHE_ENTRY FramingDiscoveryCache[];
};

//
// ADAPTER_CONTEXT - the device context of an NDIS driver. It includes links to
// all dynamic data structures of the data link driver.
//
// This version does not support the group SAPs
//

#define LINK_HASH_SIZE  128

struct _ADAPTER_CONTEXT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // pointer to singly-linked list of ADAPTER_CONTEXT structures opened by
    // all clients of this driver
    //

    struct _ADAPTER_CONTEXT* pNext;

#if !defined(DLC_UNILOCK)

    NDIS_SPIN_LOCK SendSpinLock;        // locked when accessing send queues
    NDIS_SPIN_LOCK ObjectDataBase;      // used also with sap/direct create

#endif

    PLLC_STATION_OBJECT pDirectStation; // link list of direct stations
    PBINDING_CONTEXT pBindings;         // link list of all bindings
    NDIS_HANDLE NdisBindingHandle;
    PVOID hLinkPool;                    // pool for link station structs
    PVOID hPacketPool;                  // pool for usr/small LLC packets

    //
    // circular link list is free NDIS packets for send (initially maybe 5)
    //

    PLLC_NDIS_PACKET pNdisPacketPool;
    NDIS_HANDLE hNdisPacketPool;

    //
    // Some stuff for asynchronous receive indications
    //

    PVOID hReceiveCompletionRequest;
    PLLC_PACKET pResetPackets;

    //
    // pHeadBuf - pointer to the MAC header buffer, containing:
    //
    //  FDDI:
    //      1 Byte Frame Control (FDDI)
    //      6 Bytes Destination MAC Address (ALL)
    //      6 Bytes Source MAC Address (ALL)
    //
    //  Token Ring:
    //      1 Byte Access Control (Token Ring)
    //      1 Byte Frame Control (Token Ring)
    //      6 Bytes Destination MAC Address (ALL)
    //      6 Bytes Source MAC Address (ALL)
    //      0-18 Bytes Source Routing
    //
    //  Ethernet:
    //      6 Bytes Destination MAC Address (ALL)
    //      6 Bytes Source MAC Address (ALL)
    //      2 Bytes Length or DIX Type
    //

    PUCHAR pHeadBuf;

    //
    // cbHeadBuf - number of bytes in pHeadBuf
    //

    UINT cbHeadBuf;

    //
    // pLookBuf - pointer to the MAC look-ahead buffer which contains the rest
    // of the data for this frame or as much as the MAC could fit into the look
    // ahead buffer (in which case NdisTransferData must be used to get the
    // rest)
    //

    PUCHAR pLookBuf;

    //
    // cbLookBuf - number of bytes in pLookBuf
    //

    UINT cbLookBuf;

    //
    // cbPacketSize - actual size of the whole frame. Calculated from information
    // in the header or supplied by the MAC, depending on the medium
    //

    UINT cbPacketSize;

    //
    // IsSnaDixFrame - true if the frame just received (on ethernet) is a DIX
    // frame and the DIX identifier is 0x80D5 (big-endian)
    //

    UINT IsSnaDixFrame;
    LAN802_ADDRESS Adapter;
    ULONG MaxFrameSize;
    ULONG LinkSpeed;

    //
    // We use UINTs, because (Move mem, ULONG) may not be an
    // atomic operation (in theory)
    //

    UINT NdisMedium;
    UINT XidTestResponses;
    ULONG ObjectCount;                  // must be zero, when adapter closed

    //
    // ConfigInfo - holds the SwapAddressBits and UseDixOverEthernet flags and
    // the timer tick values
    //

    ADAPTER_CONFIGURATION_INFO ConfigInfo;

    //
    // the original node addresses
    //

    ULONG ulBroadcastAddress;

    USHORT usBroadcastAddress;
    USHORT BackgroundProcessRequests;

    UCHAR NodeAddress[6];               // Current network format
    USHORT cbMaxFrameHeader;

    UCHAR PermanentAddress[6];
    USHORT OpenOptions;

    USHORT AddressTranslationMode;
    USHORT FrameType;

    USHORT usRcvMask;
    USHORT EthernetType;

    USHORT RcvLanHeaderLength;
    USHORT BindingCount;

    USHORT usHighFunctionalBits;

    //
    // Keep UCHAR alignment
    //

    BOOLEAN boolTranferDataNotComplete;
    BOOLEAN IsDirty;
    BOOLEAN ResetInProgress;
    UCHAR Unused1;

#ifndef NDIS40
    // Not used.
    UCHAR AdapterNumber;
#endif // NDIS40
    UCHAR IsBroadcast;
    BOOLEAN SendProcessIsActive;
    BOOLEAN LlcPacketInSendQueue;

    //
    // We keep the big structures and tables in the end,
    // that makes most x86 offsets 1 byte instead of 4.
    // The compiler aligns the fields naturally, whenever
    // it is necessary.
    //

    //
    // the next elements will be linked to circular
    // end process link list, if there are any frames to send
    //

    LIST_ENTRY NextSendTask;            // pointer to active sends
    LIST_ENTRY QueueEvents;
    LIST_ENTRY QueueCommands;
    LLC_QUEUE QueueI;
    LLC_QUEUE QueueDirAndU;
    LLC_QUEUE QueueExpidited;
    UNICODE_STRING Name;                // current adapter name
    PTIMER_TICK pTimerTicks;

    NDIS_STATUS AsyncOpenStatus;        // used to wait async open
    NDIS_STATUS AsyncCloseResetStatus;  // used to wait async close
    NDIS_STATUS OpenCompleteStatus;     // used to wait the first open
    NDIS_STATUS LinkRcvStatus;          // link state machine ret status
    NDIS_STATUS NdisRcvStatus;          // NdisRcvIndication ret status
    NDIS_STATUS OpenErrorStatus;        // special adapter open status

    //
    // NDIS calls back when adapter open completes. Use a Kernel Event to
    // synchronize LLC with NDIS
    //

    KEVENT Event;

    //
    // the following are reasonably large arrays (like 256 pointers to SAP
    // objects...)
    //

    PLLC_SAP apSapBindings[256];        // the clients bound to the SAPs
    PDATA_LINK aLinkHash[LINK_HASH_SIZE];   // hash table to links
    PLLC_STATION_OBJECT aDixStations[MAX_DIX_TABLE];
    LLC_TRANSFER_PACKET TransferDataPacket;

#if DBG

    //
    // memory usage counters for memory owned by this ADAPTER_CONTEXT
    //

    MEMORY_USAGE MemoryUsage;
    MEMORY_USAGE StringUsage;

#endif

#ifdef NDIS40
        
    #define BIND_STATE_UNBOUND      1
    #define BIND_STATE_UNBINDING    2
    #define BIND_STATE_BOUND        3
    
    LONG     BindState;
    REF_CNT  AdapterRefCnt;
    KEVENT   CloseAdapterEvent;
#endif // NDIS40
};

typedef PLLC_PACKET (*PF_GET_PACKET)(IN PADAPTER_CONTEXT pAdapterContext);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llctimr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    llctimr.c

Abstract:

    This module contains code that implements a lightweight timer system
    for the data link driver.

    This module gets control once in 40 ms when a DPC timer expires.
    The routine scans the device context's link database, looking for timers
    that have expired, and for those that have expired, their expiration
    routines are executed.

    This is how timers work in DLC:

        Each adapter has a singly-linked list of timer ticks (terminated by NULL).
        A tick just specifies work to be done at a certain time in the future.
        Ticks are ordered by increasing time (multiples of 40 mSec). The work
        list that has to be performed when a tick comes due is described by a
        doubly-linked list of timers (LLC_TIMER) that the tick structure points
        at through the pFront field. For each timer added to a tick's list, the
        tick reference count is incremented; it is decremented when a timer is
        removed. When the reference count is decremented to zero, the timer
        tick is unlinked and deallocated

        Every 40 mSec a kernel timer fires and executes our DPC routine
        (ScanTimersDpc). This grabs the requisite spinlocks and searches through
        all timer ticks on all adapter context structures looking for work to
        do

    Pictorially:

              +---------+ --> other adapter contexts
     +--------| Adapter |
     |        +---------+
     |
     +-> +------+---> +------+---> 0 (end of singly-linked list)
         | Tick |     | Tick |
         |      |     |      |
         +------+     +------+
            | ^
            | +------------+-------------+
            v |            |             |
    +--> +-------+---> +-------+---> +-------+-----+
    | +--| Timer | <---| Timer | <---| Timer | <-+ |
    | |  +-------+     +-------+     +-------+   | |
    | |                                          | |
    | +------------------------------------------+ |
    +----------------------------------------------+

    The procedures in this module can be called only when SendSpinLock is set.

    Contents:
        ScanTimersDpc
        LlcInitializeTimerSystem
        LlcTerminateTimerSystem
        TerminateTimer
        InitializeLinkTimers
        InitializeTimer
        StartTimer
        StopTimer

Author:

    Antti Saarenheimo (o-anttis) 30-MAY-1991

Environment:

    Kernel mode

Revision History:

    28-Apr-1994 rfirth

        * Changed to use single driver-level spinlock

        * Added useful picture & description above to aid any other poor saps -
          er - programmers - who get tricked into - er - who are lucky enough
          to work on DLC

--*/

#include <llc.h>

//
// DLC timer tick is 40 ms !!!
//

#define TIMER_DELTA 400000L

//
// global data
//

ULONG AbsoluteTime = 0;
BOOLEAN DlcIsTerminating = FALSE;
BOOLEAN DlcTerminated = FALSE;

//
// private data
//

static LARGE_INTEGER DueTime = { (ULONG) -TIMER_DELTA, (ULONG) -1 };
static KTIMER SystemTimer;
static KDPC TimerSystemDpc;


VOID
ScanTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at regular
    intervals to determine if any link-level timers have expired, and
    if they have, to execute their expiration routines.

Arguments:

    Dpc             - Ignored
    DeferredContext - Ignored
    SystemArgument1 - Ignored
    SystemArgument2 - Ignored

Return Value:

    None.

--*/

{
    PLLC_TIMER pTimer;
    PADAPTER_CONTEXT pAdapterContext;
    PLLC_TIMER pNextTimer;
    PTIMER_TICK pTick;
    PTIMER_TICK pNextTick;
    BOOLEAN boolRunBackgroundProcess;
    KIRQL irql;

    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    ASSUME_IRQL(DISPATCH_LEVEL);

    AbsoluteTime++;

    //
    // The global spinlock keeps the adapters alive over this
    //

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

    //
    // scan timer queues for all adapters
    //

    for (pAdapterContext = pAdapters; pAdapterContext; pAdapterContext = pAdapterContext->pNext) {

        boolRunBackgroundProcess = FALSE;

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        //
        // The timer ticks are protected by a reference counter
        //

        for (pTick = pAdapterContext->pTimerTicks; pTick; pTick = pNextTick) {

            if (pTick->pFront) {

                //
                // This keeps the tick alive, we cannot use spin lock,
                // because the timers are called and deleted within
                // SendSpinLock.  (=> deadlock)
                //

                pTick->ReferenceCount++;

                //
                // Send spin lock prevents anybody to remove a timer
                // when we are processing it.
                //

                for (pTimer = pTick->pFront;
                     pTimer && pTimer->ExpirationTime <= AbsoluteTime;
                     pTimer = pNextTimer) {

                    if ( (pNextTimer = pTimer->pNext) == pTick->pFront) {
                        pNextTimer = NULL;
                    }

                    //
                    // DLC driver needs a timer tick every 0.5 second to
                    // implement timer services defined by the API
                    //

                    if (pTick->Input == LLC_TIMER_TICK_EVENT) {

                        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                        ((PBINDING_CONTEXT)pTimer->hContext)->pfEventIndication(
                            ((PBINDING_CONTEXT)pTimer->hContext)->hClientContext,
                            NULL,
                            LLC_TIMER_TICK_EVENT,
                            NULL,
                            0
                            );

                        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                        StartTimer(pTimer);

                    } else {
                        StopTimer(pTimer);
                        RunStateMachineCommand(
                            pTimer->hContext,
                            pTick->Input
                            );
                        boolRunBackgroundProcess = TRUE;
                    }
                }

                pNextTick = pTick->pNext;

                //
                // Delete the timer tick, if there are no references to it.
                //

                if ((--pTick->ReferenceCount) == 0) {

                    //
                    // The timers are in a single entry list!
                    //

                    RemoveFromLinkList((PVOID*)&pAdapterContext->pTimerTicks, pTick);

                    FREE_MEMORY_ADAPTER(pTick);
                }
            } else {
                pNextTick = pTick->pNext;
            }
        }

        if (boolRunBackgroundProcess) {
            BackgroundProcessAndUnlock(pAdapterContext);
        } else {
            RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
        }
    }

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();

    //
    // Start up the timer again.  Note that because we start the timer
    // after doing work (above), the timer values will slip somewhat,
    // depending on the load on the protocol.  This is entirely acceptable
    // and will prevent us from using the timer DPC in two different
    // threads of execution.
    //

    if (!DlcIsTerminating) {

        ASSUME_IRQL(ANY_IRQL);

        KeSetTimer(&SystemTimer, DueTime, &TimerSystemDpc);
    } else {
        DlcTerminated = TRUE;
    }
}


VOID
LlcInitializeTimerSystem(
    VOID
    )

/*++

Routine Description:

    This routine initializes the lightweight timer system for the
    data link driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    KeInitializeDpc(&TimerSystemDpc, ScanTimersDpc, NULL);
    KeInitializeTimer(&SystemTimer);
    KeSetTimer(&SystemTimer, DueTime, &TimerSystemDpc);
}


VOID
LlcTerminateTimerSystem(
    VOID
    )

/*++

Routine Description:

    This routine terminates the timer system of the data link driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    DlcIsTerminating = TRUE;

    //
    // if KeCancelTimer returns FALSE then the timer was not set. Assume the DPC
    // is either waiting to be scheduled or is already in progress
    //

    if (!KeCancelTimer(&SystemTimer)) {

        //
        // if timer is not set, wait for DPC to complete
        //

        while (!DlcTerminated) {

            //
            // wait 40 milliseconds - period of DLC's tick
            //

            LlcSleep(40000);
        }
    }
}


BOOLEAN
TerminateTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_TIMER pTimer
    )

/*++

Routine Description:

    Terminate a timer tick by stopping pTimer (remove it from the tick's active
    timer list). If pTimer was the last timer on the tick's list then unlink and
    deallocate the timer tick.

    This routine assumes that if a timer (LLC_TIMER) has a non-NULL pointer to
    a tick (TIMER_TICK) then the timer tick owns the timer (i.e. the timer is
    started) and this ownership is reflected in the reference count. Even if a
    timer is stopped, if its pointer to the timer tick 'object' is valid then
    the timer tick still owns the timer

Arguments:

    pAdapterContext - adapter context which owns ticks/timers
    pTimer          - timer tick object of a link station

Return Value:

    None

--*/

{
    BOOLEAN timerActive;
    PTIMER_TICK pTick;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Timer may not always be initialized, when this is called
    // from the cleanup processing of a failed OpenAdapter call.
    //

    if (!pTimer->pTimerTick) {
        return FALSE;
    }

    pTick = pTimer->pTimerTick;
    timerActive = StopTimer(pTimer);

    //
    // if that was the last timer on the list for this tick then remove the
    // tick from the list and deallocate it
    //

    if (!--pTick->ReferenceCount) {

        RemoveFromLinkList((PVOID*)&pAdapterContext->pTimerTicks, pTick);

        FREE_MEMORY_ADAPTER(pTick);

    }
    return timerActive;
}


DLC_STATUS
InitializeLinkTimers(
    IN OUT PDATA_LINK pLink
    )

/*++

Routine Description:

    This routine initializes a timer tick objects of a link station.

Arguments:

    pAdapterContext - the device context
    pLink           - the link context

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                    out of system memory

--*/

{
    DLC_STATUS LlcStatus;

    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    LlcStatus = InitializeTimer(pAdapterContext,
                                &pLink->T1,
                                pLink->TimerT1,
                                pAdapterContext->ConfigInfo.TimerTicks.T1TickOne,
                                pAdapterContext->ConfigInfo.TimerTicks.T1TickTwo,
                                T1_Expired,
                                pLink,
                                pLink->AverageResponseTime,
                                FALSE
                                );
    if (LlcStatus != STATUS_SUCCESS) {
        return LlcStatus;
    }

    LlcStatus = InitializeTimer(pAdapterContext,
                                &pLink->T2,
                                pLink->TimerT2,
                                pAdapterContext->ConfigInfo.TimerTicks.T2TickOne,
                                pAdapterContext->ConfigInfo.TimerTicks.T2TickTwo,
                                T2_Expired,
                                pLink,
                                0,  // T2 is not based on the response time
                                FALSE
                                );
    if (LlcStatus != STATUS_SUCCESS) {
        return LlcStatus;
    }

    LlcStatus = InitializeTimer(pAdapterContext,
                                &pLink->Ti,
                                pLink->TimerTi,
                                pAdapterContext->ConfigInfo.TimerTicks.TiTickOne,
                                pAdapterContext->ConfigInfo.TimerTicks.TiTickTwo,
                                Ti_Expired,
                                pLink,
                                pLink->AverageResponseTime,
                                TRUE
                                );
    return LlcStatus;
}


DLC_STATUS
InitializeTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN OUT PLLC_TIMER pTimer,
    IN UCHAR TickCount,
    IN UCHAR TickOne,
    IN UCHAR TickTwo,
    IN UINT Input,
    IN PVOID hContextHandle,
    IN UINT ResponseDelay,
    IN BOOLEAN StartNewTimer
    )

/*++

Routine Description:

    This routine initializes a timer tick objects of a link station.

Arguments:

    pTimer          - timer tick object of a link station
    TickCount       - DLC ticks, see DLC documentation (or code)
    TickOne         - see DLC documentation
    TickTwo         - see DLC documentation
    Input           - the used state machine input, when the timer expires
    hContextHandle  - context handle when the state machine is called
    StartNewTimer   - set if the timer must be started when it is initialized
                      for the first time. Subsequent times, the timer keeps its
                      old state
    ResponseDelay   - an optional base value that is added to the timer value

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                    out of system memory

--*/

{
    UINT DeltaTime;
    PTIMER_TICK pTick;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // All times are multiples of 40 milliseconds
    // (I am not sure how portable is this design)
    // See LAN Manager Network Device Driver Guide
    // ('Remoteboot protocol') for further details
    // about TickOne and TickTwo
    // We have already checked, that the
    // timer tick count is less than 11.
    //

    DeltaTime = (TickCount > 5 ? (UINT)(TickCount - 5) * (UINT)TickTwo
                               : (UINT)TickCount * (UINT)TickOne);

    //
    // We discard the low bits in the reponse delay.
    //

    DeltaTime += (ResponseDelay & 0xfff0);

    //
    // Return immediately, if the old value is the
    // same as the new one (T2 link station is reinitialized
    // unnecessary, when the T1 and Ti timers are retuned
    // for changed response time.
    //

    if (pTimer->pTimerTick && (pTimer->pTimerTick->DeltaTime == DeltaTime)) {
        return STATUS_SUCCESS;
    }

    //
    // Try to find a timer tick object having the same delta time and input
    //

    for (pTick = pAdapterContext->pTimerTicks; pTick; pTick = pTick->pNext) {
        if ((pTick->DeltaTime == DeltaTime) && (pTick->Input == (USHORT)Input)) {
            break;
        }
    }
    if (!pTick) {
        pTick = ALLOCATE_ZEROMEMORY_ADAPTER(sizeof(TIMER_TICK));
        if (!pTick) {
            return DLC_STATUS_NO_MEMORY;
        }
        pTick->DeltaTime = DeltaTime;
        pTick->Input = (USHORT)Input;
        pTick->pNext = pAdapterContext->pTimerTicks;
        pAdapterContext->pTimerTicks = pTick;
    }
    pTick->ReferenceCount++;

    //
    // We must delete the previous timer reference
    // when we know if the memory allocation operation
    // was successfull or not. Otherwise the setting of
    // the link parameters might delete old timer tick,
    // but it would not be able to allocate the new one.
    // The link must be protected, when this routine is called.
    //

    if (pTimer->pTimerTick) {
        StartNewTimer = TerminateTimer(pAdapterContext, pTimer);
    }
    pTimer->pTimerTick = pTick;
    pTimer->hContext = hContextHandle;

    if (StartNewTimer) {
        StartTimer(pTimer);
    }
    return STATUS_SUCCESS;
}


VOID
StartTimer(
    IN OUT PLLC_TIMER pTimer
    )

/*++

Routine Description:

    This starts the given timer within spin locks

Arguments:

    pTimer  - timer tick object of a link station

Return Value:

    None.

--*/

{
    PLLC_TIMER pFront;
    PTIMER_TICK pTimerTick = pTimer->pTimerTick;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We always reset the pNext pointer, when a item is
    // removed from a link list => the timer element cannot be
    // in the link list of a timer tick object if its next pointer is null
    //

    if (pTimer->pNext) {

        //
        // We don't need to change the timer's position, if the new timer
        // would be the same as the old time.
        //

        if (pTimer->ExpirationTime != AbsoluteTime + pTimerTick->DeltaTime) {

            //
            // The timer has already been started, move it to the top of
            // the link list.
            //

            if (pTimer != (pFront = pTimerTick->pFront)) {
                pTimer->pPrev->pNext = pTimer->pNext;
                pTimer->pNext->pPrev = pTimer->pPrev;
                pTimer->pNext = pFront;
                pTimer->pPrev = pFront->pPrev;
                pFront->pPrev->pNext = pTimer;
                pFront->pPrev = pTimer;
            }
        }
    } else {
        if (!(pFront = pTimerTick->pFront)) {
            pTimerTick->pFront = pTimer->pNext = pTimer->pPrev = pTimer;
        } else {
            pTimer->pNext = pFront;
            pTimer->pPrev = pFront->pPrev;
            pFront->pPrev->pNext = pTimer;
            pFront->pPrev = pTimer;
        }
    }
    pTimer->ExpirationTime = AbsoluteTime + pTimerTick->DeltaTime;
}


BOOLEAN
StopTimer(
    IN PLLC_TIMER pTimer
    )

/*++

Routine Description:

    This stops the given timer within spin locks

Arguments:

    pTimer  - timer tick object of a link station

Return Value:

    BOOLEAN
        TRUE    - timer was running
        FALSE   - timer was not running

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pTimer->pNext) {

        PTIMER_TICK pTimerTick = pTimer->pTimerTick;

        //
        // if the timer points to itself then its the only thing on the list:
        // zap the link in the timer tick structure (no more timers for this
        // tick) and zap the next field in the timer structure to indicate
        // the timer has been removed from the tick list. If the timer points
        // to another timer, then remove this timer from the doubly-linked list
        // of timers
        //

        if (pTimer != pTimer->pNext) {
            if (pTimer == pTimerTick->pFront) {
                pTimerTick->pFront = pTimer->pNext;
            }
            pTimer->pPrev->pNext = pTimer->pNext;
            pTimer->pNext->pPrev = pTimer->pPrev;
            pTimer->pNext = NULL;
        } else {
            pTimerTick->pFront = pTimer->pNext = NULL;
        }
        return TRUE;
    } else {

        //
        // this timer was not on a timer tick list
        //

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcsend.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcsend.c

Abstract:

    The module implements all sending functions and the main
    send process. There three different send queues:
        - I_Queue
        - DirU_Queue
        - ExpiditedQueue (for LLC commands)

    Each queue has the pointer of a packet building primitive, that
    takes an NDIS packet of an queue element.

    Contents:
        RunSendTaskAndUnlock
        BackgroundProcessAndUnlock
        BackgroundProcess
        LlcNdisSendComplete
        GetI_Packet
        StartSendProcess
        EnableSendProcess
        StopSendProcess
        DisableSendProcess
        BuildDirOrU_Packet
        SendLlcFrame
        GetLlcCommandPacket
        SendNdisPacket
        CompleteSendAndLock
        RespondTestOrXid
        LlcSendU
        LlcSendI
        QueuePacket
        CheckAndDuplicatePacket
        BackgroundProcessWithinLock

Author:

    Antti Saarenheimo (o-anttis) 23-MAY-1991

Revision History:

--*/

#include <llc.h>

//
// The IEEE XID frame is constant data: (id, support Class II, maxin = 127};
//

LLC_XID_INFORMATION Ieee802Xid = {IEEE_802_XID_ID, LLC_CLASS_II, (127 << 1)};
PMDL pXidMdl = NULL;


//
// Because normally LAN networks are error free, we added this option
// to test the error recovery of DLC protocol.  It seems to work now
// quite well (but first we had to fix a fundamental bug in the sending
// of REJ-r0).
//

//
// Enable this to test REJECT states (after a major changes in
// the state machine).
//

//#define LLC_LOSE_I_PACKETS

#ifdef LLC_LOSE_I_PACKETS

#define DBG_ERROR_PERCENT(a)  (((a) * 0x8000) / 100)


//
// Pseudo random table to lose packets
//

static USHORT aRandom[1000] = {
        41, 18467,  6334, 26500, 19169, 15724, 11478, 29358, 26962, 24464,
      5705, 28145, 23281, 16827,  9961,   491,  2995, 11942,  4827,  5436,
     32391, 14604,  3902,   153,   292, 12382, 17421, 18716, 19718, 19895,
      5447, 21726, 14771, 11538,  1869, 19912, 25667, 26299, 17035,  9894,
     28703, 23811, 31322, 30333, 17673,  4664, 15141,  7711, 28253,  6868,
     25547, 27644, 32662, 32757, 20037, 12859,  8723,  9741, 27529,   778,
     12316,  3035, 22190,  1842,   288, 30106,  9040,  8942, 19264, 22648,
     27446, 23805, 15890,  6729, 24370, 15350, 15006, 31101, 24393,  3548,
     19629, 12623, 24084, 19954, 18756, 11840,  4966,  7376, 13931, 26308,
     16944, 32439, 24626, 11323,  5537, 21538, 16118,  2082, 22929, 16541,
      4833, 31115,  4639, 29658, 22704,  9930, 13977,  2306, 31673, 22386,
      5021, 28745, 26924, 19072,  6270,  5829, 26777, 15573,  5097, 16512,
     23986, 13290,  9161, 18636, 22355, 24767, 23655, 15574,  4031, 12052,
     27350,  1150, 16941, 21724, 13966,  3430, 31107, 30191, 18007, 11337,
     15457, 12287, 27753, 10383, 14945,  8909, 32209,  9758, 24221, 18588,
      6422, 24946, 27506, 13030, 16413, 29168,   900, 32591, 18762,  1655,
     17410,  6359, 27624, 20537, 21548,  6483, 27595,  4041,  3602, 24350,
     10291, 30836,  9374, 11020,  4596, 24021, 27348, 23199, 19668, 24484,
      8281,  4734,    53,  1999, 26418, 27938,  6900,  3788, 18127,   467,
      3728, 14893, 24648, 22483, 17807,  2421, 14310,  6617, 22813,  9514,
     14309,  7616, 18935, 17451, 20600,  5249, 16519, 31556, 22798, 30303,
      6224, 11008,  5844, 32609, 14989, 32702,  3195, 20485,  3093, 14343,
     30523,  1587, 29314,  9503,  7448, 25200, 13458,  6618, 20580, 19796,
     14798, 15281, 19589, 20798, 28009, 27157, 20472, 23622, 18538, 12292,
      6038, 24179, 18190, 29657,  7958,  6191, 19815, 22888, 19156, 11511,
     16202,  2634, 24272, 20055, 20328, 22646, 26362,  4886, 18875, 28433,
     29869, 20142, 23844,  1416, 21881, 31998, 10322, 18651, 10021,  5699,
      3557, 28476, 27892, 24389,  5075, 10712,  2600,  2510, 21003, 26869,
     17861, 14688, 13401,  9789, 15255, 16423,  5002, 10585, 24182, 10285,
     27088, 31426, 28617, 23757,  9832, 30932,  4169,  2154, 25721, 17189,
     19976, 31329,  2368, 28692, 21425, 10555,  3434, 16549,  7441,  9512,
     30145, 18060, 21718,  3753, 16139, 12423, 16279, 25996, 16687, 12529,
     22549, 17437, 19866, 12949,   193, 23195,  3297, 20416, 28286, 16105,
     24488, 16282, 12455, 25734, 18114, 11701, 31316, 20671,  5786, 12263,
      4313, 24355, 31185, 20053,   912, 10808,  1832, 20945,  4313, 27756,
     28321, 19558, 23646, 27982,   481,  4144, 23196, 20222,  7129,  2161,
      5535, 20450, 11173, 10466, 12044, 21659, 26292, 26439, 17253, 20024,
     26154, 29510,  4745, 20649, 13186,  8313,  4474, 28022,  2168, 14018,
     18787,  9905, 17958,  7391, 10202,  3625, 26477,  4414,  9314, 25824,
     29334, 25874, 24372, 20159, 11833, 28070,  7487, 28297,  7518,  8177,
     17773, 32270,  1763,  2668, 17192, 13985,  3102,  8480, 29213,  7627,
      4802,  4099, 30527,  2625,  1543,  1924, 11023, 29972, 13061, 14181,
     31003, 27432, 17505, 27593, 22725, 13031,  8492,   142, 17222, 31286,
     13064,  7900, 19187,  8360, 22413, 30974, 14270, 29170,   235, 30833,
     19711, 25760, 18896,  4667,  7285, 12550,   140, 13694,  2695, 21624,
     28019,  2125, 26576, 21694, 22658, 26302, 17371, 22466,  4678, 22593,
     23851, 25484,  1018, 28464, 21119, 23152,  2800, 18087, 31060,  1926,
      9010,  4757, 32170, 20315,  9576, 30227, 12043, 22758,  7164,  5109,
      7882, 17086, 29565,  3487, 29577, 14474,  2625, 25627,  5629, 31928,
     25423, 28520,  6902, 14962,   123, 24596,  3737, 13261, 10195, 32525,
      1264,  8260,  6202,  8116,  5030, 20326, 29011, 30771,  6411, 25547,
     21153, 21520, 29790, 14924, 30188, 21763,  4940, 20851, 18662, 13829,
     30900, 17713, 18958, 17578,  8365, 13007, 11477,  1200, 26058,  6439,
      2303, 12760, 19357,  2324,  6477,  5108, 21113, 14887, 19801, 22850,
     14460, 22428, 12993, 27384, 19405,  6540, 31111, 28704, 12835, 32356,
      6072, 29350, 18823, 14485, 20556, 23216,  1626,  9357,  8526, 13357,
     29337, 23271, 23869, 29361, 12896, 13022, 29617, 10112, 12717, 18696,
     11585, 24041, 24423, 24129, 24229,  4565,  6559,  8932, 22296, 29855,
     12053, 16962,  3584, 29734,  6654, 16972, 21457, 14369, 22532,  2963,
      2607,  2483,   911, 11635, 10067, 22848,  4675, 12938,  2223, 22142,
     23754,  6511, 22741, 20175, 21459, 17825,  3221, 17870,  1626, 31934,
     15205, 31783, 23850, 17398, 22279, 22701, 12193, 12734,  1637, 26534,
      5556,  1993, 10176, 25705,  6962, 10548, 15881,   300, 14413, 16641,
     19855, 24855, 13142, 11462, 27611, 30877, 20424, 32678,  1752, 18443,
     28296, 12673, 10040,  9313,   875, 20072, 12818,   610,  1017, 14932,
     28112, 30695, 13169, 23831, 20040, 26488, 28685, 19090, 19497,  2589,
     25990, 15145, 19353, 19314, 18651, 26740, 22044, 11258,   335,  8759,
     11192,  7605, 25264, 12181, 28503,  3829, 23775, 20608, 29292,  5997,
     17549, 29556, 25561, 31627,  6467, 29541, 26129, 31240, 27813, 29174,
     20601,  6077, 20215,  8683,  8213, 23992, 25824,  5601, 23392, 15759,
      2670, 26428, 28027,  4084, 10075, 18786, 15498, 24970,  6287, 23847,
     32604,   503, 21221, 22663,  5706,  2363,  9010, 22171, 27489, 18240,
     12164, 25542,  7619, 20913,  7591,  6704, 31818,  9232,   750, 25205,
      4975,  1539,   303, 11422, 21098, 11247, 13584, 13648,  2971, 17864,
     22913, 11075, 21545, 28712, 17546, 18678,  1769, 15262,  8519, 13985,
     28289, 15944,  2865, 18540, 23245, 25508, 28318, 27870,  9601, 28323,
     21132, 24472, 27152, 25087, 28570, 29763, 29901, 17103, 14423,  3527,
     11600, 26969, 14015,  5565,    28, 21543, 25347,  2088,  2943, 12637,
     22409, 26463,  5049,  4681,  1588, 11342,   608, 32060, 21221,  1758,
     29954, 20888, 14146,   690,  7949, 12843, 21430, 25620,   748, 27067,
      4536, 20783, 18035, 32226, 15185,  7038,  9853, 25629, 11224, 15748,
     19923,  3359, 32257, 24766,  4944, 14955, 23318, 32726, 25411, 21025,
     20355, 31001, 22549,  9496, 18584,  9515, 17964, 23342,  8075, 17913,
     16142, 31196, 21948, 25072, 20426, 14606, 26173, 24429, 32404,  6705,
     20626, 29812, 19375, 30093, 16565, 16036, 14736, 29141, 30814,  5994,
      8256,  6652, 23936, 30838, 20482,  1355, 21015,  1131, 18230, 17841,
     14625,  2011, 32637,  4186, 19690,  1650,  5662, 21634, 10893, 10353,
     21416, 13452, 14008,  7262, 22233,  5454, 16303, 16634, 26303, 14256,
       148, 11124, 12317,  4213, 27109, 24028, 29200, 21080, 21318, 16858,
     24050, 24155, 31361, 15264, 11903,  3676, 29643, 26909, 14902,  3561,
     28489, 24948,  1282, 13653, 30674,  2220,  5402,  6923,  3831, 19369,
      3878, 20259, 19008, 22619, 23971, 30003, 21945,  9781, 26504, 12392,
     32685, 25313,  6698,  5589, 12722,  5938, 19037,  6410, 31461,  6234,
     12508,  9961,  3959,  6493,  1515, 25269, 24937, 28869,    58, 14700,
     13971, 26264, 15117, 16215, 24555,  7815, 18330,  3039, 30212, 29288,
     28082,  1954, 16085, 20710, 24484, 24774,  8380, 29815, 25951,  6541,
     18115,  1679, 17110, 25898, 23073,   788, 23977, 18132, 29956, 28689,
     26113, 10008, 12941, 15790,  1723, 21363,    28, 25184, 24778,  7200,
      5071,  1885, 21974,  1071, 11333, 22867, 26153, 14295, 32168, 20825,
      9676, 15629, 28650,  2598,  3309,  4693,  4686, 30080, 10116, 12249,
};

#endif



VOID
RunSendTaskAndUnlock(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function is the send engine of the data link driver
    and the background task.
    It sends the queue objects as far as there is
    free NDIS packets in a small packet queue.
    The number of NDIS packets are limited because
    too deep send queues are bad for the connection based protocols.

    This is called from NdisIndicateReceiveComplete,
    NdisSendComplete and almost all LLC commands.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We must serialize the sending.  802.2 protocol
    // will simply die if two sequential packets are sent in a wrong
    // order.  The receiving and DLC level transmit processing can still
    // work even if the sending is syncronous in the data link level.
    //

    if (pAdapterContext->SendProcessIsActive == FALSE) {

        pAdapterContext->SendProcessIsActive = TRUE;

        while (!IsListEmpty(&pAdapterContext->NextSendTask)
        && pAdapterContext->pNdisPacketPool != NULL
        && !pAdapterContext->ResetInProgress) {

            //
            // executed the next send task in the send queue,
            // expidited data (if any) is always the first and
            // it is executed as far as there is any expidited packets.
            // The rest (I, UI, DIR) are executed in a round robin
            //

            SendNdisPacket(pAdapterContext,

                //
                // this next generates a pointer to a function which returns a
                // packet to send (eg. GetI_Packet)
                //

                ((PF_GET_PACKET)((PLLC_QUEUE)pAdapterContext->NextSendTask.Flink)->pObject)(pAdapterContext)
                );
        }

        pAdapterContext->SendProcessIsActive = FALSE;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}


VOID
BackgroundProcessAndUnlock(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function is both the send engine of the data link driver
    and the background task.
    It executes the queue objects as far as there is
    free NDIS packets in a small packet queue.
    The number of NDIS packets are limited because
    too deep send queues are bad for the connection based protocols.

    This is called from NdisIndicateReceiveComplete,
    NdisSendComplete and almost all LLC commands.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Prevent recursive background process calls, we don't need to start
    // new loop, if there is already one instance running somewhere
    // up in the stack.  Still we must do everything again,
    // if there was another backgroun process request, because
    // it may have been saved before the current position.
    //

    pAdapterContext->BackgroundProcessRequests++;

    if (pAdapterContext->BackgroundProcessRequests == 1) {

        //
        //  repeat this as far as there are new tasks
        //

        do {

            USHORT InitialRequestCount;

            InitialRequestCount = pAdapterContext->BackgroundProcessRequests;

            //
            // This actually completes only link transmit, connect and
            // disconnect commands.  The connectionless frames
            // are completed immediately when NDIS send completes.
            // Usually several frames are acknowledged in the same time.
            // Thus we create a local command list and execute
            // its all completions with a single spin locking.
            //

            while (!IsListEmpty(&pAdapterContext->QueueCommands)) {

                PLLC_PACKET pCommand;

                pCommand = LlcRemoveHeadList(&pAdapterContext->QueueCommands);

                RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                pCommand->pBinding->pfCommandComplete(pCommand->pBinding->hClientContext,
                                                      pCommand->Data.Completion.hClientHandle,
                                                      pCommand
                                                      );

                ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
            }

            //
            // indicate the queued events
            //

            while (!IsListEmpty(&pAdapterContext->QueueEvents)) {

                PEVENT_PACKET pEvent;

                pEvent = LlcRemoveHeadList(&pAdapterContext->QueueEvents);

                RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                pEvent->pBinding->pfEventIndication(pEvent->pBinding->hClientContext,
                                                    pEvent->hClientHandle,
                                                    pEvent->Event,
                                                    pEvent->pEventInformation,
                                                    pEvent->SecondaryInfo
                                                    );

                ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pEvent);

            }
            pAdapterContext->BackgroundProcessRequests -= InitialRequestCount;

        } while (pAdapterContext->BackgroundProcessRequests > 0);
    }

    //
    // also execute the send task if the send queue is not empty
    //

    pAdapterContext->LlcPacketInSendQueue = FALSE;
    RunSendTaskAndUnlock(pAdapterContext);
}


//
//  Background process entry for those, that don't
//  want to play with SendSpinLock.
//  We will execute the DPC taks on DPC level (hLockHandle = NULL),
//  that's perfectly OK as far as the major send operations by
//  LlcSendI and LlcSendU lower the IRQL level while they are sending
//  (to allow the DPC processing when we doing a long string io or
//  memory move to a slow ISA adapter)
//

VOID
BackgroundProcess(
    IN PADAPTER_CONTEXT pAdapterContext
    )
{
    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    BackgroundProcessAndUnlock(pAdapterContext);
}


VOID
LlcNdisSendComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    The routine handles NdisCompleteSend indication, it makes send
    completed indication to upper protocol drivers if necessary and
    executes the background process to find if there is any other
    frames in the send queue.
    This is usually called below the DPC level.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    //
    // this function may be called from NDIS wrapper at DPC level or from
    // SendNdisPacket() at passive level
    //

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    CompleteSendAndLock(pAdapterContext,
                        (PLLC_NDIS_PACKET)pNdisPacket,
                        NdisStatus
                        );

    //
    // Send command completion should not queue any command
    // completions or events.  The send queue is the only possiblity.
    //

    if (!IsListEmpty(&pAdapterContext->NextSendTask)) {
        RunSendTaskAndUnlock(pAdapterContext);
    } else {

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    }

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'dneS');
#endif // NDIS40
}


PLLC_PACKET
GetI_Packet(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function does:
        - selects the current link station in the queue and schedules
          (round robin) the queues for the next send
        - executes its send procedure
        - initializes the data link packet for the I frame

Arguments:

    pAdapterContext - adapter context

Return Value:

    PLLC_PACKET

--*/

{
    PDATA_LINK pLink;
    PLLC_PACKET pPacket;

    //
    // search the link (three LLC queues linked together!)
    //

    pLink = (((PLLC_QUEUE)pAdapterContext->QueueI.ListHead.Flink)->pObject);

/*
    This is probably just wasting of CPU cycles.  Remove the comments,
    if somebody has troubles because of this.  Stop send process will
    reschedule the queues in any way.

    //
    // We have a round robin scheduling for all main queues (U, I
    // and expidited) and for all sending links within the I- queue.
    // Select the next main task and the next sending link, if
    // there is any. (Usually we have only one sending object)
    //

    ScheduleQueue(&pAdapterContext->NextSendTask);
    ScheduleQueue(&pAdapterContext->QueueI.ListHead);
*/

    //
    // A resent packet may still not be completed by NDIS,
    // a very, very bad things begin to happen, if we try
    // to send packet again before it has been completed
    // by NDIS (we may complete the same packet twice).
    // The flag indicates, that the send process should be
    // restarted.
    //

    if (((PLLC_PACKET)pLink->SendQueue.ListHead.Flink)->CompletionType & LLC_I_PACKET_PENDING_NDIS) {
        ((PLLC_PACKET)pLink->SendQueue.ListHead.Flink)->CompletionType |= LLC_I_PACKET_WAITING_NDIS;
        StopSendProcess(pAdapterContext, pLink);
        return NULL;
    }

    //
    // move the next element in the send list to the list of unacknowledged packets
    //

    pPacket = LlcRemoveHeadList(&pLink->SendQueue.ListHead);
    LlcInsertTailList(&pLink->SentQueue, pPacket);

    if (IsListEmpty(&pLink->SendQueue.ListHead)) {
        StopSendProcess(pAdapterContext, pLink);
    }

    //
    // Copy SSAP and DSAP, reset the default stuff.
    // Set the POLL bit if this is the last frame of the send window.
    //

    pPacket->Data.Xmit.LlcHeader.I.Dsap = pLink->Dsap;
    pPacket->Data.Xmit.LlcHeader.I.Ssap = pLink->Ssap;
    pPacket->Data.Xmit.LlcHeader.I.Ns = pLink->Vs;
    pPacket->Data.Xmit.LlcHeader.I.Nr = pLink->Vr;
    pPacket->CompletionType = LLC_I_PACKET;

    //
    // We should actually lock the link, but we cannot do it,
    // because it is against the spin lock rules:  SendSpinLock has already
    // been acquired. But nothing terrible can happen: in the worst case
    // pLink->Ir_Ct update is lost and we send an extra ack.  All Vs updates
    // are done behind SendSpinLock in any way and the timers are
    // protected by the timer spin lock.
    //

    pLink->Vs += 2; // modulo 128 increment for 7 highest bit

    // Update VsMax only if this is a new send.
    // .... pLink->VsMax = pLink->Vs;

    if( pLink->Va <= pLink->VsMax ){
        if( pLink->VsMax < pLink->Vs ){
            pLink->VsMax = pLink->Vs;
        }else if( pLink->Vs < pLink->Va ){
            pLink->VsMax = pLink->Vs;
        }else{
            // Don't change, we are resending.
        }
    }else{
        if( pLink->Va < pLink->Vs ){
            // Don't change, wrapping.
        }else if( pLink->VsMax < pLink->Vs ){
            pLink->VsMax = pLink->Vs;
        }else{
            // Don't change, we are resending.
        }
    }



    //
    // We are now sending the acknowledge, we can stop the ack timer
    // if it has been running.  T1 timer must be started or reinitialized
    // and Ti must be stopped (as always when T1 is started).
    //

    if (pLink->T2.pNext != NULL) {
        StopTimer(&pLink->T2);
    }
    if (pLink->Ti.pNext != NULL) {
        StopTimer(&pLink->Ti);
    }

    //
    // Normally send an I- frame as Command-0 (without the poll bit),
    // but Command-Poll when the send window is full.
    // BUT! we cannot resend the packets with the poll bit (what?)
    //

    if (pLink->Vs == (UCHAR)(pLink->Va + pLink->Ww)) {

        //
        // The send process must be stopped until we have got
        // a response for this poll.  THE SEND PROCESS MUST BE
        // STOPPED BEFORE SendSpinLock IS OPENED.  Otherwise
        // simultaneous execution could send two polls, corrupt
        // the send queues, etc.
        //

        pLink->Flags |= DLC_SEND_DISABLED;
        StopSendProcess(pAdapterContext, pLink);

        //
        // IBM TR network architecture reference gives some hints how
        // to prevent the looping between check and sending states,
        // if link can send small S- frames, but not bigger data frames.
        // Unfortunately they do not provide any working solution.
        // They have described the problem on page 11-22 and in the
        // T1 expiration handler of all sending states (different T1
        // for sending and poll states in state machine).  All Is_Ct stuff
        // in the state machine is garbage, because the link sets the
        // transmit window to 1 immediately after a failed xmit and enters
        // to a check state after every retransmit => T1 timeout happens
        // in the current check state, but P_Ct never expires, because
        // the other side sends always S acknowledge and link returns
        // to open state until the nexting retransmit (which action
        // resets the P_Ct counter).
        // I added this check to send process and the decrement of
        // Is_Ct counter to all SEND_I_POLL actions => The link times out,
        // when it cannot send I-frames even if S- exchange works.
        //

        if (pLink->Vp == pLink->Vs && pLink->Is_Ct == 0) {

            //
            // The same I- frame has been retransmitted too many times.
            // We must shut down this link.  This happen now, when
            // we give T1 expired indication and and Is_Ct == 0.
            //

            RunStateMachineCommand(pLink, T1_Expired);

            //
            // We must (NDIS) complete the last packet now, because
            // the data link protocol may have already cancelled it.
            //

            pPacket->CompletionType &= ~LLC_I_PACKET_PENDING_NDIS;
            if (pPacket->CompletionType == LLC_I_PACKET_COMPLETE) {
                LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
            }

            //
            // We must execute the background process from here,
            // because the background process is not called from
            // the send task
            //

            BackgroundProcessAndUnlock(pAdapterContext);

            ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

            return NULL;
        } else {

            //
            // This is a Command-Poll, set the flag and the current
            // time stamp, whenever a new command poll was queued.
            //

            pLink->LastTimeWhenCmdPollWasSent = (USHORT)AbsoluteTime;
            pLink->Flags |= DLC_WAITING_RESPONSE_TO_POLL;

            pPacket->Data.Xmit.LlcHeader.I.Nr |= (UCHAR)LLC_I_S_POLL_FINAL;
            RunStateMachineCommand(pLink, SEND_I_POLL);
        }
    } else {
        pLink->Ir_Ct = pLink->N3;
        if (pLink->T1.pNext == NULL) {
            StartTimer(&pLink->T1);
        }
    }
    return pPacket;
}


VOID
StartSendProcess(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PDATA_LINK pLink
    )

/*++

Routine Description:

    The routine starts the send process of a data link station.
    It links the data link send queue to the send
    queue of all link stations and again that queue
    to the main send queue.
    THE QUEUES MUST BE SPIN LOCKED WHEN THIS IS CALLED!

Arguments:

    pAdapterContext - adapter context

    pLink -

Return Value:

    None

--*/

{
    //
    // This procedure can be called when there is nothing to send,
    // or when the send process is already running or when
    // the link is not in a active state for send.
    //

    if (pLink->SendQueue.ListEntry.Flink == NULL
    && !(pLink->Flags & DLC_SEND_DISABLED)
    && !IsListEmpty(&pLink->SendQueue.ListHead)) {

        //
        // Link the queue to the active I send tasks of all links
        //

        LlcInsertTailList(&pAdapterContext->QueueI.ListHead,
                          &pLink->SendQueue.ListEntry
                          );

        //
        // Link first the queue of I send tasks to the generic main
        // send task queue, if it has not yet been linked
        //

        if (pAdapterContext->QueueI.ListEntry.Flink == NULL) {
            LlcInsertTailList(&pAdapterContext->NextSendTask,
                              &pAdapterContext->QueueI.ListEntry
                              );
        }
    }
}


//
// Procedure is a space saving version of the send process enabling
// for the state machine. It also reset any bits disabling the send.
// CALL THIS ONLY FROM THE STATE MACHINE!!!!
//

VOID
EnableSendProcess(
    IN PDATA_LINK pLink
    )
{
    //
    // reset the disabled send state
    //

    pLink->Flags &= ~DLC_SEND_DISABLED;
    pLink->Gen.pAdapterContext->LlcPacketInSendQueue = TRUE;
    StartSendProcess(pLink->Gen.pAdapterContext, pLink);
}


VOID
StopSendProcess(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PDATA_LINK pLink
    )

/*++

Routine Description:


    The routine stops the send process of a data link station.
    It unlinks the data link send queue from the send
    queue of all link stations and again that queue
    from the main send queue.
    THE QUEUES MUST BE SPIN LOCKED WHEN THIS IS CALLED!

Arguments:

    pAdapterContext - adapter context

    pLink - data link object

Return Value:

    None

--*/

{
    //
    // Do all this only if the send process is really running.
    // The NULL pointer marks a list element as a disconnected,
    // A non-empty I- queue of a link may be disconencted from
    // the link station send queue of the adapter, if the link is
    // not in a sending state.  The same thing is true also on
    // the next level.
    //

    if (pLink->SendQueue.ListEntry.Flink != NULL) {

        //
        // unlink the queue from the active I send tasks of all links
        //

        LlcRemoveEntryList(&pLink->SendQueue.ListEntry);
        pLink->SendQueue.ListEntry.Flink = NULL;

        //
        // Unlink first the queue of all I send tasks from the
        // generic main send task queue, if it is now empty.
        //

        if (IsListEmpty(&pAdapterContext->QueueI.ListHead)) {
            LlcRemoveEntryList(&pAdapterContext->QueueI.ListEntry);
            pAdapterContext->QueueI.ListEntry.Flink = NULL;
        }
    }
}


//
// Procedure is a space saving version of the send process disabling
// for the state machine.
//

VOID
DisableSendProcess(
    IN PDATA_LINK pLink
    )
{
    //
    // set the send state variable disabled
    //

    pLink->Flags |= DLC_SEND_DISABLED;
    StopSendProcess(pLink->Gen.pAdapterContext, pLink);
}


PLLC_PACKET
BuildDirOrU_Packet(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function selects the next packet from the queue of connectionless
    frames (U, TEST, XID, DIX and Direct),
    initilizes the LLC packet for the send.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    PLLC_PACKET pPacket;

    //
    // Take next element, select the next send queue and
    // unlink the current queue, if this was the only packet left.
    //

    pPacket = LlcRemoveHeadList(&pAdapterContext->QueueDirAndU.ListHead);

/*
    This is probably just wasting of CPU cycles.  Remove the comments,
    if somebody has troubles because of this.

    ScheduleQueue(&pAdapterContext->NextSendTask);
*/

    if (IsListEmpty(&pAdapterContext->QueueDirAndU.ListHead)) {
        LlcRemoveEntryList(&pAdapterContext->QueueDirAndU.ListEntry);
        pAdapterContext->QueueDirAndU.ListEntry.Flink = NULL;
    }
    return pPacket;
}


DLC_STATUS
SendLlcFrame(
    IN PDATA_LINK pLink,
    IN UCHAR LlcCommandId
    )

/*++

Routine Description:

    Function queues a Type 2 LLC S or U command frame.
    The LLC command code includes also the command/response and
    poll/final bits. That saves quite a lot space in the state machine,
    because this function is called from very many places.
    The code execution may also be faster because of this packing.

Arguments:

    pLink       - current data link station
    LlcCommand  - Packed LLC command (bit 0 is the Poll-Final bit,
                  bit 1 is the command/response and higher bits inlcude
                  the enumerated LLC command code.

Return Value:

    DLC_STATUS

--*/

{
    PLLC_PACKET pPacket;
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pPacket = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

    if (pPacket == NULL) {

        //
        // The non paged pool is empty, we must drop this
        // frame and hope that the protocol can recover (or disconnect)
        //

        return DLC_STATUS_NO_MEMORY;
    }
    pPacket->InformationLength = 0;
    pPacket->pBinding = NULL;

    //
    // Supervisory S commands (RR, RNR, REJ) consists 4 bytes and poll/final
    // bit is in a different place. The unnumbered U commands are only 3
    // bytes, but FRMR has some special data in the info field, that will be
    // added also to the 'extended LLC header'. We must reserve some
    // extra space for the FRMR data in the few NDIS packets!!!!!
    //

    if ((auchLlcCommands[LlcCommandId >> 2] & LLC_S_U_TYPE_MASK) == LLC_S_TYPE) {

        //
        // Build S frame
        //

        pPacket->Data.Xmit.LlcHeader.S.Command = auchLlcCommands[LlcCommandId >> 2];

#if(0)
        if(pPacket->Data.Xmit.LlcHeader.S.Command == LLC_REJ)
		{
			DbgPrint("SendLlcFrame: REJ\n");
		}
#endif
        pPacket->Data.Xmit.pLlcObject = (PLLC_OBJECT)pLink;
        pPacket->Data.Xmit.pLanHeader = pLink->auchLanHeader;
        pPacket->Data.Xmit.LlcHeader.S.Dsap  = pLink->Dsap;
        pPacket->Data.Xmit.LlcHeader.S.Ssap = pLink->Ssap;
        pPacket->CompletionType = LLC_I_PACKET_UNACKNOWLEDGED;
        pPacket->cbLlcHeader = sizeof(LLC_S_HEADER);       // 4
        pPacket->Data.Xmit.LlcHeader.S.Nr = pLink->Vr | (LlcCommandId & (UCHAR)LLC_I_S_POLL_FINAL);

        //
        // Second bit is the LLC command flag, set it to the source SAP
        //

        if (!(LlcCommandId & 2)) {
            pPacket->Data.Xmit.LlcHeader.S.Ssap |= LLC_SSAP_RESPONSE;

            //
            // We must have only one final response in LLC or NDIS
            // send queues in any time.  Thus we just discard any further
            // final responses until the previous one is sent.
            // This is a partial solution to the problem, when the
            // the Elnkii send queue is totally hung because of overflowing
            // packets.
            //

            if ((LlcCommandId & (UCHAR)LLC_I_S_POLL_FINAL)) {
// >>> SNA bug #9517 (NT bug #12907)
#if(0)
                if (pLink->Flags & DLC_FINAL_RESPONSE_PENDING_IN_NDIS) {

                    DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                    return STATUS_SUCCESS;
                }
#endif 

            // Changed the if statment to ignore the Poll only if the link
            // speed is 10MB (the unit of link speed measurement is 100 bps).
            //
            // Ignoring the Poll kills the DLC performance on 100MB ethernet 
            // (particularly on MP machines). The other end must time out (T1 timer) 
            // before it can send more data if we ignore the Poll here.

                if ((pLink->Flags & DLC_FINAL_RESPONSE_PENDING_IN_NDIS) &&
                     pAdapterContext->LinkSpeed <= 100000) {

                     DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                     return STATUS_SUCCESS;
                }

// >>> SNA bug #9517
                pLink->Flags |= DLC_FINAL_RESPONSE_PENDING_IN_NDIS;
            }
        } else if (LlcCommandId & (UCHAR)LLC_I_S_POLL_FINAL) {

            //
            // This is a Command-Poll, set the flag and the current
            // time stamp, whenever a new command poll was queued
            //

            pLink->LastTimeWhenCmdPollWasSent = (USHORT)AbsoluteTime;
            pLink->Flags |= DLC_WAITING_RESPONSE_TO_POLL;
        }

        //
        // The last sent command/response is included in the DLC statistics
        //

        pLink->LastCmdOrRespSent = pPacket->Data.Xmit.LlcHeader.S.Command;
    } else {
        pPacket->Data.XmitU.Command = auchLlcCommands[LlcCommandId >> 2];
        pPacket->Data.XmitU.Dsap  = pLink->Dsap;
        pPacket->Data.XmitU.Ssap = pLink->Ssap;

        //
        // Second bit is the LLC command flag, set it to the source SAP
        //

        if (!(LlcCommandId & 2)) {
            pPacket->Data.XmitU.Ssap |= LLC_SSAP_RESPONSE;
        }

        //
        // Build a U command frame (FRMR has some data!!!)
        //

        pPacket->cbLlcHeader = sizeof(LLC_U_HEADER);       // 3

        if (pPacket->Data.XmitU.Command == LLC_FRMR) {
            pPacket->cbLlcHeader += sizeof(LLC_FRMR_INFORMATION);
            pPacket->Data.Response.Info.Frmr = pLink->DlcStatus.FrmrData;
        }
        if (LlcCommandId & 1) {
            pPacket->Data.XmitU.Command |= LLC_U_POLL_FINAL;
        }

        //
        // U- commands (eg. UA response for DISC) may be sent after
        // the link object has been deleted.  This invalidates
        // the lan header pointer => we must change all U- commands
        // to response types.  Null object handle prevents the
        // the close process to cancel the packet, when the
        // station is closed.
        //

        //
        // RLF 05/09/94
        //
        // If the framing type stored in the link structure is unspecified then
        // either this is an AUTO configured binding and we haven't worked out
        // the type of framing to use, or this is not an AUTO configured binding.
        // In this case, defer to the address translation stored in the binding.
        // If the framing type is known, use it
        //

        if (pLink->FramingType == LLC_SEND_UNSPECIFIED) {
            pPacket->Data.XmitU.TranslationType = (UCHAR)pLink->Gen.pLlcBinding->InternalAddressTranslation;
        } else {
            pPacket->Data.XmitU.TranslationType = (UCHAR)pLink->FramingType;
        }
        pPacket->CompletionType = LLC_U_COMMAND_RESPONSE;

        pPacket->Data.XmitU.pLanHeader = (PUCHAR)ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

        if (pPacket->Data.XmitU.pLanHeader == NULL) {

            DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

            return DLC_STATUS_NO_MEMORY;
        }

        LlcMemCpy(pPacket->Data.XmitU.pLanHeader,
                  pLink->auchLanHeader,
                  pLink->cbLanHeaderLength
                  );

        //
        // In the AUTO mode in ethernet we duplicate all
        // TEST, XID and SABME packets and send them both in
        // 802.3 and DIX formats.
        //

        //
        // RLF 05/09/94
        //
        // Similarly, we duplicate DISC frames (since right now we don't
        // keep per-destination frame state information)
        //

        if (((pPacket->Data.XmitU.Command & ~LLC_U_POLL_FINAL) == LLC_SABME)
//        || ((pPacket->Data.XmitU.Command & ~LLC_U_POLL_FINAL) == LLC_DISC)
        ) {
            CheckAndDuplicatePacket(
#if DBG
                                    pAdapterContext,
#endif
                                    pLink->Gen.pLlcBinding,
                                    pPacket,
                                    &pAdapterContext->QueueExpidited
                                    );
        }

        //
        // The last sent command/response is included in the DLC statistics
        //

        pLink->LastCmdOrRespSent = pPacket->Data.XmitU.Command;
    }

    LlcInsertTailList(&pAdapterContext->QueueExpidited.ListHead, pPacket);

    //
    // The S- frames must be sent immediately before any I- frames,
    // because otherwise the sequential frames may have NRs in a
    // wrong order => FRMR  (that's why we insert the expidited
    // queue to the head instead of the tail.
    //

    pAdapterContext->LlcPacketInSendQueue = TRUE;
    if (pAdapterContext->QueueExpidited.ListEntry.Flink == NULL) {
        LlcInsertHeadList(&pAdapterContext->NextSendTask,
                          &pAdapterContext->QueueExpidited.ListEntry
                          );
    }

    return STATUS_SUCCESS;
}


PLLC_PACKET
GetLlcCommandPacket(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function selects the next LLC command from the expidited queue.

Arguments:

    pAdapterContext - adapter context

Return Value:

    PLLC_PACKET

--*/

{
    PLLC_PACKET pPacket;

    //
    // Unlink the current task, if this was the only one left.
    // We will send the expidited packets as far as there is any
    //

    pPacket = LlcRemoveHeadList(&pAdapterContext->QueueExpidited.ListHead);
    if (pPacket->CompletionType == LLC_I_PACKET_UNACKNOWLEDGED) {
        pPacket->CompletionType = LLC_I_PACKET;
    }
    if (IsListEmpty(&pAdapterContext->QueueExpidited.ListHead)) {
        LlcRemoveEntryList(&pAdapterContext->QueueExpidited.ListEntry);
        pAdapterContext->QueueExpidited.ListEntry.Flink = NULL;
    }
    return pPacket;
}


VOID
SendNdisPacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    Function builds NDIS packet. LAN and LLC headers can be
    given separately to this routine. All NDIS packets
    include a fixed MDL descriptor and buffer for the headers.
    The actual data is linked after that header.
    I would say, that this is a clever algorithm,
    in this way we avoid quite well the supid NDIS packet management.
    We have just a few (5) NDIS packets for each adapter.

    The direct frames includes only the LAN header and MDL pointer are
    linked directly to the packet

    Steps:

    1. Reset the NDIS packet
    2. Get the frame translation type and initialize the completion
       packet.
    3. Build the LAN header into a small buffer in NDIS packet.
    4. Copy optional LLC header behind it
    5. Initialize NDIS packet for the send
    6. Send the packet
    7. if command not pending
        - Complete the packet (if there was a non-null request handle)
        - Link the NDIS packet back to the send queue.

Arguments:

    pAdapterContext - NDIS adapter context
    pPacket         - generic LLC transmit packet used for all transmit types

Return Value:

    NDIS_STATUS  (status of NdisSend)

--*/

{
    UCHAR LlcOffset;
    PLLC_NDIS_PACKET pNdisPacket;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Sometimes we must discard I-frame in GetI_Packet routine and
    // return a NULL packet
    //

    if (pPacket == NULL) {
        return;
    }


    //
    // Allocate an NDIS packet from the pool and reset the private NDIS header!
    //

    pNdisPacket = PopFromList((PLLC_PACKET)pAdapterContext->pNdisPacketPool);
    ResetNdisPacket(pNdisPacket);

    //
    // The internal LAN headers always have the correct address format. Only
    // Dir and Type 1 LAN headers need to be swapped, because they are owned
    // by users. The internal address swapping is defined by binding basis
    // because some transports may want to use DIX\DLC Saps, and others just
    // the normal 802.3 DLC
    //

    if (pPacket->CompletionType == LLC_I_PACKET) {
        pNdisPacket->pMdl->Next = pPacket->Data.Xmit.pMdl;
        ReferenceObject(pPacket->Data.Xmit.pLlcObject);

        //
        // Type 2 packets use always the LAN header of the link station
        //

        LlcMemCpy(pNdisPacket->auchLanHeader,
                  pPacket->Data.Xmit.pLanHeader,
                  LlcOffset = pPacket->Data.Xmit.pLlcObject->Link.cbLanHeaderLength
                  );

        //
        // Copy the LLC header as it is, the case set its offset
        //

        LlcMemCpy(&pNdisPacket->auchLanHeader[LlcOffset],
                  &pPacket->Data.Xmit.LlcHeader,
                  4
                  );
    } else {

        //
        // We must increment the reference counter of an LLC object, when
        // we give its pointer to NDIS queue (and increment it, when the
        // command is complete)
        //-------
        // We need two references for each transmit, First caller (DLC module)
        // must reference and dereference the object to keep it alive over
        // the synchronous code path here we do it second time to keep the
        // object alive, when it has pointers queued on NDIS
        //

        if (pPacket->CompletionType > LLC_MAX_RESPONSE_PACKET) {
            pNdisPacket->pMdl->Next = pPacket->Data.Xmit.pMdl;
            ReferenceObject(pPacket->Data.Xmit.pLlcObject);
        } else if (pPacket->CompletionType > LLC_MIN_MDL_PACKET) {
            pNdisPacket->pMdl->Next = pPacket->Data.Xmit.pMdl;
        } else {
            pNdisPacket->pMdl->Next = NULL;
        }

        //
        // LLC_TYPE_1 packets have non-null binding, the internally
        // sent packets (ie. XID and TEST frames) use the current
        // internal default format (tr, ethernet or dix)
        //

        LlcOffset = CopyLanHeader(pPacket->Data.XmitU.TranslationType,
                                  pPacket->Data.XmitU.pLanHeader,
                                  pAdapterContext->NodeAddress,
                                  pNdisPacket->auchLanHeader,
                                  pAdapterContext->ConfigInfo.SwapAddressBits
                                  );
        LlcMemCpy(&pNdisPacket->auchLanHeader[LlcOffset],
                  &pPacket->Data.XmitU.Dsap,
                  pPacket->cbLlcHeader
                  );
    }
    pNdisPacket->pCompletionPacket = pPacket;
    MmGetMdlByteCount(pNdisPacket->pMdl) = LlcOffset + pPacket->cbLlcHeader;

    //
    // We must set the lenth field of all 802.2 or DIX DLC Ethernet frames,
    // BUT NOT FOR DIX ethernet types having 2 bytes long 'LLC header'
    //

    if ((pAdapterContext->NdisMedium == NdisMedium802_3) && (pPacket->cbLlcHeader != 2)) {

        UINT InformationLength;

        InformationLength = pPacket->cbLlcHeader + pPacket->InformationLength;

        //
        // The possible offets are 12 and 14 and LLC offsets are 14 and 17
        //

        pNdisPacket->auchLanHeader[(LlcOffset & 0xfe) - 2] = (UCHAR)(InformationLength >> 8);
        pNdisPacket->auchLanHeader[(LlcOffset & 0xfe) - 1] = (UCHAR)InformationLength;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    RELEASE_DRIVER_LOCK();

    NdisChainBufferAtFront((PNDIS_PACKET)pNdisPacket, pNdisPacket->pMdl);

#if LLC_DBG

    if (pNdisPacket->ReferenceCount != 0) {
        DbgBreakPoint();
    }
    pNdisPacket->ReferenceCount++;

#endif

#ifdef LLC_LOSE_I_PACKETS

    //
    // This code tests the error recoverability of the LLC protocol.
    // We randomly delete packets to check how the protocol recovers.
    // We use current timer tick, running static and a table of random
    // numbers.
    //

    if (pPacket->CompletionType == LLC_I_PACKET) {

        static UINT i = 0;

        //
        // 2 % is high enough.  With 20 percent its takes forever to
        // send the data.  We send all discarded packets to Richard =>
        // we can see in the net which one packets were lost.
        //

        i++;
        if (aRandom[(i % 1000)] <= (USHORT)DBG_ERROR_PERCENT(2)) {
            if (pAdapterContext->NdisMedium == NdisMedium802_3) {
                memcpy(pNdisPacket->auchLanHeader,
                       "\0FIRTH",
                       6
                       );
            } else {
                memcpy(&pNdisPacket->auchLanHeader[2],
                       "\0FIRTH",
                       6
                       );
            }
        }
    }

#endif

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'dneS');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) == BIND_STATE_BOUND)
    {                                           
        NdisSend(&Status,
                 pAdapterContext->NdisBindingHandle,
                 (PNDIS_PACKET)pNdisPacket
                 );
    }
    // Above reference is removed by LlcNdisSendComplete handler.
#endif // NDIS40
    

    //
    // Ndis may return a synchronous status!
    //

    if (Status != NDIS_STATUS_PENDING) {
        LlcNdisSendComplete(pAdapterContext,
                            (PNDIS_PACKET)pNdisPacket,
                            Status
                            );
    }

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

}


VOID
CompleteSendAndLock(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_PACKET pNdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    The routines completes the connectionless packets and also the
    I-frames if they have already acknowledged by the other side.
    We will leave the send spinlock locked.

Arguments:

    pAdapterContext - current adapter context
    pNdisPacket     - the NDIS packet used in teh send.
    NdisStatus      - the status of the send operation

Return Value:

    None

--*/

{
    PLLC_PACKET pPacket;
    PLLC_OBJECT pLlcObject;
    UCHAR CompletionType;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE( 'A' );

    //
    // Only the connectionless packets issued by user needs
    // a command completion.  I- frames are indicated when they
    // are acknowledged by the remote link station.
    //

    pPacket = pNdisPacket->pCompletionPacket;
    pLlcObject = pPacket->Data.Xmit.pLlcObject;
    if ((CompletionType = pPacket->CompletionType) == LLC_TYPE_1_PACKET) {

        DLC_TRACE( 'j' );

        pPacket->Data.Completion.Status = NdisStatus;
        pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
        pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                             pLlcObject->Gen.hClientHandle,
                                             pPacket
                                             );
    }

    //
    // !!! DON'T TOUCH PACKET AFTER THE PREVIOUS PROCEDURE CALL
    //     (unless the packet type is different from Type 1)
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

#if LLC_DBG

    pNdisPacket->ReferenceCount--;
    if (pNdisPacket->ReferenceCount != 0) {
        DbgBreakPoint();
    }

#endif

    PushToList((PLLC_PACKET)pAdapterContext->pNdisPacketPool, (PLLC_PACKET)pNdisPacket);

    //
    // We first complete the internal packets of the data link driver,
    // that has no connection to the link objects.
    //

    if (CompletionType <= LLC_MAX_RESPONSE_PACKET) {

        DLC_TRACE('l');

        //
        // XID and U- command reponses have allocated two packets.
        // TEST reponses have allocated a non paged pool buffer
        // and MDL for the echones frame (it might have been 17 kB)
        //

        switch(CompletionType) {
        case LLC_XID_RESPONSE:
            pAdapterContext->XidTestResponses--;

#if LLC_DBG

            ((PLLC_PACKET)pPacket->Data.Response.pLanHeader)->pNext = NULL;

#endif

            DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket->Data.Response.pLanHeader);

            break;

        case LLC_U_COMMAND_RESPONSE:

#if LLC_DBG

            //
            // Break immediately, when we have sent a FRMR packet
            //

            if (pPacket->Data.Xmit.LlcHeader.U.Command == LLC_FRMR) {
                DbgBreakPoint();
            }
            ((PLLC_PACKET)pPacket->Data.Response.pLanHeader)->pNext = NULL;

#endif

            DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket->Data.Response.pLanHeader);

            break;

        case LLC_TEST_RESPONSE:
            pAdapterContext->XidTestResponses--;

            //
            // RLF 03/30/93
            //
            // The TEST response packet may have had 0 information field length,
            // in which case the MDL will be NULL
            //

            if (pPacket->Data.Response.Info.Test.pMdl) {
                IoFreeMdl(pPacket->Data.Response.Info.Test.pMdl);
            }
            FREE_MEMORY_ADAPTER(pPacket->Data.Response.pLanHeader);
            break;

#if LLC_DBG

        case LLC_DIX_DUPLICATE:
            break;

        default:
            LlcInvalidObjectType();
            break;

#endif

        }

        DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

    } else {

        //
        // We use extra status bits to indicate, when I- packet has been both
        // completed by NDIS and acknowledged by the other side of link
        // connection. An I packet can be queued to the completion queue by
        // the second quy (either state machine or SendCompletion handler)
        // only when the first guy has completed its work.
        // An I packet could be acknowledged by the other side before
        // its completion is indicated by NDIS.  Dlc Driver deallocates
        // the packet immediately, when Llc driver completes the acknowledged
        // packet => possible data corruption (if packet is reused before
        // NDIS has completed it).  This is probably not possible in a
        // single processor  NT- system, but very possible in multiprocessor
        // NT or systems without a single level DPC queue (like OS/2 and DOS).
        //

        if (CompletionType != LLC_TYPE_1_PACKET) {

            DLC_TRACE( 'k' );

            //
            // All packets allocated for S-type frames have null
            // binding context.  All the rest of packets must
            // be I- completions.
            //

            if (pPacket->pBinding == NULL) {

                //
                // We cannot send a new final response before
                // the previous one has been complete by NDIS.
                //

                if ((pPacket->Data.Xmit.LlcHeader.S.Nr & LLC_I_S_POLL_FINAL)
                && (pPacket->Data.Xmit.LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)) {
                    pLlcObject->Link.Flags &= ~DLC_FINAL_RESPONSE_PENDING_IN_NDIS;
                }

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

            } else {
                pPacket->CompletionType &= ~LLC_I_PACKET_PENDING_NDIS;

                //
                // A packet cannot be resent before the previous send
                // has been completed by NDIS.  We have simply stopped
                // the send process until the NDIS is completed here.
                //

                if (pPacket->CompletionType & LLC_I_PACKET_WAITING_NDIS) {
                    pPacket->CompletionType &= ~LLC_I_PACKET_WAITING_NDIS;
                    StartSendProcess(pAdapterContext, (PDATA_LINK)pLlcObject);
                } else if (pPacket->CompletionType == LLC_I_PACKET_COMPLETE) {

                    //
                    // We don't care at all about the result of the
                    // NDIS send operation with the I-frames.
                    // If the other side has acknowledged the packet,
                    // it is OK.   In that case we had to wait the send
                    // to complete, because an too early ack and
                    // command completion would have invalidated
                    // the pointer on NDIS.
                    //

                    LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
                    BackgroundProcessWithinLock(pAdapterContext);
                }
            }
        }

        //
        // Pending close commands of LLC object must wait until all its
        // NDIS send commands have been completed.
        // We must also indicate the completed send command.
        // The same must be true, when we are cancelling transmit commands.
        // The system crashes, if we remove a transmit command, that is
        // not yet sent or it is just being sent by NDIS.
        // => Dereference LlcObject when the ndis packet is complete,
        // We must run the background process
        //

        pLlcObject->Gen.ReferenceCount--;
        if (pLlcObject->Gen.ReferenceCount == 0) {
            CompletePendingLlcCommand(pLlcObject);
            BackgroundProcessWithinLock(pAdapterContext);
        }
        DLC_TRACE((UCHAR)pLlcObject->Gen.ReferenceCount);
    }
}


VOID
RespondTestOrXid(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN LLC_HEADER LlcHeader,
    IN UINT SourceSap
    )

/*++

Routine Description:

    Function builds a response packet for the XID or TEST frame.
    All TEST Commands are echoed directy back as responses.
    802.2 XID header is the only supported XID command type.

Arguments:

    pAdapterContext - current adapter context
	MacReceiveContext - For NdisTransferData
    LlcHeader       - The received LLC header
    SourceSap       - current source SAP

Return Value:

    None

--*/

{
    PLLC_PACKET pPacket = NULL;
    USHORT InfoFieldLength;
    UINT BytesCopied;
    NDIS_STATUS Status;
    PMDL pTestMdl = NULL;
    PUCHAR pBuffer = NULL;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Respond to a 802.2 XIDs and TESTs, and discard everything else
    // Echo the TEST commands back with the same information field
    // (but that's limited by our buffer capasity).
    //

    if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_TEST) {

        //
        // Echo the TEST frames back to the sender, but only, we do:
        // 1. Allocate a buffer from the non-paged pool
        // 2. Allocate a MDL for it
        // 3. Transfer the data
        //

        if (pAdapterContext->cbPacketSize < (pAdapterContext->RcvLanHeaderLength + sizeof(LLC_U_HEADER)) ) {
          return;
        }


        InfoFieldLength = (USHORT)(pAdapterContext->cbPacketSize
                        - (pAdapterContext->RcvLanHeaderLength
                        + sizeof(LLC_U_HEADER)));
        pBuffer = ALLOCATE_ZEROMEMORY_ADAPTER(pAdapterContext->cbPacketSize);
        if (pBuffer == NULL) {
            return;
        }

        //
        // RLF 03/30/93
        //
        // There may be no data in the info field to transfer. In this case
        // don't allocate a MDL
        //

        if (InfoFieldLength) {
            pTestMdl = IoAllocateMdl(pBuffer
                                     + pAdapterContext->RcvLanHeaderLength
                                     + sizeof(LLC_U_HEADER),
                                     InfoFieldLength,
                                     FALSE,
                                     FALSE,
                                     NULL
                                     );
            if (pTestMdl == NULL) {
                goto ProcedureErrorExit;
            }
            MmBuildMdlForNonPagedPool(pTestMdl);

            //
            // Copy the TEST data from NDIS to our buffer
            //

            ResetNdisPacket(&pAdapterContext->TransferDataPacket);

            RELEASE_DRIVER_LOCK();

            NdisChainBufferAtFront((PNDIS_PACKET)&pAdapterContext->TransferDataPacket, pTestMdl);

            //
            // ADAMBA - Removed pAdapterContext->RcvLanHeaderLength
            // from ByteOffset (the fourth param).
            //

            NdisTransferData(&Status,
                             pAdapterContext->NdisBindingHandle,
                             MacReceiveContext,
                             sizeof(LLC_U_HEADER)

                             //
                             // RLF 05/09/94
                             //
                             // if we have received a DIX packet then the data
                             // starts 3 bytes from where NDIS thinks the start
                             // of non-header data is
                             //
                             // ASSUME: Only DIX frames have header length of
                             // 17 (i.e. on Ethernet)
                             //
                             // What about FDDI?
                             //

                             + ((pAdapterContext->RcvLanHeaderLength == 17) ? 3 : 0),
                             InfoFieldLength,
                             (PNDIS_PACKET)&pAdapterContext->TransferDataPacket,
                             &BytesCopied
                             );

            ACQUIRE_DRIVER_LOCK();

            //
            // We don't care if the transfer data is still pending,
            // If very, very unlikely, that the received dma would
            // write the data later, than a new transmit command
            // would read the same data. BUT we cannot continue,
            // if transfer data failed.
            //

            if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
                goto ProcedureErrorExit;
            }
        }
    } else if (((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) != LLC_XID)
    || (LlcHeader.auchRawBytes[3] != IEEE_802_XID_ID)) {

        //
        // This was not a IEEE 802.2 XID !!!
        //

        return;
    }

    //
    // We have only a limited number reponse packets available
    // for the XID and TEST responses. Thus we will
    // drop many packets in a broadcast storms created by token-ring
    // source routing bridges, that is
    // actually a good thing. On the other hand we may
    // also loose some packets that should have been reponsed,
    // but who cares (this is a connectionless thing).
    // (This is probably wasted effort, XID and TEST frames are not
    // usually sent with the broadcast bit set).
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    if ((pAdapterContext->XidTestResponses < MAX_XID_TEST_RESPONSES)
    && ((pPacket = (PLLC_PACKET)ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool)) != NULL)) {

        if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_XID) {

            pPacket->Data.Xmit.pLanHeader = (PUCHAR)ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

            if (pPacket->Data.Xmit.pLanHeader == NULL) {

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                pPacket = NULL;
                goto LockedErrorExit;
            } else {
                LlcMemCpy(&pPacket->Data.Response.Info,
                          &Ieee802Xid,
                          sizeof(Ieee802Xid)
                          );
                pPacket->InformationLength = 0;
                pPacket->cbLlcHeader = sizeof(Ieee802Xid) + sizeof(LLC_U_HEADER);
                pPacket->CompletionType = LLC_XID_RESPONSE;
            }
        } else {
            pPacket->Data.Xmit.pLanHeader = pBuffer;
            pPacket->cbLlcHeader = sizeof(LLC_U_HEADER);
            pPacket->CompletionType = LLC_TEST_RESPONSE;
            pPacket->Data.Response.Info.Test.pMdl = pTestMdl;
            pPacket->InformationLength = InfoFieldLength;
        }
        pAdapterContext->XidTestResponses++;

        //
        // The packet initialization is the same for XID and TEST
        //

        pPacket->Data.XmitU.Dsap = (UCHAR)(LlcHeader.U.Ssap & ~LLC_SSAP_RESPONSE);
        pPacket->Data.XmitU.Ssap = (UCHAR)(SourceSap | LLC_SSAP_RESPONSE);
        pPacket->Data.XmitU.Command = LlcHeader.U.Command;

        if (pAdapterContext->NdisMedium == NdisMedium802_5) {
            pPacket->Data.Response.TranslationType = LLC_SEND_802_5_TO_802_5;
        } else if (pAdapterContext->NdisMedium == NdisMediumFddi) {
            pPacket->Data.Response.TranslationType = LLC_SEND_FDDI_TO_FDDI;
        } else if (pAdapterContext->RcvLanHeaderLength == 17) {
            pPacket->Data.Response.TranslationType = LLC_SEND_802_3_TO_DIX;
        } else {
            pPacket->Data.Response.TranslationType = LLC_SEND_802_3_TO_802_3;
        }
        LlcBuildAddressFromLanHeader(pAdapterContext->NdisMedium,
                                     pAdapterContext->pHeadBuf,
                                     pPacket->Data.Xmit.pLanHeader
                                     );

        //
        // Connect the packet to the send queues, we can use a subprocedure
        // because this is not on the main code path
        //

        QueuePacket(pAdapterContext, &pAdapterContext->QueueDirAndU, pPacket);

        //
        // Request and send process execution from the receive indication
        //

        pAdapterContext->LlcPacketInSendQueue = TRUE;
    }

LockedErrorExit:

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

ProcedureErrorExit:

    if (pPacket == NULL) {
        if (pBuffer) {
            FREE_MEMORY_ADAPTER(pBuffer);
        }
        if (pTestMdl != NULL) {
            IoFreeMdl(pTestMdl);
        }
    }
}

//
// The table maps all SAP send commands to the actual LLC commands
//

static struct {
    UCHAR   ResponseFlag;
    UCHAR   Command;
} Type1_Commands[LLC_LAST_FRAME_TYPE / 2] = {
    {(UCHAR)-1, (UCHAR)-1},
    {(UCHAR)-1, (UCHAR)-1},
    {(UCHAR)-1, (UCHAR)-1},
    {0, LLC_UI},                                        // UI command
    {0, LLC_XID | LLC_U_POLL_FINAL},                    // XID_COMMAND_POLL
    {0, LLC_XID},                                       // XID_COMMAND_NOT_POLL
    {LLC_SSAP_RESPONSE, LLC_XID | LLC_U_POLL_FINAL},    // XID_RESPONSE_FINAL
    {LLC_SSAP_RESPONSE, LLC_XID},                       // XID_RESPONSE_NOT_FINAL
    {LLC_SSAP_RESPONSE, LLC_TEST | LLC_U_POLL_FINAL},   // TEST_RESPONSE_FINAL
    {LLC_SSAP_RESPONSE, LLC_TEST},                      // TEST_RESPONSE_NOT_FINAL
    {(UCHAR)-1, (UCHAR)-1},
    {0, LLC_TEST | LLC_U_POLL_FINAL}                    // TEST_RESPONSE_FINAL
};


VOID
LlcSendU(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pPacket,
    IN UINT eFrameType,
    IN UINT uDestinationSap
    )

/*++

Routine Description:

    Function sends the given network frame. and sets up
    The frame may be a direct frame or Type 1 connectionless
    frame (UI, XID or TEST).

    First we build LLC (or ethernet type) header for the frame
    and then we either send the packet directly or queue it
    on data link.

Arguments:

    pStation        - Link, SAP or Direct station handle
    pPacket         - data link packet, also the completion handle for
                      the upper protocol.
    eFrameType      - the sent frame type
    uDestinationSap - destination sap or dix ethernet type

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;
    UINT Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('U');

    pPacket->pBinding = pStation->Gen.pLlcBinding;
    pPacket->Data.Xmit.pLlcObject = pStation;
    pPacket->CompletionType = LLC_TYPE_1_PACKET;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // Build LLC header for SAP stations, the direct stations do not have any
    // LLC header
    //

    switch (pStation->Gen.ObjectType) {
    case LLC_SAP_OBJECT:
        pPacket->cbLlcHeader = sizeof(LLC_U_HEADER);
        pPacket->Data.XmitU.TranslationType = (UCHAR)pStation->Gen.pLlcBinding->AddressTranslation;
        pPacket->Data.XmitU.Dsap = (UCHAR)uDestinationSap;
        pPacket->Data.XmitU.Ssap = (UCHAR)pStation->Sap.SourceSap;
        pPacket->Data.XmitU.Ssap |= Type1_Commands[eFrameType >> 1].ResponseFlag;
        pPacket->Data.XmitU.Command = Type1_Commands[eFrameType >> 1].Command;

        //
        // Do the UI- code path ASAP, then check TEST and XID special cases
        //

        if (pPacket->Data.XmitU.Command != LLC_UI) {

            //
            // Data link driver must build the DLC headers if it handles XID
            // frames internally. In this case we use a constant XID info field
            //

            if ((pStation->Sap.OpenOptions & LLC_HANDLE_XID_COMMANDS)
            && ((eFrameType == LLC_XID_COMMAND_POLL)
            || (eFrameType == LLC_XID_COMMAND_NOT_POLL))) {

                pPacket->Data.XmitU.pMdl = pXidMdl;
            }

            //
            // duplicated TEST and XID frame responses are in a separate
            // function since they're off the main code path. The code is also
            // used in more than one place
            //

            Status = CheckAndDuplicatePacket(
#if DBG
                                             pAdapterContext,
#endif
                                             pStation->Gen.pLlcBinding,
                                             pPacket,
                                             &pAdapterContext->QueueDirAndU
                                             );
            if (Status != DLC_STATUS_SUCCESS) {
                goto ErrorExit;
            }
        }
        break;

    case LLC_DIRECT_OBJECT:

        //
        // We must not send MAC frames to an ethernet network!!!
        // Bit7 and bit6 in FC byte defines the frame type in token ring.
        // 00 => MAC frame (no LLC), 01 => LLC, 10,11 => reserved.
        // We send all other frames to direct except 01 (LLC)
        //

        if (pAdapterContext->NdisMedium != NdisMedium802_5
        && (pPacket->Data.XmitU.pLanHeader[1] & 0xC0) != 0x40) {
            goto ErrorExit;
        }
        pPacket->Data.XmitU.TranslationType = (UCHAR)pStation->Gen.pLlcBinding->AddressTranslation;
        pPacket->cbLlcHeader = 0;
        break;

    case LLC_DIX_OBJECT:

        //
        // Return error if we are sending DIX frames to a token-ring network.
        // The DIX lan header is always in an ethernet format.
        // (But lan headers for LLC and DIR frames are in token-ring
        // format)
        //

        if (pAdapterContext->NdisMedium != NdisMedium802_3) {
            Status = DLC_STATUS_UNAUTHORIZED_MAC;
            goto ErrorExit;
        }
        pPacket->cbLlcHeader = 2;
        pPacket->Data.XmitDix.TranslationType = LLC_SEND_DIX_TO_DIX;
        pPacket->Data.XmitDix.EthernetTypeLowByte = (UCHAR)uDestinationSap;
        pPacket->Data.XmitDix.EthernetTypeHighByte = (UCHAR)(uDestinationSap >> 8);
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    }

    //
    // Update the statistics, we may count the transmits as well here because
    // the failed transmissions are not counted. This should be moved to
    // SendComplete and be incremented only if STATUS_SUCCESS and if we counted
    // only the successful transmits. I don't really know which one should be
    // counted
    //

    pStation->Sap.Statistics.FramesTransmitted++;

    LlcInsertTailList(&pAdapterContext->QueueDirAndU.ListHead, pPacket);

    if (pAdapterContext->QueueDirAndU.ListEntry.Flink == NULL) {
        LlcInsertTailList(&pAdapterContext->NextSendTask,
                          &pAdapterContext->QueueDirAndU.ListEntry
                          );
    }

    RunSendTaskAndUnlock(pAdapterContext);
    return;

ErrorExit:

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    pPacket->Data.Completion.Status = Status;
    pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
    pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                         pStation->Gen.hClientHandle,
                                         pPacket
                                         );
}


VOID
LlcSendI(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The primitive implements a pure connection-oriented LLC Class II send.
    It sends frame to the remote link station and
    indicates the upper protocol when the data has been acknowledged.
    The link station provides all address information and LLC header.
    Function queues the given I packet to the queue and connects the
    I- packet queue to the main send queue, if it has not
    yet been connected.

Arguments:

    pStation    - link, sap or direct station handle
    pPacket     - data link packet, it is used also a request handle
                  to identify the command completion

Return Value:

    None.

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('I');

    pPacket->pBinding = pStation->Gen.pLlcBinding;
    pPacket->cbLlcHeader = sizeof(LLC_I_HEADER);

    //
    // We keep the acknowledge bit set, because it identifies that
    // the packet is not yet in the NDIS queue
    //

    pPacket->CompletionType = LLC_I_PACKET_UNACKNOWLEDGED;
    pPacket->Data.Xmit.pLlcObject = (PLLC_OBJECT)pStation;
    pPacket->Data.Xmit.pLanHeader = pStation->auchLanHeader;

    //
    // We check the info field length for I- frames.
    // All Type 1 frames are checked by the data link.
    // Actually it checks also the I-frames, but
    // data links do not care about the physical errors.
    // It would disconnect the link after the too
    // many retries.
    //

    if (pPacket->InformationLength > pStation->MaxIField) {
        pPacket->Data.Completion.Status = DLC_STATUS_INVALID_FRAME_LENGTH;
        pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
        pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                             pStation->Gen.hClientHandle,
                                             pPacket
                                             );
    } else {

        PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;

        //
        // We must do all queue handling inside the send spin lock. We also have
        // to enable the send process and run the background process only when
        // the send queue has been emptied
        //

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        if (!(PrimaryStates[pStation->State] & LLC_LINK_OPENED)) {

            RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

            //
            // The 802.2 state machine may discard the data send request.
            // It may also only queue the packet, but to keep the send process
            // disabled
            //

            pPacket->Data.Completion.Status = DLC_STATUS_LINK_NOT_TRANSMITTING;
            pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
            pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                                 pStation->Gen.hClientHandle,
                                                 pPacket
                                                 );
        } else {
            LlcInsertTailList(&pStation->SendQueue.ListHead, pPacket);

            if (pStation->SendQueue.ListEntry.Flink == NULL) {
                StartSendProcess(pAdapterContext, pStation);
            }
            RunSendTaskAndUnlock(pAdapterContext);
        }
    }
}


VOID
QueuePacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_QUEUE pQueue,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The routines queues a packet to a queue and connects the
    queue to the send tack list, if it was not connected.
    This procedure is called from the non-timecritical code paths
    just to save some extra code.

Arguments:

    pAdapterContext - context of the data link adapter
    pQueue          - a special send queue structure
    pPacket         - transmit packet

Return Value:

    None

--*/

{
    LlcInsertTailList(&pQueue->ListHead, pPacket);

    if (pQueue->ListEntry.Flink == NULL) {
        LlcInsertTailList(&pAdapterContext->NextSendTask, &pQueue->ListEntry);
    }
}


DLC_STATUS
CheckAndDuplicatePacket(
#if DBG
    IN PADAPTER_CONTEXT pAdapterContext,
#endif
    IN PBINDING_CONTEXT pBinding,
    IN PLLC_PACKET pPacket,
    IN PLLC_QUEUE pQueue
    )

/*++

Routine Description:

    If determining the ethernet type dynamically, create a duplicate DIX frame
    for a SABME or XID or TEST frame

Arguments:

    pBindingContext - current data link binding context
    pPacket         - transmit packet
    pQueue          - a special send queue structure

Return Value:

    DLC_STATUS
        Success - DLC_STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PLLC_PACKET pNewPacket;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pBinding->EthernetType == LLC_ETHERNET_TYPE_AUTO) {

        pNewPacket = ALLOCATE_PACKET_LLC_PKT(pBinding->pAdapterContext->hPacketPool);

        if (pNewPacket == NULL) {
            return DLC_STATUS_NO_MEMORY;
        } else {

            *pNewPacket = *pPacket;
            pNewPacket->pBinding = NULL;
            pNewPacket->CompletionType = LLC_DIX_DUPLICATE;

            //
            // We always send first the 802.3 packet and then the DIX one.
            // The new packet must be sent first, because it has no resources
            // associated with it. Therefore we must change the type of the
            // old packet
            //
            //

            if (pPacket->Data.XmitU.TranslationType == LLC_SEND_802_5_TO_802_3) {

                //
                //  token-ring -> dix
                //

                pPacket->Data.XmitU.TranslationType = LLC_SEND_802_5_TO_DIX;
            } else if (pPacket->Data.XmitU.TranslationType == LLC_SEND_802_3_TO_802_3) {

                //
                //  ethernet 802.3 -> dix
                //

                pPacket->Data.XmitU.TranslationType = LLC_SEND_802_3_TO_DIX;
            }
            QueuePacket(pBinding->pAdapterContext, pQueue, pNewPacket);
        }
    }
    return DLC_STATUS_SUCCESS;
}


VOID
BackgroundProcessWithinLock(
    IN PADAPTER_CONTEXT pAdapterContext
    )
{
    ASSUME_IRQL(DISPATCH_LEVEL);

    BackgroundProcessAndUnlock(pAdapterContext);

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llctrace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  ICL Data

Module Name:

    llctrace.c

Abstract:

    Module implements simple trace buffer management.
    The application must povides a trace buffer and
    read it by polling.
    
    THIS MODULE HAS BEEN IMPLEMENTED ONLY FOR THE DATA LINK 
    EMULATION ENVIRONMENT ON USER LEVEL.
    

Author:

    Antti Saarenheimo (o-anttis) 10-OCT-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <llc.h>
#ifndef max
#include <stdlib.h>
#endif

#ifdef  TRACE_ENABLED

BOOLEAN                     TraceEnabled;
static PLLC_TRACE_HEADER    pTraceBufferBase;
static PLLC_TRACE_HEADER    pTraceBufferTop;
static PLLC_TRACE_HEADER    pTraceBufferHead;
static NDIS_SPIN_LOCK       TraceLock;
static ULONG                TraceFlags;


UCHAR GetHexDigit( 
    UINT   Ch
    );
PUCHAR
GetHexString( 
    PUCHAR pDest, 
    UINT Length,
    PUCHAR Buffer 
    );
DLC_STATUS
LlcTraceInitialize(
    IN PVOID pUserTraceBuffer,
    IN ULONG UserTraceBufferSize,
    IN ULONG UserTraceFlags
    )
{
    //
    //  This small piece of code is not multiprocessors safe,
    //  but nobody will ever find it ...
    //
    if (TraceEnabled)
    {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }
    if (UserTraceBufferSize < LLC_MIN_TRACE_BUFFER)
    {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
    RtlZeroMemory( pUserTraceBuffer, (UINT)UserTraceBufferSize );
    ALLOCATE_SPIN_LOCK( &TraceLock );
    pTraceBufferBase = pTraceBufferHead = (PLLC_TRACE_HEADER)pUserTraceBuffer;
    pTraceBufferHead->Event = LLC_TRACE_END_OF_DATA;
    pTraceBufferTop = 
        &pTraceBufferBase[ UserTraceBufferSize / sizeof(LLC_TRACE_HEADER) ];
    TraceFlags = UserTraceFlags;
    TraceEnabled = TRUE;
    return STATUS_SUCCESS;
}


VOID
LlcTraceClose(
    VOID
    )
{
    if (TraceEnabled)
    {
        TraceEnabled = FALSE;
        DEALLOCATE_SPIN_LOCK( &TraceLock );
    }
}

VOID
LlcTraceWrite( 
    IN UINT Event, 
    IN UCHAR AdapterNumber,
    IN UINT DataBufferSize,
    IN PVOID pDataBuffer
    )
{

//if ((AdapterNumber & 0x7f) != 0)
//    return;

    if (TraceEnabled)
    {
        ACQUIRE_SPIN_LOCK( &TraceLock );
        if ((ULONG)(&pTraceBufferHead[1]) >= (ULONG)pTraceBufferTop)
        {
            pTraceBufferHead = (PLLC_TRACE_HEADER)pTraceBufferBase;
        }
        pTraceBufferHead->Event = (USHORT)Event;
        pTraceBufferHead->AdapterNumber = AdapterNumber;
        pTraceBufferHead->TimerTick = AbsoluteTime;
        pTraceBufferHead->DataLength = (UCHAR)
#ifdef min 
            min( TRACE_DATA_LENGTH, DataBufferSize );
#else
            __min( TRACE_DATA_LENGTH, DataBufferSize );
#endif
        memcpy( 
            pTraceBufferHead->Buffer,
            pDataBuffer,
            pTraceBufferHead->DataLength
            );
        pTraceBufferHead++;
        pTraceBufferHead->Event = LLC_TRACE_END_OF_DATA;
        RELEASE_SPIN_LOCK( &TraceLock );
    }
}

#ifdef  OS2_EMU_DLC
//
//  Procedure makes the post mortem dump of the given number of last frames.
//  The output should look very much like in Sniffer.
//  This routine doesn't supprot source routing info, but its implementatin
//  should not be a very big thing.
//
VOID
LlcTraceDump( 
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    )
{
    PUCHAR      pDest, pSrc, pCommand, pDlcHeader, pDirection, pTmp;
    UINT        i;
    UCHAR       Buffer1[13], Buffer2[13];
    UCHAR       CmdResp, PollFinal;
    LLC_HEADER  LlcHeader;
    BOOLEAN     IsEthernet;
    PLLC_TRACE_HEADER pTrace;
    UCHAR       DataBuffer[18];
    USHORT      EthernetType;

RtlZeroMemory( DataBuffer, sizeof( DataBuffer ));
LlcTraceWrite( 
    LLC_TRACE_RECEIVE_FRAME, AdapterNumber, sizeof(DataBuffer), DataBuffer );
 
    if (!TraceEnabled)
        return;
    ACQUIRE_SPIN_LOCK( &TraceLock );
    
    printf( 
 "#    Time      Adpt Local Node      Remote Node  Dsp Ssp   Cmd    Nr  Ns\n");
//0---------1---------2---------3---------4---------5---------6---------7-----
//5    10        5    13              13           4   4   9        4   4
    for (
        pTrace = pTraceBufferHead, i = 0;
        i < LastEvents;
        i++)
    {
        EthernetType = 0;
        if (pTrace != pTraceBufferBase)
        {
            pTrace--;
        }
        else
        {
	    pTrace = pTraceBufferTop - 2;
        }

        if (pTrace->Event == LLC_TRACE_END_OF_DATA)
        {
            break;
        }
        //
        //  The highest bit is set in the adapter number, if
        //  it's a token-ring adapter.
        //
        if (pTrace->AdapterNumber & 0x80)
        {
            IsEthernet = FALSE;
        }
        else
            IsEthernet = TRUE;
    
        pDlcHeader = &pTrace->Buffer[14];
        if (IsEthernet)
        {
            pSrc = &pTrace->Buffer[6];
            pDest = pTrace->Buffer;

            //
            //  Discard all non ieee 802.2 frames, but support
            //  the SNA dix headers.
            //
            if (pTrace->Buffer[12] == 0x80 &&
                pTrace->Buffer[13] == 0xd5)
            {
                pDlcHeader = &pTrace->Buffer[17];
            }
            else if (pTrace->Buffer[12] >= 64)
            {
                EthernetType = (USHORT)
                    (((USHORT)pTrace->Buffer[12] << 8) + 
                     pTrace->Buffer[13]
                     );
            }
        }
        else
        {
            pSrc = &pTrace->Buffer[8];
            pDest = &pTrace->Buffer[2];

            //
            //  Skip the source souting info
            //
            if (pTrace->Buffer[8] & 0x80)
                pDlcHeader += pTrace->Buffer[14] & 0x1f;

                //
                //  Discard all non ieee 802.2 frames
                //
            if (pTrace->Buffer[1] != 0x40)
                continue;
        }
        memcpy( (PUCHAR)&LlcHeader, pDlcHeader, 4 );
    
        if (AdapterNumber != -1 && 
            AdapterNumber != ((UINT)pTrace->AdapterNumber & 0x7f))
            continue;

        if (pTrace->Event == LLC_TRACE_SEND_FRAME)
        {
            if (pRemoteNode != NULL && memcmp( pDest, pRemoteNode, 6))
                continue;
            pTmp = pDest;
            pDest = pSrc;
            pSrc = pTmp;
            pDirection = "->";
        }
        else if (pTrace->Event == LLC_TRACE_RECEIVE_FRAME)
        {
            if (pRemoteNode != NULL && memcmp( pSrc, pRemoteNode, 6))
                continue;
            pDirection = "<-";
        }
        else
        {
            continue;
        }
        if (EthernetType != 0)
        {
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  DIX type %x\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                EthernetType
                );

        }
        //
        //  Handle first I frames, they are the most common!
        //
        else if (!(LlcHeader.U.Command & LLC_NOT_I_FRAME))
        {
            PollFinal = ' ';
            if (LlcHeader.I.Ssap & LLC_SSAP_RESPONSE)
            {
                CmdResp = 'r';
                if (LlcHeader.I.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'f';
                }
            }
            else
            {
                CmdResp = 'c';
                if (LlcHeader.I.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'p';
                }
            }
            pCommand =  "I";
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  %-2x  %-2x %5s-%c%c %-3u %-3u\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                LlcHeader.U.Dsap,
                LlcHeader.U.Ssap & 0xfe,
                pCommand,
                CmdResp,
                PollFinal,
                LlcHeader.I.Nr >> 1,
                LlcHeader.I.Ns >> 1
                ); 
        }
        else if (!(LlcHeader.S.Command & LLC_U_TYPE_BIT))
        {
            //
            // Handle S (Supervisory) commands (RR, REJ, RNR)
            //
            switch (LlcHeader.S.Command)
            {
            case LLC_RR:
                pCommand = "RR";
                break;
            case LLC_RNR:
                pCommand = "RNR";
                break;
            case LLC_REJ:
                pCommand = "REJ";
                break;
            default:
                pCommand = "INV";
                break;
            };
            //
            //  The valid frames has modulo: Va <= Nr <= Vs,
            //  Ie. the Receive sequence number should belong to
            //  a frame that has been sent but not acknowledged.
            //  The extra check in the beginning makes the most common
            //  code path faster: usually the other is waiting the next frame.
            //  (keep the rest code the same as in I path, even a very
            //  primitive optimizer will puts these code paths together)
            //
            PollFinal = ' ';
            if (LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)
            {
                CmdResp = 'r';
                if (LlcHeader.S.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'f';
                }
            }
            else
            {
                CmdResp = 'c';
                if (LlcHeader.S.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'p';
                }
            }
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  %-2x  %-2x %5s-%c%c %-3u\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                LlcHeader.U.Dsap,
                LlcHeader.U.Ssap & 0xfe,
                pCommand,
                CmdResp,
                PollFinal,
                LlcHeader.I.Nr >> 1
                ); 
        }
        else
        {
            //
            // Handle U (Unnumbered) command frames
            // (FRMR, DM, UA, DISC, SABME, XID, TEST)
            switch (LlcHeader.U.Command & ~LLC_U_POLL_FINAL)
            {
            case LLC_UI:
                pCommand = "UI";
                break;
            case LLC_DISC:
                pCommand = "DISC";
                break;
            case LLC_SABME:
                pCommand = "SABME";
                break;
            case LLC_DM:
                pCommand = "DM";
                break;
            case LLC_UA:
                pCommand = "UA";
                break;
            case LLC_FRMR:
                 pCommand =  "FRMR";
                break;
            case LLC_TEST:
                pCommand =  "TEST";
                break;
            case LLC_XID:
                pCommand =  "XID";
                break;
            default:
                pCommand =  "INV";
                break;
            };
            //
            //  We set an uniform poll/final bit for procedure call
            //
            PollFinal = ' ';
            if (LlcHeader.U.Command & LLC_U_POLL_FINAL)
            {
                if (LlcHeader.U.Ssap & 1)
                {
                    PollFinal = 'f';
                }
                else
                {
                    PollFinal = 'p';
                }
            }
            if (LlcHeader.U.Ssap & 1)
            {
                CmdResp = 'r';
            }
            else
            {
                CmdResp = 'c';
            }
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  %-2x  %-2x %5s-%c%c\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                LlcHeader.U.Dsap,
                LlcHeader.U.Ssap & 0xfe,
                pCommand,
                CmdResp,
                PollFinal
                ); 
        } 
    }
    RELEASE_SPIN_LOCK( &TraceLock );
}


UCHAR GetHexDigit( 
    UINT   Ch
    )
{
    if (Ch <= 9)
        return (UCHAR)('0' + (UCHAR)Ch);
    else
        return (UCHAR)('A' + (UCHAR)Ch - 10);
}

PUCHAR
GetHexString( 
    PUCHAR pDest, 
    UINT Length,
    PUCHAR Buffer 
    )
{
    UINT i;
    
    for (i = 0; i < (Length * 2); i += 2)
    {
        Buffer[i] = GetHexDigit( *pDest >> 4 );
        Buffer[i+1] = GetHexDigit( *pDest & 0x0f );
        pDest++;
    }
    Buffer[i] = 0;
    return Buffer;
}


VOID
LlcTraceDumpAndReset( 
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    )
{
    LlcTraceDump( LastEvents, AdapterNumber, pRemoteNode );
    ACQUIRE_SPIN_LOCK( &TraceLock );
    if ((ULONG)(&pTraceBufferHead[1]) >= (ULONG)pTraceBufferTop)
    {
        pTraceBufferHead = (PLLC_TRACE_HEADER)pTraceBufferBase;
    }
    else
        pTraceBufferHead++;
    RELEASE_SPIN_LOCK( &TraceLock );
}
#endif
#endif  // TRACE_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\refcnt.h ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
       refcnt.h

 Abstract:       
       
       Reference counting for an object.
       
 Author:
 
       Scott Holden (sholden)  12/29/1998 Borrowed from IrDA.
       
 Revision History:

--*/

#ifndef _REFCNT_H_
#define _REFCNT_H_

#ifdef NDIS40 // Only used for NDIS40 code now.

#define TAG_CNT 8
#define REF_SIG 0x7841eeee

#if DBG
typedef struct _REF_TAG
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    
#endif 

typedef struct _REF_CNT
{
    LONG       	Count;
    PVOID       Instance;
    VOID        (*DeleteHandler)(PVOID pvContext);
#if DBG    
    int         Sig;
    REF_TAG     Tags[TAG_CNT];
    KSPIN_LOCK  Lock;
    ULONG       TypeTag;
#endif // DBG    
}
REF_CNT, *PREF_CNT;

//
// ReferenceInit - Initialize the reference control block.
//

_inline VOID    
ReferenceInit( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)(PVOID pvContext)
    )
{
    pRefCnt->Count          = 0;
    pRefCnt->Instance       = InstanceHandle;
    pRefCnt->DeleteHandler  = DeleteHandler;
}

//
// ReferenceAdd - Add a reference.
//

_inline VOID
ReferenceAdd(
    IN 	PREF_CNT  pRefCnt
    )
{
    InterlockedIncrement(&pRefCnt->Count);
}

//
// ReferenceRemove - Del a reference. If the reference is zero, and a 
//                   delete handler has been specified, then call the
//                   handler.
//

_inline VOID
ReferenceRemove(
    IN PREF_CNT  pRefCnt
    )
{
    if (InterlockedDecrement(&pRefCnt->Count) <= 0 &&
        pRefCnt->DeleteHandler)
    {
        (pRefCnt->DeleteHandler)(pRefCnt->Instance);
    }
}

#if DBG

//
// For checked builds, we will do some verification with tags, etc to ensure
// that the ref counting is done correctly.
//

VOID    
ReferenceInitDbg( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)(PVOID pvContext),
    ULONG       TypeTag
    );

VOID 
ReferenceAddDbg(
    PREF_CNT pRefCnt, 
    ULONG Tag, 
    int cLine
    );

VOID 
ReferenceRemoveDbg(
    PREF_CNT pRefCnt, 
    ULONG Tag, 
    int cLine
    );

#define REFINIT(Rc, Inst, DelHandler, Tag) ReferenceInitDbg(Rc, Inst, DelHandler, Tag)
#define REFADD(Rc, Tag)                    ReferenceAddDbg(Rc, Tag, __LINE__)
#define REFDEL(Rc, Tag)                    ReferenceRemoveDbg(Rc, Tag, __LINE__)

#else // DBG

#define REFINIT(Rc, Inst, DelHandler, Tag) ReferenceInit(Rc, Inst, DelHandler)
#define REFADD(Rc, Tag)                    ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)                    ReferenceRemove(Rc);

#endif // !DBG

#endif // NDIS40
#endif // _REFCNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\alg_ftp.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// ALG_FTP.cpp : Implementation of DLL Exports.
//
// JPDup
// Sanjiv
//


#include "PreComp.h"

#include <initguid.h>
#include "MyALG.h"
//#include "MyAdapterNotify.h"



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_AlgFTP,                       CAlgFTP)
//    OBJECT_ENTRY(CLSID_MyAdapterNotificationSink,   CMyAdapterNotify)
END_OBJECT_MAP()






MYTRACE_ENABLE;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MYTRACE_START(L"ALG_FTP");
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MYTRACE_STOP;
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object from the Object Map
    return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\refcnt.c ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
    refcnt.c

 Abstract:       
    
    This module contains checked reference counting support functions.
    The free versions are inline.   
       
 Author:
 
       Scott Holden (sholden)  12/29/1998 Borrowed from IrDA.
       
 Revision History:

--*/

#ifdef NDIS40 // Only used for NDIS40 code now.
#if DBG

//
// Include Files
//

#include "dlc.h"
#include "llc.h"
#include "dbgmsg.h"


#define EXPAND_TAG(_Tag) ((CHAR *)(&_Tag))[0], \
                         ((CHAR *)(&_Tag))[1], \
                         ((CHAR *)(&_Tag))[2], \
                         ((CHAR *)(&_Tag))[3]

VOID
ReferenceInitDbg(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)(PVOID pvContext),
    ULONG       TypeTag
    )

/*++

Routine Description:

    Initializes the reference control block. Reference count is initialized
    to zero.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    
    InstanceHandle - handle to the managed instance.
    
    DeleteHandler - pointer to delete function, NULL is OK.
    
    TypeTag - Identifies initialization.

Return Value:

    The function's value is VOID.

--*/

{
    DEBUGMSG(DBG_REF, (TEXT("ReferenceInit(%#x, %#x, %#x, %c%c%c%c)\n"), 
        pRefCnt, InstanceHandle, DeleteHandler, EXPAND_TAG(TypeTag)));

    ASSERT(pRefCnt);

    //
    // Set the reference to 0 and save the instance 
    // handle and the delete handler.
    //

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;

    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);

    pRefCnt->Tags[0].Tag = 'LTOT';

    KeInitializeSpinLock(&pRefCnt->Lock);

    pRefCnt->TypeTag = TypeTag;

    return;
}

VOID
ReferenceAddDbg(
    PREF_CNT    pRefCnt, 
    ULONG       Tag,
    int         cLine
    )
{
    int             i;
    int             TotalPerArray = 0;
    KIRQL           OldIrql;

    ASSERT(pRefCnt->Sig == REF_SIG);

    DEBUGMSG(DBG_REF && DBG_VERBOSE, (TEXT("REFADD %#x [%c%c%c%c:%c%c%c%c] %d [l:%d]\n"),
        pRefCnt, EXPAND_TAG(pRefCnt->TypeTag), EXPAND_TAG(Tag), 
        pRefCnt->Count, cLine));    

    KeAcquireSpinLock(&pRefCnt->Lock, &OldIrql);

    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }

    ASSERT(i < TAG_CNT);

    InterlockedIncrement(&pRefCnt->Tags[0].Count);

    InterlockedIncrement(&pRefCnt->Count);

    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);    

#ifdef REFCNT_SANITY_CHECK    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
#endif // REFCNT_SANITY_CHECK

    KeReleaseSpinLock(&pRefCnt->Lock, OldIrql);
}

VOID
ReferenceRemoveDbg(
    PREF_CNT pRefCnt, 
    ULONG    Tag,
    int      cLine)
{
    int             i;
    KIRQL           OldIrql;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;

    ASSERT(pRefCnt->Sig == REF_SIG);

    KeAcquireSpinLock(&pRefCnt->Lock, &OldIrql);

    DEBUGMSG(DBG_REF && DBG_VERBOSE, (TEXT("REFDEL %#x [%c%c%c%c:%c%c%c%c] %d [l:%d]\n"),
        pRefCnt, EXPAND_TAG(pRefCnt->TypeTag), EXPAND_TAG(Tag), 
        pRefCnt->Count, cLine));

    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;

            ASSERT(pRefCnt->Tags[i].Count > 0);

            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
            {
                pRefCnt->Tags[i].Tag = Tag;
            }
            break;
        }
    }

    ASSERT(FoundIt);
    ASSERT(pRefCnt->Tags[0].Count > 0);
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    InterlockedDecrement(&pRefCnt->Tags[0].Count);

    //
    // If the decremented count is non zero return the instance handle.
    //

    //
    // If reference is zero and delete handler is available, then call
    // handler.
    //

    if (InterlockedDecrement(&pRefCnt->Count) <= 0 &&
        pRefCnt->DeleteHandler)
    {
        DEBUGMSG(DBG_REF,(TEXT("REFDEL %#x [%c%c%c%c:%c%c%c%c] calling delete handler [l:%d].\n"),
            pRefCnt, EXPAND_TAG(pRefCnt->TypeTag), EXPAND_TAG(Tag), cLine));
        KeReleaseSpinLock(&pRefCnt->Lock, OldIrql);


        (pRefCnt->DeleteHandler)(pRefCnt->Instance);
    }
    else
    {
        KeReleaseSpinLock(&pRefCnt->Lock, OldIrql);
    }

#ifdef REFCNT_SANITY_CHECK    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint(TEXT("Tag %X, RefCnt %X, perArray %d, total %d\n"), Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
#endif // REFCNT_SANITY_CHECK
}
#endif // DBG
#endif // NDIS40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\buffer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains code for buffer-management.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "precomp.h"
#include "list.h"

#pragma hdrstop

#define NH_ALLOCATE(s)          HeapAlloc(GetProcessHeap(), 0, (s))
#define NH_FREE(p)              HeapFree(GetProcessHeap(), 0, (p))



LIST_ENTRY          MyHelperpBufferQueue;
LONG                MyHelperpBufferQueueLength;
CRITICAL_SECTION    MyHelperpBufferQueueLock;

PNH_BUFFER
MyHelperAcquireFixedLengthBuffer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer.
    If no buffer is available on the buffer queue, a new one is obtained.

Arguments:

    none.

Return Value:

    PNH_BUFFER - the buffer allocated

--*/

{
    MYTRACE_ENTER_NOSHOWEXIT("MyHelperAcquireFixedLengthBuffer");
    PNH_BUFFER Buffer;
    PLIST_ENTRY Link;
    EnterCriticalSection(&MyHelperpBufferQueueLock);
    if ( !IsListEmpty(&MyHelperpBufferQueue) ) 
    {
        Link = RemoveHeadList(&MyHelperpBufferQueue);
        LeaveCriticalSection(&MyHelperpBufferQueueLock);
        InterlockedDecrement(&MyHelperpBufferQueueLength);
        Buffer = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        Buffer->Type = MyHelperFixedLengthBufferType;
        return Buffer;
    }
    LeaveCriticalSection(&MyHelperpBufferQueueLock);
    
    Buffer = NH_ALLOCATE_BUFFER();
    if (Buffer) {
        Buffer->Type = MyHelperFixedLengthBufferType;
    }
    return Buffer;
} // MyHelperAcquireFixedLengthBuffer


PNH_BUFFER
MyHelperAcquireVariableLengthBuffer(
    ULONG Length
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer of non-standard size.
    If the length requested is less than or equal to 'NH_BUFFER_SIZE',
    a buffer from the shared buffer-queue is returned.
    Otherwise, a buffer is especially allocated for the caller.

Arguments:

    Length - the length of the buffer required.

Return Value:

    PNH_BUFFER - the buffer allocated.

--*/

{
    MYTRACE_ENTER_NOSHOWEXIT(">>>MyHelperAcquireVariableLengthBuffer");

    PNH_BUFFER Buffer;
    if (Length <= NH_BUFFER_SIZE) {
        return MyHelperAcquireFixedLengthBuffer();
    }

    Buffer = reinterpret_cast<PNH_BUFFER>(
                NH_ALLOCATE(FIELD_OFFSET(NH_BUFFER, Buffer[Length]))
                );
                
    if (Buffer) { Buffer->Type = MyHelperVariableLengthBufferType; }
    return Buffer;
} // MyHelperAcquireVariableLengthBuffer


PNH_BUFFER
MyHelperDuplicateBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine creates a duplicate of the given buffer,
    including both its data and its control information.

    N.B. Variable-length buffers cannot be duplicated by this routine.

Arguments:

    Bufferp - the buffer to be duplicated

Return Value:

    PNH_BUFFER - a pointer to the duplicate

--*/

{
    PNH_BUFFER Duplicatep;
    _ASSERT(Bufferp->Type == MyHelperFixedLengthBufferType);
    if (!(Duplicatep = MyHelperAcquireBuffer())) 
    { 
        return NULL; 
    }

    *Duplicatep = *Bufferp;
    return Duplicatep;
} // MyHelperDuplicateBuffer



ULONG
MyHelperInitializeBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine readies the buffer-management for operation.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    InitializeListHead(&MyHelperpBufferQueue);
    MyHelperpBufferQueueLength = 0;
    __try 
    {
        InitializeCriticalSection(&MyHelperpBufferQueueLock);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        //MyHelperTrace(
        //TRACE_FLAG_BUFFER,
        //"MyHelperInitializeBufferManagement: exception %d creating lock",
        //Error = GetExceptionCode()
        //);
    }

    return Error;

} // MyHelperInitializeBufferManagement


VOID
MyHelperReleaseBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to release a buffer to the buffer queue.
    It attempts to place the buffer on the queue for re-use, unless
    the queue is full in which case the buffer is immediately freed.

Arguments:

    Bufferp - the buffer to be released

Return Value:

    none.

--*/

{
    MYTRACE_ENTER_NOSHOWEXIT("<<<MyHelperReleaseBuffer");

    if (MyHelperpBufferQueueLength > NH_MAX_BUFFER_QUEUE_LENGTH || Bufferp->Type != MyHelperFixedLengthBufferType) 
    {
        NH_FREE_BUFFER(Bufferp);
    } 
    else 
    {
        EnterCriticalSection(&MyHelperpBufferQueueLock);
        InsertHeadList(&MyHelperpBufferQueue, &Bufferp->Link);
        LeaveCriticalSection(&MyHelperpBufferQueueLock);
        InterlockedIncrement(&MyHelperpBufferQueueLength);
    }
} // MyHelperReleaseBuffer



VOID
MyHelperShutdownBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine cleans up resources used by the buffer-management module.
    It assumes the list will not be accessed while the clean up is in progress.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNH_BUFFER Bufferp;

    while (!IsListEmpty(&MyHelperpBufferQueue)) 
    {
        Link = RemoveHeadList(&MyHelperpBufferQueue);
        Bufferp = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        NH_FREE_BUFFER(Bufferp);
    }

    DeleteCriticalSection(&MyHelperpBufferQueueLock);
    MyHelperpBufferQueueLength = 0;

} // MyHelperShutdownBufferManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\buffer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    This module contains declarations for buffer-management.

    All network I/O in this component occurs via completion packets.
    The buffer routines below are used to acquire and release the buffers
    used for sending and receiving data.

    In addition to holding the data transferred, the buffers contain fields
    to facilitate their use with completion ports. See below for details
    on the use of the fields.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_BUFFER_H_
#define _NATHLP_BUFFER_H_

#define NH_BUFFER_SIZE              576
#define NH_MAX_BUFFER_QUEUE_LENGTH  32

struct _NH_BUFFER;

//
// Typedef:     PNH_COMPLETION_ROUTINE
//

typedef
VOID
(*PNH_COMPLETION_ROUTINE)(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    struct _NH_BUFFER* Bufferp
    );


//
// Structure:   NH_BUFFER
//
// This structure holds a buffer used for network I/O on a socket.
//

typedef enum _NH_BUFFER_TYPE {
    MyHelperFixedLengthBufferType,
    MyHelperVariableLengthBufferType
} NH_BUFFER_TYPE;

typedef struct _NH_BUFFER {
    union {
        LIST_ENTRY Link;
        NH_BUFFER_TYPE Type;
    };
    //
    // The socket associated with the buffer's most recent I/O request
    //
    SOCKET Socket;
    //
    // Completion routine and contexts for the buffer's most recent I/O request
    //
    PNH_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Context2;
    //
    // Passed as the system context area for any I/O using the buffer
    //
    OVERLAPPED Overlapped;
    //
    // Upon completion of a receive, the receive-flags and source-address
    // length for the message read
    //
    ULONG ReceiveFlags;
    ULONG AddressLength;
    union {
        //
        // Holds the source address when a datagram-read completes
        //
        SOCKADDR_IN ReadAddress;
        //
        // Holds the destination address while a datagram-send is in progress
        //
        SOCKADDR_IN WriteAddress;
        //
        // Holds the remote address while a connect is in progress
        //
        SOCKADDR_IN ConnectAddress;
        //
        // Holds the state of a multi-request read or write
        //
        struct {
            ULONG UserFlags;
            ULONG BytesToTransfer;
            ULONG TransferOffset;
        };
    };
    //
    // Upon completion of an I/O request, the error-code, byte-count,
    // and data-bytes for the request
    //
    ULONG ErrorCode;
    ULONG BytesTransferred;
    UCHAR Buffer[NH_BUFFER_SIZE];
} NH_BUFFER, *PNH_BUFFER;

#define NH_ALLOCATE_BUFFER() \
    reinterpret_cast<PNH_BUFFER>(NH_ALLOCATE(sizeof(NH_BUFFER)))
    
#define NH_FREE_BUFFER(b)       NH_FREE(b)


//
// BUFFER-MANAGEMENT ROUTINES (alphabetically)
//

#define MyHelperAcquireBuffer() MyHelperAcquireFixedLengthBuffer()
PNH_BUFFER
MyHelperAcquireFixedLengthBuffer(
    VOID
    );

PNH_BUFFER
MyHelperAcquireVariableLengthBuffer(
    ULONG Length
    );

PNH_BUFFER
MyHelperDuplicateBuffer(
    PNH_BUFFER Bufferp
    );

ULONG
MyHelperInitializeBufferManagement(
    VOID
    );

VOID
MyHelperReleaseBuffer(
    PNH_BUFFER Bufferp
    );

VOID
MyHelperShutdownBufferManagement(
    VOID
    );

#endif // _NATHLP_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\ftpcontrol.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// FtpControl.cpp : Implementation
//
// JPDup
// Sanjiv
//
#include "precomp.h"

#include "MyAlg.h"


//
// Default constructor
//
CFtpControlConnection::CFtpControlConnection()
{
    MYTRACE_ENTER_NOSHOWEXIT("CFtpControlConnection::CFtpControlConnection()");
    m_ClientConnectedSocket = INVALID_SOCKET;
    m_AlgConnectedSocket = INVALID_SOCKET;
    m_ControlState.m_nAddressNew = 0;
    m_ControlState.m_nPortNew = 0;
    m_nSourcePortReplacement = 0;
    m_RefCount = 0;
    m_pPendingProxy = NULL;
}




//
// Destructor
//
CFtpControlConnection::~CFtpControlConnection()
{
    MYTRACE_ENTER_NOSHOWEXIT("CFtpControlConnection::~CFtpControlConnection()");
}



//
// Find a unique source port for the public client address given
// 
USHORT
PickNewSourcePort(
    ULONG  nPublicSourceAddress,
    USHORT nPublicSourcePort
    )
{
    MYTRACE_ENTER("CFtpControlConnection::PickNewSourcePort()");

    USHORT nNewSourcePort = 45000-nPublicSourcePort; // example 45000 - 3000

    bool    bPortAvailable;

    do
    {
        nNewSourcePort--;
        bPortAvailable = g_ControlObjectList.IsSourcePortAvailable(nPublicSourceAddress, nNewSourcePort);
        MYTRACE("Port %d is %s", nNewSourcePort, bPortAvailable ? "Available" : "Inuse" );

    } while ( (false == bPortAvailable) && (nNewSourcePort > 6001) );

    return nNewSourcePort;
}


//
// Initialize
//
HRESULT
CFtpControlConnection::Init(
    SOCKET                          AcceptedSocket,
    ULONG                           nToAddr,
    USHORT                          nToPort,
    CONNECTION_TYPE                 ConnType
    )
{
    MYTRACE_ENTER("CFtpControlConnection::Init");


    //
    // Figure what address to use
    //
    ULONG BestAddress;

    HRESULT hr = g_pIAlgServicesAlgFTP->GetBestSourceAddressForDestinationAddress(
        nToAddr,
        TRUE,
        &BestAddress
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Could not get best source address", hr);
        return hr;
    }


    ULONG Err = 0;

    m_ClientConnectedSocket = AcceptedSocket;
    m_ConnectionType = ConnType;

    IncReference();

    m_AlgConnectedSocket = INVALID_SOCKET;




    Err = MyHelperCreateStreamSocket(BestAddress,0,&m_AlgConnectedSocket);


    if ( Err == 0 )
    {
        if ( m_ConnectionType == OUTGOING )
        {
            MYTRACE("OUTGOING FTP");

            ULONG   icsAddr;
            USHORT  icsPort;

            Err = MyHelperQueryLocalEndpointSocket(m_AlgConnectedSocket,&icsAddr,&icsPort);
            MYTRACE("AlgConnectedSocket Local %s:%d",MYTRACE_IP(icsAddr), ntohs(icsPort) );

            if ( Err == 0 )
            {
                hr = g_pIAlgServicesAlgFTP->PrepareProxyConnection(
                    eALG_TCP,
                    icsAddr,
                    icsPort,
                    nToAddr,
                    nToPort,
                    FALSE,
                    &m_pPendingProxy
                    );
            }
        }
        else if (m_ConnectionType == INCOMING)
        {
            MYTRACE("INCOMING FTP");

            ULONG   icsAddr,pubAddr;
            USHORT  icsPort,pubPort;

            Err = MyHelperQueryLocalEndpointSocket(m_AlgConnectedSocket,&icsAddr,&icsPort);
            MYTRACE("AlgConnectedSocket Local %s:%d",MYTRACE_IP(icsAddr), ntohs(icsPort) );

            if (Err == 0)
            {
                Err = MyHelperQueryRemoteEndpointSocket(m_ClientConnectedSocket,&pubAddr,&pubPort);

                if ( Err == 0 )
                {
                    if ( icsAddr == nToAddr )
                    {
                        //
                        // Special case it the FTP server is hosted on the EDGE box
                        // we would create a loop the incoming public client address/port
                        // this new modified connection would look exacly like 
                        // the original one example:
                        //
                        // 1.1.1.2:3000 connects to 1.1.1.1:21
                        // we accept this connection
                        // and in return we connect to the FTP server destination 1.1.1.1:21
                        // asking the NAT to source mofify and replace the source with 1.1.1.2:3000
                        // that does not work
                        // in order to go arround this we pick another source port example 45000
                        //

                        // Cache this info in order to pick a unique one next time
                        m_nSourcePortReplacement = PickNewSourcePort(pubAddr, pubPort);

                        pubPort = m_nSourcePortReplacement;   // This is the new bogus port to use now
                    }

                    hr = g_pIAlgServicesAlgFTP->PrepareSourceModifiedProxyConnection(
                        eALG_TCP,
                        icsAddr,
                        icsPort,
                        nToAddr,
                        nToPort,
                        pubAddr,
                        pubPort,
                        &m_pPendingProxy
                        );
                    if ( FAILED(hr) )
                    {
                        MYTRACE_ERROR("PrepareSourceModifiedProxyConnection",hr);
                    }
                }
                else
                {
                    MYTRACE_ERROR("MyHelperQueryRemoteEndpointSocket",Err);
                }

            }
            else
            {
                MYTRACE_ERROR("LocalEndpointSocket", Err);
            }

        }
    }
    else
    {
        MYTRACE_ERROR("MyHelperCreateStreamSocket",Err);
    }

    if ( SUCCEEDED(hr) && Err == 0 )
    {

        Err = MyHelperConnectStreamSocket(
            NULL,
            m_AlgConnectedSocket,
            nToAddr,
            nToPort,
            NULL,
            MyConnectCompletion,
            (void *)this,
            NULL
            );

        if ( Err != 0 )
        {
            MYTRACE_ERROR("From MyHelperConnectStreamSocket", Err);

            m_pPendingProxy->Cancel();
        }
    }

    if ( FAILED(hr) || Err )
    {
        MYTRACE_ERROR("We can't init this Connection", hr);

        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 0);

        if ( SUCCEEDED(hr) )
            hr = HRESULT_FROM_WIN32(Err);
    }

    return hr;
}


#define MAKE_ADDRESS(a,b,c,d)       ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))
#define MAKE_PORT(a,b)              ((a) | ((b) << 8))



//
//
//
ULONG
GetNumFromString(UCHAR *String,ULONG *pNum)
{
    ULONG retval = 0;
    int i = 0;
    while (String[i] != ',')
    {
        retval = retval*10 + (String[i]-'0');
        i++;
    }
    *pNum = i;
    return retval;
}


//
// Needs to return in Network address order
//
USHORT
GetUSHORTFromString(UCHAR *String,ULONG *pNum)
{
    MYTRACE_ENTER("GetUSHORTFromString");



    ULONG Num;
    UCHAR Numbers[2];
    *pNum = 0;

    Numbers[0] = (UCHAR)GetNumFromString(String,&Num);
    *pNum += Num+1;


    Numbers[1] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num;


    USHORT retval = (USHORT)MAKE_PORT((USHORT)Numbers[0], (USHORT)Numbers[1]);

    return retval;
}

//
// return the String IP Address as 192,168,0,0, in a ULONG in HOST format
//
ULONG
GetULONGFromString(
    UCHAR*  String,
    ULONG*  pNum
    )
{
    UCHAR Numbers[4];

    ULONG retval = 0;
    ULONG Num;

    *pNum = 0;
    Numbers[0] = (UCHAR)GetNumFromString(String,&Num);
    *pNum += Num+1;

    Numbers[1] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num+1;

    Numbers[2] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num+1;

    Numbers[3] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num;

    retval = MAKE_ADDRESS(Numbers[0], Numbers[1], Numbers[2], Numbers[3]);

    return retval;
}





//
//
//
void
CFtpControlConnection::ConnectCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred
    )
{
    MYTRACE_ENTER("CFtpControlConnection::ConnectCompletionRoutine");

    

    ULONG Err;


    if ( ErrCode )
    {
        MYTRACE_ERROR("ConnectCompletionRoutine", ErrCode);

        if ( m_pPendingProxy )
        {
            MYTRACE("PendingProxy still active CANCEL");
            m_pPendingProxy->Cancel();
        }

        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 0);

        return;
    }

    Err = MyHelperReadStreamSocket(
        NULL,
        m_ClientConnectedSocket,
        NULL,
        FTP_MAX_MSG_SIZE,
        0,
        MyReadCompletion,
        (void *)this,
        (void *)CLIENT_READ
        );


    if ( Err )
    {
        MYTRACE_ERROR("From MyHelperReadStreamSocket CLIENT_READ",Err);
        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 0);

        return;
    }

    IncReference();
    Err = MyHelperReadStreamSocket(
        NULL,
        m_AlgConnectedSocket,
        NULL,
        FTP_MAX_MSG_SIZE,0,
        MyReadCompletion,
        (void *)this,
        (void *)SERVER_READ
        );

    if ( Err )
    {
        MYTRACE("MyHelperReadStreamSocket SERVER_READ",Err);
        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 1);

        if (ref)
            Shutdown();

        return;
    }
    
    return;
}




//
//
//
ULONG
CFtpControlConnection::IncReference(void)
{
    MYTRACE_ENTER("CFtpControlConnection::IncReference()");
    ULONG nRef = InterlockedIncrement((LPLONG)&m_RefCount);

    MYTRACE("REFCOUNT for 0x%X is now %d", this, nRef);
    return nRef;
}



//
//
//
ULONG
CFtpControlConnection::DecReference(void)
{
    MYTRACE_ENTER("CFtpControlConnection::DecReference()");
    
    ULONG tmp = InterlockedDecrement((LPLONG)&m_RefCount);
    MYTRACE("REFCOUNT for 0x%X is now %d", this, tmp);

    if ( tmp > 0 )
        return tmp;

    MYTRACE("HIT ZERO refcount cleanup the CFtpControlConnection");


    if ( m_AlgConnectedSocket == INVALID_SOCKET )
    {
        MYTRACE("SOCKET SERVER ALREADY CLOSED!");
    }
    else
    {
        MYTRACE("CLOSING SOCKET ALGCONNECTED!");
        shutdown(m_AlgConnectedSocket, SD_BOTH);
        closesocket(m_AlgConnectedSocket);
        m_AlgConnectedSocket = INVALID_SOCKET;
    }

    if ( m_ClientConnectedSocket == INVALID_SOCKET )
    {
        MYTRACE("SOCKET CLIENT ALREADY CLOSED!");
    }
    else
    {
        MYTRACE("CLOSING SOCKET CLIENT CONNECTED!");
        shutdown(m_ClientConnectedSocket, SD_BOTH);
        closesocket(m_ClientConnectedSocket);
        m_ClientConnectedSocket = INVALID_SOCKET;
    }

    if ( m_pPendingProxy )
    {
//
// At this point NAT already cancel this redirect, so no need to call cancel
//        m_pPendingProxy->Cancel(); 
// this was causing a ERROR on a multi-client scenario
//
        m_pPendingProxy->Release();
        m_pPendingProxy = NULL;
    }

    if ( m_ControlState.m_nPortNew )
    {
        MYTRACE("ReleaseReservedPort-A %d", ntohs(m_ControlState.m_nPortNew));
        g_pIAlgServicesAlgFTP->ReleaseReservedPort(m_ControlState.m_nPortNew,1);
        m_ControlState.m_nPortNew = 0;
    }


    //
    // CleanUp the collection of DataChannel
    //
    IDataChannel*   pData;
    USHORT          Port;
    HANDLE          CreationHandle,DeletionHandle;

    MYTRACE("Empty CDataChannelList");

    while ( m_DataChannelList.Remove(&pData,&Port,&CreationHandle,&DeletionHandle) )
    {
        //
        // Creation and Deletion events are not used for now
        // NhUnRegisterEvent(CreationHandle); // Hopefully nothing bad will happen ! May have been called before
        // NhUnRegisterEvent(DeletionHandle); // if delete has been called it would mean that Remove has been called.
        //

        pData->Cancel();
        pData->Release();
        MYTRACE("ReleaseReservedPort-B %d", ntohs(Port));
        g_pIAlgServicesAlgFTP->ReleaseReservedPort(Port,1);
    }


    if ( g_ControlObjectList.Remove(this) )
    {
        // happens when this was called from within ChannelDeletion or some DecReferece after that.
    }
    else
    {
        // would happen if this was called from shutdown. not otherwise.
    }

    delete this;

    return 0;
}




//
// The last one to call DecReference would take it off control list.
// The first one to call DecReference because of fatal error would call Shutdown to start off
// the DecReference for all the connected stuff.
//
void
CFtpControlConnection::Shutdown()
{
    MYTRACE_ENTER("CFtpControlConnection::Shutdown()");

    if ( m_AlgConnectedSocket != INVALID_SOCKET )
    {
        MYTRACE("CLOSING SOCKET ALG CONNECTED! %d", m_AlgConnectedSocket);
        shutdown(m_AlgConnectedSocket, SD_BOTH);
        closesocket(m_AlgConnectedSocket);
        m_AlgConnectedSocket = INVALID_SOCKET;
    }


    if ( m_ClientConnectedSocket != INVALID_SOCKET )
    {
        MYTRACE("CLOSING SOCKET CLIENT CONNECTED! %d", m_ClientConnectedSocket);
        shutdown(m_ClientConnectedSocket, SD_BOTH);
        closesocket(m_ClientConnectedSocket);
        m_ClientConnectedSocket = INVALID_SOCKET;
    }

    return;
}








//
//
//
void
CFtpControlConnection::ReadCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    MYTRACE_ENTER( "CFtpControlConnection::ReadCompletionRoutine" );

    if ( ErrCode || BytesTransferred == 0 )
    {

        if ( ErrCode )
        {
            MYTRACE("Shutdown because of read ERROR 0x%x", ErrCode);
        }
        else
        {
            MYTRACE("Shutdown because of read 0 bytes");
        }

        MyHelperReleaseBuffer(Bufferp);
        if (DecReference())
            Shutdown();

        return;
    }

    ULONG_PTR ReadType = (ULONG_PTR)Bufferp->Context2;

    ULONG_PTR WriteType;

    SOCKET    ReadSocket;
    SOCKET    WriteSocket;

    ULONG Err;

    if ( ReadType == CLIENT_READ )
    {
        WriteType = SERVER_READ;
        ReadSocket = m_ClientConnectedSocket;
        WriteSocket = m_AlgConnectedSocket;
    }
    else
    {
        WriteType = CLIENT_READ;
        ReadSocket = m_AlgConnectedSocket;
        WriteSocket = m_ClientConnectedSocket;

    }

#if defined(DBG) || defined(_DEBUG)
    ULONG   TraceAddr = 0;
    USHORT  TracePort = 0;

    if ( ReadSocket != INVALID_SOCKET )
        Err = MyHelperQueryRemoteEndpointSocket(ReadSocket ,&TraceAddr,&TracePort);

    MYTRACE("from %s (%s:%d)", 
       ReadType == CLIENT_READ ? "CLIENT":"SERVER", 
	   MYTRACE_IP(TraceAddr),
       ntohs(TracePort)
	   );
    MYTRACE("EC(0x%x)   Buffer size(%d)='%s'", ErrCode, BytesTransferred, MYTRACE_BUFFER2STR((char*)Bufferp->Buffer, BytesTransferred));
#endif
    if ( (ReadType == CLIENT_READ && m_ConnectionType == OUTGOING) || (ReadType == SERVER_READ && m_ConnectionType == INCOMING) )
    {
        // the number of bytes transferred can change.
        // because the ProcessFtpMessage may have to
        // buffer the Address,Port string from PORT or PASV response command.
        ProcessFtpMessage(Bufferp->Buffer,&BytesTransferred);

    }


    if ( BytesTransferred != 0 && WriteSocket != INVALID_SOCKET )
    {
        IncReference();

        MYTRACE(
            "Write to %s size(%d)='%s'",
            WriteType == SERVER_READ ? "SERVER" : "CLIENT",
            BytesTransferred,
            MYTRACE_BUFFER2STR((char*)Bufferp->Buffer, BytesTransferred)
            );

        Err = MyHelperWriteStreamSocket(
            NULL,
            WriteSocket,
            Bufferp,BytesTransferred,
            0,
            MyWriteCompletion,
            (void *)this,(PVOID)WriteType
            );

        if (Err)
        {
            MYTRACE_ERROR("from MyHelperWriteStreamSocket", Err);

            DecReference();
            if (DecReference())
                Shutdown();    // I am not going to call the Read again so one more DecReference is needed.
            MyHelperReleaseBuffer(Bufferp);
            return;
        }
    }

    if ( INVALID_SOCKET == ReadSocket )
    {
        if (DecReference())
            Shutdown();
    }
    else
    {
        Err = MyHelperReadStreamSocket(
            NULL,
            ReadSocket,
            NULL,
            FTP_MAX_MSG_SIZE,
            0,
            MyReadCompletion,
            (void *)this,
            (void *)ReadType
            );
    
    
        if (Err)
        {
            MYTRACE_ERROR("from MyHelperReadStreamSocket",Err);
    
            if (DecReference())
                Shutdown();
        }
    }
    
    return;
}




//
//
//
void
CFtpControlConnection::WriteCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    MYTRACE_ENTER("CFtpControlConnection::WriteCompletionRoutine");

    if (BytesTransferred == 0)
        ErrCode = ERROR_IO_CANCELLED;

    if (ErrCode)
    {
        if (MyHelperIsFatalSocketError(ErrCode) || ErrCode == ERROR_IO_CANCELLED)
        {
            MYTRACE_ERROR("FATAL ERROR", ErrCode);
            MyHelperReleaseBuffer(Bufferp);

            if (DecReference())
                Shutdown();
        }
        else
        {
            MYTRACE_ERROR("ANOTHER MyHelperWriteStreamSocket", ErrCode);

            ULONG_PTR Type = (ULONG_PTR)Bufferp->Context2;
            ULONG Err = MyHelperWriteStreamSocket(
                NULL,
                Bufferp->Socket,
                Bufferp,Bufferp->BytesToTransfer,
                0,
                MyWriteCompletion,
                (void *)this,
                (PVOID)Type
                );

            if (Err)
            {
                MYTRACE_ERROR("From MyHelperWriteStreamSocket", Err);

                MyHelperReleaseBuffer(Bufferp);
                if (DecReference())
                    Shutdown();
            }
        }
    }
    else
    {
        ULONG_PTR Type = (ULONG_PTR)Bufferp->Context2;

        MYTRACE(Type == CLIENT_READ ? "to CLIENT" : "to SERVER" );
        MYTRACE("EC(0x%x) Buffer size(%d)='%s'", ErrCode, BytesTransferred, MYTRACE_BUFFER2STR((char*)Bufferp->Buffer, BytesTransferred));
        MYTRACE("Write Succeeded now cleanup");
        MyHelperReleaseBuffer(Bufferp);
        DecReference();
    }

    return;
}



bool
FtpExtractOctet(
    UCHAR** Buffer,
    UCHAR*  BufferEnd,
    UCHAR*  Octet
    )

/*++

Routine Description:

    This routine is called to extract an octet from a string.

Arguments:

    Buffer - points to a pointer to a string where conversion starts; on
        return it points to the pointer to the string where conversion ends
    BufferEnd - points to the end of the string
    Octet - points to a caller-suplied storage to store converted octet

Return Value:

    BOOLEAN - TRUE if successfuly converted, FALSE otherwise.

--*/

{
    bool    bSuccess;
    ULONG   nDigitFound = 0;
    ULONG   Value = 0;

    while ( 
            *Buffer <= BufferEnd 
        &&  nDigitFound < 3                   
        &&  **Buffer >= '0' 
        &&  **Buffer <= '9'
        ) 
    {
        Value *= 10;
        Value += **Buffer - '0';
        (*Buffer)++;
        nDigitFound++;
    }

    bSuccess = nDigitFound > 0 && Value < 256;

    if ( bSuccess ) 
    {
        *Octet = (UCHAR)Value;
    }

    return bSuccess;
}


//
// Extract host and port numbers.
// example 192,168,0,2,100,200
//
bool
ExtractAddressAndPortCommandValue(
    UCHAR*  pCommandBuffer,
    UCHAR*  pEndOfBuffer,
    UCHAR*  Numbers,
    ULONG*  nTotalLen
    )
{
    UCHAR*  pStartingPosition = pCommandBuffer;

    
    bool bSuccess = FtpExtractOctet(
        &pCommandBuffer,
        pEndOfBuffer,
        &Numbers[0]
        );

    int i = 1;

    while ( i < 6 && bSuccess && *pCommandBuffer == ',' ) 
    {
        pCommandBuffer++;
        bSuccess = FtpExtractOctet(
            &pCommandBuffer,
            pEndOfBuffer,
            &Numbers[i]
            );
        i++;
    }

    if ( bSuccess && i == 6 ) 
    {
        *nTotalLen = (ULONG)(pCommandBuffer - pStartingPosition);
        return true;
    }
    
    return false;
}


#define TOUPPER(c)      ((c) > 'z' ? (c) : ((c) < 'a' ? (c) : (c) ^ 0x20))

//
// Look for the "PORT" or "227" command and remap the private address associated with these command
// to a public address
//
void
CFtpControlConnection::ProcessFtpMessage(
    UCHAR*  Buffer,
    ULONG*  pBytes
    )
{
    MYTRACE_ENTER("CFtpControlConnection::ProcessFtpMessage");
    MYTRACE("Buffer size(%d)='%s'", *pBytes, MYTRACE_BUFFER2STR((char*)Buffer, *pBytes));

    ULONG Bytes = *pBytes;
    UCHAR* pCommandBuffer = reinterpret_cast<UCHAR*>(Buffer);
    UCHAR* EndOfBufferp   = reinterpret_cast<UCHAR*>(Buffer + *pBytes);

    HRESULT hr;
    char *String;

    UCHAR* pBeginAddressAndPortOld=NULL;
    UCHAR* pEndAddressAndPortOld=NULL;


    ULONG nOldAddressLen=0;

    CONST CHAR *pCommandToFind;

    // for now lets keep the OUTGOING and INCOMING seperate.
    // can be put together since most of the code is the same.
    // differences in the first few bytes to scan for.
    if ( m_ConnectionType == OUTGOING )
    {
        MYTRACE("OUTGOING - Look for 'PORT ' command");
        pCommandToFind = (PCHAR)"PORT ";
    }
    else
    {
        MYTRACE("INCOMING - Look for '227 ' command ");
        pCommandToFind = (PCHAR)"227 ";
    }
       
    while ( *pCommandToFind != '\0' && *pCommandToFind == TOUPPER(*pCommandBuffer)) 
    {
        pCommandToFind++;
        pCommandBuffer++;
    }

    if ( *pCommandToFind == '\0' ) 
    {
        MYTRACE("COMMAND found");

        //
        // Skip non digit char
        //
        if ( m_ConnectionType == OUTGOING )
        {
            //
            // Skip white space.  example ->  PORT    10,12,13,14,1,2 
            //
            while (*pCommandBuffer == ' ')
                pCommandBuffer++;
        }
        else
        {
            //
            // Skip non digit char example 227 Entering passive mode (10,12,13,14,1,2)
            //
            while ( pCommandBuffer < EndOfBufferp && !isdigit(*pCommandBuffer) )
                pCommandBuffer++;
        }
        

        //
        // so next stuff should be the addr,port combination.
        //
        UCHAR Numbers[6];


        
        if ( ExtractAddressAndPortCommandValue(pCommandBuffer, EndOfBufferp, Numbers, &nOldAddressLen) )
        {
            pBeginAddressAndPortOld = pCommandBuffer;
            pEndAddressAndPortOld   = pCommandBuffer + nOldAddressLen;

            m_ControlState.m_nAddressOld    = MAKE_ADDRESS(Numbers[0], Numbers[1], Numbers[2], Numbers[3]);
            m_ControlState.m_nPortOld       = MAKE_PORT(Numbers[4], Numbers[5]);

            MYTRACE("***** PRIVATE PORT is %d %d", m_ControlState.m_nPortOld, ntohs(m_ControlState.m_nPortOld));

            if ( ntohs(m_ControlState.m_nPortOld) <= 1025 )
            {
                //
                // For security reason we will disallow any redirection to ports lower then 1025
                // this port range is reserver for standard port Like 139/Netbios 
                // if this port range was requested it probably is the source of hacker attacking this FTP proxy
                //
                MYTRACE("***** Port to redirect is lower then 1025 so rejected");
                m_ControlState.m_nAddressNew    = htonl(0);
                m_ControlState.m_nPortNew       = htons(0);
                m_ControlState.m_nAddressLenNew = 11;
                strcpy((char*)m_ControlState.m_szAddressPortNew, "0,0,0,0,0,0");

                // pretend that a Redirection got created
                // This way we send out a PORT command with the Public addapter address and a new reserver PORT
                // but when the public hacker comes back it wil not be redirect but simply droped
            }
            else
            {
                //
                // Get best public address to use and reserver a port 
                // This will be the Address/Port expose on the public side.
                //
                hr = CreateNewAddress();

                if ( FAILED(hr) )
                {
                    MYTRACE_ERROR("CreateNewAddress failed",hr);
                    // We screwed up. cant make redirects now. so for now lets just act
                    // as if nothing happened and carry on with the stuff.
                }
            }
        }
        else
        {
            MYTRACE_ERROR("NOT a valid PORT command syntax", E_INVALIDARG);
        }
    }

    //
    // Rebuild the string command with the new address port 
    //
    if ( pBeginAddressAndPortOld )
    {
        if ( ntohs(m_ControlState.m_nPortOld) <= 1025 )
        {
            // No need to setup a redirection
            hr = S_OK;
        }
        else
        {
            hr = SetupDataRedirect();
        }

        if ( FAILED(hr) )
        {
            // we got screwed badly here. we wont set up redirect and act as if nothing happened.
            MYTRACE_ERROR("Could not setup a redirect", hr);
        }
        else
        {
            //
            // Move trailing buffer 
            //  Left if new address is smaller then old address
            //  Right if new address is bigger then old address
            //
            

            // This is the right side reminder of the buffer just after the last digit of the ascii port value
            int nReminerSize = (int)(Bytes - (pEndAddressAndPortOld - Buffer));

            if ( *pBytes + nReminerSize < FTP_MAX_MSG_SIZE )
            {
                int nOffset = m_ControlState.m_nAddressLenNew - nOldAddressLen; // What is the delta size between the old and new address

                MoveMemory(
                    pEndAddressAndPortOld + nOffset,    // Destination
                    pEndAddressAndPortOld,              // Source
                    nReminerSize                        // Size
                    );
    
                //
                // Insert the new address and port
                //
                memcpy(
                    pBeginAddressAndPortOld,            // Destination
                    m_ControlState.m_szAddressPortNew,  // Source
                    m_ControlState.m_nAddressLenNew     // Size
                    );
    
                MYTRACE("OLD Address size(%d) %s:%d", nOldAddressLen,                  MYTRACE_IP(m_ControlState.m_nAddressOld), ntohs(m_ControlState.m_nPortOld));
                MYTRACE("New Address size(%d) %s:%d", m_ControlState.m_nAddressLenNew, MYTRACE_IP(m_ControlState.m_nAddressNew), ntohs(m_ControlState.m_nPortNew));
                
                *pBytes = Bytes - nOldAddressLen + m_ControlState.m_nAddressLenNew;
                MYTRACE("Edited COMMAND is '%s' size(%d)", MYTRACE_BUFFER2STR((char*)Buffer, *pBytes), *pBytes);

                // Now we are sure to have a DataChannel created and in the list of DataChanel
                // on the last DecRefer the ResertPort was deleted twice
                // now by setting m_nPortNew to zero only the DataChannel code will release the port
                //
                m_ControlState.m_nPortNew = 0;
            }
            else
            {
                MYTRACE_ERROR("Could not alter the command the new address size does not fit in the the current buffer ", E_ABORT);
            }
        }
    }

    return;
}



//
//
//
int
CreateStringFromNumber(UCHAR *String,ULONG Num)
{
    int retval = 0;
    UCHAR ch1,ch2,ch3;

    ch3 = (UCHAR)(Num%10) + '0';
    Num = Num/10;
    ch2 = (UCHAR)(Num%10) + '0';
    Num = Num/10;
    ch1 = (UCHAR)(Num%10) + '0';
    _ASSERT(Num == 0);
    if (ch1 != '0') {
        String[retval++] = ch1;
        String[retval++] = ch2;
        String[retval++] = ch3;
    }
    else if (ch2 != '0') {
        String[retval++] = ch2;
        String[retval++] = ch3;
    }
    else {
        String[retval++] = ch3;
    }

    return retval;
}


//
//
//
int
CreateULONGString(UCHAR *String,ULONG Num)
{
    int retval = 0;
    retval += CreateStringFromNumber(String,Num&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>8)&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>16)&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>24)&0xff);
    return retval;
}


//
//
//
int
CreateUSHORTString(UCHAR *String,USHORT Num)
{
    int retval = 0;
    retval += CreateStringFromNumber(String,Num&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>8)&0xff);
    return retval;
}


//
//
//
HRESULT
CFtpControlConnection::CreateNewAddress(void)
{
    MYTRACE_ENTER("CFtpControlConnection::CreateNewAddress");

    SOCKET  sd;
    HRESULT hr = S_OK;
    ULONG   Err = 0;

    sd = (m_ConnectionType == OUTGOING ? m_AlgConnectedSocket : m_ClientConnectedSocket);

    ULONG OtherAddr,PublicAddr;
    USHORT OtherPort,PublicPort;

    Err = MyHelperQueryRemoteEndpointSocket(sd,&OtherAddr,&OtherPort);

    if (Err == 0)
    {
        hr = g_pIAlgServicesAlgFTP->GetBestSourceAddressForDestinationAddress(OtherAddr,FALSE,&PublicAddr);

        if ( SUCCEEDED(hr) )
        {
            hr = g_pIAlgServicesAlgFTP->ReservePort(1,&PublicPort);
        }
        else
        {
            MYTRACE_ERROR("Could not GetBestSourceAddressForDestinationAddress", hr);
            PublicAddr = 0; // Try with this
        }

        MYTRACE("ICS Reserved Address   %s:%d", MYTRACE_IP(PublicAddr), ntohs(PublicPort));
        m_ControlState.m_nAddressNew = PublicAddr;
        m_ControlState.m_nPortNew = PublicPort;

        
        ULONG StrLen = CreateULONGString(m_ControlState.m_szAddressPortNew,PublicAddr);

        m_ControlState.m_szAddressPortNew[StrLen++] = ',';
        StrLen += CreateUSHORTString(m_ControlState.m_szAddressPortNew+StrLen,PublicPort);
        m_ControlState.m_nAddressLenNew = StrLen;
        MYTRACE("NEW AddressPort String %s Len(%d)", MYTRACE_BUFFER2STR((char*)m_ControlState.m_szAddressPortNew, StrLen), StrLen);

    }

    return hr;
}



//
//
//
HRESULT
CFtpControlConnection::SetupDataRedirect(void)
{
    MYTRACE_ENTER("CFtpControlConnection::SetupDataRedirect");

    ULONG   pubAddr,prvAddr,icsAddr;
    USHORT  pubPort,prvPort,icsPort;
    ULONG   Err = 0;



    switch ( m_ConnectionType )
    {
    case OUTGOING:
        MYTRACE("OUTGOING");

        Err = MyHelperQueryRemoteEndpointSocket(m_AlgConnectedSocket,&pubAddr,&pubPort);
        pubPort = 0;

        icsAddr = m_ControlState.m_nAddressNew;
        icsPort = m_ControlState.m_nPortNew;

        prvAddr = m_ControlState.m_nAddressOld;
        prvPort = m_ControlState.m_nPortOld;
        break;

    case INCOMING:
        MYTRACE("INCOMING");
        Err = MyHelperQueryRemoteEndpointSocket(m_ClientConnectedSocket,&pubAddr,&pubPort);
        pubPort = 0;
        pubAddr = 0;
        icsAddr = m_ControlState.m_nAddressNew;
        icsPort = m_ControlState.m_nPortNew;

        prvAddr = m_ControlState.m_nAddressOld;
        prvPort = m_ControlState.m_nPortOld;
        break;

    default:
        MYTRACE_ERROR("invalid m_ConnectionType", E_FAIL);
        return E_FAIL;
    }


    if ( Err != 0 )
    {
        MYTRACE_ERROR("MyHelperQueryRemoteEndpointSocket", Err);
        return E_FAIL;
    }


    HRESULT         hr = S_OK;
    IDataChannel*   pDataChannel = NULL;

    hr = g_pIAlgServicesAlgFTP->CreateDataChannel(
        eALG_TCP,
        prvAddr,
        prvPort,
        icsAddr,
        icsPort,
        pubAddr,
        pubPort,
        eALG_INBOUND,   //| eALG_OUTBOUND, not needed i suppose since we
                        // are not bothered if client tries to open connection.
        (ALG_NOTIFICATION)0,// (eALG_SESSION_CREATION | eALG_SESSION_DELETION),
        FALSE,
        &pDataChannel
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("g_pIAlgServicesAlgFTP->CreateDataChannel", hr);
        return hr;
    }


    m_DataChannelList.Insert(
        pDataChannel,
        icsPort,
        0,
        0
        );

    return S_OK;


    //
    // Don't use creation and deletion events for now
    //
#if 0
    HANDLE          HandleDataChannelCreation = NULL;
    HANDLE          HandleDataChannelDeletion = NULL;

    HANDLE          MyHandleRegisteredCreation = NULL;
    HANDLE          MyHandleRegisteredDeletion = NULL;

    //
    // Get the CREATION handle
    //

    hr = pDataChannel->GetSessionCreationEventHandle((HANDLE_PTR *)&HandleDataChannelCreation);

    if ( SUCCEEDED(hr) )
    {
        MYTRACE("Creation Handle is %d", HandleDataChannelCreation);

        MyHandleRegisteredCreation = NhRegisterEvent(
            HandleDataChannelCreation,
            DataChannelCreationCallback,
            (PVOID)this,
            (PVOID)pDataChannel,
            DATA_CREATION_TIMEO
            );

        if ( MyHandleRegisteredCreation )
        {

            //
            // Get the DELETION handle
            //
            hr = pDataChannel->GetSessionDeletionEventHandle((HANDLE_PTR *)&HandleDataChannelDeletion);

            if ( SUCCEEDED(hr) )
            {
                MYTRACE("Deletion Handle is %d", HandleDataChannelDeletion);

                MyHandleRegisteredDeletion = NhRegisterEvent(
                    HandleDataChannelDeletion,
                    DataChannelDeletionCallback,
                    (PVOID)this,
                    (PVOID)pDataChannel,
                    INFINITE
                    );


                if ( MyHandleRegisteredDeletion )
                {
                    //
                    // We have a valid DataChannel
                    //
                    MYTRACE ("Inserting into DataChannelList");

                    m_DataChannelList.Insert(
                        pDataChannel,
                        icsPort,
                        MyHandleRegisteredCreation,
                        MyHandleRegisteredDeletion
                        );

                    return S_OK;
                }
                else
                {
                    MYTRACE_ERROR("NhRegisterEven(HandleDataChannelDeletion)", 0);
                }
            }
            else
            {
                MYTRACE_ERROR("GetSessionDeletionEventHandle",hr);
            }

        }
        else
        {
            MYTRACE_ERROR("NhRegisterEvent(HandleDataChannelCreation)", 0);
        }
    }
    else
    {
        MYTRACE_ERROR("GetSessionCreationEventHandle",hr);
    }

    //
    // ERROR if we got here, rollback
    //

    pDataChannel->Cancel();
    pDataChannel->Release();

    if ( MyHandleRegisteredCreation )
        NhUnRegisterEvent(MyHandleRegisteredCreation);

    if ( MyHandleRegisteredDeletion )
        NhUnRegisterEvent(MyHandleRegisteredDeletion);

    return hr; // return the last error
#endif
}


//
//
//
void
CFtpControlConnection::DataChannelDeletion(
    BOOLEAN TimerOrWait,
    PVOID   Context
    )
{
    MYTRACE_ENTER("CFtpControlConnection::DataChannelDeletion");

    USHORT port;
    IDataChannel *pDataChannel = (IDataChannel *)Context;
/*
    if (m_DataChannelList.Remove(pDataChannel,&port))
    {
        MYTRACE("Releasing Port");
        pDataChannel->Release();
        g_pIAlgServicesAlgFTP->ReleaseReservedPort(port,1);
        ULONG ref;
        ref = DecReference();
    }
*/
    return;
}




//
//
//
void
CFtpControlConnection::DataChannelCreation(
    BOOLEAN TimerOrWait,
    PVOID   Context
    )
{
    MYTRACE_ENTER("CFtpControlConnection::DataChannelCreation");
    MYTRACE("TimerOrWait: %d", TimerOrWait);

    USHORT port;
    if (TimerOrWait==0)
    {
/*
        IDataChannel *pDataChannel = (IDataChannel *)Context;
        HANDLE DeletionHandle;

        if ( m_DataChannelList.Remove(pDataChannel,&port,&DeletionHandle))
        {
            MYTRACE("Cancelling DataChannel");
            pDataChannel->Cancel();
            pDataChannel->Release();

            MYTRACE("Releasing Port");
            g_pIAlgServicesAlgFTP->ReleaseReservedPort(port,1);
            NhUnRegisterEvent(DeletionHandle);
            DecReference();
        }
*/
    }

    return;
}



CComAutoCriticalSection         m_AutoCS_FtpIO;



//
//
//
void
DataChannelCreationCallback(
    BOOLEAN TimerOrWait,
    PVOID   Context,
    PVOID   Context2
    )
{
    MYTRACE_ENTER("DataChannelCreationCallback");

    CFtpControlConnection *pFtpControl = (CFtpControlConnection *)Context;
    pFtpControl->DataChannelCreation(TimerOrWait,Context2);
}




//
//
//
void
DataChannelDeletionCallback(
    BOOLEAN TimerOrWait,
    PVOID   Context,
    PVOID   Context2
    )
{
    MYTRACE_ENTER("DataChannelDeletionCallback");

    CFtpControlConnection *pFtpControl = (CFtpControlConnection *)Context;
    pFtpControl->DataChannelDeletion(TimerOrWait,Context2);
}




//
//
//
void
MyAcceptCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    m_AutoCS_FtpIO.Lock();

    MYTRACE_ENTER("MyAcceptCompletion");

    CAlgFTP* pMainObj = (CAlgFTP*)Bufferp->Context;
    if ( pMainObj )
        pMainObj->AcceptCompletionRoutine(ErrCode,BytesTransferred,Bufferp);

    m_AutoCS_FtpIO.Unlock();

}




//
//
//
void
MyConnectCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  pContext
    )
{
    m_AutoCS_FtpIO.Lock();

    MYTRACE_ENTER("MyConnectCompletion");
   

    CFtpControlConnection* pControl = (CFtpControlConnection *)pContext;  // Special case here see socket.cpp MyHelperpConnectOrCloseCallbackRoutine

    if ( pControl )
        pControl->ConnectCompletionRoutine(ErrCode,BytesTransferred);

    m_AutoCS_FtpIO.Unlock();

}







//
//
//
void
MyReadCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    m_AutoCS_FtpIO.Lock();

    MYTRACE_ENTER("");
    
    CFtpControlConnection *pControl = (CFtpControlConnection *)Bufferp->Context;

    if ( pControl )
        pControl->ReadCompletionRoutine(ErrCode,BytesTransferred,Bufferp);
    else
    {
        MYTRACE_ENTER("ERROR ERROR ERROR MyReadCompletion");
    }

    m_AutoCS_FtpIO.Unlock();

}




//
//
//
void
MyWriteCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    m_AutoCS_FtpIO.Lock();    

    MYTRACE_ENTER("");

    CFtpControlConnection *pControl = (CFtpControlConnection *)Bufferp->Context;
    if ( pControl )
        pControl->WriteCompletionRoutine(ErrCode,BytesTransferred,Bufferp);
    else
    {
        MYTRACE_ENTER("ERROR ERROR ERROR MyWriteCompletion");
    }

    m_AutoCS_FtpIO.Unlock();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\list.cpp ===
#include "precomp.h"
#include "myalg.h"

//
//
//
BOOL 
CGenericList::Insert(VOID *key, VOID *key2, VOID *context, VOID *context2, VOID *context3)
{
    CNode* pNode = new CNode(key,key2,context,context2,context3);

    if (pNode == NULL)
        return FALSE;

    EnterCriticalSection(&m_ObjectListCritical);
    pNode->m_pNext = m_Head;
    m_Head = pNode;
    LeaveCriticalSection(&m_ObjectListCritical);

    return TRUE;
}


//
//
//
BOOL 
CGenericList::RemoveKey(VOID *key, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3)
{
    BOOL retval = TRUE;
    EnterCriticalSection(&m_ObjectListCritical);
    if (m_Head) 
    {
        CNode* pNode = m_Head;
        if ((ULONG_PTR)key == (ULONG_PTR)pNode->m_pKey) 
        {
            m_Head = m_Head->m_pNext;
        }
        else 
        {
            CNode* pNodepre;
            while (pNode && (ULONG_PTR)pNode->m_pKey != (ULONG_PTR)key) 
            {
                pNodepre = pNode;
                pNode = pNode->m_pNext;
            }

            if ( pNode ) 
            {
                pNodepre->m_pNext = pNode->m_pNext;
            }
        }

        LeaveCriticalSection(&m_ObjectListCritical);

        if ( pNode ) 
        {
            if (pkey2)
                *pkey2 = pNode->m_pKey2;

            if (pcontext)
                *pcontext = pNode->m_pContext;

            if (pcontext2)
                *pcontext2 = pNode->m_pContext2;

            if (pcontext3)
                *pcontext3 = pNode->m_pContext3;

            delete pNode;
        }
        else
        {
            retval = FALSE;
        }
    }
    else 
    {
        LeaveCriticalSection(&m_ObjectListCritical);
        retval = FALSE;
    }
    return retval;
}



//
// removal based on second key
//
BOOL 
CGenericList::RemoveKey2(VOID **pkey, VOID *key2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3)
{
    BOOL retval = TRUE;
    EnterCriticalSection(&m_ObjectListCritical);
    if (m_Head) 
    {
        CNode* pNode = m_Head;
        if ( (ULONG_PTR)key2 == (ULONG_PTR)pNode->m_pKey2 ) 
        {
            m_Head = m_Head->m_pNext;
        }
        else 
        {
            CNode* pNodepre;
            while (pNode && (ULONG_PTR)pNode->m_pKey2 != (ULONG_PTR)key2) 
            {
                pNodepre = pNode;
                pNode = pNode->m_pNext;
            }

            if (pNode) 
            {
                pNodepre->m_pNext = pNode->m_pNext;
            }
        }

        LeaveCriticalSection(&m_ObjectListCritical);

        if (pNode) 
        {
            if (pkey)
                *pkey       = pNode->m_pKey;
            if (pcontext)
                *pcontext   = pNode->m_pContext;

            if (pcontext2)
                *pcontext2  = pNode->m_pContext2;

            if (pcontext3)
                *pcontext3  = pNode->m_pContext3;

            delete pNode;
        }
        else
            retval = FALSE;
    }
    else 
    {
        LeaveCriticalSection(&m_ObjectListCritical);
        retval = FALSE;
    }
    return retval;
}



//
// removal from beginning of list
//
BOOL 
CGenericList::Remove(VOID **pkey, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3)
{
    BOOL retval = TRUE;
    EnterCriticalSection(&m_ObjectListCritical);
    CNode* pNode = m_Head;

    if (pNode) 
    {
        m_Head = pNode->m_pNext;
    }

    LeaveCriticalSection(&m_ObjectListCritical);

    if (pNode) 
    {
        if (pkey)
            *pkey       = pNode->m_pKey;
        if (pkey2)
            *pkey2      = pNode->m_pKey2;
        if (pcontext)
            *pcontext   = pNode->m_pContext;
        if (pcontext2)
            *pcontext2  = pNode->m_pContext2;
        if (pcontext3)
            *pcontext3  = pNode->m_pContext3;

        delete pNode;
    }
    else 
    {
        retval = FALSE;
    }
    return retval;
}



//
//
//
BOOL 
CControlObjectList::Insert(CFtpControlConnection *pControlConnection)
{
    MYTRACE_ENTER("CControlObjectList::Insert");
    BOOL retval = m_ControlObjectList.Insert(pControlConnection,NULL,NULL,NULL,NULL);
    if (retval) {
        ++m_NumElements;
        MYTRACE("Inserting %x Number of Elements %d",pControlConnection,m_NumElements);
    }
    else {
        MYTRACE("Error Inserting into list");
    }

    return retval;
}


extern HANDLE g_hNoMorePendingConnection; // see MyAlg.cpp

//
//
//
BOOL 
CControlObjectList::Remove(CFtpControlConnection *pControlConnection)
{
    MYTRACE_ENTER("CControlObjectList::Remove");   
    BOOL retval = m_ControlObjectList.RemoveKey(pControlConnection,NULL,NULL,NULL,NULL);
    if (retval) {
        --m_NumElements;
        MYTRACE("Number of elements remaining %d",m_NumElements);
    }
    else {
        MYTRACE("Not found");
    }

    
    if ( m_NumElements == 0 )
    {

        MYTRACE("No more connection");

        if ( g_hNoMorePendingConnection )
        {
            MYTRACE("Must be in stop so signal g_hNoMorePendingConnection");
            SetEvent(g_hNoMorePendingConnection);
        }
    }

    return retval;
}



//
//
//
void
CControlObjectList::ShutdownAll()
{
    MYTRACE_ENTER("CControlObjectList::ShutdownAll");

    EnterCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));
    MYTRACE("List contains %d CFTPcontrolConnection", m_NumElements);
    if ( m_ControlObjectList.m_Head )
    {
        CNode* pNode = (CNode*)m_ControlObjectList.m_Head;

        while ( pNode )
        {
            CFtpControlConnection* pFtpCtrl = (CFtpControlConnection*)pNode->m_pKey;

            closesocket(pFtpCtrl->m_AlgConnectedSocket);
            pFtpCtrl->m_AlgConnectedSocket = INVALID_SOCKET;


            closesocket(pFtpCtrl->m_ClientConnectedSocket);
            pFtpCtrl->m_ClientConnectedSocket=INVALID_SOCKET;

            pNode = pNode->m_pNext;
        }
    }

    LeaveCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));
}




//
// Return false if the given port is currently in use for the give address
// else return it's available and return true
//
bool
CControlObjectList::IsSourcePortAvailable(
    ULONG   nPublicSourceAddress,
    USHORT  nPublicSourcePortToVerify
    )
{
    MYTRACE_ENTER("CControlObjectList::IsSourcePortAvailable");

    EnterCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));

    MYTRACE("List contains %d CFTPcontrolConnection", m_NumElements);

    if ( m_ControlObjectList.m_Head )
    {
        CNode* pNode = (CNode*)m_ControlObjectList.m_Head;

        while ( pNode )
        {
            CFtpControlConnection* pFtpCtrl = (CFtpControlConnection*)pNode->m_pKey;

            ULONG  nClientSourceAddress;
            USHORT nClientSourcePort;

            ULONG Err = MyHelperQueryRemoteEndpointSocket(
                pFtpCtrl->m_ClientConnectedSocket,
                &nClientSourceAddress,
                &nClientSourcePort
                );

            if ( 0 == Err )
            {

                if ( nClientSourceAddress == nPublicSourceAddress )
                {
                    MYTRACE("Source Address %s:%d substitude %d", 
                        MYTRACE_IP(nClientSourceAddress), 
                        ntohs(nClientSourcePort), 
                        pFtpCtrl ->m_nSourcePortReplacement
                        );

                    if ( nPublicSourcePortToVerify == nClientSourcePort ||
                         nPublicSourcePortToVerify == pFtpCtrl->m_nSourcePortReplacement
                        )
                    {
                        MYTRACE("Already in use");
                        LeaveCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));
                        return false;
                    }
                }
            }
            else
            {
                MYTRACE_ERROR("From MyHelperQueryRemoteEndpointSocket", Err);
            }

            pNode = pNode->m_pNext;
        }
    }

    LeaveCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));

    return true;
}



//
//
//
BOOL 
CDataChannelList::Insert(IDataChannel *pDataChannel,USHORT icsPort,HANDLE CreationHandle,HANDLE DeletionHandle)
{
    MYTRACE_ENTER("CDataChannelList::Insert");
    MYTRACE("Inserting %x",pDataChannel);
    BOOL retval = m_DataChannelObjectList.Insert(pDataChannel,(VOID *)icsPort,CreationHandle,DeletionHandle,NULL);
    if (retval) {
        MYTRACE("Number of elements %d",++m_NumElements);
    }
    else {
        MYTRACE("Unable to insert");
    }
    return retval;
}


//
//
//
BOOL 
CDataChannelList::Remove(IDataChannel **pDataChannel,USHORT *picsPort,HANDLE *pCreationHandle,HANDLE *pDeletionHandle)
{
    MYTRACE_ENTER("CDataChannelList::Remove");
    BOOL retval;
    retval = m_DataChannelObjectList.Remove((VOID **)pDataChannel,(VOID **)picsPort,pCreationHandle,pDeletionHandle,NULL);
    if (retval) {
        MYTRACE("Number of elements remaining %d",--m_NumElements);
    }
    else {
        MYTRACE("No more elements to remove");
    }

    return retval;
}


//
//
//
BOOL 
CDataChannelList::Remove(IDataChannel *pDataChannel,USHORT *picsPort)
{
    MYTRACE_ENTER("CDataChannelList::Remove");
    BOOL retval = m_DataChannelObjectList.RemoveKey(pDataChannel,(VOID **)picsPort,NULL,NULL,NULL);
    if (retval) {
        MYTRACE("Number of elements remaining %d",--m_NumElements);
    }
    else {
        MYTRACE("Element not found");
    }

    return retval;
}


//
//
//
BOOL 
CDataChannelList::Remove(IDataChannel *pDataChannel,USHORT *picsPort,HANDLE *pDeletionHandle)
{
    MYTRACE_ENTER("CDataChannelList::Remove");    
    BOOL retval = m_DataChannelObjectList.RemoveKey(pDataChannel,(VOID **)picsPort,NULL,pDeletionHandle,NULL);
    if (retval) {
        MYTRACE("Number of elements remaining %d",--m_NumElements);
    }
    else {
        MYTRACE("Element not found");
    }
    return retval;
}


//
//
//
BOOL 
CRegisteredEventList::Insert(HANDLE WaitHandle, HANDLE hEvent,EVENT_CALLBACK CallBack, void *Context, void *Context2)
{
    MYTRACE_ENTER("CRegisteredEventList::Insert");
    BOOL retval = m_RegEventObjectList.Insert(WaitHandle,hEvent,CallBack,Context,Context2);
    if (retval) {
        MYTRACE("Number of elements %d",++m_NumElements);
    }
    else {
        MYTRACE("Error Inserting");
    }
    return retval;
}

//
//
//
BOOL 
CRegisteredEventList::Remove(HANDLE WaitHandle, HANDLE *phEvent)
{
    MYTRACE_ENTER("CRegisteredEventList::Remove");
    BOOL retval = m_RegEventObjectList.RemoveKey(WaitHandle,phEvent,NULL,NULL,NULL);
    if (retval) {
        MYTRACE("Removal on WaitHandle Number of elements %d",--m_NumElements);
    }
    else {
        MYTRACE("Element WaitHandle on not found");
    }
    return retval;
}


//
//
//
BOOL 
CRegisteredEventList::Remove(HANDLE *pWaitHandle, HANDLE hEvent,EVENT_CALLBACK *pCallBack,void **pcontext,void **pcontext2)
{
    MYTRACE_ENTER("CRegisteredEventList::Remove");
    BOOL retval = m_RegEventObjectList.RemoveKey2(pWaitHandle,hEvent,(VOID **)pCallBack,pcontext,pcontext2);
    if (retval) {
        MYTRACE("Removal on EventHandle Number of elements %d",--m_NumElements);
    }
    else {
        MYTRACE("Element EventHandle not found");
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\ftpcontrol.h ===
//
// Copyright (C) 2001 Microsoft Corp
//
// FtpControl.cpp 
//
// Sanjiv
// JPDup
//

#pragma once

class CFtpControlConnection;

//#include "PreComp.h"  // Theis FtpControl.h file get included by MyAlg.h that is used in the ALG.exe build
// so we can't use this precompile file
#include "buffer.h"
#include "list.h"


#define FTP_MAX_MSG_SIZE 1024

typedef enum _READ_TYPE 
{
    CLIENT_READ = 0x1,
    SERVER_READ = 0x2

} READ_TYPE;


typedef enum _CONNECTION_TYPE 
{
    INCOMING = 0x1,
    OUTGOING = 0x2

}CONNECTION_TYPE;

extern CControlObjectList g_ControlObjectList;




#define ERROR_IO_CANCELLED  0xC0000120
#define DATA_CREATION_TIMEO 1000
#define ADD_STR_SIZE        23




class CControlState 
{

public:
    ULONG   m_nAddressNew;
    ULONG   m_nAddressOld;

    USHORT  m_nPortNew;
    USHORT  m_nPortOld;
    
    UCHAR   m_szAddressPortNew[ADD_STR_SIZE];
    ULONG   m_nAddressLenNew;    
};



//
//
// Main class that controls the FTP
//
//
class CFtpControlConnection
{
public:
    // Constructor(s)
    CFtpControlConnection();

    // Destruction
    ~CFtpControlConnection();

//
// Properties
//
    SOCKET                          m_ClientConnectedSocket;
    SOCKET                          m_AlgConnectedSocket;
    USHORT                          m_nSourcePortReplacement;
private:

    IPendingProxyConnection*        m_pPendingProxy;

    CONNECTION_TYPE                 m_ConnectionType;    
    CControlState                   m_ControlState;  

    volatile LONG                   m_RefCount;

    CDataChannelList                m_DataChannelList;

//
// Methods
//
private:

    //
    void 
        ProcessFtpMessage(
            UCHAR*  Buffer,
            ULONG*   pBytes
            );

    //
    HRESULT 
        CreateNewAddress(void);

    //
    HRESULT 
        SetupDataRedirect(void);


public:  

    //
    ULONG 
        IncReference();

    //
    ULONG 
        DecReference();

    //
    void 
        Shutdown();


    //
    HRESULT 
        Init(
            SOCKET                          AcceptedSocket,
            ULONG                           ToAddr,
            USHORT                          ToPort,
            CONNECTION_TYPE                 ConnType
            );

    //
    void 
        DataChannelDeletion(
            BOOLEAN TimerOrWait,
            PVOID   Context
            );

    //
    void 
        DataChannelCreation(
            BOOLEAN TimerOrWait,
            PVOID   Context
            );

    //
    void 
        ConnectCompletionRoutine(
            ULONG       ErrCode,
            ULONG       BytesTransferred
            );

    //
    void 
        ReadCompletionRoutine(
            ULONG       ErrCode,
            ULONG       BytesTransferred,
            PNH_BUFFER  Bufferp
            );

    //
    void 
        WriteCompletionRoutine(
            ULONG       ErrCode,
            ULONG       BytesTransferred,
            PNH_BUFFER  Bufferp
            );
};



void 
DataChannelCreationCallback(
    BOOLEAN TimerOrWait,PVOID Context,PVOID Context2
    );

void 
DataChannelDeletionCallback(
    BOOLEAN TimerOrWait,PVOID Context,PVOID Context2
    );

void 
MyAcceptCompletion(
    ULONG ErrCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp);



void 
MyConnectCompletion(ULONG ErrCode,
                    ULONG BytesTransferred,
                    PNH_BUFFER Bufferp);
void 
MyReadCompletion(ULONG ErrCode,
                 ULONG BytesTransferred,
                 PNH_BUFFER Bufferp);
void 
MyWriteCompletion(ULONG ErrCode,
                  ULONG BytesTransferred,
                  PNH_BUFFER Bufferp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\myadapternotify.h ===
//
// MyAdapterNotify.h : Declaration of the CMyAdapterNotify
//

#pragma once



// {6E590D42-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_MyAdapterNotificationSink, 0x6e590d42, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);


/////////////////////////////////////////////////////////////////////////////
//
// CMyAdapterNotify
//
class ATL_NO_VTABLE CMyAdapterNotify : 
    public CComObjectRoot,
    public CComCoClass<CMyAdapterNotify, &CLSID_MyAdapterNotificationSink>,
    public IAdapterNotificationSink
{
public:
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CMyAdapterNotify)

BEGIN_COM_MAP(CMyAdapterNotify)
	COM_INTERFACE_ENTRY(IAdapterNotificationSink)
END_COM_MAP()


//
// IAdapterNotificationSink
//
public:
	STDMETHODIMP    AdapterAdded     (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterRemoved   (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterModified  (IAdapterInfo*   pAdapter);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\list.h ===
//
// Collections(list) class
//

#pragma once

#include "regevent.h"


//
//
//
class CNode
{

public:
    CNode(
        VOID* pKey, 
        VOID* pKey2, 
        VOID* pContext, 
        VOID* pContext2, 
        VOID* pContext3
        )
    {
        m_pKey      = pKey;
        m_pKey2     = pKey2;
        m_pContext  = pContext;
        m_pContext2 = pContext2;
        m_pContext3 = pContext3;
    };

    VOID*   m_pKey;
    VOID*   m_pKey2;
    VOID*   m_pContext;
    VOID*   m_pContext2;
    VOID*   m_pContext3;
    CNode*  m_pNext;
};



//
//
//
class CGenericList
{
   
public:
    CRITICAL_SECTION    m_ObjectListCritical;

    CNode*              m_Head;

    CGenericList() 
    {
        m_Head = NULL;
        InitializeCriticalSection(&m_ObjectListCritical);
    };

    ~CGenericList()
    {
        DeleteCriticalSection(&m_ObjectListCritical);
    };

    BOOL Insert(VOID *key, VOID *key2, VOID *context, VOID *context2, VOID *context3);
    
    // removal based on first key
    BOOL RemoveKey(VOID *key, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3);
    
    // removal based on second key
    BOOL RemoveKey2(VOID **pkey, VOID *key2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3);

    // removal from list.
    BOOL Remove(VOID **pkey, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3);
};



//
//
//
class CControlObjectList
{
private:
    CGenericList     m_ControlObjectList;
    
public:

    ULONG            m_NumElements;

    CControlObjectList() 
    { 
        m_NumElements = 0; 
    };
    
    BOOL Insert(CFtpControlConnection *pControlConnection);
    
    BOOL Remove(CFtpControlConnection *pControlConnection);
    
    bool
    IsSourcePortAvailable(
        ULONG   nPublicSourceAddress,
        USHORT  nPublicSourcePortToVerify
        );

    void ShutdownAll();

    
};


//
//
//
class CDataChannelList
{
private:
    CGenericList    m_DataChannelObjectList;
    ULONG           m_NumElements;

public:
    CDataChannelList() 
    { 
        m_NumElements = 0; 
    };

    BOOL Insert(IDataChannel *pDataChannel,USHORT icsPort,HANDLE CreationHandle,HANDLE DeletionHandle);

    BOOL Remove(IDataChannel **pDataChannel,USHORT *icsPort,HANDLE *CreationHandle,HANDLE *DeletionHandle);

    BOOL Remove(IDataChannel *pDataChannel,USHORT *icsPort);
    
    BOOL Remove(IDataChannel *pDataChannel,USHORT *icsPort,HANDLE *DeletionHandle);

};


//
//
//
class CRegisteredEventList
{    
private:
    CGenericList    m_RegEventObjectList;
    ULONG           m_NumElements;

public:
    CRegisteredEventList() { m_NumElements = 0; };

    BOOL Insert(HANDLE WaitHandle, HANDLE hEvent,EVENT_CALLBACK CallBack, void *Context, void *Context2);
    
    BOOL Remove(HANDLE WaitHandle, HANDLE *hEvent);
    
    BOOL Remove(HANDLE *WaitHandle, HANDLE hEvent,EVENT_CALLBACK *CallBack,void **context,void **context2);
};

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\precomp.h ===
//
// Precom.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//

#pragma once


#define _ATL_FREE_THREADED


#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "resource.h"

#include <Winsock2.h>
#include <MsWSock.h>
#include <mstcpip.h>

#include <ALG.h>

#include "MyTrace.h"

#include "buffer.h"
#include "socket.h"
#include "regevent.h"

#include "FtpControl.h"
#include "list.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\myalg.h ===
//
// AlgFTP.h : Declaration of the CAlgFTP
//
#pragma once

#include "FtpControl.h"

// {6E590D61-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_AlgFTP, 0x6e590d61, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);


extern IApplicationGatewayServices*  g_pIAlgServicesAlgFTP;
extern USHORT                        g_nFtpPort;           // By Default this will be 21 band can be overwritten by
                                                           // a RegKey see MyAlg.cpp->Initialize




/////////////////////////////////////////////////////////////////////////////
//
// CAlgFTP
//
class ATL_NO_VTABLE CAlgFTP: 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAlgFTP, &CLSID_AlgFTP>,
    public IApplicationGateway
{
public:
    CAlgFTP();
    ~CAlgFTP();


public:
//    DECLARE_REGISTRY(CAlgFTP, TEXT("ALG_FTP.MyALG.1"), TEXT("ALG_FTP.MyALG"), -1, THREADFLAGS_BOTH)
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CAlgFTP)

BEGIN_COM_MAP(CAlgFTP)
	COM_INTERFACE_ENTRY(IApplicationGateway) 
END_COM_MAP()

//
// IApplicationGateway
//
public:
	STDMETHODIMP Initialize(
        IApplicationGatewayServices* pIAlgServices
        );

	STDMETHODIMP Stop(
        void
        );
        

//
// Properties
//
private:
    HANDLE                        m_hNoMoreAccept;

public:

    IPrimaryControlChannel*       m_pPrimaryControlChannel;

    ULONG                         m_ListenAddress;
    USHORT                        m_ListenPort;
    SOCKET                        m_ListenSocket;



//
// Methods
//
public:

    //
    HRESULT
    GetFtpPortToUse(
        USHORT& usPort
        );

    //
    void
    CleanUp();

    //
    HRESULT 
    MyGetOriginalDestinationInfo(
        PUCHAR              Buffer,
        ULONG*              pAddr,
        USHORT*             pPort,
        CONNECTION_TYPE*    pConnType
        );
	
    //
    ULONG 
    MakeListenerSocket();

    //
    ULONG 
    RedirectToMyPort();

    //
    void 
    AcceptCompletionRoutine(
        ULONG       ErrCode,
        ULONG       BytesTransferred,
        PNH_BUFFER  Bufferp
        );



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\myalg.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// MyAlg.cpp : Implementation of DLL Exports.
//
// Sanjiv
// JPDup
//

#include "PreComp.h"

#include "MyAlg.h"


CControlObjectList              g_ControlObjectList;
IApplicationGatewayServices*    g_pIAlgServicesAlgFTP = NULL;
USHORT                          g_nFtpPort=0;
HANDLE                          g_hNoMorePendingConnection=NULL;
bool                            g_bStoping = false;

//
//  got to move WSAStartup to Initialize
//
CAlgFTP::CAlgFTP ()
{
    MYTRACE_ENTER("CAlgFTP::CAlgFTP ");

    m_ListenAddress = 0;
    m_ListenPort = 0;
    m_ListenSocket = INVALID_SOCKET;
    m_pPrimaryControlChannel = NULL;
    m_hNoMoreAccept = NULL;
    g_bStoping = false;
    

    WSADATA wsaData;
    DWORD Err;
    Err = WSAStartup(MAKEWORD(2,2),&wsaData);
    _ASSERT(Err == 0);

    MyHelperInitializeBufferManagement();
}



//
// Destructor
//
CAlgFTP ::~CAlgFTP ()
{
    MYTRACE_ENTER("CAlgFTP::~CAlgFTP ");


    if ( g_pIAlgServicesAlgFTP ) 
    {
        MYTRACE("Releasing AlgServices");
        g_pIAlgServicesAlgFTP->Release();
        g_pIAlgServicesAlgFTP = NULL;
    }


    if ( g_hNoMorePendingConnection )
    {
        CloseHandle(g_hNoMorePendingConnection);
        g_hNoMorePendingConnection = NULL;
    }

    if ( m_hNoMoreAccept )
    {
        CloseHandle(m_hNoMoreAccept);
        m_hNoMoreAccept = NULL;
    }

   

    WSACleanup();
    MyHelperShutdownBufferManagement();
}


//
//  Initialize can be called in two cases
//  1. From the main IApplicationGateway::Initialize
//  2. From AcceptCompletionRoutine when some FatalSocket Error has occured, which forced the
//     closure of the m_ListenSocket and all the control connections/data connections etc.
//     (This call to ShutDown will terminate all current ControlSessions. Might not be necessary.
//     But if AcceptCompletion returned error we do it anyway.)
//
STDMETHODIMP  
CAlgFTP ::Initialize(
    IApplicationGatewayServices * pAlgServices
    )
{
    MYTRACE_ENTER("CAlgFTP::Initialize");
   
    pAlgServices->AddRef();
    g_pIAlgServicesAlgFTP = pAlgServices;
    
    if ( FAILED(GetFtpPortToUse(g_nFtpPort)) )
        g_nFtpPort = 21;    // Use the standard ftp port 21

    MYTRACE("USING FTP PORT %d", g_nFtpPort);


    HRESULT hr = RedirectToMyPort();

    if ( FAILED(hr) )
        CleanUp();

    return hr;
}




//
//  ALG.exe will call this interface to terminat
//  this ALG FTP PlugIn
//      
STDMETHODIMP
CAlgFTP::Stop()
{
    MYTRACE_ENTER("CAlgFTP::Stop");
    
    CleanUp();

    return S_OK;
}


#define REG_KEY_ALG_FTP     TEXT("SOFTWARE\\Microsoft\\ALG\\ISV\\{6E590D61-F6BC-4dad-AC21-7DC40D304059}")
#define REG_VALUE_FTP_PORT  TEXT("UsePort")

HRESULT
CAlgFTP::GetFtpPortToUse(
    USHORT& usPort
    )
{
    MYTRACE_ENTER("CAlgFTP:GetFtpPortToUse");

    DWORD dwPort = 0;

    //
    // Did you modify the default FTP Port
    //
    LONG lRet;
    CRegKey RegKeyAlgFTP;

    MYTRACE("Looking in RegKey \"%S\"", REG_KEY_ALG_FTP);

    lRet = RegKeyAlgFTP.Open(HKEY_LOCAL_MACHINE, REG_KEY_ALG_FTP, KEY_READ);
    if ( ERROR_SUCCESS == lRet )
    {
        LONG lRet = RegKeyAlgFTP.QueryValue(dwPort, REG_VALUE_FTP_PORT);

        if ( ERROR_SUCCESS == lRet )
        {   
            MYTRACE("Found the \"%S\" value %d", REG_VALUE_FTP_PORT, dwPort);
            usPort = (USHORT) dwPort;
        }
        else
        {
            MYTRACE("\"%S\" Value not set", REG_VALUE_FTP_PORT);
            return E_FAIL;
        }
    }
    else
    {
        MYTRACE("Could not open regkey", lRet);
        return E_FAIL;
    }   

    return S_OK;
}


extern CComAutoCriticalSection         m_AutoCS_FtpIO;  // See FtpControl.cpp


//
//
//
void
CAlgFTP::CleanUp()
{
    MYTRACE_ENTER("CAlgFTP::CleanUp()");

    g_bStoping = true;

    //
    // Free socket
    //
    if ( INVALID_SOCKET != m_ListenSocket ) 
    {
        MYTRACE("CAlgFTP::STOP ACCEPTING NEW CONNECTION !!");

        m_AutoCS_FtpIO.Lock();

        m_hNoMoreAccept = CreateEvent(NULL, false, false, NULL);

        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;


        m_AutoCS_FtpIO.Unlock();

        if ( m_hNoMoreAccept )
        {
            WaitForSingleObject(
                m_hNoMoreAccept,
                INFINITE
                );
        }
    }	



    if ( m_pPrimaryControlChannel ) 
    {
        MYTRACE("Cancelling PrimaryControl");
        HRESULT hr = m_pPrimaryControlChannel->Cancel();
        
        MYTRACE("Releasing Primary");
        m_pPrimaryControlChannel->Release();
        m_pPrimaryControlChannel = NULL;
    }

    m_AutoCS_FtpIO.Lock();
  
    if ( g_ControlObjectList.m_NumElements == 0 )
    {
        MYTRACE("List for FTPconnections is empty");
        m_AutoCS_FtpIO.Unlock();
    }   
    else
    {
        //
        // Pending connection are still active
        // shut them down a wait till the last one is free
        //

        MYTRACE("Empty the list of FTPconnections (%d)", g_ControlObjectList.m_NumElements);
        g_hNoMorePendingConnection = CreateEvent(NULL, false, false, NULL);

        MYTRACE("Closing all connections");
        g_ControlObjectList.ShutdownAll();  



        m_AutoCS_FtpIO.Unlock();
    
        MYTRACE("Waiting for last connection to notify us");
        WaitForSingleObject(
            g_hNoMorePendingConnection,
            2000    // Will give them 2 second max to close  vs using INFINITE
            );

        MYTRACE("Got signal no more pending connection");
    }

}



/*
  We have this private function to get the OriginalDestionationInfo  
  and to get the type of connection it is. Whether it is INCOMING or OUTGOING.
*/
HRESULT 
CAlgFTP::MyGetOriginalDestinationInfo(
    PUCHAR              AcceptBuffer,
    ULONG*              pAddr,
    USHORT*             pPort,
    CONNECTION_TYPE*    pConnType
    )
{
    MYTRACE_ENTER("CAlgFTP::MyGetOriginalDestinationInfo");

    IAdapterInfo *pAdapterInfo = NULL;
    HRESULT hr = S_OK;
    ULONG RemoteAddr = 0;
    USHORT RemotePort = 0;
    ALG_ADAPTER_TYPE Type;

    
    MyHelperQueryAcceptEndpoints(
        AcceptBuffer,
        0,
        0,
        &RemoteAddr,
        &RemotePort
        );

    MYTRACE("Source Address %s:%d", MYTRACE_IP(RemoteAddr), ntohs(RemotePort));

    hr = m_pPrimaryControlChannel->GetOriginalDestinationInformation(
        RemoteAddr,
        RemotePort,
        pAddr,
        pPort,
        &pAdapterInfo
        );


    if ( SUCCEEDED(hr) ) 
    {
        hr = pAdapterInfo->GetAdapterType(&Type);

        if (SUCCEEDED(hr) ) 
        {
            ULONG   ulAddressCount;
            ULONG*  arAddresses;
        
            hr = pAdapterInfo->GetAdapterAddresses(&ulAddressCount, &arAddresses);

            if ( SUCCEEDED(hr) )
            {
                if ( ulAddressCount > 0 )
                {
                    bool bFromIcsBox = FALSE;
                    while (ulAddressCount && !bFromIcsBox) 
                    {
                       if (arAddresses[--ulAddressCount] == RemoteAddr)
                           bFromIcsBox = TRUE;
                    }
                    
                    MYTRACE("Address count %d  address[0] %s", ulAddressCount, MYTRACE_IP(arAddresses[0]));
                    
                    switch (Type) 
                    {
                    case eALG_PRIVATE:
                        MYTRACE("Adapter is Private");
                        if ( bFromIcsBox )
                        {
                            *pConnType = INCOMING;
                            MYTRACE("InComing");
                        }
                        else
                        {
                            *pConnType = OUTGOING;
                            MYTRACE("OutGoing");
                        }
                        break;
                        
                    
                    case eALG_BOUNDARY:
                    case eALG_FIREWALLED:
                    case eALG_BOUNDARY|eALG_FIREWALLED:

                        MYTRACE("Adapter is Public or/and Firewalled");
    
                        if ( bFromIcsBox )
                        {
                            *pConnType = OUTGOING;
                            MYTRACE("OutGoing");
                        }
                        else
                        {
                            *pConnType = INCOMING;
                            MYTRACE("InComing");
                        }
                        break;
                        
                       
                        
                    default:     
                        MYTRACE("Adapter is ????");
                        _ASSERT(FALSE);
                        hr = E_FAIL;
                        break;
                    }
                }

                CoTaskMemFree(arAddresses);
            }
        }

        pAdapterInfo->Release();

    }
	else
	{
		MYTRACE_ERROR("from GetOriginalDestinationInformation", hr);
	}
	




    return hr;
}








/*
  Can be called in 2 cases.
  1. AcceptEx has actually succeeded or failed
     If Succeeded we make a new CFtpControlConnection giving it the AcceptedSocket
       And reissue the Accept
     If Failed and not fatal failure we just reissue the Accept
     If Failed and Fatal Failure we ShutDown gracefully. Restart the a new listen

  2. Because we closed the listening socket in STOP => ErrCode = ERROR_IO_CANCELLED
      in which case we just return
*/

void 
CAlgFTP::AcceptCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    MYTRACE_ENTER("CAlgFTP::AcceptCompletionRoutine");


#if defined(DBG) || defined(_DEBUG)
    if ( 0 != ErrCode )
    {
        MYTRACE("ErrCode : %x", ErrCode);
        MYTRACE("MyHelperIsFatalSocketError(ErrCode) is %d", MyHelperIsFatalSocketError(ErrCode));
    }
#endif

    ULONG           OriginalAddress = 0;
    USHORT          OriginalPort = 0;
    CONNECTION_TYPE ConnType;  
    HRESULT         hr;
    ULONG           Err;


    if ( ERROR_IO_CANCELLED == ErrCode  || g_bStoping ) 
    {
        MYTRACE("CAlgFTP::AcceptCompletionRoutine-ERROR_IO_CANCELLED");

        //
        // Ok we are closing here MyAlg->Stop got called
        // no need to attemp a new Listen/Accept incoming
        //
        MYTRACE("------NORMAL TERMINATION (not creating a new listen/accept)-----");

        MyHelperReleaseBuffer(Bufferp);

        if ( m_hNoMoreAccept )
            SetEvent(m_hNoMoreAccept);

        return; // Normal termination
    }


    SOCKET AcceptedSocket = Bufferp->Socket;

    if ( ErrCode && MyHelperIsFatalSocketError(ErrCode) ) 
    {
        MYTRACE_ERROR("CAlgFTP::AcceptCompletionRoutine-FATAL ERROR", ErrCode);


        //
        // Socket Routines says that we have a problem
        // so clean up and try a new redirection
        //

        
        if ( AcceptedSocket != INVALID_SOCKET ) 
        {
            MYTRACE("CLOSING ACCEPTED SOCKET!!");
            closesocket(AcceptedSocket);      
        }

        hr = RedirectToMyPort();

        MyHelperReleaseBuffer(Bufferp);
        return;
    }



    if ( 0 == ErrCode ) 
    {    

        //
        // Everything is good lets accept the connection
        //
        hr = MyGetOriginalDestinationInfo(Bufferp->Buffer,&OriginalAddress,&OriginalPort,&ConnType);
 
        if ( SUCCEEDED(hr) ) 
        {  
            Err = setsockopt(
                AcceptedSocket,
                SOL_SOCKET,
                SO_UPDATE_ACCEPT_CONTEXT,
                (char *)&m_ListenSocket,
                sizeof(m_ListenSocket)
                );
 
            MYTRACE("setsockopt SO_UPDATE_ACCEPT_CONTEXT %x", Err);
            CFtpControlConnection *pFtpControlConnection = new CFtpControlConnection;

            if ( pFtpControlConnection )
            {
                hr = pFtpControlConnection->Init(
                    AcceptedSocket,
                    OriginalAddress,
                    OriginalPort,
                    ConnType
                    );
  
                if ( SUCCEEDED(hr) )
                {
                    g_ControlObjectList.Insert(pFtpControlConnection);
                }
                else
                {
                    MYTRACE_ERROR("pFtpControlConnection->Init failed", hr);
        
                    // No need to close at this time the closesocket(AcceptedSocket);
                    // when the Init fails it will deref the newly created CFtpControlConnection 
                    // and will hit ZERO ref count and close the socket
                }
            }
            else
            {
                MYTRACE_ERROR("memory low, new pFtpControlConnection failed - CLOSING ACCEPTED SOCKET!!", 0);
            
                if ( AcceptedSocket != INVALID_SOCKET ) 
                    closesocket(AcceptedSocket);
            }
        }
        else 
        {
            MYTRACE_ERROR("MyGetOriginalDestinationInfo failed - CLOSING ACCEPTED SOCKET!!", hr);
    
            if ( AcceptedSocket != INVALID_SOCKET ) 
                closesocket(AcceptedSocket);
        }

        AcceptedSocket = INVALID_SOCKET;      

   }


    Err = MyHelperAcceptStreamSocket(
        NULL,
        m_ListenSocket,
        AcceptedSocket,
        Bufferp,
        MyAcceptCompletion,
        (void *)this,
        NULL
        );  

    if ( Err )  
    {
        MYTRACE_ERROR("From MyHelperAcceptStreamSocket", Err);


        if ( AcceptedSocket != INVALID_SOCKET ) 
        {
            MYTRACE("CLOSING ACCEPTED SOCKET!!");
            closesocket(AcceptedSocket);      
            AcceptedSocket = INVALID_SOCKET;
        }
        

        RedirectToMyPort();
        MyHelperReleaseBuffer(Bufferp);

    }


    return;
}






//
//  called From InitCAlgFTP
//  Will just create a socket bound to LOOP BACK adapter.
//
ULONG 
CAlgFTP::MakeListenerSocket()
{
    MYTRACE_ENTER("CAlgFTP::MakeListenerSocket");


    if ( INVALID_SOCKET != m_ListenSocket )
    {
        //
        // Since this function is call on the starting point (See Initialize)
        // and also when a Accept error occured and needs a new redirect
        // we may already have a Socket created so let's free it 
        //
        MYTRACE ("Remove current ListenSocket");
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
    }

    ULONG Err;

    ULONG Addr = inet_addr("127.0.0.1");
    Err = MyHelperCreateStreamSocket(Addr,0,&m_ListenSocket);

    if ( ERROR_SUCCESS == Err ) 
    {
        Err = MyHelperQueryLocalEndpointSocket(m_ListenSocket,&m_ListenAddress,&m_ListenPort);
        MYTRACE ("Listen on %s:%d", MYTRACE_IP(m_ListenAddress), ntohs(m_ListenPort));
    }
    else
    {
        MYTRACE_ERROR("MyHelperCreateStreamSocket", Err);
    }

    _ASSERT(Err == 0);

    return Err;
}



//
// Redirect trafic destinated for PORT FTP_CONTROL_PORT(21) 
// to our listening socket (127.0.0.1) port (Allocated by MakeListenerSocket())
//
ULONG 
CAlgFTP::RedirectToMyPort()
{
    MYTRACE_ENTER("CAlgFTP::RedirectToMyPort()");


    if ( ERROR_SUCCESS == MakeListenerSocket() ) 
    {
        if ( m_pPrimaryControlChannel )
        {
            //
            // Since this function is call on the starting point (See Initialize)
            // and also when a Accept error occured and needs a new redirect
            // we may already have a PrimaryControlChannel created so let's free it 
            //
            MYTRACE("Releasing PrimaryControl");
            m_pPrimaryControlChannel->Cancel();
            m_pPrimaryControlChannel->Release();
            m_pPrimaryControlChannel = NULL;
        }

        //
        // ask for a redirection
        //
        HRESULT hr = g_pIAlgServicesAlgFTP->CreatePrimaryControlChannel(
            eALG_TCP,
            htons(g_nFtpPort),    // 21 is the most common one
            eALG_DESTINATION_CAPTURE,
            TRUE,
            m_ListenAddress,
            m_ListenPort,
            &m_pPrimaryControlChannel
            );

        if ( SUCCEEDED(hr) )
        {

            //
            // Start listening
            //
            int nRetCode = listen( m_ListenSocket, 5);

            if ( SOCKET_ERROR != nRetCode )
            {

                ULONG Err = MyHelperAcceptStreamSocket(
                    NULL,
                    m_ListenSocket,
                    INVALID_SOCKET,
                    NULL,
                    MyAcceptCompletion,
                    (void *)this,NULL
                    );    

                if ( ERROR_SUCCESS == Err )
                {
                    return S_OK;
                }
                else
                {
                    MYTRACE_ERROR("FAILED TO START ACCEPT on 127.0.0.1:", Err);
                }
            }
            else
            {
                MYTRACE_ERROR("listen() failed ", nRetCode);
            }
        }
        else
        {
            MYTRACE_ERROR("from CreatePrimaryControlChannel", hr);

        }

    }


    //
    // if we got here that mean that one of the step above faild
    // 
    MYTRACE_ERROR("Failed to RedirectToPort",E_FAIL)
    CleanUp();

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\regevent.h ===
#ifndef __REGEVENT_H
#define __REGEVENT_H

typedef VOID (*EVENT_CALLBACK)(BOOLEAN TimerOrWait,VOID *Context,VOID *Context2);
HANDLE
NhRegisterEvent(HANDLE hEvent,EVENT_CALLBACK CallBack,VOID *Context,VOID *Context2,ULONG TimeOut);
/*
  VOID
  NhInitializeCallBack(VOID);
  
  VOID
  NhShutdownCallBack(VOID);
*/

VOID
NhUnRegisterEvent(HANDLE WaitHandle);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\regevent.cpp ===
#include "precomp.h"
#include "list.h"


CRegisteredEventList g_RegisteredEventList;

VOID
NhInitializeCallBack(VOID) 
{
    return;
}

//
//
//
VOID
NhUnRegisterEvent(HANDLE WaitHandle)
{
  HANDLE hEvent;
  UnregisterWaitEx(WaitHandle,INVALID_HANDLE_VALUE);
  g_RegisteredEventList.Remove(WaitHandle,&hEvent);
  CloseHandle(hEvent);
  return;
}


//
//
//
VOID
NhEventCallBackFunction(
    PVOID   Context,
	BOOLEAN TimerOrWait
    )
{
  HANDLE hEvent = (HANDLE)Context;
  HANDLE WaitHandle;
  VOID *Context1;
  VOID *Context2;
  EVENT_CALLBACK CallBack;
  g_RegisteredEventList.Remove(&WaitHandle,hEvent,&CallBack,&Context1,&Context2);
  CloseHandle(hEvent);
  (*CallBack)(TimerOrWait,Context1,Context2);
  return;
}


//
//
//
HANDLE
NhRegisterEvent(
    HANDLE          hEvent,
    EVENT_CALLBACK  CallBack,
    VOID*           Context,
    VOID*           Context2,
    ULONG           TimeOut
    )
{
  VOID *nContext;
  HANDLE WaitHandle = NULL;
  BOOL Err;
  Err = RegisterWaitForSingleObject(&WaitHandle,hEvent,NhEventCallBackFunction,(PVOID)hEvent,TimeOut,
				    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE);
  if (Err)
      g_RegisteredEventList.Insert(WaitHandle,hEvent,CallBack,Context,Context2);  
  else
      WaitHandle = NULL;

  return WaitHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "ALG FTP proxy"
#define VER_INTERNALNAME_STR            "ALG_FTP.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\socket.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains code for socket-management.
    The routines provided generally follow the same asynchronous model
    using a completion routine that is invoked in the context of
    a callback thread.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

--*/

#include "precomp.h"
#pragma hdrstop


#include <stdio.h>

extern bool g_bStoping;

#if DBG
ULONG MyHelperpReadCount = 0;
#endif



ULONG UnusedBytesTransferred;

typedef struct _NH_CONNECT_BUFFER {
    HANDLE Event;
    HANDLE WaitHandle;
} NH_CONNECT_BUFFER, *PNH_CONNECT_BUFFER;

//
// FORWARD DECLARATIONS
//


VOID NTAPI
MyHelperpConnectCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

VOID WINAPI
MyHelperpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    );

VOID APIENTRY
MyHelperpIoWorkerRoutine(
    PVOID Context
    );


ULONG
MyHelperAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to accept an incoming connection-request
    on a listening stream socket using 'AcceptEx'. The I/O system invokes
    the provided 'CompletionRoutine' upon completion of the read.

    It is the completion-routine's responsibility to use 'setsockopt' to
    set the SO_UPDATE_ACCEPT_CONTEXT option on the accepted socket before
    the accepted socket can be used with Winsock2 routines.

    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    ListeningSocket - the endpoint that is listening for connection-requests

    AcceptedSocket - the endpoint to be assigned a connection-request,
        or INVALID_SOCKET to create a new endpoint

    Bufferp - the buffer to be used for asynchronous completion
        or NULL to acquire a new buffer

    AcceptCompletionRoutine - the routine to be invoked upon completion

    Context - the context to be associated with the accept-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the accept-completion routine
    will be invoked.
    Conversely, a failure code is a guarantee that the routine will not
    be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    SOCKET LocalSocket = INVALID_SOCKET;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = MyHelperAcquireBuffer();
        if (!Bufferp) {
            //MyHelperTrace(TRACE_FLAG_SOCKET, "error allocating buffer for accept");
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    
    if (AcceptedSocket == INVALID_SOCKET) {
        Error = MyHelperCreateStreamSocket(INADDR_NONE, 0, &LocalSocket);
        if (Error) {
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET, "error %d creating socket for accept", Error
            //);
            if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        AcceptedSocket = LocalSocket;
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = AcceptedSocket;
    Bufferp->CompletionRoutine = AcceptCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;


    if ( !g_bStoping && 
        AcceptEx(
            ListeningSocket,
            AcceptedSocket,
            Bufferp->Buffer,
            0,
            sizeof(SOCKADDR_IN) + 16,
            sizeof(SOCKADDR_IN) + 16,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            )) 
    {
        Error = NO_ERROR;
    } 
    else 
    {
        if ((Error = WSAGetLastError()) == ERROR_IO_PENDING) {
            Error = NO_ERROR;
        } else if (Error) {
            if (LocalSocket != INVALID_SOCKET) {
                MyHelperDeleteStreamSocket(LocalSocket);
            }
            if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET, "error %d returned by 'AcceptEx'", Error
            //);
        }
    }

    return Error;

} // MyHelperAcceptStreamSocket


ULONG
MyHelperConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to establish a connection using a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

    Since Windows Sockets does not deliver connect-notifications to
    I/O completion ports, we need to make some special arrangements in order
    to notify the caller's completion routine the way we do for send-requests
    and receive-requests. Specifically, we create an event-handle and
    request connect-notification on it by calling 'WSAEventSelect'.
    We then register a wait on the event-handle, specifying a private
    completion routine. (See 'MyHelperpConnectCallbackRoutine'.)
    When this completion routine runs, it extracts the status code of the
    connection-attempt using 'WSAEnumNetworkEvents'. It then passes the status
    along with the usual parameters to the caller's completion routine.


    N.B. The buffer supplied to this routine may not be released by 
    the connect-completion routine.
    (See 'MyHelperpConnectCallbackRoutine' for more information.)

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket with which to establish a connection

    Address - the IP address of the remote endpoint

    Port - the port number of the remote endpoint

    Bufferp - optionally supplies the buffer to be used to hold context
        during the connection-attempt

    ConnectCompletionRoutine - a routine to be invoked upon completion 
        of the connect-attempt

    Context - passed to the 'ConnectCompletionRoutine'

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code

    A success code is a guarantee that the connect-completion routine, 
    if supplied, will be invoked.
    Conversely, a failure code is a guarantee that the neither routine will
    be invoked.

--*/

{
    MYTRACE_ENTER("ALGFTP:MyHelperConnectStreamSocket");

    ULONG   nSourceAddress;
    USHORT  nSourcePort;
        
    MyHelperQueryLocalEndpointSocket(ConnectingSocket,&nSourceAddress,&nSourcePort);

    MYTRACE("From Source    %s:%d", MYTRACE_IP(nSourceAddress), ntohs(nSourcePort) );
    MYTRACE("To Destination %s:%d", MYTRACE_IP(Address), ntohs(Port) );
    



    PNH_CONNECT_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = MyHelperAcquireBuffer();
        if (!Bufferp) {
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET,
            //"MyHelperConnectStreamSocket: error allocating buffer for connect"
            //);
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socket = ConnectingSocket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = ConnectCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->ConnectAddress.sin_family = AF_INET;
    Bufferp->ConnectAddress.sin_addr.s_addr = Address;
    Bufferp->ConnectAddress.sin_port = Port;

    Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            MyHelperpConnectCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) {
        Error = GetLastError();
    } else {
        ULONG EventsSelected = FD_CONNECT;
        Error =
            WSAEventSelect(
                ConnectingSocket, Contextp->Event, EventsSelected
                );
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
        } else {
            Error =
                WSAConnect(
                    ConnectingSocket,
                    (PSOCKADDR)&Bufferp->ConnectAddress,
                    sizeof(Bufferp->ConnectAddress),
                    NULL,
                    NULL,
                    NULL,
                    NULL    
                    );
        }
    }

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSAEWOULDBLOCK) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }
        if (Contextp->Event) { CloseHandle(Contextp->Event); }
        if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // MyHelperConnectStreamSocket



ULONG
MyHelperCreateStreamSocket(
    ULONG Address OPTIONAL,
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is invoked to create and initialize a stream socket.
    The socket will also be bound to a local IP address and port,
    unless none is specified.

Arguments:

    Address - the local IP address to which the new socket should be bound,
        or INADDR_ANY to allow the system to leave the IP address unspecified,
        or INADDR_NONE if the socket should not be bound at all.

    Port - the port number to which the new socket should be bound,
        or 0 if to allow the system to select a port number.

    Socketp - receives initialized socket

Return Value:

    ULONG - Win32/Winsock2 status code.

--*/

{
    MYTRACE_ENTER("AlgFTP:MyHelperCreateStreamSocket");
    MYTRACE("Address %s:%d", MYTRACE_IP(Address), ntohs(Port));

    ULONG Error;
    ULONG Option;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new stream socket.
        //

        Socket =
            WSASocket(
                AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) 
        {
            Error = WSAGetLastError();
            MYTRACE_ERROR("from WSASocket", Error);
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        BindIoCompletionCallback((HANDLE)Socket, MyHelperpIoCompletionRoutine, 0);

        //
        // Disable send and receive buffering in AFD,
        // since we will be operating asynchronously with a receive-buffer
        // (almost) always outstanding, and since in any case we want
        // TCP/IP's flow-control to limit the sender's sending rate properly.
        //
	
        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );
        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );
	
        //
        // If the caller has requested that the socket be bound by specifying
        // a local IP address, bind the socket now.
        //
	
        if (Address != INADDR_NONE) {
            SocketAddress.sin_family = AF_INET;
            SocketAddress.sin_port = Port;
            SocketAddress.sin_addr.s_addr = Address;
            Error =
                bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));
            if (Error == SOCKET_ERROR) 
            {
                Error = WSAGetLastError();
                MYTRACE_ERROR("from BIND", Error);
                break;
            }
        }

        //
        // Store the new socket in the caller's output-parameter, and return.
        //

        *Socketp = Socket;
        return NO_ERROR;

    } while(FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;
} // MyHelperCreateStreamSocket


VOID
MyHelperDeleteSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine releases network resources for a socket.

Arguments:

    Socket - the socket to be deleted

Return Value:

    none.

--*/

{
    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
} // MyHelperDeleteSocket





VOID NTAPI
MyHelperpConnectCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked by upon completion of a connect-operation
    or upon closure of the connection by the remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when a connection-attempt is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CONNECT_BUFFER Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;
    
    
    
    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CONNECT', we unregister the wait if an error
    // occurred. 
    //
    // In essence, our goal is to guarantee that whatever the success
    // or failure or sequence of events on the socket, the connect-completion
    // routines will be called for the socket,
    //
    // N.B. routine is not allowed to release the connect-buffer,
    // since we will free it 
    //
    //

    Bufferp->BytesTransferred = 0;
    NetworkEvents.lNetworkEvents = 0;


    PNH_COMPLETION_ROUTINE CallbackConnectCompletion = Bufferp->CompletionRoutine;

    if ( CallbackConnectCompletion )
    {
        Bufferp->CompletionRoutine = NULL;


        if ( g_bStoping )
        {   
            Error = ERROR_OPERATION_ABORTED;
        }
        else
        {
            Error = WSAEnumNetworkEvents(Bufferp->Socket, Contextp->Event, &NetworkEvents);

            if ( Error ) 
            {
                //
                // We couldn't determine which events occurred on the socket,
                // so call the routines with errors, and fall through
                // to the cleanup code below.
                //
                Error = ERROR_OPERATION_ABORTED;
            } 
            else 
            {
                if ( NetworkEvents.lNetworkEvents & FD_CONNECT ) 
                {
                    Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];
                }
                else
                {

                    //
                    // Not sure what even was sent to US we only requested FD_CONNECT so treat this as an error
                    //
                    Error = ERROR_OPERATION_ABORTED;
                }
            }
        }

        //
        // We are about to call the User Completion routine
        // but to insure that the buffer is freed and that any event the 
        // CompletionRoutine generates (Shutdown the process) and we did not have time to free
        // we will free now and call
        //


        PNH_BUFFER pUserContext = (PNH_BUFFER)Bufferp->Context;

        UnregisterWait(Contextp->WaitHandle);
        CloseHandle(Contextp->Event);
        MyHelperReleaseBuffer(Bufferp);


        //
        // Now call the UserCallback routine
        //
        if ( CallbackConnectCompletion ) 
        {
            CallbackConnectCompletion(Error, 0, pUserContext);
        }

        
    }
    else
    {
        //
        // The completion routine was call and resource freed previously
        // and now we are getting a EVENT that we never solicitated.
        // 
    }
    

} // MyHelperpConnectCallbackRoutine


VOID
MyHelperpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    )

/*++

Routine Description:

    This routine is invoked by the I/O system upon completion of an operation.

Arguments:

    ErrorCode - system-supplied error code

    BytesTransferred - system-supplied byte-count

    Overlapped - caller-supplied context area

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread.

--*/

{
    PNH_BUFFER Bufferp = CONTAINING_RECORD(Overlapped, NH_BUFFER, Overlapped);
    
    Bufferp->ErrorCode = ErrorCode;
    Bufferp->BytesTransferred = BytesTransferred;
    Bufferp->CompletionRoutine(
        Bufferp->ErrorCode,
        Bufferp->BytesTransferred,
        Bufferp
        );  

} // MyHelperpIoCompletionRoutine


VOID APIENTRY
MyHelperpIoWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to continue processing of completed I/O
    in the context of an alertably waiting thread which does not exit idly.

Arguments:

    Context - holds the buffer associated with the completed I/O operation.

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL alertable worker thread.

--*/

{
    ((PNH_BUFFER)Context)->CompletionRoutine(
        ((PNH_BUFFER)Context)->ErrorCode,
        ((PNH_BUFFER)Context)->BytesTransferred,
        ((PNH_BUFFER)Context)
        );

} // MyHelperpIoWorkerRoutine


VOID
MyHelperQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    )
{
    PSOCKADDR_IN LocalSockAddr = NULL;
    ULONG LocalLength = sizeof(LocalSockAddr);
    PSOCKADDR_IN RemoteSockAddr = NULL;
    ULONG RemoteLength = sizeof(RemoteSockAddr);
    GetAcceptExSockaddrs(
        AcceptBuffer,
        0,
        sizeof(SOCKADDR_IN) + 16,
        sizeof(SOCKADDR_IN) + 16,
        (PSOCKADDR*)&LocalSockAddr,
        reinterpret_cast<LPINT>(&LocalLength),
        (PSOCKADDR*)&RemoteSockAddr,
        (LPINT)&RemoteLength
        );

    if (LocalAddress && LocalSockAddr) {
        *LocalAddress = LocalSockAddr->sin_addr.s_addr; 
    }
    if (LocalPort && LocalSockAddr) { 
        *LocalPort = LocalSockAddr->sin_port; 
    }
    if (RemoteAddress && RemoteSockAddr) { 
        *RemoteAddress = RemoteSockAddr->sin_addr.s_addr; 
    }
    if (RemotePort && RemoteSockAddr) { 
        *RemotePort = RemoteSockAddr->sin_port; 
    }

} // MyHelperQueryAcceptEndpoints


ULONG
MyHelperQueryAddressSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to retrieve the IP address associated with
    a socket.

Arguments:

    Socket - the socket to be queried

Return Value:

    ULONG - the IP address retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_addr.s_addr;
} // MyHelperQueryAddressSocket


ULONG
MyHelperQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getsockname(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // MyHelperQueryEndpointSocket


USHORT
MyHelperQueryPortSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine retrieves the port number to which a socket is bound.

Arguments:

    Socket - the socket to be queried

Return Value:

    USHORT - the port number retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_port;
} // MyHelperQueryPortSocket


ULONG
MyHelperQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getpeername(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // MyHelperQueryRemoteEndpointSocket



ULONG
MyHelperReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a stream socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer

    Length - the maximum number of bytes to be read

    Offset - the offset into the buffer at which the read should begin,
        valid only if 'Bufferp' is provided.

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }
    
    if (!Bufferp) {
        Offset = 0;
        Bufferp = LocalBufferp = MyHelperAcquireVariableLengthBuffer(Length);
        if (!Bufferp) {
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET,
            //"MyHelperReadStreamSocket: error allocating buffer for receive"
            //);
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (ReadFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperReadStreamSocket: error %d returned by 'ReadFile'", Error
        //);
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSARecv(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            &Bufferp->ReceiveFlags,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperReadStreamSocket: error %d returned by 'WSARecv'", Error
        //);
    }
#endif

    return Error;

} // MyHelperReadStreamSocket



ULONG
MyHelperWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    Offset - the offset into the buffer at which the data to be sent begins

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (WriteFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperWriteStreamSocket: error %d returned by 'WriteFile'", Error
        //);
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSASend(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            0,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperWriteStreamSocket: error %d returned by 'WSASend'", Error
        //);
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#endif

    return Error;

} // MyHelperWriteStreamSocket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\socket.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations for socket-management.
    The routines declared here operate asynchronously on sockets
    associated with an I/O completion port. They are also integrated
    with the component-reference object, which may optionally be used
    by callers to control the number of outstanding entries into a component's
    address-space. 

    This module contains declarations for maintaining reference-count
    on a component. It provides an asynchronous thread-safe means of
    handling cleanup in a module.

    The mechanism defined uses a locked reference count and cleanup-routine
    to manage the lifetime of the component. When the reference-count
    is dropped to zero, the associated cleanup-routine is invoked.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

--*/


#pragma once


typedef VOID (*PCOMPONENT_CLEANUP_ROUTINE)(VOID);



//
// Structure:   COMPONENT_REFERENCE
//
// This structure must reside in memory for the lifetime of the component
// to which it refers. It is used to synchronize the component's execution.
//

typedef struct _COMPONENT_REFERENCE 
{
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    BOOLEAN Deleted;
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine;
#if COMPREF_TRACKING
    struct _COMPREF_RECORD* RecordArray;
    ULONG RecordIndex;
#endif

} COMPONENT_REFERENCE, *PCOMPONENT_REFERENCE;



#if COMPREF_TRACKING
#define COMPREF_RECORD_COUNT    (1024)

typedef struct _COMPREF_RECORD 
{
    PCHAR File;
    USHORT Line;
    UCHAR ReferenceCount;
    enum 
    {
        ComprefAcquireRecord,
        ComprefReleaseRecord
    } Type;

} COMPREF_RECORD, *PCOMPREF_RECORD;

#endif


//
// FUNCTION DECLARATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    );

#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    );
#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

//
// MACRO DECLARATIONS
//

#define RETURN_VOID

#if COMPREF_TRACKING

#define REFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)

#define DEREFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord); \
    return retcode

#else

#define REFERENCE_COMPONENT(c) \
    AcquireComponentReference(c)

#define DEREFERENCE_COMPONENT(c) \
    ReleaseComponentReference(c)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!AcquireComponentReference(c)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    ReleaseComponentReference(c); return retcode

#endif


//
// INLINE ROUTINE IMPLEMENTATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    ++ComponentReference->ReferenceCount;
    LeaveCriticalSection(&ComponentReference->Lock);
    return TRUE;

} // AcquireComponentReference


VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the last reference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/

{
    DeleteCriticalSection(&ComponentReference->Lock);
#if COMPREF_TRACKING
    HeapFree(GetProcessHeap(), 0, ComponentReference->RecordArray);
#endif

} // DeleteComponentReference


ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    )

/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/

{
    __try {
        InitializeCriticalSection(&ComponentReference->Lock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    ComponentReference->Deleted = FALSE;
    ComponentReference->ReferenceCount = 1;
    ComponentReference->CleanupRoutine = CleanupRoutine;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ComponentReference->RecordArray =
        HeapAlloc(
            GetProcessHeap(), 0, sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
            );
#endif
    return NO_ERROR;

} // InitializeComponentReference



#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    )
{
    BOOLEAN Success;
    ULONG i = InterlockedIncrement(&ComponentReference->RecordIndex);
    i %= COMPREF_RECORD_COUNT;
    ComponentReference->RecordArray[i].File = File;
    ComponentReference->RecordArray[i].Line = (USHORT)Line;
    ComponentReference->RecordArray[i].Type = Type;
    if (Type == ComprefAcquireRecord) {
        Success = AcquireComponentReference(ComponentReference);
    } else {
        Success = ReleaseComponentReference(ComponentReference);
    }
    ComponentReference->RecordArray[i].ReferenceCount =
        (UCHAR)ComponentReference->ReferenceCount;
    return Success;
}

#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseComponentReference


__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return TRUE;
    }
    ComponentReference->Deleted = TRUE;
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseInitialComponentReference




__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    ComponentReference->ReferenceCount = 1;
    ComponentReference->Deleted = FALSE;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ZeroMemory(
        ComponentReference->RecordArray,
        sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
        );
#endif
    LeaveCriticalSection(&ComponentReference->Lock);
} // ReleaseComponentReference





#ifndef _NATHLP_SOCKET_H_
#define _NATHLP_SOCKET_H_






ULONG
MyHelperAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
MyHelperConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PVOID Context,
    PVOID Context2
    );


ULONG
MyHelperCreateStreamSocket(
    ULONG Address OPTIONAL, // may be INADDR_NONE
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    );


#define MyHelperDeleteStreamSocket(s) MyHelperDeleteSocket(s)

VOID
MyHelperDeleteSocket(
    SOCKET Socket
    );

//
// BOOLEAN
// MyHelperIsFatalSocketError(
//     ULONG Error
//     );
//
// Determines whether a request may be reissued on a socket,
// given the error-code from the previous issuance of the request.
// This macro is arranged to branch on the most common error-codes first.
//

#define \
MyHelperIsFatalSocketError( \
    _Error \
    ) \
    ((_Error) != ERROR_OPERATION_ABORTED && \
    ((_Error) == WSAEDISCON || \
     (_Error) == WSAECONNRESET || \
     (_Error) == WSAETIMEDOUT || \
     (_Error) == WSAENETDOWN || \
     (_Error) == WSAENOTSOCK || \
     (_Error) == WSAESHUTDOWN || \
     (_Error) == WSAECONNABORTED))


VOID
MyHelperQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    );

ULONG
MyHelperQueryAddressSocket(
    SOCKET Socket
    );

ULONG
MyHelperQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );

USHORT
MyHelperQueryPortSocket(
    SOCKET Socket
    );

ULONG
MyHelperQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );


ULONG
MyHelperReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );


ULONG
MyHelperWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

#endif // _NATHLP_SOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\alg_ftp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ALG_TEST.rc
//
#define IDS_PROJNAME                    100
#define IDR_MYALG                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\adapterinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CAdapterInfo
//
// AdapterInfo.cpp : Implementation of CAdapterInfo
//

#include "PreComp.h"
#include "AdapterInfo.h"



//
//
//
STDMETHODIMP 
CAdapterInfo::GetAdapterIndex(
    ULONG*  pulAdapterIndex
    )
{
	*pulAdapterIndex = m_nAdapterIndex;

	return S_OK;
}


//
//
//
STDMETHODIMP 
CAdapterInfo::GetAdapterType(
    ALG_ADAPTER_TYPE*   pAdapterType
    )
{
	*pAdapterType = (ALG_ADAPTER_TYPE )m_eType;

	return S_OK;
}



//
//
//
STDMETHODIMP 
CAdapterInfo::GetAdapterAddresses(
    ULONG*  pulAddressCount, 
    ULONG** prgAddresses
    )
{
	*pulAddressCount = m_nAddressCount;

    *prgAddresses = (ULONG*)CoTaskMemAlloc(m_nAddressCount*sizeof(ULONG));

    if ( *prgAddresses == NULL )
        return ERROR_OUTOFMEMORY;

    memcpy(*prgAddresses,  m_anAddress, m_nAddressCount*sizeof(ULONG));

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\algcontroller.h ===
// AlgController.h : Declaration of the CAlgController

#pragma once

#include "resource.h"       // main symbols


#include "ApplicationGatewayServices.h"

#include "CollectionAdapters.h"
#include "CollectionAlgModules.h"



/////////////////////////////////////////////////////////////////////////////
// CAlgController
class ATL_NO_VTABLE CAlgController : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAlgController, &CLSID_AlgController>,
    public IAlgController
{

//
// Constructors & Destructor
//
public:

    CAlgController()
    { 
        MYTRACE_ENTER_NOSHOWEXIT("CAlgController()");
        HRESULT hr;

        m_pINat         = NULL;
        m_pIAlgServices = NULL;
    }

    ~CAlgController()
    {
        MYTRACE_ENTER_NOSHOWEXIT("~CAlgController()");
    }


//
// ATL COM helper macros
//

DECLARE_REGISTRY_RESOURCEID(IDR_ALGCONTROLLER)
DECLARE_NOT_AGGREGATABLE(CAlgController)


BEGIN_COM_MAP(CAlgController)
    COM_INTERFACE_ENTRY(IAlgController)
END_COM_MAP()


//
// IAlgController - COM Interface exposed methods
//
public:


    STDMETHODIMP    Start(
        IN  INat*   pINat
        );
    
    STDMETHODIMP    Stop();
    
    STDMETHODIMP    Adapter_Add(	
        IN  ULONG   nCookie,
        IN  short   Type
        );
    
    STDMETHODIMP    Adapter_Remove(
        IN ULONG    nCookie
        );
    
    STDMETHODIMP    Adapter_Modify(
        IN  ULONG   nCookie
        );
    
    STDMETHODIMP    Adapter_Bind(
        IN  ULONG   nCookie,
        IN  ULONG   nAdapterIndex,
        IN  ULONG   nAddressCount,
        IN  DWORD   anAdress[]
        );

    STDMETHODIMP    Adapter_PortMappingChanged(
        IN  ULONG   nCookie,
        IN  UCHAR   ucProtocol,
        IN  USHORT  usPort
        );
        

//
// Private internal methods
//
private:




public:

    //
    // Return the private interface to CComNAT
    //
    INat*  GetNat()
    {
        return m_pINat;
    }
    
    //
    // Load new ALG module that may have been added and unload any modules not configured anymore
    //
    void
    ConfigurationUpdated()
    {
        m_AlgModules.Refresh();
    }

    //
    //
    //
    void
    FreeResources()
    {
        //
        // Cleanup member before the scalar destruction is 
        // done on them because at that time the
        // two next intruction will have been done ant the two interface will be nuked
        //
        m_CollectionOfAdapters.RemoveAll();
        m_ControlChannelsPrimary.RemoveAll();
        m_ControlChannelsSecondary.RemoveAll();
        m_AdapterNotificationSinks.RemoveAll();


        //
        // Done with the public interface
        //
        if ( m_pIAlgServices )
        {
            m_pIAlgServices->Release();
            m_pIAlgServices = NULL;
        }

        //
        // Done with the private interface
        //
        if ( m_pINat )
        {
            m_pINat->Release();
            m_pINat = NULL;
        }

    }

//
// Properties
//
private:
    INat*                                       m_pINat;
    CCollectionAlgModules                       m_AlgModules;

    
public:

    
    IApplicationGatewayServices*                m_pIAlgServices;

    CCollectionAdapters                         m_CollectionOfAdapters;
    CCollectionAdapterNotifySinks               m_AdapterNotificationSinks;   

    CCollectionControlChannelsPrimary           m_ControlChannelsPrimary;
    CCollectionControlChannelsSecondary         m_ControlChannelsSecondary;
    
};






extern CAlgController*   g_pAlgController;    // This is a singleton created by IPNATHLP/NatALG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\algmodule.h ===
#pragma once

#include <Softpub.h>




//
// Holds information on the ALG module loaded
//
class CAlgModule
{

public:

    CAlgModule(
        LPCTSTR pszProgID,
        LPCTSTR pszFriendlyName
        )
    {
        lstrcpy(m_szID,             pszProgID);
        lstrcpy(m_szFriendlyName,   pszFriendlyName);

        m_pInterface=NULL;
    };


    ~CAlgModule()
    {
        Stop();
    }


//
// Methods
//
private:

    HRESULT
    ValidateDLL(
	    LPCTSTR pszPathAndFileNameOfDLL
	    );

public:

    HRESULT 
    Start();


    HRESULT
    Stop();

//
// Properties
//
public:

    TCHAR                   m_szID[MAX_PATH];
    TCHAR                   m_szFriendlyName[MAX_PATH];
    IApplicationGateway*    m_pInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\adapterinfo.h ===
// AdapterInfo.h : Declaration of the CAdapterInfo

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
//
// CAdapterInfo
//
class ATL_NO_VTABLE CAdapterInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAdapterInfo, &CLSID_AdapterInfo>,
	public IAdapterInfo
{
public:
	CAdapterInfo()
	{
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterInfo::NEW");
        m_nCookie       = 0;
        m_nAdapterIndex = 0;
        m_eType         = (ALG_ADAPTER_TYPE)0;
        m_nAddressCount = 0;
        m_bNotified     = false;    // Flag to see if a newly added adapter notified the user CallBack notification
                                    // This is used to only notify once the ALG plugin when the IP Address have been assign see CollectionAdapters.cpp
	}

	~CAdapterInfo()
	{
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterInfo::DELETE");
	}


 

DECLARE_REGISTRY_RESOURCEID(IDR_ADAPTERINFO)
DECLARE_NOT_AGGREGATABLE(CAdapterInfo)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAdapterInfo)
	COM_INTERFACE_ENTRY(IAdapterInfo)
END_COM_MAP()

//
// IAdapterInfo
//
public:
	STDMETHODIMP    GetAdapterAddresses(
        OUT ULONG*  pulAddressCount, 
        OUT ULONG** prgAddresses
        );

	STDMETHODIMP    GetAdapterType(
        OUT ALG_ADAPTER_TYPE* pAdapterType
        );

	STDMETHODIMP    GetAdapterIndex(
        OUT ULONG* pulIndex
        );

//
// Properties
//
public:
    ULONG               m_nCookie;
    ULONG               m_nAdapterIndex;
    ALG_ADAPTER_TYPE    m_eType;

    short               m_nAddressCount;
    DWORD               m_anAddress[65];
    DWORD               m_aMask[65];
    
    bool                m_bNotified;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\algcontroller.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    AlgController.cpp : Implementation of CAlgController

Abstract:

    This module contains routines for the ALG Manager module's 
    private interface to be used only by ICS see rmALG.cpp

Author:

    JPDup        10-Nov-2000

Revision History:

--*/

#include "PreComp.h"
#include "AlgController.h"






//
// Globals
//
CAlgController*      g_pAlgController=NULL;       // This is a singleton created by IPNATHLP/NatALG




//
// IPNATHLP is ready and is asking the ALG manager to do it's magic and load all the ISV ALGs
//
STDMETHODIMP 
CAlgController::Start(
    INat*   pINat
    )
{
    MYTRACE_ENTER("CAlgController::Start");


    if ( !pINat )
    {
        MYTRACE_ERROR("NULL pINat",0);
        return E_INVALIDARG;
    }

    //
    // Cache the INat interface that is given, will be used for the total life time of the ALG manager
    //
    m_pINat = pINat;
    m_pINat->AddRef();
    


    //
    // Create the one and only ALG Public interface will be passed to all ALG module that we host
    //
    HRESULT hr;

    CComObject<CApplicationGatewayServices>* pAlgServices;
    CComObject<CApplicationGatewayServices>::CreateInstance(&pAlgServices);
    hr = pAlgServices->QueryInterface(
        IID_IApplicationGatewayServices, 
        (void**)&m_pIAlgServices
        );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("CreateInstance(CApplicationGateway)", hr);
        return hr;
    }
    

    //
    // Cache the ApplicationGatewayService, other call like PrimaryControlChannel etc.. will refer to this singleton 
    //
    g_pAlgController = this;


    //
    // Load all the ALG's will return S_OK even if some ALG had problem loading
    //
    m_AlgModules.Load();

    return S_OK;

}





extern HANDLE  g_EventKeepAlive;

//
// CALL by IPNATHLP when the ICS/Firewall SharedAccess service is stoped
//
STDMETHODIMP 
CAlgController::Stop()
{
    MYTRACE_ENTER("CAlgController::Stop()")

    //
    // Release all ALG currently loaded
    //
    m_AlgModules.Unload();

    FreeResources();

    //
    // Let's stop 
    //
    MYTRACE("Next intruction will signale the g_EventKeepAlive");
    SetEvent(g_EventKeepAlive); // see ALG.cpp the WinMain is waiting on the event before exiting the process

    return S_OK;
}









//
// CComNAT will call this interface when a new adapter is reported
//
STDMETHODIMP 
CAlgController::Adapter_Add(
    IN    ULONG                nCookie,    // Internal handle to indentify the Adapter being added
    IN    short                nType
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Add")
    MYTRACE("Adapter Cookie %d Type %d", nCookie, nType);

    
#if defined(DBG) || defined(_DEBUG)

    if ( nType & eALG_PRIVATE )
        MYTRACE("eALG_PRIVATE ADAPTER");

    if ( nType & eALG_FIREWALLED )
        MYTRACE("eALG_FIREWALLED ADAPTER");

    if ( nType & eALG_BOUNDARY )
        MYTRACE("eALG_BOUNDARY ADAPTER");

#endif
    
    
    m_CollectionOfAdapters.Add(
        nCookie,
        nType
        );
    
    return S_OK;
}



//
// CComNAT will call this interface when a new adapter is Removed
//
STDMETHODIMP 
CAlgController::Adapter_Remove(
    IN    ULONG                nCookie     // Internal handle to indentify the Adapter being removed
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Remove")
    MYTRACE("Adapter nCookie %d", nCookie);
        
    m_CollectionOfAdapters.Remove(
        nCookie
        );

    return S_OK;
}




//
// CComNAT will call this interface when a new adapter is modified
//
STDMETHODIMP 
CAlgController::Adapter_Modify(
    IN    ULONG                nCookie     // Internal handle to indentify the Adapter being Modified
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Modify")
    MYTRACE("Adapter nCookie %d", nCookie);

    return S_OK;
}



 
//
// CComNAT will call this interface when a new adapter is modified
//
STDMETHODIMP 
CAlgController::Adapter_Bind(
    IN  ULONG    nCookie,                // Internal handle to indentify the Adapter being Bind
    IN  ULONG    nAdapterIndex,
    IN  ULONG    nAddressCount,
    IN  DWORD    anAddresses[]
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Bind")
    MYTRACE("Adapter nCookie(%d)=Index(%d), AddressCount %d Address[0] %s", nCookie, nAdapterIndex, nAddressCount, MYTRACE_IP(anAddresses[0]));

    m_CollectionOfAdapters.SetAddresses(
        nCookie, 
        nAdapterIndex, 
        nAddressCount, 
        anAddresses
        );

    return S_OK;
}

//
// CComNat will call this method when a port mapping is modified
//
STDMETHODIMP
CAlgController::Adapter_PortMappingChanged(
    IN  ULONG   nCookie,
    IN  UCHAR   ucProtocol,
    IN  USHORT  usPort
   )
{
    MYTRACE_ENTER("CAlgController::Adapter_PortMappingChanged");
    MYTRACE("Adapter Cookie %d, Protocol %d, Port %d", nCookie, ucProtocol, usPort);

    HRESULT hr =
        m_ControlChannelsPrimary.AdapterPortMappingChanged(
            nCookie,
            ucProtocol,
            usPort
            );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\algmodule.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    AlgModule.cpp

Abstract:

    Iplementation of the CAlgModule class

Author:

    JP Duplessis    (jpdup)  2000.01.19

Revision History:

--*/

#include "PreComp.h"
#include "AlgModule.h"
#include "AlgController.h"




//
// Validate and Load an ALG
//
HRESULT
CAlgModule::Start()
{
    MYTRACE_ENTER("CAlgModule::Start");
    MYTRACE("---------------------------------------------------");
    MYTRACE("ALG Module:\"%S\"", m_szFriendlyName);
    MYTRACE("CLSID is  :\"%S\"", m_szID);
    MYTRACE("---------------------------------------------------");

    //
    // Extract Full Path and File Name of DLL of the ISV ALG
    //
    CLSID    guidAlgToLoad;


    HRESULT hr = CLSIDFromString(
        CComBSTR(m_szID),    // ProgID
        &guidAlgToLoad        // Pointer to the CLSID
    );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Could not convert to CLSID", hr);
        return hr;
    }


    hr = CoCreateInstance(
        guidAlgToLoad, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IApplicationGateway, 
        (void**)&m_pInterface
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Error CoCreating", hr);
        return hr;
    }



    //
    // Start the ALG plug-in
    //
    try
    {
        
        hr = m_pInterface->Initialize(g_pAlgController->m_pIAlgServices);
        
    }
    catch(...)
    {
        MYTRACE_ERROR("Exception done by this ISV ALG Module", hr);
        return hr;
    }


    return S_OK;
}



//
//
//
HRESULT
CAlgModule::Stop()
{
    MYTRACE_ENTER("CAlgModule::Stop");

    HRESULT hr=E_FAIL;

    try
    {
        if ( m_pInterface )
        {
            hr = m_pInterface->Stop(); 

            LONG nRef = m_pInterface->Release();
            MYTRACE("************ REF is NOW %d", nRef);
            m_pInterface = NULL;
        }
    }
    catch(...)
    {
        MYTRACE_ERROR("TRY/CATCH on Stop", GetLastError());
    }

    return hr;
};





//
// Verify that the DLL has a valid signature
//
HRESULT
CAlgModule::ValidateDLL(
    LPCTSTR pszPathAndFileNameOfDLL
    )
{
/*
    MYTRACE_ENTER("CAlgModule::ValidateDLL");

    USES_CONVERSION;

    HRESULT hr=0;

    try
    {

        //
        // Used by WINTRUST_DATA
        //

        WINTRUST_FILE_INFO    FileInfo;

        FileInfo.cbStruct        = sizeof(WINTRUST_FILE_INFO);
        FileInfo.pcwszFilePath  = T2W((LPTSTR)pszPathAndFileNameOfDLL); //szFilePath;
        FileInfo.hFile            = INVALID_HANDLE_VALUE;
        FileInfo.pgKnownSubject    = NULL;



    
        WINTRUST_DATA TrustData;

        memset(&TrustData,0,sizeof(TrustData));
        TrustData.cbStruct                = sizeof(WINTRUST_DATA);
        TrustData.pPolicyCallbackData    = NULL;
        TrustData.pSIPClientData        = NULL;
        TrustData.dwUIChoice            = WTD_UI_NONE; //WTD_UI_ALL; //;
        TrustData.fdwRevocationChecks    = WTD_REVOKE_NONE;
        TrustData.dwUnionChoice            = WTD_CHOICE_FILE;
        TrustData.pFile                    = &FileInfo;
        TrustData.dwStateAction            = WTD_STATEACTION_IGNORE;
        TrustData.hWVTStateData            = NULL;
        TrustData.pwszURLReference        = NULL;
        TrustData.dwProvFlags            = WTD_USE_IE4_TRUST_FLAG;
        

        //
        // Win32 Verification
        //
        GUID ActionGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;

        hr =  WinVerifyTrust(
            GetDesktopWindow(), 
            &ActionGUID, 
            &TrustData
            );

        if ( SUCCEEDED(hr) )
        {
    //        MessageBox(NULL, TEXT("Valid ALG"), TEXT("ALG.EXE"), MB_OK|MB_SERVICE_NOTIFICATION);
        }
        else
        {
            MYTRACE("******************************");
            MYTRACE(" NOT SIGNED - %ws", pszPathAndFileNameOfDLL);
            MYTRACE("******************************");
        }
    }
    catch(...)
    {
        MYTRACE_ERROR("WinTrust exception", hr);
    }

    hr = S_OK;  // For the purpose of DEV for now we will always report OK

    return hr;
*/
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\applicationgatewayservices.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ApplicationGatewayServices.cpp : Implementation of CApplicationGatewayServices

Abstract:

    This module contains routines for the ALG Manager module's 
    that expose a public api via COM.

Author:

    Jon Burstein            
    Jean-Pierre Duplessis   

    JPDup            10-Nov-2000


Revision History:


--*/


/////////////////////////////////////////////////////////////////////////////
// CApplicationGatewayServices
//
// ApplicationGatewayServices.cpp : Implementation of CApplicationGatewayServices
//

#include "PreComp.h"
#include "AlgController.h"
#include "ApplicationGatewayServices.h"
#include "PendingProxyConnection.h"
#include "DataChannel.h"
#include "PersistentDataChannel.h"
#include "EnumAdapterInfo.h" 




STDMETHODIMP 
CApplicationGatewayServices::CreatePrimaryControlChannel(
    IN  ALG_PROTOCOL                eProtocol, 
    IN  USHORT                      usPortToCapture, 
    IN  ALG_CAPTURE                 eCaptureType, 
    IN  BOOL                        fCaptureInbound, 
    IN  ULONG                       ulListenAddress, 
    IN  USHORT                      usListenPort, 
    OUT IPrimaryControlChannel**    ppIControlChannel
    )
/*++

Routine Description:


Arguments:

    eProtocol, 
    usPortToCapture, 
    eCaptureType, 
    fCaptureInbound, 
    ulListenAddress, 
    usListenPort, 
    ppIControlChannel

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreatePrimaryControlChannel")
    MYTRACE("eProtocol          %s",    eProtocol==1? "TCP" : "UDP");
    MYTRACE("usPortToCapture    %d",    ntohs(usPortToCapture));
    MYTRACE("eCaptureType       %s",    eCaptureType==eALG_SOURCE_CAPTURE ? "eALG_SOURCE_CAPTURE" : "eALG_DESTINATION_CAPTURE");
    MYTRACE("fCaptureInbound    %d",    fCaptureInbound);
    MYTRACE("ulListenAddress    %s:%d", MYTRACE_IP(ulListenAddress), ntohs(usListenPort));


    if ( !ppIControlChannel )
    {
        MYTRACE_ERROR("ppIControlChannel not supplied",0);
        return E_INVALIDARG;
    }


    if ( eProtocol != eALG_TCP && eProtocol != eALG_UDP )
    {
        MYTRACE_ERROR("Arg - eProtocol",0);
        return E_INVALIDARG;
    }


    if ( eCaptureType == eALG_SOURCE_CAPTURE && fCaptureInbound )
    {
        MYTRACE_ERROR("Can not have SOURCE CAPTURE and fCaptureInBount at same time",0);
        return E_INVALIDARG;
    }


    HRESULT hr;

    //
    // Add new ControlChannel to List of RULES
    //
    CComObject<CPrimaryControlChannel>*   pIChannel;
    hr = CComObject<CPrimaryControlChannel>::CreateInstance(&pIChannel);
    

    if ( SUCCEEDED(hr) )
    {
        pIChannel->AddRef();

        pIChannel->m_Properties.eProtocol           = eProtocol;
        pIChannel->m_Properties.eCaptureType        = eCaptureType;
        pIChannel->m_Properties.fCaptureInbound     = fCaptureInbound;
        pIChannel->m_Properties.ulListeningAddress  = ulListenAddress;
        pIChannel->m_Properties.usCapturePort       = usPortToCapture;
        pIChannel->m_Properties.usListeningPort     = usListenPort;

        hr = pIChannel->QueryInterface(IID_IPrimaryControlChannel, (void**)ppIControlChannel);

        if ( SUCCEEDED(hr) )
        {
            hr = g_pAlgController->m_ControlChannelsPrimary.Add(pIChannel);    

            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("from m_ControlChannelsPrimary.Add", hr);

                (*ppIControlChannel)->Release();
                *ppIControlChannel = NULL;
            }
        }
        else
        {
            MYTRACE_ERROR("from pIChannel->QueryInterface", hr);
        }

        pIChannel->Release();
        
    }
    else
    {
        MYTRACE_ERROR("CreateInstance(&pIChannel);", hr);
    }


    return hr;
}





STDMETHODIMP 
CApplicationGatewayServices::CreateSecondaryControlChannel(
    IN  ALG_PROTOCOL                eProtocol,                  

    IN  ULONG                       ulPrivateAddress,    
    IN  USHORT                      usPrivatePort, 

    IN  ULONG                       ulPublicAddress, 
    IN  USHORT                      usPublicPort, 

    IN  ULONG                       ulRemoteAddress, 
    IN  USHORT                      usRemotePort, 

    IN  ULONG                       ulListenAddress, 
    IN  USHORT                      usListenPort, 

    IN  ALG_DIRECTION               eDirection, 
    IN  BOOL                        fPersistent, 
    OUT ISecondaryControlChannel**  ppIControlChannel
    )
/*++

Routine Description:


Arguments:

    eProtocol,
    ulPrivateAddress,    
    usPrivatePort, 
    ulPublicAddress, 
    usPublicPort, 
    ulRemoteAddress, 
    usRemotePort, 
    ulListenAddress, 
    usListenPort, 
    eDirection, 
    fPersistent, 
    ppIControlChannel


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreateSecondaryControlChannel");

    if ( !ppIControlChannel )
    {
        MYTRACE_ERROR("ppIControlChannel not supplied",0);
        return E_INVALIDARG;
    }

    
    ULONG   ulSourceAddress=0;
    USHORT  usSourcePort=0;

    ULONG   ulDestinationAddress=0;
    USHORT  usDestinationPort=0;

    ULONG   ulNewSourceAddress=0;
    USHORT  usNewSourcePort=0;

    ULONG   ulNewDestinationAddress=0;
    USHORT  usNewDestinationPort=0;

    ULONG   nFlags=0;

    ULONG   ulRestrictAdapterIndex=0;



    if ( eALG_INBOUND == eDirection )
    {
        if ( ulPublicAddress == 0 || usPublicPort == 0 )
        {
            //
            // Madatory arguments for INBOUND
            //
            MYTRACE_ERROR("ulPublicAddress == 0 || usPublicPort == 0", E_INVALIDARG);
            return E_INVALIDARG;
        }

        //
        // All inbound cases map to a single redirect; unlike a primary control channel, there's no need to create per-adapter redirects.
        //

        if ( ulRemoteAddress==0 && usRemotePort == 0 )
        {
            //
            // Scenario #1a
            //
            // Inbound connection from unknown machine
            //
            MYTRACE("SCENARIO:eALG_INBOUND #1a");

            nFlags                   = NatRedirectFlagReceiveOnly;

            ulSourceAddress          = 0;
            usSourcePort             = 0;

            ulDestinationAddress     = ulPublicAddress;
            usDestinationPort        = usPublicPort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort == 0 )
        {
            //
            // Scenario #1b
            //
            // Inbound connection from known machine, but unknown port
            //
            MYTRACE("SCENARIO:eALG_INBOUND #1b");
            nFlags                   = NatRedirectFlagReceiveOnly|NatRedirectFlagRestrictSource;

            ulSourceAddress          = ulRemoteAddress;
            usSourcePort             = 0;

            ulDestinationAddress     = ulPublicAddress;
            usDestinationPort        = usPublicPort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;

        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort != 0 )
        {
            //
            // Scenario #1c
            //
            // Inbound connection from known machine and port
            //
            MYTRACE("SCENARIO:eALG_INBOUND #1c");

            nFlags                   = NatRedirectFlagReceiveOnly; 

            ulSourceAddress          = ulRemoteAddress;
            usSourcePort             = usRemotePort;

            ulDestinationAddress     = ulPublicAddress;
            usDestinationPort        = usPublicPort;

            ulNewSourceAddress       = ulRemoteAddress;
            usNewSourcePort          = usRemotePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;

        }
        else
            return E_INVALIDARG;
    
    }
    else
    if ( eALG_OUTBOUND == eDirection )
    {
        //
        // These cases can also be handled by a single ul
        //

        if ( ulRemoteAddress !=0 && usRemotePort != 0 && ulPrivateAddress == 0 && usPrivatePort == 0 )
        {
            //
            // Scenario #2a
            //
            // Outbound connection to known machine/port, from any private machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2a");

            nFlags                   = 0; 

            ulSourceAddress          = 0;
            usSourcePort             = 0;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = usRemotePort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            
            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort != 0 && ulPrivateAddress != 0 && usPrivatePort == 0 )
        {
            //
            // Scenario #2b
            //
            // Outbound connection to known machine/port, from a specific private machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2b");
            nFlags                   = NatRedirectFlagRestrictSource;

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = 0;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = usRemotePort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort != 0 && ulPrivateAddress != 0 && usPrivatePort != 0 )
        {
            //
            // Scenario #2c
            //
            // Outbound connection to known machine/port, from a specific port on a specific private machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2c");
            nFlags                   = 0; 

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = usPrivatePort;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = usRemotePort;

            ulNewSourceAddress       = ulPrivateAddress;
            usNewSourcePort          = usPrivatePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort != 0 && ulRemoteAddress == 0 && usRemotePort == 0 )
        {
            //
            // Scenario #2d
            //
            // Outbound connection from a specific port on a specific private machine, to an unknown machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2d");
            nFlags                   = NatRedirectFlagSourceRedirect; 

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = usPrivatePort;

            ulDestinationAddress     = 0;
            usDestinationPort        = 0;

            ulNewSourceAddress       = ulPrivateAddress;
            usNewSourcePort          = usPrivatePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort != 0 && ulRemoteAddress != 0 && usRemotePort == 0 )
        {
            //
            // Scenario #2e
            //
            // Outbound connection from a specific port on a specific private machine, to a known machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2e");
            nFlags                   = 0; 

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = usPrivatePort;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = 0;

            ulNewSourceAddress       = ulPrivateAddress;
            usNewSourcePort          = usPrivatePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
            return E_INVALIDARG;

    }
    else
    {
        //
        //
        //
        return E_INVALIDARG;
    }

    HRESULT     hr;
    HANDLE_PTR  HandleDynamicRedirect=NULL;

    if ( fPersistent )
    {
        // Dynamic
        hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
            nFlags, 
            0,                               // Adapter Index 
            (UCHAR)eProtocol,
                                         
            ulDestinationAddress,            // ULONG    DestinationAddress
            usDestinationPort,               // USHORT   DestinationPort

            ulSourceAddress,                 // ULONG    SourceAddress
            usSourcePort,                    // USHORT   SourcePort

            ulNewDestinationAddress,         // ULONG    NewDestinationAddress
            usNewDestinationPort,            // USHORT   NewDestinationPort

            ulNewSourceAddress,              // ULONG    NewSourceAddress
            usNewSourcePort,                 // USHORT   NewSourcePort

            &HandleDynamicRedirect
            );
    }
    else
    {

        // Normal
        hr = g_pAlgController->GetNat()->CreateRedirect(
            nFlags, 
            (UCHAR)eProtocol,

            ulDestinationAddress,            // ULONG    DestinationAddress
            usDestinationPort,               // USHORT   DestinationPort

            ulSourceAddress,                 // ULONG    SourceAddress
            usSourcePort,                    // USHORT   SourcePort

            ulNewDestinationAddress,         // ULONG    NewDestinationAddress
            usNewDestinationPort,            // USHORT   NewDestinationPort

            ulNewSourceAddress,              // ULONG    NewSourceAddress
            usNewSourcePort,                 // USHORT   NewSourcePort

            ulRestrictAdapterIndex,          // ULONG    RestrictAdapterIndex

            0,                               // DWORD_PTR    ThisProcessID
            NULL,                            // HANDLE_PTR   CreateEvent
            NULL                             // HANDLE_PTR   DeleteEvent
            );
    }


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("From g_pAlgController->GetNat()->CreateRedirect", hr);
        return hr;
    }


    //
    // Add new ControlChannel to List
    //
    CComObject<CSecondaryControlChannel>*   pIChannel;
    hr = CComObject<CSecondaryControlChannel>::CreateInstance(&pIChannel);

    if ( SUCCEEDED(hr) )
    {
        pIChannel->AddRef();

        pIChannel->m_Properties.eProtocol           = eProtocol;
        pIChannel->m_Properties.ulPrivateAddress    = ulPrivateAddress;
        pIChannel->m_Properties.usPrivatePort       = usPrivatePort;
        pIChannel->m_Properties.ulPublicAddress     = ulPublicAddress;
        pIChannel->m_Properties.usPublicPort        = usPublicPort;
        pIChannel->m_Properties.ulRemoteAddress     = ulRemoteAddress;
        pIChannel->m_Properties.usRemotePort        = usRemotePort;
        pIChannel->m_Properties.ulListenAddress     = ulListenAddress;
        pIChannel->m_Properties.usListenPort        = usListenPort;
        pIChannel->m_Properties.eDirection          = eDirection;
        pIChannel->m_Properties.fPersistent         = fPersistent;

        //
        // Cache calling parameters used to create the redirect we will need them to cancel the redirect
        //
        pIChannel->m_ulDestinationAddress           = ulDestinationAddress;
        pIChannel->m_usDestinationPort              = usDestinationPort;

        pIChannel->m_ulSourceAddress                = ulSourceAddress;
        pIChannel->m_usSourcePort                   = usSourcePort;

        pIChannel->m_ulNewDestinationAddress        = ulNewDestinationAddress;
        pIChannel->m_usNewDestinationPort           = usNewDestinationPort;

        pIChannel->m_ulNewSourceAddress             = ulNewSourceAddress;
        pIChannel->m_usNewSourcePort                = usNewSourcePort;

        pIChannel->m_HandleDynamicRedirect          = HandleDynamicRedirect;

        
        hr = pIChannel->QueryInterface(IID_ISecondaryControlChannel, (void**)ppIControlChannel);

        if ( SUCCEEDED(hr) )
        {
            hr = g_pAlgController->m_ControlChannelsSecondary.Add(pIChannel);    

            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("Adding to list of SecondaryChannel", hr);   

               (*ppIControlChannel)->Release();
               *ppIControlChannel=NULL;

            }
        }
        else
        {
            MYTRACE_ERROR("QueryInterface(IID_ISecondaryControlChannel", hr);
        }

        pIChannel->Release();

    }
    else
    {
        MYTRACE_ERROR("From CreateInstance<CSecondaryControlChannel>", hr);
    }


    return hr;
}





STDMETHODIMP 
CApplicationGatewayServices::GetBestSourceAddressForDestinationAddress(
    IN  ULONG       ulDestinationAddress, 
    IN  BOOL        fDemandDial, 
    OUT ULONG*      pulBestSrcAddress
    )
/*++

Routine Description:

    We create a temporary UDP socket, connect the socket to the
    actual client's IP address, extract the IP address to which
    the socket is implicitly bound by the TCP/IP driver, and
    discard the socket. This leaves us with the exact IP address
    that we need to use to contact the client.

Arguments:

    ulDestinationAddress, 
    fDemandDial, 
    pulBestSrcAddress


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/

{
    MYTRACE_ENTER("CApplicationGatewayServices::GetBestSourceAddressForDestinationAddress");

    HRESULT hr = g_pAlgController->GetNat()->GetBestSourceAddressForDestinationAddress(
        ulDestinationAddress, 
        fDemandDial, 
        pulBestSrcAddress
        );

    MYTRACE("For Destination address of %s", MYTRACE_IP(ulDestinationAddress) );
    MYTRACE("the Best source address is %s", MYTRACE_IP(*pulBestSrcAddress) );

    return hr;

}




//
// 
// 
// 
// 
//

STDMETHODIMP 
CApplicationGatewayServices::PrepareProxyConnection(
    IN  ALG_PROTOCOL                eProtocol, 

    IN  ULONG                       ulSourceAddress, 
    IN  USHORT                      usSourcePort, 

    IN  ULONG                       ulDestinationAddress, 
    IN  USHORT                      usDestinationPort, 

    IN  BOOL                        fNoTimeout,
    OUT IPendingProxyConnection**   ppPendingConnection
    )
/*++

Routine Description:

    If we have a firwewall interface, possibly install a
    shadow redirect for this connection. The shadow redirect
    is necessary to prevent this connection from also being
    redirected to the proxy (setting in motion an infinite loop...)


Arguments:

    eProtocol, 

    ulSourceAddress, 
    usSourcePort, 

    ulDestinationAddress, 
    usDestinationPort, 

    fNoTimeout,
    ppPendingConnection


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::PrepareProxyConnection");

    MYTRACE("eProtocol    %s",    eProtocol==1? "TCP" : "UDP");
    MYTRACE("Source       %s:%d", MYTRACE_IP(ulSourceAddress),         ntohs(usSourcePort));
    MYTRACE("Destination  %s:%d", MYTRACE_IP(ulDestinationAddress),    ntohs(usDestinationPort));
    MYTRACE("NoTimeout    %d", fNoTimeout);

    ULONG   ulFlags = NatRedirectFlagLoopback;


    if ( !ppPendingConnection )
    {
        MYTRACE_ERROR("ppPendingConnection not supplied",0);
        return E_INVALIDARG;
    }


    if ( fNoTimeout )
    {
        MYTRACE("NoTimeout specified");

        if (  eProtocol == eALG_UDP )
        {
            ulFlags |= NatRedirectFlagNoTimeout;
        }
        else
        {
            MYTRACE("Wrong use of fNoTimeout && eProtocol != eALG_UDP");
            return E_INVALIDARG;
        }
    }


    HRESULT hr = g_pAlgController->GetNat()->CreateRedirect(
        ulFlags,
        (UCHAR)eProtocol,

        ulDestinationAddress,           // ULONG    DestinationAddress, 
        usDestinationPort,              // USHORT   DestinationPort,        

        ulSourceAddress,                // ULONG    SourceAddress, 
        usSourcePort,                   // USHORT   SourcePort,             

        ulDestinationAddress,           // ULONG    NewDestinationAddress
        usDestinationPort,              // USHORT   NewDestinationPort

        ulSourceAddress,                // ULONG    NewSourceAddress, 
        usSourcePort,                   // USHORT   NewSourcePort, 

        0,                              // ULONG    RestrictAdapterIndex

        0,                              // DWORD_PTR    ThisProcessID
        NULL,                           // HANDLE_PTR   CreateEvent
        NULL                            // HANDLE_PTR   DeleteEvent
        );

    

    if ( SUCCEEDED(hr) )
    {
        CComObject<CPendingProxyConnection>*   pIPendingProxyConnection;
        CComObject<CPendingProxyConnection>::CreateInstance(&pIPendingProxyConnection);

        pIPendingProxyConnection->m_eProtocol            = eProtocol;
        pIPendingProxyConnection->m_ulDestinationAddress = ulDestinationAddress;
        pIPendingProxyConnection->m_usDestinationPort    = usDestinationPort;

        pIPendingProxyConnection->m_ulSourceAddress      = ulSourceAddress;
        pIPendingProxyConnection->m_usSourcePort         = usSourcePort;

        pIPendingProxyConnection->m_ulNewSourceAddress   = ulSourceAddress; // Since the PendingProxyConenction is also used
        pIPendingProxyConnection->m_usNewSourcePort      = usSourcePort;    // by PrepareSourceModifiedProxyConnection we use the NewSource 
                                                                            // for the Cancel

        pIPendingProxyConnection->QueryInterface(ppPendingConnection);

    }
    else
    {
        MYTRACE_ERROR(">GetNat()->CreateRedirect failed", hr);
    }



    return hr;

}





STDMETHODIMP 
CApplicationGatewayServices::PrepareSourceModifiedProxyConnection(
    IN  ALG_PROTOCOL                eProtocol, 
    IN  ULONG                       ulSourceAddress, 
    IN  USHORT                      usSrcPort, 
    IN  ULONG                       ulDestinationAddress, 
    IN  USHORT                      usDestinationPort, 
    IN  ULONG                       ulNewSrcAddress, 
    IN  USHORT                      usNewSourcePort, 
    OUT IPendingProxyConnection**   ppPendingConnection
    )
/*++

Routine Description:

   

Arguments:

    eProtocol, 
    ulSourceAddress,   
    usSrcPort, 
    ulDestinationAddress,
    usDestinationPort, 
    ulNewSrcAddress, 
    usNewSourcePort, 
    ppPendingConnection

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::PrepareSourceModifiedProxyConnection");
    MYTRACE("Source      %s:%d", MYTRACE_IP(ulSourceAddress), ntohs(usSrcPort));
    MYTRACE("Destination %s:%d", MYTRACE_IP(ulDestinationAddress), ntohs(usDestinationPort));
    MYTRACE("NewSource   %s:%d", MYTRACE_IP(ulNewSrcAddress), ntohs(usNewSourcePort));

    if ( !ppPendingConnection )
    {
        MYTRACE_ERROR("IPendingProxyConnection** not supplied",0);
        return E_INVALIDARG;
    }



    HRESULT hr = g_pAlgController->GetNat()->CreateRedirect(
        NatRedirectFlagLoopback, 
        (UCHAR)eProtocol,

        ulDestinationAddress,           // ULONG    DestinationAddress, 
        usDestinationPort,              // USHORT   DestinationPort,       

        ulSourceAddress,                // ULONG    SourceAddress, 
        usSrcPort,                      // USHORT   SourcePort,             

        ulDestinationAddress,           // ULONG    NewDestinationAddress
        usDestinationPort,              // USHORT   NewDestinationPort

        ulNewSrcAddress,                // ULONG    NewSourceAddress, 
        usNewSourcePort,                // USHORT   NewSourcePort, 

        0,                              // ULONG    RestrictAdapterIndex

        0,                              // DWORD_PTR    ThisProcessID
        NULL,                           // HANDLE_PTR   CreateEvent
        NULL                            // HANDLE_PTR   DeleteEvent
        );


    if ( SUCCEEDED(hr) )
    {
        CComObject<CPendingProxyConnection>*   pIPendingProxyConnection;
        CComObject<CPendingProxyConnection>::CreateInstance(&pIPendingProxyConnection);

        pIPendingProxyConnection->m_eProtocol            = eProtocol;
        pIPendingProxyConnection->m_ulDestinationAddress = ulDestinationAddress;
        pIPendingProxyConnection->m_usDestinationPort    = usDestinationPort;

        pIPendingProxyConnection->m_ulSourceAddress      = ulSourceAddress;
        pIPendingProxyConnection->m_usSourcePort         = usSrcPort;

        pIPendingProxyConnection->m_ulNewSourceAddress   = ulNewSrcAddress;
        pIPendingProxyConnection->m_usNewSourcePort      = usNewSourcePort;

        hr  = pIPendingProxyConnection->QueryInterface(ppPendingConnection);

    }



    return hr;
}




HRESULT
GetRedirectParameters(
    IN  ALG_DIRECTION   eDirection,
    IN  ALG_PROTOCOL    eProtocol,

    IN  ULONG           ulPrivateAddress,
    IN  USHORT          usPrivatePort,
    IN  ULONG           ulPublicAddress,
    IN  USHORT          usPublicPort,
    IN  ULONG           ulRemoteAddress,
    IN  USHORT          usRemotePort,

    OUT ULONG&          ulFlags,
    OUT ULONG&          ulSourceAddress,
    OUT USHORT&         usSourcePort,
    OUT ULONG&          ulDestinationAddress,
    OUT USHORT&         usDestinationPort,
    OUT ULONG&          ulNewSourceAddress,
    OUT USHORT&         usNewSourcePort,
    OUT ULONG&          ulNewDestinationAddress,
    OUT USHORT&         usNewDestinationPort,

    OUT ULONG&          ulRestrictAdapterIndex
    )
/*++

Routine Description:

   The logic in these scenario are use by CreateDataChannel and CreatePersitenDataChannel

Arguments:

    eProtocol, 
    ulSourceAddress,   
    usSrcPort, 
    ulDestinationAddress,
    usDestinationPort, 
    ulNewSrcAddress, 
    usNewSourcePort, 
    ppPendingConnection

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{


    if ( eALG_INBOUND == eDirection )
    {
        if ( ulRemoteAddress == 0 && usRemotePort == 0 )
        {
            // 1a
            ulFlags = NatRedirectFlagReceiveOnly;

            ulSourceAddress = 0;
            usSourcePort = 0;
            ulDestinationAddress = ulPublicAddress;
            usDestinationPort = usPublicPort;
            ulNewSourceAddress = 0;
            usNewSourcePort = 0;
            ulNewDestinationAddress = ulPrivateAddress;
            usNewDestinationPort = usPrivatePort;
            ulRestrictAdapterIndex = 0;

        }
        else
        if ( ulRemoteAddress != 0 && usRemotePort == 0 )
        {
            // 1b
            ulFlags = NatRedirectFlagReceiveOnly|NatRedirectFlagRestrictSource;

            ulSourceAddress = ulRemoteAddress;
            usSourcePort    = 0;
            ulDestinationAddress = ulPublicAddress;
            usDestinationPort = usPublicPort;
            ulNewSourceAddress = 0;
            usNewSourcePort = 0;
            ulNewDestinationAddress = ulPrivateAddress;
            usNewDestinationPort = usPrivatePort;
            ulRestrictAdapterIndex = 0;
        }
        else
        if ( ulRemoteAddress != 0 && usRemotePort != 0 )
        {
            // 1c. 
            ulFlags = NatRedirectFlagReceiveOnly;

            ulSourceAddress = ulRemoteAddress;
            usSourcePort = usRemotePort;
            ulDestinationAddress = ulPublicAddress;
            usDestinationPort = usPublicPort;
            ulNewSourceAddress = ulRemoteAddress;
            usNewSourcePort = usRemotePort;
            ulNewDestinationAddress = ulPrivateAddress;
            usNewDestinationPort = usPrivatePort;

            ulRestrictAdapterIndex = 0;
        }
        else
            return E_INVALIDARG;
    }
    else
    if ( eALG_OUTBOUND == eDirection )
    {
        if ( ulPrivateAddress == 0 && usPrivatePort == 0 )
        {
            // 2a.
            ulFlags = 0;
            ulSourceAddress = 0;
            usSourcePort = 0;
            ulDestinationAddress = ulRemoteAddress;
            usDestinationPort = usRemotePort;
            ulNewSourceAddress = ulPublicAddress;
            usNewSourcePort = usPublicPort;
            ulNewDestinationAddress = ulRemoteAddress;
            usNewDestinationPort = usRemotePort;

            ulRestrictAdapterIndex = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort == 0 )
        {
            // 2b. 
            ulFlags = NatRedirectFlagRestrictSource;
            ulSourceAddress = ulPrivateAddress;
            usSourcePort = 0;
            ulDestinationAddress = ulRemoteAddress;
            usDestinationPort = usRemotePort;
            ulNewSourceAddress = ulPublicAddress;
            usNewSourcePort = usPublicPort;
            ulNewDestinationAddress = ulRemoteAddress;
            usNewDestinationPort = usRemotePort;

            ulRestrictAdapterIndex  = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort != 0 )
        {
            // 2c. 
            ulFlags = 0;
            ulSourceAddress         = ulPrivateAddress;
            usSourcePort            = usPrivatePort;
            ulDestinationAddress    = ulRemoteAddress;
            usDestinationPort       = usRemotePort;
            ulNewSourceAddress      = ulPublicAddress;
            usNewSourcePort         = usPublicPort;
            ulNewDestinationAddress = ulRemoteAddress;
            usNewDestinationPort    = usRemotePort;
            
            ulRestrictAdapterIndex  = 0;
        }
        else
            return E_INVALIDARG;
    }
    else
    if ( (eALG_INBOUND | eALG_OUTBOUND) == eDirection )
    {
        ulFlags                 = 0;
        ulSourceAddress         = ulRemoteAddress;
        usSourcePort            = usRemotePort;
        ulDestinationAddress    = ulPublicAddress;
        usDestinationPort       = usPublicPort;
        ulNewSourceAddress      = ulRemoteAddress;
        usNewSourcePort         = usRemotePort;
        ulNewDestinationAddress = ulPrivateAddress;
        usNewDestinationPort    = usPrivatePort;

        ulRestrictAdapterIndex  = 0;
    }
    else
        return E_INVALIDARG;

    return S_OK;
}




STDMETHODIMP 
CApplicationGatewayServices::CreateDataChannel(
    IN  ALG_PROTOCOL          eProtocol,
    IN  ULONG                 ulPrivateAddress,
    IN  USHORT                usPrivatePort,
    IN  ULONG                 ulPublicAddress,
    IN  USHORT                usPublicPort,
    IN  ULONG                 ulRemoteAddress,
    IN  USHORT                usRemotePort,
    IN  ALG_DIRECTION         eDirection,
    IN  ALG_NOTIFICATION      eDesiredNotification,
    IN  BOOL                  fNoTimeout,
    OUT IDataChannel**        ppDataChannel
    )
/*++

Routine Description:



Arguments:

    eProtocol,  
    ulPrivateAddress,
    usPrivatePort,
    ulPublicAddress,
    usPublicPort,
    ulRemoteAddress,
    usRemotePort,
    eDirection,
    eDesiredNotification,
    fNoTimeout,
    ppDataChannel

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreateDataChannel");

    if ( !ppDataChannel )
    {
        MYTRACE_ERROR("IDataChannel** not supplied",0);
        return E_INVALIDARG;
    }

    MYTRACE("eProtocol              %d", eProtocol);
    MYTRACE("ulPrivateAddress       %s:%d", MYTRACE_IP(ulPrivateAddress), ntohs(usPrivatePort));
    MYTRACE("ulPublicAddress        %s:%d", MYTRACE_IP(ulPublicAddress), ntohs(usPublicPort));
    MYTRACE("ulRemoteAddress        %s:%d", MYTRACE_IP(ulRemoteAddress), ntohs(usRemotePort));
    MYTRACE("eDirection             %d", eDirection);
    MYTRACE("eDesiredNotification   %d", eDesiredNotification);
    MYTRACE("fNoTimeout             %d", fNoTimeout);


    ULONG   ulFlags=0;

    ULONG   ulSourceAddress=0;
    USHORT  usSourcePort=0;
    ULONG   ulDestinationAddress=0;
    USHORT  usDestinationPort=0;
    ULONG   ulNewSourceAddress=0;
    USHORT  usNewSourcePort=0;
    ULONG   ulNewDestinationAddress=0;
    USHORT  usNewDestinationPort=0;

    ULONG   ulRestrictAdapterIndex=0;


    HRESULT hr = GetRedirectParameters(
        // IN Params
        eDirection,
        eProtocol,
        ulPrivateAddress,
        usPrivatePort,
        ulPublicAddress,
        usPublicPort,
        ulRemoteAddress,
        usRemotePort,

        // OUT Params
        ulFlags,
        ulSourceAddress,
        usSourcePort,
        ulDestinationAddress,
        usDestinationPort,
        ulNewSourceAddress,
        usNewSourcePort,
        ulNewDestinationAddress,
        usNewDestinationPort,
        ulRestrictAdapterIndex
        );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Invalid parameters pass", hr);
        return E_INVALIDARG;
    }


    //
    // Check for timeout
    //
    if ( fNoTimeout && eALG_UDP == eProtocol)
        ulFlags |= NatRedirectFlagNoTimeout;

    HANDLE_PTR hCreateEvent = NULL;
    HANDLE_PTR hDeleteEvent = NULL;

    //
    // We need to events Create and Delete
    //
    if ( eALG_SESSION_CREATION & eDesiredNotification )
    {
        hCreateEvent = (HANDLE_PTR)CreateEvent(NULL, FALSE, FALSE, NULL);
        if ( !hCreateEvent )
        {
            MYTRACE_ERROR("Could not create hCreateEvent", GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        MYTRACE("NO eALG_SESSION_CREATION notification requested");
    }

    if ( eALG_SESSION_DELETION & eDesiredNotification )
    {
        hDeleteEvent = (HANDLE_PTR)CreateEvent(NULL, FALSE, FALSE, NULL);
        if ( !hDeleteEvent )
        {
            MYTRACE_ERROR("Could not create hDeleteEvent", GetLastError());
            if ( hCreateEvent )
                CloseHandle((HANDLE)hCreateEvent);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        MYTRACE("NO eALG_SESSION_DELETION notification requested");
    }

    //
    // Create a IDataChannel and cache arg to be able CancelRedirect
    //
    hr = g_pAlgController->GetNat()->CreateRedirect(
        ulFlags|NatRedirectFlagLoopback, 
        (UCHAR)eProtocol,

        ulDestinationAddress,     
        usDestinationPort,        

        ulSourceAddress,          
        usSourcePort,             

        ulNewDestinationAddress,  
        usNewDestinationPort,     

        ulNewSourceAddress,       
        usNewSourcePort,          

        ulRestrictAdapterIndex,   

        GetCurrentProcessId(),
        hCreateEvent,
        hDeleteEvent
        ); 

    
    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("GetNAT()->CreateRedirect",hr);
        if ( hCreateEvent )
            CloseHandle((HANDLE)hCreateEvent);

        if ( hDeleteEvent )
            CloseHandle((HANDLE)hDeleteEvent);
        return hr;
    }


    CComObject<CDataChannel>*   pIDataChannel;
    hr = CComObject<CDataChannel>::CreateInstance(&pIDataChannel);

    if ( SUCCEEDED(hr) )
    {
        //
        // Save these settings so to be able to return them to the user 
        // if the IDataChannel->GetProperties is called
        //
        pIDataChannel->m_Properties.eProtocol               = eProtocol;
        pIDataChannel->m_Properties.ulPrivateAddress        = ulPrivateAddress;
        pIDataChannel->m_Properties.usPrivatePort           = usPrivatePort;
        pIDataChannel->m_Properties.ulPublicAddress         = ulPublicAddress;
        pIDataChannel->m_Properties.usPublicPort            = usPublicPort;
        pIDataChannel->m_Properties.ulRemoteAddress         = ulRemoteAddress;
        pIDataChannel->m_Properties.usRemotePort            = usRemotePort;
        pIDataChannel->m_Properties.eDirection              = eDirection;
        pIDataChannel->m_Properties.eDesiredNotification    = eDesiredNotification;



        //
        // Cache these arguments in order to implement IDataChannel->Cancel
        //
        pIDataChannel->m_ulSourceAddress          = ulSourceAddress;
        pIDataChannel->m_usSourcePort             = usSourcePort;
        pIDataChannel->m_ulDestinationAddress     = ulDestinationAddress;
        pIDataChannel->m_usDestinationPort        = usDestinationPort;
        pIDataChannel->m_ulNewSourceAddress       = ulNewSourceAddress;
        pIDataChannel->m_usNewSourcePort          = usNewSourcePort;
        pIDataChannel->m_ulNewDestinationAddress  = ulNewDestinationAddress;
        pIDataChannel->m_usNewDestinationPort     = usNewDestinationPort;
        pIDataChannel->m_ulRestrictAdapterIndex   = ulRestrictAdapterIndex;

        pIDataChannel->m_hCreateEvent             = (HANDLE)hCreateEvent;
        pIDataChannel->m_hDeleteEvent             = (HANDLE)hDeleteEvent;

        hr = pIDataChannel->QueryInterface(ppDataChannel);

        if ( FAILED(hr) )
        {
            MYTRACE_ERROR("QI on IDataChannel", hr);
        }
    }


    return hr;
}





STDMETHODIMP 
CApplicationGatewayServices::CreatePersistentDataChannel(
    IN  ALG_PROTOCOL                eProtocol,
    IN  ULONG                       ulPrivateAddress,
    IN  USHORT                      usPrivatePort,
    IN  ULONG                       ulPublicAddress,
    IN  USHORT                      usPublicPort,
    IN  ULONG                       ulRemoteAddress,
    IN  USHORT                      usRemotePort,
    IN  ALG_DIRECTION               eDirection,
    OUT IPersistentDataChannel**    ppIPersistentDataChannel
    )
/*++

Routine Description:



Arguments:

    eProtocol,
    ulPrivateAddress,
    usPrivatePort,
    ulPublicAddress,
    usPublicPort,
    ulRemoteAddress,
    usRemotePort,
    eDirection,
    ppIPersistentDataChannel


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreatePersistentDataChannel");

    if ( !ppIPersistentDataChannel )
    {
        MYTRACE_ERROR("IPersistentDataChannel** not supplied",0);
        return E_INVALIDARG;
    }


    ULONG   ulFlags=0;

    ULONG   ulSourceAddress=0;
    USHORT  usSourcePort=0;
    ULONG   ulDestinationAddress=0;
    USHORT  usDestinationPort=0;
    ULONG   ulNewSourceAddress=0;
    USHORT  usNewSourcePort=0;
    ULONG   ulNewDestinationAddress=0;
    USHORT  usNewDestinationPort=0;

    ULONG   ulRestrictAdapterIndex=0;


    HRESULT hr = GetRedirectParameters(
        // IN Params
        eDirection,
        eProtocol,
        ulPrivateAddress,
        usPrivatePort,
        ulPublicAddress,
        usPublicPort,
        ulRemoteAddress,
        usRemotePort,

        // OUT Params
        ulFlags,
        ulSourceAddress,
        usSourcePort,
        ulDestinationAddress,
        usDestinationPort,
        ulNewSourceAddress,
        usNewSourcePort,
        ulNewDestinationAddress,
        usNewDestinationPort,
        ulRestrictAdapterIndex
        );

    if ( FAILED(hr) )
        return hr;


    //
    // Create a IDataChannel and cache arg so to CancelRedirect
    //

    HANDLE_PTR  HandleDynamicRedirect=NULL;

    // Dynamic
    hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
        ulFlags, 
        0,                               // Adapter Index 
        (UCHAR)eProtocol,

        ulDestinationAddress,            // ULONG    DestinationAddress
        usDestinationPort,               // USHORT   DestinationPort

        ulSourceAddress,                 // ULONG    SourceAddress
        usSourcePort,                    // USHORT   SourcePort

        ulNewDestinationAddress,         // ULONG    NewDestinationAddress
        usNewDestinationPort,            // USHORT   NewDestinationPort

        ulNewSourceAddress,              // ULONG    NewSourceAddress
        usNewSourcePort,                 // USHORT   NewSourcePort

        &HandleDynamicRedirect
        );

    
    if ( SUCCEEDED(hr) )
    {
        
        CComObject<CPersistentDataChannel>*   pIPersistentDataChannel;
        CComObject<CPersistentDataChannel>::CreateInstance(&pIPersistentDataChannel);


        //
        // Save these settings so to be able to return them to the user 
        // if the IDataChannel->GetProperties is called
        //
        pIPersistentDataChannel->m_Properties.eProtocol               = eProtocol;
        pIPersistentDataChannel->m_Properties.ulPrivateAddress        = ulPrivateAddress;
        pIPersistentDataChannel->m_Properties.usPrivatePort           = usPrivatePort;
        pIPersistentDataChannel->m_Properties.ulPublicAddress         = ulPublicAddress;
        pIPersistentDataChannel->m_Properties.usPublicPort            = usPublicPort;
        pIPersistentDataChannel->m_Properties.ulRemoteAddress         = ulRemoteAddress;
        pIPersistentDataChannel->m_Properties.usRemotePort            = usRemotePort;
        pIPersistentDataChannel->m_Properties.eDirection              = eDirection;



        //
        // Cache these hanlde in order to implement IPersistentDataChannel->Cancel
        //
        pIPersistentDataChannel->m_HandleDynamicRedirect = HandleDynamicRedirect;


        hr = pIPersistentDataChannel->QueryInterface(ppIPersistentDataChannel);

    }


    return hr;

}





STDMETHODIMP 
CApplicationGatewayServices::ReservePort(
    IN  USHORT     usPortCount,     // must be 1 or more and not more then ALG_MAXIMUM_PORT_RANGE_SIZE
    OUT USHORT*    pusReservedPort  // Received the base reserved port *pusReservedPort+usPortCount-1 are reserved for the caller
    )
/*++

Routine Description:

    Reserve a number of port (usPortCount) port(s)

Arguments:

    usPortCount     - greated then 1 and not more then ALG_MAXIMUM_PORT_RANGE_SIZE
    pusReservedPort - Received the base reserved port *pusReservedPort+usPortCount-1 are reserved for the caller

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::ReservePort")

    if ( usPortCount < 0 || usPortCount > ALG_MAXIMUM_PORT_RANGE_SIZE )
        return E_INVALIDARG;

    _ASSERT(pusReservedPort);

    HRESULT hr = g_pAlgController->GetNat()->ReservePort(usPortCount, pusReservedPort);

    if ( FAILED(hr) )
    {
        MYTRACE("Reserving Ports", hr);
    }
    else
    {
        MYTRACE("%d port stating at %d", usPortCount, ntohs(*pusReservedPort) );
    }
        
    return hr;
}





//
//
//
VOID CALLBACK 
CApplicationGatewayServices::TimerCallbackReleasePort(
    PVOID   pParameter,         // thread data
    BOOLEAN TimerOrWaitFired    // reason
    )
{
    MYTRACE_ENTER("CApplicationGatewayServices::TimerCallbackReleasePort");

    CTimerQueueReleasePort* pTimerQueueReleasePort = (CTimerQueueReleasePort*)pParameter;

    if ( pTimerQueueReleasePort )
    {
        MYTRACE("Releasing port Base %d count %d", ntohs(pTimerQueueReleasePort->m_usPortBase), pTimerQueueReleasePort->m_usPortCount);
        g_pAlgController->GetNat()->ReleasePort(pTimerQueueReleasePort->m_usPortBase, pTimerQueueReleasePort->m_usPortCount);

        delete pTimerQueueReleasePort;
    }
}




STDMETHODIMP 
CApplicationGatewayServices::ReleaseReservedPort(
    IN  USHORT      usPortBase,     // Port to release
    IN  USHORT      usPortCount     // Number of port in the range starting at usPortBase
    )
/*++

Routine Description:

    Release the given port(s)

Arguments:

    pusReservedPort - The starting base port number
    usPortCount     - greated then 1 and not more then ALG_MAXIMUM_PORT_RANGE_SIZE

Return Value:

    HRESULT         - S_OK      for success
                    - E_FAIL    could no release the port
                    
Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::ReleaseReservedPort")

    MYTRACE("BasePort %d, Count %d", ntohs(usPortBase), usPortCount);

    //
    // By creating a CTimerQueueReleasePort it will trigger a ReleaseReservePort after 4 minutes
    // we need this delay to insure that a ReserverPort does not get the same port that just go Released
    // because the connnection would not work (This is a TCP/IP TIME_WAIT restriction)
    //
    CTimerQueueReleasePort* pTimerReleasePort = new CTimerQueueReleasePort(m_hTimerQueue, usPortBase, usPortCount);
    
    if ( pTimerReleasePort )
        return S_OK;
    else
        return E_FAIL;
}





STDMETHODIMP 
CApplicationGatewayServices::EnumerateAdapters(
    OUT IEnumAdapterInfo**    ppEnumAdapterInfo 
    )
/*++

Routine Description:

    Create a list of IEnumAdapterInfo
    the AddRef will be done soe caller needs to call Release 

Arguments:

    ppEnumAdapterInfo   - receive the enumarator interface of the IAdapterInfo

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::EnumerateAdapters")

    _ASSERT(ppEnumAdapterInfo==NULL);

    HRESULT hr = S_OK;

    CreateSTLEnumerator<ComEnumOnSTL_ForAdapters>(
        (IUnknown**)ppEnumAdapterInfo, 
        NULL, 
        g_pAlgController->m_CollectionOfAdapters.m_ListOfAdapters
        );

    return hr;
}

 



STDMETHODIMP 
CApplicationGatewayServices::StartAdapterNotifications(
    IN  IAdapterNotificationSink*    pSink,
    OUT DWORD*                       pdwCookie
    )
/*++

Routine Description:

    The ALG module calls this method to Register a notification sync with the ALG.exe

Arguments:

    pSink           - Interface to call back with future notification
    pdwCookie       - this cookie will be used to cancel this sink


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::StartAdapterNotifications")

    if ( pSink==NULL || pdwCookie==NULL )
    {
        MYTRACE("Invalid argument pass");
        return E_INVALIDARG;
    }

    return g_pAlgController->m_AdapterNotificationSinks.Add(pSink, pdwCookie);
}




STDMETHODIMP 
CApplicationGatewayServices::StopAdapterNotifications(
    IN  DWORD   dwCookieToRemove
    )
/*++

Routine Description:

    Cancel a previously registered sink

Arguments:

    
    pdwCookieToRemove   - Pass the cookie that was return from the StartAdapterNotifications


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::StopAdapterNotifications")

    return g_pAlgController->m_AdapterNotificationSinks.Remove(dwCookieToRemove);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\alg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// ALG.cpp : Implementation of WinMain
//
//
// JPDup  - 2000.12.15
//      
//      

#include "PreComp.h"

#include "AlgController.h"
#include "ApplicationGatewayServices.h"
#include "PrimaryControlChannel.h"
#include "SecondaryControlChannel.h"
#include "PendingProxyConnection.h"
#include "DataChannel.h"
#include "AdapterInfo.h"
#include "PersistentDataChannel.h"


#include <initguid.h>

#include "..\ALG_FTP\MyALG.h"



//
// GLOBALS
//
MYTRACE_ENABLE;                     // Define Tracing globals see MyTrace.h

CComModule              _Module;

HINSTANCE               g_hInstance=NULL;
HANDLE                  g_EventKeepAlive=NULL;
HANDLE                  g_EventRegUpdates=NULL;
SERVICE_STATUS          g_MyServiceStatus; 
SERVICE_STATUS_HANDLE   g_MyServiceStatusHandle; 



BEGIN_OBJECT_MAP(ObjectMap)

    OBJECT_ENTRY(CLSID_AlgController,               CAlgController)
    OBJECT_ENTRY(CLSID_ApplicationGatewayServices,  CApplicationGatewayServices)
    OBJECT_ENTRY(CLSID_PrimaryControlChannel,       CPrimaryControlChannel)
    OBJECT_ENTRY(CLSID_SecondaryControlChannel,     CSecondaryControlChannel)
    OBJECT_ENTRY(CLSID_PendingProxyConnection,      CPendingProxyConnection)
    OBJECT_ENTRY(CLSID_DataChannel,                 CDataChannel)
    OBJECT_ENTRY(CLSID_AdapterInfo,                 CAdapterInfo)
    OBJECT_ENTRY(CLSID_PersistentDataChannel,       CPersistentDataChannel)

    OBJECT_ENTRY(CLSID_AlgFTP,                      CAlgFTP)
//    OBJECT_ENTRY(CLSID_AlgICQ,                      CAlgICQ)

END_OBJECT_MAP()





 


//
///
//
VOID 
MyServiceCtrlHandler(
    DWORD Opcode
    ) 
{ 
    MYTRACE_ENTER("ALG.exe::MyServiceCtrlHandler");

    DWORD status; 
 
    switch(Opcode) 
    { 
        case SERVICE_CONTROL_PAUSE: 
            MYTRACE("SERVICE_CONTROL_PAUSE");
            // Do whatever it takes to pause here. 
            g_MyServiceStatus.dwCurrentState = SERVICE_PAUSED; 
            break; 
 
        case SERVICE_CONTROL_CONTINUE: 
            MYTRACE("SERVICE_CONTROL_CONTINUE");
            // Do whatever it takes to continue here. 
            g_MyServiceStatus.dwCurrentState = SERVICE_RUNNING; 
            break; 
 
        case SERVICE_CONTROL_STOP: 
            MYTRACE("SERVICE_CONTROL_STOP");
            // Do whatever it takes to stop here. 
            g_MyServiceStatus.dwWin32ExitCode = 0; 
            g_MyServiceStatus.dwCurrentState  = SERVICE_STOPPED; 
            g_MyServiceStatus.dwCheckPoint    = 0; 
            g_MyServiceStatus.dwWaitHint      = 0; 
 
            if (!SetServiceStatus(g_MyServiceStatusHandle, &g_MyServiceStatus))
            { 
                MYTRACE_ERROR("SetServiceStatus ",0);
            } 
 
            MYTRACE("Leaving MyService"); 
            return; 
 
        case SERVICE_CONTROL_INTERROGATE: 
            MYTRACE("SERVICE_CONTROL_STOP");
            break; 
 
        default: 
            MYTRACE("Unrecognized opcode %ld", Opcode); 
    } 
 
    // Send current status. 
    if (!SetServiceStatus (g_MyServiceStatusHandle,  &g_MyServiceStatus)) 
    { 
        MYTRACE_ERROR("SetServiceStatus error ",0);
    } 
    return; 
} 




// 
// Stub initialization function. 
//
DWORD 
MyServiceInitialization(
    DWORD   argc, 
    LPTSTR* argv
    ) 
{ 
    MYTRACE_ENTER("ALG.exe::MyServiceInitialization");

    DWORD status; 
    DWORD specificError; 
 
    g_MyServiceStatus.dwServiceType               = SERVICE_WIN32; 
    g_MyServiceStatus.dwCurrentState              = SERVICE_START_PENDING; 
    g_MyServiceStatus.dwControlsAccepted          = SERVICE_ACCEPT_STOP;// | SERVICE_ACCEPT_PAUSE_CONTINUE; 
    g_MyServiceStatus.dwWin32ExitCode             = 0; 
    g_MyServiceStatus.dwServiceSpecificExitCode   = 0; 
    g_MyServiceStatus.dwCheckPoint                = 0; 
    g_MyServiceStatus.dwWaitHint                  = 0; 
 
    g_MyServiceStatusHandle = RegisterServiceCtrlHandler(TEXT("ALG"), MyServiceCtrlHandler); 
 
    if ( g_MyServiceStatusHandle == (SERVICE_STATUS_HANDLE)0 ) 
    { 
        MYTRACE_ERROR("RegisterServiceCtrlHandler",0);
        return GetLastError();
    } 
/*
    // Handle error condition 
    if (status != NO_ERROR) 
    { 
        g_MyServiceStatus.dwCurrentState       = SERVICE_STOPPED; 
        g_MyServiceStatus.dwCheckPoint         = 0; 
        g_MyServiceStatus.dwWaitHint           = 0; 
        g_MyServiceStatus.dwWin32ExitCode      = status; 
        g_MyServiceStatus.dwServiceSpecificExitCode = specificError; 
 
        SetServiceStatus (g_MyServiceStatusHandle, &g_MyServiceStatus); 
        return; 
    } 
*/

    //
    // Initialise COM
    //
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _ASSERTE(SUCCEEDED(hr));

    _Module.Init(
        ObjectMap, 
        g_hInstance,
        &LIBID_ALGLib
        );
    

	//
	// Register the CLASS with the ROT
	//
    MYTRACE(">>>>>> RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE)");
    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);


    _ASSERTE(SUCCEEDED(hr));

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("RegisterClassObject", hr);
    }


    // Initialization complete - report running status. 
    g_MyServiceStatus.dwCurrentState       = SERVICE_RUNNING; 
    g_MyServiceStatus.dwCheckPoint         = 0; 
    g_MyServiceStatus.dwWaitHint           = 0; 
 
    if (!SetServiceStatus (g_MyServiceStatusHandle, &g_MyServiceStatus)) 
    { 
        MYTRACE_ERROR("SetServiceStatus error",0); 
        return GetLastError();
    } 

    return NO_ERROR; 
} 



//
// Since the RegNotifyChangeKeyValue is call at two place in MyServiceMain
// I created a function to clean up the code.
// 
void
SetRegNotifyEvent(
    CRegKey&    RegKeyToWatch
    )
{ 
    MYTRACE_ENTER("ALG.exe::SetRegNotifyEvent");


    //
    // Watch the registry key for a change of value.
    //
    LONG nError = RegNotifyChangeKeyValue(
        RegKeyToWatch, 
        TRUE, 
        REG_NOTIFY_CHANGE_LAST_SET, 
        g_EventRegUpdates, 
        TRUE
        );

    if ( ERROR_SUCCESS != nError )
    {
        MYTRACE_ERROR("Error calling RegNotifyChangeKeyValue", nError);
        return;
    }
}



//
// This is the entry point call by the Service Control manager
// This EXE stays loaded until the AlgController->Stop is invoke by rmALG-ICS it does that via a event
// and this is the thread that wait for that event to be signal
//
void 
MyServiceMain(
    DWORD   argc, 
    LPTSTR* argv
    ) 
{ 
    MYTRACE_ENTER("ALG.exe::MyServiceMain");

    
    //
    // This will satisfy the Service control mananager and also initialise COM
    //
    MyServiceInitialization(argc, argv);
 


    //
    // Open a key to be watch doged on
    //
    CRegKey KeyAlgISV;
    LONG nError = KeyAlgISV.Open(HKEY_LOCAL_MACHINE, REGKEY_ALG_ISV, KEY_NOTIFY);

    if (ERROR_SUCCESS != nError)
    {
        MYTRACE_ERROR("Error in opening ALG_ISV regkey", GetLastError());
        goto cleanup;
    }

    //
    // Create an events.
    //
    g_EventKeepAlive = CreateEvent(NULL, false, false, NULL);
    g_EventRegUpdates= CreateEvent(NULL, false, false, NULL);

    if ( !g_EventKeepAlive || !g_EventRegUpdates )
    {
        MYTRACE_ERROR("Error in CreateEvent", GetLastError());
        goto cleanup;
    }

    //
    // Ok no problem we set a registry notification
    //
    SetRegNotifyEvent(KeyAlgISV);


    //
    // These are the event we will wait for.
    //
    HANDLE  hArrayOfEvent[] = {g_EventKeepAlive, g_EventRegUpdates};


    //
    // Main wait loop
    //
    while ( true )
    {
        MYTRACE("");
        MYTRACE("(-(-(-(- Waiting for Shutdown or Registry update-)-)-)-)\n");

        DWORD nRet = WaitForMultipleObjects(
            sizeof(hArrayOfEvent)/sizeof(HANDLE),   // number of handles in array
            hArrayOfEvent,                          // object-handle array
            false,                                  // wait option, FALSE mean then can be signal individualy
            INFINITE                                // time-out interval
            );
            
                
        //
        // We are no longet waiting, let's see what trigger this wake up
        //

        if ( WAIT_FAILED        == nRet )   // Had a problem wainting
        {
            MYTRACE_ERROR("Main thread could not WaitForMulipleObject got a WAIT_FAILED",0);
            break;
        }
        else
        if ( WAIT_OBJECT_0 + 1  == nRet )    // g_EventRegUpdate got signaled
        {
            //
            // Some changes occured in the Registry we need to reload or disables some ALG modules
            //
            MYTRACE("");
            MYTRACE(")-)-) got signal Registry Changed (-(-(\n");

            if ( g_pAlgController )
                g_pAlgController->ConfigurationUpdated();

            SetRegNotifyEvent(KeyAlgISV);
        }
        else 
        if ( WAIT_OBJECT_0 + 0  == nRet )    // g_EventKeepAlive got signaled
        {
            //
            // Signal to terminate this process
            //
            MYTRACE("");
            MYTRACE(")-)-) got signal Shutdown (-(-(\n");
            break;
        }
    }




cleanup:

    MYTRACE("CleanUp*******************");

    //
    // We are done no COm object will be supported by ALG.exe anymore
    // the RevokeClassObjects could be done sooner Like just after the CAlgControl::Initialize is done
    // since only the IPNATHLP can call use and is consuming this only once
    // be because of the hosting of the ALG_ICQ and ALG_FTP we need o have the ROT class available 
    // even after we are initialize.
    //
    MYTRACE("<<<<< RevokeClassObjects");
    _Module.RevokeClassObjects();   

    //
    // Close the event handles.
    //
  
    if (g_EventKeepAlive)
    {
        CloseHandle(g_EventKeepAlive);
    }
    
    if (g_EventRegUpdates)
    {
        CloseHandle(g_EventRegUpdates);
    }

    Sleep(500); // Give the AlgController->Release() called by rmALG the time to cleanup

    
    //
    // We are done with COM
    //
    _Module.Term();
    CoUninitialize();


    //
    // we are all done here time to stop the Service
    //
    MYTRACE("SetServiceStatus 'SERVICE_STOPPED'");

    g_MyServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    g_MyServiceStatus.dwCheckPoint         = 0; 
    g_MyServiceStatus.dwWaitHint           = 0; 


    if (!SetServiceStatus(g_MyServiceStatusHandle, &g_MyServiceStatus)) 
    { 
        MYTRACE_ERROR("SetServiceStatus error for SERVICE_STOPPED",0); 
        return;
    } 


    return; 
} 
 





/////////////////////////////////////////////////////////////////////////////
//
// Starting point of this process
//
//
extern "C" int WINAPI 
_tWinMain(
	HINSTANCE	hInstance, 
    HINSTANCE	hPrevInstance,
	LPTSTR		pzCmdLine, 
	int			nShowCmd
	)
{
 
    MYTRACE_START(L"ALG");
    MYTRACE_ENTER("ALG.exe::WinMain");

    g_hInstance = hInstance;

    SERVICE_TABLE_ENTRY   DispatchTable[] = 
        { 
            { TEXT("ALG"), MyServiceMain }, 
            { NULL,        NULL          } 
        }; 
 
    if (!StartServiceCtrlDispatcher(DispatchTable)) 
    { 
        MYTRACE_ERROR("StartServiceCtrlDispatcher error",00);
        return 0;
    } 

    MYTRACE("Exiting");
    MYTRACE_STOP;
    
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\applicationgatewayservices.h ===
// ApplicationGatewayServices.h : Declaration of the CApplicationGatewayServices

#pragma once

#include "resource.h"       // main symbols


#include "CollectionChannels.h"
#include "CollectionAdapterNotifySinks.h"



/////////////////////////////////////////////////////////////////////////////
// CApplicationGatewayServices
class ATL_NO_VTABLE CApplicationGatewayServices : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CApplicationGatewayServices, &CLSID_ApplicationGatewayServices>,
    public IApplicationGatewayServices
{
public:

    CApplicationGatewayServices()
    {
        m_hTimerQueue = NULL;
    }

    ~CApplicationGatewayServices()
    {
        MYTRACE_ENTER_NOSHOWEXIT("~CApplicationGatewayServices()");

        if ( m_hTimerQueue )
        {

            MYTRACE("Deleting the TimerQueue");
            DeleteTimerQueueEx(
               m_hTimerQueue,          // handle to timer queue
               INVALID_HANDLE_VALUE    // handle to completion event
               );
        }
    }



    HRESULT FinalConstruct()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CApplicationGatewayServices()::FinalConstruct()");

        m_hTimerQueue = CreateTimerQueue();

        HRESULT hr = S_OK;

        if ( m_hTimerQueue == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            MYTRACE_ERROR("Could not CreateTimerQueue", hr);
        }

        return hr;
    }
    

DECLARE_REGISTRY_RESOURCEID(IDR_APPLICATIONGATEWAYSERVICES)
DECLARE_NOT_AGGREGATABLE(CApplicationGatewayServices)

DECLARE_PROTECT_FINAL_CONSTRUCT()


BEGIN_COM_MAP(CApplicationGatewayServices)
    COM_INTERFACE_ENTRY(IApplicationGatewayServices)
END_COM_MAP()

// IApplicationGatewayServices
public:

    STDMETHODIMP CreatePrimaryControlChannel (
        ALG_PROTOCOL                eProtocol, 
        USHORT                      usPortToCapture, 
        ALG_CAPTURE                 eCaptureType,    
        BOOL                        fCaptureInbound,    
        ULONG                       ulListenAddress,    
        USHORT                      usListenPort,
        IPrimaryControlChannel**    ppIControlChannel
        );


    STDMETHODIMP CreateSecondaryControlChannel(
        ALG_PROTOCOL                eProtocol,
        ULONG                       ulPrivateAddress,    
        USHORT                      usPrivatePort, 
        ULONG                       ulPublicAddress, 
        USHORT                      usPublicPort, 
        ULONG                       ulRemoteAddress, 
        USHORT                      usRemotePort, 
        ULONG                       ulListenAddress, 
        USHORT                      usListenPort, 
        ALG_DIRECTION               eDirection, 
        BOOL                        fPersistent, 
        ISecondaryControlChannel ** ppControlChannel
        );


    STDMETHODIMP GetBestSourceAddressForDestinationAddress(
        ULONG    ulDstAddress, 
        BOOL    fDemandDial, 
        ULONG *    pulBestSrcAddress
        );


    STDMETHODIMP PrepareProxyConnection(
        ALG_PROTOCOL                eProtocol, 
        ULONG                       ulSrcAddress, 
        USHORT                      usSrcPort, 
        ULONG                       ulDstAddress, 
        USHORT                      usDstPort, 
        BOOL                        fNoTimeout,
        IPendingProxyConnection **  ppPendingConnection
        );


    STDMETHODIMP PrepareSourceModifiedProxyConnection(
        ALG_PROTOCOL                eProtocol, 
        ULONG                       ulSrcAddress, 
        USHORT                      usSrcPort, 
        ULONG                       ulDstAddress, 
        USHORT                      usDstPort, 
        ULONG                       ulNewSrcAddress, 
        USHORT                      usNewSourcePort, 
        IPendingProxyConnection **  ppPendingConnection
        );


    STDMETHODIMP CreateDataChannel(
        ALG_PROTOCOL                eProtocol,
        ULONG                       ulPrivateAddress,
        USHORT                      usPrivatePort,
        ULONG                       ulPublicAddress,
        USHORT                      ulPublicPort,
        ULONG                       ulRemoteAddress,
        USHORT                      ulRemotePort,
        ALG_DIRECTION               eDirection,
        ALG_NOTIFICATION            eDesiredNotification,
        BOOL                        fNoTimeout,
        IDataChannel**              ppDataChannel
        );


    STDMETHODIMP CreatePersistentDataChannel(
        ALG_PROTOCOL                eProtocol,
        ULONG                       ulPrivateAddress,
        USHORT                      usPrivatePort,
        ULONG                       ulPublicAddress,
        USHORT                      ulPublicPort,
        ULONG                       ulRemoteAddress,
        USHORT                      ulRemotePort,
        ALG_DIRECTION               eDirection,
        IPersistentDataChannel**    ppPersistentDataChannel
        );
        


    STDMETHODIMP ReservePort(
        USHORT                      usPortCount,
        USHORT*                     pusReservedPort
        );


    STDMETHODIMP ReleaseReservedPort(
        USHORT                      usReservedPortBase,
        USHORT                      usPortCount
        );


    STDMETHODIMP EnumerateAdapters(
        IEnumAdapterInfo**          ppEnumAdapterInfo
        );
    
    STDMETHODIMP StartAdapterNotifications(
        IAdapterNotificationSink *  pSink,
        DWORD*                      pdwCookie
        );
    
    STDMETHODIMP StopAdapterNotifications(
        DWORD                       dwCookieToRemove
        );


//
// Properties
//
public:
    HANDLE  m_hTimerQueue;


//
// Methods
//
public:
    static VOID CALLBACK 
    TimerCallbackReleasePort(
        PVOID   lpParameter,      // thread data
        BOOLEAN TimerOrWaitFired  // reason
        );
};


//
// Reserved port release delay
//
#define ALG_PORT_RELEASE_DELAY      240000


//
//
//
class CTimerQueueReleasePort
{
public:
    CTimerQueueReleasePort(
        IN  HANDLE      MainTimerQueue,
        IN  USHORT      usPortBase,    // Port to release
        IN  USHORT      usPortCount
        ) :
        m_hTimerQueue(MainTimerQueue),
        m_usPortBase(usPortBase),
        m_usPortCount(usPortCount)
    {
        MYTRACE_ENTER_NOSHOWEXIT("CTimerQueueReleasePort:NEW");

        BOOL bRet = CreateTimerQueueTimer(
            &m_hTimerThis,
            m_hTimerQueue,
            CApplicationGatewayServices::TimerCallbackReleasePort,
            (PVOID)this,
            ALG_PORT_RELEASE_DELAY,
            0,
            WT_EXECUTEDEFAULT
            );


        if ( bRet == FALSE )
        {
            MYTRACE_ERROR("Could not CreateTimerQueueTimer", GetLastError());
            m_hTimerThis = NULL;
        }

    }


    ~CTimerQueueReleasePort()
    {
        if ( m_hTimerThis )
        {
            DeleteTimerQueueTimer(
                m_hTimerQueue,
                m_hTimerThis,
                NULL
                );  
        }
    }



    HANDLE  m_hTimerQueue;
    HANDLE  m_hTimerThis;
    USHORT  m_usPortBase;       // Port to release
    USHORT  m_usPortCount;      // Number of port to release
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionadapternotifysinks.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionAdapterNotifySinks.cpp

Abstract:

    Implement a collection of the CPrimaryControlChannel.cpp & CSecondaryControlChannel
    in a threa safe way.

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "CollectionAdapterNotifySinks.h"
#include "AlgController.h"


CCollectionAdapterNotifySinks::~CCollectionAdapterNotifySinks()
{
    RemoveAll();
}



//
// Add an already created Adapter
//
HRESULT 
CCollectionAdapterNotifySinks::Add( 
    IN  IAdapterNotificationSink*   pAdapterSinkToAdd,  // AdapterSink to be added at the collection
    OUT DWORD*                      pdwNewCookie        // Will be populated with the new unique id can be used later to retrieve the AdapterSink
    )
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAdapterNotifySinks::Add")

        if ( !pdwNewCookie )
        {
            MYTRACE_ERROR("Return Cookie address not supplied", 0);
            return E_INVALIDARG;
        }


        CAdapterSinkBuket* pNewBuketToAdd = new CAdapterSinkBuket(pAdapterSinkToAdd);

        if ( !pNewBuketToAdd )
            return E_OUTOFMEMORY;

        *pdwNewCookie = 1;

    
        //
        // Find a unique cookie
        //
        if ( m_ListOfAdapterSinks.empty() )
        {
            //
            // List is empty so obviously the cookie '1' is unique
            //
            MYTRACE("First SINK Cookie is %d", *pdwNewCookie);
            pNewBuketToAdd->m_dwCookie = *pdwNewCookie;
        }
        else
        {
            //
            // Travers the collection and stop when the cookie is not found 
            // this schema could be optimize but the number of Sink is not expect to be large (1 per ALG modules)
            //
            MYTRACE("Current size %d", m_ListOfAdapterSinks.size() );

            while ( pNewBuketToAdd->m_dwCookie==0 )
            {
                MYTRACE("Search for unique Cookie %d", *pdwNewCookie);

                for (   LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator = m_ListOfAdapterSinks.begin(); 
                        theIterator != m_ListOfAdapterSinks.end(); 
                        theIterator++ 
                    )
                {

                    CAdapterSinkBuket* pAdapterSinkBuket = (CAdapterSinkBuket*)(*theIterator);

                    if ( pAdapterSinkBuket->m_dwCookie == *pdwNewCookie )
                        break;
                    else
                    {
                        pNewBuketToAdd->m_dwCookie = *pdwNewCookie;
                        break; // ok we found a unique cookie
                    }

            
                }

                *pdwNewCookie = *pdwNewCookie + 1;
            }
        }
    

        //
        // Add Sync to Collection
        //
        m_ListOfAdapterSinks.push_back(pNewBuketToAdd);

    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}







//
// Remove a adapter from the list (Thead safe)
//
HRESULT 
CCollectionAdapterNotifySinks::Remove( 
    IN  DWORD   dwCookieToRemove
    )
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAdapterNotifySinks::Remove")

        HRESULT hr = S_OK;

        for (   LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator = m_ListOfAdapterSinks.begin(); 
                theIterator != m_ListOfAdapterSinks.end(); 
                theIterator++ 
            )
        {

            CAdapterSinkBuket* pAdapterSinkBuket = (CAdapterSinkBuket*)(*theIterator);

            if ( pAdapterSinkBuket->m_dwCookie == dwCookieToRemove )
            {
                delete pAdapterSinkBuket;
                m_ListOfAdapterSinks.erase(theIterator);
                return S_OK;
            }
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    return E_INVALIDARG;    // if we are here that mean the cookie was not found
}




//
// When an adapter form the collection
//
HRESULT
CCollectionAdapterNotifySinks::RemoveAll()
{
    try
    {

        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapterNotifySinks::RemoveAll")


        //
        // By deleting all the ControlChannel they will also cancel all their associated Redirection
        //
        LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator;

        MYTRACE("Collection has %d item", m_ListOfAdapterSinks.size());

        while ( m_ListOfAdapterSinks.size() > 0 )
        {
            theIterator = m_ListOfAdapterSinks.begin(); 

            delete (*theIterator);
            m_ListOfAdapterSinks.erase(theIterator);
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;

}






HRESULT
CCollectionAdapterNotifySinks::Notify(
    eNOTIFY             eAction,
    IAdapterInfo*       pIAdapterInfo
    )
/*++

Routine Description:

    For all AdapterSink inteface in the current collection do a notify with the given action ADDED,REMOVED,MODIFIED

Arguments:

    eAction         - ADDED, REMOVED, MODIFIED

    pIAdapterInfo   - Interface of the Adapter with the current action to be notify to alg modules

Return Value:

    void            - None

Environment:


--*/
{
    
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapterNotifySinks::NotifySink")
        MYTRACE("Collection size %d", m_ListOfAdapterSinks.size());


        for (   LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator = m_ListOfAdapterSinks.begin(); 
                theIterator != m_ListOfAdapterSinks.end(); 
                theIterator++ 
            )
        {

            CAdapterSinkBuket* pAdapterSinkBuket = (CAdapterSinkBuket*)(*theIterator);

            MYTRACE("Will notify AdapterSink with cookie #%d", pAdapterSinkBuket->m_dwCookie);

            switch ( eAction )
            {
            case eNOTIFY_ADDED:
                pAdapterSinkBuket->m_pInterface->AdapterAdded(pIAdapterInfo);
                break;

            case eNOTIFY_REMOVED:
                pAdapterSinkBuket->m_pInterface->AdapterRemoved(pIAdapterInfo);
                break;

            case eNOTIFY_MODIFIED:
                pAdapterSinkBuket->m_pInterface->AdapterModified(pIAdapterInfo);
                break;
            }
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionadapters.h ===
//
// Microsoft
//
// CollectionAdapter.h

#pragma once

#include "ScopeCriticalSection.h"
#include "AdapterInfo.h"
#include "PrimaryControlChannel.h"

#include <list>
#include <algorithm>

//
// Adapters
//
typedef std::list<IAdapterInfo*>        LISTOF_ADAPTERS;


//
//
//
class CCollectionAdapters
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_ADAPTERS                             m_ListOfAdapters;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionAdapters();
 

    //
    // Add a new Adapter (Thread safe)
    //
    HRESULT 
    Add( 
        IN  IAdapterInfo*       pAdapterToAdd
        );

    //
    // This version of Add will actualy create the new IAdapterInfo before adding it to the collection
    // return the newly created IAdapterInfo or NULL is faild
    //
    IAdapterInfo* 
    Add( 
        IN	ULONG				nCookie,
	    IN	short				nType
        );

 
    //
    // Remove a adapter from the list (Thead safe)
    // by removing a adapter it will also kill all associated ControlChannel 
    //
    HRESULT 
    Remove( 
        IN  IAdapterInfo*       pAdapterToRemove
        );


    //
    // This version od Remove will remove the IAdapterInfo base on the given index
    //
    HRESULT 
    Remove( 
        IN  ULONG               nCookie
        );

    //
    // Remove all the adapter from the collection
    //
    HRESULT
    RemoveAll();


    //
    // Return an IAdapterInfo the caller is responsable of releasing the interface
    //
    HRESULT
    GetAdapterInfo(
        IN  ULONG               nCookie,
        OUT IAdapterInfo**      ppAdapterInfo
        );

    //
    // Bind the given addresses with the given index representing the AdapterInfo
    //
    HRESULT
    SetAddresses(
        IN  ULONG               nCookie,
        IN  ULONG               nAdapterIndex,
	    IN  ULONG	            nAddressCount,
	    IN  DWORD	            anAddress[]
        );


    HRESULT
    ApplyPrimaryChannel(
        CPrimaryControlChannel* pChannelToActivate
        );

    HRESULT
    AdapterUpdatePrimaryChannel(
        ULONG nCookie,
        CPrimaryControlChannel *pChannel
        );
    

private:

    //
    // Will return the IAdapterInfo* of for the given Cookie or NULL if not found
    //
    IAdapterInfo*
    FindUsingCookie(
        ULONG nCookie
        )
    {

        for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
                theIterator != m_ListOfAdapters.end(); 
                theIterator++ 
            )
        {
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);
            if (  pAdapterInfo->m_nCookie == nCookie )
                return *theIterator;
        }

        return NULL;
    }

    //
    // Will return the IAdapterInfo* of given the AdapterIndex or NULL if not found
    //
    IAdapterInfo*
    FindUsingAdapterIndex(
        ULONG nAdapterIndex
        )
    {
        MYTRACE_ENTER("FindUsingAdapterIndex");
        MYTRACE("Looking for adapter %d", nAdapterIndex);

        for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
                theIterator != m_ListOfAdapters.end(); 
                theIterator++ 
            )
        {
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);
            MYTRACE("ADAPTER index %d", pAdapterInfo->m_nAdapterIndex);
            if (  pAdapterInfo->m_nAdapterIndex == nAdapterIndex )
                return *theIterator;
        }

        return NULL;
    }


    //
    // Return true if the AdapterInfo is part of the collection
    //
    inline bool
    FindUsingInterface(
        IAdapterInfo* pAdapterToFind
        )
    {
        LISTOF_ADAPTERS::iterator theIterator = std::find(
            m_ListOfAdapters.begin(),
            m_ListOfAdapters.end(),
            pAdapterToFind
            );

        return *theIterator ? true : false;
    }


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionalgmodules.h ===
#pragma once

#include "ScopeCriticalSection.h"
#include "AlgModule.h"


#include <list>
#include <algorithm>






typedef  std::list<CAlgModule*> LISTOF_ALGMODULE;



//
//
//
class CCollectionAlgModules
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;
    LISTOF_ALGMODULE                            m_ThisCollection;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionAlgModules();

    int	// Returns the total number of ISV ALG  loaded or -1 if could not load them  or 0 is none where setup
    Load();

    HRESULT
    Unload();

    HRESULT
    UnloadDisabledModule();


    //
    // Make sure that ALG modules reflect the curren configuration
    //
    void
    Refresh()
    {
        MYTRACE_ENTER("CCollectionAlgModules::Refresh()");

        UnloadDisabledModule();
        Load();
    }

private:

    //
    // Add a new control channel (Thread safe)
    //
    CAlgModule*
    CCollectionAlgModules::AddUniqueAndStart( 
        CRegKey&    KeyEnumISV,
        LPCTSTR     pszAlgID
        );


    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT 
    Remove( 
        CAlgModule* pAglToRemove
        );

    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionadapters.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionAdapters.cpp

Abstract:

    Implement a collection of the CPrimaryControlChannel.cpp & CSecondaryControlChannel
    in a threa safe way.

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "CollectionAdapters.h"
#include "CollectionAdapterNotifySinks.h"
#include "AlgController.h"


CCollectionAdapters::~CCollectionAdapters()
{
    RemoveAll();
}



//
// Add an already created Adapter
//
HRESULT 
CCollectionAdapters::Add( 
    IAdapterInfo* pAdapterToAdd
    )
{
    try
    {
        ENTER_AUTO_CS

        if ( !FindUsingInterface(pAdapterToAdd) )
            m_ListOfAdapters.push_back(pAdapterToAdd);
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}




//
// Add a NEW Adapter this function insure that the is only 1 adatper with the given INDEX
// returns the newly added adapter or NULL is faild
// if the Adapter index was already present the return pointer is of the one found in the collection
//
IAdapterInfo*
CCollectionAdapters::Add( 
    IN	ULONG				nCookie,
	IN	short				nType
    )
{
    CComObject<CAdapterInfo>*   pIAdapterInfo=NULL;

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::Add");
        MYTRACE("Adapter Cookie %d of type %d", nCookie, nType);
    

        IAdapterInfo*   pIFound = FindUsingCookie(nCookie);
    
        if ( pIFound )
            return pIFound;   // Adapter with the given Index is already in the collection


        
        HRESULT hr = CComObject<CAdapterInfo>::CreateInstance(&pIAdapterInfo);

        if ( FAILED(hr) ) 
        {
            MYTRACE_ERROR("CComObject<CAdapterInfo>::CreateInstance(&pIAdapterInfo)",hr);
            return NULL; //ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the new interface
        //
        pIAdapterInfo->m_nCookie = nCookie;
        pIAdapterInfo->m_eType  = (ALG_ADAPTER_TYPE)nType;

        m_ListOfAdapters.push_back(pIAdapterInfo);
        pIAdapterInfo->AddRef();

    }
    catch(...)
    {
        return NULL;
    }

    return pIAdapterInfo;
}




//
// Remove a adapter from the list (Thead safe)
//
HRESULT 
CCollectionAdapters::Remove( 
    IAdapterInfo* pAdapterToRemove
    )
{
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::Remove by IAdapterInfo");

        LISTOF_ADAPTERS::iterator theIterator = std::find(
            m_ListOfAdapters.begin(),
            m_ListOfAdapters.end(),
            pAdapterToRemove
            );

        if ( *theIterator )
        {
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)pAdapterToRemove;

            g_pAlgController->m_AdapterNotificationSinks.Notify(eNOTIFY_REMOVED, (*theIterator) );
            g_pAlgController->m_ControlChannelsPrimary.AdapterRemoved(pAdapterInfo->m_nAdapterIndex);

            (*theIterator)->Release();
            m_ListOfAdapters.erase(theIterator);
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}



//
// Remove a adapter from the list (Thead safe)
//
HRESULT 
CCollectionAdapters::Remove( 
    ULONG   nCookieOfAdapterToRemove
    )
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAdapters::Remove by Index");

        for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
                theIterator != m_ListOfAdapters.end(); 
                theIterator++ 
            )
        {

            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);

            if (  pAdapterInfo->m_nCookie == nCookieOfAdapterToRemove )
            {
                g_pAlgController->m_AdapterNotificationSinks.Notify(eNOTIFY_REMOVED, (*theIterator) );
                g_pAlgController->m_ControlChannelsPrimary.AdapterRemoved(pAdapterInfo->m_nAdapterIndex);

                pAdapterInfo->Release();
                m_ListOfAdapters.erase(theIterator);

                return S_OK;
            }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return E_INVALIDARG;
}


//
// When an adapter form the collection
//
HRESULT
CCollectionAdapters::RemoveAll()
{
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::RemoveAll");

        //
        // By deleting all the ControlChannel they will also cancel all their associated Redirection
        //
        MYTRACE("Collection has %d item", m_ListOfAdapters.size());

        LISTOF_ADAPTERS::iterator theIterator;

        while ( m_ListOfAdapters.size() > 0 )
        {
            theIterator = m_ListOfAdapters.begin(); 
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);

            pAdapterInfo->Release();
            m_ListOfAdapters.erase(theIterator);
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}



//
// Return an IAdapterInfo the caller is responsable of releasing the interface
//
HRESULT
CCollectionAdapters::GetAdapterInfo(
    IN  ULONG               nAdapterIndex,
    OUT IAdapterInfo**      ppAdapterInfo
    )
{
    MYTRACE_ENTER("CCollectionAdapters::GetAdapterInfo");

    try
    {
        ENTER_AUTO_CS

        MYTRACE("Adapter index %d requested", nAdapterIndex);

        *ppAdapterInfo = FindUsingAdapterIndex(nAdapterIndex);

        if ( *ppAdapterInfo == NULL )
        {
            MYTRACE_ERROR("Adapter was not found in the collection", 0);
            return E_INVALIDARG;
        }

        (*ppAdapterInfo)->AddRef();

    }
    catch(...)
    {
        MYTRACE_ERROR("TRY/CATCH",0);
        return E_FAIL;
    }

    return S_OK;
}


//
// Update the addresses member proprety
//
// Now that we have the address we can apply any outstanding ControlChannel (Redirect)
//
HRESULT
CCollectionAdapters::SetAddresses(
	ULONG	nCookie,
    ULONG   nAdapterIndex,
	ULONG	nAddressCount,
	DWORD	anAddress[]
    )
{

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::SetAddresses");
        MYTRACE("Adapter BIND Cookie %d  Address Count %d", nCookie, nAddressCount);


        CAdapterInfo*  pIAdapterFound = (CAdapterInfo*)FindUsingCookie(nCookie);

        if ( !pIAdapterFound )
        {
            MYTRACE_ERROR("Adapter was not found in the collection", 0);
            return E_INVALIDARG;
        }

        //
        // Cache the Adapter Index 
        //
        pIAdapterFound->m_nAdapterIndex = nAdapterIndex;

        //
        // Cache the addresses
        //
        pIAdapterFound->m_nAddressCount = nAddressCount;

        for ( short nA=0; nA < nAddressCount; nA++ )
            pIAdapterFound->m_anAddress[nA] = anAddress[nA];


        //
        // Fire any Sink that may be setup
        //
        if ( pIAdapterFound->m_bNotified )
        {
            //
            // Already notify once the user that this adapter was added
            // from now on any CCollectionAdapters::SetAddresses
            // will trigger a eNOTIFY_MODIFIED notification
            //
            g_pAlgController->m_AdapterNotificationSinks.Notify(
                eNOTIFY_MODIFIED, 
                pIAdapterFound 
                );
        }
        else
        {
            //
            // Ok this is the first time we received address for this
            // adapter we will let the user know that a new adapter got added
            //
            g_pAlgController->m_AdapterNotificationSinks.Notify(
                eNOTIFY_ADDED, 
                pIAdapterFound 
                );

            pIAdapterFound->m_bNotified = true;
        }


        //
        // Create redirect(s) for any ControlChannels in the Collection of PrimaryControlChannel
        //
        g_pAlgController->m_ControlChannelsPrimary.SetRedirects(
            pIAdapterFound->m_eType, 
            nAdapterIndex,
            anAddress[0]
            );
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}



//
//
//
HRESULT
CCollectionAdapters::ApplyPrimaryChannel(
    CPrimaryControlChannel* pChannelToActivate
    )
{
    MYTRACE_ENTER("CCollectionAdapters::ApplyPrimaryChannel");

    if ( !pChannelToActivate )
        return E_INVALIDARG;

    ENTER_AUTO_CS

    for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
            theIterator != m_ListOfAdapters.end(); 
            theIterator++ 
        )
    {

        CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);

        if ( pAdapterInfo && pAdapterInfo->m_nAddressCount >0 )
        {
            pChannelToActivate->SetRedirect(
                pAdapterInfo->m_eType, 
                pAdapterInfo->m_nAdapterIndex,
                pAdapterInfo->m_nAddressCount
                );
        }
    }

    return S_OK;
}





//
// Will be called when port mapping has changed
//
HRESULT
CCollectionAdapters::AdapterUpdatePrimaryChannel(
    ULONG nCookie,
    CPrimaryControlChannel *pChannel
    )
{
    HRESULT hr = S_OK;

    MYTRACE_ENTER("CCollectionAdapters::AdapterUpdatePrimaryChannel");

    try
    {
        ENTER_AUTO_CS

        CAdapterInfo *pAdapter = (CAdapterInfo*) FindUsingCookie(nCookie);
        if (NULL != pAdapter
            && ( (eALG_BOUNDARY   & pAdapter->m_eType) || 
                 (eALG_FIREWALLED & pAdapter->m_eType) 
               )
           )
        {
            ULONG ulAddress;
            USHORT usPort;
            HANDLE_PTR hRedirect;
            
            HRESULT hrPortMappingExists =
                g_pAlgController->GetNat()->LookupAdapterPortMapping(
                    pAdapter->m_nAdapterIndex,
                    pChannel->m_Properties.eProtocol,
                    0,
                    pChannel->m_Properties.usCapturePort,
                    &ulAddress,
                    &usPort
                    );

            hRedirect = pChannel->m_CollectionRedirects.FindInboundRedirect(pAdapter->m_nAdapterIndex);

            if (SUCCEEDED(hrPortMappingExists) && NULL == hRedirect)
            {
                MYTRACE("PortMapping Exist and We had no Redirect so create them");
                hr = pChannel->CreateInboundRedirect(pAdapter->m_nAdapterIndex);
            }
            else if (FAILED(hrPortMappingExists) && NULL != hRedirect)
            {
                MYTRACE("PortMapping DOES NOT Exist and We had Redirect set so remove them");
                hr = pChannel->m_CollectionRedirects.Remove(hRedirect);
            }
        }
        else
        {
            MYTRACE("Adapter is not ICS or ICF");
        }
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionadapternotifysinks.h ===
//
// Microsoft
//
// CollectionAdapterNotifySinks.h

#pragma once

#include "ScopeCriticalSection.h"
//#include "AdapterNotificationSink.h"

#include <list>
#include <algorithm>



class CAdapterSinkBuket
{
public:
    CAdapterSinkBuket(IAdapterNotificationSink* pInterface)
    {
        MYTRACE_ENTER("CAdapterSinkBuket(IAdapterNotificationSink* pInterface)")

        m_pInterface = pInterface;
        m_pInterface->AddRef();

        m_dwCookie = 0;
    }

    ~CAdapterSinkBuket()
    {
        m_pInterface->Release();
    }


//
// Properties
//
    IAdapterNotificationSink*   m_pInterface;
    DWORD                       m_dwCookie;
};


//
// Adapters
//
typedef std::list<CAdapterSinkBuket*>        LISTOF_ADAPTER_NOTIFICATION_SINK;


enum eNOTIFY
{
    eNOTIFY_ADDED,
    eNOTIFY_REMOVED,
    eNOTIFY_MODIFIED
};





//
//
//
class CCollectionAdapterNotifySinks
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_ADAPTER_NOTIFICATION_SINK            m_ListOfAdapterSinks;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionAdapterNotifySinks();
 

    //
    // Add a new Adapter (Thread safe)
    //
    HRESULT 
    Add( 
        IN  IAdapterNotificationSink*       pAdapterSinkToAdd,
        OUT DWORD*                          pdwNewCookie
        );

 
    //
    // Remove a adapterSink from the list (Thead safe)
    //
    HRESULT 
    Remove( 
        IN  DWORD   dwCookie
        );


 
    //
    // Remove all the IAdapterNotificationSinks from the collection
    //
    HRESULT
    RemoveAll();


    //
    // Fire a notification to any ALG module requesting notification
    //
    HRESULT
    Notify(
        IN  eNOTIFY             eAction,
        IN  IAdapterInfo*       pIAdapterInfo
        );
 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionalgmodules.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionAlgModules.cpp

Abstract:

    Implement a thread safe collection of CAlgModules

Author:

    JP Duplessis    (jpdup)  2000.01.19

Revision History:

--*/

#include "PreComp.h"
#include "CollectionAlgModules.h"
#include "AlgController.h"




CCollectionAlgModules::~CCollectionAlgModules()
{
    MYTRACE_ENTER("CCollectionAlgModules::~CCollectionAlgModules()");

    Unload(); 
}



//
// Add a new ALG Module only if it's uniq meaning that if it's alread in the collection 
// it will return the one found and not add a new one
//
CAlgModule*
CCollectionAlgModules::AddUniqueAndStart( 
    CRegKey&    KeyEnumISV,
    LPCTSTR     pszAlgID
    )
{

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAlgModules::AddUniqueAndStart");

        //
        // Is it already in the collection ?
        //
        for (   LISTOF_ALGMODULE::iterator theIterator = m_ThisCollection.begin(); 
                theIterator != m_ThisCollection.end(); 
                theIterator++ 
            )
        {
            if ( _wcsicmp( (*theIterator)->m_szID, pszAlgID) == 0 )
            {
                //
                // Found it already
                //
                MYTRACE("Already loaded nothing to do");
                return (*theIterator);
            }
        }
        //
        // At this point we know that it's not in the collection
        //


        //
        // Get more information on the ALG module
        //
        CRegKey RegAlg;
        RegAlg.Open(KeyEnumISV, pszAlgID, KEY_QUERY_VALUE);

        TCHAR szFriendlyName[MAX_PATH];
        DWORD   dwSize = MAX_PATH;
        RegAlg.QueryValue(szFriendlyName, TEXT("Product"), &dwSize);
        

        //
        // Stuff in a CAlgModule that will be added to the collection
        //
        CAlgModule* pAlg = new CAlgModule(pszAlgID, szFriendlyName);

        if ( !pAlg )
            return NULL;

        HRESULT hr = pAlg->Start();

        if ( FAILED(hr) )
        {
            delete pAlg;
        }

        //
        // Now we know this is a valid and trouble free ALG plug-in we can safely cache it to our collection
        //
        try
        {
            m_ThisCollection.push_back(pAlg);
        }
        catch(...)
        {
            MYTRACE_ERROR("Had problem adding the ALG plun-in to the collection", 0);
            pAlg->Stop();
            delete pAlg;
            return NULL;
        }
        

        return pAlg;
    }
    catch(...)
    {
        return NULL;
    }


    return NULL;
}




//
// Remove a AlgModule from the list (Thead safe)
//
HRESULT CCollectionAlgModules::Remove( 
    CAlgModule* pAlgToRemove
    )
{

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAlgModules::Remove");

    
        LISTOF_ALGMODULE::iterator theIterator = std::find(
            m_ThisCollection.begin(),
            m_ThisCollection.end(),
            pAlgToRemove
            );

        if ( *theIterator )
        {
            m_ThisCollection.erase(theIterator);
        }

    }
    catch(...)
    {
        return E_FAIL;
    }


    return S_OK;
}


//
// return TRUE is the ALG Module specified by pszAlgProgID
// is currently marked as "Enable"
//
bool
IsAlgModuleEnable(
    CRegKey&    RegKeyISV,
    LPCTSTR     pszAlgID
    )
{

    DWORD dwSize = MAX_PATH;
    TCHAR szState[MAX_PATH];

    LONG nRet = RegKeyISV.QueryValue(
        szState, 
        pszAlgID, 
        &dwSize
        );


    if ( ERROR_SUCCESS != nRet )
        return false;
    
    if ( dwSize == 0 )
        return false;


    return ( _wcsicmp(szState, L"Enable") == 0);

};


//
//
//
HRESULT
CCollectionAlgModules::UnloadDisabledModule()
{
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAlgModules::UnloadDisabledModule()");

        CRegKey KeyEnumISV;
        LONG nError = KeyEnumISV.Open(HKEY_LOCAL_MACHINE, REGKEY_ALG_ISV, KEY_READ);

        bool bAllEnable = false;

        //
        // The total of item in the collectio is the maximum time we should attempt 
        // to verify and unload Alg Module that are disable
        //
        int nPassAttemp = m_ThisCollection.size();         
        
        while ( !bAllEnable && nPassAttemp > 0 )
        {
            bAllEnable = true;

            //
            // For all Module unload if not mark as "ENABLE"
            //
            for (   LISTOF_ALGMODULE::iterator theIterator = m_ThisCollection.begin(); 
                    theIterator != m_ThisCollection.end(); 
                    theIterator++ 
                )
            {
                if ( IsAlgModuleEnable(KeyEnumISV, (*theIterator)->m_szID) )
                {
                    MYTRACE("ALG Module %S is ENABLE", (*theIterator)->m_szFriendlyName);
                }
                else
                {
                    MYTRACE("ALG Module %S is DISABLE", (*theIterator)->m_szFriendlyName);
                    //
                    // Stop/Release/Unload this module it's not enabled
                    //
                    delete (*theIterator);
                    m_ThisCollection.erase(theIterator);

                    bAllEnable = false;
                    break;
                }
            }
            
            nPassAttemp--;      // Ok one pass done 
        }
        
        
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}




//
//
// Enumared the regsitry for all ALG-ISV module and verify that they are sign and CoCreates them and call there  Initialise method
//
//
int	                            // Returns the total number of ISV ALG loaded or -1 for error or 0 is none where setup
CCollectionAlgModules::Load()
{
    MYTRACE_ENTER("CAlgController::LoadAll()");

    int nValidAlgLoaded = 0;

	CRegKey KeyEnumISV;
	LONG nError = KeyEnumISV.Open(HKEY_LOCAL_MACHINE, REGKEY_ALG_ISV, KEY_READ|KEY_ENUMERATE_SUB_KEYS);

    if ( ERROR_SUCCESS != nError )
    {
        MYTRACE_ERROR("Could not open RegKey 'HKLM\\SOFTWARE\\Microsoft\\ALG\\ISV'",nError);
        return nError;
    }


	DWORD dwIndex=0;
	TCHAR szID_AlgToLoad[256];
	DWORD dwKeyNameSize;
	LONG  nRet;


	do
	{
		dwKeyNameSize = 256;

		nRet = RegEnumKeyEx(
			KeyEnumISV.m_hKey,      // handle to key to enumerate
			dwIndex,				// subkey index
			szID_AlgToLoad,         // subkey name
			&dwKeyNameSize,         // size of subkey buffer
			NULL,					// reserved
			NULL,					// class string buffer
			NULL,					// size of class string buffer
			NULL					// last write time
			);

		dwIndex++;

        if ( ERROR_NO_MORE_ITEMS == nRet )
            break;  // All items are enumerated we are done here


		if ( ERROR_SUCCESS == nRet )
		{
            //
            // Must be flag as enable under the main ALG/ISV hive to be loaded
            //
            if ( IsAlgModuleEnable(KeyEnumISV, szID_AlgToLoad) )
            {
                MYTRACE("* %S Is 'ENABLE' make sure it's loaded", szID_AlgToLoad);

                AddUniqueAndStart(KeyEnumISV, szID_AlgToLoad);
            }
            else
            {
                MYTRACE("* %S Is 'DISABLE' will not be loaded", szID_AlgToLoad);
            }
		}
        else
        {
            MYTRACE_ERROR("RegEnumKeyEx", nRet);
        }

	} while ( ERROR_SUCCESS == nRet );



	return nValidAlgLoaded;
}
 





//
// For all loaded ALG moudles calls the STOP method and release any resources
//
HRESULT
CCollectionAlgModules::Unload()
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAlgModules::Unload ***");
        MYTRACE("Colletion size is %d", m_ThisCollection.size());

        HRESULT hr;


        LISTOF_ALGMODULE::iterator theIterator;

        while ( m_ThisCollection.size() > 0 )
        {
            theIterator = m_ThisCollection.begin();
            
            delete (*theIterator);

            m_ThisCollection.erase(theIterator);
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionchannels.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionChannels.cpp

Abstract:

    Implement a collection of the CPrimaryControlChannel.cpp & CSecondaryControlChannel
    in a threa safe way.

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "AlgController.h"

#define NAT_PROTOCOL_TCP 0x06
#define NAT_PROTOCOL_UDP 0x11

CCollectionControlChannelsPrimary::~CCollectionControlChannelsPrimary()
{
    RemoveAll();
}



//
// Add a new control channel (Thread safe)
//
HRESULT 
CCollectionControlChannelsPrimary::Add( 
    CPrimaryControlChannel* pChannelToAdd
    )
{
    try
    {
        ENTER_AUTO_CS

        m_ListOfChannels.push_back(pChannelToAdd);
        g_pAlgController->m_CollectionOfAdapters.ApplyPrimaryChannel(pChannelToAdd);
        pChannelToAdd->AddRef();
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// Remove a channel from the list (Thead safe)
//
HRESULT 
CCollectionControlChannelsPrimary::Remove( 
    CPrimaryControlChannel* pChannelToRemove
    )
{
    HRESULT hr = S_OK;

    try
    {
        ENTER_AUTO_CS
        

        LISTOF_CHANNELS_PRIMARY::iterator theIterator = std::find(
            m_ListOfChannels.begin(),
            m_ListOfChannels.end(),
            pChannelToRemove
            );

        if ( *theIterator )
        {
            m_ListOfChannels.erase(theIterator);    // Remove from list

            pChannelToRemove->CancelRedirects();
            pChannelToRemove->Release();
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return hr;
}


//
// Empty the list and free the PrimaryControlChannels
//
HRESULT
CCollectionControlChannelsPrimary::RemoveAll()
{

    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionControlChannelsPrimary::RemoveAll()");

        //
        // By deleting all the ControlChannel they will also cancel all associated Redirects
        //
        MYTRACE("Collection has %d item", m_ListOfChannels.size());

        LISTOF_CHANNELS_PRIMARY::iterator theIterator;

        while ( m_ListOfChannels.size() > 0 )
        {
            theIterator = m_ListOfChannels.begin(); 


            m_ListOfChannels.erase(theIterator);    // Remove from list

            (*theIterator)->CancelRedirects();
            (*theIterator)->Release();

        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    
    return S_OK;
}




//
// Set a dynamic redirection and all collected Primary ControlChannel
//
HRESULT
CCollectionControlChannelsPrimary::SetRedirects(       
    ALG_ADAPTER_TYPE    eAdapterType,
    ULONG               nAdapterIndex,
    ULONG               nAdapterAddress
    )
{
    HRESULT hr=S_OK;

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionControlChannelsPrimary::SetRedirects");
        MYTRACE("AdapterType %d, RealAdapterIndex %d, Currently %d ControlChannel in the collection", eAdapterType, nAdapterIndex, m_ListOfChannels.size());
    


        //
        // Set redirect for all Channel
        //
        for (   LISTOF_CHANNELS_PRIMARY::iterator theIterator = m_ListOfChannels.begin(); 
                theIterator != m_ListOfChannels.end(); 
                theIterator++ 
            )
        {
            (*theIterator)->SetRedirect(    
                eAdapterType,
                nAdapterIndex,
                nAdapterAddress
                );
        }

    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//
// Check to see if the any PrimaryChannel need to be apply or his redirect should be removed
//
HRESULT
CCollectionControlChannelsPrimary::AdapterPortMappingChanged(
    ULONG               nCookie,
    UCHAR               ucProtocol,
    USHORT              usPort
    )
{
    HRESULT hr = S_OK;
    ALG_PROTOCOL algProtocol;

    MYTRACE_ENTER("CCollectionControlChannelsPrimary::AdapterPortMappingChanged");
    MYTRACE("AdapterCookie %d, Protocol %d, Port %d", nCookie, ucProtocol, usPort);

    if (NAT_PROTOCOL_TCP == ucProtocol)
    {
        algProtocol = eALG_TCP;
    }
    else if (NAT_PROTOCOL_UDP == ucProtocol)
    {
        algProtocol = eALG_UDP;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        try
        {
            ENTER_AUTO_CS


            CPrimaryControlChannel *pControlChannel = FindControlChannel(algProtocol, usPort);
            if (NULL != pControlChannel
                && pControlChannel->m_Properties.fCaptureInbound)
            {
                hr = g_pAlgController->m_CollectionOfAdapters.AdapterUpdatePrimaryChannel(
                        nCookie,
                        pControlChannel
                        );
            }
        }
        catch (...)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}





//
// Called when an adapter got removed
// function will cancel any redirect that was done on this adapter index
//
HRESULT
CCollectionControlChannelsPrimary::AdapterRemoved(
    ULONG               nAdapterIndex
    )
{
    HRESULT hr = S_OK;
    MYTRACE_ENTER("CCollectionControlChannelsPrimary::AdapterRemoved");
    MYTRACE("AdapterIndex %d", nAdapterIndex);

    try
    {
        ENTER_AUTO_CS

        //
        // Set redirect for all Channel
        //
        for (   LISTOF_CHANNELS_PRIMARY::iterator theIterator = m_ListOfChannels.begin(); 
                theIterator != m_ListOfChannels.end(); 
                theIterator++ 
            )
        {
            
            (*theIterator)->CancelRedirectsForAdapter(    
                nAdapterIndex
                );
        }

    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}




//
//
// Collection of Secondary control channels
//
//




//
//
//
CCollectionControlChannelsSecondary::~CCollectionControlChannelsSecondary()
{
    RemoveAll();
}



//
// Add a new control channel (Thread safe)
//
HRESULT 
CCollectionControlChannelsSecondary::Add( 
    CSecondaryControlChannel* pChannelToAdd
    )
{
    try
    {
        ENTER_AUTO_CS

        m_ListOfChannels.push_back(pChannelToAdd);
        pChannelToAdd->AddRef();
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// Remove a channel from the list (Thead safe)
//
HRESULT 
CCollectionControlChannelsSecondary::Remove( 
    CSecondaryControlChannel* pChannelToRemove
    )
{
    try
    {
        ENTER_AUTO_CS

        LISTOF_CHANNELS_SECONDARY::iterator theIterator = std::find(
            m_ListOfChannels.begin(),
            m_ListOfChannels.end(),
            pChannelToRemove
            );

        if ( *theIterator )
        {
            m_ListOfChannels.erase(theIterator);    // Remove from list

            pChannelToRemove->CancelRedirects();
            pChannelToRemove->Release();
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// When a Control is cancel it need to Cancel all it's redirect previousely created
//
HRESULT
CCollectionControlChannelsSecondary::RemoveAll()
{
  
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionControlChannelsSecondary::RemoveAll()");

        //
        // By deleting all the SecondaryControlChannel they will also cancel all associated Redirects
        //
        MYTRACE("Collection has %d item", m_ListOfChannels.size());

        LISTOF_CHANNELS_SECONDARY::iterator theIterator;

        while ( m_ListOfChannels.size() > 0 )
        {
            theIterator = m_ListOfChannels.begin(); 

            m_ListOfChannels.erase(theIterator);    // Remove from list

            (*theIterator)->CancelRedirects();
            (*theIterator)->Release();
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionchannels.h ===
//
// Microsoft
//
//

#include "PrimaryControlChannel.h"
#include "SecondaryControlChannel.h"


#include <list>



//
// Free the Channels
//
typedef  std::list<CPrimaryControlChannel*>     LISTOF_CHANNELS_PRIMARY;
typedef  std::list<CSecondaryControlChannel*>   LISTOF_CHANNELS_SECONDARY;





//
//
//
class CCollectionControlChannelsPrimary
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_CHANNELS_PRIMARY                     m_ListOfChannels;



//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionControlChannelsPrimary();
 

    //
    // Add a new control channel (Thread safe)
    //
    HRESULT 
    Add( 
        CPrimaryControlChannel* pChannelToAdd
        );

 
    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT 
    Remove( 
        CPrimaryControlChannel* pChannelToRemove
        );


    //
    // Use to cancel all ControlChannel in the collection and free the list
    //
    HRESULT
    RemoveAll();


    //
    // Set a dynamic redirection and all collected Primary ControlChannel
    //
    HRESULT
    SetRedirects(       
        ALG_ADAPTER_TYPE    eAdapterType,
        ULONG               nAdapterIndex,
        ULONG               nAdapterAddress
        );

    //
    // Called when a port mapping is modified
    //
    HRESULT
    AdapterPortMappingChanged(
        ULONG               nCookie,
        UCHAR               ucProtocol,
        USHORT              usPort
        );

    //
    // Called when an adapter got removed
    // function will cancel any redirect that was done on this adapter index
    //
    HRESULT
    AdapterRemoved(
        ULONG               nAdapterIndex
        );

private:

    CPrimaryControlChannel*
    FindControlChannel(
        ALG_PROTOCOL        eProtocol,
        USHORT              usPort
        )
    {
        for (   LISTOF_CHANNELS_PRIMARY::iterator theIterator = m_ListOfChannels.begin(); 
                theIterator != m_ListOfChannels.end(); 
                theIterator++ 
            )
        {
            CPrimaryControlChannel* pControlChannel = (CPrimaryControlChannel*)(*theIterator);
            if (pControlChannel->m_Properties.eProtocol == eProtocol
                && pControlChannel->m_Properties.usCapturePort == usPort)
            {
                return pControlChannel;
            }
        }

        return NULL;
    };
    

};









//
//
//
class CCollectionControlChannelsSecondary
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_CHANNELS_SECONDARY                   m_ListOfChannels;



//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionControlChannelsSecondary();


    //
    // Add a new control channel (Thread safe)
    //
    HRESULT Add( 
        CSecondaryControlChannel* pChannelToAdd
        );


    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT Remove( 
        CSecondaryControlChannel* pChannelToRemove
        );

    //
    // Use to cancel all ControlChannel in the collection and free the list
    //
    HRESULT
    RemoveAll();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionredirects.h ===
#pragma once


#include "ScopeCriticalSection.h"
#include <list>
#include <algorithm>


class CPrimaryControlChannelRedirect
{
public:
    HANDLE_PTR m_hRedirect;
    ULONG m_nAdapterIndex;
    BOOL m_fInboundRedirect;

    CPrimaryControlChannelRedirect(
        HANDLE_PTR hRedirect,
        ULONG nAdapterIndex,
        BOOL fInboundRedirect
        )
    {
        m_hRedirect = hRedirect;
        m_nAdapterIndex = nAdapterIndex;
        m_fInboundRedirect = fInboundRedirect;
    }

};



typedef  std::list<CPrimaryControlChannelRedirect> LISTOF_REDIRECTS;


//
//
//
class CCollectionRedirects
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;
    LISTOF_REDIRECTS                            m_ListOfRedirects;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionRedirects();


    //
    // Add a new control channel (Thread safe)
    //
    HRESULT Add( 
        HANDLE_PTR hRedirect,
        ULONG nAdapterIndex,
        BOOL fInboundRedirect
        );


    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT Remove( 
        HANDLE_PTR hRedirect    // Redirect handle to remove
        );

    //
    // Remove all redirect that are targeted a for given Adapter
    // this is use when an adapter is removed and it had a PrimaryControlChannel
    //
    HRESULT RemoveForAdapter( 
        ULONG   nAdapterIndex   // Cookie of adapter to remove
        );


    //
    // Same as remove but for all Redirect in part of the collection
    //
    HRESULT
    RemoveAll();

    //
    // Searches for an inbound redirect for this adapter. Returns the
    // redirect handle if found, or NULL if not found.
    //
    HANDLE_PTR
    FindInboundRedirect(
        ULONG nAdapterIndex
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\enumadapterinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CEnumAdapterInfo
//
// EnumAdapterInfo.cpp : Implementation of CEnumAdapterInfo
//

#include "PreComp.h"
#include "EnumAdapterInfo.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\datachannel.h ===
/////////////////////////////////////////////////////////////////////////////
//
// DataChannel.h : Declaration of the CDataChannel
//
// JPDup 2000.12.10

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CDataChannel
//
class ATL_NO_VTABLE CDataChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CDataChannel, &CLSID_DataChannel>,
	public IDataChannel
{
public:
    CDataChannel()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CDataChannel::NEW");

        m_hCreateEvent=NULL;
        m_hDeleteEvent=NULL;
    }


    ~CDataChannel()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CDataChannel::DELETE");

        if ( m_hCreateEvent )
            CloseHandle((HANDLE)m_hCreateEvent);

        if ( m_hDeleteEvent )
            CloseHandle((HANDLE)m_hDeleteEvent);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DATACHANNEL)
DECLARE_NOT_AGGREGATABLE(CDataChannel)


BEGIN_COM_MAP(CDataChannel)
	COM_INTERFACE_ENTRY(IDataChannel)
END_COM_MAP()

//
// IDataChannel
//
public:
	STDMETHODIMP    GetSessionDeletionEventHandle(
        OUT HANDLE* pHandle
        );

	STDMETHODIMP    GetSessionCreationEventHandle(
        OUT HANDLE* pHandle
        );

	STDMETHODIMP    GetChannelProperties(
        OUT ALG_DATA_CHANNEL_PROPERTIES** ppProperties
        );

	STDMETHODIMP    Cancel();


//
// Properties
//
    
    ALG_DATA_CHANNEL_PROPERTIES     m_Properties;

    //
    // Used to cache the last arguments used to create the redirect
    // will be use to cancel the redirect
    //
    ULONG                           m_ulFlags;

    ULONG                           m_ulSourceAddress;
    USHORT                          m_usSourcePort;
    ULONG                           m_ulDestinationAddress;
    USHORT                          m_usDestinationPort;
    ULONG                           m_ulNewSourceAddress;
    USHORT                          m_usNewSourcePort;
    ULONG                           m_ulNewDestinationAddress;
    USHORT                          m_usNewDestinationPort;

    ULONG                           m_ulRestrictAdapterIndex;

    HANDLE                          m_hCreateEvent;
    HANDLE                          m_hDeleteEvent;
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\pendingproxyconnection.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CPendingProxyConnection
//
// PendingProxyConnection.cpp : Implementation of CPendingProxyConnection

#include "PreComp.h"
#include "AlgController.h"
#include "PendingProxyConnection.h"



STDMETHODIMP 
CPendingProxyConnection::Cancel()
{
    MYTRACE_ENTER("CPendingProxyConnection::Cancel()");
    MYTRACE("Protocol       %s", m_eProtocol==1? "TCP" : "UDP");
    MYTRACE("Destination    %s:%d", MYTRACE_IP(m_ulDestinationAddress), ntohs(m_usDestinationPort));
    MYTRACE("Source         %s:%d", MYTRACE_IP(m_ulSourceAddress), ntohs(m_usSourcePort));
    MYTRACE("Destination    %s:%d", MYTRACE_IP(m_ulDestinationAddress), ntohs(m_usDestinationPort));
    MYTRACE("NewSource      %s:%d", MYTRACE_IP(m_ulNewSourceAddress), ntohs(m_usNewSourcePort));


    HRESULT hr = g_pAlgController->GetNat()->CancelRedirect(
	    (UCHAR)m_eProtocol,

	    m_ulDestinationAddress,                              
	    m_usDestinationPort,                                 

	    m_ulSourceAddress,                                   
	    m_usSourcePort,                   

        m_ulDestinationAddress,                              
        m_usDestinationPort,                                 

	    m_ulNewSourceAddress,                                
	    m_usNewSourcePort                                    

        );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("CancelRedirect", hr);
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\enumadapterinfo.h ===
// EnumerateAdapterInfo.h : Declaration of the CAdapterInfo

#pragma once

#include "resource.h"       // main symbols

#include "AdapterInfo.h"


#include <list>

#include "CollectionAdapters.h"


//
// Store the data in a vector of std::strings
//


typedef CComEnumOnSTL<IEnumAdapterInfo, &IID_IEnumAdapterInfo, IAdapterInfo*, _CopyInterface<IAdapterInfo>, LISTOF_ADAPTERS>    ComEnumOnSTL_ForAdapters;





/////////////////////////////////////////////////////////////////////////////
// CEnumAdapterInfo
//
class ATL_NO_VTABLE CEnumAdapterInfo : 
    public ComEnumOnSTL_ForAdapters,
	public CComCoClass<CEnumAdapterInfo, &CLSID_EnumAdapterInfo>
{
public:
	CEnumAdapterInfo()
	{
  	}

DECLARE_REGISTRY_RESOURCEID(IDR_MAPCOLLECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEnumAdapterInfo)
	COM_INTERFACE_ENTRY(IEnumAdapterInfo)
END_COM_MAP()

};



//
// Helper template to create the IEnum
//
template <class EnumType, class CollType>
HRESULT CreateSTLEnumerator(IUnknown** ppUnk, IUnknown* pUnkForRelease, CollType& collection)
{
    if (ppUnk == NULL)
        return E_POINTER;
    *ppUnk = NULL;

    CComObject<EnumType>* pEnum = NULL;
    HRESULT hr = CComObject<EnumType>::CreateInstance(&pEnum);

    if (FAILED(hr))
        return hr;

    hr = pEnum->Init(pUnkForRelease, collection);

    if (SUCCEEDED(hr))
        hr = pEnum->QueryInterface(ppUnk);

    if (FAILED(hr))
        delete pEnum;

    return hr;

} // CreateSTLEnumerator
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\collectionredirects.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionRedirects.cpp

Abstract:

    Implement a thread safe collection of HANDLE

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "CollectionRedirects.h"
#include "AlgController.h"



CCollectionRedirects::~CCollectionRedirects()
{
    MYTRACE_ENTER("CCollectionRedirects::~CCollectionRedirects()");

    RemoveAll();
}



//
// Add a new control channel (Thread safe)
//
HRESULT 
CCollectionRedirects::Add( 
    HANDLE_PTR hRedirect,
    ULONG nAdapterIndex,
    BOOL fInboundRedirect
    )
{
    try
    {
        ENTER_AUTO_CS

        CPrimaryControlChannelRedirect cRedirect(hRedirect, nAdapterIndex, fInboundRedirect);

        MYTRACE_ENTER("CCollectionRedirects::Add");

        m_ListOfRedirects.push_back(cRedirect);
        MYTRACE ("Added %d now Total redirect is %d", hRedirect, m_ListOfRedirects.size());
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// Remove a channel from the list (Thead safe)
//
HRESULT CCollectionRedirects::Remove( 
    HANDLE_PTR hRedirect
    )
{
    HRESULT hr = E_INVALIDARG;
    
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionRedirects::Remove");

        for (LISTOF_REDIRECTS::iterator theIterator = m_ListOfRedirects.begin();
             theIterator != m_ListOfRedirects.end(); 
             theIterator++
            )
        {
            if ((*theIterator).m_hRedirect == hRedirect)
            {
                g_pAlgController->GetNat()->CancelDynamicRedirect(hRedirect);
                m_ListOfRedirects.erase(theIterator);
                hr = S_OK;
                break;
            }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return hr;
}


//
// Remove all redirect that are targeted a for given AdapterIndex
// this is use when an adapter is removed and it had a PrimaryControlChannel
//
HRESULT CCollectionRedirects::RemoveForAdapter( 
    ULONG      nAdapterIndex
    )
{
    HRESULT hr = S_OK;
    
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionRedirects::RemoveForAdapter");
        MYTRACE ("Total redirect is %d looking for %d", m_ListOfRedirects.size(), nAdapterIndex);

        for (LISTOF_REDIRECTS::iterator theIterator = m_ListOfRedirects.begin();
             theIterator != m_ListOfRedirects.end(); 
             theIterator++
            )
        {
	        MYTRACE("Index %d handle %d", (*theIterator).m_nAdapterIndex, (*theIterator).m_hRedirect);

            if ( (*theIterator).m_nAdapterIndex == nAdapterIndex )
            {
                MYTRACE("Found redirect for adapter %d and calling CancelDynamicRedirect", nAdapterIndex);
                g_pAlgController->GetNat()->CancelDynamicRedirect((*theIterator).m_hRedirect);
                m_ListOfRedirects.erase(theIterator);
                theIterator = m_ListOfRedirects.begin(); // start over stl list does not like to have mid node go away in a for loop
            }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return hr;
}


//
// Same as remove but for all Redirect in part of the collection
//
HRESULT
CCollectionRedirects::RemoveAll()
{
    try
    {
 
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionRedirects::RemoveAll");
        MYTRACE("Collection has %d item(s)", m_ListOfRedirects.size());


        LISTOF_REDIRECTS::iterator itRedirect;

        while ( m_ListOfRedirects.size() > 0 )
        {
            itRedirect = m_ListOfRedirects.begin();

            g_pAlgController->GetNat()->CancelDynamicRedirect((*itRedirect).m_hRedirect);
            m_ListOfRedirects.erase(itRedirect);

        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}

HANDLE_PTR
CCollectionRedirects::FindInboundRedirect(
    ULONG nAdapterIndex
    )
{
    HANDLE_PTR hRedirect = NULL;

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionRedirects::FindInboundRedirect");

        for (LISTOF_REDIRECTS::iterator theIterator = m_ListOfRedirects.begin();
             theIterator != m_ListOfRedirects.end(); 
             theIterator++
            )
        {
            if ((*theIterator).m_nAdapterIndex == nAdapterIndex
                && (*theIterator).m_fInboundRedirect == TRUE)
            {
                hRedirect = (*theIterator).m_hRedirect;
                break;
            }
        }
    }
    catch (...)
    {
    }

    return hRedirect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\persistentdatachannel.cpp ===
//
// PersistentDataChannel.cpp : Implementation of CPersistentDataChannel
//
#include "PreComp.h"
#include "PersistentDataChannel.h"
#include "AlgController.h"


/////////////////////////////////////////////////////////////////////////////
//
// CPersistentDataChannel
//



//
// Cancel the associated DynamicRedirect of the PersistenDataChannel
//
STDMETHODIMP CPersistentDataChannel::Cancel()
{
    HRESULT hr = S_OK;

    if ( m_HandleDynamicRedirect )
    {
        hr = g_pAlgController->GetNat()->CancelDynamicRedirect(m_HandleDynamicRedirect);
    }

	return hr;
}



//
// Return the propreties to an ALG Modules
//
STDMETHODIMP CPersistentDataChannel::GetChannelProperties(ALG_PERSISTENT_DATA_CHANNEL_PROPERTIES **ppProperties)
{
    *ppProperties = &m_Properties;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\datachannel.cpp ===
//
// DataChannel.cpp : Implementation of CDataChannel
//
#include "PreComp.h"
#include "DataChannel.h"
#include "AlgController.h"

/////////////////////////////////////////////////////////////////////////////
// CDataChannel


STDMETHODIMP CDataChannel::Cancel()
{
    MYTRACE_ENTER_NOSHOWEXIT("CDataChannel::Cancel()");

    //
    // Normal redirect cancel using original argument pass to CreateRedirect
    //
    HRESULT hr = g_pAlgController->GetNat()->CancelRedirect(
        (UCHAR)m_Properties.eProtocol,
        m_ulDestinationAddress,                             
	    m_usDestinationPort,                               
	    m_ulSourceAddress,                                  
	    m_usSourcePort,
        m_ulNewDestinationAddress,                          
        m_usNewDestinationPort,
	    m_ulNewSourceAddress,                                
	    m_usNewSourcePort 
        );

    return hr;
}

STDMETHODIMP CDataChannel::GetChannelProperties(ALG_DATA_CHANNEL_PROPERTIES** ppProperties)
{
    HRESULT hr = S_OK;
    
    if (NULL != ppProperties)
    {
        *ppProperties = reinterpret_cast<ALG_DATA_CHANNEL_PROPERTIES*>(
            CoTaskMemAlloc(sizeof(ALG_DATA_CHANNEL_PROPERTIES))
            );

        if (NULL != *ppProperties)
        {
            CopyMemory(*ppProperties, &m_Properties, sizeof(ALG_DATA_CHANNEL_PROPERTIES));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;

}


//
// Retrieve the requested event handle. 
// The caller must call CloseHandle on this handle.
// This routine will fail if session creation notification was not requested.
//
// Notification will be triggered when the Channel is open (TCP)
// or when the first UDP packet are received
//
STDMETHODIMP CDataChannel::GetSessionCreationEventHandle(HANDLE* pHandle)
{
    MYTRACE_ENTER("CDataChannel::GetSessionCreationEventHandle");

    if ( pHandle == NULL )
        return E_INVALIDARG;

    if ( !m_hCreateEvent )
        return E_FAIL;

    if ( DuplicateHandle(
            GetCurrentProcess(),
            m_hCreateEvent,
            GetCurrentProcess(),
            pHandle,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            )
        )
    {
        MYTRACE("Duplicated handle from %d to new %d", m_hCreateEvent, *pHandle);
    }
    else
    {

        MYTRACE_ERROR("Duplicating handle", 0);
        return E_FAIL;
    }
    return S_OK;
}


//
// Retrieve the requested event handle. 
// The caller must call CloseHandle on this handle.
// This routine will fail if session deletion notification was not requested.
//
// Notification will be triggered when the Channel is close
// or when UDP packet are now reveice for a period of time.
//
STDMETHODIMP CDataChannel::GetSessionDeletionEventHandle(HANDLE* pHandle)
{
    MYTRACE_ENTER("CDataChannel::GetSessionDeletionEventHandle");

    if ( pHandle == NULL )
        return E_INVALIDARG;

    if ( !m_hDeleteEvent )
        return E_FAIL;

    if ( DuplicateHandle(
            GetCurrentProcess(),
            m_hDeleteEvent,
            GetCurrentProcess(),
            pHandle,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            )
        )
    {
        MYTRACE("Duplicated handle from %d to new %d", m_hDeleteEvent, *pHandle);
    }
    else
    {
        MYTRACE_ERROR("Duplicating handle", 0);
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\persistentdatachannel.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  PersistentDataChannel.h : Declaration of the CPersistentDataChannel
//
//
//  JPDup   2000.12.10
//

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
//
// CPersistentDataChannel
//
class ATL_NO_VTABLE CPersistentDataChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CPersistentDataChannel, &CLSID_PersistentDataChannel>,
	public IPersistentDataChannel
{

public:

	CPersistentDataChannel()
	{
        m_HandleDynamicRedirect=NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PERSISTENTDATACHANNEL)
DECLARE_NOT_AGGREGATABLE(CPersistentDataChannel)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPersistentDataChannel)
	COM_INTERFACE_ENTRY(IPersistentDataChannel)
END_COM_MAP()

//
// IPersistentDataChannel
//
public:
	STDMETHODIMP    GetChannelProperties(
        OUT ALG_PERSISTENT_DATA_CHANNEL_PROPERTIES ** ppProperties
        );

	STDMETHODIMP    Cancel();

//
// Properties
//
    ALG_PERSISTENT_DATA_CHANNEL_PROPERTIES  m_Properties;
    HANDLE_PTR                              m_HandleDynamicRedirect;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\pendingproxyconnection.h ===
/////////////////////////////////////////////////////////////////////////////
//
// PendingProxyConnection.h : Declaration of the CPendingProxyConnection
//

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CPendingProxyConnection
//
class ATL_NO_VTABLE CPendingProxyConnection : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPendingProxyConnection, &CLSID_PendingProxyConnection>,
	public IPendingProxyConnection
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_PENDINGPROXYCONNECTION)
DECLARE_NOT_AGGREGATABLE(CPendingProxyConnection)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPendingProxyConnection)
	COM_INTERFACE_ENTRY(IPendingProxyConnection)
END_COM_MAP()

//
// IPendingProxyConnection
//
public:
	STDMETHODIMP    Cancel();


//
// Properties
//
public:

    ALG_PROTOCOL				m_eProtocol;
    
	ULONG						m_ulDestinationAddress;
	USHORT						m_usDestinationPort;

    ULONG						m_ulSourceAddress;
	USHORT						m_usSourcePort;

    ULONG						m_ulNewSourceAddress;
	USHORT						m_usNewSourcePort;

    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\primarycontrolchannel.h ===
// PrimaryControlChannel.h : Declaration of the CPrimaryControlChannel

#pragma once


#include "CollectionRedirects.h"

#include "resource.h"       // main symbols
#include <list>



/////////////////////////////////////////////////////////////////////////////
// CPrimaryControlChannel
class ATL_NO_VTABLE CPrimaryControlChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CPrimaryControlChannel, &CLSID_PrimaryControlChannel>,
	public IPrimaryControlChannel
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PRIMARYCONTROLCHANNEL)
DECLARE_NOT_AGGREGATABLE(CPrimaryControlChannel)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPrimaryControlChannel)
	COM_INTERFACE_ENTRY(IPrimaryControlChannel)
END_COM_MAP()


//
// IPrimaryControlChannel - Methods
//
public:
	STDMETHODIMP    Cancel();

	STDMETHODIMP    GetChannelProperties(
        ALG_PRIMARY_CHANNEL_PROPERTIES ** ppProperties
        );

    STDMETHODIMP    GetOriginalDestinationInformation(
	    ULONG				ulSourceAddress, 
	    USHORT				usSourcePort, 
	    ULONG *				pulOriginalDestinationAddress, 
	    USHORT *			pusOriginalDestinationPort, 
	    IAdapterInfo **		ppReceiveAdapter
	    );


//
// Methods not part of the Interface
//


    // Set the redirect and return the hCookie associated with the new redirect
    HRESULT      
    SetRedirect(
        ALG_ADAPTER_TYPE    eAdapterType,
        ULONG               nAdapterIndex,
        ULONG               nAdapterAddress
        );  

    //
    HRESULT
    CancelRedirects()
    {
        return m_CollectionRedirects.RemoveAll();
    }

    //
    HRESULT
    CancelRedirectsForAdapter(
        ULONG               nAdapterIndex
        );

    HRESULT
    CreateInboundRedirect(
        ULONG               nAdapterIndex
        );

//
// Properties
//
    ALG_PRIMARY_CHANNEL_PROPERTIES  m_Properties;

    CCollectionRedirects            m_CollectionRedirects;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//

#pragma once


#define STRICT


#define _ATL_FREE_THREADED

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>




#include "ALG.h"            // From Publish\IDLOLE
#include "ALG_Private.h"	// From ALG\IDL_Private publish in NT\net\inc


//
// Tracing routines
//
#include "MyTrace.h"

#include <ipnatapi.h>


#include "resource.h"
#define REGKEY_ALG_ISV      TEXT("SOFTWARE\\Microsoft\\ALG\\ISV")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\scopecriticalsection.h ===
#pragma once

//
// This is a generic class that wraps a given CComAutoCriticalSection
//
class CScopeCriticalSection
{

private:
	CComAutoCriticalSection* m_pCriticalSection;

public:
	CScopeCriticalSection(CComAutoCriticalSection* pNewCS) : 
      m_pCriticalSection(pNewCS) 
    {
        Lock();
    }

	~CScopeCriticalSection() 
    {
        Unlock();
    }

    void
    inline Lock()
    {
        m_pCriticalSection->Lock();
    }


    void
    inline Unlock()
    {
        m_pCriticalSection->Unlock();
    }

};


#define ENTER_AUTO_CS CScopeCriticalSection _ScopeAutoCriticalSection(&m_AutoCS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ALG.rc
//
#define IDS_PROJNAME                    100
#define IDR_ALG                         100
#define IDR_ALGCONTROLLER               101
#define IDR_APPLICATIONGATEWAYSERVICES  102
#define IDR_PRIMARYCONTROLCHANNEL       103
#define IDR_SECONDARYCONTROLCHANNEL     104
#define IDR_ADAPTERINFO                 105
#define IDR_PENDINGPROXYCONNECTION      106
#define IDR_DATACHANNEL                 107
#define IDR_PERSISTENTDATACHANNEL       108
#define IDR_ADAPTERNOTIFICATIONSINK     109
#define IDR_CONTROLCHANNEL              110
#define IDR_MAPCOLLECTION               111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\secondarycontrolchannel.h ===
// SecondaryControlChannel.h : Declaration of the CSecondaryControlChannel

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CSecondaryControlChannel
class ATL_NO_VTABLE CSecondaryControlChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CSecondaryControlChannel, &CLSID_SecondaryControlChannel>,
	public ISecondaryControlChannel
{
public:
	CSecondaryControlChannel()
	{
        m_HandleDynamicRedirect = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SECONDARYCONTROLCHANNEL)
DECLARE_NOT_AGGREGATABLE(CSecondaryControlChannel)


BEGIN_COM_MAP(CSecondaryControlChannel)
	COM_INTERFACE_ENTRY(ISecondaryControlChannel)
END_COM_MAP()

// ISecondaryControlChannel
public:


	STDMETHODIMP    Cancel();

	STDMETHODIMP    GetChannelProperties(
        ALG_SECONDARY_CHANNEL_PROPERTIES ** ppProperties
        );

    STDMETHODIMP    GetOriginalDestinationInformation(
	    ULONG				ulSourceAddress, 
	    USHORT				usSourcePort, 
	    ULONG *				pulOriginalDestinationAddress, 
	    USHORT *			pusOriginalDestinationPort, 
	    IAdapterInfo **		ppReceiveAdapter
	    );

//
// Methods
//
    HRESULT         CancelRedirects();

//
// Properties
//

    ALG_SECONDARY_CHANNEL_PROPERTIES    m_Properties;

    

    // Cache original argument of the redirect


    // Dynamic Redirect
    HANDLE_PTR                          m_HandleDynamicRedirect;

    // None dynamic redirect
    ULONG                               m_ulDestinationAddress;
    USHORT                              m_usDestinationPort;       

    ULONG                               m_ulSourceAddress;         
    USHORT                              m_usSourcePort;

    ULONG                               m_ulNewDestinationAddress; 
    USHORT                              m_usNewDestinationPort;    

    ULONG                               m_ulNewSourceAddress;      
    USHORT                              m_usNewSourcePort;



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\secondarycontrolchannel.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CSecondaryControlChannel
//
// SecondaryControlChannel.cpp : Implementation of CSecondaryControlChannel
//

#include "PreComp.h"
#include "AlgController.h"
#include "SecondaryControlChannel.h"







//
// Cancel the redirect when it was created we stored the original demanded addresses & ports
// now we need to reverse(Cancel) them
//
STDMETHODIMP 
CSecondaryControlChannel::Cancel()
{
    //
    // By removing this Channel from the collection of SecondaryChannel
    // the Redirect associated with this channel will be cancel(release)
    // and ref count decrement.

    return g_pAlgController->m_ControlChannelsSecondary.Remove(this);
}



STDMETHODIMP 
CSecondaryControlChannel::GetChannelProperties(
    ALG_SECONDARY_CHANNEL_PROPERTIES** ppProperties
    )
{
    HRESULT hr = S_OK;
    
    if (NULL != ppProperties)
    {
        *ppProperties = reinterpret_cast<ALG_SECONDARY_CHANNEL_PROPERTIES*>(
            CoTaskMemAlloc(sizeof(ALG_SECONDARY_CHANNEL_PROPERTIES))
            );

        if (NULL != *ppProperties)
        {
            CopyMemory(*ppProperties, &m_Properties, sizeof(ALG_SECONDARY_CHANNEL_PROPERTIES));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}



//
//
//
STDMETHODIMP 
CSecondaryControlChannel::GetOriginalDestinationInformation(
    IN           ULONG          ulSourceAddress, 
    IN           USHORT         usSourcePort, 
    OUT          ULONG*         pulOriginalDestinationAddress, 
    OUT          USHORT*        pusOriginalDestinationPort, 
    OUT OPTIONAL IAdapterInfo** ppReceiveAdapter               
    )
{
    MYTRACE_ENTER("CSecondaryControlChannel::GetOriginalDestinationInformation");

    if (    pulOriginalDestinationAddress==NULL ||
            pusOriginalDestinationPort== NULL
        )
    {
        MYTRACE_ERROR("Invalid argument pass pulOriginalDestinationAddress or pulOriginalDestinationPort", E_INVALIDARG);
        return E_INVALIDARG;
    }


    ULONG   nAdapterCookie;

    HRESULT hr = g_pAlgController->GetNat()->GetOriginalDestinationInformation(
        m_Properties.eProtocol,
        m_ulNewDestinationAddress,
        m_usNewDestinationPort,
        ulSourceAddress,
        usSourcePort,
        pulOriginalDestinationAddress, 
        pusOriginalDestinationPort,
        &nAdapterCookie
        );



    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("GetNat()->GetOriginalDestinationInformation", hr);
        return hr;
    }


    if ( ppReceiveAdapter )
    {
        hr = g_pAlgController->m_CollectionOfAdapters.GetAdapterInfo(
            nAdapterCookie, 
            ppReceiveAdapter
            );
    }

    return hr;

}




//
// Public method
// 
// release associated Redirects
//
HRESULT    
CSecondaryControlChannel::CancelRedirects()
{
    HRESULT hr;

    if ( m_HandleDynamicRedirect )
    {
        //
        // We have a handle to a dynamic redirect so we cancel it using this handle
        //
        hr = g_pAlgController->GetNat()->CancelDynamicRedirect(m_HandleDynamicRedirect);
    }
    else
    {
        //
        // Normal redirect cancel using original argument pass to CreateRedirect
        //
        hr = g_pAlgController->GetNat()->CancelRedirect(
            (UCHAR)m_Properties.eProtocol,
            m_ulDestinationAddress,                             
            m_usDestinationPort,                               
            m_ulSourceAddress,                                  
            m_usSourcePort,
            m_ulNewDestinationAddress,                          
            m_usNewDestinationPort,
            m_ulNewSourceAddress,                                
            m_usNewSourcePort 
            );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\primarycontrolchannel.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    PrimaryControlChannel.cpp.cpp

Abstract:

    Control channel a created to control the life time of a newly created DynamicRedirection

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "PrimaryControlChannel.h"
#include "AlgController.h"



/////////////////////////////////////////////////////////////////////////////
//
// CPrimaryControlChannel
//



//
// Cancel the control channel. Cleans up by Reversing the Redirection
//
STDMETHODIMP CPrimaryControlChannel::Cancel()
{
    MYTRACE_ENTER("STDMETHODIMP CPrimaryControlChannel::Cancel()");


    //
    // No longer valid so no need to keep track of this Channel
    //
    g_pAlgController->m_ControlChannelsPrimary.Remove(this);

    return S_OK;
}



//
//
//
STDMETHODIMP 
CPrimaryControlChannel::GetChannelProperties(
    OUT ALG_PRIMARY_CHANNEL_PROPERTIES** ppProperties
    )
{
    HRESULT hr = S_OK;
    
    if (NULL != ppProperties)
    {
        *ppProperties = reinterpret_cast<ALG_PRIMARY_CHANNEL_PROPERTIES*>(
            CoTaskMemAlloc(sizeof(ALG_PRIMARY_CHANNEL_PROPERTIES))
            );

        if (NULL != *ppProperties)
        {
            CopyMemory(*ppProperties, &m_Properties, sizeof(ALG_PRIMARY_CHANNEL_PROPERTIES));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}





//
// Small helper class to get the IP address of an adapter 
// and release the memory allocated on the destructor
//
class CAdapterAddresses
{
public:
    LRESULT         m_hResultLastState;
    IAdapterInfo*   m_pIAdapter;
    ULONG           m_ulAddressCount;
    ULONG*          m_arAddresses;

    CAdapterAddresses(
        ULONG nIndexOfAdapter
        )
    {
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterAddresses:NEW");

        m_pIAdapter      = NULL;
        m_ulAddressCount = 0;

        m_hResultLastState = g_pAlgController->m_CollectionOfAdapters.GetAdapterInfo(
            nIndexOfAdapter, 
            &m_pIAdapter
            );

        if ( SUCCEEDED(m_hResultLastState) )
        {
            m_arAddresses = NULL;
            m_hResultLastState = m_pIAdapter->GetAdapterAddresses(
                &m_ulAddressCount, 
                &m_arAddresses
                );

            if ( FAILED(m_hResultLastState) )
            {
                MYTRACE_ERROR("Could not get the address", m_hResultLastState);
            }
        }
        else
        {
            MYTRACE_ERROR("On GetAdapterInfo", m_hResultLastState);
        }
    }

    ~CAdapterAddresses()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterAddresses:DELETE");
        if ( m_pIAdapter )
        {
            m_pIAdapter->Release();

            if ( m_arAddresses )
                CoTaskMemFree(m_arAddresses);
        }
    }

    bool
    FindAddress(
        ULONG  ulAddressToFind
        )
    {
        int nAddress = (int)m_ulAddressCount;

        //
        // Is the original address on the edgebox adapter
        //
        while ( --nAddress >= 0 ) 
        {   
            if ( m_arAddresses[nAddress] == ulAddressToFind )
                return true;
        }
        
        return false;
    }
};



//
//
//
STDMETHODIMP 
CPrimaryControlChannel::GetOriginalDestinationInformation(
    IN           ULONG              ulSourceAddress, 
    IN           USHORT             usSourcePort, 
    OUT          ULONG*             pulOriginalDestinationAddress, 
    OUT          USHORT*            pusOriginalDestinationPort, 
    OUT          IAdapterInfo**     ppReceiveAdapter               
    )
{
    MYTRACE_ENTER("CPrimaryControlChannel::GetOriginalDestinationInformation");
    MYTRACE("Source                   %s:%d", MYTRACE_IP(ulSourceAddress), ntohs(usSourcePort));

    if ( !ppReceiveAdapter )
    {
        MYTRACE_ERROR("Invalid Arg no Pointer supplied for the AdapterInfo", E_INVALIDARG);
        return E_INVALIDARG;
    }

    ULONG   nAdapterIndex;


    HRESULT hr = g_pAlgController->GetNat()->GetOriginalDestinationInformation(
        m_Properties.eProtocol,

        m_Properties.ulListeningAddress,    //  ULONG   DestinationAddress,
        m_Properties.usListeningPort,       //  USHORT  DestinationPort,

        ulSourceAddress,
        usSourcePort,

        pulOriginalDestinationAddress, 
        pusOriginalDestinationPort,
        &nAdapterIndex
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Could not GetNat()->GetOriginalDestinationInformation", hr);
        return hr;
    }

    MYTRACE("Original destination is  %s:%d", MYTRACE_IP(*pulOriginalDestinationAddress), ntohs(*pusOriginalDestinationPort));

    //
    // Get the AdapterInfo interface object and list of IP Address
    //
    CAdapterAddresses Adapter(nAdapterIndex);

    if ( FAILED(Adapter.m_hResultLastState) )
    {
        MYTRACE_ERROR("On GetAdapterInfo", hr);
        return Adapter.m_hResultLastState;
    }

    if ( Adapter.m_ulAddressCount==0 )
    {
        //
        // We have a problem there is no IP address on this adapter
        // 
        MYTRACE_ERROR("No address on adapter %d", nAdapterIndex);
        return E_FAIL;
    }

    //
    // Return the AdapterInfo to the caller
    //
    Adapter.m_pIAdapter->AddRef();              // The destructor of CAdapterAddress does a release on this interface so we need to pump it up by one
    *ppReceiveAdapter = Adapter.m_pIAdapter;   



    bool bOriginalAddressIsOnTheEdgeAdapters = Adapter.FindAddress(*pulOriginalDestinationAddress);
        
    //
    // if pulOriginalDestinationAddress match one of the adapter on the edge box
    // then lookup for a remap port
    //
    if ( bOriginalAddressIsOnTheEdgeAdapters )
    {

        //
        // This may be an inbound
        //
        ULONG   nRemapAddress;
        USHORT  nRemapPort;

        HRESULT hr = g_pAlgController->GetNat()->LookupAdapterPortMapping(
            nAdapterIndex,
            m_Properties.eProtocol, 
            *pulOriginalDestinationAddress,
            *pusOriginalDestinationPort,
            &nRemapAddress,
            &nRemapPort
            );

        if ( SUCCEEDED(hr) )  
        {
            //
            // Theres a remap address/Port
            //

            *pulOriginalDestinationAddress = nRemapAddress;
            *pusOriginalDestinationPort    = nRemapPort;
            
            MYTRACE("Remap    destination to  %s:%d", MYTRACE_IP(*pulOriginalDestinationAddress), ntohs(*pusOriginalDestinationPort));        
        }
        else
        {
            //
            // This is just a soft error meaning no mapping where found we can still continue
            //
            MYTRACE("LookupAdapterPortMapping did not find a port maping %x", hr);        
        }
    }


    return hr;
}



//
// Need to remove any redirect that was set for this Adapter
//
HRESULT
CPrimaryControlChannel::CancelRedirectsForAdapter(
    ULONG               nAdapterIndex
    )
{
    return m_CollectionRedirects.RemoveForAdapter(nAdapterIndex);
}



//
//
//
HRESULT
CPrimaryControlChannel::SetRedirect(
    ALG_ADAPTER_TYPE    eAdapterType,
    ULONG               nAdapterIndex,
    ULONG               nAdapterAddress
    )
{
    MYTRACE_ENTER("CPrimaryControlChannel::SetRedirect");
            

    HANDLE_PTR  hCookie;
    HRESULT     hr=S_OK;

    ULONG       nFlags=NatRedirectFlagPortRedirect|NatRedirectFlagRestrictAdapter;
    ULONG       nProtocol=0;
    ULONG       nDestinationAddress=0;
    USHORT      nDestinationPort=0;
    ULONG       nSourceAddress=0;
    USHORT      nSourcePort=0;



    //
    // What type of port is supplied
    //
    if ( m_Properties.eCaptureType == eALG_DESTINATION_CAPTURE )
    {
        MYTRACE("CAPTURE TYPE is eALG_DESTINATION_CAPTURE");

        nDestinationPort    = m_Properties.usCapturePort;
    }

    if ( m_Properties.eCaptureType == eALG_SOURCE_CAPTURE )
    {
        MYTRACE("CAPTURE TYPE is eALG_SOURCE_CAPTURE");

        nFlags |= NatRedirectFlagSourceRedirect;

        nSourcePort         = m_Properties.usCapturePort;
    }






    //
    // ADAPTER IS FIREWALL or SHARED
    //
    if ( (eAdapterType & eALG_FIREWALLED) ||  (eAdapterType & eALG_BOUNDARY) )
    {
        nFlags |= NatRedirectFlagSendOnly;

        MYTRACE("ADAPTER TYPE is %s %s", 
            eAdapterType & eALG_FIREWALLED ? "FIREWALLED"   : "", 
            eAdapterType & eALG_BOUNDARY   ? "SHARED"       : ""  
            );
        MYTRACE("Destination    %s:%d",     MYTRACE_IP(nDestinationAddress), ntohs(nDestinationPort));
        MYTRACE("Source         %s:%d",     MYTRACE_IP(nSourceAddress), ntohs(nSourcePort));
        MYTRACE("NewDestination %s:%d",     MYTRACE_IP(m_Properties.ulListeningAddress), ntohs(m_Properties.usListeningPort));

        //
        // INBOUND Additional Redirect needed
        //
        if ( m_Properties.fCaptureInbound == TRUE)
        {
            MYTRACE("INBOUND requested - Lookup Remap port service to see if we should allow it");

            //
            // Create an additional Redirect for inbound from the Public side to the ICS box
            //

            //
            // before we allow the redirection 
            // See if a maping was set by the user ("under the SERVICE Tab of ICS")
            // 
            ULONG   nRemapAddress;
            USHORT  nRemapPort;

            hr = g_pAlgController->GetNat()->LookupAdapterPortMapping(
                    nAdapterIndex,
                    m_Properties.eProtocol, 
                    nDestinationAddress,
                    nDestinationPort,
                    &nRemapAddress,
                    &nRemapPort
                    );

            if ( SUCCEEDED(hr) )
            {
                MYTRACE("RemapAddress is %s:%d", MYTRACE_IP(nRemapAddress), ntohs(nRemapPort));

                hr = CreateInboundRedirect(nAdapterIndex);
            }
            else
            {
                MYTRACE_ERROR("LookupPortMappingAdapter Failed", hr);
            }

        }

    }
    else
    {
        //
        // ADAPTER IS PRIVATE
        //
        if ( eAdapterType & eALG_PRIVATE )
        {
            MYTRACE("ADAPTER TYPE is PRIVATE");

            CAdapterAddresses PrivateAdapter(nAdapterIndex);

            if ( PrivateAdapter.m_ulAddressCount > 0 )
            {
                MYTRACE("Create Shadow redirect between any private computers to private adapter %s", MYTRACE_IP(PrivateAdapter.m_arAddresses[0]) );
                
                hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
                        NatRedirectFlagReceiveOnly,
                        nAdapterIndex,
                        (UCHAR)    m_Properties.eProtocol,
                        PrivateAdapter.m_arAddresses[0],                    // ULONG    DestinationAddress, 
                        nDestinationPort,                                   // USHORT   DestinationPort,       
                        0,                                                  // ULONG    SourceAddress, 
                        0,                                                  // USHORT    SourcePort,            
                        PrivateAdapter.m_arAddresses[0],                    // ULONG    NewDestinationAddress
                        nDestinationPort,                                   // USHORT   NewDestinationPort
                        0,                                                  // ULONG    NewSourceAddress, 
                        0,                                                  // USHORT    NewSourcePort, 
                        &hCookie
                        );
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_CollectionRedirects.Add(hCookie, nAdapterIndex, FALSE); // Cache the Dynamic redirect Handle            
            }
            else
            {
                MYTRACE_ERROR("Failed to createDynamicRedirect PRIVATE", hr);
            }



            nFlags |= NatRedirectFlagReceiveOnly;

            if ( m_Properties.eCaptureType == eALG_SOURCE_CAPTURE )
            {
                nFlags |= NatRedirectFlagSourceRedirect;
            }
        }
    }


    MYTRACE("CreateDynamicRedirect for OUTBOUND");
    hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
            nFlags,
            nAdapterIndex,
            (UCHAR)    m_Properties.eProtocol,
            nDestinationAddress,                                // ULONG    DestinationAddress, 
            nDestinationPort,                                   // USHORT   DestinationPort,       
            nSourceAddress,                                     // ULONG    SourceAddress, 
            nSourcePort,                                        // USHORT    SourcePort,            
            m_Properties.ulListeningAddress,                    // ULONG    NewDestinationAddress
            m_Properties.usListeningPort,                       // USHORT   NewDestinationPort
            0,                                                  // ULONG    NewSourceAddress, 
            0,                                                  // USHORT    NewSourcePort, 
            &hCookie
            );


    if ( SUCCEEDED(hr) )
    {
        hr = m_CollectionRedirects.Add(hCookie, nAdapterIndex, FALSE); // Cache the Dynamic redirect Handle            
    }
    else
    {
        MYTRACE_ERROR("Failed to createDynamicRedirect PRIVATE", hr);
    }

    return hr;
}

HRESULT
CPrimaryControlChannel::CreateInboundRedirect(
    ULONG               nAdapterIndex
    )
{
    HRESULT hr;
    HANDLE_PTR hCookie;

    MYTRACE_ENTER("CPrimaryControlChannel::SetRedirect");
    
    hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
            NatRedirectFlagPortRedirect|NatRedirectFlagReceiveOnly|NatRedirectFlagRestrictAdapter, 
            nAdapterIndex,
            (UCHAR)m_Properties.eProtocol,
            0,                                                  // ULONG    DestinationAddress, 
            m_Properties.usCapturePort,                         // USHORT   DestinationPort,        
            0,                                                  // ULONG    SourceAddress, 
            0,                                                  // USHORT   SourcePort,
            m_Properties.ulListeningAddress,                    // ULONG    NewDestinationAddress
            m_Properties.usListeningPort,                       // USHORT   NewDestinationPort
            0,                                                  // ULONG    NewSourceAddress, 
            0,                                                  // USHORT   NewSourcePort, 
            &hCookie
            );

    if ( SUCCEEDED(hr) )
    {
        hr = m_CollectionRedirects.Add(hCookie, nAdapterIndex, TRUE);  // Cache the Dynamic redirect Handle
    }
    else
    {
        MYTRACE_ERROR("Failed to CreateDynamicRedirect INBOUND", hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\exe\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Application Layer Gateway Service"
#define VER_INTERNALNAME_STR            "ALG.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\beacon.cpp ===
#include "beacon.h"

CInternetGateway::CInternetGateway()
{
    m_MediaType = NCM_NONE;
    ZeroMemory(&m_LocalAdapterGUID, sizeof(m_LocalAdapterGUID));
    ZeroMemory(&m_Services, sizeof(m_Services));
    m_UniqueDeviceName = NULL;
}

HRESULT CInternetGateway::FinalRelease()
{
    for(int i = 0; i < SAHOST_SERVICE_MAX; i++)
    {
        if(NULL != m_Services[i])
        {
            m_Services[i]->Release();
        }
    }

    SysFreeString(m_UniqueDeviceName);

    return S_OK;
}

HRESULT CInternetGateway::SetMediaType(NETCON_MEDIATYPE MediaType)
{
    m_MediaType = MediaType;
    return S_OK;
}

HRESULT CInternetGateway::SetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(&m_LocalAdapterGUID, pGuid, sizeof(GUID));
    return S_OK;
}

HRESULT CInternetGateway::SetService(ULONG ulService, IUPnPService* pService)
{
    HRESULT hr = S_OK;
    if(SAHOST_SERVICE_MAX > ulService && NULL == m_Services[ulService])
    {
        m_Services[ulService] = pService;
        pService->AddRef();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CInternetGateway::SetUniqueDeviceName(BSTR UniqueDeviceName)
{
    HRESULT hr = S_OK;

    m_UniqueDeviceName = SysAllocString(UniqueDeviceName);
    if(NULL == m_UniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CInternetGateway::GetMediaType(NETCON_MEDIATYPE* pMediaType)
{
    *pMediaType = m_MediaType;    
    return S_OK;
}

HRESULT CInternetGateway::GetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(pGuid, &m_LocalAdapterGUID, sizeof(GUID));
    return S_OK;
}

HRESULT CInternetGateway::GetService(SAHOST_SERVICES ulService, IUPnPService** ppService)
{
    HRESULT hr = S_OK;

    *ppService = NULL;

    if(SAHOST_SERVICE_MAX > ulService)
    {
        *ppService = m_Services[ulService];
        if(NULL != *ppService)
        {
            (*ppService)->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CInternetGateway::GetUniqueDeviceName(BSTR* pUniqueDeviceName)
{
    HRESULT hr = S_OK;

    *pUniqueDeviceName = SysAllocString(m_UniqueDeviceName);
    if(NULL == *pUniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\beacon.h ===
#pragma once

#include "stdafx.h"
#include "netconp.h"

class ATL_NO_VTABLE CInternetGateway :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IInternetGateway
{

public:
    BEGIN_COM_MAP(CInternetGateway)
        COM_INTERFACE_ENTRY(IInternetGateway)
    END_COM_MAP()
    
    CInternetGateway();
    
    // IInternetGateway
    STDMETHODIMP GetMediaType(NETCON_MEDIATYPE* pMediaType);
    STDMETHODIMP GetLocalAdapterGUID(GUID* pGuid);
    STDMETHODIMP GetService(SAHOST_SERVICES ulService, IUPnPService**);
    STDMETHODIMP GetUniqueDeviceName(BSTR* pUniqueDeviceName);

    HRESULT SetMediaType(NETCON_MEDIATYPE MediaType);
    HRESULT SetLocalAdapterGUID(GUID* pGuid);
    HRESULT SetService(ULONG ulService, IUPnPService* pService);
    HRESULT SetUniqueDeviceName(BSTR UniqueDeviceName);
    HRESULT FinalRelease();
private:
    
    NETCON_MEDIATYPE m_MediaType;
    GUID m_LocalAdapterGUID;
    IUPnPService* m_Services[SAHOST_SERVICE_MAX];
    BSTR m_UniqueDeviceName;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__9B23B3D8_8B85_4FDF_BC3E_83D5A56E02C0__INCLUDED_)
#define AFX_DLLDATAX_H__9B23B3D8_8B85_4FDF_BC3E_83D5A56E02C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__9B23B3D8_8B85_4FDF_BC3E_83D5A56E02C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\client.cpp ===
#include "stdafx.h"
#include <windows.h>
#include "client.h"
#include "trayicon.h"
#include "resource.h"
#include "util.h"
#include "shellapi.h"
#include "winsock2.h"


static const LPTSTR g_szWindowTitle = TEXT("Internet Gateway Status");
static const LPWSTR g_szWANIPConnectionService = L"urn:schemas-upnp-org:service:WANIPConnection:1";
static const LPWSTR g_szWANPPPConnectionService = L"urn:schemas-upnp-org:service:WANPPPConnection:1";

void CALLBACK ICSClient(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;

    // first see if app is already running and if so activate status window
    
    HWND hExistingWindow = FindWindow(NULL, g_szWindowTitle); // check only current winstation, every login session can have an instance
    if(NULL != hExistingWindow)
    {
        if(0 == lstrcmp(lpszCmdLine, TEXT("/force"))) // secret command line to close existing instance and run new one instead
        {
            ::PostMessage(hExistingWindow, WM_CLOSE, NULL, NULL);
        }
        else if(0 == lstrcmp(lpszCmdLine, TEXT("/close"))) // secret command line to close existing instance 
        {
            ::PostMessage(hExistingWindow, WM_CLOSE, NULL, NULL);
            hr = E_FAIL;
        }
        else
        {
            DWORD dwProcessId = NULL;
            GetWindowThreadProcessId(hExistingWindow, &dwProcessId); // no documented error return
            
            HMODULE hUser32 = GetModuleHandle(TEXT("user32.dll"));
            if(NULL != hUser32)
            {
                BOOL (WINAPI *pAllowSetForegroundWindow)(DWORD);
                
                pAllowSetForegroundWindow = reinterpret_cast<BOOL (WINAPI*)(DWORD)>(GetProcAddress(hUser32, "AllowSetForegroundWindow"));
                if(NULL != pAllowSetForegroundWindow)
                {
                    pAllowSetForegroundWindow(dwProcessId);
                }
            }
            
            ::PostMessage(hExistingWindow, WM_COMMAND, IDM_TRAYICON_STATUS, NULL);
            hr = E_FAIL;
        }
    }
    
    // if this is first instance then start up the main apartment
    
    if(SUCCEEDED(hr))
    {
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if(SUCCEEDED(hr))
        {
            WSADATA SocketVersionData;
            if(0 == WSAStartup(MAKEWORD(2,2), &SocketVersionData))
            {
            
                CICSTrayIcon TrayIcon;
                HWND hWindow = TrayIcon.Create(NULL, CWindow::rcDefault, g_szWindowTitle, WS_OVERLAPPEDWINDOW);
                if(NULL != hWindow)
                {
                    BOOL bGetMessage;
                    MSG Message;
                    while(bGetMessage = GetMessage(&Message, NULL, 0, 0) && -1 != bGetMessage)
                    {
                        DispatchMessage(&Message);
                    }
                }
                WSACleanup();
            }
            CoUninitialize();
        }
    }
    return;
}

CBeaconFinder::CBeaconFinder()
{
    m_hCallbackWindow = NULL;
}

HRESULT CBeaconFinder::Initialize(HWND hCallbackWindow)
{
    HRESULT hr = S_OK;
    
    m_hCallbackWindow = hCallbackWindow;
    
    return hr;
}

HRESULT CBeaconFinder::DeviceAdded(LONG lFindData, IUPnPDevice* pDevice)
{
    HRESULT hr = S_OK;
    
    if(SUCCEEDED(hr))
    {
        IInternetGateway* pInternetGateway;
        hr = GetServices(pDevice, &pInternetGateway);
        if(SUCCEEDED(hr))
        {
            SendMessage(m_hCallbackWindow, WM_APP_ADDBEACON, 0, reinterpret_cast<LPARAM>(pInternetGateway));
            pInternetGateway->Release();
        }
    }
    

    return hr;
}

HRESULT CBeaconFinder::DeviceRemoved(LONG lFindData, BSTR bstrUDN)
{

    SendMessage(m_hCallbackWindow, WM_APP_REMOVEBEACON, 0, reinterpret_cast<LPARAM>(bstrUDN));

    return S_OK;
}

HRESULT CBeaconFinder::SearchComplete(LONG lFindData)
{
    HRESULT hr = S_OK;

    // don't care

    return hr;
}

HRESULT CBeaconFinder::GetServices(IUPnPDevice* pDevice, IInternetGateway** ppInternetGateway)
{
    HRESULT hr = S_OK;
    
    *ppInternetGateway = NULL;

    CComObject<CInternetGateway>* pInternetGateway;
    hr = CComObject<CInternetGateway>::CreateInstance(&pInternetGateway);    
    if(SUCCEEDED(hr))
    {
        pInternetGateway->AddRef();

        BSTR pUniqueDeviceName;
        hr = pDevice->get_UniqueDeviceName(&pUniqueDeviceName);
        if(SUCCEEDED(hr))
        {
            hr = pInternetGateway->SetUniqueDeviceName(pUniqueDeviceName);
            SysFreeString(pUniqueDeviceName);
        }
        
        if(SUCCEEDED(hr))
        {
            
            IUPnPService* pOSInfoService;
            hr = FindService(pDevice, L"urn:schemas-microsoft-com:service:OSInfo:1", &pOSInfoService); // this service is not required
            if(SUCCEEDED(hr))
            {
                pInternetGateway->SetService(SAHOST_SERVICE_OSINFO, pOSInfoService);
                pOSInfoService->Release();
            }
            
            IUPnPDevice* pWANDevice;
            hr = FindChildDevice(pDevice, L"urn:schemas-upnp-org:device:WANDevice:1", &pWANDevice);
            if(SUCCEEDED(hr))
            {
                
                IUPnPService* pWANCommonInterfaceConfigService;
                hr = FindService(pWANDevice, L"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1", &pWANCommonInterfaceConfigService);
                if(SUCCEEDED(hr))
                {
                    pInternetGateway->SetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, pWANCommonInterfaceConfigService);
                    
                    IUPnPDevice* pWANCommonDevice;
                    hr = FindChildDevice(pWANDevice, L"urn:schemas-upnp-org:device:WANConnectionDevice:1", &pWANCommonDevice);
                    if(SUCCEEDED(hr))
                    {
                        IUPnPService* pWANConnectionService;
                        hr = FindService(pWANCommonDevice, NULL, &pWANConnectionService);
                        if(SUCCEEDED(hr))
                        {
                            BSTR ServiceType;
                            hr = pWANConnectionService->get_ServiceTypeIdentifier(&ServiceType);
                            if(SUCCEEDED(hr))
                            {
                                if(0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
                                {
                                    pInternetGateway->SetMediaType(NCM_SHAREDACCESSHOST_RAS);
                                    pInternetGateway->SetService(SAHOST_SERVICE_WANPPPCONNECTION, pWANConnectionService);
                                }
                                else // we can assume this is WANPPPConnectionService
                                {
                                    pInternetGateway->SetMediaType(NCM_SHAREDACCESSHOST_LAN);
                                    pInternetGateway->SetService(SAHOST_SERVICE_WANIPCONNECTION, pWANConnectionService);
                                }
                                
                                SysFreeString(ServiceType);
                            }
                            pWANConnectionService->Release();
                        }
                        pWANCommonDevice->Release();
                    }
                    pWANCommonInterfaceConfigService->Release();
                }
                pWANDevice->Release();
            }
        }
        
        if(SUCCEEDED(hr))
        {
            *ppInternetGateway = static_cast<IInternetGateway*>(pInternetGateway);
            (*ppInternetGateway)->AddRef();
        }
        pInternetGateway->Release();
    }
    return hr;
}

HRESULT CBeaconFinder::FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;
    
    IUPnPDevices* pDevices;
    hr = pDevice->get_Children(&pDevices);
    if(SUCCEEDED(hr))
    {
        hr = FindDevice(pDevices, pszDeviceType, ppChildDevice);
        pDevices->Release();
    }
    return hr;
}


HRESULT CBeaconFinder::FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;

    *ppChildDevice = NULL;

    IUnknown* pEnumerator;
    hr = pDevices->get__NewEnum(&pEnumerator);
    
    if (SUCCEEDED(hr))
    {
        IEnumVARIANT* pVariantEnumerator;
        hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
        if (SUCCEEDED(hr))
        {
            VARIANT DeviceVariant;
            
            VariantInit(&DeviceVariant);
            
            pVariantEnumerator->Reset();
            
            // Traverse the collection.
            
            while (NULL == *ppChildDevice && S_OK == pVariantEnumerator->Next(1, &DeviceVariant, NULL))
            {
                IDispatch   * pDeviceDispatch = NULL;
                IUPnPDevice * pDevice = NULL;
                
                pDeviceDispatch = V_DISPATCH(&DeviceVariant);
                hr = pDeviceDispatch->QueryInterface(IID_IUPnPDevice, reinterpret_cast<void **>(&pDevice));
                if (SUCCEEDED(hr))
                {
                    BSTR Type;
                    hr = pDevice->get_Type(&Type);
                    if(SUCCEEDED(hr))
                    {
                        if(0 == wcscmp(Type, pszDeviceType))
                        {
                            *ppChildDevice = pDevice;
                            pDevice->AddRef();

                        }
                        SysFreeString(Type);
                    }                    
                    pDevice->Release();
                }
                VariantClear(&DeviceVariant);                                
            };
            
            if(NULL == *ppChildDevice)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            pVariantEnumerator->Release();
        }
        pEnumerator->Release();
    }
    return hr;

    
}

HRESULT CBeaconFinder::FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService)
{
    HRESULT hr;

    *ppICSService = NULL;

    IUPnPServices* pServices;        
    hr = pDevice->get_Services(&pServices);
    if (SUCCEEDED(hr))
    {
        IUnknown* pEnumerator;
        hr = pServices->get__NewEnum(&pEnumerator);
        if (SUCCEEDED(hr))
        {
            IEnumVARIANT* pVariantEnumerator;
            hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
            if (SUCCEEDED(hr))
            {
                VARIANT ServiceVariant;
                
                VariantInit(&ServiceVariant);
                
                while (NULL == *ppICSService && S_OK == pVariantEnumerator->Next(1, &ServiceVariant, NULL))
                {
                    IDispatch   * pServiceDispatch = NULL;
                    IUPnPService * pService = NULL;
                    
                    pServiceDispatch = V_DISPATCH(&ServiceVariant);
                    hr = pServiceDispatch->QueryInterface(IID_IUPnPService, reinterpret_cast<void **>(&pService));
                    if (SUCCEEDED(hr))
                    {
                        BOOL bMatch;
                        hr = IsServiceMatch(pService, pszServiceName, &bMatch);
                        if(SUCCEEDED(hr) && TRUE == bMatch)
                        {
                            *ppICSService = pService;
                            pService->AddRef();
                        }
                        pService->Release();
                    }
                    VariantClear(&ServiceVariant);
                }
                if(NULL == *ppICSService)
                {
                    hr = E_FAIL;
                }                   
                pVariantEnumerator->Release();
            }
            pEnumerator->Release();
        }
        pServices->Release();
    }
    return hr;
}

HRESULT CBeaconFinder::IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch)
{
    HRESULT hr = S_OK;

    *pbMatch = FALSE;
    
    BSTR ServiceType;
    hr = pService->get_ServiceTypeIdentifier(&ServiceType);
    if(SUCCEEDED(hr))
    {
        if(NULL != SearchCriteria) // if the caller provides a name then we search for it
        {
            if(0 == wcscmp(ServiceType, SearchCriteria))
            {
                *pbMatch = TRUE;
            }                            
        }
        else // otherwise we enter the special search case
        {
            if(0 == wcscmp(ServiceType, g_szWANIPConnectionService) || 0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
            {
                VARIANT OutArgsGetConnectionTypeInfo;
                hr = InvokeVoidAction(pService, L"GetConnectionTypeInfo", &OutArgsGetConnectionTypeInfo);
                if(SUCCEEDED(hr))
                {
                    VARIANT ConnectionType;
                    LONG lIndex = 0;
                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetConnectionTypeInfo), &lIndex, &ConnectionType);
                    if(SUCCEEDED(hr))
                    {
                        if(V_VT(&ConnectionType) == VT_BSTR)
                        {
                            if(0 == wcscmp(V_BSTR(&ConnectionType), L"IP_Routed"))
                            {
                                VARIANT OutArgsGetNATRSIPStatus;
                                hr = InvokeVoidAction(pService, L"GetNATRSIPStatus", &OutArgsGetNATRSIPStatus);
                                if(SUCCEEDED(hr))
                                {
                                    VARIANT NATEnabled;
                                    lIndex = 1;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetNATRSIPStatus), &lIndex, &NATEnabled);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&NATEnabled) == VT_BOOL)
                                        {
                                            if(VARIANT_TRUE == V_BOOL(&NATEnabled))
                                            {
                                                *pbMatch = TRUE;
                                            }
                                        }
                                        VariantClear(&NATEnabled);
                                    }
                                    VariantClear(&OutArgsGetNATRSIPStatus);
                                }
                            }
                        }
                        VariantClear(&ConnectionType);
                    }
                    VariantClear(&OutArgsGetConnectionTypeInfo);
                }
            }
        }
        SysFreeString(ServiceType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "icsdclt_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\alg\inc\mytrace.h ===
#pragma once

#include <stdio.h>
#include <stdarg.h>
#include <stdio.h>
#include <Rtutils.h>
#include <Winsock.h>

extern DWORD    g_dwTraceId;                                

#if defined(DBG) || defined(_DEBUG)
    #define MYTRACE_ENABLE                      DWORD g_dwTraceId=0;  int CMyDebugTrace::m_nIndent=-1; 
    #define MYTRACE_START(UNIQUE_NAME)          g_dwTraceId = TraceRegister(UNIQUE_NAME); // TRACE_USE_FILE
    #define MYTRACE_STOP                        TraceDeregister(g_dwTraceId);

    #define MYTRACE_ENTER(MSG)                  CMyDebugTrace   _NewMyTrace(MSG, __FILE__, __LINE__, true);
    #define MYTRACE_ENTER_EXTRA_SPACE(MSG)      CMyDebugTrace   _NewMyTrace(MSG, __FILE__, __LINE__, true,1);
    #define MYTRACE_ENTER_NOSHOWEXIT(MSG)       CMyDebugTrace   _NewMyTrace(MSG, __FILE__, __LINE__, false);
    #define MYTRACE_ERROR(MSG,ERROR_NUMBER)     _NewMyTrace.TraceError(MSG, ERROR_NUMBER, __LINE__);
    #define MYTRACE_IP(ULONG_ADDRESS)           _NewMyTrace.IP2A(ULONG_ADDRESS)
    #define MYTRACE                             _NewMyTrace.MyTrace
    #define MYTRACE_BUFFER2STR(BUFF, NLEN)      _NewMyTrace.Buffer2Str(BUFF, NLEN)
#else
    #define MYTRACE_ENABLE              
    #define MYTRACE_START(UNIQUE_NAME)  
    #define MYTRACE_STOP                

    #define MYTRACE_ENTER(MSG)
    #define MYTRACE_ENTER_EXTRA_SPACE(MSG)
    #define MYTRACE_ENTER_NOSHOWEXIT(MSG)
    #define MYTRACE_ERROR(MSG,ERROR_NUMBER)
    #define MYTRACE_IP(ULONG_ADDRESS)   0
    #define MYTRACE
    #define MYTRACE_BUFFER2STR(BUFF, NLEN) 0
#endif



//#define DOTRACE(ID, str)
#define DOTRACE(ID, str)    TracePrintf(g_dwTraceId, str);
//#define DOTRACE(ID, str)    OutputDebugString(str);OutputDebugString(L"\n");
//#define DOTRACE(ID, str)    MessageBox(NULL,str,m_szMsgEnter,MB_OK|MB_SERVICE_NOTIFICATION);







class CMyDebugTrace
{
public:
    CMyDebugTrace(
        LPCSTR      szMsgEnter, 
        LPCSTR      szFile, 
        const int   nLine,
        bool        bShowExit,
        int         nExtraWhiteSpace=0
        )
    {
        USES_CONVERSION;
        m_nExtraSpace = nExtraWhiteSpace;
        m_bShowExit = bShowExit;
        lstrcpy(m_szMsgEnter,    A2T(szMsgEnter));

        // From the entry/creation text we extract the function name 
        // example   "CFoo::Format" we will have CFoo to prefix in front of all traces done after
        lstrcpy(m_szFunction, A2T(szMsgEnter));
        wchar_t* pEnd = wcschr(m_szFunction, L':');
        if ( pEnd )
            *pEnd = L'\0';
        else
            lstrcpy(m_szFunction, L"");


        lstrcpy(m_szFile,   A2T(szFile));
        
        m_nIndent++;
        
        wsprintf(
            m_szTrace, 
            L"%s%s %s", 
            SzRepeat(m_nIndent), 
            m_bShowExit ? L"++" : L"+-",
            m_szMsgEnter
            );

        int nLen = lstrlen(m_szTrace);

        wsprintf(
            m_szTrace,
            L"%s%s[L%d]%s",
            m_szTrace,
            SzRepeat(80-nLen),
            nLine,
            m_szFile
            );
            
        if ( m_nExtraSpace != 0 )
            DOTRACE(g_dwTraceId, TEXT(""));

        DOTRACE(g_dwTraceId, m_szTrace);
    }

    ~CMyDebugTrace()
    {
        if ( m_bShowExit )
        {
    
            wsprintf(m_szTrace, L"%s-- %s", SzRepeat(m_nIndent), m_szMsgEnter);
            DOTRACE(g_dwTraceId, m_szTrace);

            if ( m_nExtraSpace != 0 )
                DOTRACE(g_dwTraceId, TEXT(""));
        }

        m_nIndent--;
    }


    //
    // Output to the debug window a user trace
    //
    inline void _cdecl MyTrace(LPCSTR lpszFormat, ...)
    {
    #if defined(DBG) || defined(_DEBUG)

        USES_CONVERSION;
        va_list args;
        va_start(args, lpszFormat);

        char szBuffer[2048];

        _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);

        TCHAR szLine[2048];
        wsprintf(szLine, L"%s%s   %s", SzRepeat(CMyDebugTrace::m_nIndent+3), m_szFunction, A2T(szBuffer));
        DOTRACE(g_dwTraceId, szLine);

        va_end(args);

    #endif
    }


    //
    // Output a debug trace for a error including Line number and source file name
    //
    inline void 
    TraceError(
        LPCSTR      szMsg, 
        int         nError,
        const int   nLine
        )
    {
        USES_CONVERSION;
	    TCHAR   szBuffer[512];

        //
        // No Error # was given so lets get the last one raised
        //
        if ( nError == 0 )
            nError = GetLastError();
    
        wsprintf(szBuffer, L"%s  %s   ERROR(0x%X):%s               [L%d]%s", SzRepeat(CMyDebugTrace::m_nIndent), m_szMsgEnter, nError, A2T(szMsg), nLine, m_szFile);
        DOTRACE(g_dwTraceId, szBuffer);
    }

    //
    // Return the ascii equivalent of the IP example "192.168.0.1"
    //
    inline char*
    IP2A(ULONG ulAddress)
    {
        in_addr tmpAddr;
        tmpAddr.s_addr = ulAddress;
        return inet_ntoa(tmpAddr);
    }


    inline char*
    Buffer2Str(char* pBuff, int nLen)
    {
        static char szPrintableStr[1024];
        memcpy(szPrintableStr, pBuff, min(nLen,1022));
        szPrintableStr[min(nLen,1023)] = '\0';

        int nLenMin = strlen(szPrintableStr);

        for ( int nChar=0; nChar < nLenMin; nChar++ )
        {
            if ( isprint(szPrintableStr[nChar])==0 )
                szPrintableStr[nChar] =  '';
        }

        return szPrintableStr;
    }

    //
    // Return a left paded space indentation
    //
    inline LPCTSTR 
    SzRepeat(int nCount)
    {
        static TCHAR szPading[200];

        lstrcpy(szPading, L"");

        for ( int nI=0; nI < nCount; nI++ )
            lstrcat(szPading, L" ");

        return szPading;
    }
    int         m_nExtraSpace;
    bool        m_bShowExit;
    TCHAR       m_szTrace[512];
    TCHAR       m_szMsgEnter[1024];
    TCHAR       m_szFunction[256];
    TCHAR       m_szFile[256];
    static      int m_nIndent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\client.h ===
#pragma once

#include "beacon.h"
#include <upnp.h>

class ATL_NO_VTABLE CBeaconFinder :
    public CComObjectRootEx <CComSingleThreadModel>,
    public IUPnPDeviceFinderCallback
{

public:
    BEGIN_COM_MAP(CBeaconFinder)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT();

    CBeaconFinder();
    
    STDMETHODIMP DeviceAdded(LONG lFindData, IUPnPDevice* pDevice); 
    STDMETHODIMP DeviceRemoved(LONG lFindData, BSTR bstrUDN); 
    STDMETHODIMP SearchComplete(LONG lFindData); 

    HRESULT Initialize(HWND hCallbackWindow);

private:
    HRESULT FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService);
    HRESULT FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT GetServices(IUPnPDevice* pDevice, IInternetGateway** ppInternetGateway);
    HRESULT IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch);
    
    HWND m_hCallbackWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\dllmain.cpp ===
// testatl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for testatl.idl by adding the following 
//      files to the Outputs.
//          testatl_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f testatlps.mk in the project directory.

#include <stdafx.h>
#include <ole2.h>
#include "resource.h"
#include <initguid.h>
#include "dlldatax.h"

#include "icsdclt_i.c"
#include "InternetGatewayFinder.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#include "atlbase.h"
CComModule _Module;
#include "atlcom.h"

#include "NATUPnP.h"
#include "UPnPNAT.h"

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPNAT, CUPnPNAT)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\internetgatewayfinder.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "InternetGatewayFinder.h"
#include "trayicon.h"

CInternetGatewayFinder::CInternetGatewayFinder()
{
    m_hWindow = NULL;
}

HRESULT CInternetGatewayFinder::Initialize(HWND hWindow)
{
    HRESULT hr = S_OK;
    
    m_hWindow = hWindow;
    
    return hr;    
}

HRESULT CInternetGatewayFinder::GetInternetGateway(BSTR DeviceId, IInternetGateway** ppInternetGateway)
{
    HRESULT hr = S_OK;
    
    *ppInternetGateway = NULL;
    
    IInternetGateway* pInternetGateway;
    if(1 == SendMessage(m_hWindow, WM_APP_GETBEACON, 0, reinterpret_cast<LPARAM>(&pInternetGateway)))
    {
        *ppInternetGateway = pInternetGateway;
        // pass reference
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    return hr;
}




CInternetGatewayFinderClassFactory::CInternetGatewayFinderClassFactory()
{
    m_hWindow = NULL;
}

HRESULT CInternetGatewayFinderClassFactory::Initialize(HWND hWindow)
{
    HRESULT hr = S_OK;
    
    m_hWindow = hWindow;
    
    return hr;    
}

HRESULT CInternetGatewayFinderClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppvObject)
{
    HRESULT hr = S_OK;

    if(NULL != pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    
    if(NULL == ppvObject)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppvObject = NULL;
    }

    if(SUCCEEDED(hr))
    {
        CComObject<CInternetGatewayFinder>* pInternetGatewayFinder;
        hr = CComObject<CInternetGatewayFinder>::CreateInstance(&pInternetGatewayFinder);
        if(SUCCEEDED(hr))
        {
            pInternetGatewayFinder->AddRef();

            hr = pInternetGatewayFinder->Initialize(m_hWindow);
            if(SUCCEEDED(hr))
            {
                hr = pInternetGatewayFinder->QueryInterface(riid, ppvObject);
                // pass reference
            }
            pInternetGatewayFinder->Release();
        }
    }
    
    return hr;
}

HRESULT CInternetGatewayFinderClassFactory::LockServer(BOOL fLock)
{
    HRESULT hr = S_OK;

    fLock ? _Module.Lock() : _Module.Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\internetgatewayfinder.h ===
#pragma once

// {4D3F9715-73DA-4506-8933-1E0E1718BA3B}
DEFINE_GUID(CLSID_CInternetGatewayFinder, 
0x4d3f9715, 0x73da, 0x4506, 0x89, 0x33, 0x1e, 0xe, 0x17, 0x18, 0xba, 0x3b);

class ATL_NO_VTABLE CInternetGatewayFinder :
    public CComObjectRootEx <CComSingleThreadModel>,
    public IInternetGatewayFinder
{

public:
    BEGIN_COM_MAP(CInternetGatewayFinder)
        COM_INTERFACE_ENTRY(IInternetGatewayFinder)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT();

    CInternetGatewayFinder();
    HRESULT Initialize(HWND hWindow);
    
    STDMETHODIMP GetInternetGateway(BSTR DeviceId, IInternetGateway** ppInternetGateway);

    HWND m_hWindow;
};



class ATL_NO_VTABLE CInternetGatewayFinderClassFactory :
    public CComObjectRootEx <CComSingleThreadModel>,
    public IClassFactory
{

public:
    BEGIN_COM_MAP(CInternetGatewayFinderClassFactory)
        COM_INTERFACE_ENTRY(IClassFactory)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT();

    CInternetGatewayFinderClassFactory();
    HRESULT Initialize(HWND hWindow);
    
    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

    HWND m_hWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\resource.h ===
#pragma once

#define IDC_STATIC -1

// strings
#define IDS_DEFAULTADAPTERNAME 100
#define IDS_UPTIME_ZERODAYS 101
#define IDS_UPTIME_ONEDAY 102
#define IDS_UPTIME_MANYDAYS 103
#define IDS_TOOLTIP_FORMAT 104
#define IDS_NAME_FORMAT 105
#define IDS_PROPERTIES_FORMAT 106
#define IDS_STATUS_FORMAT 107
#define IDS_BEACONNOTFOUND 108
#define IDS_APPTITLE 109
#define IDS_CONNECTED 110
#define IDS_DISCONNECTED 111
#define IDS_ENABLE 112
#define IDS_DISABLE 113
#define IDS_CONNECT 114
#define IDS_DISCONNECT 115
#define IDS_CONNECTING 116
#define IDS_DISCONNECTING 117
#define IDS_UNCONFIGURED 118
#define IDS_ACCESSDENIED 119
#define IDS_NOTAVAILABLE 120
#define IDS_CLOSE 121
#define IDS_NEEDNEWERIE 122
#define IDS_CONNECTIONFAILED 123


// status bps strings, must remain in order
#define IDS_METRIC_ZERO 200
#define IDS_METRIC_KILO 201
#define IDS_METRIC_MEGA 202
#define IDS_METRIC_GIGA 203
#define IDS_METRIC_TERA 204
// end status bps string, must remain in order


// icons
#define IDI_TRAYICON 100
// REMOVED #define IDI_PROPERTIESICON 101
#define IDI_INTERNET 102
// REMOVED #define IDI_LAN 103
#define IDI_GATEWAY 104
#define IDI_MYCOMPUTER 105

// menu items
#define IDM_TRAYICON_LAN_CONNECT 100
#define IDM_TRAYICON_LAN_DISCONNECT 101
#define IDM_TRAYICON_RAS_CONNECT 102
#define IDM_TRAYICON_RAS_DISCONNECT 103
#define IDM_TRAYICON_CONNECT 104
#define IDM_TRAYICON_DISCONNECT 105
#define IDM_TRAYICON_STATUS 106
#define IDM_TRAYICON_PROPERTIES 107

// dialogs
#define IDD_STATUS 100
#define IDD_PROPERTIES 101

// status dialog control
#define IDC_STATUS_STATUS 100
#define IDC_STATUS_DURATION 101
#define IDC_STATUS_SPEED 102
#define IDC_STATUS_BYTESSENT 103
#define IDC_STATUS_BYTESRECEIVED 104
#define IDC_STATUS_LOCALBYTESSEND 105
#define IDC_STATUS_LOCALBYTESRECEIVTED 106
#define IDC_STATUS_PROPERTIES 107
#define IDC_STATUS_DISCONNECT 108
// REMOVED #define IDC_STATUS_DISABLE 109
#define IDC_STATUS_BYTESLABEL 110
#define IDC_STATUS_PACKETSLABEL 111
#define IDC_STATUS_CONNECT 112

// properties dialog controls
#define IDC_PROPERTIES_ADAPTERNAME 100
#define IDC_PROPERTIES_SHOWICON 101
#define IDC_PROPERTIES_ADAPTERICON 102

// registry data
#define IDR_UPNPNAT                 103

// end of resources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\saprop.cpp ===
#include <stdio.h>

#ifdef DBG
#undef DBG
#endif

//#ifdef ASSERT
//#undef ASSERT
//#endif
//#define ASSERT(a)

//#ifdef _ASSERT
//#undef _ASSERT
//#endif
//#define _ASSERT(a)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>    // added to "Fusionized"
#include <windowsx.h>
#include <wbemidl.h>
#include <netcon.h>
#include <netconp.h>
#include <devguid.h>
#include <iphlpapi.h>
#include <ipnathlp.h>
#include <lmerr.h>

#include "hncbase.h"
#include "hncdbg.h"
#include "hnetcfg.h"
#include "hncres.h"
#include "hncstrs.h"
#include "hncutil.h"

#include "hncenum.h"
#include "hncaenum.h"
#include "hnappprt.h"
#include "hnprtmap.h"
#include "hnprtbnd.h"
#include "hnetconn.h"
#include "hnbridge.h"
#include "hnbrgcon.h"
#include "hnicspub.h"
#include "hnicsprv.h"
#include "hnfwconn.h"
#include "hncfgmgr.h"
#include "hnapi.h"
#include "icsdclt.h"

#include <NATUPnP.h>
#include "UPnPNAT.h"

#define DOWNLEVEL_CLIENT
#include "..\..\config\dll\resourc2.h"
#include "..\..\config\dll\sadlg.cpp"
#include "..\..\config\dll\sautil.cpp"

HINSTANCE g_hinstDll = NULL;

extern HRESULT GetWANConnectionService(IInternetGateway* pInternetGateway, IUPnPService** ppWANConnectionService);
HPROPSHEETPAGE GetSharedAccessPropertyPage (IInternetGateway* pInternetGateway, HWND hwndOwner)
{
    g_hinstDll = _Module.GetResourceInstance();

    HPROPSHEETPAGE hpsp = NULL;

    CComPtr<IUPnPService> spUPS;
    HRESULT hr = GetWANConnectionService (pInternetGateway, &spUPS);
    if (spUPS) {
        PROPSHEETPAGE psp;
        ZeroMemory (&psp, sizeof(psp));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.lParam = (LPARAM)hwndOwner;     // double-secret place to hang owner (will get wiped)
        hr = HNetGetSharingServicesPage (spUPS, &psp);
        if (SUCCEEDED(hr))
            hpsp = CreatePropertySheetPage (&psp);
    }
    return hpsp;
}

// stubs (these are referenced, but not called via this code path)
HRESULT CFirewallLoggingDialog_FinalRelease(CFirewallLoggingDialog* pThis) { return S_OK; }
HRESULT CICMPSettingsDialog_FinalRelease(CICMPSettingsDialog* pThis) { return S_OK; }
INT_PTR CALLBACK CFirewallLoggingDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam) { return 0; }
INT_PTR CALLBACK CICMPSettingsDialog_StaticDlgProc(HWND hwnd, UINT unMsg, WPARAM wparam, LPARAM lparam ) { return 0; }
HRESULT CFirewallLoggingDialog_Init(CFirewallLoggingDialog* pThis, IHNetCfgMgr* pHomenetConfigManager) { return S_OK; }
HRESULT CICMPSettingsDialog_Init(CICMPSettingsDialog* pThis, IHNetConnection* pHomenetConnection) { return S_OK; }
STDAPI_(VOID) NcFreeNetconProperties (NETCON_PROPERTIES* pProps) { return; }
DWORD RasGetErrorString(UINT uErrorValue, LPTSTR lpszErrorString, DWORD cBufSize) { return -1; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\properties.h ===
#pragma once

#include "stdafx.h"
#include <windows.h>
#include "resource.h"
#include "atlsnap.h"
#include "netconp.h"

class CPropertiesDialog : public CSnapInPropertyPageImpl<CPropertiesDialog, FALSE>
{

public:
    BEGIN_MSG_MAP(CPropertiesDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
      
    END_MSG_MAP()

    enum { IDD = IDD_PROPERTIES };    

    CPropertiesDialog(IInternetGateway* pInternetGateway);
    ~CPropertiesDialog();
    
    static HRESULT ShouldShowIcon(void);
    static HRESULT SetShowIcon(BOOL bShowIcon);

private:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HICON m_hIcon;
    IInternetGateway* m_pInternetGateway;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\status.cpp ===
#include "status.h"
#include "properties.h"
#include "util.h"

CStatusDialog::CStatusDialog(IInternetGateway* pInternetGateway)
{
    m_pInternetGateway = pInternetGateway;
    m_pInternetGateway->AddRef();

    m_uTimerId = 0;
    m_bGettingStatistics = FALSE;
    m_bShowingBytes = TRUE;
}

CStatusDialog::~CStatusDialog()
{
    m_pInternetGateway->Release();
    
}

LRESULT CStatusDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_uTimerId = SetTimer(1, 1000);

    TCHAR szCloseText[64];
    if(0 != ::LoadString(_Module.GetResourceInstance(), IDS_CLOSE, szCloseText, sizeof(szCloseText) / sizeof(TCHAR)))
    {
        ::SetDlgItemText(GetParent(), IDCANCEL, szCloseText); // set the cancel to close
    }
    
    ::ShowWindow(::GetDlgItem(GetParent(), IDOK), SW_HIDE); // hide the original close
    ::EnableWindow(::GetDlgItem(GetParent(), IDCANCEL), TRUE); // and re-enable the cancel button
    
    
    IUPnPService* pWANConnectionService;
    HRESULT hr = GetWANConnectionService(m_pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        NETCON_STATUS Status;
        hr = GetConnectionStatus(pWANConnectionService, &Status);
        if(SUCCEEDED(hr))
        {
            UpdateButtons(Status);
        }
        pWANConnectionService->Release();
    }

    return TRUE;
}

LRESULT CStatusDialog::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(0 != m_uTimerId)
    {
        ::KillTimer(m_hWnd, m_uTimerId);
    }
    return 0;
}

LRESULT CStatusDialog::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    if(FALSE == m_bGettingStatistics) // this functions pumps messages, so don't let us be re-entered  
    {
        m_bGettingStatistics = TRUE;
        
        NETCON_STATUS Status = NCS_CONNECTED;
        ULONG ulTotalBytesSent = 0;
        ULONG ulTotalBytesReceived = 0;
        ULONG ulTotalPacketsSent = 0;
        ULONG ulTotalPacketsReceived = 0;
        ULONG ulSpeedbps = 0;
        ULONG ulUptime = 0;
        BOOL bStatisticsAvailable = TRUE;
        
        
        IUPnPService* pWANConnection;
        hr = GetWANConnectionService(m_pInternetGateway, &pWANConnection);
        if(SUCCEEDED(hr))
        {
            IUPnPService* pWANCommonInterfaceConfig;
            hr = m_pInternetGateway->GetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, &pWANCommonInterfaceConfig);
            if(SUCCEEDED(hr))
            {
                
                hr = GetConnectionStatus(pWANConnection, &Status);                
                if(SUCCEEDED(hr))
                {
                    if(NCS_CONNECTED == Status)
                    {
                        VARIANT OutArgs;
                        VariantInit(&OutArgs);
                        hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"X_GetICSStatistics", &OutArgs);
                        if(SUCCEEDED(hr))
                        {
                            SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                            
                            LONG lIndex = 0;
                            VARIANT Param;
                            
                            lIndex = 0;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalBytesSent = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 1;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalBytesReceived = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 2;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalPacketsSent = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 3;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalPacketsReceived = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 4;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulSpeedbps = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 5;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulUptime = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            VariantClear(&OutArgs);
                        }
                        else if(UPNP_E_INVALID_ACTION == hr)
                        {
                            VARIANT OutArgs;
                            LONG lIndex = 0;
                            VARIANT Param;
                            
                            hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalBytesSent", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        ulTotalBytesSent = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                            
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalBytesReceived", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulTotalBytesReceived = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalPacketsSent", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulTotalPacketsSent = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalPacketsReceived", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    lIndex = 0;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulTotalPacketsReceived = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetCommonLinkProperties", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    lIndex = 2;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulSpeedbps = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = InvokeVoidAction(pWANConnection, L"GetStatusInfo", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    lIndex = 2;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulUptime = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            
                            if(UPNP_E_INVALID_ACTION == hr)
                            {
                                hr = S_OK; // server does not support statistics
                                bStatisticsAvailable = FALSE;
                            }
                        }
                    }
                }
                pWANCommonInterfaceConfig->Release();
            }
            pWANConnection->Release();
        }
    
        if(SUCCEEDED(hr) && NCS_CONNECTED == Status)
        {
            if(TRUE == bStatisticsAvailable)
            {
                if(0 != ulTotalBytesSent && 0 != ulTotalBytesReceived)
                {
                    if(FALSE == m_bShowingBytes) // switch labels
                    {
                        m_bShowingBytes = TRUE;
                        ::ShowWindow(GetDlgItem(IDC_STATUS_BYTESLABEL), SW_SHOW);
                        ::ShowWindow(GetDlgItem(IDC_STATUS_PACKETSLABEL), SW_HIDE);
                    
                    }
                    SetDlgItemInt(IDC_STATUS_BYTESSENT, ulTotalBytesSent, FALSE);
                    SetDlgItemInt(IDC_STATUS_BYTESRECEIVED, ulTotalBytesReceived, FALSE);
                }
                else
                {
                    if(TRUE == m_bShowingBytes) // switch labels
                    {
                        m_bShowingBytes = FALSE;
                        ::ShowWindow(GetDlgItem(IDC_STATUS_PACKETSLABEL), SW_SHOW);
                        ::ShowWindow(GetDlgItem(IDC_STATUS_BYTESLABEL), SW_HIDE);
                    }
                    SetDlgItemInt(IDC_STATUS_BYTESSENT, ulTotalPacketsSent, FALSE);
                    SetDlgItemInt(IDC_STATUS_BYTESRECEIVED, ulTotalPacketsReceived, FALSE);
                }
            
                TCHAR szTimeDuration[128];
                hr = FormatTimeDuration(ulUptime, szTimeDuration, sizeof(szTimeDuration) / sizeof(TCHAR));
                if(SUCCEEDED(hr))
                {
                    SetDlgItemText(IDC_STATUS_DURATION, szTimeDuration);
                }                                                                                                                                 \
            
                TCHAR szBytesPerSecond[128];
                hr = FormatBytesPerSecond(ulSpeedbps, szBytesPerSecond, sizeof(szBytesPerSecond) / sizeof(TCHAR));
                if(SUCCEEDED(hr))
                {
                    SetDlgItemText(IDC_STATUS_SPEED, szBytesPerSecond);
                }
            }
            else
            {                
                TCHAR szNotAvailable[64];
                if(0 == LoadString(_Module.GetResourceInstance(), IDS_NOTAVAILABLE, szNotAvailable, sizeof(szNotAvailable) / sizeof(TCHAR)))
                {
                    szNotAvailable[0] = TEXT('\0');
                }
                
                SetDlgItemText(IDC_STATUS_BYTESSENT, szNotAvailable);
                SetDlgItemText(IDC_STATUS_BYTESRECEIVED, szNotAvailable);
                SetDlgItemText(IDC_STATUS_DURATION, szNotAvailable);
                SetDlgItemText(IDC_STATUS_SPEED, szNotAvailable);
            }
            
        }
        else
        {
            SetDlgItemText(IDC_STATUS_BYTESSENT, TEXT(""));
            SetDlgItemText(IDC_STATUS_BYTESRECEIVED, TEXT(""));
            SetDlgItemText(IDC_STATUS_DURATION, TEXT(""));
            SetDlgItemText(IDC_STATUS_SPEED, TEXT(""));
        }
        
        if(SUCCEEDED(hr) || UPNP_E_ACTION_REQUEST_FAILED == hr) // if we disconnected after getting status this will fail
        {
            UpdateButtons(Status);
            
            TCHAR szConnectionStatus[64];
            hr = ConnectionStatusToString(Status, szConnectionStatus, sizeof(szConnectionStatus) / sizeof(TCHAR));
            if(SUCCEEDED(hr)) 
            {
                SetDlgItemText(IDC_STATUS_STATUS, szConnectionStatus);
            }
        }
        


        if(FAILED(hr))
        {
            ::PropSheet_PressButton(GetParent(), PSBTN_CANCEL);
        }

        m_bGettingStatistics = FALSE;
    }
    return 0;
}

LRESULT CStatusDialog::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND hPropertySheet = GetParent();
    if(NULL != hPropertySheet)
    {
        HWND hTopLevelWindow = ::GetParent(hPropertySheet);
        if(NULL != hTopLevelWindow)
        {
            ::PostMessage(hTopLevelWindow, WM_COMMAND, IDM_TRAYICON_PROPERTIES, (LPARAM)hPropertySheet);
        }
    }

    return 0;
}

LRESULT CStatusDialog::OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    HRESULT hr = S_OK;
    

    IUPnPService* pWANConnectionService;
    hr = GetWANConnectionService(m_pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        VARIANT OutArgs;
        hr = InvokeVoidAction(pWANConnectionService, L"ForceTermination", &OutArgs);
        if(SUCCEEDED(hr))
        {
            VariantClear(&OutArgs);
        }
        else if(UPNP_ACTION_HRESULT(800) == hr)
        {
            ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
        }

        pWANConnectionService->Release();
    }
    
    return 0;
}

LRESULT CStatusDialog::OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    HRESULT hr = S_OK;
    
    IUPnPService* pWANConnectionService;
    hr = GetWANConnectionService(m_pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        VARIANT OutArgs;
        hr = InvokeVoidAction(pWANConnectionService, L"RequestConnection", &OutArgs);
        if(SUCCEEDED(hr))
        {
            VariantClear(&OutArgs);
        }
        else if(UPNP_ACTION_HRESULT(800) == hr)
        {
            ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
        }
        else if(UPNP_E_DEVICE_TIMEOUT != hr)
        {
            ShowErrorDialog(m_hWnd, IDS_CONNECTIONFAILED);
        }


        pWANConnectionService->Release();
    }
    
    return 0;
}

HRESULT CStatusDialog::UpdateButtons(NETCON_STATUS Status)
{
     
    NETCON_MEDIATYPE MediaType;
    HRESULT hr = m_pInternetGateway->GetMediaType(&MediaType);
    if(SUCCEEDED(hr))
    {
        TCHAR szButtonText[64];
        
        if(NCS_CONNECTED == Status)
        {
            if(NCM_SHAREDACCESSHOST_RAS == MediaType)
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_DISCONNECT, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_DISCONNECT, szButtonText);
                }
            }
            else
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_DISABLE, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_DISCONNECT, szButtonText);
                }
            }

            ::ShowWindow(GetDlgItem(IDC_STATUS_DISCONNECT), SW_SHOW);
            ::ShowWindow(GetDlgItem(IDC_STATUS_CONNECT), SW_HIDE);

        }
        else if(NCS_DISCONNECTED == Status)
        {
            if(NCM_SHAREDACCESSHOST_RAS == MediaType)
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_CONNECT, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_CONNECT, szButtonText);
                }
            }
            else
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_ENABLE, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_CONNECT, szButtonText);
                }
            }

            ::ShowWindow(GetDlgItem(IDC_STATUS_CONNECT), SW_SHOW);
            ::ShowWindow(GetDlgItem(IDC_STATUS_DISCONNECT), SW_HIDE);
        }
    }
 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\main.cpp ===
#pragma hdrstop
#include <stdio.h>
#include "debug.h"
#include "upnp.h"

HRESULT PrintVariantBool(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_BOOL)
    {
        wprintf(L"%s is %s\n", pszVariable, VARIANT_TRUE == V_BOOL(pVariant) ?  L"TRUE" : L"FALSE");
    }

    return hr;
}

HRESULT PrintVariableBool(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantBool(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintVariantShort(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_UI2)
    {
        wprintf(L"%s is %d\n", pszVariable, V_UI2(pVariant));
    }

    return hr;
}

HRESULT PrintVariableShort(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantShort(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintVariantLong(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_UI4)
    {
        wprintf(L"%s is %d\n", pszVariable, V_UI4(pVariant));
    }

    return hr;
}

HRESULT PrintVariableLong(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantLong(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintVariantString(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_BSTR)
    {
        wprintf(L"%s is %s\n", pszVariable, V_BSTR(pVariant));
    }

    return hr;
}

HRESULT PrintVariableString(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantString(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintOutParams(VARIANT* pOutParams)
{
    HRESULT hr = S_OK;
    
    SAFEARRAY* pArray = V_ARRAY(pOutParams);
    
    LONG lIndex = 0;
    VARIANT Param;
    
    while(SUCCEEDED(hr))
    {
        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
        if(SUCCEEDED(hr))
        {
            switch(V_VT(&Param))
            {
                
            case VT_BOOL:
                PrintVariantBool(L"B  ", &Param);
                break;
            case VT_UI4:
                PrintVariantLong(L"D  ", &Param);
                break;
            case VT_UI2:
                PrintVariantShort(L"W  ", &Param);
                break;
            case VT_BSTR:
                PrintVariantString(L"S  ", &Param);
                break;
            }
            
        }
        lIndex++;
    }
    
    return hr;
}


HRESULT FindFirstDevice(IUPnPDevices* pDevices, IUPnPDevice** ppDevice)
{
    HRESULT hr = S_OK;

    IUnknown* pEnumerator;
    hr = pDevices->get__NewEnum(&pEnumerator);
    
    if (SUCCEEDED(hr))
    {
        IEnumVARIANT* pVariantEnumerator;
        hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
        if (SUCCEEDED(hr))
        {
            VARIANT DeviceVariant;
            
            VariantInit(&DeviceVariant);
            
            pVariantEnumerator->Reset();
            
            // Traverse the collection.
            
            while (S_OK == pVariantEnumerator->Next(1, &DeviceVariant, NULL))
            {
                IDispatch   * pDeviceDispatch = NULL;
                IUPnPDevice * pDevice = NULL;
                
                pDeviceDispatch = V_DISPATCH(&DeviceVariant);
                
                
                hr = pDeviceDispatch->QueryInterface(IID_IUPnPDevice, reinterpret_cast<void **>(&pDevice));
                if (SUCCEEDED(hr))
                {
                    // Do something interesting with pDevice.
                    *ppDevice = pDevice;
                    
                    BSTR FriendlyName;
                    hr = pDevice->get_FriendlyName(&FriendlyName);
                    if(SUCCEEDED(hr))
                    {
                        wprintf(L"Friendly Name %s\n", FriendlyName);
                        SysFreeString(FriendlyName);
                    }
                    //                                pDevice->Release();
                    break; // BUGBUG
                }
                
                VariantClear(&DeviceVariant);                                
            };
            
            if(NULL == *ppDevice)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            pVariantEnumerator->Release();
        }
        pEnumerator->Release();
    }

    return hr;
}

HRESULT FindGatewayDevice(IUPnPDevice** ppGatewayDevice)
{
    HRESULT hr;
    
    *ppGatewayDevice = NULL;
    
    IUPnPDeviceFinder *pDeviceFinder;
    hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, reinterpret_cast<void **>(&pDeviceFinder));
    if(SUCCEEDED(hr))
    {

        BSTR            bstrTypeURI;
        
        bstrTypeURI = SysAllocString(L"urn:schemas-upnp-org:device:InternetGatewayDevice:0.3");
        if (NULL != bstrTypeURI)
        {
            IUPnPDevices* pFoundDevices;
            hr = pDeviceFinder->FindByType(bstrTypeURI, 0, &pFoundDevices);
            if (SUCCEEDED(hr))
            {
                hr = FindFirstDevice(pFoundDevices, ppGatewayDevice);
                pFoundDevices->Release();
            }
            SysFreeString(bstrTypeURI);
        }
        pDeviceFinder->Release();
    }
    else
    {
        printf("Couldn't create device finder %x\n", hr);
    }
    return hr;
}

HRESULT FindChildDevice(IUPnPDevice* pDevice, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;
    
    IUPnPDevices* pDevices;
    hr = pDevice->get_Children(&pDevices);
    if(SUCCEEDED(hr))
    {
        hr = FindFirstDevice(pDevices, ppChildDevice);
    }

    return hr;
}

HRESULT FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService)
{
    HRESULT hr;
    IUPnPServices* pServices;        
    hr = pDevice->get_Services(&pServices);
    if (SUCCEEDED(hr))
    {
//        IUnknown* pEnumerator;
//        hr = pServices->get__NewEnum(&pEnumerator);
//        if (SUCCEEDED(hr))
//        {
//            IEnumVARIANT* pVariantEnumerator;
//            hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
//            if (SUCCEEDED(hr))
//            {
//                VARIANT ServiceVariant;
//                
//                VariantInit(&ServiceVariant);
//                
//                pVariantEnumerator->Reset();
//                
//                // Traverse the collection.
//                
//                while (S_OK == pVariantEnumerator->Next(1, &ServiceVariant, NULL))
//                {
//                    wprintf(L"getting i1d\n");
//                    IDispatch   * pServiceDispatch = NULL;
//                    IUPnPService * pService = NULL;
//                    
//                    pServiceDispatch = V_DISPATCH(&ServiceVariant);
//                    hr = pServiceDispatch->QueryInterface(IID_IUPnPService, reinterpret_cast<void **>(&pService));
//                    if (SUCCEEDED(hr))
//                    {
//                        wprintf(L"getting id\n");
//                        
//                        BSTR ServiceId;
//                        hr = pService->get_Id(&ServiceId);
//                        if(SUCCEEDED(hr))
//                        {
//                            wprintf(L"service %s\n", ServiceId);
//                            SysFreeString(ServiceId);
//                        }
//                        pService->Release();
//                    }
//                    
//                    VariantClear(&ServiceVariant);                                
//                };
//                wprintf(L"done enum\n");
//                pVariantEnumerator->Release();
//            }
//            pEnumerator->Release();
//        }
        
        BSTR ServiceId = SysAllocString(pszServiceName);
        if (NULL != ServiceId)
        {
            IUPnPService* pICSService;
            hr = pServices->get_Item(ServiceId, &pICSService);
            if(SUCCEEDED(hr))
            {
                wprintf(L"found service\n");
                *ppICSService = pICSService;    
            }
            SysFreeString(ServiceId);
        }
        
        pServices->Release();
    }
    if(FAILED(hr))
    {
        wprintf(L"find ICS Service %x\n", hr);
    }
    
    return hr;
}

HRESULT CreateParamArray(LONG lElements, VARIANT* pInParams)
{
    HRESULT hr = S_OK;
    
    VariantInit(pInParams);
    
    
    SAFEARRAYBOUND  rgsaBound[1];
    SAFEARRAY       * psa = NULL;
    
    rgsaBound[0].lLbound = 0;
    rgsaBound[0].cElements = lElements;
    
    psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
    if(NULL != psa)
    {
        pInParams->vt = VT_VARIANT | VT_ARRAY;
        V_ARRAY(pInParams) = psa;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT InvokeAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pInParams, VARIANT* pOutParams)
{
    HRESULT hr = S_OK;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        
        VARIANT varReturnVal;
        VariantInit(pOutParams);
        VariantInit(&varReturnVal);
        
        hr = pService->InvokeAction(bstrActionName, *pInParams, pOutParams, &varReturnVal);
        if(SUCCEEDED(hr))
        {
            VariantClear(&varReturnVal);
        }
        
        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }


    return hr;
}

HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr = S_OK;
    
    VARIANT varInArgs;
    hr = CreateParamArray(0, &varInArgs);
    if (SUCCEEDED(hr))
    {
        hr = InvokeAction(pService, pszCommand, &varInArgs, pOutParams);
        
        VariantClear(&varInArgs);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }   
    
    return hr;
}

HRESULT TestInternetGatewayDevice_OSInfo(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestInternetGatewayDevice_OSInfo\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:OSInfo", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            BSTR VariableName; 
            VARIANT Variant;
            VariantInit(&Variant);
            
            VariableName = SysAllocString(L"OSMajorVersion");
            hr = pICSService->QueryStateVariable(VariableName, &Variant);
            if(SUCCEEDED(hr))
            {
                if(V_VT(&Variant) == VT_I4)
                {
                    wprintf(L"OSMajorVersion is %d\n", V_I4(&Variant));
                }
            }
            else
            {
                wprintf(L"error %x\n", hr);
            }
            SysFreeString(VariableName);
            VariantClear(&Variant);
            
            if(SUCCEEDED(hr))
            {
                VariableName = SysAllocString(L"OSMinorVersion");
                hr = pICSService->QueryStateVariable(VariableName, &Variant);
                if(SUCCEEDED(hr))
                {
                    if(V_VT(&Variant) == VT_I4)
                    {
                        wprintf(L"OSMinorVersion is %d\n", V_I4(&Variant));
                    }
                }
                else
                {
                    wprintf(L"error %x\n", hr);
                }
                SysFreeString(VariableName);
                VariantClear(&Variant);
            }
            
            if(SUCCEEDED(hr))
            {
                VariableName = SysAllocString(L"OSBuildNumber");
                hr = pICSService->QueryStateVariable(VariableName, &Variant);
                if(SUCCEEDED(hr))
                {
                    if(V_VT(&Variant) == VT_I4)
                    {
                        wprintf(L"OSBuildNumber is %d\n", V_I4(&Variant));
                    }
                }
                else
                {
                    wprintf(L"error %x\n", hr);
                }
                SysFreeString(VariableName);
                VariantClear(&Variant);
            }
            
            //            if(SUCCEEDED(hr))
            //            {
            //                MessageBox(NULL, L"click to disconnect", L"debug", MB_OK);
            //                wprintf(L"disconnect\n");
            //                hr = InvokePlay(pICSService, L"Disconnect");
            //                wprintf(L"invoke failed %x\n", hr);
            //                MessageBox(NULL, L"click to connect", L"debug", MB_OK);
            //                wprintf(L"connect\n");
            //                hr = InvokePlay(pICSService, L"Connect");
            //                wprintf(L"invoke failed %x\n", hr);
            //            }
            //            
            //        
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANDevice_WANCommonInterfaceConfig(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANDevice_WANCommonInterfaceConfig\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANCommonInterfaceConfig", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"WANAccessType");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"Layer1UpstreamMaxBitRate");
            }

            if(SUCCEEDED(hr))
            {                                                                                     
                hr = PrintVariableLong(pICSService, L"Layer1DownstreamMaxBitRate");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PhysicalLinkStatus");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"WANAccessProvider");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalBytesSent");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalBytesReceived");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalPacketsSent");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalPacketsReceived");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableShort(pICSService, L"MaximumActiveConnections");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"PersonalFirewallEnabled");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetCommonLinkProperties\n");

                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetCommonLinkProperties", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  WANAccessType", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  Layer1UpstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  Layer1DownstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 3;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  PhysicalLinkStatus", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }

            if(SUCCEEDED(hr))
            {
                wprintf(L"GetCommonConnectionProperties\n");
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetCommonConnectionProperties", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);

                    LONG lIndex = 0;
                    VARIANT Param;

                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  WANAccessProvider", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantShort(L"  MaximumActiveConnections", &Param);
                        VariantClear(&Param);
                    }

                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalBytesSent", &Param);
                        VariantClear(&Param);
                    }

                    lIndex = 3;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalBytesReceived", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 4;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalPacketsSent", &Param);
                        VariantClear(&Param);
                    }

                    lIndex = 5;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalPacketsReceived", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_WANPOTSLinkConfig(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_WANPOTSLinkConfig\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANPOTSLinkConfig", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ISPPhoneNumber");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ISPInfo");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"LinkType");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"NumberOfRetries");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"DelayBetweenRetries");
            }
            
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_WANPPPConnection(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_WANPPPConnection\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANPPPConnection", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionType");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PossibleConnectionTypes");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionStatus");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"Uptime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"UpstreamMaxBitRate");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"DownstreamMaxBitRate");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"LastConnectionError");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"RSIPAvailable");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"NATEnabled");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"AutoDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"IdleDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"WarnDisconnectDelay");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PPPEncryptionProtocol");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PPPCompressionProtocol");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PPPAuthenticationProtocol");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableShort(pICSService, L"ServiceMapNumberOfEntries");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetConnectionTypeInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetConnectionTypeInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionType", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPossibleConnectionTypes", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStatusInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetStatusInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionStatus", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewLastConnectionError", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewUptime", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetNATInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetNATInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewRSIPAvailable", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewNATEnabled", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantShort(L"  NewServiceMapNumberOfEntries", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetLinkLayerInfo\n");
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetLinkLayerInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewUpstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewDownstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPPPEncryptionProtocol", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 3;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPPPCompressionProtocol", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 4;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPPPAuthenticationProtocol", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetTerminationInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetTerminationInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  AutoDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  IdleDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  WarnDisconnectDelay", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_WANIPConnection(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_WANIPConnection\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANIPConnection", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionType");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PossibleConnectionTypes");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionStatus");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"Uptime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"RSIPAvailable");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"NATEnabled");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"AutoDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"IdleDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"WarnDisconnectDelay");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableShort(pICSService, L"ServiceMapNumberOfEntries");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetConnectionTypeInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetConnectionTypeInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionType", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPossibleConnectionTypes", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStatusInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetStatusInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionStatus", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewLastConnectionError", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewUptime", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetNATInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetNATInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewRSIPAvailable", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewNATEnabled", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantShort(L"  NewServiceMapNumberOfEntries", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetTerminationInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetTerminationInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  AutoDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  IdleDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  WarnDisconnectDelay", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_NATStaticPortMapping(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_NATStaticPortMapping\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:NATStaticPortMapping", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"StaticPortDescriptionList");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStaticPortMappingList\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetStaticPortMappingList", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    PrintOutParams(&OutArgs);
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStaticPortMapping\n");
                
                VARIANT InArgs;
                VARIANT OutArgs;
                hr = CreateParamArray(1, &InArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&InArgs);

                    long lIndex = 0;
                    VARIANT Param0;
                    Param0.vt = VT_BSTR;
                    V_BSTR(&Param0) = SysAllocString(L"tester");
                    SafeArrayPutElement(pArray, &lIndex, &Param0);
                    
                    hr = InvokeAction(pICSService, L"GetStaticPortMapping", &InArgs, &OutArgs);
                    if(SUCCEEDED(hr))
                    {
                        PrintOutParams(&OutArgs);
                        VariantClear(&OutArgs);
                    }
                    else
                    {
                        printf("no action %x\n", hr);
                    }
                }
            }

            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_NATDynamicPortMapping(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_NATDynamicPortMapping\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:NATDynamicPortMapping", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_NATInfo(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_NATInfo\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:NATInfo", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

int __cdecl main(int argc, char* argv[])
{

    HRESULT hr;

    hr = CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        
        IUPnPDevice* pGatewayDevice;
        
        hr = FindGatewayDevice(&pGatewayDevice);
        if(SUCCEEDED(hr))
        {
//            TestInternetGatewayDevice_OSInfo(pGatewayDevice);
            
            IUPnPDevice* pWANDevice;
            hr = FindChildDevice(pGatewayDevice, &pWANDevice);
            if(SUCCEEDED(hr))
            {
                //TestWANDevice_WANCommonInterfaceConfig(pWANDevice);        

                IUPnPDevice* pWANConnectionDevice;
                hr = FindChildDevice(pWANDevice, &pWANConnectionDevice);
                if(SUCCEEDED(hr))
                {
                    //        TestWANCommonDevice_WANPOTSLinkConfig(pWANConnectionDevice); 
                    //        TestWANCommonDevice_WANPPPConnection(pWANConnectionDevice);
//                            TestWANCommonDevice_WANIPConnection(pWANConnectionDevice);
                            TestWANCommonDevice_NATStaticPortMapping(pWANConnectionDevice);
                            TestWANCommonDevice_NATDynamicPortMapping(pWANConnectionDevice);
                            TestWANCommonDevice_NATInfo(pWANConnectionDevice);
                    
                    pWANConnectionDevice->Release();
                }
                pWANDevice->Release();
            }
            pGatewayDevice->Release();
        }
        CoUninitialize();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\properties.cpp ===
#include "properties.h"
#include "util.h"

static const TCHAR c_szSharedAccessClientKeyPathDownlevel[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ICSClient");
static const TCHAR c_szShowIcon[] = TEXT("ShowIcon");

CPropertiesDialog::CPropertiesDialog(IInternetGateway* pInternetGateway)
{
    m_hIcon = NULL;
    m_pInternetGateway = pInternetGateway;
    m_pInternetGateway->AddRef();

}

CPropertiesDialog::~CPropertiesDialog()
{
    m_pInternetGateway->Release();
}


LRESULT CPropertiesDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    HRESULT hr = S_OK;
    
    // load the little icon, this can not be done in the rc file, it stretches the icon
    
    int cx = GetSystemMetrics(SM_CXSMICON);
    int cy = GetSystemMetrics(SM_CYSMICON);
    
    m_hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_GATEWAY), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR));
    if(NULL != m_hIcon)
    {
        SendDlgItemMessage(IDC_PROPERTIES_ADAPTERICON, STM_SETICON, reinterpret_cast<WPARAM>(m_hIcon), 0);
    }

    // set the text with the connection name
    
    LPTSTR pszConnectionName;
    hr = GetConnectionName(m_pInternetGateway, &pszConnectionName);
    if(SUCCEEDED(hr))
    {
        SetDlgItemText(IDC_PROPERTIES_ADAPTERNAME, pszConnectionName);
        
        LocalFree(pszConnectionName);
    }

    // check the show icon checkbox

    if(SUCCEEDED(ShouldShowIcon()))
    {
        CheckDlgButton(IDC_PROPERTIES_SHOWICON, BST_CHECKED);
    }

    return 0;
}

LRESULT CPropertiesDialog::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(NULL != m_hIcon)
    {
        DestroyIcon(m_hIcon);
    }

    return 0;
}

LRESULT CPropertiesDialog::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR* pNotifyHeader = reinterpret_cast<NMHDR*>(lParam);

    if(PSN_APPLY == pNotifyHeader->code)
    {
        SetShowIcon(BST_CHECKED == IsDlgButtonChecked(IDC_PROPERTIES_SHOWICON));
    }

    return 0;
}

HRESULT CPropertiesDialog::ShouldShowIcon(void)
{
    HRESULT hr = S_OK;
    
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPathDownlevel, NULL, KEY_QUERY_VALUE, &hKey))
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, c_szShowIcon, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue), &dwSize))
        {
            if(REG_DWORD == dwType && 0 == dwValue) 
            {
                hr = E_FAIL;
            }
        }
        RegCloseKey(hKey);
    }

    return hr;
}

HRESULT CPropertiesDialog::SetShowIcon(BOOL bShowIcon)
{
    HRESULT hr = S_OK;
    
    HKEY hKey;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPathDownlevel, NULL, TEXT(""), 0, KEY_SET_VALUE, NULL, &hKey, NULL))
    {
        DWORD dwValue = bShowIcon;
        if(ERROR_SUCCESS == RegSetValueEx(hKey, c_szShowIcon, NULL, REG_DWORD, reinterpret_cast<LPBYTE>(&dwValue), sizeof(dwValue)))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
        
        RegCloseKey(hKey);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\stdafx.h ===
#pragma once

#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#include "atlwin.h"
#include "upnp.h"
#include "icsdclt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\status.h ===
#pragma once

#include "stdafx.h"
#include <windows.h>
#include "resource.h"
#include "atlsnap.h"
#include "netconp.h"

class CStatusDialog : public CSnapInPropertyPageImpl<CStatusDialog, FALSE>
{

public:
    BEGIN_MSG_MAP(CStatusDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        COMMAND_ID_HANDLER(IDC_STATUS_PROPERTIES, OnProperties)
        COMMAND_ID_HANDLER(IDC_STATUS_DISCONNECT, OnDisconnect)
        COMMAND_ID_HANDLER(IDC_STATUS_CONNECT, OnConnect)
    END_MSG_MAP()

    enum { IDD = IDD_STATUS };    

    CStatusDialog(IInternetGateway* pInternetGateway);
    ~CStatusDialog();
    
private:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT UpdateButtons(NETCON_STATUS Status);

    IInternetGateway* m_pInternetGateway;
    UINT_PTR m_uTimerId;
    BOOL m_bGettingStatistics;
    BOOL m_bShowingBytes;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\idl\beaconrc.h ===
#pragma once

#define IDXML_LAN 1
#define IDXML_RAS 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\trayicon.h ===
#pragma once

#include "stdafx.h"
#include <windows.h>
#include "resource.h"
#include "beacon.h"
#include "winsock2.h"

#define WM_APP_TRAYMESSAGE WM_APP
#define WM_APP_ADDBEACON WM_APP+1 // wParam: unused, lParam: IInternetGateway*
#define WM_APP_REMOVEBEACON WM_APP+2 // wParam: unused, lParam: unused
#define WM_APP_SOCKET_NOTIFICATION WM_APP+3
#define WM_APP_GETBEACON WM_APP+4


class CICSTrayIcon : public CWindowImpl<CICSTrayIcon>
{

public:
    BEGIN_MSG_MAP(CICSTrayIcon)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_APP_TRAYMESSAGE, OnTrayMessage)
        MESSAGE_HANDLER(WM_APP_ADDBEACON, OnAddBeacon)
        MESSAGE_HANDLER(WM_APP_REMOVEBEACON, OnRemoveBeacon)
        MESSAGE_HANDLER(WM_APP_SOCKET_NOTIFICATION, OnSocketNotification)
        MESSAGE_HANDLER(WM_APP_GETBEACON, OnGetBeacon)
        COMMAND_ID_HANDLER(IDM_TRAYICON_STATUS, OnStatus)
        COMMAND_ID_HANDLER(IDM_TRAYICON_PROPERTIES, OnProperties)
        COMMAND_ID_HANDLER(IDM_TRAYICON_CONNECT, OnConnect)
        COMMAND_ID_HANDLER(IDM_TRAYICON_DISCONNECT, OnDisconnect)
    END_MSG_MAP()
    
    CICSTrayIcon();
    ~CICSTrayIcon();
    
private:
    HRESULT GetInternetGateway(IInternetGateway** ppInternetGateway);
    HRESULT ShowTrayIcon(UINT uID);
    HRESULT HideTrayIcon(UINT uID);
    HRESULT StartSearch(void);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEndSession(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTrayMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAddBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRemoveBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSocketNotification(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGetBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnStatus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    IInternetGateway* m_pInternetGateway;
    HRESULT m_hShowIconResult;
    IUPnPDeviceFinder* m_pDeviceFinder;
    LONG m_lSearchCookie;
    SOCKET m_DummySocket;

    BOOL m_bShowingProperties;
    BOOL m_bShowingStatus;
    DWORD m_dwRegisterClassCookie;
    BOOL m_bFileVersionsAccepted;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Internet Connection Sharing Client"
#define VER_INTERNALNAME_STR            "ICSDCLT.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\trayicon.cpp ===
#include "trayicon.h"
#include "resource.h"
#include "shellapi.h"
#include "windowsx.h"
#include "status.h"
#include "properties.h"
#include "util.h"
#include "stdio.h"
#include "client.h"
#include "InternetGatewayFinder.h"

CICSTrayIcon::CICSTrayIcon()
{
    m_pInternetGateway = NULL;
    m_hShowIconResult = E_FAIL;
    m_pDeviceFinder = NULL;
    m_DummySocket = INVALID_SOCKET;
    m_bShowingProperties = FALSE;
    m_bShowingStatus = FALSE;
    m_dwRegisterClassCookie = 0;
    m_bFileVersionsAccepted = FALSE;
}

CICSTrayIcon::~CICSTrayIcon()
{
}

LRESULT CICSTrayIcon::OnAddBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    IInternetGateway* pInternetGateway = reinterpret_cast<IInternetGateway*>(lParam);

    OnRemoveBeacon(WM_APP_REMOVEBEACON, 0, 0, bHandled);
    
    m_pInternetGateway = pInternetGateway;
    m_pInternetGateway->AddRef();
    m_hShowIconResult = ShowTrayIcon(0);

    return 0;
}

LRESULT CICSTrayIcon::OnRemoveBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    BSTR UniqueDeviceName = reinterpret_cast<BSTR>(lParam);
    
    if(NULL != m_pInternetGateway)
    {
        if(NULL != UniqueDeviceName)
        {
            BSTR CurrentUniqueDeviceName;
            hr = m_pInternetGateway->GetUniqueDeviceName(&CurrentUniqueDeviceName);
            if(SUCCEEDED(hr))
            {
                if(0 != wcscmp(UniqueDeviceName, CurrentUniqueDeviceName))
                {
                    hr = E_FAIL;
                }
                SysFreeString(CurrentUniqueDeviceName);
            }
        }
        if(SUCCEEDED(hr))
        {
            if(SUCCEEDED(m_hShowIconResult))
            {
                HideTrayIcon(0);
            }
            
            m_pInternetGateway->Release();
            m_pInternetGateway = NULL;
        }
    }

    return 0;
}

LRESULT CICSTrayIcon::OnGetBeacon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    IInternetGateway** ppInternetGateway = reinterpret_cast<IInternetGateway**>(lParam);

    hr = GetInternetGateway(ppInternetGateway);
   
    return SUCCEEDED(hr) ? 1 : 0;

}

HRESULT CICSTrayIcon::ShowTrayIcon(UINT uID)
{
    HRESULT hr = S_OK;
    hr = CPropertiesDialog::ShouldShowIcon();
    if(SUCCEEDED(hr))
    {
        int nHeight = GetSystemMetrics(SM_CYSMICON); // ok if these fails, LoadImage has default behavior
        int nWidth = GetSystemMetrics(SM_CXSMICON);
        
        NOTIFYICONDATA IconData;
        IconData.cbSize = NOTIFYICONDATA_V1_SIZE; // compat with pre IE5
        IconData.uID = uID;
        IconData.hWnd = m_hWnd; 
        IconData.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        IconData.uCallbackMessage = WM_APP_TRAYMESSAGE;
        IconData.hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_TRAYICON), IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR));
        lstrcpyn(IconData.szTip, TEXT("Internet Connection Sharing"), 64);
        if(FALSE == Shell_NotifyIcon(NIM_ADD, &IconData))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CICSTrayIcon::HideTrayIcon(UINT uID)
{
    HRESULT hr = S_OK;

    NOTIFYICONDATA IconData;
    IconData.cbSize = NOTIFYICONDATA_V1_SIZE; // compat with pre IE5
    IconData.hWnd = m_hWnd; 
    IconData.uID = uID;
    IconData.uFlags = 0;
    Shell_NotifyIcon(NIM_DELETE, &IconData);

    return hr;
}

HRESULT CICSTrayIcon::GetInternetGateway(IInternetGateway** ppInternetGateway)
{
    HRESULT hr = S_OK;
    
    *ppInternetGateway = NULL;

    if(NULL != m_pInternetGateway)
    {
        *ppInternetGateway = m_pInternetGateway;
        m_pInternetGateway->AddRef();
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

LRESULT CICSTrayIcon::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    
    // if not IE 5.01 we can't do UPnP, but the window must stay so it can later post error dialogs
    hr = EnsureFileVersion("wininet.dll", MakeQword4(5, 0, 2919, 6305)); 
    if(SUCCEEDED(hr))
    {
        hr = EnsureFileVersion("urlmon.dll", MakeQword4(5, 0, 2919, 6303)); 
    }
    
    if(SUCCEEDED(hr))
    {
        hr = EnsureFileVersion("msxml.dll", MakeQword4(5, 0, 2919, 6303)); 
    }
    
    if(SUCCEEDED(hr))
    {
        m_bFileVersionsAccepted = TRUE;

        IUPnPDeviceFinder* pDeviceFinder;
        hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, reinterpret_cast<void **>(&m_pDeviceFinder));
        if(SUCCEEDED(hr))
        {
            hr = StartSearch();
        }
        
        if(SUCCEEDED(hr))
        {
            m_DummySocket = socket(AF_INET, SOCK_DGRAM, 0);
            if(INVALID_SOCKET != m_DummySocket)
            {
                if(0 == WSAAsyncSelect(m_DummySocket, m_hWnd, WM_APP_SOCKET_NOTIFICATION, FD_ADDRESS_LIST_CHANGE))
                {
                    DWORD dwBytesReturned;
                    if(SOCKET_ERROR != WSAIoctl(m_DummySocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL, 0, &dwBytesReturned, NULL, NULL) || WSAEWOULDBLOCK != WSAGetLastError())
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        
        if(SUCCEEDED(hr))
        {
            CComObject<CInternetGatewayFinderClassFactory>* pInternetGatewayFinderClassFactory;
            hr = CComObject<CInternetGatewayFinderClassFactory>::CreateInstance(&pInternetGatewayFinderClassFactory);
            if(SUCCEEDED(hr))
            {
                pInternetGatewayFinderClassFactory->AddRef();
                
                hr = pInternetGatewayFinderClassFactory->Initialize(m_hWnd);
                if(SUCCEEDED(hr))
                {
                    hr = CoRegisterClassObject(CLSID_CInternetGatewayFinder, pInternetGatewayFinderClassFactory, CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &m_dwRegisterClassCookie);
                }
                
                pInternetGatewayFinderClassFactory->Release();
            }
            
        }
        
    }
    return 0;
}

LRESULT CICSTrayIcon::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DestroyWindow();
    return 0;
}

LRESULT CICSTrayIcon::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    OnRemoveBeacon(WM_APP_REMOVEBEACON, 0, 0, bHandled);
    
    if(NULL != m_pDeviceFinder)
    {
        m_pDeviceFinder->CancelAsyncFind(m_lSearchCookie); 
        m_pDeviceFinder->Release();
        m_pDeviceFinder = NULL;
    }

    if(INVALID_SOCKET != m_DummySocket)
    {
        closesocket(m_DummySocket);
    }
    
    if(0 != m_dwRegisterClassCookie)
    {
        CoRevokeClassObject(m_dwRegisterClassCookie);
    }
    
    PostQuitMessage(0);

    return 0;
}

LRESULT CICSTrayIcon::OnTrayMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    switch(lParam)
    {
    case WM_RBUTTONDOWN:
        {
            IInternetGateway* pInternetGateway;
            hr = GetInternetGateway(&pInternetGateway);
            if(SUCCEEDED(hr))
            {
                NETCON_MEDIATYPE MediaType;
                hr = pInternetGateway->GetMediaType(&MediaType);
                if(SUCCEEDED(hr))
                {
                    IUPnPService* pWANConnectionService;
                    hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
                    if(SUCCEEDED(hr))
                    {
                        NETCON_STATUS Status;
                        hr = GetConnectionStatus(pWANConnectionService, &Status);
                        if(SUCCEEDED(hr))
                        {
                            HMENU hMenu;
                            LPTSTR pszMenuID = NULL;
                            
                            if(NCS_CONNECTED == Status)
                            {
                                pszMenuID = NCM_SHAREDACCESSHOST_LAN == MediaType ? MAKEINTRESOURCE(IDM_TRAYICON_LAN_CONNECT) : MAKEINTRESOURCE(IDM_TRAYICON_RAS_CONNECT);
                            }
                            else if (NCS_DISCONNECTED == Status)
                            {
                                pszMenuID = NCM_SHAREDACCESSHOST_LAN == MediaType ? MAKEINTRESOURCE(IDM_TRAYICON_LAN_DISCONNECT) : MAKEINTRESOURCE(IDM_TRAYICON_RAS_DISCONNECT);
                            }
                            
                            if(NULL != pszMenuID)
                            {
                                hMenu = LoadMenu(_Module.GetResourceInstance(), pszMenuID);
                                if(NULL != hMenu)
                                {
                                    HMENU hSubMenu = GetSubMenu(hMenu, 0);
                                    if(NULL != hSubMenu)
                                    {
                                        POINT CursorPosition;
                                        if(GetCursorPos(&CursorPosition))
                                        {
                                            SetForegroundWindow(m_hWnd); // this is to get the menu to go away when it loses focus.  
                                            
                                            TrackPopupMenu(hSubMenu, TPM_RIGHTBUTTON, CursorPosition.x, CursorPosition.y, 0, m_hWnd, NULL);
                                        }
                                    }
                                    
                                    DestroyMenu(hMenu);
                                }
                            }
                        }
                        pWANConnectionService->Release();
                    }
                }
                pInternetGateway->Release();
            }
            break;
        }
    case WM_MOUSEMOVE: // REVIEW: is there a better message?
        {
            IInternetGateway* pInternetGateway;
            hr = GetInternetGateway(&pInternetGateway);
            if(SUCCEEDED(hr))
            {
                IUPnPService* pWANConnectionService;
                hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
                if(SUCCEEDED(hr))
                {
                    NETCON_STATUS Status;
                    hr = GetConnectionStatus(pWANConnectionService, &Status);
                    if(SUCCEEDED(hr))
                    {
                        TCHAR szConnectionStatus[64];
                        hr = ConnectionStatusToString(Status, szConnectionStatus, sizeof(szConnectionStatus) / sizeof(TCHAR));
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szFormat[64];
                            if(0 != LoadString(_Module.GetResourceInstance(), IDS_TOOLTIP_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                            {
                                NOTIFYICONDATA NotifyIconData;
                                ZeroMemory(&NotifyIconData, sizeof(NotifyIconData));
                                NotifyIconData.cbSize = NOTIFYICONDATA_V1_SIZE;
                                NotifyIconData.hWnd = m_hWnd;
                                NotifyIconData.uID = 0;
                                NotifyIconData.uFlags = NIF_TIP;
                                _sntprintf(NotifyIconData.szTip, 64, szFormat, szConnectionStatus);
                                NotifyIconData.szTip[63] = TEXT('\0'); // make sure a maximum length string is null terminated
                                
                                Shell_NotifyIcon(NIM_MODIFY, &NotifyIconData);
                            }
                        }
                    }
                    pWANConnectionService->Release();
                }
                pInternetGateway->Release();
            }
            break;
        }
        
    default:
        bHandled = FALSE;
        break;
    }
    return 0;
}

LRESULT CICSTrayIcon::OnStatus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    if(FALSE == m_bShowingStatus)
    {
        m_bShowingStatus = TRUE;

        IInternetGateway* pInternetGateway;
        hr = GetInternetGateway(&pInternetGateway);
        if(SUCCEEDED(hr))
        {
            LPTSTR pszConnectionName;
            hr = GetConnectionName(pInternetGateway, &pszConnectionName);
            if(SUCCEEDED(hr))
            {
                TCHAR szFormat[32];
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_STATUS_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                {
                    
                    LPTSTR pszArguments[] = {pszConnectionName};
                    LPTSTR pszFormattedString;
                    if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, reinterpret_cast<LPTSTR>(&pszFormattedString), 0, pszArguments))
                    {
                        CStatusDialog StatusDialog(pInternetGateway);
                        HPROPSHEETPAGE hStatusPage = StatusDialog.Create();
                        if(NULL != hStatusPage)
                        {
                            
                            HPROPSHEETPAGE PropertySheetPages[1];
                            PropertySheetPages[0] = hStatusPage;
                            
                            PROPSHEETHEADER PropertySheetHeader;
                            ZeroMemory(&PropertySheetHeader, sizeof(PropertySheetHeader));
                            PropertySheetHeader.dwSize = PROPSHEETHEADER_V1_SIZE;
                            PropertySheetHeader.dwFlags = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
                            PropertySheetHeader.hwndParent = m_hWnd;
                            PropertySheetHeader.pszCaption = pszFormattedString;
                            PropertySheetHeader.hInstance = _Module.GetResourceInstance();
                            PropertySheetHeader.nPages = 1;
                            PropertySheetHeader.phpage = PropertySheetPages;
                            
                            PropertySheet(&PropertySheetHeader);
                        }
                        LocalFree(pszFormattedString);
                    }
                }
                LocalFree(pszConnectionName);
            }
            pInternetGateway->Release();
        }
        else // if not beacon was detected
        {
            TCHAR szTitle[128];
            TCHAR szText[1024];

            if(NULL != LoadString(_Module.GetResourceInstance(), IDS_APPTITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR)))
            {
                if(TRUE == m_bFileVersionsAccepted)
                {
                    if(NULL != LoadString(_Module.GetResourceInstance(), IDS_BEACONNOTFOUND, szText, sizeof(szText) / sizeof(TCHAR)))
                    {
                        MessageBox(szText, szTitle);                    
                    }
                }
                else
                {
                    if(NULL != LoadString(_Module.GetResourceInstance(), IDS_NEEDNEWERIE, szText, sizeof(szText) / sizeof(TCHAR)))
                    {
                        MessageBox(szText, szTitle);                    
                    }
                }
            }
        }
    
        m_bShowingStatus = FALSE;
    }
    return 0;
}

extern HPROPSHEETPAGE GetSharedAccessPropertyPage (IInternetGateway* pInternetGateway, HWND hwndOwner);   // in saprop.cpp
LRESULT CICSTrayIcon::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    if(FALSE == m_bShowingProperties)
    {
        m_bShowingProperties = TRUE;

        IInternetGateway* pInternetGateway;
        hr = GetInternetGateway(&pInternetGateway);
        if(SUCCEEDED(hr))
        {
            CPropertiesDialog PropertiesDialog(pInternetGateway);
            HPROPSHEETPAGE hStatusPage = PropertiesDialog.Create();
            if(NULL != hStatusPage)
            {
                LPTSTR pszConnectionName;
                hr = GetConnectionName(pInternetGateway, &pszConnectionName);
                if(SUCCEEDED(hr))
                {
                    TCHAR szFormat[32];
                    if(0 != LoadString(_Module.GetResourceInstance(), IDS_PROPERTIES_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                    {
                        
                        LPTSTR pszArguments[] = {pszConnectionName};
                        LPTSTR pszFormattedString;
                        if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, reinterpret_cast<LPTSTR>(&pszFormattedString), 0, pszArguments))
                        {
                            HPROPSHEETPAGE PropertySheetPages[2];
                            PropertySheetPages[0] = hStatusPage;
                            PropertySheetPages[1] = GetSharedAccessPropertyPage (pInternetGateway, hWndCtl);
                            
                            PROPSHEETHEADER PropertySheetHeader;
                            ZeroMemory(&PropertySheetHeader, sizeof(PropertySheetHeader));
                            PropertySheetHeader.dwSize = PROPSHEETHEADER_V1_SIZE;
                            PropertySheetHeader.dwFlags = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
                            PropertySheetHeader.hwndParent = m_hWnd;
                            PropertySheetHeader.pszCaption = pszFormattedString;
                            PropertySheetHeader.hInstance = _Module.GetResourceInstance();
                            PropertySheetHeader.phpage = PropertySheetPages;
                            PropertySheetHeader.nPages = PropertySheetPages[1] ? 2 : 1;
                            
                            PropertySheet(&PropertySheetHeader);
                            
                            HRESULT hShouldShowIcon = CPropertiesDialog::ShouldShowIcon();
                            if(SUCCEEDED(hShouldShowIcon))   // if we are now showing the icon
                            {
                                if(FAILED(m_hShowIconResult)) // and weren't before
                                {
                                    m_hShowIconResult = ShowTrayIcon(0); // show it
                                }
                            }
                            else // if we are not hiding the icon
                            {
                                if(SUCCEEDED(m_hShowIconResult)) // and were showing it before
                                {
                                    HideTrayIcon(0); // hide it
                                    m_hShowIconResult = E_FAIL;
                                }
                            }
                            
                            LocalFree(pszFormattedString);
                        }
                        
                    }
                    
                    LocalFree(pszConnectionName);
                }
            }
            pInternetGateway->Release();
        }
        m_bShowingProperties = FALSE;
    }
    return 0;
}

LRESULT CICSTrayIcon::OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;

    IInternetGateway* pInternetGateway;
    hr = GetInternetGateway(&pInternetGateway);
    if(SUCCEEDED(hr))
    {
        IUPnPService* pWANConnectionService;
        hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
        if(SUCCEEDED(hr))
        {
            VARIANT OutArgs;
            hr = InvokeVoidAction(pWANConnectionService, L"RequestConnection", &OutArgs);
            if(SUCCEEDED(hr))
            {
                VariantClear(&OutArgs);
            }
            else if(UPNP_ACTION_HRESULT(800) == hr)
            {
                ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
            }
            else if(UPNP_E_DEVICE_TIMEOUT != hr)
            {
                ShowErrorDialog(m_hWnd, IDS_CONNECTIONFAILED);
            }

            
            pWANConnectionService->Release();
        }
        pInternetGateway->Release();
    }
    return 0;
}

LRESULT CICSTrayIcon::OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    IInternetGateway* pInternetGateway;
    hr = GetInternetGateway(&pInternetGateway);
    if(SUCCEEDED(hr))
    {
        IUPnPService* pWANConnectionService;
        hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
        if(SUCCEEDED(hr))
        {
            VARIANT OutArgs;
            hr = InvokeVoidAction(pWANConnectionService, L"ForceTermination", &OutArgs);
            if(SUCCEEDED(hr))
            {
                VariantClear(&OutArgs);
            }
            else if(UPNP_ACTION_HRESULT(800) == hr)
            {
                ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
            }

            
            pWANConnectionService->Release();
        }
        pInternetGateway->Release();
    }

    return 0;
}


LRESULT CICSTrayIcon::OnSocketNotification(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr S_OK;

    if(FD_ADDRESS_LIST_CHANGE == WSAGETSELECTEVENT(lParam))
    {
        if(NULL != m_pDeviceFinder)
        {
            hr = m_pDeviceFinder->CancelAsyncFind(m_lSearchCookie);
            hr = StartSearch();
        }
        
        DWORD dwBytesReturned;
        if(SOCKET_ERROR != WSAIoctl(m_DummySocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL, 0, &dwBytesReturned, NULL, NULL) || WSAEWOULDBLOCK != WSAGetLastError())
        {
            hr = E_FAIL;
        }
    }

    return 0;
}

HRESULT CICSTrayIcon::StartSearch(void)
{
    HRESULT hr = S_OK;
    

    BOOL bHandled;
    OnRemoveBeacon(WM_APP_REMOVEBEACON, 0, 0, bHandled); // dump out the cache
   
    CComObject<CBeaconFinder>* pBeaconFinder;
    hr = CComObject<CBeaconFinder>::CreateInstance(&pBeaconFinder);
    if(SUCCEEDED(hr))
    {
        pBeaconFinder->AddRef();
        
        hr = pBeaconFinder->Initialize(m_hWnd);
        if(SUCCEEDED(hr))
        {
            BSTR bstrTypeURI;
            bstrTypeURI = SysAllocString(L"urn:schemas-upnp-org:device:InternetGatewayDevice:1");
            if (NULL != bstrTypeURI)
            {
                hr = m_pDeviceFinder->CreateAsyncFind(bstrTypeURI, 0, pBeaconFinder, &m_lSearchCookie);
                if(SUCCEEDED(hr))
                {
                    hr = m_pDeviceFinder->StartAsyncFind(m_lSearchCookie);
                    
                }
                
                if(FAILED(hr)) // we must close this here because later calls don't know if the cookie is valid
                {
                    m_pDeviceFinder->Release();
                    m_pDeviceFinder = NULL;
                    
                }
                
                SysFreeString(bstrTypeURI);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        pBeaconFinder->Release();
    }

    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\util.cpp ===
#include "stdafx.h"
#include "util.h"
#include "upnp.h"
#include "stdio.h"
#include "resource.h"

HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;
    
    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName; 
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        
        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }
        
        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}

HRESULT InvokeVoidAction(IUPnPService * pService, LPWSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        SAFEARRAYBOUND  rgsaBound[1];
        SAFEARRAY       * psa = NULL;

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

        if (psa)
        {
            LONG    lStatus;
            VARIANT varInArgs;
            VARIANT varReturnVal;

            VariantInit(&varInArgs);
            VariantInit(pOutParams);
            VariantInit(&varReturnVal);

            varInArgs.vt = VT_VARIANT | VT_ARRAY;

            V_ARRAY(&varInArgs) = psa;

            hr = pService->InvokeAction(bstrActionName,
                                        varInArgs,
                                        pOutParams,
                                        &varReturnVal);
            if(SUCCEEDED(hr))
            {
                VariantClear(&varReturnVal);
            }

            SafeArrayDestroy(psa);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }   

        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT GetConnectionName(IInternetGateway* pInternetGateway, LPTSTR* ppszConnectionName) // use LocalFree to free ppszConnectionName
{
    HRESULT hr = S_OK;

    *ppszConnectionName = NULL;

    IUPnPService* pWANConnectionService;
    hr = GetWANConnectionService(pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        BSTR ConnectionName;
        hr = GetStringStateVariable(pWANConnectionService, L"X_Name", &ConnectionName);
        if(SUCCEEDED(hr))
        {
            LPSTR pszConnectionName;
            hr = UnicodeToAnsi(ConnectionName, SysStringLen(ConnectionName), &pszConnectionName);
            {
                IUPnPService* pOSInfoService;
                hr = pInternetGateway->GetService(SAHOST_SERVICE_OSINFO, &pOSInfoService);
                if(SUCCEEDED(hr))
                {
                    BSTR MachineName;
                    hr = GetStringStateVariable(pOSInfoService, L"OSMachineName", &MachineName);
                    if(SUCCEEDED(hr))
                    {
                        LPSTR pszMachineName;
                        hr = UnicodeToAnsi(MachineName, SysStringLen(MachineName), &pszMachineName);
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szFormat[16];
                            if(0 != LoadString(_Module.GetResourceInstance(), IDS_NAME_FORMAT, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
                            {
                                LPTSTR pszArguments[] = {pszConnectionName, pszMachineName};
                                LPTSTR pszFormattedName;
                                if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, reinterpret_cast<LPTSTR>(&pszFormattedName), 0, pszArguments))
                                {
                                    *ppszConnectionName = pszFormattedName;
                                }
                                else
                                {
                                    hr = E_FAIL;
                                }
                                
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                            CoTaskMemFree(pszMachineName);
                        }
                        SysFreeString(MachineName);
                    }
                    pOSInfoService->Release();
                }
                CoTaskMemFree(pszConnectionName);
            }
            SysFreeString(ConnectionName);
        }
        pWANConnectionService->Release();
    }

    if(FAILED(hr))
    {
        hr = S_OK;
        
        LPTSTR pszDefaultName = reinterpret_cast<LPTSTR>(LocalAlloc(0, 128 * sizeof(TCHAR)));
        if(NULL != pszDefaultName)
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_DEFAULTADAPTERNAME, pszDefaultName, 128))
            {
                *ppszConnectionName = pszDefaultName;
            }
            else
            {
                LocalFree(pszDefaultName);
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT GetWANConnectionService(IInternetGateway* pInternetGateway, IUPnPService** ppWANConnectionService)
{
    HRESULT hr = S_OK;

    *ppWANConnectionService = NULL;

    if(NULL != pInternetGateway)
    {
        NETCON_MEDIATYPE MediaType;
        hr = pInternetGateway->GetMediaType(&MediaType);
        if(SUCCEEDED(hr))
        {
            if(NCM_SHAREDACCESSHOST_LAN == MediaType)
            {
                hr = pInternetGateway->GetService(SAHOST_SERVICE_WANIPCONNECTION, ppWANConnectionService);
            }
            else if(NCM_SHAREDACCESSHOST_RAS == MediaType)
            {
                hr = pInternetGateway->GetService(SAHOST_SERVICE_WANPPPCONNECTION, ppWANConnectionService);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
            
            
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return hr;
}

HRESULT UnicodeToAnsi(LPWSTR pszUnicodeString, ULONG ulUnicodeStringLength, LPSTR* ppszAnsiString)
{
    HRESULT hr = S_OK;

    int nSizeNeeded = WideCharToMultiByte(CP_ACP, 0, pszUnicodeString, ulUnicodeStringLength + 1, NULL, 0, NULL, NULL);            
    if(nSizeNeeded != 0)
    {
        LPSTR pszAnsiString = reinterpret_cast<LPSTR>(CoTaskMemAlloc(nSizeNeeded));
        if(NULL != pszAnsiString)
        {
            if(0 != WideCharToMultiByte(CP_ACP, 0, pszUnicodeString, ulUnicodeStringLength + 1, pszAnsiString, nSizeNeeded, NULL, NULL))
            {
                *ppszAnsiString = pszAnsiString;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT FormatTimeDuration(UINT uSeconds, LPTSTR pszTimeDuration, SIZE_T uTimeDurationLength)
{
    HRESULT hr = S_OK;

    TCHAR   szTimeSeperator[5]; // 4 is the maximum length for szTimeSeperator
    if(0 != GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szTimeSeperator, sizeof(szTimeSeperator) / sizeof(TCHAR)))
    {
        UINT uMinutes = uSeconds / 60;

        uSeconds = uSeconds % 60;
        
        UINT uHours = uMinutes / 60;

        uMinutes = uMinutes % 60;

        UINT uDays = uHours / 24;

        uHours = uHours % 24;


        TCHAR szFormat[64];
        
        if(0 == uDays)
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_UPTIME_ZERODAYS, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
            {
                _sntprintf(pszTimeDuration, uTimeDurationLength, szFormat, uHours, szTimeSeperator, uMinutes, szTimeSeperator, uSeconds);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        } 
        else if (1 == uDays)
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_UPTIME_ONEDAY, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
            {
                _sntprintf(pszTimeDuration, uTimeDurationLength, szFormat, uHours, szTimeSeperator, uMinutes, szTimeSeperator, uSeconds);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            if(0 != LoadString(_Module.GetResourceInstance(), IDS_UPTIME_MANYDAYS, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
            {
                _sntprintf(pszTimeDuration, uTimeDurationLength, szFormat, uDays, uHours, szTimeSeperator, uMinutes, szTimeSeperator, uSeconds);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }

        pszTimeDuration[uTimeDurationLength - 1] = TEXT('\0');

    }
    else
    {
        hr = E_FAIL;
    }
    
    return S_OK;
}

HRESULT FormatBytesPerSecond(UINT uBytesPerSecond, LPTSTR pszBytesPerSecond, SIZE_T uBytesPerSecondLength)
{
    HRESULT hr = S_OK;
    
    enum            {eZero = 0, eKilo, eMega, eGiga, eTera, eMax};
    INT             iOffset             = 0;
    UINT            uiDecimal           = 0;
    const UINT c_uiKilo = 1000;

    for (iOffset = eZero; iOffset < eMax; iOffset++)
    {

        // If we still have data, increment the counter
        //
        if (c_uiKilo > uBytesPerSecond)
        {
            break;
        }

        // Divide up the string
        //
        uiDecimal   = (uBytesPerSecond % c_uiKilo);
        uBytesPerSecond       /= c_uiKilo;
    }

    // We only want one digit for the decimal
    //
    uiDecimal /= (c_uiKilo/10);

    // Get the string used to display
    //
    TCHAR szFormat[64];
    if(0 != LoadString(_Module.GetResourceInstance(), IDS_METRIC_ZERO + iOffset, szFormat, sizeof(szFormat) / sizeof(TCHAR)))
    {
        _sntprintf(pszBytesPerSecond, uBytesPerSecondLength, szFormat, uBytesPerSecond, uiDecimal);
        pszBytesPerSecond[uBytesPerSecondLength - 1] = TEXT('\0');
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

HRESULT GetConnectionStatus(IUPnPService* pWANConnection, NETCON_STATUS* pStatus)
{
    HRESULT hr = S_OK;
    
    BSTR ConnectionStatus;
    hr = GetStringStateVariable(pWANConnection, L"ConnectionStatus", &ConnectionStatus);
    if(SUCCEEDED(hr))
    {
        if(0 == wcscmp(ConnectionStatus, L"Connected"))
        {
            *pStatus = NCS_CONNECTED;    
        }
        else if(0 == wcscmp(ConnectionStatus, L"Connecting"))
        {
            *pStatus = NCS_CONNECTING;    
        }
        else if(0 == wcscmp(ConnectionStatus, L"Disconnected"))
        {
            *pStatus = NCS_DISCONNECTED;
        }
        else if(0 == wcscmp(ConnectionStatus, L"Disconnecting"))
        {
            *pStatus = NCS_DISCONNECTING;
        }
        else
        {
            *pStatus = NCS_HARDWARE_DISABLED;
        }
        SysFreeString(ConnectionStatus);
    }

    return hr;
}

HRESULT ConnectionStatusToString(NETCON_STATUS Status, LPTSTR szBuffer, int nBufferSize)
{
    HRESULT hr = S_OK;
    UINT uStringID = 0;    
    
    switch(Status)
    {
    case NCS_CONNECTED:
        uStringID = IDS_CONNECTED;
        break;
    case NCS_CONNECTING:
        uStringID = IDS_CONNECTING;
        break;
    case NCS_DISCONNECTED:
        uStringID = IDS_DISCONNECTED;
        break;
    case NCS_DISCONNECTING:
        uStringID = IDS_DISCONNECTING;
        break;
    default:
        uStringID = IDS_UNCONFIGURED;
        break;
    }

    if(0 == LoadString(_Module.GetResourceInstance(), uStringID, szBuffer, nBufferSize))
    {
        hr = E_FAIL;
    }

    return hr;
}

LRESULT ShowErrorDialog(HWND hParentWindow, UINT uiErrorString)
{
    TCHAR szTitle[128];
    TCHAR szText[1024];
    
    if(NULL != LoadString(_Module.GetResourceInstance(), IDS_APPTITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR)))
    {
        if(NULL != LoadString(_Module.GetResourceInstance(), uiErrorString, szText, sizeof(szText) / sizeof(TCHAR)))
        {
            MessageBox(hParentWindow, szText, szTitle, MB_OK);                    
        }
    }

    return 0;
}

UINT64 MakeQword2(DWORD a, DWORD b)
{
    UINT64 qw = a;
    qw = qw << 32;
    qw |= b;
    return qw;    
}

UINT64 MakeQword4(WORD a, WORD b, WORD c, WORD d)
{
    UINT64 qw = a;
    qw = qw << 16;
    qw |= b;
    qw = qw << 16;
    qw |= c;
    qw = qw << 16;
    qw |= d;
    return qw;    
}

HRESULT EnsureFileVersion(LPTSTR pszModule, UINT64 qwDesiredVersion)
{
    HRESULT hr = S_OK;

    DWORD dwDummy;
    DWORD dwVersionSize = GetFileVersionInfoSize(pszModule, &dwDummy);
    if(0!= dwVersionSize)
    {
        void* pVersionInfo = CoTaskMemAlloc(dwVersionSize);
        if(NULL != pVersionInfo)
        {
            if(0 != GetFileVersionInfo(pszModule, 0, dwVersionSize, pVersionInfo))
            {
                void* pSubInfo;
                UINT uiSubInfoSize;
                if(0 != VerQueryValue(pVersionInfo, TEXT("\\"), &pSubInfo, &uiSubInfoSize))
                {
                    VS_FIXEDFILEINFO* pFixedFileInfo = reinterpret_cast<VS_FIXEDFILEINFO*>(pSubInfo);
                    UINT64 qwFileVersion = MakeQword2(pFixedFileInfo->dwProductVersionMS, pFixedFileInfo->dwProductVersionLS);
                    if(qwFileVersion < qwDesiredVersion)
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }

            CoTaskMemFree(pVersionInfo);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\client\util.h ===
#pragma once

#include "netconp.h"
#include "upnp.h"
    
#define UPNP_ACTION_HRESULT(lError) (UPNP_E_ACTION_SPECIFIC_BASE + (lError - FAULT_ACTION_SPECIFIC_BASE))

UINT64 MakeQword2(DWORD a, DWORD b);
UINT64 MakeQword4(WORD a, WORD b, WORD c, WORD d);

HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);
HRESULT InvokeVoidAction(IUPnPService * pService, LPWSTR pszCommand, VARIANT* pOutParams);
HRESULT GetConnectionName(IInternetGateway* pInternetGateway, LPTSTR* ppszConnectionName);
HRESULT GetWANConnectionService(IInternetGateway* pInternetGateway, IUPnPService** ppWANConnectionService);
HRESULT UnicodeToAnsi(LPWSTR pszUnicodeString, ULONG ulUnicodeStringLength, LPSTR* ppszAnsiString);
HRESULT FormatTimeDuration(UINT uSeconds, LPTSTR pszTimeDuration, SIZE_T uTimeDurationLength);
HRESULT FormatBytesPerSecond(UINT uBytesPerSecond, LPTSTR pszBytesPerSecond, SIZE_T uBytesPerSecondLength);
HRESULT GetConnectionStatus(IUPnPService* pWANConnection, NETCON_STATUS* pStatus);
HRESULT ConnectionStatusToString(NETCON_STATUS Status, LPTSTR szBuffer, int nBufferSize);
HRESULT EnsureFileVersion(LPTSTR pszModule, UINT64 qwDesiredVersion);

LRESULT ShowErrorDialog(HWND hParentWindow, UINT uiErrorString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\api.h ===
#pragma once

#include "InternetGatewayDevice.h"
#include "beacon.h" // public apis

HRESULT AdviseNATEvents(INATEventsSink* pNATEventsSink);
HRESULT UnadviseNATEvents(INATEventsSink* pNATEventsSink);
HRESULT FireNATEvent_PublicIPAddressChanged(void);
HRESULT FireNATEvent_PortMappingsChanged(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\api.cpp ===
#include "pch.h"
#pragma hdrstop
#include "api.h"
#include "upnphost.h"
#include "CInternetGatewayDevice.h"
#include "beaconrc.h"
#include "util.h"

HRESULT BeaconEnabled(void);

static const WCHAR c_szSharedAccessClientKeyPath[] = L"System\\CurrentControlSet\\Control\\Network\\SharedAccessConnection";
static BSTR g_DeviceId = NULL;
static BOOL g_bStarted = FALSE;
static INATEventsSink* g_pNATEventsSink;


CRITICAL_SECTION g_RegistrationProtection;
CRITICAL_SECTION g_NATEventsProtection;

HRESULT GetXMLPath(BSTR* pPath)
{
    HRESULT hr = S_OK;

    *pPath = NULL;

    WCHAR szXMLDirectory[] = L"ICSXML";
    WCHAR szSystemDirectory[MAX_PATH + 1 + (sizeof(szXMLDirectory) / sizeof(WCHAR))];
    UINT uiSize = GetSystemDirectory(szSystemDirectory, MAX_PATH);
    if(0 != uiSize)
    {
        if(L'\\' != szSystemDirectory[uiSize])
        {
            szSystemDirectory[uiSize] = L'\\';
            uiSize++;
        }
        
        lstrcpy(&szSystemDirectory[uiSize], szXMLDirectory);
        *pPath = SysAllocString(szSystemDirectory);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT GetDescriptionDocument(INT nResource, BSTR* pDocument)
{
    HRESULT hr = E_FAIL;
    
    *pDocument = NULL;

    HRSRC hrsrc = FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(nResource), L"XML"); // REVIEW change this from 1
    if(hrsrc)
    {
        HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hrsrc);
        if(hGlobal)
        {
            void* pvData = LockResource(hGlobal);
            if(pvData)
            {
                long nLength = SizeofResource(_Module.GetResourceInstance(), hrsrc);
                WCHAR * sz = new WCHAR[nLength + 1];
                if(NULL != sz)
                {
                    if(0 != MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinterpret_cast<char*>(pvData), nLength, sz, nLength))
                    {
                        sz[nLength] = 0;
                        *pDocument = SysAllocString(sz);
                        if(NULL != *pDocument)
                        {
                            hr = S_OK;
                        }
                    }
                    delete [] sz;
                }
            }
            FreeResource(hGlobal);
        }
    }
    return hr;

}

HRESULT WINAPI InitializeBeaconSvr()
{
    __try 
    {
        InitializeCriticalSection(&g_RegistrationProtection);
        InitializeCriticalSection(&g_NATEventsProtection);
    } __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT WINAPI TerminateBeaconSvr()
{
    DeleteCriticalSection(&g_RegistrationProtection);
    DeleteCriticalSection(&g_NATEventsProtection);
    return S_OK;
}

HRESULT WINAPI StartBeaconSvr(void)
{
    HRESULT hr = S_OK;

    //
    // Check if OS is a workstation (Per/Pro) Type
    //
    if ( FALSE == IsAllowedBeaconOSType() )
    {
        return hr;
    }

    EnterCriticalSection(&g_RegistrationProtection);
    
    g_bStarted = TRUE;  

    if(NULL == g_DeviceId)
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
        if(SUCCEEDED(hr))
        {
            hr = BeaconEnabled();
            if(SUCCEEDED(hr))
            {
                IUPnPRegistrar* pRegistrar;
                hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
                if(SUCCEEDED(hr))
                {
                    SetProxyBlanket(pRegistrar);

                    hr = CSwitchSecurityContext::ObtainImpersonationToken();
                    _ASSERT( SUCCEEDED(hr) );
                    
                    CComObject<CInternetGatewayDevice>* pGatewayDevice;
                    hr = CComObject<CInternetGatewayDevice>::CreateInstance(&pGatewayDevice);
                    if(SUCCEEDED(hr))
                    {
                        pGatewayDevice->AddRef();
                        
                        BSTR bstrData;
                        hr = GetDescriptionDocument(NCM_LAN == pGatewayDevice->m_pWANCommonInterfaceConfigService->m_MediaType ? IDXML_LAN : IDXML_RAS, &bstrData);
                        if(SUCCEEDED(hr))
                        {
                            BSTR bstrInitString = SysAllocString(L"Init");
                            if(NULL != bstrInitString)
                            {
                                BSTR pPath;
                                hr = GetXMLPath(&pPath);
                                if(SUCCEEDED(hr))
                                {
                                    hr = pRegistrar->RegisterRunningDevice(bstrData, static_cast<IUPnPDeviceControl*>(pGatewayDevice), bstrInitString, pPath, 1800, &g_DeviceId);
                                    
                                    SysFreeString(pPath);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                                SysFreeString(bstrInitString);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            SysFreeString(bstrData);
                        }
                        pGatewayDevice->Release();
                    }
                    pRegistrar->Release();
                }
            }
            CoUninitialize();
        }
    }

    LeaveCriticalSection(&g_RegistrationProtection);

    return hr;
}

HRESULT WINAPI SignalBeaconSvr(void)
{
    HRESULT hr = S_OK;

    //
    // Check if OS is a workstation (Per/Pro) Type
    //
    if ( FALSE == IsAllowedBeaconOSType() )
    {
        return hr;
    }


    // go ahead and dump the whole object since the services need for the client are different.  
    //
    if(TRUE == g_bStarted)
    {
        hr = StopBeaconSvr();
        if(SUCCEEDED(hr))
        {
            hr = StartBeaconSvr();
        }
    }
    return hr;
}

HRESULT WINAPI StopBeaconSvr(void)
{
    HRESULT hr = S_OK;
    IUPnPRegistrar* pRegistrar;

    //
    // Check if OS is a workstation (Per/Pro) Type
    //
    if ( FALSE == IsAllowedBeaconOSType() )
    {
        return hr;
    }


    EnterCriticalSection(&g_RegistrationProtection);

    if(NULL != g_DeviceId)
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
        if(SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
            if(SUCCEEDED(hr))
            {
                SetProxyBlanket(pRegistrar);
                hr = pRegistrar->UnregisterDevice(g_DeviceId, TRUE);
                pRegistrar->Release();
            }
            SysFreeString(g_DeviceId);
            
            g_DeviceId = NULL;

            CoUninitialize();
        }

    }
    
    g_bStarted = FALSE;

    CSwitchSecurityContext::DestroyImpersonationToken ();
    
    LeaveCriticalSection(&g_RegistrationProtection);

    return hr;
}

HRESULT BeaconEnabled(void)
{
    HRESULT hr = S_OK;
    
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, NULL, KEY_QUERY_VALUE, &hKey))
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, L"DisableBeacon", NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue), &dwSize))
        {
            if(REG_DWORD == dwType && 0 != dwValue) 
            {
                hr = E_FAIL;
            }
        }
        RegCloseKey(hKey);
    }

    return hr;
}


// This function must be called on an MTA thread          
HRESULT AdviseNATEvents(INATEventsSink* pNATEventsSink)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    if(NULL == g_pNATEventsSink)
    {
        g_pNATEventsSink = pNATEventsSink;
        g_pNATEventsSink->AddRef();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    LeaveCriticalSection(&g_NATEventsProtection);
    

    return hr;
}

// This function must be called on an MTA thread          
HRESULT UnadviseNATEvents(INATEventsSink* pNatEventsSink)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    if(NULL != g_pNATEventsSink)
    {
        g_pNATEventsSink->Release();
        g_pNATEventsSink = NULL;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    LeaveCriticalSection(&g_NATEventsProtection);
    
    return hr;
}

HRESULT WINAPI FireNATEvent_PublicIPAddressChanged(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
    if(SUCCEEDED(hr))
    {
        if(NULL != g_pNATEventsSink)
        {
            g_pNATEventsSink->PublicIPAddressChanged();
        }
        CoUninitialize();
    }

    LeaveCriticalSection(&g_NATEventsProtection);

    return hr;
}

HRESULT WINAPI FireNATEvent_PortMappingsChanged(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_NATEventsProtection);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE); // Ensure we are in the MTA
    if(SUCCEEDED(hr))
    {
        if(NULL != g_pNATEventsSink)
        {
            g_pNATEventsSink->PortMappingsChanged();
        }
        CoUninitialize();
    }

    LeaveCriticalSection(&g_NATEventsProtection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\beaconbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S D E V B A S E . H 
//
//  Contents:   Base include file for sdev.dll. Global defines.
//
//  Notes:      
//
//  Author:     mbend   25 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//#include "ncatl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cinternetgatewaydevice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . C P P 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "stdio.h"
#include "CInternetGatewayDevice.h"
#include "COSInfoService.h"
#include "CWANCommonInterfaceConfigService.h"
#include "CWANIPConnectionService.h"
#include "CWANPOTSLinkConfigService.h"
#include "util.h"


CInternetGatewayDevice::CInternetGatewayDevice()
{
    m_pOSInfoService = NULL;
    m_pWANCommonInterfaceConfigService = NULL;
}

HRESULT CInternetGatewayDevice::FinalConstruct()
{
    HRESULT hr = S_OK;
    
    hr = CComObject<COSInfoService>::CreateInstance(&m_pOSInfoService);
    if(SUCCEEDED(hr))
    {
        m_pOSInfoService->AddRef();
    }
    
    if(SUCCEEDED(hr))
    {
        hr = CComObject<CWANCommonInterfaceConfigService>::CreateInstance(&m_pWANCommonInterfaceConfigService);
        if(SUCCEEDED(hr))
        {
            m_pWANCommonInterfaceConfigService->AddRef();
        }
    }
    return hr;

}

HRESULT CInternetGatewayDevice::FinalRelease()
{
    HRESULT hr = S_OK;
    
    if(NULL != m_pOSInfoService)
    {
        m_pOSInfoService->Release();
    }

    if(NULL != m_pWANCommonInterfaceConfigService)
    {
        m_pWANCommonInterfaceConfigService->Release();
    }

    return S_OK;
}


STDMETHODIMP CInternetGatewayDevice::Initialize(BSTR bstrXMLDesc, BSTR bstrDeviceIdentifier, BSTR bstrInitString)
{
    HRESULT hr = S_OK;

    IUPnPRegistrar* pRegistrar;
    hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_SERVER, IID_IUPnPRegistrar, reinterpret_cast<void**>(&pRegistrar));
    if(SUCCEEDED(hr))
    {
        SetProxyBlanket(pRegistrar);
        
        BSTR bstrUDN = NULL;
        BSTR bstrTemplateUDN = SysAllocString(L"DummyUDN");
        if(!bstrTemplateUDN)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            hr = pRegistrar->GetUniqueDeviceName(bstrDeviceIdentifier, bstrTemplateUDN, &bstrUDN);
            if(SUCCEEDED(hr))
            {
                SysFreeString(bstrUDN);
            }
            SysFreeString(bstrTemplateUDN);
        }
        pRegistrar->Release();
    }
    return hr;
}

STDMETHODIMP CInternetGatewayDevice::GetServiceObject(BSTR bstrUDN, BSTR bstrServiceId,IDispatch** ppdispService)
{
    HRESULT hr = E_NOINTERFACE;

    *ppdispService = NULL;

    if(0 == lstrcmp(bstrServiceId, L"urn:microsoft-com:serviceId:OSInfo1"))
    {
        hr = m_pOSInfoService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANCommonIFC1"))
    {
        hr = m_pWANCommonInterfaceConfigService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANPOTSLinkC1"))
    {
        if(NULL != m_pWANCommonInterfaceConfigService->m_pWANPOTSLinkConfigService)
        {
            hr = m_pWANCommonInterfaceConfigService->m_pWANPOTSLinkConfigService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
        }
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANPPPConn1"))
    {
        if(NULL != m_pWANCommonInterfaceConfigService->m_pWANPPPConnectionService)
        {
            hr = m_pWANCommonInterfaceConfigService->m_pWANPPPConnectionService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
        }
    } 
    else if(0 == lstrcmp(bstrServiceId, L"urn:upnp-org:serviceId:WANIPConn1"))
    {
        if(NULL != m_pWANCommonInterfaceConfigService->m_pWANIPConnectionService)
        {
            hr = m_pWANCommonInterfaceConfigService->m_pWANIPConnectionService->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdispService));    
        }
    } 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cinternetgatewaydevice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"

#include "COSInfoService.h"
#include "CWANCommonInterfaceConfigService.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CInternetGatewayDevice : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IUPnPDeviceControl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CInternetGatewayDevice)
    COM_INTERFACE_ENTRY(IUPnPDeviceControl)
END_COM_MAP()

public:

    CInternetGatewayDevice();

    // IUPnPDeviceControl methods
    STDMETHOD(Initialize)(
       /*[in]*/ BSTR     bstrXMLDesc,
       /*[in]*/ BSTR     bstrDeviceIdentifier,
       /*[in]*/ BSTR     bstrInitString);
    STDMETHOD(GetServiceObject)(
       /*[in]*/          BSTR     bstrUDN,
       /*[in]*/          BSTR     bstrServiceId,
       /*[out, retval]*/ IDispatch ** ppdispService);

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

    CComObject<COSInfoService>* m_pOSInfoService;
    CComObject<CWANCommonInterfaceConfigService>* m_pWANCommonInterfaceConfigService;

private:


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cnatdynamicportmappingservice.cpp ===
#include "pch.h"
#pragma hdrstop

#include "CNATDynamicPortMappingService.h"


CNATDynamicPortMappingService::CNATDynamicPortMappingService()
{
    m_pEventSink = NULL;
    m_pHNetConnection = NULL;
}

HRESULT CNATDynamicPortMappingService::FinalConstruct()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATDynamicPortMappingService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pHNetConnection)
    {
        m_pHNetConnection->Release();
    }
    
    return hr;
}

HRESULT CNATDynamicPortMappingService::Initialize(IHNetConnection* pHNetConnection)
{
    HRESULT hr = S_OK;

    m_pHNetConnection = pHNetConnection;
    m_pHNetConnection->AddRef();
    
    return hr;
}


HRESULT CNATDynamicPortMappingService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    return hr;
}

HRESULT CNATDynamicPortMappingService::Unadvise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

HRESULT CNATDynamicPortMappingService::get_DynamicPublicIP(BSTR* pDynamicPublicIP)
{
    *pDynamicPublicIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicPort(ULONG* pulDynamicPort)
{
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicProtocol(BSTR* pDynamicProtocol)
{
    *pDynamicProtocol = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicPrivateIP(BSTR* pDynamicPrivateIP)
{
    *pDynamicPrivateIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::get_DynamicLeaseDuration(ULONG* pulDynamicLeaseDuration)
{
    return E_UNEXPECTED;
}

HRESULT CNATDynamicPortMappingService::CreateDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, BSTR DynamicPrivateIP, BSTR DynamicLeaseDuration)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATDynamicPortMappingService::DeleteDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATDynamicPortMappingService::ExtendDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, ULONG ulDynamicLeaseDuration)
{
    HRESULT hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cnatinfoservice.cpp ===
#include "pch.h"
#pragma hdrstop


#include "precomp.h"

#include "CNATInfoService.h"

#include "pastif.h"


CNATInfoService::CNATInfoService()
{
    m_pEventSink = NULL;
    m_pHNetConnection = NULL;
}

HRESULT CNATInfoService::FinalConstruct()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATInfoService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pHNetConnection)
    {
        m_pHNetConnection->Release();
    }
    
    return hr;
}

HRESULT CNATInfoService::Initialize(IHNetConnection* pHNetConnection)
{
    HRESULT hr = S_OK;

    m_pHNetConnection = pHNetConnection;
    m_pHNetConnection->AddRef();
    
    return hr;
}


HRESULT CNATInfoService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    return hr;
}

HRESULT CNATInfoService::Unadvise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

HRESULT CNATInfoService::get_IPList(BSTR *pIPList)
{
    HRESULT hr = S_OK;

    *pIPList = SysAllocString(L"");
    if(NULL == *pIPList)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CNATInfoService::get_PublicIP(BSTR *pPublicIP)
{
    *pPublicIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::get_Port(ULONG* pPort)
{
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::get_Protocol(BSTR* pProtocol)
{
    *pProtocol = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::get_PrivateIP(BSTR* pPrivateIP)
{
    *pPrivateIP = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATInfoService::GetPublicIPList(BSTR* IPListp)
{
    HRESULT             hr           = S_OK;

    PPAST_INTERFACE     Interfacep   = NULL;
    
    PLIST_ENTRY         Linkp        = NULL;

    ULONG               AddressCount = 0;

    LPOLESTR            AddressListp = NULL;



    _ASSERT(IPListp != NULL);

    SysFreeString(*IPListp);

    *IPListp = NULL;


    EnterCriticalSection(&PastInterfaceLock);

    for(Linkp = PastInterfaceList.Flink;
        Linkp != &PastInterfaceList;
        Linkp = Linkp->Flink)
    {
        Interfacep = CONTAINING_RECORD(Linkp, PAST_INTERFACE, Link);

        if( NAT_IFC_BOUNDARY(Interfacep->Characteristics) )
        {
            //
            // Check for all IPs on the Boundary Interface(s)
            //
            for(ULONG i = 0;
                (i < Interfacep->BindingCount) &&
                (Interfacep->BindingArray[i].Address != INADDR_NONE) ;
                i++)
            {
                if( AddressCount > 0 )
                {
                    AddressListp = AppendAndAllocateWString(AddressListp, L",");
                }

                AddressListp = AppendAndAllocateWString(AddressListp, 
                                  INET_NTOW(Interfacep->BindingArray[i].Address));
                
                AddressCount++;
            }
        }
    }

    LeaveCriticalSection(&PastInterfaceLock);

    //
    // Allocate and construct the BSTR reply
    //
    if( AddressListp != NULL)
    {
        *IPListp = SysAllocString( AddressListp );

        if( *IPListp != NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CNATInfoService::GetPortMappingPrivateIP(
                                                 BSTR PublicIP,
                                                 ULONG ulPort,
                                                 BSTR Protocol,
                                                 BSTR* pPrivateIP
                                                )
{
    HRESULT hr = E_NOTIMPL;

    SysFreeString(*pPrivateIP);

    *pPrivateIP = NULL;

    return hr;
}

HRESULT CNATInfoService::GetPortMappingPublicIP(BSTR PrivateIP, ULONG ulPort, BSTR Protocol, BSTR* pPublicIP)
{
    HRESULT hr = E_NOTIMPL;

    SysFreeString(*pPublicIP);
    *pPublicIP = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cnatdynamicportmappingservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"

class ATL_NO_VTABLE CNATDynamicPortMappingService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<INATDynamicPortMappingService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATDynamicPortMappingService)
    COM_INTERFACE_ENTRY(INATDynamicPortMappingService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CNATDynamicPortMappingService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink* pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink* pesSubscriber);

    // INATDynamicPortMappingService
    STDMETHODIMP get_DynamicPublicIP(BSTR* pDynamicPublicIP);
    STDMETHODIMP get_DynamicPort(ULONG* pulDynamicPort);
    STDMETHODIMP get_DynamicProtocol(BSTR* pDynamicProtocol);
    STDMETHODIMP get_DynamicPrivateIP(BSTR* pDynamicPrivateIP);
    STDMETHODIMP get_DynamicLeaseDuration(ULONG* pulDynamicLeaseDuration);
    STDMETHODIMP CreateDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, BSTR DynamicPrivateIP, BSTR DynamicLeaseDuration);
    STDMETHODIMP DeleteDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol);
    STDMETHODIMP ExtendDynamicPortMapping(BSTR DynamicPublicIP, ULONG ulDynamicPort, BSTR DynamicProtocol, ULONG ulDynamicLeaseDuration);


    
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT Initialize(IHNetConnection* pHNetConnection);

private:

    IUPnPEventSink* m_pEventSink;
    IHNetConnection* m_pHNetConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cnatinfoservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"

class ATL_NO_VTABLE CNATInfoService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<INATInfoService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATInfoService)
    COM_INTERFACE_ENTRY(INATInfoService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CNATInfoService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink* pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink* pesSubscriber);

    // INATInfoService
    STDMETHODIMP get_IPList(BSTR* pIPList);
    STDMETHODIMP get_PublicIP(BSTR* pPublicIP);
    STDMETHODIMP get_Port(ULONG* pulPort);
    STDMETHODIMP get_Protocol(BSTR* pProtocol);
    STDMETHODIMP get_PrivateIP(BSTR* pPrivateIP);
    STDMETHODIMP GetPublicIPList(BSTR* pIPList);
    STDMETHODIMP GetPortMappingPrivateIP(BSTR PublicIP, ULONG ulPort, BSTR Protocol, BSTR* pPrivateIP);
    STDMETHODIMP GetPortMappingPublicIP(BSTR PrivateIP, ULONG ulPort, BSTR Protocol, BSTR* pPublicIP);

    
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT Initialize(IHNetConnection* pHNetConnection);

private:

    IUPnPEventSink* m_pEventSink;
    IHNetConnection* m_pHNetConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cnatstaticportmappingservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File      : CNATStaticPortMappingService.cpp
//
//  Contents  : CNATStaticPortMappingService implementation
//
//  Notes     :
//
//  Author    : savasg  28 February 2001
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "CNATStaticPortMappingService.h"

#include "ipnat.h"
#include "winsock2.h"
#include "debug.h"




//
// GLOBALS
//
IHNetIcsSettings*               g_IcsSettingsp = NULL;



HRESULT
SeekPortMapping(
                IN OPTIONAL LPOLESTR                    searchNamep,
                IN OPTIONAL USHORT                      searchPort,
                OUT         IHNetPortMappingProtocol    **Protocolpp
               )
//
// Seeks and retrieves a MappingProtocol by Name or Port
//
{
    HRESULT                         hr                    = S_OK;

    IHNetProtocolSettings*          ProtocolSettingsp     = NULL;

    IEnumHNetPortMappingProtocols*  EnumProtocolsp        = NULL;

    IHNetPortMappingProtocol*       Protocolp             = NULL;

    LPOLESTR                        ProtocolNamep         = NULL;

    USHORT                          ProtocolPort          = 0;

    BOOLEAN                         bFound                = FALSE;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > SeekPortMapping \n");

    do
    {
        hr = g_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Query Interface failed for ProtocolSettingsp e:%X", hr);

            break;
        }

        hr = ProtocolSettingsp->EnumPortMappingProtocols(&EnumProtocolsp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Enum Interface can't be retrieved \n");

            break;
        }

        while(
              (FALSE == bFound) &&
              (S_OK == EnumProtocolsp->Next(1, &Protocolp, NULL))
             )
        {
            hr = Protocolp->GetName(&ProtocolNamep);

            if( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"problemo name\n");
            } 
  

            hr = Protocolp->GetPort(&ProtocolPort);

            if( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L" problemo ");

                break;
            }

            if(searchNamep && 
               !( wcscmp(ProtocolNamep, searchNamep) )
              )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"The Name is hit %S\n", searchNamep);

                bFound = TRUE;    
            }

            if(searchPort &&
               (searchPort == ProtocolPort))
            {       
                bFound = TRUE;
            }

            CoTaskMemFree(ProtocolNamep);

            ProtocolNamep = NULL;
            
            if (FALSE == bFound) Protocolp->Release();
        }

        EnumProtocolsp->Release();

    } while ( FALSE );

    if(ProtocolSettingsp != NULL)
    {
        ProtocolSettingsp->Release();
    }

    if(Protocolpp && (bFound == TRUE) )
    {
        *Protocolpp = Protocolp;
    }

    return hr;
}

HRESULT
DeleteMappingByName(LPOLESTR ProtocolNamep)
{
    HRESULT                  hr         = S_OK;

    IHNetPortMappingProtocol* Protocolp = NULL;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > DeleteMappingByName \n");

    do
    {
        if(ProtocolNamep == NULL)
        {
            break;
        }
        
        hr = SeekPortMapping(ProtocolNamep,
                             0,
                             &Protocolp);
        if( FAILED(hr) || 
            (Protocolp == NULL))
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"No Such Protocol %S: %X", ProtocolNamep, hr);

            break;
        }

        DBG_SPEW(TM_STATIC, TL_ERROR, L"DELETING\n");

        hr = Protocolp->Delete();

        Protocolp->Release();

    } while ( FALSE );

    return hr;
}





CNATStaticPortMappingService::CNATStaticPortMappingService()
{
    m_pEventSink = NULL;

    m_pHNetConnection = NULL;
}

HRESULT CNATStaticPortMappingService::FinalConstruct()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CNATStaticPortMappingService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pHNetConnection)
    {
        m_pHNetConnection->Release();
    }
    
    return hr;
}

HRESULT 
CNATStaticPortMappingService::Initialize(IHNetConnection* pHNetConnection)
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT                         hr                          = S_OK;

    IHNetConnection*                HomenetConnectionp          = NULL;

    IEnumHNetIcsPublicConnections*  EnumIcsPublicConnectionsp   = NULL;

    IHNetIcsPublicConnection*       PublicConnectionp           = NULL;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > Initialize \n");

    do 
    {
        hr = CoCreateInstance(CLSID_HNetCfgMgr,
                              NULL,
                              CLSCTX_SERVER,
                              IID_IHNetIcsSettings,
                              reinterpret_cast<void**>(&g_IcsSettingsp));

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L" CoCreateInstance for IID_IHNetIcsSettings failed \n");

            break; 
        }
    
        //
        // Get the Enumeration Interface
        //
        hr = g_IcsSettingsp->EnumIcsPublicConnections(&EnumIcsPublicConnectionsp);
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Getting Interface for Enumeration of Public Connections has failed \n");

            break;
        }
    
        //
        // Find the Interface .. for now there is only one Public Interface
        // This is not the RRAS case
        //
        hr = EnumIcsPublicConnectionsp->Next(1,
                                             &PublicConnectionp,
                                             NULL);
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"There is no Public Connection.. how come?\n");

            break;
        }


        hr = PublicConnectionp->QueryInterface(IID_IHNetConnection,
                                   reinterpret_cast<void**>(&HomenetConnectionp));

        _ASSERT( SUCCEEDED(hr) );

        if( FAILED(hr) )
        {
            EnumIcsPublicConnectionsp->Release();

            PublicConnectionp->Release();

            DBG_SPEW(TM_STATIC, TL_ERROR, L"Can't Get the IID_IHNetConnection Interface from the Public Connection\n");

            break;
        }
    
    } while( FALSE );
    
    //
    // Release the Ref counts
    //
    if(PublicConnectionp != NULL)
    {
        PublicConnectionp->Release();
    }

    if(EnumIcsPublicConnectionsp != NULL)
    {
        EnumIcsPublicConnectionsp->Release();
    }
    
    m_pHNetConnection = HomenetConnectionp;

/* Instead of Using the existing
    m_pHNetConnection = pHNetConnection;
    m_pHNetConnection->AddRef();
*/
    return hr;
}


HRESULT CNATStaticPortMappingService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;

    m_pEventSink->AddRef();

    return hr;
}

HRESULT CNATStaticPortMappingService::Unadvise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();

    m_pEventSink = NULL;

    return hr;
}

HRESULT CNATStaticPortMappingService::get_StaticPortDescriptionList(BSTR* pStaticPortDescriptionList)
{
    HRESULT hr = S_OK;
    
    *pStaticPortDescriptionList = NULL;
    
    typedef struct tagNameEnablePair
    {
        LIST_ENTRY LinkField;
        LPOLESTR pName;
        ULONG ulNameSize;
        BOOLEAN bEnabled;
    } NameEnablePair;
    
    LIST_ENTRY PairList;
    InitializeListHead(&PairList);
    
    // First construct a linklist of NameEnablePairs with the info needed
    
    IEnumHNetPortMappingBindings *pBindingEnum = NULL;
    hr = m_pHNetConnection->EnumPortMappings(FALSE, &pBindingEnum);
    if(SUCCEEDED(hr))
    {
        IHNetPortMappingBinding* pBinding;
        while(S_OK == pBindingEnum->Next(1, &pBinding, NULL))
        {
            BOOLEAN bEnabled;
            
            hr = pBinding->GetEnabled(&bEnabled);
            if(SUCCEEDED(hr))
            {
                IHNetPortMappingProtocol* pProtocol;
                hr = pBinding->GetProtocol(&pProtocol);
                if(SUCCEEDED(hr))
                {
                    LPOLESTR pName;
                    hr = pProtocol->GetName(&pName);
                    if(SUCCEEDED(hr))
                    {
                        NameEnablePair* pPair = new NameEnablePair;
                        if(NULL != pPair)
                        {
                            pPair->pName = pName;
                            pPair->bEnabled = bEnabled;
                            
                            InsertTailList(&PairList, &pPair->LinkField);
                        }
                        //CoTaskMemFree(pName);
                    }
                    pProtocol->Release();
                }
            }
            pBinding->Release();
        }
        pBindingEnum->Release();
    }
    

    LIST_ENTRY* pCount;
    NameEnablePair* pContainingPair;

    if(SUCCEEDED(hr))
    {
        // Count the space needed in the return string
    
        unsigned int uSizeNeeded = 0;
        pCount = PairList.Flink;
        while(&PairList != pCount)
        {
            pContainingPair = CONTAINING_RECORD(pCount, NameEnablePair, LinkField);
            pContainingPair->ulNameSize = lstrlen(pContainingPair->pName);
            uSizeNeeded += 3 + pContainingPair->ulNameSize;  //Name:1,
            pCount = pCount->Flink;
        }

        BSTR pReturnString;
        if(0 != uSizeNeeded)
        {
            pReturnString = SysAllocStringLen(NULL, uSizeNeeded);
        }
        else
        {
            pReturnString = SysAllocString(L"");
        }
        
        if(NULL != pReturnString)
        {
            *pStaticPortDescriptionList = pReturnString;
            
            // Fill in the string
            pCount = PairList.Flink;
            while(&PairList != pCount)
            {
                pContainingPair = CONTAINING_RECORD(pCount, NameEnablePair, LinkField);
                
                
                lstrcpy(pReturnString, pContainingPair->pName);
                pReturnString += pContainingPair->ulNameSize;
                
                *pReturnString = L':';
                pReturnString++;
                
                *pReturnString = pContainingPair->bEnabled ? L'1' : L'0';
                pReturnString++;
                
                *pReturnString = (&PairList == pCount->Flink) ? L'\0' : L',';
                pReturnString++;
                
                pCount = pCount->Flink;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
            
    }

    // Clean up the linked list
    pCount = PairList.Flink;
    while(&PairList != pCount)
    {
        NameEnablePair* pDelete = CONTAINING_RECORD(pCount, NameEnablePair, LinkField);
        pCount = pCount->Flink;
        CoTaskMemFree(pDelete->pName);
        delete pDelete;
    }

    return hr;
}

HRESULT CNATStaticPortMappingService::get_StaticPort(ULONG* pulStaticPort)
{
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortProtocol(BSTR* pStaticPortProtocol)
{
    *pStaticPortProtocol = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortClient(BSTR* pStaticPortClient)
{
    *pStaticPortClient = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortEnable(VARIANT_BOOL* pbStaticPortEnable)
{
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::get_StaticPortDescription(BSTR* pStaticPortDescription)
{
    *pStaticPortDescription = NULL;
    return E_UNEXPECTED;
}

HRESULT CNATStaticPortMappingService::GetStaticPortMappingList(BSTR* pStaticPortMappingList)
{
    HRESULT hr = S_OK;
    
    SysFreeString(*pStaticPortMappingList);

    *pStaticPortMappingList = NULL;

    hr = get_StaticPortDescriptionList(pStaticPortMappingList);
    
    return hr;
}

HRESULT 
CNATStaticPortMappingService::GetStaticPortMapping(
                                                   BSTR StaticPortMappingDescription,
                                                   ULONG* pulStaticPort,
                                                   BSTR* pStaticPortClient,
                                                   BSTR* pStaticPortProtocol
                                                  )
/*++

Routine Description:

     Retrieves the Port, Client Name/Address and the Protocol for a given 
     Mapping (redirect in NAT context)... Note that a Binding may not exist 
     for a Mapping.. Thus There might not be a Client Name/Address.

Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT                   hr            = S_OK;

    IHNetPortMappingProtocol* Protocolp     = NULL;

    IHNetPortMappingBinding*  Bindingp      = NULL;

    LPOLESTR                  ClientNamep   = NULL;

    ULONG                     ClientAddress = 0;

    USHORT                    ProtocolPort  = 0;

    UCHAR                     ProtocolType  = 0;


    
    DBG_SPEW(TM_STATIC, TL_ERROR, L" > GetStaticPortMapping");

    _ASSERT( StaticPortMappingDescription != NULL );
    _ASSERT( pulStaticPort                != NULL );
    _ASSERT( pStaticPortClient            != NULL );
    _ASSERT( pStaticPortProtocol          != NULL );
    
    SysFreeString(*pStaticPortClient);

    SysFreeString(*pStaticPortProtocol);

    *pStaticPortClient = NULL;

    *pStaticPortProtocol = NULL;

    do
    {
        hr = SeekPortMapping((LPOLESTR)StaticPortMappingDescription,
                             0,
                             &Protocolp);

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"There is no such Port Mapping");

            break;
        }

        hr = Protocolp->GetPort(&ProtocolPort); //USHORT

        _ASSERT( SUCCEEDED(hr) );

        *pulStaticPort = ProtocolPort;
        
        //
        // Get the Type of the Protocol Mapping and put the appropriate
        // String
        //
        hr = Protocolp->GetIPProtocol(&ProtocolType); //UCHAR

        _ASSERT( SUCCEEDED(hr) );

        if ( ProtocolType == NAT_PROTOCOL_TCP )
        {
            *pStaticPortProtocol = SysAllocString(L"TCP");
        }
        else if ( ProtocolType == NAT_PROTOCOL_UDP )
        {
            *pStaticPortProtocol = SysAllocString(L"UDP");
        } 
        else
        {
            _ASSERT( FALSE );
        }

        
        //
        // A Binding may not exist.. That's Ok..
        //
        hr = m_pHNetConnection->GetBindingForPortMappingProtocol(Protocolp, &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L" No Such Binding for that protocol.");

            hr = S_OK;

            break;
        }

        //
        // If the Address exist just process that.
        // Convert the Name to a OLESTR
        //
        hr = Bindingp->GetTargetComputerAddress(&ClientAddress);

        if ( SUCCEEDED(hr) )
        {
            ClientNamep = (LPOLESTR) CoTaskMemAlloc( (wcslen(INET_NTOW(ClientAddress)) + 1) * sizeof(WCHAR) );

            _ASSERT(ClientNamep != NULL);

            wcscpy( ClientNamep, INET_NTOW(ClientAddress) );
        }
        else
        {
            hr = Bindingp->GetTargetComputerName(&ClientNamep);
        }

        if( FAILED( hr ) || (ClientNamep == NULL))
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Can't Retrieve Name or Address of Client from Binding ");

            break;
        }

        *pStaticPortClient = SysAllocString( ClientNamep );  

        if (*pStaticPortClient == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

    } while ( FALSE );

    if ( ClientNamep != NULL)
    {
        CoTaskMemFree( ClientNamep );
    }

    if ( Bindingp != NULL)
    {
        Bindingp->Release();
    }

    if ( Protocolp != NULL )
    {
        Protocolp->Release();
    }

    //
    // If there was a failure then clear up the allocated Strings
    //
    if ( FAILED(hr) && ( *pStaticPortProtocol != NULL ) )
    {
         SysFreeString( *pStaticPortProtocol );

         *pStaticPortProtocol = NULL;
    }

    return hr;
}

HRESULT 
CNATStaticPortMappingService::SetStaticPortMappingEnabled(
                                                          BSTR StaticPortMappingDescription, 
                                                          VARIANT_BOOL bStaticPortEnable
                                                         )
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT hr = S_OK;

    IHNetPortMappingProtocol* Protocolp = NULL;

    IHNetPortMappingBinding*  Bindingp  = NULL;

    
    
    DBG_SPEW(TM_STATIC, TL_ERROR, L" > SetStaticPortMappingEnabled");

    do
    {
        hr = SeekPortMapping((LPOLESTR)StaticPortMappingDescription,
                             NULL,
                             &Protocolp);

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"There is no such Port Mapping");

            break;
        }
        
        hr = m_pHNetConnection->GetBindingForPortMappingProtocol(Protocolp, &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L" No Such Binding for that protocol.");

            break;
        }

        if ( VARIANT_TRUE == bStaticPortEnable )
        {
            hr = Bindingp->SetEnabled(TRUE);
        }
        else if ( VARIANT_FALSE == bStaticPortEnable )
        {
            hr = Bindingp->SetEnabled(FALSE);
        }

        _ASSERT( SUCCEEDED(hr) );

    } while ( FALSE );

    if (Protocolp != NULL)
    {
        Protocolp->Release();
    }
    
    if (Bindingp != NULL)
    {
        Bindingp->Release();
    }

    return hr;
}

HRESULT 
CNATStaticPortMappingService::CreateStaticPortMapping(
                                                      BSTR  StaticPortMappingDescription, 
                                                      ULONG ulStaticPort, 
                                                      BSTR  StaticPortClient, 
                                                      BSTR  StaticPortProtocol
                                                     )
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/

{
    HRESULT                      hr                    = S_OK;

    UCHAR                        ProtocolType          = 0;

    IHNetProtocolSettings*       ProtocolSettingsp     = NULL;

    IHNetPortMappingProtocol*    PortMappingProtocolp  = NULL;

    IHNetPortMappingBinding*     PortMappingBindingp   = NULL;

    ULONG                        ClientAddr            = 0;


    ASSERT( StaticPortMappingDescription != NULL );
    ASSERT( ulStaticPort == 0 );
    // ASSERT( StaticPortClient != NULL );
    ASSERT( StaticPortProtocol );

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > CreateStaticPortMapping");

    //
    // Check and transform the Protocol Value to its correct type.
    //
    if( wcscmp(StaticPortProtocol, L"TCP") == 0)
    {
        ProtocolType = NAT_PROTOCOL_TCP;
    } 
    else if ( wcscmp(StaticPortProtocol, L"UDP") == 0)
    {
        ProtocolType = NAT_PROTOCOL_UDP;
    }
    else
    {
        DBG_SPEW(TM_STATIC, TL_ERROR, L"Unknown Protocol Type\n");

        _ASSERT(FALSE);

        return E_INVALIDARG;
    }

    do
    {
        hr = g_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));

        _ASSERT( SUCCEEDED(hr) );
    
        if( FAILED(hr) )
        {
            break;
        }


        hr = ProtocolSettingsp->CreatePortMappingProtocol((LPOLESTR)StaticPortMappingDescription,
                                                          ProtocolType,
                                                          (USHORT)ulStaticPort,
                                                          &PortMappingProtocolp);

        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Creating the PortMapping has failed");

            break;
        }

        //
        // If there is no 
        //
        if ( StaticPortClient != NULL )
        {
            hr = m_pHNetConnection->GetBindingForPortMappingProtocol(PortMappingProtocolp,
                                                                     &PortMappingBindingp);

            if( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L" GetBinding  for PORT Mapping has failed ");

                break;
            }

            //
            // Decide wether the given address is a Name or an valid IP address
            // ient_addrw will return an INADDR_NONE if the address is not 
            // decimal doted IP address
            //
            ClientAddr = INET_ADDR((LPOLESTR)StaticPortClient);

            if( ClientAddr == INADDR_NONE)
            {
                hr = PortMappingBindingp->SetTargetComputerName(StaticPortClient);

                _ASSERT( SUCCEEDED(hr) );
            }
            else
            {
                hr = PortMappingBindingp->SetTargetComputerAddress(ClientAddr);

                _ASSERT( SUCCEEDED(hr) );
            }

            //
            // It creates it enabled
            //
            hr = PortMappingBindingp->SetEnabled(TRUE);
        }
    } while (FALSE);

    if( PortMappingProtocolp != NULL)
    {
        PortMappingProtocolp->Release();
    }

    if( ProtocolSettingsp != NULL)
    {
        ProtocolSettingsp->Release();
    }

    return hr;
}

HRESULT
CNATStaticPortMappingService::DeleteStaticPortMapping(BSTR StaticPortMappingDescription)
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT hr = S_OK;

    DBG_SPEW(TM_STATIC, TL_ERROR, L"> DeleteStaticPortMapping");    

    _ASSERT( StaticPortMappingDescription != NULL );

    hr = DeleteMappingByName( (LPOLESTR) StaticPortMappingDescription );

    return hr;
}

HRESULT 
CNATStaticPortMappingService::SetStaticPortMapping(
                                                   BSTR StaticPortMappingDescription,
                                                   ULONG ulStaticPort, 
                                                   BSTR StaticPortClient, 
                                                   BSTR StaticPortProtocol
                                                  )
/*++

Routine Description:


Arguments:

	none

Return Value:

	none

--*/
{
    HRESULT hr = S_OK;

    hr = DeleteMappingByName((LPOLESTR) StaticPortMappingDescription);

    if ( SUCCEEDED(hr) )
    {
        hr = this->CreateStaticPortMapping(StaticPortMappingDescription,
                                           ulStaticPort, 
                                           StaticPortClient, 
                                           StaticPortProtocol);

        _ASSERT( SUCCEEDED(hr) );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cosinfoservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"

/////////////////////////////////////////////////////////////////////////////
// COSInfoService
class ATL_NO_VTABLE COSInfoService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<IOSInfoService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COSInfoService)
    COM_INTERFACE_ENTRY(IOSInfoService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

public:

    COSInfoService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink *pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink *pesSubscriber);
        

    // IOSInfo methods
    STDMETHODIMP get_OSMajorVersion(LONG *pOSMajorVersion);
    STDMETHODIMP get_OSMinorVersion(LONG *pOSMinorVersion);
    STDMETHODIMP get_OSBuildNumber(LONG *pOSBuildNumber);
    STDMETHODIMP get_OSMachineName(BSTR* pOSMachineName);
    STDMETHODIMP MagicOn( void);

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

private:

    IUPnPEventSink* m_pEventSink;
    VARIANT_BOOL m_vbMagic;

    OSVERSIONINFOEX m_OSVersionInfo;
    BSTR m_MachineName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cosinfoservice.cpp ===
#include "pch.h"
#pragma hdrstop

#include "COSInfoService.h"

COSInfoService::COSInfoService()
{
    m_MachineName = NULL;
    m_pEventSink = NULL;
}

HRESULT COSInfoService::FinalConstruct()
{
    HRESULT hr = S_OK;
    m_OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (0 == GetVersionEx(reinterpret_cast<LPOSVERSIONINFO>(&m_OSVersionInfo)))
    {
        hr = E_FAIL;
    }
    
    if(SUCCEEDED(hr))
    {
        TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = sizeof(szMachineName) / sizeof(TCHAR); // REVIEW: extend for DNS names?
        if(0 != GetComputerName(szMachineName, &dwSize))
        {
            m_MachineName = SysAllocString(szMachineName);
            if(NULL == m_MachineName)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT COSInfoService::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_MachineName)
    {
        SysFreeString(m_MachineName);
    }

    return hr;
}

// IUPnPEventSource methods

STDMETHODIMP COSInfoService::Advise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    if(NULL == m_pEventSink)
    {
        m_pEventSink = pesSubscriber;
        m_pEventSink->AddRef();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP COSInfoService::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

// Functions for IOSInfoService 

STDMETHODIMP COSInfoService::get_OSMajorVersion(LONG* pOSMajorVersion)
{
    HRESULT hr = S_OK;

    *pOSMajorVersion = m_OSVersionInfo.dwMajorVersion;
    return hr;
}

STDMETHODIMP COSInfoService::get_OSMinorVersion(LONG* pOSMinorVersion)
{
    HRESULT hr = S_OK;

    *pOSMinorVersion = m_OSVersionInfo.dwMinorVersion;
    return hr;
}

STDMETHODIMP COSInfoService::get_OSBuildNumber(LONG* pOSBuildNumber)
{
    HRESULT hr = S_OK;

    *pOSBuildNumber = m_OSVersionInfo.dwBuildNumber;
    return hr;
}

STDMETHODIMP COSInfoService::get_OSMachineName(BSTR* pMachineName)
{
    HRESULT hr = S_OK;

    *pMachineName = SysAllocString(m_MachineName);
    if(NULL == *pMachineName)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP COSInfoService::MagicOn()
{
//    CHECK_POINTER(pbMagic);
//    TraceTag(ttidUPnPSampleDevice, "CInternetGatewayDevice::get_Magic");
    HRESULT hr = S_OK;

//    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CInternetGatewayDevice::get_Magic");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwancommoninterfaceconfigservice.cpp ===
#include "pch.h"
#pragma hdrstop 

#include "CWANCommonInterfaceConfigService.h"
#include "StatisticsProviders.h"

CWANCommonInterfaceConfigService::CWANCommonInterfaceConfigService()
{
    m_pEventSink = NULL;
    m_pWANIPConnectionService = NULL;
    m_pWANPPPConnectionService = NULL;
    m_pWANPOTSLinkConfigService = NULL;
    m_pICSSupport = NULL;
    m_bFirewalled = FALSE;
    m_pStatisticsProvider = NULL;
};

HRESULT CWANCommonInterfaceConfigService::FinalConstruct()
{
    HRESULT hr = S_OK;
    
    IHNetConnection* pPublicConnection;
    IHNetConnection* pPrivateConnection;

    hr = GetConnections(&pPublicConnection, &pPrivateConnection);
    if(SUCCEEDED(hr))
    {
        GUID* pGuid;
        hr = pPublicConnection->GetGuid(&pGuid);
        if(SUCCEEDED(hr))
        {
            INetConnection* pNetConnection;
            hr = pPublicConnection->GetINetConnection(&pNetConnection);
            if(SUCCEEDED(hr))
            {
                NETCON_PROPERTIES* pProperties;
                hr = pNetConnection->GetProperties(&pProperties);
                if(SUCCEEDED(hr))
                {

                    // cache the firewall state, the beacon will be signaled (torn down and rebuilt) when the firewall status changes
                    
                    m_bFirewalled = (NCCF_FIREWALLED & pProperties->dwCharacter) == NCCF_FIREWALLED;
                    
                    m_MediaType = pProperties->MediaType;

                    if(NCM_LAN == m_MediaType)
                    {
                        CComObject<CLANStatisticsProvider>* pLANStatisticsProvider;
                        hr = CComObject<CLANStatisticsProvider>::CreateInstance(&pLANStatisticsProvider);
                        if(SUCCEEDED(hr))
                        {
                            pLANStatisticsProvider->AddRef();                                                                                

                            hr = pLANStatisticsProvider->Initialize(pGuid);
                            
                            // pass the reference
                            m_pStatisticsProvider = static_cast<IStatisticsProvider*>(pLANStatisticsProvider);
                        }
                            
                    }
                    else
                    {
                        CComObject<CRASStatisticsProvider>* pRASStatisticsProvider;
                        hr = CComObject<CRASStatisticsProvider>::CreateInstance(&pRASStatisticsProvider);
                        if(SUCCEEDED(hr))
                        {
                            pRASStatisticsProvider->AddRef();

                            hr = pRASStatisticsProvider->Initialize(pNetConnection);
                            
                            // pass the reference
                            m_pStatisticsProvider = static_cast<IStatisticsProvider*>(pRASStatisticsProvider);
                        }
                    }
                    
                    if(SUCCEEDED(hr))
                    {
                        if(NCM_LAN == m_MediaType)
                        {
                            hr = CComObject<CWANIPConnectionService>::CreateInstance(&m_pWANIPConnectionService);
                            if(SUCCEEDED(hr))
                            {
                                m_pWANIPConnectionService->AddRef();
                                hr = m_pWANIPConnectionService->Initialize(pGuid, pPublicConnection, m_pStatisticsProvider);
                            }
                        }
                        else
                        {
                            hr = CComObject<CWANPPPConnectionService>::CreateInstance(&m_pWANPPPConnectionService);
                            if(SUCCEEDED(hr))
                            {
                                m_pWANPPPConnectionService->AddRef();
                                hr = m_pWANPPPConnectionService->Initialize(pGuid, pPublicConnection, m_pStatisticsProvider);
                            }
                            
                            if(SUCCEEDED(hr))
                            {
                                hr = CComObject<CWANPOTSLinkConfigService>::CreateInstance(&m_pWANPOTSLinkConfigService);
                                if(SUCCEEDED(hr))
                                {
                                    m_pWANPOTSLinkConfigService->AddRef();
                                    hr = m_pWANPOTSLinkConfigService->Initialize(pNetConnection);
                                }
                            }
                        }
                    }

                    NcFreeNetconProperties(pProperties);
                }
                pNetConnection->Release();
            }
            CoTaskMemFree(pGuid);
        }

        if(SUCCEEDED(hr))
        {
            hr = pPrivateConnection->GetGuid(&pGuid);
            if(SUCCEEDED(hr))
            {
                hr = CoCreateInstance(CLSID_UPnPDeviceHostICSSupport, NULL, CLSCTX_SERVER, IID_IUPnPDeviceHostICSSupport, reinterpret_cast<void**>(&m_pICSSupport));                 
                if(SUCCEEDED(hr))
                {
                    hr = m_pICSSupport->SetICSInterfaces(1, pGuid);
                }
                CoTaskMemFree(pGuid);
            }
        }

        pPublicConnection->Release();
        pPrivateConnection->Release();
    }
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::FinalRelease()
{
    HRESULT hr = S_OK;
    
    
    if(NULL != m_pWANIPConnectionService)
    {
        m_pWANIPConnectionService->StopListening();
        m_pWANIPConnectionService->Release();
    }
    if(NULL != m_pWANPPPConnectionService)
    {
        m_pWANPPPConnectionService->StopListening();
        m_pWANPPPConnectionService->Release();
    }
    if(NULL != m_pWANPOTSLinkConfigService)
    {
        m_pWANPOTSLinkConfigService->Release();
    }
    if(NULL != m_pICSSupport)
    {
        m_pICSSupport->SetICSOff();
        m_pICSSupport->Release();
    }
    if(NULL != m_pStatisticsProvider)
    {
        m_pStatisticsProvider->Release();
    }


    return hr;
}

HRESULT CWANCommonInterfaceConfigService::GetConnections(IHNetConnection** ppPublicConnection, IHNetConnection** ppPrivateConnection)
{
    HRESULT hr = S_OK;

    *ppPublicConnection = NULL;
    *ppPrivateConnection = NULL;


    IHNetIcsSettings* pIcsSettings;
    hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_SERVER, IID_IHNetIcsSettings, reinterpret_cast<void**>(&pIcsSettings));
    if(SUCCEEDED(hr))
    {
        IHNetConnection* pHomenetConnection;
        
        IEnumHNetIcsPublicConnections* pEnumIcsPublicConnections;
        hr = pIcsSettings->EnumIcsPublicConnections(&pEnumIcsPublicConnections);
        if(SUCCEEDED(hr))
        {
            IHNetIcsPublicConnection* pPublicConnection;
            hr = pEnumIcsPublicConnections->Next(1, &pPublicConnection, NULL);
            if(S_OK == hr)
            {
                hr = pPublicConnection->QueryInterface(IID_IHNetConnection, reinterpret_cast<void**>(&pHomenetConnection));
                if(SUCCEEDED(hr))
                {
                    *ppPublicConnection = pHomenetConnection;
                }

                pPublicConnection->Release();
            }
            else if(S_FALSE == hr)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            pEnumIcsPublicConnections->Release();
        }

        if(SUCCEEDED(hr))
        {
            IEnumHNetIcsPrivateConnections* pEnumIcsPrivateConnections;
            hr = pIcsSettings->EnumIcsPrivateConnections(&pEnumIcsPrivateConnections);
            if(SUCCEEDED(hr))
            {
                IHNetIcsPrivateConnection* pPrivateConnection;
                hr = pEnumIcsPrivateConnections->Next(1, &pPrivateConnection, NULL);
                if(S_OK == hr)
                {
                    hr = pPrivateConnection->QueryInterface(IID_IHNetConnection, reinterpret_cast<void**>(&pHomenetConnection));
                    if(SUCCEEDED(hr))
                    {
                        *ppPrivateConnection = pHomenetConnection;
                    }
                    pPrivateConnection->Release();
                }
                else if(S_FALSE == hr)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
                pEnumIcsPrivateConnections->Release();
            }
            
            if(FAILED(hr))
            {
                if(NULL != *ppPublicConnection)
                {
                    (*ppPublicConnection)->Release();
                    *ppPublicConnection = NULL;
                }
            }
        }
        pIcsSettings->Release();
    }

    return hr;
}

// IUPnPEventSource methods

HRESULT CWANCommonInterfaceConfigService::Advise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    if(NULL != m_pEventSink)
    {
        m_pEventSink->Release();
        m_pEventSink = NULL;
    }
    return hr;
}

// Functions for IWANCommonInterfaceConfig

HRESULT CWANCommonInterfaceConfigService::get_WANAccessType(BSTR *pWANAccessType)
{
    HRESULT hr = S_OK;
    
    *pWANAccessType = SysAllocString(NCM_LAN == m_MediaType ? L"Ethernet" : L"POTS");
    if(NULL == *pWANAccessType)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_Layer1UpstreamMaxBitRate(ULONG *pLayer1UpstreamMaxBitRate)
{
    HRESULT hr = S_OK;
    
    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pLayer1UpstreamMaxBitRate, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_Layer1DownstreamMaxBitRate(ULONG *pLayer1DownstreamMaxBitRate)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pLayer1DownstreamMaxBitRate, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_PhysicalLinkStatus(BSTR *pPhysicalLinkStatus)
{
    HRESULT hr = S_OK;
    *pPhysicalLinkStatus = SysAllocString(L"Up");

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalBytesSent(ULONG *pTotalBytesSent)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(pTotalBytesSent, NULL, NULL, NULL, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalBytesReceived(ULONG *pTotalBytesReceived)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, pTotalBytesReceived, NULL, NULL, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalPacketsSent(ULONG *pTotalPacketsSent)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, pTotalPacketsSent, NULL, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_TotalPacketsReceived(ULONG *pTotalPacketsReceived)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, pTotalPacketsReceived, NULL, NULL); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_WANAccessProvider(BSTR *pWANAccessProvider)
{
    HRESULT hr = S_OK;
    *pWANAccessProvider = SysAllocString(L"");
    if(NULL == *pWANAccessProvider)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_MaximumActiveConnections(USHORT *pMaximumActiveConnections)
{
    HRESULT hr = S_OK;
    *pMaximumActiveConnections = 0;
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_X_PersonalFirewallEnabled(VARIANT_BOOL *pPersonalFirewallEnabled)
{
    HRESULT hr = S_OK;

    *pPersonalFirewallEnabled = m_bFirewalled ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::get_X_Uptime(ULONG *pUptime)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, NULL, pUptime); 
    
    return hr;
}

HRESULT CWANCommonInterfaceConfigService::GetCommonLinkProperties(BSTR* pWANAccessType, ULONG* pLayer1UpstreamMaxBitRate, ULONG *pLayer1DownstreamMaxBitRate, BSTR *pPhysicalLinkStatus)
{
    HRESULT hr = S_OK;
    
    SysFreeString(*pWANAccessType);
    SysFreeString(*pPhysicalLinkStatus);
    *pWANAccessType = NULL;
    *pPhysicalLinkStatus = NULL;

    hr = get_WANAccessType(pWANAccessType);

    if(SUCCEEDED(hr))
    {
        hr = get_Layer1UpstreamMaxBitRate(pLayer1UpstreamMaxBitRate);
    }

    if(SUCCEEDED(hr))
    {
        hr = get_Layer1DownstreamMaxBitRate(pLayer1DownstreamMaxBitRate);
    }

    if(SUCCEEDED(hr))
    {
        hr = get_PhysicalLinkStatus(pPhysicalLinkStatus);
    }

    if(FAILED(hr))
    {
        SysFreeString(*pWANAccessType);
        SysFreeString(*pPhysicalLinkStatus);
        *pWANAccessType = NULL;
        *pPhysicalLinkStatus = NULL;
    }

    return hr;
}

HRESULT CWANCommonInterfaceConfigService::GetTotalBytesSent(ULONG *pTotalBytesSent)
{
    return get_TotalBytesSent(pTotalBytesSent);
}

HRESULT CWANCommonInterfaceConfigService::GetTotalBytesReceived(ULONG *pTotalBytesReceived)
{
    return get_TotalBytesReceived(pTotalBytesReceived);
}

HRESULT CWANCommonInterfaceConfigService::GetTotalPacketsSent(ULONG *pTotalPacketsSent)
{
    return get_TotalPacketsSent(pTotalPacketsSent);
}

HRESULT CWANCommonInterfaceConfigService::GetTotalPacketsReceived(ULONG *pTotalPacketsReceived)
{
    return get_TotalPacketsReceived(pTotalPacketsReceived);
}

HRESULT CWANCommonInterfaceConfigService::X_GetICSStatistics(ULONG *pTotalBytesSent, ULONG *pTotalBytesReceived, ULONG *pTotalPacketsSent, ULONG *pTotalPacketsReceived, ULONG *pSpeed, ULONG *pUptime)
{
    HRESULT hr = S_OK;
    
    hr = m_pStatisticsProvider->GetStatistics(pTotalBytesSent, pTotalBytesReceived, pTotalPacketsSent, pTotalPacketsReceived, pSpeed, pUptime); 
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwancommoninterfaceconfigservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"
#include "upnpp.h"

#include "CWANIPConnectionService.h"
#include "CWANPPPConnectionService.h"
#include "CWANPOTSLinkConfigService.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CWANCommonInterfaceConfigService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<ICommonInterfaceConfigService>,
    public IUPnPEventSource

{
public:
    CWANCommonInterfaceConfigService();

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWANCommonInterfaceConfigService)
    COM_INTERFACE_ENTRY(ICommonInterfaceConfigService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)

END_COM_MAP()

public:

    // IUPnPEventSource methods
    STDMETHOD(Advise)(
        /*[in]*/ IUPnPEventSink *pesSubscriber);
    STDMETHOD(Unadvise)(
        /*[in]*/ IUPnPEventSink *pesSubscriber);

    // ICommonInterfaceConfigService methods
    STDMETHODIMP get_WANAccessType(BSTR *pWANAccessType);
    STDMETHODIMP get_Layer1UpstreamMaxBitRate(ULONG *pLayer1UpstreamMaxBitRate);
    STDMETHODIMP get_Layer1DownstreamMaxBitRate(ULONG *pLayer1DownstreamMaxBitRate);
    STDMETHODIMP get_PhysicalLinkStatus(BSTR *pPhysicalLinkStatus);

    STDMETHODIMP get_TotalBytesSent(ULONG *pTotalBytesSent);
    STDMETHODIMP get_TotalBytesReceived(ULONG *pTotalBytesReceived);
    STDMETHODIMP get_TotalPacketsSent(ULONG *pTotalPacketsSent);
    STDMETHODIMP get_TotalPacketsReceived(ULONG *pTotalPacketsReceived);
    STDMETHODIMP get_WANAccessProvider(BSTR *pWANAccessProvider);
    STDMETHODIMP get_MaximumActiveConnections(USHORT *pMaximumActiveConnections);
    STDMETHODIMP get_X_PersonalFirewallEnabled(VARIANT_BOOL *pPersonalFirewallEnabled);
    STDMETHODIMP get_X_Uptime(ULONG* pUptime);
    STDMETHODIMP GetCommonLinkProperties(BSTR* pWANAccessType, ULONG* pLayer1UpstreamMaxBitRate, ULONG *pLayer1DownstreamMaxBitRate, BSTR *pPhysicalLinkStatus);
    STDMETHODIMP GetTotalBytesSent(ULONG *pTotalBytesSent);
    STDMETHODIMP GetTotalBytesReceived(ULONG *pTotalBytesReceived);
    STDMETHODIMP GetTotalPacketsSent(ULONG *pTotalPacketsSent);
    STDMETHODIMP GetTotalPacketsReceived(ULONG *pTotalPacketsReceived);
    STDMETHODIMP X_GetICSStatistics(ULONG *pTotalBytesSent, ULONG *pTotalBytesReceived, ULONG *pTotalPacketsSent, ULONG *pTotalPacketsReceived, ULONG *pSpeed, ULONG *pUptime);
    
    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

    CComObject<CWANIPConnectionService>* m_pWANIPConnectionService;
    CComObject<CWANPPPConnectionService>* m_pWANPPPConnectionService;
    CComObject<CWANPOTSLinkConfigService>* m_pWANPOTSLinkConfigService;

    NETCON_MEDIATYPE m_MediaType;

private:

    HRESULT GetConnections(IHNetConnection** ppPublicConnection, IHNetConnection** ppPrivateConnection);
    
    IUPnPEventSink* m_pEventSink;
    IUPnPDeviceHostICSSupport* m_pICSSupport;
    BOOL m_bFirewalled;
    IStatisticsProvider* m_pStatisticsProvider;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cnatstaticportmappingservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "hnetcfg.h"

class ATL_NO_VTABLE CNATStaticPortMappingService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<INATStaticPortMappingService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATStaticPortMappingService)
    COM_INTERFACE_ENTRY(INATStaticPortMappingService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CNATStaticPortMappingService();

    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink* pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink* pesSubscriber);

    // INATStaticPortMappingService
    STDMETHODIMP get_StaticPortDescriptionList(BSTR* pStaticPortDescriptionList);
    STDMETHODIMP get_StaticPort(ULONG* pulStaticPort);
    STDMETHODIMP get_StaticPortProtocol(BSTR* pStaticPortProtocol);
    STDMETHODIMP get_StaticPortClient(BSTR* pStaticPortClient);
    STDMETHODIMP get_StaticPortEnable(VARIANT_BOOL* pbStaticPortEnable);
    STDMETHODIMP get_StaticPortDescription(BSTR* pStaticPortDescription);
    STDMETHODIMP GetStaticPortMappingList(BSTR* pStaticPortMappingList);
    STDMETHODIMP GetStaticPortMapping(BSTR StaticPortMappingDescription, ULONG* pulStaticPort, BSTR* pStaticPortClient, BSTR* pStaticPortProtocol);
    STDMETHODIMP SetStaticPortMappingEnabled(BSTR StaticPortMappingDescription, VARIANT_BOOL bStaticPortEnable);
    STDMETHODIMP CreateStaticPortMapping(BSTR StaticPortMappingDescription, ULONG ulStaticPort, BSTR StaticPortClient, BSTR StaticPortProtocol);
    STDMETHODIMP DeleteStaticPortMapping(BSTR StaticPortMappingDescription);
    STDMETHODIMP SetStaticPortMapping(BSTR StaticPortMappingDescription, ULONG ulStaticPort, BSTR StaticPortClient, BSTR StaticPortProtocol);

    
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT Initialize(IHNetConnection* pHNetConnection);

private:

    IUPnPEventSink* m_pEventSink;
    IHNetConnection* m_pHNetConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanconnectionbase.cpp ===
#include "pch.h"
#pragma hdrstop


#include "CWANConnectionBase.h"
#include "beacon.h"

#include <ipnat.h>
#include <iphlpapi.h>
#include <ntddip.h>
#include <winsock.h>


#include "debug.h"
#include "util.h"



extern "C"
ULONG
NhpAllocateAndGetInterfaceInfoFromStack(
    IP_INTERFACE_NAME_INFO** Table,
    PULONG Count,
    BOOL SortOutput,
    HANDLE AllocationHeap,
    ULONG AllocationFlags
    );


CWANConnectionBase::CWANConnectionBase()
{
    m_pConnectionPoint = NULL;
    m_pHomenetConnection = NULL;
    m_pEventSink = NULL;

    m_pStatisticsProvider = NULL;

    m_IcsSettingsp          = NULL;
    m_hAdviseNATEventsResult = E_FAIL;
}

HRESULT CWANConnectionBase::FinalConstruct()
{
    HRESULT hr = S_OK;
    hr = StartNetmanEvents(this);
    if(SUCCEEDED(hr))
    {
        hr = AdviseNATEvents(this);
        m_hAdviseNATEventsResult = hr;
    }
    return hr;
}

HRESULT CWANConnectionBase::FinalRelease()
{

    if ( NULL != m_pHomenetConnection)
    {
        m_pHomenetConnection->Release();
    }

    if ( NULL != m_IcsSettingsp)
    {
        m_IcsSettingsp->Release();
    }

    if(NULL != m_pStatisticsProvider)
    {
        m_pStatisticsProvider->Release();
    }
    DestroyDebugger();

    return S_OK;    
}

HRESULT CWANConnectionBase::StopListening()

{
    HRESULT hr = S_OK;

    if(NULL != m_pConnectionPoint)
    {
        hr = m_pConnectionPoint->Unadvise(m_dwConnectionManagerConnectionPointCookie);

        m_pConnectionPoint->Release();
        m_pConnectionPoint = NULL;
    }

    if(SUCCEEDED(m_hAdviseNATEventsResult))
    {
        UnadviseNATEvents(this);  
    }
    return hr;
}

HRESULT CWANConnectionBase::StartNetmanEvents(INetConnectionNotifySink* pSink)
{
    HRESULT hr = S_OK;

    INetConnectionManager* pConnectionManager;    
    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, reinterpret_cast<void**>(&pConnectionManager));
    if SUCCEEDED(hr)
    {
        IConnectionPointContainer* pConnectionPointContainer;
        hr = pConnectionManager->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void**>(&pConnectionPointContainer));
        if(SUCCEEDED(hr))
        {
            hr = pConnectionPointContainer->FindConnectionPoint(IID_INetConnectionNotifySink, &m_pConnectionPoint);
            if(SUCCEEDED(hr))
            {
                hr = m_pConnectionPoint->Advise(pSink, &m_dwConnectionManagerConnectionPointCookie);
                if(FAILED(hr))
                {
                    m_pConnectionPoint->Release();
                    m_pConnectionPoint = NULL;
                }
                // release in stop listening on success
            }
            pConnectionPointContainer->Release();
        }
        pConnectionManager->Release();
    }                   


    return hr;
}



HRESULT
CWANConnectionBase::Initialize(
                               GUID*           pGuid, 
                               IHNetConnection* pHomenetConnection,
                               IStatisticsProvider* pStatisticsProvider
                              )
{
    HRESULT                         hr                          = S_OK;
    
    InitDebugger();

    DBG_SPEW(TM_STATIC, TL_INFO, L" > Initialize ");


    m_pStatisticsProvider = pStatisticsProvider;
    m_pStatisticsProvider->AddRef();
    
    m_pHomenetConnection = pHomenetConnection;
    m_pHomenetConnection->AddRef();

    CopyMemory(&m_SharedGuid, pGuid, sizeof(GUID));

    hr = CoCreateInstance(CLSID_HNetCfgMgr,
                          NULL,
                          CLSCTX_SERVER,
                          IID_IHNetIcsSettings,
                          reinterpret_cast<void**>(&m_IcsSettingsp));

    return hr;
}

HRESULT CWANConnectionBase::FireEvent(DISPID DispatchId)
{
    HRESULT hr = S_OK;

    IUPnPEventSink* pEventSink = NULL;

    Lock();

    if(NULL != m_pEventSink)
    {
        pEventSink = m_pEventSink;
        pEventSink->AddRef();
    }

    Unlock();

    if(NULL != pEventSink)
    {
        hr = pEventSink->OnStateChanged(1, &DispatchId);
        pEventSink->Release();            
    }

    return hr;
}

// IUPnPEventSource methods

HRESULT CWANConnectionBase::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    Lock();

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    Unlock();

    return hr;
}

HRESULT CWANConnectionBase::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    Lock();
    
    m_pEventSink->Release();
    m_pEventSink = NULL;

    Unlock();

    return hr;
}

// INATEventsNotifySink

HRESULT CWANConnectionBase::PublicIPAddressChanged(void)
{
    return FireEvent(IWANIPCONNECTION_DISPID_EXTERNALIPADDRESS);
}

HRESULT CWANConnectionBase::PortMappingsChanged(void)
{
    return FireEvent(IWANIPCONNECTION_DISPID_PORTMAPPINGNUMBEROFENTRIES);
}


// INetConnectionNotifySink methods

HRESULT CWANConnectionBase::ConnectionAdded(const NETCON_PROPERTIES_EX* pProps)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::ConnectionBandWidthChange(const GUID* pguidId)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::ConnectionDeleted(const GUID* pguidId)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::ConnectionModified(const NETCON_PROPERTIES_EX* pProps)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CWANConnectionBase::ConnectionRenamed(const GUID* pguidId, LPCWSTR pszwNewName)
{
    HRESULT hr = S_OK;
    if(IsEqualGUID(*pguidId, m_SharedGuid))
    {
        hr = FireEvent(IWANIPCONNECTION_DISPID_NAME);
    }

    return hr;
}

HRESULT CWANConnectionBase::ConnectionStatusChange(const GUID* pguidId, NETCON_STATUS Status)
{
    HRESULT hr = S_OK;
    if(IsEqualGUID(*pguidId, m_SharedGuid))
    {
        hr = FireEvent(IWANIPCONNECTION_DISPID_CONNECTIONSTATUS);
    }
    return hr;
}

HRESULT CWANConnectionBase::ConnectionAddressChange(const GUID* pguidId)
{
    HRESULT hr = S_OK;

    if ( IsEqualGUID(*pguidId, m_SharedGuid) )
    {
        hr = FireEvent( IWANIPCONNECTION_DISPID_EXTERNALIPADDRESS );
    }

    return hr;
}

HRESULT CWANConnectionBase::ShowBalloon(const GUID* pguidId, const BSTR szCookie, const BSTR szBalloonText)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT CWANConnectionBase::RefreshAll()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CWANConnectionBase::DisableEvents(const BOOL fDisable, const ULONG ulDisableTimeout)
{
    HRESULT hr = S_OK;

    return hr;
}

// IWANIPConnection and IWANPPPConnection methods

HRESULT CWANConnectionBase::get_ConnectionType(BSTR *pConnectionType)
{
    HRESULT hr = S_OK;
    *pConnectionType = SysAllocString(L"IP_Routed");
    if(NULL == *pConnectionType)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANConnectionBase::get_PossibleConnectionTypes(BSTR *pPossibleConnectionTypes)
{
    HRESULT hr = S_OK;
    *pPossibleConnectionTypes = SysAllocString(L"IP_Routed");
    if(NULL == *pPossibleConnectionTypes)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANConnectionBase::get_ConnectionStatus(BSTR *pConnectionStatus)
{
    HRESULT hr = S_OK;

    *pConnectionStatus = NULL;

    INetConnection* pNetConnection;
    hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
    if(SUCCEEDED(hr))
    {
        NETCON_PROPERTIES* pProperties;
        hr = pNetConnection->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            LPWSTR pszStatus;
            switch(pProperties->Status)
            {
            case NCS_AUTHENTICATION_SUCCEEDED:
            case NCS_CONNECTED:
                pszStatus = L"Connected";
                break;
            case NCS_DISCONNECTED:
                pszStatus = L"Disconnected";
                break;
            case NCS_AUTHENTICATING:
            case NCS_CONNECTING:
                pszStatus = L"Connecting";
                break;
            case NCS_DISCONNECTING:
                pszStatus = L"Disconnecting";
                break;
            case NCS_INVALID_ADDRESS:
            case NCS_CREDENTIALS_REQUIRED:
            case NCS_AUTHENTICATION_FAILED:
            case NCS_HARDWARE_DISABLED:
            case NCS_HARDWARE_MALFUNCTION:
            case NCS_HARDWARE_NOT_PRESENT:
            default:
                pszStatus = L"Unconfigured";
                break;
                
            }
            
            *pConnectionStatus = SysAllocString(pszStatus);
            if(NULL == *pConnectionStatus)
            {
                hr = E_OUTOFMEMORY;
            }
            
            NcFreeNetconProperties(pProperties);
        }
        pNetConnection->Release();
    }
    return hr;


}

HRESULT CWANConnectionBase::get_Uptime(ULONG *pUptime)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, NULL, pUptime); 
    
    return hr;
}

HRESULT CWANConnectionBase::get_UpstreamMaxBitRate(ULONG *pUpstreamMaxBitRate)
{
    HRESULT hr = S_OK;

    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pUpstreamMaxBitRate, NULL); 
    
    return hr;
}

HRESULT CWANConnectionBase::get_DownstreamMaxBitRate(ULONG *pDownstreamMaxBitRate)
{
    HRESULT hr = S_OK;
    
    hr = m_pStatisticsProvider->GetStatistics(NULL, NULL, NULL, NULL, pDownstreamMaxBitRate, NULL); 

    return hr;
}

HRESULT CWANConnectionBase::get_RSIPAvailable(VARIANT_BOOL *pRSIPAvailable)
{
    HRESULT hr = S_OK;
    *pRSIPAvailable = VARIANT_FALSE;
    return hr;
}

HRESULT CWANConnectionBase::get_NATEnabled(VARIANT_BOOL *pNATEnabled)
{
    HRESULT hr = S_OK;
    *pNATEnabled = VARIANT_TRUE;
    return hr;
}

HRESULT CWANConnectionBase::get_X_Name(BSTR* pName)
{

    HRESULT hr = S_OK;

    *pName = NULL;
    
    INetConnection* pNetConnection;
    hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
    if(SUCCEEDED(hr))
    {
        NETCON_PROPERTIES* pProperties;
        hr = pNetConnection->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            *pName = SysAllocString(pProperties->pszwName);
            if(NULL == *pName)
            {
                hr = E_OUTOFMEMORY;
            }
            NcFreeNetconProperties(pProperties);
        }
        pNetConnection->Release();
    }
    return hr;
}


HRESULT
get_HrLocalAdaptersInfo(PIP_ADAPTER_INFO* ppAdapter)
{
    HRESULT          hr = S_OK, dwErr = NO_ERROR;
    PIP_ADAPTER_INFO paAdapterInfo = NULL;
    ULONG            uBufLen = (2 * BUF_SIZE); 

    _ASSERT( ppAdapter != NULL );

    *ppAdapter = NULL;

    
    paAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc( uBufLen );

    if ( NULL == paAdapterInfo ) { return E_OUTOFMEMORY; }

    //
    // Discover How much Memory we need. If we need at all.

    // Note that paAdapterInfo may be non-NULL and that is desired.
    dwErr = GetAdaptersInfo( paAdapterInfo, &uBufLen );

    if ( ERROR_BUFFER_OVERFLOW == dwErr )
    {
        CoTaskMemFree( paAdapterInfo );

        paAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc( uBufLen );

        if ( paAdapterInfo != NULL)
        {
            dwErr = GetAdaptersInfo ( paAdapterInfo, &uBufLen );
        }
    }

    if ( paAdapterInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if ( ERROR_SUCCESS != dwErr )
    {
        DBG_SPEW( TM_INFO, TL_ERROR, 
                  L" GetAdapterInfo has failed with E(%u) BufSize(%u) ", 
                  dwErr, uBufLen );

        CoTaskMemFree(paAdapterInfo);

        return HRESULT_FROM_WIN32( dwErr );
    }

    if ( ppAdapter && paAdapterInfo ) { *ppAdapter = paAdapterInfo; }

    return hr;
}

// {c200e360-38c5-11ce-ae62-08002b2b79ef} - 38 chars 
#define GUID_STRING_LENGTH 38

PIP_ADAPTER_INFO
GetExternalAdapterInfo( GUID* pGUID )
{
    HRESULT hr = S_OK;
    WCHAR   szwGUID[ GUID_STRING_LENGTH + 1 ] = { 0 };
    char    ascGUID[ GUID_STRING_LENGTH + 1 ] = { 0 }; 
    PIP_ADAPTER_INFO pRetAdapter = NULL;
    PIP_ADAPTER_INFO pAdapterList = NULL, pTempAdapter = NULL;


    _ASSERT( pGUID != NULL );

    //
    // Change the given GUID to a String
    if ( StringFromGUID2( *pGUID, szwGUID, GUID_STRING_LENGTH + 1 ) == 0 )
    { return NULL; }

    if ( WideCharToMultiByte( CP_ACP, 0, szwGUID, -1, ascGUID, sizeof(ascGUID), NULL, NULL) == 0 )
    { return NULL; }

    hr = get_HrLocalAdaptersInfo( &pAdapterList );

    if ( FAILED(hr) || (pAdapterList == NULL) ) { return NULL; }

    pTempAdapter = pAdapterList;

    while ( pAdapterList != NULL )
    {
        if ( 0 == strcmp(ascGUID, pAdapterList->AdapterName) )
        {
            pRetAdapter = (PIP_ADAPTER_INFO) CoTaskMemAlloc( sizeof(IP_ADAPTER_INFO) );

            if ( NULL != pRetAdapter )
            {
                memcpy( pRetAdapter, pAdapterList, sizeof(IP_ADAPTER_INFO) );
                
                pRetAdapter->Next = NULL;
                
                break;
            }
        }

        pAdapterList = pAdapterList->Next;
    }
    
    CoTaskMemFree( pTempAdapter );
    
    return pRetAdapter;
}

                                                 




HRESULT CWANConnectionBase::get_ExternalIPAddress(BSTR *pExternalIPAddress)
{
    HRESULT         hr           = S_OK;
    ULONG           AddressCount = 0;
    LPOLESTR        swAddr       = NULL;
    PIP_ADAPTER_INFO pExternalAdapterInfo = NULL;
    ULONG numOfChar = 0, uTemp = 0, Error = NO_ERROR;

    WCHAR   szwGUID[ GUID_STRING_LENGTH + 1 ] = { 0 };
    IP_INTERFACE_NAME_INFO*  Table = NULL;
    ULONG  Count = 0;

    _ASSERT( pExternalIPAddress != NULL );
    
    if ( pExternalIPAddress != NULL )
    {
        *pExternalIPAddress = NULL;
    }
    else
    {
        return E_POINTER;
    }

    
    _ASSERT( pExternalIPAddress != NULL );

    StringFromGUID2( m_SharedGuid, szwGUID, GUID_STRING_LENGTH + 1 );

    DBG_SPEW(TM_INFO, TL_TRACE, L"> get_ExternalIpAddress Looking for GUID %s", szwGUID);

    Error = NhpAllocateAndGetInterfaceInfoFromStack(&Table, 
                                                    &Count, 
                                                    FALSE, 
                                                    GetProcessHeap(), 
                                                    0);
    
    if ( (NO_ERROR == Error) && (Table != NULL) )
    {
        for (ULONG i = 0; i < Count ; i++) 
        {
#if DBG
            StringFromGUID2( Table[i].DeviceGuid, szwGUID, GUID_STRING_LENGTH + 1 );
            DBG_SPEW(TM_INFO, TL_DUMP, L" DeviceGUID[%u] = %s", i, szwGUID);
            
            StringFromGUID2( Table[i].InterfaceGuid, szwGUID, GUID_STRING_LENGTH + 1 );
            DBG_SPEW(TM_INFO, TL_DUMP, L" DeviceGUID[%u] = %s", i, szwGUID);
#endif
            if ( IsEqualGUID((Table[i].InterfaceGuid), m_SharedGuid) )
            {
                pExternalAdapterInfo = GetExternalAdapterInfo( &Table[i].DeviceGuid );

                break;
            }
        }

        HeapFree(GetProcessHeap(), 0, Table);
    }

    if ( pExternalAdapterInfo == NULL )
    {
        pExternalAdapterInfo = GetExternalAdapterInfo( &m_SharedGuid );
    }
    

    if ( pExternalAdapterInfo != NULL )
    {
        if ( strcmp("0.0.0.0", pExternalAdapterInfo->IpAddressList.IpAddress.String) )
        {
            numOfChar = strlen( pExternalAdapterInfo->IpAddressList.IpAddress.String );
            
            swAddr = (LPOLESTR) CoTaskMemAlloc( (numOfChar + 1) * sizeof(WCHAR) );
    
            if ( swAddr != NULL )
            {
                memset( swAddr, 0, (numOfChar + 1) * sizeof(WCHAR));
    
                uTemp = _snwprintf( swAddr, numOfChar, L"%S",  
                                    pExternalAdapterInfo->IpAddressList.IpAddress.String );
    
                _ASSERT( numOfChar == uTemp );

                swAddr[ numOfChar] = L'\0';
    
                *pExternalIPAddress = SysAllocString( swAddr );
                
                CoTaskMemFree( swAddr );
            }
        }
        else
        {
            *pExternalIPAddress = SysAllocString( L"" );
        }

        CoTaskMemFree( pExternalAdapterInfo );
    }
    else
    {
        *pExternalIPAddress = SysAllocString( L"" );
    }


    if ( *pExternalIPAddress == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        DBG_SPEW(TM_INFO, TL_INFO, L"Returning IP String (%s)", *pExternalIPAddress);
    }

    return hr;
}

HRESULT CWANConnectionBase::get_RemoteHost(BSTR *pRemoteHost)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_ExternalPort(USHORT *pExternalPort)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_InternalPort(USHORT *pInternalPort)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingProtocol(BSTR *pProtocol)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_InternalClient(BSTR *pInternalClient)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingDescription(BSTR *pDescription)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingEnabled(VARIANT_BOOL *pEnabled)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingLeaseDuration(ULONG *LeaseDuration)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}

HRESULT CWANConnectionBase::get_PortMappingNumberOfEntries(USHORT *pNumberOfEntries)
{
    HRESULT                         hr                 = S_OK;
    
    IHNetPortMappingProtocol*       MappingProtocolp   = NULL;

    IHNetProtocolSettings*          ProtocolSettingsp  = NULL;

    IEnumHNetPortMappingProtocols*  EnumProtocolsp     = NULL;


    _ASSERT( pNumberOfEntries != NULL );

    *pNumberOfEntries = 0;

    do
    {
        
        hr = m_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Query Interface failed for ProtocolSettingsp E:(%X)", hr);

            break;
        }

        hr = ProtocolSettingsp->EnumPortMappingProtocols(&EnumProtocolsp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Enum Interface can't be retrieved E(%X)", hr);

            break;
        }

        while( S_OK == EnumProtocolsp->Next(1, &MappingProtocolp, NULL) )
        {
            (*pNumberOfEntries)++;

            _ASSERT( MappingProtocolp != NULL );

            MappingProtocolp->Release();
        }
    
    } while ( FALSE );

    


    if ( ProtocolSettingsp != NULL ) { ProtocolSettingsp->Release(); }

    if ( EnumProtocolsp != NULL) { EnumProtocolsp->Release(); }

    return hr;
}

HRESULT CWANConnectionBase::SetConnectionType(BSTR NewConnectionType)
{
    HRESULT hr = S_OK;
    
    if(0 != lstrcmp(NewConnectionType, L"IP_Routed"))
    {
        hr = E_FAIL; // we only support IP_Routed
    }

    return hr;
}


HRESULT CWANConnectionBase::GetConnectionTypeInfo(BSTR* pNewConnectionType, BSTR* pNewPossibleConnectionTypes)
{
    HRESULT hr = S_OK;

    SysFreeString(*pNewConnectionType);
    SysFreeString(*pNewPossibleConnectionTypes);
    *pNewConnectionType = NULL;
    *pNewPossibleConnectionTypes = NULL;

    hr = get_ConnectionType(pNewConnectionType);
    if(SUCCEEDED(hr))
    {
        hr = get_PossibleConnectionTypes(pNewPossibleConnectionTypes);
    }

    if(FAILED(hr))
    {
        if(NULL != *pNewConnectionType)
        {
            SysFreeString(*pNewConnectionType);
            *pNewConnectionType = NULL;
        }
    }
    return hr;
}

HRESULT CWANConnectionBase::GetStatusInfo(BSTR* pNewConnectionStatus, BSTR* pNewLastConnectionError, ULONG* pNewUptime)
{
    HRESULT hr = S_OK;

    SysFreeString(*pNewConnectionStatus);
    SysFreeString(*pNewLastConnectionError);
    *pNewConnectionStatus = NULL;
    *pNewLastConnectionError = NULL;
    
    hr = get_ConnectionStatus(pNewConnectionStatus);
    if(SUCCEEDED(hr))
    {
        hr = get_LastConnectionError(pNewLastConnectionError);
    }

    if(SUCCEEDED(hr) && 0 == lstrcmp(L"Connected", *pNewConnectionStatus))
    {
        hr = get_Uptime(pNewUptime);
    }
    else
    {
        *pNewUptime = 0;
    }

    if(FAILED(hr))
    {
        if(NULL != *pNewConnectionStatus)
        {
            SysFreeString(*pNewConnectionStatus);
            *pNewConnectionStatus = NULL;
        }
        
        if(NULL != *pNewLastConnectionError)
        {
            SysFreeString(*pNewLastConnectionError);
            *pNewLastConnectionError = NULL;
        }

    } 

    return hr;
}

HRESULT CWANConnectionBase::GetNATRSIPStatus(VARIANT_BOOL* pNewRSIPAvailable, VARIANT_BOOL* pNewNATEnabled)
{
    HRESULT hr = S_OK;

    hr = get_RSIPAvailable(pNewRSIPAvailable);
    if(SUCCEEDED(hr))
    {
        hr = get_NATEnabled(pNewNATEnabled);
    }

    return hr;
}

HRESULT CWANConnectionBase::GetLinkLayerMaxBitRates(ULONG* pNewUpstreamMaxBitRate, ULONG* pNewDownstreamMaxBitRate)
{
    HRESULT hr = S_OK;

    hr = get_UpstreamMaxBitRate(pNewUpstreamMaxBitRate);
    if(SUCCEEDED(hr))
    {
        hr = get_DownstreamMaxBitRate(pNewDownstreamMaxBitRate);
    }

    return hr;
}

HRESULT 
CWANConnectionBase::GetGenericPortMappingEntry(
                                  USHORT        ulIndex,
                                  BSTR*         RemoteHostp,
                                  USHORT*       uExternalPortp,
                                  BSTR*         Protocolp,
                                  USHORT*       uInternalPortp,
                                  BSTR*         InternalClientp,
                                  VARIANT_BOOL* bEnabledp,
                                  BSTR*         Descriptionp,
                                  ULONG*        ulLeaseDurationp
                                 )       
{
    HRESULT                     hr                 = S_OK;
    IHNetPortMappingProtocol*   MappingProtocolp   = NULL;
    IHNetPortMappingBinding*    Bindingp           = NULL;
    USHORT BoundaryPort = 0, InternalPort = 0;

    _ASSERT ( RemoteHostp      != NULL );
    _ASSERT ( uExternalPortp   != NULL );
    _ASSERT ( Protocolp        != NULL );
    _ASSERT ( uInternalPortp   != NULL );
    _ASSERT ( InternalClientp  != NULL );
    _ASSERT ( bEnabledp        != NULL );
    _ASSERT ( Descriptionp     != NULL );
    _ASSERT ( ulLeaseDurationp != NULL );

    //
    // In/Out Parameters to COM Interfaces needs cleanup
    //
    SysFreeString(*RemoteHostp);
    SysFreeString(*Protocolp);
    SysFreeString(*InternalClientp);
    SysFreeString(*Descriptionp);

    *RemoteHostp         = NULL;
    *Protocolp           = NULL;
    *InternalClientp     = NULL;
    *Descriptionp        = NULL;
    
    *ulLeaseDurationp    = 0;

    DBG_SPEW(TM_INFO, TL_TRACE, L"> GetGenericPortMapping");

    //
    // check for access
    hr = this->ControlEnabled();

    if ( FAILED(hr) ) 
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Control Disabled returning E(%X)", hr);
        return hr; 
    }
    
    do
    {
        hr = SearchPortMapping(m_IcsSettingsp,
                               ulIndex,
                               0,
                               0,
                               &MappingProtocolp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Enum - Seeking the port has failed E(%X)", hr);
            SetUPnPError(L"713"); 
            break;
        }

        //
        // Getting the binding - is this how it should be?
        //
        hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(MappingProtocolp,
                                                                    &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Enum - Error In Getting Binding for Protocol E(%X)", hr);

            break;
        }


        hr = FillStaticMappingInformation(MappingProtocolp,
                                          Bindingp,
                                          &BoundaryPort,
                                          Protocolp,
                                          &InternalPort,
                                          InternalClientp,
                                          bEnabledp,
                                          Descriptionp);

        _ASSERT( SUCCEEDED(hr) );

        if ( SUCCEEDED(hr) ) // correct the port Byte Ordering
        {
            *uExternalPortp = ntohs( BoundaryPort );
            *uInternalPortp = ntohs( InternalPort );
        }
        else
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Enum - Error In Getting Binding for Protocol E(%X)" , hr);
        }
    
    } while ( FALSE );

    if ( MappingProtocolp != NULL) MappingProtocolp->Release();

    if ( Bindingp != NULL ) Bindingp->Release();

    if ( FAILED(hr) )
    {
        DBG_SPEW(TM_INFO, TL_ERROR, 
                 L"Enum - GetGenericEntry has failed with E(%X)", hr);    
    }
    
    return hr;
} // GetArrayEntry

HRESULT 
CWANConnectionBase::GetSpecificPortMappingEntry(
                                   IN  BSTR          RemoteHost,
                                   IN  USHORT        uwExternalPort,
                                   IN  BSTR          Protocol,
                                   OUT USHORT*       puwInternalPort,
                                   OUT BSTR*         InternalClientp,
                                   OUT VARIANT_BOOL* pbEnabled,
                                   OUT BSTR*         Descriptionp,
                                   OUT ULONG*        pulLeaseDuration
                                  )
//
// Note that every port is expected to arrive in HOST order 
// and will be returned in HOST order
//
{
    HRESULT                     hr                  = S_OK;
    IHNetPortMappingProtocol*   MappingProtocolp    = NULL;
    IHNetPortMappingBinding*    Bindingp            = NULL;
    USHORT tempExtPort = 0, tempIntPort = 0;
    UCHAR                       searchProtocol      = NULL;

    _ASSERT( RemoteHost     != NULL );
    _ASSERT( uwExternalPort != 0    );
    _ASSERT( Protocol       != NULL );

    SysFreeString( *InternalClientp );
    SysFreeString( *Descriptionp );

    *InternalClientp = NULL;
    *Descriptionp    = NULL;

    tempExtPort = htons( uwExternalPort ); // flip to Network order

    DBG_SPEW(TM_INFO, TL_TRACE, L"> GetSpecificPortMapping");

    //
    // check for access
    hr = this->ControlEnabled();

    if ( FAILED(hr) ) 
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Control is Disabled E(%X)", hr);
        return hr; 
    }
    
    if ( 0 == uwExternalPort)
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Parameters Incorrect Port(%hu)", uwExternalPort );
        SetUPnPError(L"402");
        return E_INVALIDARG;
    }


    do
    {
    //
    // Resolve the Protocol to the appropriate enum.
    //
        RESOLVE_PROTOCOL_TYPE(searchProtocol, Protocol);

        DBG_SPEW(TM_INFO, TL_INFO, 
                 L"Search Specific - ExtPort (%hu) Protocol (%s)",
                 htons( tempExtPort ), 
                 (NAT_PROTOCOL_TCP == searchProtocol)?L"TCP":L"UDP");

        hr = SearchPortMapping(m_IcsSettingsp,
                               0,
                               tempExtPort,
                               searchProtocol,
                               &MappingProtocolp);

        if ( FAILED(hr))
        {
            DBG_SPEW(TM_INFO, TL_ERROR, L"Error or can't get Search E(%X)", hr);
            SetUPnPError(L"714");
            break;
        }
        
        //
        // Getting the binding 
        //
        hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(MappingProtocolp,
                                                                    &Bindingp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_INFO, TL_ERROR, 
                     L"Error In Getting Binding for Protocol E(%X)", hr);

            break;
        }


        hr = FillStaticMappingInformation(MappingProtocolp,
                                          Bindingp,
                                          &tempExtPort,
                                          &Protocol,
                                          &tempIntPort,
                                          InternalClientp,
                                          pbEnabled,
                                          Descriptionp);
        _ASSERT( SUCCEEDED(hr) );

        *puwInternalPort = ntohs( tempIntPort );
        
        DBG_SPEW(TM_INFO, TL_TRACE,
                 L"Returning IntClient (%s) IntPort (%hu) IntProtocol (%s), Enabled (%s), Desc (%s)",
                 *InternalClientp,
                 *puwInternalPort,
                 Protocol,
                 (*pbEnabled == VARIANT_TRUE)?L"TRUE":L"FALSE",
                 *Descriptionp);

    
    } while ( FALSE );

    if ( MappingProtocolp != NULL)  MappingProtocolp->Release();

    if ( Bindingp != NULL ) Bindingp->Release();

    if ( FAILED(hr) )
    {
        DBG_SPEW(TM_INFO, TL_ERROR, L"Error or can't get Search Done E(%X)", hr);
    }

    return hr;
}


HRESULT
CWANConnectionBase::AddPortMapping(
                                   BSTR         RemoteHost,
                                   USHORT       uwExternalPort,  
                                   BSTR         Protocol,
                                   USHORT       uwInternalPort,  
                                   BSTR         InternalClient,  
                                   VARIANT_BOOL bEnabled,        
                                   BSTR         Description,     
                                   ULONG        ulLeaseDuration
                                  )
{
    HRESULT       hr           = S_OK;
    MAPPING_TYPE  MappingType  = ePortMappingInvalid;

    DBG_SPEW(TM_STATIC, TL_TRACE, L"> AddPortMapping");

    //
    // Check for Access status
    hr = this->ControlEnabled();

    if ( SUCCEEDED(hr) )
    {
        hr = ValidatePortMappingParameters(RemoteHost,
                                           uwExternalPort,
                                           Protocol,
                                           uwInternalPort,
                                           InternalClient,
                                           bEnabled,
                                           Description,
                                           ulLeaseDuration,
                                           &MappingType);

        if ( SUCCEEDED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_TRACE, 
                     L"Add PortMapping - ExtPort (%hu) Protocol (%s)",
                     uwExternalPort, Protocol);

            DBG_SPEW(TM_STATIC, TL_TRACE,
                     L"IntClient (%s) IntPort (%hu)  Enabled (%s), Desc (%s)",
                     InternalClient,
                     uwInternalPort,
                     (bEnabled == VARIANT_TRUE)?L"TRUE":L"FALSE",
                     Description);

            if ( ePortMappingStatic == MappingType )
            {
                //
                // SECURITY - SECURITY - SECURITY
                // Here we're allowing the out-of-proc COM call
                // into our service to have SYSTEM access rights.
                //
                // REASON: UPnP works in LOCAL_SERVICE and COM
                //         Calls into our service which modify
                //         the WMI repository will FAIL. This
                //         Call alleviates that problem by changing
                //         The Security to that of the SYSTEM
                //         and is reverted back when the class
                //         is out of scope by the destructor of.
                //         CSwitchSecurityContext 
                //
                CSwitchSecurityContext SwSecCxt;

                hr = AddStaticPortMapping(RemoteHost,
                                          uwExternalPort,
                                          Protocol,
                                          uwInternalPort,
                                          InternalClient,
                                          bEnabled,
                                          Description,
                                          ulLeaseDuration);
            }
            else
            {
                hr = AddDynamicPortMapping(RemoteHost,
                                           uwExternalPort,
                                           Protocol,
                                           uwInternalPort,
                                           InternalClient,
                                           bEnabled,
                                           Description,
                                           ulLeaseDuration);
            }
        }
    }
    else
    { 
        DBG_SPEW(TM_STATIC, TL_ERROR, L"Control Disabled E(%X)", hr);
    }

    return hr;
}

HRESULT
CWANConnectionBase::AddDynamicPortMapping(
                                          BSTR         RemoteHost,
                                          USHORT       uwExternalPort,  
                                          BSTR         Protocol,
                                          USHORT       uwInternalPort,  
                                          BSTR         InternalClient,  
                                          VARIANT_BOOL bEnabled,        
                                          BSTR         Description,     
                                          ULONG        ulLeaseDuration
                                         )
{
    
    //
    // We currently don't handle any Dynamic Port Redirections.
    //
    DBG_SPEW(TM_DYNAMIC, TL_ERROR, L"Only Static Mappings are allowed [Lease]");

    SetUPnPError(L"725");

    return E_INVALIDARG;
}

HRESULT
CWANConnectionBase::AddStaticPortMapping(
                                         BSTR         RemoteHost,
                                         USHORT       uwExternalPort,  
                                         BSTR         Protocol,
                                         USHORT       uwInternalPort,  
                                         BSTR         InternalClient,  
                                         VARIANT_BOOL bEnabled,        
                                         BSTR         Description,     
                                         ULONG        ulLeaseDuration
                                        )
{
    HRESULT                      hr                    = S_OK;
    UCHAR                        ProtocolType          = 0;
    IHNetProtocolSettings*       ProtocolSettingsp     = NULL;
    IHNetPortMappingProtocol*    PortMappingProtocolp  = NULL;
    IHNetPortMappingBinding*     PortMappingBindingp   = NULL;
    ULONG                        ClientAddr            = 0;
    BOOLEAN                      bLetsEnable           = FALSE;
    BOOLEAN                      bCreatedProtocol      = FALSE;
    ULONG                        tempStrLen            = 0;
    WCHAR                        tempPortStr[]         = L"00000";
    LPOLESTR                     tempStr               = NULL;
    USHORT                       tempExtPort = 0, tempIntPort = 0;
    BSTR ProtocolFromBinding       = NULL;
    BSTR ClientFromBinding         = NULL;
    BSTR DescriptionFromBinding    = NULL;
    VARIANT_BOOL boolEnabled;




    _ASSERT( uwExternalPort );
    _ASSERT( uwInternalPort );

    //
    // Convert both ends to Network Order
    //
    tempExtPort       = htons( uwExternalPort );
    tempIntPort       = htons( uwInternalPort );


    //
    // Convert VARIANT_BOOL to boolean
    //
    bLetsEnable = ( bEnabled == VARIANT_TRUE );

    //
    // Process the Operation
    //
    do
    {
        RESOLVE_PROTOCOL_TYPE(ProtocolType, Protocol);

        //
        // IF there is no description crate one
        // using PORT and PROTOCOL
        //
        if ( wcscmp(Description, L"\0") == 0 ) 
        {   
            // Get Internal ClientName + the seperator
            tempStrLen = ( SysStringLen( InternalClient ) + 1 ); 
    
            // Get port len + plus the seperator
            _itow ( uwExternalPort, tempPortStr, 10);
    
            tempStrLen += (wcslen (tempPortStr) + 1);

            // Get Protocol Name
            tempStrLen += SysStringLen( Protocol );

    
            // Create out from these two
            tempStr = (LPOLESTR)CoTaskMemAlloc( (tempStrLen + 1) * sizeof(WCHAR) );
    
            if ( tempStr != NULL )
            {

                _snwprintf(tempStr, tempStrLen, L"%s-%s-%s", 
                           InternalClient, tempPortStr, Protocol);

                tempStr[ tempStrLen ] = L'\0';

                Description = SysAllocString ( tempStr );
            }
            
            if ( (tempStr == NULL) || (Description == NULL) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"Can't Initialize Strings - out of mem");

                hr = E_OUTOFMEMORY;

                break;
            }
        }


        //
        // Find Existing Mapping
        //
        hr = SearchPortMapping(m_IcsSettingsp,
                               0,
                               tempExtPort,
                               ProtocolType,
                               &PortMappingProtocolp);
        //
        // if found it is in Edit Mode.
        //
        if ( SUCCEEDED(hr) )
        {

            hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(PortMappingProtocolp,
                                                                        &PortMappingBindingp);

            _ASSERT( SUCCEEDED(hr) );

            if ( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, 
                         L"Can't get Binding for Port Mapping E(X)", hr);
                _ASSERT( FALSE );
                break;
            }

            //
            // Fill the information 
            //
            hr = FillStaticMappingInformation(PortMappingProtocolp,
                                              PortMappingBindingp,
                                              &tempExtPort, 
                                              &ProtocolFromBinding, 
                                              &tempIntPort,
                                              &ClientFromBinding,
                                              &boolEnabled,
                                              &DescriptionFromBinding);

            if ( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, 
                         L"Filling has failed for Mapping Information E(%X)", hr);
                break;
            }
                                        
            //
            // If the existin Mapping was disabled we should be able to change
            // the Internal Client
            //
            if ( boolEnabled == VARIANT_TRUE )
            {
                if ( _wcsicmp( InternalClient, ClientFromBinding) != 0 ) // if diff then error
                {
                    hr = E_INVALIDARG;
                    DBG_SPEW(TM_STATIC, TL_ERROR, 
                             L"Will not change the internal client for an enabled PortMapping");
                    SetUPnPError(L"718");
                    break;
                }
            }

            //
            // if the Internal Port has changed reflect the change
            //
            if ( tempIntPort != htons( uwInternalPort ) )
            {
                tempIntPort = htons( uwInternalPort );

                hr = PortMappingBindingp->SetTargetPort( tempIntPort ); 

                _ASSERT( SUCCEEDED(hr) );

                if ( FAILED(hr) )
                {
                    DBG_SPEW(TM_STATIC, TL_ERROR, L"Changin Internal Port has Failed E(%X)", hr);
                    break;
                }
            }

            //
            // Set the description if changed
            //
            if ( _wcsicmp(DescriptionFromBinding, Description) != 0)
            {
                hr = PortMappingProtocolp->SetName(Description);
                if ( FAILED(hr) )
                {
                    hr = E_INVALIDARG;
                    DBG_SPEW(TM_STATIC, TL_ERROR, L"Set Name has failed E(%X)", hr);
                    break;
                }
            }
        }
        else
        {
            //
            // Start Getting the Interface
            //
            hr = m_IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                                reinterpret_cast<void**>(&ProtocolSettingsp));

            if ( SUCCEEDED(hr) )
            {
                hr = ProtocolSettingsp->CreatePortMappingProtocol(Description,
                                                                  ProtocolType,
                                                                  tempExtPort,
                                                                  &PortMappingProtocolp);

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pHomenetConnection->GetBindingForPortMappingProtocol(PortMappingProtocolp,
                                                                                &PortMappingBindingp);
                    if ( SUCCEEDED(hr) )
                    {
                        hr = PortMappingBindingp->SetTargetPort( tempIntPort );

                        _ASSERT( SUCCEEDED(hr) );

                        if ( FAILED(hr) )
                        {
                            DBG_SPEW(TM_STATIC, TL_ERROR, L"Set Target Port has Failed E(%X)", hr);
                        }
                        
                        bCreatedProtocol = TRUE;

                    }
                    else
                    {
                        DBG_SPEW(TM_STATIC, TL_ERROR, 
                                 L"Getting Binding has Failed E(X)", hr);
                        PortMappingProtocolp->Delete();
                        break;
                    }
                }
                else
                {
                    DBG_SPEW(TM_STATIC, TL_ERROR, 
                             L"Creating the PortMapping has Failed E(%X)", hr);
                    break;
                }

            }
            else
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, 
                         L"Getting the Protocol Settings has failed E(X)", hr);
                break;
            }
        }

        //
        // Setting the Client name / address
        // For Edit mode we already checked wether this code will be run or not.
        //
        if ( 
            ( wcscmp(L"0.0.0.0", InternalClient) != 0 ) &&
            ( InternalClient[0] != L'\0' )
           )
        {
            ClientAddr = INET_ADDR((LPOLESTR) InternalClient );

            //
            // if the address is not valid (INADDR_NONE)
            // and if the address is different than Broadcast address (which also is INADDR_NONE)
            //
            if ( (ClientAddr == INADDR_NONE) && wcscmp(L"255.255.255.255", InternalClient) )
            {
                hr = PortMappingBindingp->SetTargetComputerName( InternalClient );
            }
            else
            {
                hr = PortMappingBindingp->SetTargetComputerAddress( ClientAddr );
            }

            _ASSERT( SUCCEEDED(hr) );

            if ( SUCCEEDED(hr) )
            {
                hr = PortMappingBindingp->SetEnabled( bLetsEnable );
            }

            if ( FAILED(hr) ) DBG_SPEW(TM_STATIC, TL_ERROR, L"Client Add/Edit IntClient failed - E(%X)", hr);
        }

        if ( FAILED(hr) && (TRUE == bCreatedProtocol) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Client Add / Edit failed - E(%X)", hr);
            hr = PortMappingProtocolp->Delete();
        }

    } while ( FALSE );

    if ( tempStr != NULL) 
    {
        CoTaskMemFree ( tempStr );
        SysFreeString ( Description ); // you can free a NULL string.
    }

    if ( ProtocolFromBinding )    SysFreeString(ProtocolFromBinding);

    if ( ClientFromBinding )      SysFreeString(ClientFromBinding);

    if ( DescriptionFromBinding ) SysFreeString(DescriptionFromBinding);
                                
    if ( PortMappingBindingp != NULL ) PortMappingBindingp->Release();

    if ( PortMappingProtocolp != NULL ) PortMappingProtocolp->Release();

    if ( ProtocolSettingsp != NULL ) ProtocolSettingsp->Release();

    if ( FAILED(hr) ) { DBG_SPEW(TM_STATIC, TL_ERROR, L"Error Returning hr (%X)", hr); }

    return hr;
} // CWANConnectionBase :: AddStaticPortMapping






HRESULT 
CWANConnectionBase::DeletePortMapping(
                                      BSTR      RemoteHost,
                                      USHORT    uwExternalPort, 
                                      BSTR      Protocol
                                     )
{
    HRESULT hr = S_OK;

    UCHAR                        ProtocolType          = 0;

    IHNetPortMappingProtocol*    PortMappingProtocolp  = NULL;

    USHORT                       tempExtPort              = 0;

    //
    // SECURITY - SECURITY - SECURITY
    // Here we're allowing the out-of-proc COM call
    // into our service to have SYSTEM access rights.
    //
    // REASON: UPnP works in LOCAL_SERVICE and COM
    //         Calls into our service which modify
    //         the WMI repository will FAIL. This
    //         Call alleviates that problem by changing
    //         The Security to that of the SYSTEM
    //         and is reverted back when the class
    //         is out of scope by the destructor of.
    //         CSwitchSecurityContext 
    //
    CSwitchSecurityContext SwSecCxt;


    _ASSERT( RemoteHost     != NULL );
    _ASSERT( uwExternalPort != 0    );
    _ASSERT( Protocol       != NULL );

    DBG_SPEW(TM_STATIC, TL_TRACE, L"> DeletePortMapping");

    //
    // check for access
    hr = this->ControlEnabled();

    if ( FAILED(hr) ) { return hr; }
    
    //
    // Convert to Network order
    // 
    tempExtPort = htons(uwExternalPort );

    DBG_SPEW(TM_STATIC, TL_INFO, 
             L"Search Specific - ExtPort (%hu) Protocol (%s)",
             uwExternalPort, Protocol);
    

    do
    {
        RESOLVE_PROTOCOL_TYPE( ProtocolType, Protocol );

        hr = SearchPortMapping(m_IcsSettingsp,
                               0,
                               tempExtPort,
                               ProtocolType,
                               &PortMappingProtocolp);
        
        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Error in Searching E(%X)", hr );
            SetUPnPError(L"714"); 
            break;
        }

        hr = PortMappingProtocolp->Delete();

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"ProtocolMapping deletion failure, Might be Built in E(%X)", hr );
        }
        
        PortMappingProtocolp->Release();

    } while ( FALSE );


    if ( FAILED(hr) ) DBG_SPEW(TM_STATIC, TL_ERROR, L"Delete failed with hr - %X", hr);

    return hr;
}

HRESULT CWANConnectionBase::GetExternalIPAddress(BSTR* pExternalIPAddress)
{
    HRESULT hr = S_OK;

    SysFreeString(*pExternalIPAddress);
    *pExternalIPAddress = NULL;

    hr = get_ExternalIPAddress(pExternalIPAddress);

    return hr;
}



HRESULT CWANConnectionBase::ControlEnabled()
{
    HRESULT hr = S_OK;

    // check the reg key.  Only disable if key exists and is 0.  

    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS == dwError) // if this fails we assume it is on, set the box, and commit on apply
    {
        DWORD dwType;
        DWORD dwData = 0;
        DWORD dwSize = sizeof(dwData);
        dwError = RegQueryValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, &dwType, reinterpret_cast<LPBYTE>(&dwData), &dwSize);
        if(ERROR_SUCCESS == dwError && REG_DWORD == dwType && 0 == dwData)
        {
            hr = E_ACCESSDENIED;
        }
        RegCloseKey(hKey);
    }

    return hr;
}



HRESULT
SearchPortMapping(
                  IN          IHNetIcsSettings*           IcsSettingsp,
                  IN OPTIONAL ULONG                       searchIndex,
                  IN OPTIONAL USHORT                      searchPort,
                  IN OPTIONAL UCHAR                       searchProtocol,
                  OUT         IHNetPortMappingProtocol    **Protocolpp
                 )
//
// Two ways of Seeking an entry..
// 1) By Index.. Enumerate until you hit the giventh Index.
// 2) Seeks and retrieves Port and ProtocolType
//
{
    HRESULT                         hr                    = S_OK;

    IHNetProtocolSettings*          ProtocolSettingsp     = NULL;

    IEnumHNetPortMappingProtocols*  EnumProtocolsp        = NULL;

    IHNetPortMappingProtocol*       tempProtocolp             = NULL;

    USHORT                          ProtocolPort          = 0;

    UCHAR                           ProtocolType          = 0;

    BOOLEAN                         bFound                = FALSE;

    ULONG                           iIndex                = 0;

    DBG_SPEW(TM_STATIC, TL_ERROR, L" > SearchPortMapping ");


    //
    // Index = 0 is a valid search
    // searchPort and searcProtocol should exist both or not.
    //
    _ASSERT( !((searchPort == NULL) ^  (searchProtocol == 0)) );
    

    _ASSERT( IcsSettingsp != NULL );
    _ASSERT( Protocolpp   != NULL );


    do
    {
        hr = IcsSettingsp->QueryInterface(IID_IHNetProtocolSettings,
                                    reinterpret_cast<void**>(&ProtocolSettingsp));
    
        if( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Query Interface failed for ProtocolSettingsp E(%X)", hr);
            break;
        }

        hr = ProtocolSettingsp->EnumPortMappingProtocols(&EnumProtocolsp);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Enum Interface can't be retrieved E(%X)", hr);
            break;
        }

        while( (FALSE == bFound) &&
               (S_OK == EnumProtocolsp->Next(1, &tempProtocolp, NULL)) )
        {
            if ( searchPort != 0 )
            {
                hr = tempProtocolp->GetPort( &ProtocolPort );

                if ( SUCCEEDED(hr) )
                {
                    hr = tempProtocolp->GetIPProtocol(&ProtocolType);
                }
                
                if( FAILED(hr) )
                {
                    DBG_SPEW(TM_STATIC, TL_ERROR, L"Search info Failure E(%X)", hr);
                }
                else if((searchPort == ProtocolPort) &&
                        (ProtocolType == searchProtocol))
                {       
                    bFound = TRUE;
                }
            }
            else // if the search key == the Index
            {
                if ( iIndex == searchIndex )
                {
                    bFound = TRUE;
                }
            }
            
            //
            // if Nothing is found
            if (FALSE == bFound) 
            {
                tempProtocolp->Release();
            }
            
            iIndex++;
        }

        EnumProtocolsp->Release();

    } while ( FALSE );

    if(ProtocolSettingsp != NULL)
    {
        ProtocolSettingsp->Release();
    }

    if( (bFound == TRUE)     &&
        (tempProtocolp != NULL))
    {
        *Protocolpp = tempProtocolp;
    }
    else
    {
        return E_INVALIDARG;
    }

    return hr;
}


HRESULT
FillStaticMappingInformation(
                             IN          IHNetPortMappingProtocol*  MappingProtocolp,
                             IN OPTIONAL IHNetPortMappingBinding*   Bindingp,
                             OUT         PUSHORT                    uExternalPortp,
                             OUT         BSTR*                      Protocolp,
                             OUT         PUSHORT                    uInternalPortp,
                             OUT         BSTR*                      InternalClientp,
                             OUT         VARIANT_BOOL*              bEnabledp,
                             OUT         BSTR*                      Descriptionp
                            )
//
// Note that Will return the port in Network Byte Order
//
{
    HRESULT                     hr                 = S_OK;
    
    UCHAR                       ProtocolType       = NULL;
    LPOLESTR                    szInternalHostAddr = NULL;
    LPOLESTR                    szDescription      = NULL;
    BOOLEAN                     bEnabled           = FALSE;
    BOOLEAN                     bUseName           = FALSE;
    ULONG                       InternalHostAddr   = 0;
    

    _ASSERT ( uExternalPortp   != NULL );
    _ASSERT ( Protocolp        != NULL );
    _ASSERT ( InternalClientp  != NULL );
    _ASSERT ( bEnabledp        != NULL );
    _ASSERT ( Descriptionp     != NULL );
    _ASSERT ( MappingProtocolp != NULL );
    _ASSERT ( Bindingp         != NULL );

    *uExternalPortp  = 0;
    *Protocolp       = NULL;
    *InternalClientp = NULL;
    *bEnabledp       = VARIANT_FALSE;
    *Descriptionp    = NULL;

    DBG_SPEW(TM_STATIC, TL_TRACE, L"> FillStaticMappingInformation");

    do
    {
        //
        // Description
        //
        hr = MappingProtocolp->GetName(&szDescription);

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, L"Getting the Name has failed E(%X)", hr);
            break;
        }

        BOOLEAN fBuiltin = FALSE;

        hr = MappingProtocolp->GetBuiltIn( &fBuiltin );

        _ASSERT( SUCCEEDED(hr) );

        if ( fBuiltin ) 
        {
            #define BUILTIN_KEY L" [MICROSOFT]"
            
            UINT uiLength  = wcslen(szDescription );
            uiLength      += wcslen(BUILTIN_KEY);
            *Descriptionp = SysAllocStringLen(NULL, uiLength);

            if ( *Descriptionp ) 
            {
                wcscpy (*Descriptionp, szDescription);
                wcscat (*Descriptionp, BUILTIN_KEY);
            }
        } 
        else 
        {
            *Descriptionp = SysAllocString(szDescription);
        }

        if(*Descriptionp == NULL)
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Memory Allocation for Description has Failed");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Protocol
        //
        hr = MappingProtocolp->GetIPProtocol(&ProtocolType);

        _ASSERT( SUCCEEDED(hr) );

        if ( ProtocolType == NAT_PROTOCOL_TCP )
        {
            *Protocolp = SysAllocString(L"TCP");
        }
        else if ( ProtocolType == NAT_PROTOCOL_UDP )
        {
            *Protocolp = SysAllocString(L"UDP");
        } 
        else
        {
            _ASSERT( FALSE );
        }

        if (*Protocolp == NULL)
        {
            DBG_SPEW(TM_STATIC, TL_ERROR, 
                     L"Memory Allocation for Description has Failed");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // External Port
        //
        hr = MappingProtocolp->GetPort( uExternalPortp );


        _ASSERT( SUCCEEDED(hr) );

        if ( FAILED(hr) )
        {
            DBG_SPEW(TM_STATIC, TL_ERROR,
                     L"GetPort for Protocol has failed E(%X)", hr);
            break;
        }

        // Getting the Binding Information
        if ( Bindingp != NULL )
        {
            //
            // Enabled
            hr = Bindingp->GetEnabled(&bEnabled);

            _ASSERT( SUCCEEDED(hr) );

            if ( bEnabled == TRUE)
            {
                *bEnabledp = VARIANT_TRUE;
            }
            else
            {
                *bEnabledp = VARIANT_FALSE;
            }

            hr = Bindingp->GetTargetPort( uInternalPortp );

            _ASSERT( SUCCEEDED(hr) );

            if ( FAILED(hr) )
            {
                DBG_SPEW(TM_STATIC, TL_ERROR,
                         L"GetPort for Binding has  failed E(%X)", hr);

                break;
            }

            //
            // InternalClient
            hr = Bindingp->GetCurrentMethod(&bUseName);

            if( SUCCEEDED(hr) )
	        {
                if ( bUseName == TRUE)
                {
                    hr = Bindingp->GetTargetComputerName(&szInternalHostAddr);
    
                    if ( FAILED(hr) )
                    {
                        break;
                    }
    
                    _ASSERT( SUCCEEDED(hr) );
                }
                else
                {
                    hr = Bindingp->GetTargetComputerAddress(&InternalHostAddr);
    
                    _ASSERT( SUCCEEDED(hr) );
    
                    if ( FAILED(hr) )
                    {
                        break;
                    }
    
                    //
                    // IF the address is Loopback change it to a name which would make more
                    // sense to any client who sees it.
                    //
                    if ( INADDR_LOOPBACK == htonl(InternalHostAddr) )
                    {
                        ULONG uCount = 0;
    
                        if ( 0 == GetComputerNameEx( ComputerNameDnsHostname, NULL, &uCount) )
                        {
                            if ( (ERROR_MORE_DATA == GetLastError()) )
                            {
                                szInternalHostAddr = 
                                    (LPOLESTR) CoTaskMemAlloc( uCount * sizeof(WCHAR) );
    
                                if ( NULL != szInternalHostAddr )
                                {
                                    if (!GetComputerNameEx(ComputerNameDnsHostname,
                                                           szInternalHostAddr,
                                                           &uCount))
                                    {
                                        hr = HRESULT_FROM_WIN32( GetLastError() );
    
                                        break;
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
    
                                    break;
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
    
                                break;
                            }
                        }
                    }
                    else if ( 0 != InternalHostAddr )
                    {
                        szInternalHostAddr = INET_NTOW_TS( InternalHostAddr );
                    }
                    else
                    {
                        szInternalHostAddr = (LPOLESTR) CoTaskMemAlloc( sizeof(WCHAR) );
    
                        if ( NULL != szInternalHostAddr) szInternalHostAddr[0] = 0;
                    }
    
                    if ( szInternalHostAddr == NULL )
                    {
                        hr = E_OUTOFMEMORY;
    
                        break;
                    }
                } // if Name method
        	}

            *InternalClientp = SysAllocString( szInternalHostAddr );

            if ( *InternalClientp == NULL)
            {
                DBG_SPEW(TM_STATIC, TL_ERROR, L"Mem Allocation for Internal Client Name");

                hr = E_OUTOFMEMORY;

                break;
            }
        } // if bindingp

    } while ( FALSE );

    if ( szDescription )        CoTaskMemFree( szDescription );
    
    if ( szInternalHostAddr )   CoTaskMemFree( szInternalHostAddr );

    if ( FAILED(hr) )
    {
        if(*Protocolp)       { SysFreeString(*Protocolp);       *Protocolp = NULL; }

        if(*InternalClientp) { SysFreeString(*InternalClientp); *InternalClientp = NULL;}

        if(*Descriptionp)    { SysFreeString(*Descriptionp);   *Descriptionp = NULL;}
    }
    
    return hr;
}


inline HRESULT
ValidatePortMappingParameters
(
 IN  BSTR          RemoteHost,
 IN  USHORT        uwExternalPort,
 IN  BSTR          Protocol,
 IN  USHORT        uwInternalPort,
 IN  BSTR          InternalClient,
 IN  VARIANT_BOOL  bEnabled,
 IN  BSTR          Description,
 IN  ULONG         ulLeaseDuration,
 OUT MAPPING_TYPE* pMappingType
)
//
// Decide wether a Mapping is to be dynamic or static
// Validate the parameters pre-emptively
//
{
    MAPPING_TYPE  MappingType   = ePortMappingInvalid;

    _ASSERT( RemoteHost     != NULL );
    _ASSERT( Protocol       != NULL );
    _ASSERT( Protocol[0]    != 0    );
    _ASSERT( Description    != NULL );
    _ASSERT( uwInternalPort != 0    );
    _ASSERT( pMappingType   != NULL );
    _ASSERT( InternalClient != NULL );
    _ASSERT( RemoteHost[0]  == 0    );


    //
    // An Internal Port as well as an external Port should exist all time
    //
    if ( (0 == uwInternalPort) || (0 == uwExternalPort) )
    {
        SetUPnPError(L"716");

        return E_INVALIDARG;
    }

    //
    // is this a dynamic request?
    //
    if ( 0 != ulLeaseDuration )
    {
        MappingType = ePortMappingDynamic;
    }                                     
    else
    {
        MappingType = ePortMappingStatic;
    }


    //
    // A Dynamic Port Mapping needs to be with
    // an Internal Client
    // 
    if (
        ( ePortMappingDynamic == MappingType ) &&
        ( InternalClient[0] == L'\0' )
       )
    {
        SetUPnPError(L"402");

        return E_INVALIDARG;
    }

    //
    // A remote Host is defined.. we can't process this
    // 
    if ( RemoteHost[0]  != L'\0' )
    {
        SetUPnPError(L"726");

        return E_INVALIDARG;
    }

    //
    // Check the bEnabled bool value
    //
    if ( (bEnabled != VARIANT_TRUE) && (bEnabled != VARIANT_FALSE) )
    {
        SetUPnPError(L"402");

        return E_INVALIDARG;
    }
    
    *pMappingType = MappingType;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanpotslinkconfigservice.cpp ===
#include "pch.h"
#pragma hdrstop

#include "CWANPOTSLinkConfigService.h"
#include "raserror.h"


CWANPOTSLinkConfigService::CWANPOTSLinkConfigService()
{
    m_pEventSink = NULL;
    m_pNetRasConnection = NULL;
}

HRESULT CWANPOTSLinkConfigService::Initialize(INetConnection* pNetConnection)
{
    HRESULT hr = S_OK;

    hr = pNetConnection->QueryInterface(IID_INetRasConnection, reinterpret_cast<void**>(&m_pNetRasConnection));
    
    return hr;
}

HRESULT CWANPOTSLinkConfigService::FinalRelease(void)
{
    HRESULT hr = S_OK;

    if(NULL != m_pNetRasConnection)
    {
        m_pNetRasConnection->Release();
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::Advise(IUPnPEventSink* pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;
    m_pEventSink->AddRef();

    return hr;
}

HRESULT CWANPOTSLinkConfigService::Unadvise(IUPnPEventSink *pesSubscriber)
{
    HRESULT hr = S_OK;

    m_pEventSink->Release();
    m_pEventSink = NULL;

    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_ISPPhoneNumber(BSTR* pISPPhoneNumber)
{
    HRESULT hr = S_OK;

    *pISPPhoneNumber = NULL;

    RASENTRY* pRasEntry;
    hr = GetRasEntry(&pRasEntry);
    if(SUCCEEDED(hr))
    {
        *pISPPhoneNumber = SysAllocString(pRasEntry->szLocalPhoneNumber);
        if(NULL == *pISPPhoneNumber)
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(pRasEntry);
    }
    
    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_ISPInfo(BSTR *pISPInfo)
{
    HRESULT hr = S_OK;
    *pISPInfo = SysAllocString(L"");
    if(NULL == *pISPInfo)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_LinkType(BSTR *pLinkType)
{
    HRESULT hr = S_OK;
    *pLinkType = SysAllocString(L"PPP_Dialup");
    if(NULL == *pLinkType)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_NumberOfRetries(ULONG *pNumberOfRetries)
{
    HRESULT hr = S_OK;

    RASENTRY* pRasEntry;
    hr = GetRasEntry(&pRasEntry);
    if(SUCCEEDED(hr))
    {
        *pNumberOfRetries = pRasEntry->dwRedialCount;
        CoTaskMemFree(pRasEntry);
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::get_DelayBetweenRetries(ULONG *pDelayBetweenRetries)
{
    HRESULT hr = S_OK;
    
    RASENTRY* pRasEntry;
    hr = GetRasEntry(&pRasEntry);
    if(SUCCEEDED(hr))
    {
        *pDelayBetweenRetries = pRasEntry->dwRedialPause;
        CoTaskMemFree(pRasEntry);
    }
    
    return hr;
}

HRESULT CWANPOTSLinkConfigService::GetISPInfo(BSTR* pISPPhoneNumber, BSTR *pISPInfo, BSTR *pLinkType)
{
    HRESULT hr = S_OK;

    SysFreeString(*pISPPhoneNumber);
    SysFreeString(*pISPInfo);
    SysFreeString(*pLinkType);
    *pISPPhoneNumber = NULL;
    *pISPInfo = NULL;
    *pLinkType = NULL;
    
    hr = get_ISPPhoneNumber(pISPPhoneNumber);
    if(SUCCEEDED(hr))
    {
        hr = get_ISPInfo(pISPInfo);
    }
    if(SUCCEEDED(hr))
    {
        hr = get_LinkType(pLinkType);        
    }

    if(FAILED(hr))
    {
        SysFreeString(*pISPPhoneNumber);
        SysFreeString(*pISPInfo);
        SysFreeString(*pLinkType);
        *pISPPhoneNumber = NULL;
        *pISPInfo = NULL;
        *pLinkType = NULL;
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::GetCallRetryInfo(ULONG* pNumberOfRetries, ULONG *pDelayBetweenRetries)
{
    HRESULT hr = S_OK;

    hr = get_NumberOfRetries(pNumberOfRetries);
    if(SUCCEEDED(hr))
    {
        hr = get_DelayBetweenRetries(pDelayBetweenRetries);
    }

    return hr;
}

HRESULT CWANPOTSLinkConfigService::GetRasEntry(RASENTRY** ppRasEntry)
{
    HRESULT hr = S_OK;

    *ppRasEntry = NULL;

    RASCON_INFO RasConnectionInfo;
    hr = m_pNetRasConnection->GetRasConnectionInfo(&RasConnectionInfo);
    if(SUCCEEDED(hr))
    {
        RASENTRY DummyRasEntry;
        ZeroMemory(&DummyRasEntry, sizeof(DummyRasEntry)); 
        DummyRasEntry.dwSize = sizeof(DummyRasEntry);
        DWORD dwEntrySize = sizeof(DummyRasEntry);
        DWORD dwError = RasGetEntryProperties(RasConnectionInfo.pszwPbkFile, RasConnectionInfo.pszwEntryName, &DummyRasEntry, &dwEntrySize, NULL, NULL);
        if(0 == dwError || ERROR_BUFFER_TOO_SMALL == dwError)
        {
            RASENTRY* pRasEntry = reinterpret_cast<RASENTRY*>(CoTaskMemAlloc(dwEntrySize));
            if(NULL != pRasEntry)
            {
                ZeroMemory(pRasEntry, dwEntrySize); 
                pRasEntry->dwSize = sizeof(RASENTRY);
                dwError = RasGetEntryProperties(RasConnectionInfo.pszwPbkFile, RasConnectionInfo.pszwEntryName, pRasEntry, &dwEntrySize, NULL, NULL);
                if(0 == dwError)
                {
                    *ppRasEntry = pRasEntry;                        

                }
                else
                {
                    hr = E_FAIL;
                }
                
                if(FAILED(hr))
                {
                    CoTaskMemFree(pRasEntry);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        CoTaskMemFree(RasConnectionInfo.pszwPbkFile);
        CoTaskMemFree(RasConnectionInfo.pszwEntryName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanipconnectionservice.cpp ===
#include "pch.h"
#pragma hdrstop 

#include "CWANIPConnectionService.h"
#include "ndispnp.h"
#include "ras.h"
#include "rasuip.h"
#include "util.h"

CWANIPConnectionService::CWANIPConnectionService()
{
}

HRESULT CWANIPConnectionService::get_LastConnectionError(BSTR *pLastConnectionError)
{
    HRESULT hr = S_OK;
    *pLastConnectionError = SysAllocString(L"ERROR_NONE");
    if(NULL == *pLastConnectionError)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANIPConnectionService::RequestConnection(void)
{
    HRESULT hr = S_OK;

    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        INetConnection* pNetConnection;
        hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
        if(SUCCEEDED(hr))
        {
            hr = pNetConnection->Connect();
            pNetConnection->Release();
        } 
        
        if(FAILED(hr))
        {
            SetUPnPError(DCP_ERROR_CONNECTIONSETUPFAILED);
        }
    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    return hr;
}

HRESULT CWANIPConnectionService::ForceTermination(void)
{
    HRESULT hr = S_OK;


    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        INetConnection* pNetConnection;
        hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
        if(SUCCEEDED(hr))
        {
            hr = pNetConnection->Disconnect();
            pNetConnection->Release();
        }
    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanpppconnectionservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "resource.h"       // main symbols
#include "netconp.h"
#include "netcon.h"
#include "CWANConnectionBase.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CWANPPPConnectionService : 
    public CWANConnectionBase
{
public:

    CWANPPPConnectionService();

    STDMETHODIMP RequestConnection();
    STDMETHODIMP ForceTermination();
    STDMETHODIMP get_LastConnectionError(BSTR *pLastConnectionError);

private:

    DWORD m_dwLastConnectionError;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanpppconnectionservice.cpp ===
#include "pch.h"
#pragma hdrstop 

#include "CWANPPPConnectionService.h"
#include "ndispnp.h"
#include "ras.h"
#include "rasuip.h"
#include "util.h"
#include "raserror.h"
#include "rasdlg.h"

CWANPPPConnectionService::CWANPPPConnectionService()
{
    m_dwLastConnectionError = 0;
}

HRESULT CWANPPPConnectionService::get_LastConnectionError(BSTR *pLastConnectionError)
{
    HRESULT hr = S_OK;
    
    LPOLESTR pszError = NULL;
    switch(m_dwLastConnectionError)
    {
    case 0:
        pszError = L"ERROR_NONE";
        break;
    case ERROR_PPP_TIMEOUT:
    case ERROR_REQUEST_TIMEOUT:
        pszError = L"ERROR_ISP_TIME_OUT"; 
        break;
//    case : // no mapping
//        pszError = L"ERROR_COMMAND_ABORTED"; 
//        break;
//    case : // no mapping
//        pszError = L"ERROR_NOT_ENABLED_FOR_INTERNET"; 
//        break;
    case ERROR_BAD_PHONE_NUMBER:
        pszError = L"ERROR_BAD_PHONE_NUMBER"; 
        break;
    case ERROR_USER_DISCONNECTION:
        pszError = L"ERROR_USER_DISCONNECT"; 
        break;
    case ERROR_REMOTE_DISCONNECTION:
        pszError = L"ERROR_ISP_DISCONNECT"; 
        break;
//    case : // no mapping
//        pszError = L"ERROR_IDLE_DISCONNECT"; 
//        break;
//    case : // no mapping
//        pszError = L"ERROR_FORCED_DISCONNECT"; 
//        break;
    case ERROR_SERVER_OUT_OF_RESOURCES:
        pszError = L"ERROR_SERVER_OUT_OF_RESOURCES"; 
        break;
    case ERROR_RESTRICTED_LOGON_HOURS:
        pszError = L"ERROR_RESTRICTED_LOGON_HOURS"; 
        break;
    case ERROR_ACCT_DISABLED:
        pszError = L"ERROR_ACCOUNT_DISABLED"; 
        break;
    case ERROR_ACCT_EXPIRED:
        pszError = L"ERROR_ACCOUNT_EXPIRED"; 
        break;
    case ERROR_PASSWD_EXPIRED:
        pszError = L"ERROR_PASSWORD_EXPIRED"; 
        break;
    case ERROR_AUTHENTICATION_FAILURE:
        pszError = L"ERROR_AUTHENTICATION_FAILURE"; 
        break;
    case ERROR_NO_DIALTONE:
        pszError = L"ERROR_NO_DIALTONE"; 
        break;
    case ERROR_NO_CARRIER:
        pszError = L"ERROR_NO_CARRIER"; 
        break;
    case ERROR_NO_ANSWER:
        pszError = L"ERROR_NO_ANSWER"; 
        break;
    case ERROR_LINE_BUSY:
        pszError = L"ERROR_LINE_BUSY"; 
        break;
    case ERROR_UNSUPPORTED_BPS:
        pszError = L"ERROR_UNSUPPORTED_BITSPERSECOND"; 
        break;
    case ERROR_TOO_MANY_LINE_ERRORS:
        pszError = L"ERROR_TOO_MANY_LINE_ERRORS"; 
        break;
    case ERROR_IP_CONFIGURATION:
        pszError = L"ERROR_IP_CONFIGURATION"; 
        break;
    default:
        pszError = L"ERROR_UNKNOWN";
        break;
    }
    
    *pLastConnectionError = SysAllocString(pszError);
    if(NULL == *pLastConnectionError)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CWANPPPConnectionService::RequestConnection(void)
{
    HRESULT hr = S_OK;

    m_dwLastConnectionError = 0;
    
    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        DWORD dwErr;
        RASSHARECONN rsc;
        dwErr = RasQuerySharedConnection(&rsc);
        if(NO_ERROR == dwErr)
        {
            RASCREDENTIALSW rc;
            rc.dwSize = sizeof(rc);
            rc.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;
            dwErr = RasGetCredentials(rsc.name.szPhonebookPath, rsc.name.szEntryName, &rc);
            if (NO_ERROR == dwErr) 
            {
                RASDIALEXTENSIONS rde;
                RASDIALPARAMSW rdp;

                ZeroMemory(&rde, sizeof(rde));
                rde.dwSize = sizeof(rde);
                rde.dwfOptions = RDEOPT_NoUser;
                
                ZeroMemory(&rdp, sizeof(rdp));
                rdp.dwSize = sizeof(rdp);
                lstrcpyW(rdp.szEntryName, rsc.name.szEntryName);
                lstrcpyW(rdp.szUserName, rc.szUserName);
                lstrcpyW(rdp.szDomain, rc.szDomain);
                lstrcpyW(rdp.szPassword, rc.szPassword);
                ZeroMemory(&rc, sizeof(rc)); // zero crendentials

                HRASCONN hrasconn = NULL;
                dwErr = RasDial(&rde, rsc.name.szPhonebookPath, &rdp, 0, NULL, &hrasconn);
                ZeroMemory(&rdp, sizeof(rdp)); // zero credentials
                
                if (E_NOTIMPL == dwErr)
                {
                    //
                    // This is possibly a Connection Manager connection since it's returning E_NOTIMPL,
                    // we should check the phonebook entry for the type and then call the RasDialDlg 
                    // with the RASDDFLAG_NoPrompt flag.
                    // 
                    RASDIALDLG info;
                    BOOL fRetVal = FALSE;
                    RASENTRY re;
                    DWORD dwRasEntrySize;
                    DWORD dwIgnore;
                    HINSTANCE hRasDlgDll = NULL;
                    FARPROC lpfnRasDialDlg = NULL;
                    typedef BOOL (*lpfnRasDialDlgFunc)(LPWSTR, LPWSTR, LPWSTR, LPRASDIALDLG);
                    
                    ZeroMemory(&info, sizeof(info));
                    info.dwSize = sizeof(info);

                    ZeroMemory(&re, sizeof(re));
                    dwRasEntrySize = sizeof(re);
                    re.dwSize = dwRasEntrySize;

                    dwErr = RasGetEntryProperties(
                                      rsc.name.szPhonebookPath,
                                      rsc.name.szEntryName,
                                      &re,
                                      &dwRasEntrySize,
                                      NULL,
                                      &dwIgnore);

                    if (ERROR_SUCCESS == dwErr)
                    {
                        dwErr = ERROR_NOT_SUPPORTED;

                        //
                        // Check if this is a Connection Manager entry
                        //
                        if (RASET_Internet == re.dwType)
                        {
                            //
                            // Prevent the DialerDialog
                            //
                            info.dwFlags |= RASDDFLAG_NoPrompt;
                            
                            hRasDlgDll = LoadLibrary(L"RASDLG.DLL");
                            if (hRasDlgDll)
                            {
                                lpfnRasDialDlgFunc lpfnRasDialDlg = (lpfnRasDialDlgFunc)GetProcAddress(hRasDlgDll, "RasDialDlgW");

                                if (lpfnRasDialDlg)
                                {
                                    fRetVal = (BOOL)(lpfnRasDialDlg)(rsc.name.szPhonebookPath, rsc.name.szEntryName, NULL, &info );
                                    if (fRetVal)
                                    {
                                        dwErr = NO_ERROR;
                                    }
                                }
                                FreeLibrary(hRasDlgDll);
                                hRasDlgDll = NULL;
                            }
                        }
                    }
                }

                m_dwLastConnectionError = dwErr;
                
                if(NO_ERROR != dwErr)
                {
                    hr = E_FAIL;

                    if(NULL != hrasconn)
                    {
                        RasHangUp(hrasconn);
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }

        if(FAILED(hr))
        {
            SetUPnPError(DCP_ERROR_CONNECTIONSETUPFAILED);
        }

    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    
    return hr;
}

HRESULT CWANPPPConnectionService::ForceTermination(void)
{
    HRESULT hr = S_OK;

    hr = ControlEnabled();
    if(SUCCEEDED(hr))
    {
        INetConnection* pNetConnection;
        hr = m_pHomenetConnection->GetINetConnection(&pNetConnection);
        if(SUCCEEDED(hr))
        {
            hr = pNetConnection->Disconnect();
            pNetConnection->Release();
        }
    }
    else
    {
        SetUPnPError(DCP_CUSTOM_ERROR_ACCESSDENIED);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanipconnectionservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "resource.h"       // main symbols
#include "netconp.h"
#include "netcon.h"
#include "CWANConnectionBase.h"

/////////////////////////////////////////////////////////////////////////////
// CInternetGatewayDevice
class ATL_NO_VTABLE CWANIPConnectionService : 
    public CWANConnectionBase
{
public:

    CWANIPConnectionService();

    STDMETHODIMP RequestConnection();
    STDMETHODIMP ForceTermination();
    STDMETHODIMP get_LastConnectionError(BSTR *pLastConnectionError);

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanconnectionbase.h ===
#pragma once

#include "netconp.h"
#include "dispimpl2.h"
#include "upnphost.h"
#include "InternetGatewayDevice.h"
#include "api.h"
#include "hnetcfg.h"

class CWANConnectionBase :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IUPnPEventSource,
    public INetConnectionNotifySink,
    public INATEventsSink,
    public IDelegatingDispImpl<IWANIPConnectionService>
{
public: 

    CWANConnectionBase();

    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
    BEGIN_COM_MAP(CWANConnectionBase)
        COM_INTERFACE_ENTRY(IWANIPConnectionService)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IUPnPEventSource)
        COM_INTERFACE_ENTRY(INetConnectionNotifySink)
    END_COM_MAP()
        
        

    
    HRESULT StopListening();
    HRESULT Initialize(GUID* pGuid, IHNetConnection* pSharedConnection, IStatisticsProvider* pStatisticsProvider);


     // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink *pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink *pesSubscriber);

   // INetConnectionNotifySink
    STDMETHODIMP ConnectionAdded(const NETCON_PROPERTIES_EX* pProps);
    STDMETHODIMP ConnectionBandWidthChange(const GUID* pguidId);
    STDMETHODIMP ConnectionDeleted(const GUID* pguidId);
    STDMETHODIMP ConnectionModified(const NETCON_PROPERTIES_EX* pProps);
    STDMETHODIMP ConnectionRenamed(const GUID* pguidId, LPCWSTR pszwNewName);
    STDMETHODIMP ConnectionStatusChange(const GUID* pguidId, NETCON_STATUS Status);
    STDMETHODIMP ConnectionAddressChange(const GUID* pguidId);
    STDMETHODIMP ShowBalloon(const GUID* pguidId, const BSTR szCookie, const BSTR szBalloonText); 
    STDMETHODIMP RefreshAll();
    STDMETHODIMP DisableEvents(const BOOL fDisable, const ULONG ulDisableTimeout);

    // INATEventsSink
    STDMETHODIMP PublicIPAddressChanged(void);
    STDMETHODIMP PortMappingsChanged(void);

    // IWANPPPConnection and IWANIPConnection
    STDMETHODIMP get_ConnectionType(BSTR *pConnectionType);
    STDMETHODIMP get_PossibleConnectionTypes(BSTR *pPossibleConnectionTypes);
    STDMETHODIMP get_ConnectionStatus(BSTR *pConnectionStatus);
    STDMETHODIMP get_Uptime(ULONG *pUptime);
    STDMETHODIMP get_UpstreamMaxBitRate(ULONG *pUpstreamMaxBitRate);
    STDMETHODIMP get_DownstreamMaxBitRate(ULONG *pDownstreamMaxBitRate);
    STDMETHODIMP get_LastConnectionError(BSTR *pLastConnectionError) = 0;
    STDMETHODIMP get_RSIPAvailable(VARIANT_BOOL *pRSIPAvailable);
    STDMETHODIMP get_NATEnabled(VARIANT_BOOL *pNATEnabled);
    STDMETHODIMP get_X_Name(BSTR* pName);
    STDMETHODIMP get_ExternalIPAddress(BSTR *pExternalIPAddress);
    STDMETHODIMP get_RemoteHost(BSTR *pRemoteHost);
    STDMETHODIMP get_ExternalPort(USHORT *pExternalPort);
    STDMETHODIMP get_InternalPort(USHORT *pInternalPort);
    STDMETHODIMP get_PortMappingProtocol(BSTR *pProtocol);
    STDMETHODIMP get_InternalClient(BSTR *pInternalClient);
    STDMETHODIMP get_PortMappingDescription(BSTR *pDescription);
    STDMETHODIMP get_PortMappingEnabled(VARIANT_BOOL *pEnabled);
    STDMETHODIMP get_PortMappingLeaseDuration(ULONG *LeaseDuration);
    STDMETHODIMP get_PortMappingNumberOfEntries(USHORT *pNumberOfEntries);
    

    STDMETHODIMP SetConnectionType(BSTR NewConnectionType);
    STDMETHODIMP GetConnectionTypeInfo(BSTR* pNewConnectionType, BSTR* pNewPossibleConnectionTypes);
    STDMETHODIMP RequestConnection() = 0;
    STDMETHODIMP ForceTermination() = 0;
    STDMETHODIMP GetStatusInfo(BSTR* pNewConnectionStatus, BSTR* pNewLastConnectionError, ULONG* pNewUptime);
    STDMETHODIMP GetNATRSIPStatus(VARIANT_BOOL* pNewRSIPAvailable, VARIANT_BOOL* pNewNATEnabled);
    STDMETHODIMP GetLinkLayerMaxBitRates(ULONG* pNewUpstreamMaxBitRate, ULONG* pNewDownstreamMaxBitRate);
    STDMETHODIMP GetGenericPortMappingEntry(USHORT uwIndex, BSTR* pRemoteHost, USHORT* puwExternalPort, BSTR* pProtocol, USHORT* puwInternalPort, BSTR* pInternalClient, VARIANT_BOOL* pbEnabled, BSTR* pDescription, ULONG* pulLeaseDuration);
    STDMETHODIMP GetSpecificPortMappingEntry(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT* puwInternalPort, BSTR* pInternalClient, VARIANT_BOOL* pbEnabled, BSTR* pDescription, ULONG* pulLeaseDuration);
    STDMETHODIMP AddPortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT uwInternalPort, BSTR InternalClient, VARIANT_BOOL bEnabled, BSTR Description, ULONG ulLeaseDuration);
    STDMETHODIMP DeletePortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol);
    STDMETHODIMP GetExternalIPAddress(BSTR* pExternalIPAddress);


    HRESULT FinalConstruct();
    HRESULT FinalRelease();
protected:

    HRESULT StartNetmanEvents(INetConnectionNotifySink* pSink);
    HRESULT ControlEnabled(void);
    HRESULT FireEvent(DISPID DispatchId);

    HRESULT AddDynamicPortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT uwInternalPort, BSTR InternalClient, VARIANT_BOOL bEnabled, BSTR Description, ULONG ulLeaseDuration);
    HRESULT AddStaticPortMapping(BSTR RemoteHost, USHORT uwExternalPort, BSTR Protocol, USHORT uwInternalPort, BSTR InternalClient, VARIANT_BOOL bEnabled, BSTR Description, ULONG ulLeaseDuration);

    IHNetConnection* m_pHomenetConnection;  
    GUID m_SharedGuid;
    IUPnPEventSink* m_pEventSink;
 
    //
    // Needed entries for the PortMappings
    //
    IHNetIcsSettings*       m_IcsSettingsp;

private:

    IConnectionPoint* m_pConnectionPoint;
    DWORD m_dwConnectionManagerConnectionPointCookie;
    IStatisticsProvider* m_pStatisticsProvider;
    HRESULT m_hAdviseNATEventsResult;

};

//
// Utility Functions.
//
enum MAPPING_TYPE
{
    ePortMappingInvalid = 0,
    ePortMappingDynamic,
    ePortMappingStatic
};


HRESULT
SearchPortMapping(
                  IN          IHNetIcsSettings*           IcsSettingsp,
                  IN OPTIONAL ULONG                       searchIndex,
                  IN OPTIONAL USHORT                      searchPort,
                  IN OPTIONAL UCHAR                       searchProtocol,
                  OUT         IHNetPortMappingProtocol    **Protocolpp
                 );

HRESULT
FillStaticMappingInformation(
                             IN          IHNetPortMappingProtocol*  MappingProtocolp,
                             IN OPTIONAL IHNetPortMappingBinding*   Bindingp,
                             OUT         PUSHORT                    uExternalPortp,
                             OUT         BSTR*                      Protocolp,
                             OUT         PUSHORT                    uInternalPortp,
                             OUT         BSTR*                      InternalClientp,
                             OUT         VARIANT_BOOL*              bEnabledp,
                             OUT         BSTR*                      Descriptionp
                            );

inline HRESULT
ValidatePortMappingParameters
(
 IN  BSTR          RemoteHost,
 IN  USHORT        uwExternalPort,
 IN  BSTR          Protocol,
 IN  USHORT        uwInternalPort,
 IN  BSTR          InternalClient,
 IN  VARIANT_BOOL  bEnabled,
 IN  BSTR          Description,
 IN  ULONG         ulLeaseDuration,
 OUT MAPPING_TYPE* pMappingType
);



#define RESOLVE_PROTOCOL_TYPE( _X_ , _Y_ ) \
if ( !_wcsicmp( (_Y_), L"TCP") )             \
{                                          \
     (_X_) = NAT_PROTOCOL_TCP;             \
}                                          \
else if ( !_wcsicmp((_Y_), L"UDP") )         \
{                                          \
     (_X_) = NAT_PROTOCOL_UDP;             \
}                                          \
else                                       \
{                                          \
    _ASSERT( FALSE );                      \
                                           \
    hr = E_INVALIDARG;                     \
                                           \
    break;                                 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\cwanpotslinkconfigservice.h ===
#pragma once
#include "InternetGatewayDevice.h"
#include "dispimpl2.h"
#include "resource.h"       // main symbols
#include "upnphost.h"
#include "netconp.h"
#include "netcon.h"
#include "ras.h"


class ATL_NO_VTABLE CWANPOTSLinkConfigService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<IWANPOTSLinkConfigService>,
    public IUPnPEventSource
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWANPOTSLinkConfigService)
    COM_INTERFACE_ENTRY(IWANPOTSLinkConfigService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

    CWANPOTSLinkConfigService();

    HRESULT Initialize(INetConnection* pNetConnection);
    HRESULT FinalRelease(void);
    
    // IUPnPEventSource methods
    STDMETHODIMP Advise(IUPnPEventSink *pesSubscriber);
    STDMETHODIMP Unadvise(IUPnPEventSink *pesSubscriber);

    // IWANPOTSLinkConfigService
    STDMETHODIMP get_ISPPhoneNumber(BSTR* pISPPhoneNumber);    
    STDMETHODIMP get_ISPInfo(BSTR *pISPInfo);
    STDMETHODIMP get_LinkType(BSTR *pLinkType);
    STDMETHODIMP get_NumberOfRetries(ULONG *pNumberOfRetries);
    STDMETHODIMP get_DelayBetweenRetries(ULONG *pDelayBetweenRetries);

    STDMETHODIMP GetISPInfo(BSTR* pISPPhoneNumber, BSTR *pISPInfo, BSTR *pLinkType);
    STDMETHODIMP GetCallRetryInfo(ULONG* pNumberOfRetries, ULONG *pDelayBetweenRetries);

private:
    HRESULT GetRasEntry(RASENTRY** ppRasEntry);
    
    IUPnPEventSink* m_pEventSink;
    INetRasConnection* m_pNetRasConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\debug.cpp ===
#include "pch.h"
#pragma hdrstop


#include <rtutils.h>
#include "tchar.h"

#include "debug.h"
//#include "ipnat.h"



//****************************************************************************
//  Global Parameters
//****************************************************************************
TCHAR g_szDebugKey[] = _T("SOFTWARE\\Microsoft\\Tracing\\Beacon\\Debug");


DEBUG_MODULE_INFO g_DebugInfo[] = {
    {TM_DEFAULT,  TL_CRIT,  _T("<default> "),  _T("DebugLevel")},   //
    {TM_STATIC,   TL_TRACE, _T("STATIC "),     _T("StaticDebugLevel")}, //
    {TM_INFO,     TL_TRACE, _T("INFO "),       _T("InfoDebugLevel")}, //
    {TM_DYNAMIC,  TL_TRACE, _T("DYN "),        _T("DynamicDebugLevel")}, //
    {TB_FILE,     TL_NONE,  _T("FILE "),       _T("LogToFile")}, //
};

WCHAR   g_szModule[]      = SZ_MODULE;

ULONG   g_uTraceId        = INVALID_TRACEID;

BOOLEAN bEnabled          = FALSE;



void 
DestroyDebugger(VOID) 
{
    if ( g_uTraceId != INVALID_TRACEID )
    {
        TraceDeregister(g_uTraceId);
        
        g_uTraceId = INVALID_TRACEID;
    }
}



void 
InitDebugger()
{
    HKEY        hkey;
    DWORD       dwType, cb;
    DWORD       dwLevel;
    int         iModule;         
    int         nModules;         

    
    
    //
    // Open the registry key that contains the debug configuration info
    //
    if (RegOpenKeyEx((HKEY) HKEY_LOCAL_MACHINE,
                     g_szDebugKey,
                     0,
                     KEY_READ,
                     &hkey) == ERROR_SUCCESS) 
    {
        cb = sizeof(dwLevel);

        //
        // Enable Debugging
        bEnabled = TRUE;

        //
        // Initialize all the modules to the base value or their custom value
        //

        nModules = (sizeof(g_DebugInfo)/sizeof(DEBUG_MODULE_INFO));

        for (iModule=0; iModule < nModules; iModule++) 
        {

            //
            // Open each custom debug level if present
            //

            if ((RegQueryValueEx(hkey, 
                                 g_DebugInfo[iModule].szDebugKey,
                                 NULL, 
                                 &dwType, 
                                 (PUCHAR) 
                                 &dwLevel, 
                                 &cb) == ERROR_SUCCESS) && (dwType == REG_DWORD)) 
            {
                g_DebugInfo[iModule].dwLevel = dwLevel; 
            } 
            else 
            {
                g_DebugInfo[iModule].dwLevel = g_DebugInfo[TM_DEFAULT].dwLevel; 
            }
            
            if( (TB_FILE == iModule) &&
                (1 == dwLevel))
            {
                // Init the Trace Manager
                g_uTraceId = TraceRegister(g_szModule);

            }
        }

        RegCloseKey(hkey);
    } 
    else 
    {
        // Debug Key Doesn't exist
    }

    return;
}








//
// use _vsnwprintf instead
//
void  
DbgPrintEx(ULONG Module, ULONG ErrorLevel, LPOLESTR pszMsg, ...)
{
    va_list VaList;
	
    WCHAR msg[BUF_SIZE];
    
    int len = 0;

    if ( (bEnabled is TRUE) &&
        (ErrorLevel  <= g_DebugInfo[Module].dwLevel ))
    {
        len = swprintf(msg, L"%s-", g_szModule);

        wcscat(msg, g_DebugInfo[Module].szModuleName);

        len += wcslen(g_DebugInfo[Module].szModuleName);

        

        _vsnwprintf(&msg[len], 
                    BUF_SIZE,
                    pszMsg, 
                    (va_list)(&pszMsg + 1));

        wcscat(msg, L"\n");


        if ( g_uTraceId is INVALID_TRACEID )
        {
            OutputDebugString(msg);
        }
        else
        {
            TracePrintfExW(g_uTraceId, 
                            TRACE_FLAG_NEUTR,
                            L"%s",
                            msg); 
        }
    }
}

void  
DEBUG_DO_NOTHING(ULONG Module, ULONG ErrorLevel, LPOLESTR pszMsg, ...)
{
}


//
// UTILITY Functions
//



LPOLESTR
AppendAndAllocateWString(
                         LPOLESTR oldString,
                         LPOLESTR newString
                        )
{
    LPOLESTR retString = NULL;

    ULONG retStringSize = 0, oldStringSize = 0, newStringSize = 0;

    if ( oldString != NULL )
    {
        oldStringSize = wcslen( oldString );
    }

    if ( newString != NULL )
    {
        newStringSize = wcslen(newString);
    }

    
    retStringSize = oldStringSize + newStringSize + 1;

    retString = (LPOLESTR) CoTaskMemAlloc( retStringSize * sizeof(OLECHAR) );

    if(retString != NULL)
    {
        ZeroMemory(retString, retStringSize * sizeof(OLECHAR));

        if(oldString) 
        {
            wcscat(retString, oldString);

            CoTaskMemFree(oldString);

            oldString = NULL;
        }

        if(newString)
        { 
            wcscat(retString, oldString);
        }

        return retString;
    }

    return oldString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\resource.h ===
#define IDX_DESC_DOC 100
#define IDR_SAMPLE_DEVICE 100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <wchar.h>

#include "beaconbase.h"
//#include "ncmem.h"
//#include "ncbase.h"
//#include "ncdebug.h"
//#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\statisticsproviders.cpp ===
#include "pch.h"
#pragma hdrstop
#include "StatisticsProviders.h"
#include "ras.h"
#include "rasuip.h"
#include "ndispnp.h"


CLANStatisticsProvider::CLANStatisticsProvider()
{

}

HRESULT CLANStatisticsProvider::Initialize(GUID* pGuid)
{
    HRESULT hr = S_OK;

    lstrcpy(m_pszDeviceString, L"\\Device\\");
    StringFromGUID2(*pGuid, m_pszDeviceString + (sizeof(L"\\Device\\") / sizeof(WCHAR) - 1), 54);
    RtlInitUnicodeString(&m_Device, m_pszDeviceString);

    return hr;
}

HRESULT CLANStatisticsProvider::FinalRelease()
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CLANStatisticsProvider::GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime)
{
    HRESULT hr = S_OK;

    
    NIC_STATISTICS  nsNewLanStats;
    ZeroMemory(&nsNewLanStats, sizeof(nsNewLanStats));
    nsNewLanStats.Size = sizeof(NIC_STATISTICS);
    
    if (NdisQueryStatistics(&m_Device, &nsNewLanStats))
    {
        
        if(NULL != pulBytesSent)
        {
            *pulBytesSent = static_cast<ULONG>(nsNewLanStats.BytesSent);
        }
        if(NULL != pulBytesReceived)
        {
            *pulBytesReceived = static_cast<ULONG>(nsNewLanStats.DirectedBytesReceived);
        }
        if(NULL != pulPacketsSent)
        {
            *pulPacketsSent = static_cast<ULONG>(nsNewLanStats.PacketsSent);
        }
        if(NULL != pulPacketsReceived)
        {
            *pulPacketsReceived = static_cast<ULONG>(nsNewLanStats.DirectedPacketsReceived);
        }
        if(NULL != pulUptime)
        {
            *pulUptime = nsNewLanStats.ConnectTime;
        }
        if(NULL != pulSpeedbps)
        {
            *pulSpeedbps = nsNewLanStats.LinkSpeed * 100;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


CRASStatisticsProvider::CRASStatisticsProvider()
{
    m_pNetRasConnection = NULL;
}

HRESULT CRASStatisticsProvider::Initialize(INetConnection* pNetConnection)
{
    HRESULT hr = S_OK;

    hr = pNetConnection->QueryInterface(IID_INetRasConnection, reinterpret_cast<void**>(&m_pNetRasConnection));
    
    return hr;
}

HRESULT CRASStatisticsProvider::FinalRelease()
{
    HRESULT hr = S_OK;

    if(NULL != m_pNetRasConnection)
    {
        m_pNetRasConnection->Release();
    }

    return hr;
}

HRESULT CRASStatisticsProvider::GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime)
{
    HRESULT hr = S_OK;
    
    HRASCONN hRasConnection;
    hr = m_pNetRasConnection->GetRasConnectionHandle(reinterpret_cast<ULONG_PTR*>(&hRasConnection));
    if(SUCCEEDED(hr))
    {
        RAS_STATS Statistics;
        Statistics.dwSize = sizeof(RAS_STATS);
        if(0 == RasGetConnectionStatistics(hRasConnection, &Statistics))
        {
            if(NULL != pulBytesSent)
            {
                *pulBytesSent = Statistics.dwBytesXmited;
            }
            if(NULL != pulBytesReceived)
            {
                *pulBytesReceived = Statistics.dwBytesRcved;
            }
            if(NULL != pulPacketsSent)
            {
                *pulPacketsSent = Statistics.dwFramesXmited;
            }
            if(NULL != pulPacketsReceived)
            {
                *pulPacketsReceived = Statistics.dwFramesRcved;
            }
            if(NULL != pulUptime)
            {
                *pulUptime = Statistics.dwConnectDuration / 1000;
            }
            if(NULL != pulSpeedbps)
            {
                *pulSpeedbps = Statistics.dwBps;
            }
        }
        else
        {
            hr = E_FAIL;
        }
        // any cleanup here?
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\debug.h ===
//****************************************************************************
//
//  Module:     IPNATHLP.DLL
//  File:       debug.h
//  Content:    This file contains the debug definitions
//
//  Revision History:
//  
//  Date
//  -------- ---------- -------------------------------------------------------
//  03/06/01 savasg   Created
//
//****************************************************************************

#ifndef _BCON_DBG_H_
#define _BCON_DBG_H_
//
// Name of this overall binary
//

#define SZ_MODULE              L"Beacon" 
#define TRACE_FLAG_NEUTR       ((ULONG)0x08000000 | TRACE_USE_MASK)
#define BUF_SIZE               512

#define is ==


//****************************************************************************
//  Typedef's
//****************************************************************************

typedef struct _DEBUG_MODULE_INFO {
    ULONG dwModule;    
    ULONG dwLevel;    
    TCHAR  szModuleName[80];    
    TCHAR  szDebugKey[80];    
} DEBUG_MODULE_INFO, *PDEBUG_MODULE_INFO;


//****************************************************************************
//  Extern
//****************************************************************************



//
// Trace Modules
//

#define TM_DEFAULT      0
#define TM_STATIC       1
#define TM_INFO         2
#define TM_DYNAMIC      3


//
// Boolean value Module
//
#define TB_FILE         4  



//
// Trace Levels
//

#define TL_NONE         0
#define TL_CRIT         1
#define TL_ERROR        2
#define TL_INFO         3
#define TL_TRACE        4
#define TL_DUMP         5


#if DBG   // checked build




#ifndef _DEBUG // DEBUG_CRT is not enabled.

#undef _ASSERT
#undef _ASSERTE


#define _ASSERT(expr)                   \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("UPnP-Nat: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)
    
#define _ASSERTE(expr)                  \
    do                                  \
    {                                   \
        if (!(expr))                    \
        {                               \
            TCHAR buf[BUF_SIZE + 1];    \
            _sntprintf(                 \
                buf,                    \
                BUF_SIZE,               \
                _T("UPnP-Nat: Assertion failed (%s:%i)\n"),  \
                _T(__FILE__),           \
                __LINE__                \
                );                      \
            buf[BUF_SIZE] = _T('\0');   \
            OutputDebugString(buf);     \
            DebugBreak();               \
        }                               \
    } while (0)
#endif // _DEBUG


    
    

#define DBG_SPEW DbgPrintEx

#else // DBG

#define DBG_SPEW DEBUG_DO_NOTHING

#endif // DBG


//************************************************************
//  Prototypes
//************************************************************

//void DbgPrintX(LPCSTR pszMsg, ...);

void DbgPrintEx(
                ULONG Module,
                ULONG ErrorLevel,
                LPOLESTR pszMsg,
                ...
               );

void  
DEBUG_DO_NOTHING(
                 ULONG Module,
                 ULONG ErrorLevel, 
                 LPOLESTR pszMsg,
                 ...
                );


void InitDebugger( void );

void DestroyDebugger( void );


LPOLESTR
AppendAndAllocateWString(
                         LPOLESTR oldString,
                         LPOLESTR newString
                        );




#endif // _BCON_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\dispimpl2.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D I S P I M P L 2 . H 
//
//  Contents:   Implementation of IDispatch without dual interfaces
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

//  -IDelegatingDispImpl for implementing IDispatch by delegation
//   to another interface (typically a custom interface).
//
// These classes are useful because ATL's IDispatchImpl can
// only implement duals.
//
/////////////////////////////////////////////////////////////////////////////
//
// IDelegatingDispImpl: For implementing IDispatch in terms of another
// (typically custom) interface, e.g.:
//
// [oleautomation]
// interface IFoo : IUnknown
// {
//    ...
// }
//
// IDelegatingDispImpl implements all four IDispatch methods.
// IDelegatingDispImpl gets the IDispatch vtbl entries by deriving from
// IDispatch in addition to the implementation interface.
//
// Usage:
//  class CFoo : ..., public IDelegatingDispImpl<IFoo>
//
// In the case where the coclass is intended to represent a control,
// there is a need for the coclass to have a [default] dispinterface.
// Otherwise, some control containers (notably VB) throw arcane error when
// the control is loaded.  For a control that you intend to provide the
// custom interface and delegating dispatch mechanism, you will have to
// provide a dispinterface defined in terms of a custom interface like
// so:
//
// dispinterface DFoo
// {
//    interface IFoo;
// }
//
// coclass Foo
// {
//  [default] interface DFoo;
//  interface IFoo;
// };
//
// For every other situation, declaring a dispinterface in terms of a
// custom interface is not necessary to use IDelegatingDispatchImpl.
// However, if you'd like DFoo to be in the base class list (as needed
// for the caveat control), you may use DFoo as the base class instead
// of the default template argument IDispatch like so:
//
// Usage:
//  class CFoo : ..., public IDelegatingDispImpl<IFoo, &IID_IFoo, DFoo>
//

#pragma once
#ifndef INC_DISPIMPL2
#define INC_DISPIMPL2

/////////////////////////////////////////////////////////////////////////////
// IDelegatingDispImpl

template <class T, const IID* piid = &__uuidof(T), class D = IDispatch,
          const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
          WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDelegatingDispImpl : public T, public D
{
public:
    typedef tihclass _tihclass;

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {
        *pctinfo = 1;
        return S_OK;
    }

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {
        return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
    }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
        LCID lcid, DISPID* rgdispid)
    {
        return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }
    
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
    {
        // NOTE: reinterpret_cast because CComTypeInfoHolder makes the mistaken
        //       assumption that the typeinfo can only Invoke using an IDispatch*.
        //       Since the implementation only passes the itf onto
        //       ITypeInfo::Invoke (which takes a void*), this is a safe cast
        //       until the ATL team fixes CComTypeInfoHolder.
        return _tih.Invoke(reinterpret_cast<IDispatch*>(static_cast<T*>(this)),
                           dispidMember, riid, lcid, wFlags, pdispparams,
                           pvarResult, pexcepinfo, puArgErr);
    }

protected:
    static _tihclass _tih;

    static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
    {
        return _tih.GetTI(lcid, ppInfo);
    }
};

template <class T, const IID* piid, class D, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDelegatingDispImpl<T, piid, D, plibid, wMajor, wMinor, tihclass>::_tihclass
    IDelegatingDispImpl<T, piid, D, plibid, wMajor, wMinor, tihclass>::_tih =
    { piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0 };

#endif  // INC_DISPIMPL2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\statisticsproviders.h ===
#pragma once

#include "InternetGatewayDevice.h"
#include "netconp.h"


class ATL_NO_VTABLE CLANStatisticsProvider : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IStatisticsProvider
{
public:
    CLANStatisticsProvider();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLANStatisticsProvider)
    COM_INTERFACE_ENTRY(IStatisticsProvider)
END_COM_MAP()

public:

    HRESULT Initialize(GUID* pGuid);
    HRESULT FinalRelease(void);

    STDMETHODIMP GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime);

private:

    WCHAR m_pszDeviceString[64];
    UNICODE_STRING m_Device;

};

class ATL_NO_VTABLE CRASStatisticsProvider : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IStatisticsProvider
{
public:
    CRASStatisticsProvider();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLANStatisticsProvider)
    COM_INTERFACE_ENTRY(IStatisticsProvider)
END_COM_MAP()

public:

    HRESULT Initialize(INetConnection* pNetConnection);
    HRESULT FinalRelease(void);

    STDMETHODIMP GetStatistics(ULONG* pulBytesSent, ULONG* pulBytesReceived, ULONG* pulPacketsSent, ULONG* pulPacketsReceived, ULONG* pulSpeedbps, ULONG* pulUptime);

private:

    INetRasConnection* m_pNetRasConnection;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\util.h ===
#pragma once

#define DCP_CUSTOM_ERROR_ACCESSDENIED L"800"
#define DCP_ERROR_CONNECTIONSETUPFAILED L"704"

HRESULT SetUPnPError(LPOLESTR pszError);

VOID SetProxyBlanket(IUnknown *pUnk);

DWORD WINAPI INET_ADDR( LPCWSTR szAddressW );

WCHAR * WINAPI INET_NTOW( ULONG addr );

WCHAR * WINAPI INET_NTOW_TS( ULONG addr );



class CSwitchSecurityContext
{
public:
    CSwitchSecurityContext();

    ~CSwitchSecurityContext()
    {
        CoRevertToSelf();
    };

    static HRESULT ObtainImpersonationToken();
    static DestroyImpersonationToken()
    {
        CloseHandle( m_hImpersonationToken );
        m_hImpersonationToken = NULL;
    };

private:
    
    static HANDLE m_hImpersonationToken;

};



inline BOOL IsAllowedBeaconOSType (void)
//
// Look for the Workstation SKUs;
// WinNT, Win2K, XP - Workstations are allowed (Per/Pro), returns TRUE
// Everything else returns FALSE
//

{   
#ifndef _WIN64  // On IA64, all homenet technologies are unavailable.
    OSVERSIONINFOEXW verInfo    = {0};
    ULONGLONG ConditionMask     = 0;
    
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;
    
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);

    if ( VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask) )
        return TRUE;
#endif
    return FALSE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\beacon\server\util.cpp ===
#pragma once

#include "pch.h"
#pragma hdrstop 
#include "winsock2.h"
#include "util.h"

HRESULT SetUPnPError(LPOLESTR pszError)
{
    HRESULT hr = S_OK;

    ICreateErrorInfo* pCreateErrorInfo;
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if(SUCCEEDED(hr))
    {
        hr = pCreateErrorInfo->SetSource(pszError);
        if(SUCCEEDED(hr))
        {
            
            IErrorInfo* pErrorInfo;
            hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, reinterpret_cast<void**>(&pErrorInfo));
            if(SUCCEEDED(hr))
            {
                hr = SetErrorInfo(0, pErrorInfo);
                pErrorInfo->Release();
            }
        }
        pCreateErrorInfo->Release();
    }

    return hr;
}

VOID SetProxyBlanket(IUnknown *pUnk)
{
    HRESULT hr;

    _ASSERT(pUnk);

    hr = CoSetProxyBlanket(
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE
            );

    if (SUCCEEDED(hr))
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket(
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE
                    );

            pUnkSet->Release();
        }
    }
}


HANDLE CSwitchSecurityContext::m_hImpersonationToken = NULL;

CSwitchSecurityContext::CSwitchSecurityContext( )
{
    HRESULT hr  = S_OK;

    hr = CoImpersonateClient();
    
    if ( SUCCEEDED(hr) )
    {
        if ( FALSE == SetThreadToken( NULL,
                                      m_hImpersonationToken ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;
            
            CoRevertToSelf();
        }
    }

    _ASSERT( SUCCEEDED(hr) );
}


HRESULT
CSwitchSecurityContext::ObtainImpersonationToken ( )
{
    HANDLE  hTokenHandleForDuplicate = NULL;
    HRESULT hr                       = S_OK;
    
    if ( TRUE == OpenProcessToken( GetCurrentProcess(),
                                    TOKEN_DUPLICATE | TOKEN_QUERY,
                                    &hTokenHandleForDuplicate ) )


    {
        if ( FALSE == DuplicateToken( hTokenHandleForDuplicate,
                                      SecurityImpersonation,
                                      &m_hImpersonationToken ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        CloseHandle( hTokenHandleForDuplicate );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}


DWORD WINAPI
INET_ADDR(LPCWSTR     szAddressW) 
//
// The 3 "." testing is for the sole purpose of preventing computer 
// names with digits to be catched appropriately.
// so we strictly assume a valid IP is  number.number.number.number
//
{

    CHAR   szAddressA[16];
    int    iCount = 0;
    LPCWSTR tmp    = szAddressW;

    // Check wether it is a non-shortcut IPs.
    while(tmp = wcschr(tmp, L'.'))
    {   tmp++; iCount++;   }

    if ( iCount < 3)
    { return INADDR_NONE; }


    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}


WCHAR * WINAPI
INET_NTOW( ULONG addr ) 
{
    struct in_addr  dwAddress;
    static WCHAR szAddress[16];

    dwAddress.S_un.S_addr = addr;

    char* pAddr = inet_ntoa(*(struct in_addr *) &dwAddress);

    if (pAddr)
    {
	    // mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);
	    MultiByteToWideChar(CP_ACP, 0, pAddr, -1, szAddress, 16);

	    return szAddress;
	}
	else
		return NULL;
}

WCHAR * WINAPI
INET_NTOW_TS( ULONG addr )
{
    WCHAR* retString = NULL;

    CHAR* asciiString = NULL;

    struct in_addr dwAddress;

    dwAddress.S_un.S_addr = addr;

    retString = (WCHAR*)CoTaskMemAlloc( 16 * sizeof(WCHAR) );

    if ( NULL == retString )
    {
        return NULL;
    }

    //
    // note that inet_nota is thread safe
    // altough it uses static buffer
    //
    asciiString = inet_ntoa( dwAddress);

    if (asciiString != NULL)
    {
        MultiByteToWideChar(CP_ACP, 0, asciiString, -1, retString, 16);

        return retString;
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\inc\bioctl.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgctl.h

Abstract:

    Ethernet MAC bridge.
    IOCTL interface definitions

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Apr  2000 - Original version

--*/

// ===========================================================================
//
// CONSTANTS / TYPES
//
// ===========================================================================

// The bridge's device name when using it from user-mode
#define	BRIDGE_DOS_DEVICE_NAME          "\\\\.\\BRIDGE"

// Opaque handle uniquely identifying an adapter
typedef ULONG_PTR                       BRIDGE_ADAPTER_HANDLE, *PBRIDGE_ADAPTER_HANDLE;

// Length of an Ethernet MAC address
#define ETH_LENGTH_OF_ADDRESS 6

// No reported physical medium (assume 802.3)
#define BRIDGE_NO_MEDIUM                (NDIS_PHYSICAL_MEDIUM)-1

// Types of notifications
typedef enum
{
    BrdgNotifyEnumerateAdapters,
    BrdgNotifyAddAdapter,
    BrdgNotifyRemoveAdapter,
    BrdgNotifyLinkSpeedChange,
    BrdgNotifyMediaStateChange,
    BrdgNotifyAdapterStateChange        // This only occurs when the STA is active
} BRIDGE_NOTIFICATION_TYPE;

//
// Possible states for an adapter. If the STA is not compiled in, adapters are
// always in the Forwarding state.
//
typedef enum _PORT_STATE
{
    Disabled,           // The STA is disabled on this adapter. This happens when the adapter's
                        // media is disconnected.
    Blocking,           // Not learning or relaying
    Listening,          // Transitory
    Learning,           // Learning but not relaying
    Forwarding          // Learning and relaying
} PORT_STATE;

//
// STA types and constants
//

// Time values are exchanged between bridges as 16-bit unsigned values
// in units of 1/256th of a second
typedef USHORT          STA_TIME;

// Path costs are 32-bit unsigned values
typedef ULONG           PATH_COST;

// Port identifiers are 2-byte unsigned values
typedef USHORT          PORT_ID;

// Size of bridge identifiers
#define BRIDGE_ID_LEN   8

#if( BRIDGE_ID_LEN < ETH_LENGTH_OF_ADDRESS )
#error "BRIDGE_ID_LEN must be >= ETH_LENGTH_OF_ADDRESS"
#endif

// ===========================================================================
//
// STRUCTURES
//
// ===========================================================================

//
// Common notification header
//
typedef struct _BRIDGE_NOTIFY_HEADER
{
    //
    // If NotifyType == BrdgNotifyRemoveAdapter, there is no further data.
    //
    // If NotifyType != BrdgNotifyRemoveAdapter, the header is followed by
    // a BRIDGE_ADAPTER_INFO structure.
    //
    BRIDGE_NOTIFICATION_TYPE            NotifyType;
    BRIDGE_ADAPTER_HANDLE               Handle;

} BRIDGE_NOTIFY_HEADER, *PBRIDGE_NOTIFY_HEADER;

//
// Data provided with adapter notifications
//
typedef struct _BRIDGE_ADAPTER_INFO
{
    // These fields can be the subject of a specific change notification
    ULONG                               LinkSpeed;
    NDIS_MEDIA_STATE                    MediaState;
    PORT_STATE                          State;

    // These fields are never the subject of a change notification
    UCHAR                               MACAddress[ETH_LENGTH_OF_ADDRESS];
    NDIS_PHYSICAL_MEDIUM                PhysicalMedium;

} BRIDGE_ADAPTER_INFO, *PBRIDGE_ADAPTER_INFO;

//
// Data provided in response to 
//
typedef struct _BRIDGE_STA_ADAPTER_INFO
{

    PORT_ID                             ID;
    ULONG                               PathCost;
    UCHAR                               DesignatedRootID[BRIDGE_ID_LEN];
    PATH_COST                           DesignatedCost;
    UCHAR                               DesignatedBridgeID[BRIDGE_ID_LEN];
    PORT_ID                             DesignatedPort;

} BRIDGE_STA_ADAPTER_INFO, *PBRIDGE_STA_ADAPTER_INFO;

//
// Data provided with BrdgNotifySTAGlobalInfoChange
//
typedef struct _BRIDGE_STA_GLOBAL_INFO
{
    UCHAR                               OurID[BRIDGE_ID_LEN];
    UCHAR                               DesignatedRootID[BRIDGE_ID_LEN];
    PATH_COST                           RootCost;
    BRIDGE_ADAPTER_HANDLE               RootAdapter;
    BOOLEAN                             bTopologyChangeDetected;
    BOOLEAN                             bTopologyChange;
    STA_TIME                            MaxAge;
    STA_TIME                            HelloTime;
    STA_TIME                            ForwardDelay;

} BRIDGE_STA_GLOBAL_INFO, *PBRIDGE_STA_GLOBAL_INFO;

//
// This structure is used to report statistics relating to the bridge's packet handling.
//
typedef struct _BRIDGE_PACKET_STATISTICS
{
    // Local-source frames
    LARGE_INTEGER                       TransmittedFrames;

    // Local-source frames whose transmission failed because of errors
    LARGE_INTEGER                       TransmittedErrorFrames;

    // Local-source bytes
    LARGE_INTEGER                       TransmittedBytes;

    // Breakdown of transmitted frames
    LARGE_INTEGER                       DirectedTransmittedFrames;
    LARGE_INTEGER                       MulticastTransmittedFrames;
    LARGE_INTEGER                       BroadcastTransmittedFrames;

    // Breakdown of transmitted bytes
    LARGE_INTEGER                       DirectedTransmittedBytes;
    LARGE_INTEGER                       MulticastTransmittedBytes;
    LARGE_INTEGER                       BroadcastTransmittedBytes;

    // Frames indicated to the local machine
    LARGE_INTEGER                       IndicatedFrames;

    // Frames that should have been indicated to the local machine but
    // were not due to errors
    LARGE_INTEGER                       IndicatedDroppedFrames;

    // Bytes indicated to the local machine
    LARGE_INTEGER                       IndicatedBytes;

    // Breakdown of indicated frames
    LARGE_INTEGER                       DirectedIndicatedFrames;
    LARGE_INTEGER                       MulticastIndicatedFrames;
    LARGE_INTEGER                       BroadcastIndicatedFrames;

    // Breakdown of indicated bytes
    LARGE_INTEGER                       DirectedIndicatedBytes;
    LARGE_INTEGER                       MulticastIndicatedBytes;
    LARGE_INTEGER                       BroadcastIndicatedBytes;

    // Total received frames / bytes, including frames not indicated
    LARGE_INTEGER                       ReceivedFrames;
    LARGE_INTEGER                       ReceivedBytes;

    // Breakdown of how many frames were received with/without copying 
    LARGE_INTEGER                       ReceivedCopyFrames ;
    LARGE_INTEGER                       ReceivedCopyBytes;

    LARGE_INTEGER                       ReceivedNoCopyFrames;
    LARGE_INTEGER                       ReceivedNoCopyBytes;

} BRIDGE_PACKET_STATISTICS, *PBRIDGE_PACKET_STATISTICS;

//
// This structure is used to report the packet-handling statistics for a particular
// adapter
//
typedef struct _BRIDGE_ADAPTER_PACKET_STATISTICS
{
   
    // These include all sent packets (including relay)
    LARGE_INTEGER                       SentFrames;
    LARGE_INTEGER                       SentBytes;

    // These include only packets sent by the local machine
    LARGE_INTEGER                       SentLocalFrames;
    LARGE_INTEGER                       SentLocalBytes;

    // These include all received packets (including relay)
    LARGE_INTEGER                       ReceivedFrames;
    LARGE_INTEGER                       ReceivedBytes;
    
} BRIDGE_ADAPTER_PACKET_STATISTICS, *PBRIDGE_ADAPTER_PACKET_STATISTICS;

//
// This structure is used to report statistics relating the bridge's internal
// buffer management
//
typedef struct _BRIDGE_BUFFER_STATISTICS
{
    // Packets of each type currently used
    ULONG                               UsedCopyPackets;
    ULONG                               UsedWrapperPackets;

    // Size of each pool
    ULONG                               MaxCopyPackets;
    ULONG                               MaxWrapperPackets;

    // Size of the safety buffer for each pool
    ULONG                               SafetyCopyPackets;
    ULONG                               SafetyWrapperPackets;

    // Number of times alloc requests from each pool have been denied because the
    // pool was completely full
    LARGE_INTEGER                       CopyPoolOverflows;
    LARGE_INTEGER                       WrapperPoolOverflows;

    // Number of times memory allocations have failed unexpectedly (presumably
    // because of low system resources)
    LARGE_INTEGER                       AllocFailures;

} BRIDGE_BUFFER_STATISTICS, *PBRIDGE_BUFFER_STATISTICS;

// ===========================================================================
//
// IOCTLS
//
// ===========================================================================

//
// This IOCTL will pend until the bridge has a notification to send up to the caller.
//
// Associated structures: BRIDGE_NOTIFY_HEADER and BRIDGE_ADAPTER_INFO
//
// The buffer provided with IOCTLs of this type must be at least sizeof(BRIDGE_NOTIFY_HEADER) +
// sizeof(BRIDGE_ADAPTER_INFO) large, in order to accomodate notifications that include adapter
// information
//
#define	BRIDGE_IOCTL_REQUEST_NOTIFY             CTL_CODE(FILE_DEVICE_NETWORK, 0x800, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL causes the bridge driver to send a new notification for every bound adapter, with
// BrdgNotifyEnumerateAdapters as the notification type.
//
#define	BRIDGE_IOCTL_GET_ADAPTERS               CTL_CODE(FILE_DEVICE_NETWORK, 0x801, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// These codes retrieve the device name / friendly name for a bound adapter. Input buffer must be the adapter handle.
//
// As many bytes as possible of the name are read into the supplied buffer. If the buffer is not large enough,
// the number of necessary bytes is returned as the number of written bytes.
//
#define	BRIDGE_IOCTL_GET_ADAPT_DEVICE_NAME      CTL_CODE(FILE_DEVICE_NETWORK, 0x802, METHOD_BUFFERED, FILE_READ_ACCESS)
#define	BRIDGE_IOCTL_GET_ADAPT_FRIENDLY_NAME    CTL_CODE(FILE_DEVICE_NETWORK, 0x803, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This code retrieves the MAC address of the bridge component (which is different from the MAC address
// of any particular adapter).
//
// The associated buffer must be at least ETH_LENGTH_OF_ADDRESS bytes long
//
#define	BRIDGE_IOCTL_GET_MAC_ADDRESS            CTL_CODE(FILE_DEVICE_NETWORK, 0x804, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This code retrieves packet statistics from the bridge
//
// Associated structure: BRIDGE_PACKET_STATISTICS
//
#define	BRIDGE_IOCTL_GET_PACKET_STATS           CTL_CODE(FILE_DEVICE_NETWORK, 0x805, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This code retrieves packet statistics for a particular adapter
//
// Associated structure: BRIDGE_ADAPTER_PACKET_STATISTICS
//
#define	BRIDGE_IOCTL_GET_ADAPTER_PACKET_STATS   CTL_CODE(FILE_DEVICE_NETWORK, 0x806, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This code retrieves buffer management statistics from the bridge
//
// Associated structure: BRIDGE_BUFFER_STATISTICS
//
#define	BRIDGE_IOCTL_GET_BUFFER_STATS           CTL_CODE(FILE_DEVICE_NETWORK, 0x807, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This code retrieves all forwarding table entries associated with the adapter whose handle
// is given in the input buffer
//
// Data is output as an array of MAC addresses, each ETH_LENGTH_OF_ADDRESS bytes long.
// If the provided buffer is too small to handle all entries, as many as possible are copied, the result
// status is STATUS_BUFFER_OVERFLOW (a warning value) and the count of written bytes is actually the
// required number of bytes to hold all table entries
//
#define	BRIDGE_IOCTL_GET_TABLE_ENTRIES          CTL_CODE(FILE_DEVICE_NETWORK, 0x80a, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// STA IOCTLs
//

//
// This code queries for the STA information for a particular adapter
//
// Input is an adapter handle. Output is the BRIDGE_STA_ADAPTER_INFO structure.
//
#define	BRIDGE_IOCTL_GET_ADAPTER_STA_INFO       CTL_CODE(FILE_DEVICE_NETWORK, 0x80b, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This code queries for global STA information
//
// No data is input. Output is the BRIDGE_STA_GLOBAL_INFO structure.
//
#define	BRIDGE_IOCTL_GET_GLOBAL_STA_INFO        CTL_CODE(FILE_DEVICE_NETWORK, 0x80c, METHOD_BUFFERED, FILE_READ_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\exe\bridge.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bridge.c

Abstract:

    Ethernet MAC level bridge.

    SAMPLE program illustrating how to interface with the bridge
    driver via IOCTLs

Author:

    Mark Aiken

Environment:

    User mode

Revision History:

    Apr  2000 - Original version

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <process.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include "bioctl.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

HANDLE              gThreadQuitEvent = NULL;
HANDLE              gBridgeDeviceWrite = NULL;
HANDLE              gBridgeDeviceRead = NULL;

// ===========================================================================
//
// FUNCTIONS
//
// ===========================================================================

VOID
PrintError(
    IN DWORD            Error
    )
/*++

Routine Description:

    Prints a description of a system error

Arguments:

    Error               The error code

--*/

{
    TCHAR               msg[200];

    printf( "(%08x): ", Error );

    if( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, Error, 0, msg, sizeof(msg), NULL ) > 0 )
    {
        printf( "%s", msg );
    }
}

VOID
PrintNotification(
    IN PBRIDGE_NOTIFY_HEADER        pNotify,
    IN DWORD                        DataBytes
    )
/*++

Routine Description:

    Prints a notification from the bridge driver

Arguments:

    pNotify                         The notification block
    DataBytes                       Total size of the notification block

--*/
{
    BOOLEAN                 bPrintAdapterInfo = TRUE;

    printf( "\n\nNotification on Adapter %p: ", pNotify->Handle );

    switch( pNotify->NotifyType )
    {
    case BrdgNotifyEnumerateAdapters:
        printf( "Enumeration was requested\n" );
        break;

    case BrdgNotifyAddAdapter:
        printf( "Adapter was added\n" );
        break;

    case BrdgNotifyRemoveAdapter:
        printf( "Adapter was removed\n" );
        bPrintAdapterInfo = FALSE;
        break;

    case BrdgNotifyLinkSpeedChange:
        printf( "Link speed changed\n" );
        break;

    case BrdgNotifyMediaStateChange:
        printf( "Media state changed\n" );
        break;

    case BrdgNotifyAdapterStateChange:
        printf( "Forwarding state changed\n" );
        break;

    default:
        printf( "UNKNOWN NOTIFICATION\n" );
        bPrintAdapterInfo = FALSE;
        break;
    }

    if( bPrintAdapterInfo )
    {
        PBRIDGE_ADAPTER_INFO    pInfo = (PBRIDGE_ADAPTER_INFO)((PUCHAR)pNotify + sizeof(BRIDGE_NOTIFY_HEADER));
        printf("Adapter information:\n\n");
        printf("Link Speed:       %iMbps\n", pInfo->LinkSpeed / 10000);
        printf("Media State:      %s\n", pInfo->MediaState == NdisMediaStateConnected ? "CONNECTED" : "DISCONNECTED" );
        printf("Physical Medium:  %08x\n", pInfo->PhysicalMedium);

        printf("Forwarding state: ");

        switch( pInfo->State )
        {
        case Disabled:
            printf("** DISABLED **\n");
            break;

        case Blocking:
            printf("BLOCKING\n");
            break;

        case Listening:
            printf("Listening\n");
            break;

        case Learning:
            printf("Learning\n");
            break;

        case Forwarding:
            printf("Forwarding\n");
            break; 
        }

        printf("MAC Address:      %02x-%02x-%02x-%02x-%02x-%02x\n", pInfo->MACAddress[0], pInfo->MACAddress[1],
                pInfo->MACAddress[2], pInfo->MACAddress[3], pInfo->MACAddress[4], pInfo->MACAddress[5]);
    }
}

VOID __cdecl
NotificationThread(
    PVOID               pv
    )
/*++

Routine Description:

    Notification-listening thread

    Pends an IOCTL call and waits for notifications from the bridge driver

--*/
{
    BOOLEAN             bQuit = FALSE;
    HANDLE              Handles[2];
    DWORD               WaitResult, WrittenBytes;
    UCHAR               OutBuffer[sizeof(BRIDGE_NOTIFY_HEADER) + 1514];
    OVERLAPPED          Overlap;

    Handles[0] = gThreadQuitEvent;

    // Create an event to sleep against for the request
    Handles[1] = CreateEvent( NULL, FALSE/*auto-reset*/, FALSE/*Start unsignalled*/, NULL );

    if( Handles[1] == NULL )
    {
        printf( "Couldn't create an event: " );
        PrintError( GetLastError() );
        _endthread();
    }

    Overlap.Offset = Overlap.OffsetHigh = 0L;
    Overlap.hEvent = Handles[1];

    while( ! bQuit )
    {
        // Ask for a notification
        if( ! DeviceIoControl( gBridgeDeviceWrite, BRIDGE_IOCTL_REQUEST_NOTIFY, NULL, 0L, OutBuffer,
                               sizeof(OutBuffer), &WrittenBytes, &Overlap ) )
        {
            DWORD       Error = GetLastError();

            if( Error != ERROR_IO_PENDING )
            {
                printf( "DeviceIoControl returned an error: " );
                PrintError( Error );
                _endthread();
            }
        }
         
        // Wait against the completion event and the kill event
        WaitResult = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );

        if( WaitResult == WAIT_OBJECT_0 )
        {
            // The quit event was signaled
            bQuit = TRUE;
        }
        else if( WaitResult != WAIT_OBJECT_0 + 1 )
        {
            printf( "Error waiting: " );
            PrintError( GetLastError() );
            _endthread();
        }
        else
        {
            // The completion event was signaled.

            // Try to retrieve the number of bytes read
            if( !GetOverlappedResult(gBridgeDeviceWrite, &Overlap, &WrittenBytes, FALSE) )
            {
                printf( "Couldn't get the device call result: " );
                PrintError( GetLastError() );
                _endthread();
            }

            PrintNotification( (PBRIDGE_NOTIFY_HEADER)OutBuffer, WrittenBytes );
        }
    }

    printf("Notification thread exiting.\n");

    _endthread();
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName,
    DWORD   DesiredAccess
)
/*++

Routine Description:

    Opens a device

Arguments:

    pDeviceName                 The device's name

Return Value:

    A handle to the opened device or INVALID_HANDLE_VALUE on failure;

--*/
{
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle = NULL;

	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);

	return (Handle);
}

BOOL
DoBlockingRequest(
    IN DWORD            IOCTL,
    IN PVOID            inBuff,
    IN DWORD            inSize,
    IN PVOID            outBuff,
    IN DWORD            outSize,
    OUT OPTIONAL PDWORD pWrittenBytes
    )
/*++

Routine Description:

    Makes an IOCTL call to a driver and blocks until the request completes

Arguments:

    IOCTL               The IOCTL code
    inBuff              The input data buffer
    inSize              The size of the input buffer
    outBuff             The output buffer
    outSize             The size of the output buffer
    pWrittenBytes       (optional) returns the number of bytes written to outBuff

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    DWORD               WrittenBytes;
    OVERLAPPED          Overlap;

    if( pWrittenBytes == NULL )
    {
        pWrittenBytes = &WrittenBytes;
    }

    // Create an event to sleep against for the request
    Overlap.hEvent = CreateEvent( NULL, FALSE/*auto-reset*/, FALSE/*Start unsignalled*/, NULL );

    if( Overlap.hEvent == NULL )
    {
        printf( "Couldn't create an event: " );
        PrintError( GetLastError() );
        return FALSE;
    }

    Overlap.Offset = Overlap.OffsetHigh = 0L;

    // Make the request
    if( ! DeviceIoControl( gBridgeDeviceRead, IOCTL, inBuff, inSize, outBuff,
                           outSize,pWrittenBytes, &Overlap ) )
    {
        DWORD       Error = GetLastError();

        if( Error != ERROR_IO_PENDING )
        {
            return FALSE;
        }
    }

    // Wait for the result
    if( !GetOverlappedResult(gBridgeDeviceRead, &Overlap,pWrittenBytes, TRUE) )
    {
        return FALSE;
    }

    return TRUE;
}

PVOID
GetVariableData(
    IN ULONG        IOCTL,
    IN PVOID        inBuff,
    IN ULONG        inBuffSize,
    OUT PULONG      pNumBytes,
    IN ULONG        safetyBuffer
    )
/*++

Routine Description:

    Makes an IOCTL call that returns variable-sized data (for which two calls must
    be made, one to determine the size of the data and the other to retrieve it)

Arguments:

    IOCTL               The IOCTL code
    inBuff              The input data buffer
    inBuffSize          The size of the input buffer
    pNumBytes           The size of the allocated buffer holding the result

    safetyBuffer        A count of bytes to allocate beyond the claimed size of
                        the data (a safeguard against dynamically changing data)

Return Value:

    A freshly allocated buffer, *pNumBytes large, with the return data
    NULL on failure

--*/
{
    // First make a request to discover the number of necessary bytes
    if( ! DoBlockingRequest( IOCTL, inBuff, inBuffSize, NULL, 0L, pNumBytes ) )
    {
        DWORD       Error = GetLastError();

        // Expect the error to be ERROR_MORE_DATA since we didn't provide an output buffer!
        if( Error == ERROR_MORE_DATA )
        {
            if( *pNumBytes > 0L )
            {
                // Allocate safetyBuffer extra bytes in case the data is dynamic
                PUCHAR      pData = (PUCHAR)HeapAlloc(GetProcessHeap(), 0, *pNumBytes + safetyBuffer);
                ULONG       i;

                if( pData == NULL )
                {
                    printf( "Failed to allocate %i bytes of memory: ", *pNumBytes + safetyBuffer );
                    PrintError( GetLastError() );
                    return NULL;
                }

                // Make the request again to actually retrieve the addresses
                if( ! DoBlockingRequest( IOCTL, inBuff, inBuffSize, pData, *pNumBytes + safetyBuffer, pNumBytes ) )
                {
                    HeapFree( GetProcessHeap(), 0, pData );
                    printf( "Failed to read variable-length data: " );
                    PrintError( GetLastError() );
                    return NULL;
                }

                // Success. Hand back the data buffer.
                return pData;
            }
            else
            {
                printf( "Driver returned zero bytes: " );
                PrintError( GetLastError() );
                return NULL;
            }
        }
        else
        {
            printf( "Failed to get the number of necessary bytes: " );
            PrintError( GetLastError() );
            return NULL;
        }
    }

    return NULL;
}

_inline VOID
PrintByteString(
    IN PUCHAR                       pData,
    IN UINT                         numChars
    )
{
    UINT        i;

    for( i = 0; i < numChars; i++ )
    {
        printf( "%02x", pData[i] );

        if( i != numChars - 1 )
        {
            printf( "-" );
        }
    }

    printf( "\n" );
}

VOID
PrintAdapterSTAInfo(
    IN BRIDGE_ADAPTER_HANDLE        Handle
    )
{
    BRIDGE_STA_ADAPTER_INFO         info;

    if(! DoBlockingRequest(BRIDGE_IOCTL_GET_ADAPTER_STA_INFO, &Handle, sizeof(Handle), &info, sizeof(info), NULL) )
    {
        printf( "Couldn't request STA information for adapter %p : ", Handle );
        PrintError( GetLastError() );
    }
    else
    {
        printf( "\nSTA Information for adapter %p:\n\n", Handle );
        printf( "Port unique ID       : %i\n", info.ID );
        printf( "Path Cost            : %i\n", info.PathCost );
        printf( "Designated Root      : " );
        PrintByteString( info.DesignatedRootID, BRIDGE_ID_LEN );
        printf( "Designated Cost      : %i\n", info.DesignatedCost );
        printf( "Designated Bridge    : " );
        PrintByteString( info.DesignatedBridgeID, BRIDGE_ID_LEN );
        printf( "Designated Port      : %i\n\n", info.DesignatedPort );
    }
}

VOID
PrintSTAInfo(
    )
{
    BRIDGE_STA_GLOBAL_INFO          info;

    if(! DoBlockingRequest(BRIDGE_IOCTL_GET_GLOBAL_STA_INFO, NULL, 0L, &info, sizeof(info), NULL) )
    {
        printf( "Couldn't request global STA information : " );
        PrintError( GetLastError() );
    }
    else
    {
        printf( "This bridge's ID        : " );
        PrintByteString( info.OurID, BRIDGE_ID_LEN );

        printf( "Designated Root         : " );
        PrintByteString( info.DesignatedRootID, BRIDGE_ID_LEN );

        printf( "Cost to root            : %i\n", info.RootCost );
        printf( "Root adapter            : %p\n", info.RootAdapter );
        printf( "MaxAge                  : %i\n", info.MaxAge );
        printf( "HelloTime               : %i\n", info.HelloTime );
        printf( "ForwardDelay            : %i\n", info.ForwardDelay );

        printf( "TopologyChangeDetected  : " );
        
        if( info.bTopologyChangeDetected )
        {
            printf( "TRUE\n" );
        }
        else
        {
            printf( "FALSE\n" );
        }

        printf( "TopologyChange          : " );
        
        if( info.bTopologyChange )
        {
            printf( "TRUE\n\n" );
        }
        else
        {
            printf( "FALSE\n\n" );
        }
    }
}


VOID
PrintTableEntries(
    IN BRIDGE_ADAPTER_HANDLE        Handle
    )
/*++

Routine Description:

    Retrieves and prints the MAC table entries for a particular adapter

Arguments:

    Handle                          The adapter

--*/
{
    PUCHAR          pAddresses;
    ULONG           i, numBytes;

    pAddresses = GetVariableData( BRIDGE_IOCTL_GET_TABLE_ENTRIES, &Handle, sizeof(Handle), &numBytes, 60L );

    if( pAddresses == NULL )
    {
        printf( "Failed to read table entries: " );
        PrintError( GetLastError() );
        return;
    }

    printf( "Forwarding table entries for adapter %x: \n", Handle );

    for( i = 0L; i < numBytes / ETH_LENGTH_OF_ADDRESS; i++ )
    {
        PrintByteString( pAddresses, ETH_LENGTH_OF_ADDRESS );
        pAddresses += ETH_LENGTH_OF_ADDRESS;
    }

    HeapFree( GetProcessHeap(), 0, pAddresses );
}

VOID
PrintPacketStats(
    IN PBRIDGE_PACKET_STATISTICS    pStats
    )
/*++

Routine Description:

    Prints a BRIDGE_PACKET_STATISTICS structure in a friendly way

Arguments:

    pStats                          The structure

--*/
{
    printf("Bridge packet statistics:\n\n");

    printf("Transmitted Frames:            %16I64u\n", pStats->TransmittedFrames);
    printf("Transmitted Frames w/Errors:   %16I64u\n", pStats->TransmittedErrorFrames);
    printf("Transmitted Directed Frames:   %16I64u\n", pStats->DirectedTransmittedFrames);
    printf("Transmitted Multicast Frames:  %16I64u\n", pStats->MulticastTransmittedFrames);
    printf("Transmitted Broadcast Frames:  %16I64u\n\n", pStats->BroadcastTransmittedFrames);

    printf("Transmitted Bytes:             %16I64u\n", pStats->TransmittedBytes);
    printf("Transmitted Directed Bytes     %16I64u\n", pStats->DirectedTransmittedBytes);
    printf("Transmitted Multicast Bytes:   %16I64u\n", pStats->MulticastTransmittedBytes);
    printf("Transmitted Broadcast Bytes:   %16I64u\n\n", pStats->BroadcastTransmittedBytes);

    printf("Indicated Frames:              %16I64u\n", pStats->IndicatedFrames);
    printf("Indicated Frames w/Errors:     %16I64u\n\n", pStats->IndicatedDroppedFrames);
    printf("Indicated Directed Frames:     %16I64u\n", pStats->DirectedIndicatedFrames);
    printf("Indicated Multicast Frames:    %16I64u\n", pStats->MulticastIndicatedFrames);
    printf("Indicated Broadcast Frames:    %16I64u\n\n", pStats->BroadcastIndicatedFrames);

    printf("Indicated Bytes:               %16I64u\n", pStats->IndicatedBytes);
    printf("Indicated Directed Bytes:      %16I64u\n", pStats->DirectedIndicatedBytes);
    printf("Indicated Multicast Bytes:     %16I64u\n", pStats->MulticastIndicatedBytes);
    printf("Indicated Broadcast Bytes:     %16I64u\n\n", pStats->BroadcastIndicatedBytes);

    printf("Received Frames (incl. relay): %16I64u\n", pStats->ReceivedFrames);
    printf("Received Bytes (incl. relay):  %16I64u\n", pStats->ReceivedBytes);
    printf("Received Frames w/Copy:        %16I64u\n", pStats->ReceivedCopyFrames);
    printf("Received Bytes w/Copy:         %16I64u\n", pStats->ReceivedCopyBytes);
    printf("Received Frames w/No Copy:     %16I64u\n", pStats->ReceivedNoCopyFrames);
    printf("Received Bytes w/No Copy:      %16I64u\n", pStats->ReceivedNoCopyBytes);
}

VOID
PrintAdapterPacketStats(
    IN PBRIDGE_ADAPTER_PACKET_STATISTICS    pStats
    )
/*++

Routine Description:

    Prints a BRIDGE_ADAPTER_PACKET_STATISTICS structure in a friendly way

Arguments:

    pStats                          The structure

--*/
{
    PUCHAR              pc = (PUCHAR)pStats;

    printf("Bridge per-adapter packet statistics:\n\n");
    printf("Transmitted Frames:              %16I64u\n", pStats->SentFrames);
    printf("Transmitted Bytes:               %16I64u\n", pStats->SentBytes);
    printf("Transmitted Local-Source Frames: %16I64u\n", pStats->SentLocalFrames);
    printf("Transmitted Local-Source Bytes:  %16I64u\n", pStats->SentLocalBytes);
    printf("Received Frames:                 %16I64u\n", pStats->ReceivedFrames);
    printf("Received Bytes:                  %16I64u\n\n", pStats->ReceivedBytes);
}

VOID
PrintBufferStats(
    IN PBRIDGE_BUFFER_STATISTICS    pStats
    )
/*++

Routine Description:

    Prints a BRIDGE_BUFFER_STATISTICS structure in a friendly way

Arguments:

    pStats                          The structure

--*/
{
    printf("Bridge buffer statistics:\n\n");

    printf("Copy Packets In Use:              %4lu\n", pStats->UsedCopyPackets);
    printf("Total Copy Packets Available:     %4lu\n", pStats->MaxCopyPackets);
    printf("Safety Copy Packets:              %4lu\n", pStats->SafetyCopyPackets);
    printf("Copy Pool Overflows:        %10I64u\n\n", pStats->CopyPoolOverflows);

    printf("Wrapper Packets In Use:           %4lu\n", pStats->UsedWrapperPackets);
    printf("Total Wrapper Packets Available:  %4lu\n", pStats->MaxWrapperPackets);
    printf("Safety Wrapper Packets:           %4lu\n", pStats->SafetyWrapperPackets);
    printf("Wrapper Pool Overflows:     %10I64u\n\n", pStats->WrapperPoolOverflows);

    printf("Surprise Alloc Failures:    %10I64u\n", pStats->AllocFailures);
}

BOOLEAN
ReadUlongArg(
    IN PUCHAR                       inbuf,
    OUT PULONG                      arg
    )
/*++

Routine Description:

    Reads an unsigned decimal value from a string and returns it
    The value must occur as the second word of the string

Arguments:

    inbuf                           The input string

    arg                             The resulting number

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    UCHAR               scratch[100];

    if( sscanf(inbuf, "%s %lu", scratch, arg) < 2 )
    {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ReadHexPtrArg(
    IN PUCHAR                       inbuf,
    OUT PULONG_PTR                  arg
    )
/*++

Routine Description:

    Reads an unsigned hexidecimal value from a string and returns it
    The value must occur as the second word of the string

Arguments:

    inbuf                           The input string

    arg                             The resulting number

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    UCHAR               scratch[100];
    INT                 read;

    if( sizeof(*arg) <= sizeof(ULONG) )
    {
        read = sscanf(inbuf, "%s %lx", scratch, arg);
    }
    else
    {
        read = sscanf(inbuf, "%s %I64x", scratch, arg);
    }

    if( (read != EOF) && (read < 2) )
    {
        return FALSE;
    }

    return TRUE;
}


VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{
    CHAR        inbuf[100], command[100];
    BOOLEAN     bQuit = FALSE;

    printf("\nSAMPLE MAC Bridge control program\n");

    // Open the bridge device for Read Access
    gBridgeDeviceRead = OpenDevice( BRIDGE_DOS_DEVICE_NAME , GENERIC_READ);

    if( gBridgeDeviceRead == INVALID_HANDLE_VALUE )
    {
        printf( "Couldn't open bridge device: " );
        PrintError( GetLastError() );
        return;
    }

    // Open the bridge device for Write Access
    gBridgeDeviceWrite = OpenDevice( BRIDGE_DOS_DEVICE_NAME , GENERIC_WRITE);
    
    if( gBridgeDeviceWrite == INVALID_HANDLE_VALUE )
    {
        printf( "Couldn't open bridge device: " );
        PrintError( GetLastError() );
        return;
    }

    // Create the thread-quit notification event
    gThreadQuitEvent = CreateEvent( NULL, FALSE/*auto-reset*/, FALSE/*Start unsignalled*/, NULL );

    if( gThreadQuitEvent == NULL )
    {
        printf( "Couldn't create an event: " );
        PrintError( GetLastError() );
        return;
    }

    // Spin up a thread to handle notifications
    _beginthread( NotificationThread, 0, NULL );

    while( ! bQuit )
    {
        PCHAR           pSpace;

        printf( "> " );

        // Get a line of input
        gets( inbuf );

        // Find the first word delimiter
        pSpace = strchr( inbuf, ' ' );

        // Copy over the first word
        if( pSpace != NULL )
        {
            strncpy( command, inbuf, pSpace - inbuf );
            command[pSpace-inbuf] = '\0';
        }
        else
        {
            strcpy( command, inbuf );
        }

        if( _stricmp(command, "enum")  == 0 )
        {
            if(! DoBlockingRequest(BRIDGE_IOCTL_GET_ADAPTERS, NULL, 0L, NULL, 0L, NULL) )
            {
                printf( "Couldn't request an adapter re-enumeration : " );
                PrintError( GetLastError() );
            }
            else
            {
                printf("Requested an adapter re-enumeration.\n" );
            }
        }
        else if( (_stricmp(command, "devicename")  == 0) ||
                 (_stricmp(command, "friendlyname")  == 0) )
        {
            ULONG                   IOCTL = (_stricmp(command, "devicename")  == 0) ? BRIDGE_IOCTL_GET_ADAPT_DEVICE_NAME :
                                            BRIDGE_IOCTL_GET_ADAPT_FRIENDLY_NAME;

            BRIDGE_ADAPTER_HANDLE   Handle;
            PWCHAR                  pName;
            ULONG                   numBytes;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                printf("Must supply an adapter handle for this command.\n");
            }
            else
            {
                pName = (PWCHAR)GetVariableData( IOCTL, &Handle, sizeof(Handle), &numBytes, 0L );

                if( pName == NULL )
                {
                    printf("Couldn't get name for adapter %p: ", Handle);
                    PrintError( GetLastError() );
                }
                else
                {
                    printf("The name is: %S\n", pName);
                }

                HeapFree( GetProcessHeap(), 0, pName );
            }
        }
        else if( _stricmp(command, "table")  == 0 )
        {
            BRIDGE_ADAPTER_HANDLE       Handle;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                printf("Must supply an adapter handle for this command.\n");
            }
            else
            {
                PrintTableEntries(Handle);
            }
        }
        else if( _stricmp(command, "mac")  == 0 )
        {
            UCHAR               addr[ETH_LENGTH_OF_ADDRESS];

            if(! DoBlockingRequest(BRIDGE_IOCTL_GET_MAC_ADDRESS, NULL, 0L, addr, sizeof(addr), NULL) )
            {
                printf("Attempt to query MAC address failed: ");
                PrintError( GetLastError() );
            }
            else
            {
                printf( "Bridge MAC address is %02x-%02x-%02x-%02x-%02x-%02x\n", addr[0], addr[1],
                        addr[2], addr[3], addr[4], addr[5] );
            }
        }
        else if( _stricmp(command, "packetstats")  == 0 )
        {
            BRIDGE_ADAPTER_HANDLE       Handle;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                BRIDGE_PACKET_STATISTICS    Stats;

                if(! DoBlockingRequest(BRIDGE_IOCTL_GET_PACKET_STATS, NULL, 0L, &Stats, sizeof(Stats), NULL) )
                {
                    printf("Attempt to retrieve global packet statistics failed: ");
                    PrintError( GetLastError() );
                }
                else
                {
                    PrintPacketStats(&Stats);
                }
            }
            else
            {
                BRIDGE_ADAPTER_PACKET_STATISTICS        Stats;

                if(! DoBlockingRequest(BRIDGE_IOCTL_GET_ADAPTER_PACKET_STATS, &Handle, sizeof(Handle), &Stats, sizeof(Stats), NULL) )
                {
                    printf("Attempt to retrieve packet statistics for adapter %p failed: ", Handle);
                    PrintError( GetLastError() );
                }
                else
                {
                    PrintAdapterPacketStats(&Stats);
                }
            }
        }
        else if( _stricmp(command, "bufferstats")  == 0 )
        {
            BRIDGE_BUFFER_STATISTICS    Stats;

            if(! DoBlockingRequest(BRIDGE_IOCTL_GET_BUFFER_STATS, NULL, 0L, &Stats, sizeof(Stats), NULL) )
            {
                printf("Attempt to retrieve buffer statistics failed: ");
                PrintError( GetLastError() );
            }
            else
            {
                PrintBufferStats(&Stats);
            }
        }
        else if( _stricmp(command, "stainfo")  == 0 )
        {
            BRIDGE_ADAPTER_HANDLE   Handle;

            if( ! ReadHexPtrArg(inbuf, &Handle) )
            {
                PrintSTAInfo();
            }
            else
            {
                PrintAdapterSTAInfo( Handle );
            }
        }
        else if( _stricmp( command, "quit" ) == 0 )
        {
            
            printf( "Signalling an exit...\n" );

            if( ! SetEvent( gThreadQuitEvent ) )
            {
                printf( "Couldn't signal an event: " );
                PrintError( GetLastError() );
                return;
            }

            bQuit = TRUE;
        }
        else
        {
            // Print a list of commands to help the user
            printf( "\n\nSupported commands:\n\n" );
            printf( "ENUM                   - Enumerates adapters\n" );
            printf( "DEVICENAME <handle>    - Retrieves the device name of the indicated adapter\n" );
            printf( "FRIENDLYNAME <handle>  - Retrieves the friendly name of the indicated adapter\n" );
            printf( "TABLE <handle>         - Prints the forwarding table for the indicated adapter\n" );
            printf( "MAC                    - Prints the bridge's MAC address\n" );
            printf( "PACKETSTATS [<handle>] - Retrieves packet-handling statistics for a particular\n" );
            printf( "                         adapter (or global data if no adapter handle is\n" );
            printf( "                         provided)\n" );
            printf( "BUFFERSTATS            - Retrieves buffer-management statistics\n" );
            printf( "STAINFO [<handle>]     - Retrieves STA info for a particular adapter (or global\n" );
            printf( "                         info if no adapter handle is provided)\n" );
            printf( "QUIT                   - Exits\n\n" );
        }
    }

    CloseHandle( gBridgeDeviceRead );
    CloseHandle( gBridgeDeviceWrite );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\inf\makefile.inc ===
STAMPINF_CMD=stampinf -f $@
_INF=obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)
.SUFFIXES : .inf .inx

make_infs:\
    $(_INF)\netbrdgs.inf    \
    $(_INF)\netbrdgm.inf

{}.inx{$(_INF)\}.inf:
     prodfilt -s $(@B).inx $@ +$(TARGET_DIRECTORY)
     $(STAMPINF_CMD)
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgcach.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgcach.h

Abstract:

    Ethernet MAC level bridge.
    Cache implementation header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    December  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

typedef struct _CACHE_ENTRY
{
    UINT32          key;
    UINT32          data;
    UINT64          hits;
    UINT64          misses;
} CACHE_ENTRY, *PCACHE_ENTRY;

typedef struct _CACHE
{
    // lock protects all cache fields
    NDIS_SPIN_LOCK  lock;

    // stats
    UINT64          hits;
    UINT64          misses;

    // 2^shiftFactor is the number of entries
    USHORT          shiftFactor;

    // Pointer to the array of entries
    PCACHE_ENTRY    pEntries;
} CACHE, *PCACHE;

//
// Determines the cache slot for key k in cache c. The slot is determined
// as the bottom bits of k.
//
#define CACHE_INDEX(c, k) (k & ((1 << c->shiftFactor) - 1))

// ===========================================================================
//
// INLINES
//
// ===========================================================================

__inline
VOID
BrdgClearCache(
    IN PCACHE       pCache
    )
{
    NdisAcquireSpinLock( &pCache->lock );
    memset( pCache->pEntries, 0, sizeof(CACHE_ENTRY) * (1 << pCache->shiftFactor) );
    NdisReleaseSpinLock( &pCache->lock );
}

__inline
NDIS_STATUS
BrdgInitializeCache(
    IN PCACHE       pCache,
    IN USHORT       shiftFactor
    )
{
    ULONG           numEntries = 1 << shiftFactor;
    NDIS_STATUS     status;

    pCache->shiftFactor = shiftFactor;
    NdisAllocateSpinLock( &pCache->lock );
    status = NdisAllocateMemoryWithTag( &pCache->pEntries, sizeof(CACHE_ENTRY) * numEntries, 'gdrB' );
    pCache->hits = 0L;
    pCache->misses = 0L;

    if( status != NDIS_STATUS_SUCCESS )
    {
        return status;
    }

    // Zero out the array of entries
    memset( pCache->pEntries, 0, sizeof(CACHE_ENTRY) * (1 << pCache->shiftFactor) );
    return NDIS_STATUS_SUCCESS;
}

__inline
VOID
BrdgFreeCache(
    IN PCACHE       pCache
    )
{
    NdisFreeMemory( pCache->pEntries, sizeof(CACHE_ENTRY) * (1 << pCache->shiftFactor), 0 );
}

__inline
UINT32
BrdgProbeCache(
    IN PCACHE       pCache,
    IN UINT32       key
    )
{
    UINT32          index = CACHE_INDEX(pCache, key);
    PCACHE_ENTRY    pEntry = &pCache->pEntries[index];
    UINT32          data = 0L;

    NdisAcquireSpinLock( &pCache->lock );

    if( pEntry->key == key )
    {
        data = pEntry->data;
        pEntry->hits++;
        pCache->hits++;
    }
    else
    {
        pEntry->misses++;
        pCache->misses++;
    }

    NdisReleaseSpinLock( &pCache->lock );

    return data;
}

__inline
BOOLEAN
BrdgUpdateCache(
    IN PCACHE       pCache,
    IN UINT32       key,
    IN UINT32       data
    )
{
    UINT32          index = CACHE_INDEX(pCache, key);
    PCACHE_ENTRY    pEntry = &pCache->pEntries[index];
    BOOLEAN         bUpdated = FALSE;

    NdisAcquireSpinLock( &pCache->lock );

    if( pEntry->key != key &&
        (pEntry->hits < pEntry->misses) )
    {
        pEntry->key = key;
        pEntry->data = data;
        pEntry->hits = 0L;
        pEntry->misses = 0L;
        bUpdated = TRUE;
    }

    NdisReleaseSpinLock( &pCache->lock );

    return bUpdated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgbuf.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgbuf.c

Abstract:

    Ethernet MAC level bridge.
    Buffer management section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgbuf.h"
#include "brdgprot.h"
#include "brdgmini.h"

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

//
// A guess at how many buffer descriptors an average packet indicated on the
// no-copy path is likely to have.
//
// The size of the pool of MDLs used to construct wrapper packets is based on this
// guess
//
#define GUESS_BUFFERS_PER_PACKET        3

//
// Transit unicast packets on the no-copy path require one packet descriptor to wrap
// them for relay.
//
// Transit broadcast packets require n descriptors (where n == # of adapters) to
// wrap them for relay.
//
// We can't allow our descriptor usage to reach n^2, which is the worst case to handle
// broadcast traffic from all adapters. This number is a guess at how many wrapping
// descriptors we will need, on **average**, per packet. The idea is to not run out
// of packet descriptors under regular traffic conditions. If running on a machine
// with lots of adapters and lots of broadcast traffic, the # of wrapper descriptors
// may become a limiting factor if this guess is wrong.
//
// The size of the wrapper packet descriptor pool is based on this guess.
//
#define GUESS_AVERAGE_FANOUT            2

//
// In case we can't read it out of the registry, use this default value for the
// size of the copy packet pool safety buffer.
//
#define DEFAULT_SAFETY_MARGIN           10              // A percentage (10%)

//
// In case we can't read it out of the registry, use this default value for the
// total memory footprint we are allowed.
//
#define DEFAULT_MAX_BUF_MEMORY          2 * 1024 * 1024 // 2MB in bytes

//
// Registry values that hold our config values
//
const PWCHAR            gMaxBufMemoryParameterName = L"MaxBufferMemory";
const PWCHAR            gSafetyMarginParameterName = L"SafetyMargin";

//
// Constant for different types of quota-restricted packets
//
typedef enum
{
    BrdgQuotaCopyPacket = 0,
    BrdgQuotaWrapperPacket = 1
} QUOTA_PACKET_TYPE;

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// List of free packet descriptors for copy-receives
BSINGLE_LIST_HEAD       gFreeCopyPacketList;
NDIS_SPIN_LOCK          gFreeCopyPacketListLock;

// List of free packet descriptors for wrapper packets
BSINGLE_LIST_HEAD       gFreeWrapperPacketList;
NDIS_SPIN_LOCK          gFreeWrapperPacketListLock;

// Look-aside list for copy-receive buffers
NPAGED_LOOKASIDE_LIST   gCopyBufferList;
BOOLEAN                 gInitedCopyBufferList = FALSE;

// Look-aside list for packet info blocks
NPAGED_LOOKASIDE_LIST   gPktInfoList;
BOOLEAN                 gInitedPktInfoList = FALSE;

// Packet descriptor pools for copy receives and wrapper packets
NDIS_HANDLE             gCopyPacketPoolHandle = NULL;
NDIS_HANDLE             gWrapperPacketPoolHandle = NULL;

// MDL pools for copy receives and wrapper packets
NDIS_HANDLE             gCopyBufferPoolHandle = NULL;
NDIS_HANDLE             gWrapperBufferPoolHandle = NULL;

// Spin lock to protect quota information
NDIS_SPIN_LOCK          gQuotaLock;

// Quota information for the local miniport
ADAPTER_QUOTA           gMiniportQuota;

//
// Maximum number of available packets of each type
//
// [0] == Copy packets
// [1] == Wrapper packets
//
ULONG                   gMaxPackets[2] = { 0L, 0L };

//
// Number of packets currently allocated from each pool
//
// [0] == Copy packets
// [1] == Wrapper packets
//
ULONG                   gUsedPackets[2] = { 0L, 0L };

#if DBG
ULONG                   gMaxUsedPackets[2] = { 0L, 0L };
#endif

//
// Amount of packets to keep as a buffer in each pool (the maximum consumption
// of any single adapter is gMaxPackets[X] - gSafetyBuffer[X].
//
// These values are computed from the safety margin proportion, which can
// optionally be specified by a registry value
//
ULONG                   gSafetyBuffer[2] = { 0L, 0L };

//
// Number of times we have had to deny an allocation request even though we wanted
// to allow it because we were flat out of packets. For debugging performance.
//
LARGE_INTEGER           gStatOverflows[2] = {{ 0L, 0L }, {0L, 0L}};

//
// Number of times we failed to allocated memory unexpectedly (i.e., when we had
// not allocated up to the preset maximum size of our resource pool). Should only
// occur if the host machine is actually out of non-paged memory (yikes!)
//
LARGE_INTEGER           gStatFailures = { 0L, 0L };

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

PNDIS_PACKET
BrdgBufCommonGetNewPacket(
    IN NDIS_HANDLE          Pool,
    OUT PPACKET_INFO        *pppi
    );

PNDIS_PACKET
BrdgBufGetNewCopyPacket(
    OUT PPACKET_INFO        *pppi
    );

// Type of function to pass to BrgBufCommonGetPacket
typedef PNDIS_PACKET (*PNEWPACKET_FUNC)(PPACKET_INFO*);

PNDIS_PACKET
BrdgBufCommonGetPacket(
    OUT PPACKET_INFO        *pppi,
    IN PNEWPACKET_FUNC      pNewPacketFunc,
    IN PBSINGLE_LIST_HEAD   pCacheList,
    IN PNDIS_SPIN_LOCK      ListLock
    );

BOOLEAN
BrdgBufAssignQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt,
    IN BOOLEAN              bCountAlloc
    );

VOID
BrdgBufReleaseQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Allocates a new wrapper packet
//
__forceinline PNDIS_PACKET
BrdgBufGetNewWrapperPacket(
    OUT PPACKET_INFO        *pppi
    )
{
    return BrdgBufCommonGetNewPacket( gWrapperPacketPoolHandle, pppi );
}

//
// Handles the special LOCAL_MINIPORT pseudo-pointer value
//
__forceinline PADAPTER_QUOTA
QUOTA_FROM_ADAPTER(
    IN PADAPT               pAdapt
    )
{
    SAFEASSERT( pAdapt != NULL );
    if( pAdapt == LOCAL_MINIPORT )
    {
        return &gMiniportQuota;
    }
    else
    {
        return &pAdapt->Quota;
    }
}

//
// Switches from the packet type constant to an index
//
__forceinline UINT
INDEX_FROM_TYPE(
    IN QUOTA_PACKET_TYPE    type
    )
{
    SAFEASSERT( (type == BrdgQuotaCopyPacket) || (type == BrdgQuotaWrapperPacket) );
    return (type == BrdgQuotaCopyPacket) ? 0 : 1;
}

//
// Reinitializes a packet for reuse later
//
__forceinline
VOID
BrdgBufScrubPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
{
    // This scrubs NDIS's state
    NdisReinitializePacket( pPacket );

    // Aggressively forget previous state to catch bugs
    NdisZeroMemory( ppi, sizeof(PACKET_INFO) );
    ppi->pOwnerPacket = pPacket;
}

//
// Decrements an adapter's used packet count
//
__forceinline
VOID
BrdgBufReleaseQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt
    )
{
    PADAPTER_QUOTA          pQuota = QUOTA_FROM_ADAPTER(pAdapt);
    UINT                    index = INDEX_FROM_TYPE(type);

    NdisAcquireSpinLock( &gQuotaLock );

    SAFEASSERT( pQuota->UsedPackets[index] > 0L );
    pQuota->UsedPackets[index] --;

    NdisReleaseSpinLock( &gQuotaLock );
}

//
// Decrements the global usage count
//
__forceinline
VOID
BrdgBufCountDealloc(
    IN QUOTA_PACKET_TYPE    type
    )
{
    UINT                    index = INDEX_FROM_TYPE(type);

    NdisAcquireSpinLock( &gQuotaLock );
    SAFEASSERT( gUsedPackets[index] > 0L );
    gUsedPackets[index]--;
    NdisReleaseSpinLock( &gQuotaLock );
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgBufGetStatistics(
    PBRIDGE_BUFFER_STATISTICS   pStats
    )
/*++

Routine Description:

    Retrieves our internal statistics on buffer management.

Arguments:

    pStats                      The statistics structure to fill in

Return Value:

    None

--*/
{
    pStats->CopyPoolOverflows = gStatOverflows[0];
    pStats->WrapperPoolOverflows = gStatOverflows[1];

    pStats->AllocFailures = gStatFailures;

    pStats->MaxCopyPackets = gMaxPackets[0];
    pStats->MaxWrapperPackets = gMaxPackets[1];

    pStats->SafetyCopyPackets = gSafetyBuffer[0];
    pStats->SafetyWrapperPackets = gSafetyBuffer[1];

    NdisAcquireSpinLock( &gQuotaLock );

    pStats->UsedCopyPackets = gUsedPackets[0];
    pStats->UsedWrapperPackets = gUsedPackets[1];

    NdisReleaseSpinLock( &gQuotaLock );
}

PACKET_OWNERSHIP
BrdgBufGetPacketOwnership(
    IN PNDIS_PACKET         pPacket
    )
/*++

Routine Description:

    Returns a value indicating who owns this packet (i.e., whether we own this
    packet and it is from our copy pool, we own it and it's from our wrapper
    pool, or we don't own the packet at all).

Arguments:

    pPacket                 The packet to examine

Return Value:

    Ownership enumerated value

--*/
{
    NDIS_HANDLE             Pool = NdisGetPoolFromPacket(pPacket);

    if( Pool == gCopyPacketPoolHandle )
    {
        return BrdgOwnCopyPacket;
    }
    else if ( Pool == gWrapperPacketPoolHandle )
    {
        return BrdgOwnWrapperPacket;
    }

    return BrdgNotOwned;
}

VOID
BrdgBufFreeWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi,
    IN PADAPT               pQuotaOwner
    )
/*++

Routine Description:

    Frees a packet allocated from the wrapper pool and releases the quota previously
    assigned to the owning adapter

Arguments:

    pPacket                 The packet
    ppi                     The packet's associated info block
    pQuotaOwner             The adapter previously "charged" for this packet

Return Value:

    None

--*/
{
    SAFEASSERT( pQuotaOwner != NULL );
    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( ppi != NULL );

    // Free the packet
    BrdgBufFreeBaseWrapperPacket( pPacket, ppi );

    // Account for this packet having been returned
    BrdgBufReleaseQuota( BrdgQuotaWrapperPacket, pQuotaOwner );
}


PNDIS_PACKET
BrdgBufGetBaseCopyPacket(
    OUT PPACKET_INFO        *pppi
    )
/*++

Routine Description:

    Returns a new copy packet and associated info block from our pools
    WITHOUT CHECKING FOR QUOTA against any particular adapter

    This call is made to allocated copy packets for wrapping inbound packets before
    any target adapter has been identified.

Arguments:

    pppi                    Receives the info block pointer (NULL if the alloc fails)

Return Value:

    The new packet or NULL if the target adapter failed quota

--*/
{
    PNDIS_PACKET            pPacket;
    BOOLEAN                 bAvail = FALSE;

    NdisAcquireSpinLock( &gQuotaLock );

    if( gUsedPackets[BrdgQuotaCopyPacket] < gMaxPackets[BrdgQuotaCopyPacket] )
    {
        // There are packets still available in the pool. Grab one.
        bAvail = TRUE;
        gUsedPackets[BrdgQuotaCopyPacket]++;

#if DBG
        // Keep track of the maximum used packets
        if( gMaxUsedPackets[BrdgQuotaCopyPacket] < gUsedPackets[BrdgQuotaCopyPacket] )
        {
            gMaxUsedPackets[BrdgQuotaCopyPacket] = gUsedPackets[BrdgQuotaCopyPacket];
        }
#endif
    }
    else if( gUsedPackets[BrdgQuotaCopyPacket] == gMaxPackets[BrdgQuotaCopyPacket] )
    {
        // We are at our limit. Hopefully this doesn't happen too often
        ExInterlockedAddLargeStatistic( &gStatOverflows[BrdgQuotaCopyPacket], 1L );
        bAvail = FALSE;
    }
    else
    {
        // This should never happen; it means we are over our limit somehow
        SAFEASSERT( FALSE );
        bAvail = FALSE;
    }

    NdisReleaseSpinLock( &gQuotaLock );

    if( ! bAvail )
    {
        // None available
        *pppi = NULL;
        return NULL;
    }

    pPacket =  BrdgBufCommonGetPacket( pppi, BrdgBufGetNewCopyPacket, &gFreeCopyPacketList,
                                       &gFreeCopyPacketListLock );

    if( pPacket == NULL )
    {
        // Our allocation failed. Reverse the usage increment.
        BrdgBufCountDealloc( BrdgQuotaCopyPacket );
    }

    return pPacket;
}


PNDIS_PACKET
BrdgBufGetWrapperPacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Returns a new packet and associated info block from the wrapper pool, unless the
    owning adapter does not does pass a quota check

Arguments:

    pppi                    Receives the info block pointer (NULL if the target
                            adapter fails quota)

    pAdapt                  The adapter to be "charged" for this packet

Return Value:

    The new packet or NULL if the target adapter failed quota

--*/
{
    PNDIS_PACKET            NewPacket = NULL;

    *pppi = NULL;

    if( BrdgBufAssignQuota(BrdgQuotaWrapperPacket, pAdapt, TRUE/*Count the alloc we are about to do*/) )
    {
        // Passed quota. We can allocate.
        NewPacket =  BrdgBufCommonGetPacket( pppi, BrdgBufGetNewWrapperPacket, &gFreeWrapperPacketList,
                                             &gFreeWrapperPacketListLock );

        if( NewPacket == NULL )
        {
            // We failed to allocate even though we haven't yet hit the ceiling on our
            // resource pool. This should only happen if we are physically out of non-paged
            // memory.

            // Reverse the adapter's quota bump
            BrdgBufReleaseQuota( BrdgQuotaWrapperPacket, pAdapt );

            // Reverse the usage count in BrdgBufAssignQuota
            BrdgBufCountDealloc( BrdgQuotaWrapperPacket );
        }
    }

    return NewPacket;
}

VOID
BrdgBufReleaseBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Called to release the previously assigned cost of a wrapper packet. The packet
    provided can be any packet, even one we don't own. If we own the packet, we
    decrement the appropriate usage count in the adapter's quota structure.

Arguments:

    pPacket                 The packet the indicated adapter is no longer referring to

    pAdapt                  The adapter no longer referring to pPacket

Return Value:

    NULL

--*/
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);

    // This gets called for any base packet, even ones we don't own. Just NOOP if we
    // don't own it.
    if( Own != BrdgNotOwned )
    {
        BrdgBufReleaseQuota( (Own == BrdgOwnCopyPacket) ? BrdgQuotaCopyPacket : BrdgQuotaWrapperPacket,
                             pAdapt );
    }
}

BOOLEAN
BrdgBufAssignBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Called to assign the cost of a base packet to an adapter, which is presumably attempting
    to construct a child wrapper packet that refers to the given base packet. A "cost" is
    assigned to pAdapt because by building a child wrapper packet that refers to the given
    base packet, pAdapt will cause it to not be disposed until it is done using it.

    It's OK for the input packet to be a packet we don't own; in that case, there is no cost
    to assign so we do nothing.

Arguments:

    pPacket                 The base packet that pAdapt wishes to build a child wrapper packet
                            referring to.

    pAdapt                  The adapter wishing to refer to pPacket

Return Value:

    TRUE    :   The adapter is permitted to refer to the given base packet
    FALSE   :   The adapter did not pass qutoa and may not refer to the given base packet

--*/
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);

    // We get called for any base packet, even if we don't own it.
    if( Own != BrdgNotOwned )
    {
        return BrdgBufAssignQuota( (Own == BrdgOwnCopyPacket) ? BrdgQuotaCopyPacket : BrdgQuotaWrapperPacket,
                                   pAdapt, FALSE/*We aren't going to do an alloc for this quota bump*/);
    }
    else
    {
        return TRUE;
    }
}

PNDIS_PACKET
BrdgBufCommonGetPacket(
    OUT PPACKET_INFO        *pppi,
    IN PNEWPACKET_FUNC      pNewPacketFunc,
    IN PBSINGLE_LIST_HEAD   pCacheList,
    IN PNDIS_SPIN_LOCK      ListLock
    )
/*++

Routine Description:

    Common processing for retrieving a new packet from either the copy pool or the wrapper pool

    Since we know how many packets we've allocated from each pool at all times, the only time this
    function should fail is if the host machine is physically out of memory.

Arguments:

    pppi                Receives the new info block (NULL if the alloc fails, which it shouldn't)
    pNewPacketFunc      Function to call to alloc a packet if the cache is empty
    pCacheList          Queue of cached packets that can be used to satisfy the alloc
    ListLock            The lock to use when manipulating the cache queue

Return Value:

    The newly allocated packet, or NULL if severe memory constraints cause the allocation to fail
    (this should be unusual)

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi;
    PBSINGLE_LIST_ENTRY     entry;

    // Try to get a packet out of our cache.
    entry = BrdgInterlockedRemoveHeadSingleList( pCacheList, ListLock );

    if( entry == NULL )
    {
        // Try to allocate a packet and info block from our underlying pools
        pPacket = (*pNewPacketFunc)( &ppi );

        if( (pPacket == NULL) || (ppi == NULL) )
        {
            // This should only occur if our host machine is actually out
            // of nonpaged memory; we should normally be able to allocate
            // up to our preset limit from our pools.
            ExInterlockedAddLargeStatistic( &gStatFailures, 1L );
        }
    }
    else
    {
        ppi = CONTAINING_RECORD( entry, PACKET_INFO, List );
        pPacket = ppi->pOwnerPacket;
        SAFEASSERT( pPacket != NULL );
    }

    *pppi = ppi;
    return pPacket;
}

VOID
BrdgBufFreeBaseCopyPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
/*++

Routine Description:

    Frees a packet allocated from the copy pool without quota adjustements. This is called directly
    from non-buffer-management code to free base packets because the cost for base packets is
    assigned and released directly with calls to BrdgBuf<Assign|Release>BasePacketQuota.

Arguments:

    pPacket                 The packet to free
    ppi                     Its info block to free

Return Value:

    None

--*/
{
    // If we're holding less than our cache amount, free the packet by putting it on the
    // cache list
    ULONG                   holding;
    PNDIS_BUFFER            pBuffer = BrdgBufPacketHeadBuffer( pPacket );

    SAFEASSERT( (ppi != NULL) && (pPacket != NULL) );
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( pBuffer != NULL );

    if (pBuffer)
    {
        // Return this packet descriptor to its original state
        NdisAdjustBufferLength(pBuffer, MAX_PACKET_SIZE);

        NdisAcquireSpinLock( &gFreeCopyPacketListLock );
        holding = BrdgQuerySingleListLength( &gFreeCopyPacketList );

        if( holding < gSafetyBuffer[BrdgQuotaCopyPacket] )
        {
            // Prep the packet for reuse

            // This blows away the buffer chain
            BrdgBufScrubPacket( pPacket, ppi );

            // Put the buffer back on
            SAFEASSERT( BrdgBufPacketHeadBuffer(pPacket) == NULL );
            NdisChainBufferAtFront( pPacket, pBuffer );

            // Push the packet onto the list
            BrdgInsertHeadSingleList( &gFreeCopyPacketList, &ppi->List );

            NdisReleaseSpinLock( &gFreeCopyPacketListLock );
        }
        else
        {
            PVOID               pBuf;
            UINT                Size;

            NdisReleaseSpinLock( &gFreeCopyPacketListLock );

            NdisQueryBufferSafe( pBuffer, &pBuf, &Size, NormalPagePriority );

            // Free the packet, the packet info block and the copy buffer to the underlying pools
            NdisFreeBuffer( pBuffer );
            NdisFreePacket( pPacket );
            NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );

            if( pBuf != NULL )
            {
                NdisFreeToNPagedLookasideList( &gCopyBufferList, pBuf );
            }
            else
            {
                // Shouldn't be possible since the alloced memory is in kernel space
                SAFEASSERT( FALSE );
            }
        }
        // Note the deallocation
        BrdgBufCountDealloc( BrdgQuotaCopyPacket );
    }
}

VOID
BrdgBufFreeBaseWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
/*++

Routine Description:

    Frees a packet allocated from the wrapper pool without quota adjustements. This is called directly
    from non-buffer-management code to free base packets because the cost for base packets is
    assigned and released directly with calls to BrdgBuf<Assign|Release>BasePacketQuota.

Arguments:

    pPacket                 The packet to free
    ppi                     Its info block to free

Return Value:

    None

--*/
{
    // If we're holding less than our cache amount, free the packet by putting it on the
    // cache list
    ULONG                   holding;

    SAFEASSERT( (ppi != NULL) && (pPacket != NULL) );
    SAFEASSERT( ppi->pOwnerPacket == pPacket );

    NdisAcquireSpinLock( &gFreeWrapperPacketListLock );

    holding = BrdgQuerySingleListLength( &gFreeWrapperPacketList );

    if( holding < gSafetyBuffer[BrdgQuotaWrapperPacket] )
    {
        // Prep the packet for reuse
        SAFEASSERT( BrdgBufPacketHeadBuffer(pPacket) == NULL );
        BrdgBufScrubPacket( pPacket, ppi );

        // Push the packet onto the list
        BrdgInsertHeadSingleList( &gFreeWrapperPacketList, &ppi->List );

        NdisReleaseSpinLock( &gFreeWrapperPacketListLock );
    }
    else
    {
        NdisReleaseSpinLock( &gFreeWrapperPacketListLock );

        // Free the packet and packet info block to the underlying pools
        NdisFreePacket( pPacket );
        NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
    }

    // Note the deallocation
    BrdgBufCountDealloc( BrdgQuotaWrapperPacket );
}

NDIS_STATUS
BrdgBufChainCopyBuffers(
    IN PNDIS_PACKET         pTargetPacket,
    IN PNDIS_PACKET         pSourcePacket
    )
/*++

Routine Description:

    Allocates and chains buffer descriptors onto the target packet so it describes exactly
    the same areas of memory as the source packet

Arguments:

    pTargetPacket           Target packet
    pSourcePacket           Source packet

Return Value:

    Status of the operation. We have a limited-size pool of packet descriptors, so this
    operation can fail if we run out.

--*/
{
    PNDIS_BUFFER            pCopyBuffer, pCurBuf = BrdgBufPacketHeadBuffer( pSourcePacket );
    NDIS_STATUS             Status;

    SAFEASSERT( BrdgBufPacketHeadBuffer(pTargetPacket) == NULL );

    // There must be something in the source packet!
    if( pCurBuf == NULL )
    {
        SAFEASSERT( FALSE );
        return NDIS_STATUS_RESOURCES;
    }

    while( pCurBuf != NULL )
    {
        PVOID               p;
        UINT                Length;

        // Pull the virtual address and size out of the MDL being copied
        NdisQueryBufferSafe( pCurBuf, &p, &Length, NormalPagePriority );

        if( p == NULL )
        {
            BrdgBufUnchainCopyBuffers( pTargetPacket );
            return NDIS_STATUS_RESOURCES;
        }

        // Is wacky to have a MDL describing no memory
        if( Length > 0 )
        {
            // Get a new MDL from our pool and point it to the same address
            NdisAllocateBuffer( &Status, &pCopyBuffer, gWrapperBufferPoolHandle, p, Length );

            if( Status != NDIS_STATUS_SUCCESS )
            {
                THROTTLED_DBGPRINT(BUF, ("Failed to allocate a MDL in BrdgBufChainCopyBuffers: %08x\n", Status));
                BrdgBufUnchainCopyBuffers( pTargetPacket );
                return Status;
            }

            // Use the new MDL to chain to the target packet
            NdisChainBufferAtBack( pTargetPacket, pCopyBuffer );
        }
        else
        {
            SAFEASSERT( FALSE );
        }

        NdisGetNextBuffer( pCurBuf, &pCurBuf );
    }

    return NDIS_STATUS_SUCCESS;
}

NTSTATUS
BrdgBufDriverInit( )
/*++

Routine Description:

    Driver-load-time initialization routine.

Arguments:

    None

Return Value:

    Status of initialization. A return code != STATUS_SUCCESS causes the driver load to fail.
    Any event causing an error return code must be logged.

--*/
{
    NDIS_STATUS                     Status;
    ULONG                           NumCopyPackets, ConsumptionPerCopyPacket, SizeOfPacket, i;
    ULONG                           MaxMemory = 0L, SafetyMargin = 0L;
    NTSTATUS                        NtStatus;

    // Initialize protective locks
    NdisAllocateSpinLock( &gFreeCopyPacketListLock );
    NdisAllocateSpinLock( &gFreeWrapperPacketListLock );
    NdisAllocateSpinLock( &gQuotaLock );

    // Initialize cache lists
    BrdgInitializeSingleList( &gFreeCopyPacketList );
    BrdgInitializeSingleList( &gFreeWrapperPacketList );

    // Initialize look-aside lists for receive buffers and packet info blocks
    NdisInitializeNPagedLookasideList( &gCopyBufferList, NULL, NULL, 0, MAX_PACKET_SIZE, 'gdrB', 0 );
    NdisInitializeNPagedLookasideList( &gPktInfoList, NULL, NULL, 0, sizeof(PACKET_INFO), 'gdrB', 0 );

    // Initialize the miniport's quota information
    BrdgBufInitializeQuota( &gMiniportQuota );

    //
    // Read in registry values. Substitute default values on failure.
    //
    NtStatus = BrdgReadRegDWord( &gRegistryPath, gMaxBufMemoryParameterName, &MaxMemory );

    if( NtStatus != STATUS_SUCCESS )
    {
        MaxMemory = DEFAULT_MAX_BUF_MEMORY;
        DBGPRINT(BUF, ( "Using DEFAULT maximum memory of %i\n", MaxMemory ));
    }

    NtStatus = BrdgReadRegDWord( &gRegistryPath, gSafetyMarginParameterName, &SafetyMargin );

    if( NtStatus != STATUS_SUCCESS )
    {
        SafetyMargin = DEFAULT_SAFETY_MARGIN;
        DBGPRINT(BUF, ( "Using DEFAULT safety margin of %i%%\n", SafetyMargin ));
    }

    //
    // Figure out the maximum number of packet descriptors in each pool we can allocate in order to
    // fit in the prescribed maximum memory space.
    //
    // For every copy packet, we allow ourselves GUESS_AVERAGE_FANOUT wrapper packets.
    // *Each* wrapper packet is allowed to consume GUESS_BUFFERS_PER_PACKET MDLs.
    // Given these relationships, we can calculate the number of copy packets that will fit in a given
    // memory footprint. The max for all other resources are set in relationship to that number.
    //

    SizeOfPacket = NdisPacketSize( PROTOCOL_RESERVED_SIZE_IN_PACKET );
    ConsumptionPerCopyPacket =  SizeOfPacket * (GUESS_AVERAGE_FANOUT + 1) +         // Packet decriptor memory
                                MAX_PACKET_SIZE +                                   // Copy buffer memory
                                sizeof(PACKET_INFO) * (GUESS_AVERAGE_FANOUT + 1) +  // Packet info block memory
                                sizeof(NDIS_BUFFER) * ((GUESS_AVERAGE_FANOUT * GUESS_BUFFERS_PER_PACKET) + 1);  // MDL memory

    NumCopyPackets = MaxMemory / ConsumptionPerCopyPacket;

    // Allocate the packet pools
    NdisAllocatePacketPool( &Status, &gCopyPacketPoolHandle, NumCopyPackets, PROTOCOL_RESERVED_SIZE_IN_PACKET );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate copy-packet pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisAllocatePacketPool( &Status, &gWrapperPacketPoolHandle, GUESS_AVERAGE_FANOUT * NumCopyPackets, PROTOCOL_RESERVED_SIZE_IN_PACKET );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisFreePacketPool( gCopyPacketPoolHandle );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate wrapper packet pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate the buffer pools
    NdisAllocateBufferPool( &Status, &gCopyBufferPoolHandle, NumCopyPackets );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisFreePacketPool( gCopyPacketPoolHandle );
        NdisFreePacketPool( gWrapperPacketPoolHandle );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate copy buffer pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisAllocateBufferPool( &Status, &gWrapperBufferPoolHandle, GUESS_AVERAGE_FANOUT * GUESS_BUFFERS_PER_PACKET * NumCopyPackets );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
        NdisDeleteNPagedLookasideList( &gPktInfoList );
        NdisFreePacketPool( gCopyPacketPoolHandle );
        NdisFreePacketPool( gWrapperPacketPoolHandle );
        NdisFreeBufferPool( gCopyBufferPoolHandle );
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(BUF, ("Unable to allocate wrapper buffer pool: %08x\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    gInitedCopyBufferList = gInitedPktInfoList = TRUE;

    // Note the number of each packet type
    gMaxPackets[BrdgQuotaCopyPacket] = NumCopyPackets;
    gMaxPackets[BrdgQuotaWrapperPacket] = NumCopyPackets * GUESS_AVERAGE_FANOUT;

    // Calculate the safety buffer size in packets
    SAFEASSERT( SafetyMargin > 0L );
    gSafetyBuffer[BrdgQuotaCopyPacket] = (gMaxPackets[BrdgQuotaCopyPacket] * SafetyMargin) / 100;
    gSafetyBuffer[BrdgQuotaWrapperPacket] = (gMaxPackets[BrdgQuotaWrapperPacket] * SafetyMargin) / 100;

    DBGPRINT(BUF, (  "Max memory usage of %d == %d copy packets, %d wrapper packets, %d copy-buffer space, %d/%d safety packets\n",
                MaxMemory, gMaxPackets[0], gMaxPackets[1], NumCopyPackets * MAX_PACKET_SIZE, gSafetyBuffer[0], gSafetyBuffer[1] ));

    // Pre-allocate the appropriate number of packets from each pool for perf.
    for( i = 0; i < gSafetyBuffer[BrdgQuotaCopyPacket]; i++ )
    {
        PNDIS_PACKET        pPacket;
        PPACKET_INFO        ppi;

        pPacket = BrdgBufGetNewCopyPacket( &ppi );

        // Should be impossible for this to fail
        if( (pPacket != NULL) && (ppi != NULL) )
        {
            // Count the usage ourselves because we're not going through normal channels
            gUsedPackets[BrdgQuotaCopyPacket]++;

            // This should retain the packet in memory and decrement the usage count
            BrdgBufFreeBaseCopyPacket( pPacket, ppi );
        }
        else
        {
            SAFEASSERT( FALSE );
        }
    }

    for( i = 0; i < gSafetyBuffer[BrdgQuotaWrapperPacket]; i++ )
    {
        PNDIS_PACKET        pPacket;
        PPACKET_INFO        ppi;

        pPacket = BrdgBufGetNewWrapperPacket( &ppi );

        // Should be impossible for this to fail
        if( (pPacket != NULL) && (ppi != NULL) )
        {
            // Count the usage ourselves because we're not going through normal channels
            gUsedPackets[BrdgQuotaWrapperPacket]++;

            // This should retain the packet in memory and decrement the usage count
            BrdgBufFreeBaseWrapperPacket( pPacket, ppi );
        }
        else
        {
            SAFEASSERT( FALSE );
        }
    }

    return STATUS_SUCCESS;
}

VOID
BrdgBufCleanup()
/*++

Routine Description:

    Unload-time orderly shutdown

    This function is guaranteed to be called exactly once

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_HANDLE     TmpHandle;

    if( gCopyPacketPoolHandle != NULL )
    {
        PBSINGLE_LIST_ENTRY     entry;

        TmpHandle = gCopyPacketPoolHandle;
        gCopyPacketPoolHandle = NULL;

        // Free all cached packets before freeing the pool
        entry = BrdgInterlockedRemoveHeadSingleList( &gFreeCopyPacketList, &gFreeCopyPacketListLock );

        while( entry != NULL )
        {
            PNDIS_PACKET            pPacket;
            PPACKET_INFO            ppi;
            PNDIS_BUFFER            pBuffer;

            ppi = CONTAINING_RECORD( entry, PACKET_INFO, List );
            SAFEASSERT(ppi);
            if (ppi)
            {
                pPacket = ppi->pOwnerPacket;
                SAFEASSERT( pPacket != NULL );

                if (pPacket)
                {
                    // Pull off the data buffer
                    NdisUnchainBufferAtFront( pPacket, &pBuffer );

                    if( pBuffer != NULL )
                    {
                        PVOID                   pBuf;
                        UINT                    Size;

                        NdisQueryBufferSafe( pBuffer, &pBuf, &Size, NormalPagePriority );

                        if( pBuf != NULL )
                        {
                            // Ditch the data buffer
                            NdisFreeToNPagedLookasideList( &gCopyBufferList, pBuf );
                        }
                        // else can only fail under extreme memory pressure

                        NdisFreeBuffer( pBuffer );
                    }
                    else
                    {
                        // This packet should have a chained buffer
                        SAFEASSERT( FALSE );
                    }
                }

                NdisFreePacket( pPacket );
                NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
            }
            entry = BrdgInterlockedRemoveHeadSingleList( &gFreeCopyPacketList, &gFreeCopyPacketListLock );
        }

        // Free the pool now that all packets have been returned
        NdisFreePacketPool( TmpHandle );
    }

    if( gWrapperPacketPoolHandle != NULL )
    {
        PBSINGLE_LIST_ENTRY     entry;

        TmpHandle = gWrapperPacketPoolHandle;
        gWrapperPacketPoolHandle = NULL;

        // Free all cached packets before freeing the pool
        entry = BrdgInterlockedRemoveHeadSingleList( &gFreeWrapperPacketList, &gFreeWrapperPacketListLock );

        while( entry != NULL )
        {
            PNDIS_PACKET            pPacket;
            PPACKET_INFO            ppi;

            ppi = CONTAINING_RECORD( entry, PACKET_INFO, List );
            pPacket = ppi->pOwnerPacket;
            SAFEASSERT( pPacket != NULL );
            if (pPacket)
            {
                NdisFreePacket( pPacket );
            }
            NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );

            entry = BrdgInterlockedRemoveHeadSingleList( &gFreeWrapperPacketList, &gFreeWrapperPacketListLock );
        }

        // Free the pool now that all packets have been returned
        NdisFreePacketPool( TmpHandle );
    }

    // The two lookaside lists should now be empty as well
    if( gInitedCopyBufferList )
    {
        gInitedCopyBufferList = FALSE;
        NdisDeleteNPagedLookasideList( &gCopyBufferList );
    }

    if( gInitedPktInfoList )
    {
        gInitedPktInfoList = FALSE;
        NdisDeleteNPagedLookasideList( &gPktInfoList );

    }

    if( gCopyBufferPoolHandle != NULL )
    {
        TmpHandle = gCopyBufferPoolHandle;
        gCopyBufferPoolHandle = NULL;
        NdisFreeBufferPool( TmpHandle );
    }

    if( gWrapperBufferPoolHandle != NULL )
    {
        TmpHandle = gWrapperBufferPoolHandle;
        gWrapperBufferPoolHandle = NULL;
        NdisFreeBufferPool( TmpHandle );
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

BOOLEAN
BrdgBufAssignQuota(
    IN QUOTA_PACKET_TYPE    type,
    IN PADAPT               pAdapt,
    IN BOOLEAN              bCountAlloc
    )
/*++

Routine Description:

    Determines whether a particular adapter should be permitted to allocate a new packet
    from a particular pool. Implements our quota algorithm.

    This can be called either to pre-approve an actual memory allocation or to check if
    an adapter should be permitted to refer to a base packet in constructing a child
    wrapper packet

Arguments:

    type                    Type of packet pAdapt wishes to allocate or refer to
    pAdapt                  The adapter involved

    bCountAlloc             Whether this is a check before an actual allocation. If it
                            is, the global usage counts will be incremented within the
                            gQuotaLock spin lock so everything is atomic

Return Value:

    TRUE        :       The adapter is permitted to allocate / refer
    FALSE       :       The adapter is not permitted to allocate / refer

--*/
{
    BOOLEAN                 rc;
    PADAPTER_QUOTA          pQuota = QUOTA_FROM_ADAPTER(pAdapt);
    UINT                    index = INDEX_FROM_TYPE(type);

    // Freeze this value for the duration of the function
    ULONG                   numAdapters = gNumAdapters;

    NdisAcquireSpinLock( &gQuotaLock );

    if( (numAdapters > 0) && (pQuota->UsedPackets[index] < (gMaxPackets[index] - gSafetyBuffer[index]) / numAdapters) )
    {
        // This adapter is under its "fair share"; it can allocate if there are actually
        // any packets left!

        if( gUsedPackets[index] < gMaxPackets[index] )
        {
            // There are packets left. This is the normal case.
            rc = TRUE;
        }
        else if( gUsedPackets[index] == gMaxPackets[index] )
        {
            // This should be unusual; we've blown past our safety buffer. Hopefully this is
            // transitory.
            ExInterlockedAddLargeStatistic( &gStatOverflows[index], 1L );
            rc = FALSE;
        }
        else
        {
            // This should never happen; it means we have allocated more than we should be able
            // to.
            SAFEASSERT( FALSE );
            rc = FALSE;
        }
    }
    else
    {
        // This adapter is over its "fair share"; it can allocate only if there are more packets
        // left than the safety buffer calls for

        if( gMaxPackets[index] - gUsedPackets[index] > gSafetyBuffer[index] )
        {
            rc = TRUE;
        }
        else
        {
            // We're too close to the wire; deny the request.
            rc = FALSE;
        }
    }

    if( rc )
    {
        pQuota->UsedPackets[index]++;

        if( bCountAlloc )
        {
            // The caller will allocate. Count the allocation before releasing the spin lock.
            gUsedPackets[index]++;

#if DBG
            // Keep track of the maximum used packets
            if( gMaxUsedPackets[index] < gUsedPackets[index] )
            {
                gMaxUsedPackets[index] = gUsedPackets[index];
            }
#endif
        }
    }

    NdisReleaseSpinLock( &gQuotaLock );
    return rc;
}

PNDIS_PACKET
BrdgBufGetNewCopyPacket(
    OUT PPACKET_INFO        *pppi
    )
/*++

Routine Description:

    Allocates a brand new packet from the copy-packet pool. Every copy packet comes with
    an associated data buffer large enough to hold a complete Ethernet frame, so the allocation
    attempt has several steps

Arguments:

    pppi                    The packet's info block, or NULL if the allocation fails

Return Value:

    The new packet

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi = NULL;

    // Try to allocate a packet and info block from our underlying pools
    pPacket = BrdgBufCommonGetNewPacket( gCopyPacketPoolHandle, &ppi );

    if( (pPacket == NULL) || (ppi == NULL) )
    {
        SAFEASSERT( (pPacket == NULL) && (ppi == NULL) );
    }
    else
    {
        PVOID           pBuf;

        // Allocate a copy buffer for the packet
        pBuf = NdisAllocateFromNPagedLookasideList( &gCopyBufferList );

        if( pBuf == NULL )
        {
            NdisFreePacket( pPacket );
            NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
            ppi = NULL;
            pPacket = NULL;
        }
        else
        {
            NDIS_STATUS     Status;
            PNDIS_BUFFER    pBuffer;

            // Allocate a buffer descriptor for the copy buffer
            NdisAllocateBuffer( &Status, &pBuffer, gCopyBufferPoolHandle, pBuf, MAX_PACKET_SIZE );

            if( Status != NDIS_STATUS_SUCCESS )
            {
                NdisFreePacket( pPacket );
                NdisFreeToNPagedLookasideList( &gPktInfoList, ppi );
                NdisFreeToNPagedLookasideList( &gCopyBufferList, pBuf );
                ppi = NULL;
                pPacket = NULL;
            }
            else
            {
                SAFEASSERT( pBuffer != NULL );
                NdisChainBufferAtFront( pPacket, pBuffer );
            }
        }
    }

    *pppi = ppi;
    return pPacket;
}

PNDIS_PACKET
BrdgBufCommonGetNewPacket(
    IN NDIS_HANDLE          Pool,
    OUT PPACKET_INFO        *pppi
    )
/*++

Routine Description:

    Common logic for allocating a brand new packet from either the wrapper pool or the copy pool.
    Every packet of any flavor comes with an associated info block. Both the alloc of the
    packet descriptor and the info block must succeed for the packet allocation to succeed.

Arguments:

    Pool                    The pool to allocate from
    pppi                    The allocated info block or NULL if the alloc failed

Return Value:

    The new packet or NULL if the alloc failed

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi = NULL;
    NDIS_STATUS             Status;

    // Try to allocate a new packet descriptor
    NdisAllocatePacket( &Status, &pPacket, Pool );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        *pppi = NULL;
        return NULL;
    }

    SAFEASSERT( pPacket != NULL );

    if (pPacket)
    {
        // Try to allocate a new packet info block
        ppi = NdisAllocateFromNPagedLookasideList( &gPktInfoList );

        if( ppi == NULL )
        {
            NdisFreePacket( pPacket );
            pPacket = NULL;
        }
        else
        {
            ppi->pOwnerPacket = pPacket;
        }
    }

    *pppi = ppi;
    return pPacket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgbuf.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgbuf.h

Abstract:

    Ethernet MAC level bridge.
    Buffer management section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#include "brdgpkt.h"

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

typedef enum
{
    BrdgOwnCopyPacket,
    BrdgOwnWrapperPacket,
    BrdgNotOwned
} PACKET_OWNERSHIP;

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgBufDriverInit();

VOID
BrdgBufCleanup();

PNDIS_PACKET
BrdgBufGetBaseCopyPacket(
    OUT PPACKET_INFO        *pppi
    );

VOID
BrdgBufFreeWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi,
    IN PADAPT               pQuotaOwner
    );

VOID
BrdgBufFreeBaseCopyPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    );

VOID
BrdgBufFreeBaseWrapperPacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    );

BOOLEAN
BrdgBufAssignBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    );

VOID
BrdgBufReleaseBasePacketQuota(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    );

PNDIS_PACKET
BrdgBufGetWrapperPacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pAdapt
    );

NDIS_STATUS
BrdgBufChainCopyBuffers(
    IN PNDIS_PACKET         pTargetPacket,
    IN PNDIS_PACKET         pSourcePacket
    );

PACKET_OWNERSHIP
BrdgBufGetPacketOwnership(
    IN PNDIS_PACKET         pPacket
    );

VOID
BrdgBufGetStatistics(
    PBRIDGE_BUFFER_STATISTICS   pStats
    );


// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Retrieves the first NDIS_BUFFER chained to a given packet (NULL if none)
//
__forceinline
PNDIS_BUFFER
BrdgBufPacketHeadBuffer(
    IN PNDIS_PACKET         pPacket
    )
{
    PNDIS_BUFFER            pBuffer = NULL;
    SAFEASSERT( pPacket != NULL );
    if (pPacket)
    {
        NdisQueryPacket( pPacket, NULL, NULL, &pBuffer, NULL );
    }
    return pBuffer;
}

//
// Retrieves the total size of all buffers chained to a packet
//
__forceinline
UINT
BrdgBufTotalPacketSize(
    IN PNDIS_PACKET         pPacket
    )
{
    UINT                    size = 0;
    SAFEASSERT( pPacket != NULL );
    if (pPacket)
    {
        NdisQueryPacket( pPacket, NULL, NULL, NULL, &size );
    }
    return size;
}

//
// Retrieves the virtual address of the data in the first buffer chained
// to a packet (holds the Ethernet header)
//
__forceinline
PVOID
BrdgBufGetPacketHeader(
    IN PNDIS_PACKET         pPacket
    )
{
    PNDIS_BUFFER            pBuffer = NULL;
    PVOID                   pHeader = NULL;
    UINT                    Length = 0;

    SAFEASSERT( pPacket != NULL );
    if (pPacket)
    {
        pBuffer = BrdgBufPacketHeadBuffer( pPacket );
    }
    SAFEASSERT( pBuffer != NULL );
    if (pBuffer)
    {
        NdisQueryBufferSafe( pBuffer, &pHeader, &Length, NormalPagePriority );
    }
    SAFEASSERT( pHeader != NULL );
    return pHeader;
}

//
// Unchains and frees all buffers chained to a given packet
//
__forceinline
VOID
BrdgBufUnchainCopyBuffers(
    IN PNDIS_PACKET         pPacket
    )
{
    PNDIS_BUFFER            pCurBuf;

    if (pPacket)
    {
        NdisUnchainBufferAtFront( pPacket, &pCurBuf );

        while( pCurBuf != NULL )
        {
            NdisFreeBuffer( pCurBuf );
            NdisUnchainBufferAtFront( pPacket, &pCurBuf );
        }
    }
}

//
// Determines whether this packet was allocated from our copy pool
//
__forceinline
BOOLEAN
BrdgBufIsCopyPacket(
    IN PNDIS_PACKET         pPacket
    )
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);
    return  (BOOLEAN)(Own == BrdgOwnCopyPacket);
}

//
// Determines whether this packet was allocated from our wrapper pool
//
__forceinline
BOOLEAN
BrdgBufIsWrapperPacket(
    IN PNDIS_PACKET         pPacket
    )
{
    PACKET_OWNERSHIP        Own = BrdgBufGetPacketOwnership(pPacket);
    return (BOOLEAN)(Own == BrdgOwnWrapperPacket);
}

//
// Initializes an ADAPTER_QUOTA structure
//
__forceinline
VOID
BrdgBufInitializeQuota(
    IN PADAPTER_QUOTA   pQuota
    )
{
    pQuota->UsedPackets[0] = pQuota->UsedPackets[1] = 0L;
}

// DO NOT use this variable directly outside of BrdgBuf.c
extern NDIS_HANDLE gWrapperBufferPoolHandle;

//
// Allocates an NDIS_BUFFER from our pool
//
__forceinline
PNDIS_BUFFER
BrdgBufAllocateBuffer(
    IN PVOID            p,
    IN UINT             len
    )
{
    PNDIS_BUFFER        pBuf;
    NDIS_STATUS         Status;

    NdisAllocateBuffer( &Status, &pBuf, gWrapperBufferPoolHandle, p, len );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(BUF, ("Failed to allocate a MDL in BrdgBufAllocateBuffer: %08x\n", Status));
        return NULL;
    }

    return pBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgcomp.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    brdgcomp.c

Abstract:

    Ethernet MAC level bridge.
    Compatibility-Mode section

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    September 2000 - Original version

Notes

    Currently, this code only works with traditional Ethernet framing (dest, src, ethertype).
    Much of the code would need to be changed to support IEEE 802.3-style framing
    (dest, src, size, LLC DSAP, LLC SSAP, LLC type).

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>

// TCPIP.SYS structure definitions
#include <ipinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgcomp.h"

#include "brdgfwd.h"
#include "brdgbuf.h"

// ===========================================================================
//
// TYPES
//
// ===========================================================================

// An IPv4 address
typedef UINT32      IPADDRESS;
typedef PUINT32     PIPADDRESS;

// Types of ARP packets
typedef enum
{
    ArpRequest,
    ArpReply
} ARP_TYPE;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

// Size of the payload of an IPv4 ARP packet
#define SIZE_OF_ARP_DATA            28      // bytes

// Total size of an IPv4 ARP packet, including framing
#define SIZE_OF_ARP_PACKET          (SIZE_OF_ARP_DATA + ETHERNET_HEADER_SIZE)

// Size of a basic IPv4 header, not including options
#define SIZE_OF_BASIC_IP_HEADER     20      // bytes

// Minimum amount of frame data we need to parse the IP header
#define MINIMUM_SIZE_FOR_IP         (ETHERNET_HEADER_SIZE + SIZE_OF_BASIC_IP_HEADER)

// Size of a basic UDP header
#define SIZE_OF_UDP_HEADER          8       // bytes

// Minimum size of the payload of a BOOTP packet
#define SIZE_OF_BASIC_BOOTP_PACKET  236     // bytes

// The IP Ethertype
const USHORT IP_ETHERTYPE         = 0x0800;

// The ARP Ethertype
const USHORT ARP_ETHERTYPE        = 0x0806;

// The UDP IP protocol type
const UCHAR UDP_PROTOCOL          = 0x11;

// Number of hash buckets in the IP and pending-ARP tables. This must
// be a power of 2 for our hash function to work propery.
#define NUM_HASH_BUCKETS            256

// Number of hash buckets for the pending-DHCP table. This
// must be a power of 2 for our hash function to work properly.
#define NUM_DHCP_HASH_BUCKETS       32

// The "shift factor" for our IP next-hop cache. The number of entries
// in the cache is 2 ^ (this number)
#define HOP_CACHE_SHIFT_FACTOR      8               // 256 cache entries

// Default size cap for the IP forwarding table
#define DEFAULT_MAX_IP_TABLE_SIZE   (500 * 1024)    // 500K in bytes

// Name of the registry parameter that optionally specifies the max table size
const PWCHAR                        gMaxIPTableSizeParameterName = L"MaxIPTableSize";

// Default size cap for the pending-ARP table
#define DEFAULT_MAX_ARP_TABLE_SIZE  (100 * 1024)    // 100K in bytes

// Name of the registry parameter that optionally specifies the max table size
const PWCHAR                        gMaxARPTableSizeParameterName = L"MaxARPTableSize";

// Default size cap for the pending-DHCP table
#define DEFAULT_MAX_DHCP_TABLE_SIZE (50 * 1024)     // 50K in bytes

// Name of the registry parameter that optionally specifies the max table size
const PWCHAR                        gMaxDHCPTableSizeParameterName = L"MaxDHCPTableSize";

//
// Timeout length for IP forwarding table entries
//
// This should be somewhat longer than the time it takes hosts to age out
// their ARP table entries, since we learn the location of IP hosts
// by ARP traffic. Current Windows implementations age out their
// ARP table entries after 2 minutes if there has been no traffic from
// the station corresponding to the entry.
//
// We keep our forwarding table entries alive indefinitely as long as we
// continue to see IP traffic from the hosts we have information about.
// Windows implementations will age out their ARP entries under those
// conditions after 20mins or so.
//
#define MAX_IP_ENTRY_AGE            (5 * 60 * 1000)     // 5 minutes in ms

//
// Timeout length for pending-ARP table entries
//
// This should be somewhat longer than the maximum time hosts will wait to
// hear the results of an ARP discovery before timing out. Windows boxes
// have a giveup time of 1s.
//
// Note that it is not destructive to deliver ARP reply packets to a station
// after it has given up or even after its initial discovery was
// satisfied.
//
#define MAX_ARP_ENTRY_AGE           (10 * 1000)         // 10 seconds

//
// Timeout length for pending-DHCP table entries
//
// RFC 2131 mentions that clients may wait as long as 60 seconds for an
// ACK. Have the timeout be somewhat longer than even that.
//
#define MAX_DHCP_ENTRY_AGE          (90 * 1000)         // 1 1/2 minutes

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

// Structure to express the information carried in ARP packets
typedef struct _ARPINFO
{

    ARP_TYPE            type;
    IPADDRESS           ipSource, ipTarget;
    UCHAR               macSource[ETH_LENGTH_OF_ADDRESS];
    UCHAR               macTarget[ETH_LENGTH_OF_ADDRESS];

} ARPINFO, *PARPINFO;

// Structure to express the information carried in an IP header
typedef struct _IP_HEADER_INFO
{

    UCHAR               protocol;
    IPADDRESS           ipSource, ipTarget;
    USHORT              headerSize;

} IP_HEADER_INFO, *PIP_HEADER_INFO;

// Structure of our IP forwarding hash table entries
typedef struct _IP_TABLE_ENTRY
{

    HASH_TABLE_ENTRY    hte;        // Required for hash table use

    // Protects the following fields
    NDIS_SPIN_LOCK      lock;

    PADAPT              pAdapt;
    UCHAR               macAddr[ETH_LENGTH_OF_ADDRESS];

} IP_TABLE_ENTRY, *PIP_TABLE_ENTRY;

//
// Structure of the pending-ARP table keys. We want this to get
// packet into 8 bytes.
//
typedef struct _ARP_TABLE_KEY
{
    IPADDRESS           ipTarget;
    IPADDRESS           ipReqestor;
} ARP_TABLE_KEY, *PARP_TABLE_KEY;

// Structure of our pending-ARP hash table entries
typedef struct _ARP_TABLE_ENTRY
{

    HASH_TABLE_ENTRY    hte;        // Required for hash table use

    // Protects the following fields
    NDIS_SPIN_LOCK      lock;

    // Information on the station that was trying to discover this host
    // The discovering station's IP address is part of the entry key.
    PADAPT              pOriginalAdapt;
    UCHAR               originalMAC[ETH_LENGTH_OF_ADDRESS];

} ARP_TABLE_ENTRY, *PARP_TABLE_ENTRY;

// Structure of our DHCP-relay table entries
typedef struct _DHCP_TABLE_ENTRY
{
    HASH_TABLE_ENTRY    hte;        // Required for hash table use

    // Protects the following fields
    NDIS_SPIN_LOCK      lock;

    UCHAR               requestorMAC[ETH_LENGTH_OF_ADDRESS];
    PADAPT              pRequestorAdapt;
} DHCP_TABLE_ENTRY, *PDHCP_TABLE_ENTRY;

// Structure for deferring an ARP packet transmission
typedef struct _DEFERRED_ARP
{
    ARPINFO             ai;
    PADAPT              pTargetAdapt;
} DEFERRED_ARP, *PDEFERRED_ARP;

// Per-adapter rewriting function
typedef VOID (*PPER_ADAPT_EDIT_FUNC)(PUCHAR, PADAPT, PVOID);

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

//
// Whether or not there are *any* compatibility-mode adapters in our list
// at the moment. Is updated in the protocol module with a write lock
// held on the global adapter list
//
BOOLEAN                         gCompatAdaptersExist = FALSE;

//
// Our list of the bridge machine's IP addresses (passed down through an
// OID). The list is allocated on the heap and is protected by
// gLocalIPAddressLock.
//
PIPADDRESS                      gLocalIPAddressList = NULL;
ULONG                           gLocalIPAddressListLength = 0L;
NDIS_RW_LOCK                    gLocalIPAddressListLock;

//
// The IP address-based forwarding table
//
PHASH_TABLE                     gIPForwardingTable;

//
// Our table to hold pending ARP requests so we can proxy back replies
//
PHASH_TABLE                     gPendingARPTable;

//
// Our table to hold pending DHCP requests so we can translate DHCP packets
// appropriately (the MAC address of the requesting station is carried
// in a DHCP request and has to be edited when we relay it)
//
PHASH_TABLE                     gPendingDHCPTable;

//
// A cache of IP next-hop information to avoid hammering the IP drivers's
// route table
//
CACHE                           gNextHopCache;

// Special IP address indicating a negative cache entry (we tried previously
// and got no answer)
const IPADDRESS                 NO_ADDRESS = 0xFFFFFFFF;

// Whether we have an overall MAC address for the bridge miniport yet
BOOLEAN                         gCompHaveMACAddress = FALSE;

// Our overall MAC address (cached here instead of calling the miniport
// section all the time to increase perf)
UCHAR                           gCompMACAddress[ETH_LENGTH_OF_ADDRESS];

// Pointers and handles for interacting with TCP
HANDLE                          gTCPFileHandle = NULL;
PFILE_OBJECT                    gTCPFileObject = NULL;
PDEVICE_OBJECT                  gTCPDeviceObject = NULL;

// Pointers and handles for interacting with IP
HANDLE                          gIPFileHandle = NULL;
PFILE_OBJECT                    gIPFileObject = NULL;
PDEVICE_OBJECT                  gIPDeviceObject = NULL;

// Lock to protect the references above
NDIS_SPIN_LOCK                  gTCPIPLock;

// IRP posted to TCPIP for notifications of when the route table changes.
// Manipulated with InterlockedExchange.
PIRP                            gIPRouteChangeIRP = NULL;

// Refcount to allow us to block and wait when people are using the TCP
// driver
WAIT_REFCOUNT                   gTCPIPRefcount;

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

BOOLEAN
BrdgCompDecodeARPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     dataLen,
    OUT PARPINFO                pARPInfo
    );

VOID
BrdgCompTransmitARPPacket(
    IN PADAPT                   pAdapt,
    IN PARPINFO                 pARPInfo
    );

BOOLEAN
BrdgCompDecodeIPHeader(
    IN PUCHAR                   pHeader,
    OUT PIP_HEADER_INFO         piphi
    );

BOOLEAN
BrdgCompProcessOutboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    );

BOOLEAN
BrdgCompProcessOutboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    );

BOOLEAN
BrdgCompProcessInboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    );

BOOLEAN
BrdgCompProcessInboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    );

VOID
BrdgCompTransmitDeferredARP(
    IN PVOID                    pData
    );

BOOLEAN
BrdgCompProcessInboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   pBootPData
    );

BOOLEAN
BrdgCompProcessOutboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt,
    IN PUCHAR                   pBootPData,
    IN PIP_HEADER_INFO          piphi
    );

BOOLEAN
BrdgCompIsUnicastIPAddress(
    IN IPADDRESS        ip
    );

VOID
BrdgCompAttachToTCPIP(
    IN PVOID            ignored
    );

VOID
BrdgCompDetachFromTCPIP(
    IN PVOID            ignored
    );

BOOLEAN
BrdgCompIsLocalIPAddress(
    IN IPADDRESS                ipAddr
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
//  This retrieves the Ethertype of an Ethernet frame from a pointer
//  to its header.
//
__forceinline
USHORT
BrdgCompGetEtherType(
    IN PUCHAR           pEtherHeader
    )
{
    USHORT              retVal;

    // The two bytes immediately following the source and destination addresses
    // encode the Ethertype, most significant byte first.
    retVal = 0L;
    retVal |= (pEtherHeader[2 * ETH_LENGTH_OF_ADDRESS]) << 8;
    retVal |= pEtherHeader[2 * ETH_LENGTH_OF_ADDRESS + 1];

    return retVal;
}

//
// Transmits a packet on an adapter after rewriting the source MAC address
// to be the adapter's own MAC address.
//
// The caller relinquishes ownership of the packet with this call.
//
__forceinline
VOID
BrdgCompSendPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt
    )
{
    // Rewrite the source MAC address to be our address
    ETH_COPY_NETWORK_ADDRESS(pPacketData + ETH_LENGTH_OF_ADDRESS, pAdapt->MACAddr);
    BrdgFwdSendPacketForCompat(pPacket, pAdapt);
}

//
// Transmits a packet, dealing with an optional editing function if one is
// present
//
__forceinline
VOID
BrdgCompEditAndSendPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt,
    IN PPER_ADAPT_EDIT_FUNC     pFunc,
    IN PVOID                    pData
    )
{
    if( pFunc != NULL )
    {
        (*pFunc)(pPacketData, pAdapt, pData);
    }

    BrdgCompSendPacket( pPacket, pPacketData, pAdapt );
}

//
// Transmits a packet, dealing with the possibility that we are not allowed to
// retain the packet and setting the destination MAC address to a specified
// value
//
// Returns whether the input packet was retained
//
__inline
BOOLEAN
BrdgCompEditAndSendPacketOrPacketCopy(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pDestMAC,
    IN PADAPT                   pAdapt,
    IN PPER_ADAPT_EDIT_FUNC     pFunc,
    IN PVOID                    pData
    )
{
    UINT                        dataLen;

    SAFEASSERT( (pPacket != NULL) && (pPacketData != NULL) );

    if( !bCanRetain )
    {
        // We aren't allowed to use the original packet. Make a copy.
        pPacket = BrdgFwdMakeCompatCopyPacket(pPacket, &pPacketData, &dataLen, FALSE);
    }

    if( (pPacket != NULL) && (pPacketData != NULL) )
    {
        // Poke the destination MAC address
        ETH_COPY_NETWORK_ADDRESS(pPacketData, pDestMAC);
        BrdgCompEditAndSendPacket(pPacket, pPacketData, pAdapt, pFunc, pData);
    }

    // If we were allowed to retain the packet, we did.
    return bCanRetain;
}

//
// Indicates a packet to the local machine. If the target MAC address was previously
// the adapter's hardware MAC address, it is rewritten to the bridge adapter's
// overall MAC address.
//
// The caller relinquishes ownership of the packet with this call.
//
__inline
VOID
BrdgCompIndicatePacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt          // Receiving adapter
    )
{
    // No packet indications can occur until we have a MAC address
    if( gCompHaveMACAddress )
    {
        UINT                    Result;

        // See if this frame was targeted at this adapter's MAC address.
        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pPacketData, pAdapt->MACAddr, &Result);

        if( Result == 0 )
        {
            ETH_COPY_NETWORK_ADDRESS( pPacketData, gCompMACAddress );
        }
        else
        {
            // We expect to only be indicating frames unicast to this machine
            // or sent to bcast / multicast hardware addresses.
            SAFEASSERT( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) );
        }

        BrdgFwdIndicatePacketForCompat( pPacket );
    }
}

//
// Indicates a packet to the local machine, making a copy of the packet if
// necessary.
//
__inline
BOOLEAN
BrdgCompIndicatePacketOrPacketCopy(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN BOOLEAN                  bCanRetain,
    IN PADAPT                   pAdapt,
    IN PPER_ADAPT_EDIT_FUNC     pEditFunc,
    IN PVOID                    pData
    )
{
    if( bCanRetain )
    {
        if( pEditFunc != NULL )
        {
            (*pEditFunc)(pPacketData, LOCAL_MINIPORT, pData);
        }

        BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );
    }
    else
    {
        UINT                    packetLen;

        // Make our own copy of the packet for indication
        pPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pPacketData, &packetLen, FALSE );

        if( pPacket != NULL )
        {
            if( pEditFunc != NULL )
            {
                (*pEditFunc)(pPacketData, LOCAL_MINIPORT, pData);
            }

            BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );
        }
        else
        {
            DBGPRINT(COMPAT, ("Failed to acquire a packet for indication in BrdgCompIndicatePacketOrPacketCopy\n"));
        }
    }

    // If we were allowed to retain the packet, we did.
    return bCanRetain;
}

//
// The IP and UDP checksums treat the data they are checksumming as a
// sequence of 16-bit words. The checksum is carried as the bitwise
// inverse of the actual checksum (~C). The formula for calculating
// the new checksum as transmitted, ~C', given that a 16-bit word of
// the checksummed data has changed from w to w' is
//
//      ~C' = ~C + w + ~w' (addition in ones-complement)
//
// This function returns the updated checksum given the original checksum
// and the original and new values of a word in the checksummed data.
//
__forceinline
USHORT
BrdgCompRecalcChecksum(
    IN USHORT                   oldChecksum,
    IN USHORT                   oldWord,
    IN USHORT                   newWord
    )
{
    ULONG                       sum;

    sum = oldChecksum + oldWord + ((~(newWord)) & 0xFFFF);
    return (USHORT)((sum & 0xFFFF) + (sum >> 16));
}

//
// Rewrites a BootP packet so the client MAC address in the packet payload
// is the given new MAC address
//
__inline
BrdgCompRewriteBootPClientAddress(
    IN PUCHAR                   pPacketData,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   newMAC
    )
{
    USHORT                      checkSum;
    PUCHAR                      pBootPData, pCheckSum, pDestMAC, pSrcMAC;
    UINT                        i;

    // The BOOTP packet lives right after the UDP header
    pBootPData = pPacketData + ETHERNET_HEADER_SIZE + piphi->headerSize + SIZE_OF_UDP_HEADER;

    // The checksum lives at offset 7 in the UDP packet.
    pCheckSum = pPacketData + ETHERNET_HEADER_SIZE + piphi->headerSize + 6;
    checkSum = 0;
    checkSum = pCheckSum[0] << 8;
    checkSum |= pCheckSum[1];

    // Replace the client's hardware address, updating the checksum as we go.
    // The client's hardware address lives at offset 29 in the BOOTP packet
    pSrcMAC = newMAC;
    pDestMAC = &pBootPData[28];

    for( i = 0 ; i < ETH_LENGTH_OF_ADDRESS / 2; i++ )
    {
        checkSum = BrdgCompRecalcChecksum( checkSum,
                                           (USHORT)(pDestMAC[0] << 8 | pDestMAC[1]),
                                           (USHORT)(pSrcMAC[0] << 8 | pSrcMAC[1]) );

        pDestMAC[0] = pSrcMAC[0];
        pDestMAC[1] = pSrcMAC[1];

        pDestMAC += 2;
        pSrcMAC += 2;
    }

    // Write the new checksum back out
    pCheckSum[0] = (UCHAR)(checkSum >> 8);
    pCheckSum[1] = (UCHAR)(checkSum & 0xFF);
}

//
// Rewrites an oubound ARP packet so the source MAC address carried in the payload
// matches the MAC address of the outbound adapter
//
VOID
BrdgCompRewriteOutboundARPPacket(
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt,
    IN PVOID                    ignored
    )
{
    //
    // Rewrite the source MAC address so it is the MAC address of the adapter the
    // request is going out on.
    //
    pPacketData[22] = pAdapt->MACAddr[0];
    pPacketData[23] = pAdapt->MACAddr[1];
    pPacketData[24] = pAdapt->MACAddr[2];
    pPacketData[25] = pAdapt->MACAddr[3];
    pPacketData[26] = pAdapt->MACAddr[4];
    pPacketData[27] = pAdapt->MACAddr[5];

    // Leave the rewriting of the MAC address in the actual Ethernet header to
    // BrdgCompSendPacket(), which always overwrites the source MAC address
    // with the adapter's MAC address.
}

//
// Provides a PDEVICE_OBJECT and a PFILE_OBJECT that can be used to talk to
// TCPIP.SYS. Returns TRUE if a channel is open and the pointers can be used,
// FALSE otherwise.
//
__inline
BOOLEAN
BrdgCompAcquireTCPIP(
    OUT PDEVICE_OBJECT OPTIONAL     *pTCPpdo,
    OUT PFILE_OBJECT OPTIONAL       *pTCPpfo,
    OUT PDEVICE_OBJECT OPTIONAL     *pIPpdo,
    OUT PFILE_OBJECT OPTIONAL       *pIPpfo
    )
{
    BOOLEAN             rc = FALSE;

    if( BrdgIncrementWaitRef(&gTCPIPRefcount) )
    {
        NdisAcquireSpinLock( &gTCPIPLock );

        SAFEASSERT( gTCPDeviceObject != NULL );
        SAFEASSERT( gTCPFileHandle != NULL );
        SAFEASSERT( gTCPFileObject != NULL );
        SAFEASSERT( gIPFileHandle != NULL );
        SAFEASSERT( gIPDeviceObject != NULL );
        SAFEASSERT( gIPFileObject != NULL );

        if( pTCPpdo != NULL )
        {
            *pTCPpdo = gTCPDeviceObject;
        }

        if( pTCPpfo != NULL )
        {
            *pTCPpfo = gTCPFileObject;
        }

        if( pIPpdo != NULL )
        {
            *pIPpdo = gIPDeviceObject;
        }

        if( pIPpfo != NULL )
        {
            *pIPpfo = gIPFileObject;
        }

        rc = TRUE;
        NdisReleaseSpinLock( &gTCPIPLock );
    }

    return rc;
}

//
// Releases the refcount on our connection to the TCPIP driver after a
// previous call to BrdgCompAcquireTCPIP().
//
__inline
VOID
BrdgCompReleaseTCPIP()
{
    BrdgDecrementWaitRef( &gTCPIPRefcount );
}

// ====================================================================
//
// These small helper functions would be inline except we need to pass
// pointers to them
//
// ====================================================================

//
// Rewrites a BootP packet for a particular adapter
//
VOID
BrdgCompRewriteBootPPacketForAdapt(
    IN PUCHAR                   pPacketData,
    IN PADAPT                   pAdapt,
    IN PVOID                    pData
    )
{
    PIP_HEADER_INFO             piphi = (PIP_HEADER_INFO)pData;

    //
    // pAdapt can be LOCAL_MINIPORT if we're being used to edit a packet
    // for indication to the local machine. No rewriting is necessary
    // in that case.
    //
    if( pAdapt != LOCAL_MINIPORT )
    {
        SAFEASSERT( pAdapt != NULL );
        BrdgCompRewriteBootPClientAddress( pPacketData, piphi, pAdapt->MACAddr );
    }
}

//
// Hashes an IP address. Used for the IP forwarding table as well as
// the pending-ARP table, which uses an extended key made up of
// the target IP address and the requesting station's IP address
//
ULONG
BrdgCompHashIPAddress(
    IN PUCHAR                   pKey
    )
{
    // Our hash function consists of taking the lower portion of the IP
    // address. The number of hash buckets has to be a power of 2 for
    // this to work propery.
    return (*(PULONG)pKey) & (NUM_HASH_BUCKETS - 1);
}

//
// Hashes a DHCP transaction id
//
ULONG
BrdgCompHashXID(
    IN PUCHAR                   pXid
    )
{
    // Our hash function consists of taking the lower portion of the
    // XID. The number of hash buckets has to be a power of 2 for
    // this to work propery.
    return (*(PULONG)pXid) & (NUM_DHCP_HASH_BUCKETS - 1);
}

//
// Returns true if the given IP table entry refers to a certain
// adapter
BOOLEAN
BrdgCompIPEntriesMatchAdapter(
    IN PHASH_TABLE_ENTRY        phte,
    IN PVOID                    pData
    )
{
    PADAPT                      pAdapt = (PADAPT)pData;
    PIP_TABLE_ENTRY             pipte = (PIP_TABLE_ENTRY)phte;

    // Don't take the spin lock since we're doing a single read,
    // which we ASSUME to be atomic.
    return (BOOLEAN)(pipte->pAdapt == pAdapt);
}

//
// Returns true if the given ARP table entry refers to a certain
// adapter
//
BOOLEAN
BrdgCompARPEntriesMatchAdapter(
    IN PHASH_TABLE_ENTRY        phte,
    IN PVOID                    pData
    )
{
    PADAPT                      pAdapt = (PADAPT)pData;
    PARP_TABLE_ENTRY            pate = (PARP_TABLE_ENTRY)phte;

    // Don't take the spin lock since we're doing a single read,
    // which we ASSUME to be atomic.
    return (BOOLEAN)(pate->pOriginalAdapt == pAdapt);
}

//
// Returns true if the given DHCP table entry refers to a certain
// adapter
//
BOOLEAN
BrdgCompDHCPEntriesMatchAdapter(
    IN PHASH_TABLE_ENTRY        phte,
    IN PVOID                    pData
    )
{
    PADAPT                      pAdapt = (PADAPT)pData;
    PDHCP_TABLE_ENTRY           pdhcpte = (PDHCP_TABLE_ENTRY)phte;

    // Don't take the spin lock since we're doing a single read,
    // which we ASSUME to be atomic.
    return (BOOLEAN)(pdhcpte->pRequestorAdapt == pAdapt);
}

//
// Completion function for route lookup IRPs. Returns
// STATUS_MORE_PROCESSING_REQUIRED to prevent the IO manager
// from mucking with the IRP (which we free ourselves).
//
NTSTATUS
BrdgCompCompleteRouteLookupIRP(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pirp,
    IN PVOID            ignored
    )
{
    IoFreeIrp( pirp );
    return STATUS_MORE_PROCESSING_REQUIRED;
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgCompDriverInit()
/*++

Routine Description:

    Driver-initialization function for the compatibility module

Arguments:

    None

Return Value:

    Status. Anything other than STATUS_SUCCESS aborts the driver load.

--*/
{
    ULONG           MaxSize, MaxEntries;

    // Initialize the next-hop cache
    if( BrdgInitializeCache(&gNextHopCache, HOP_CACHE_SHIFT_FACTOR) != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE NEXT-HOPE CACHE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // See if the registry specifies a max table size for the IP table
    if( BrdgReadRegDWord(&gRegistryPath, gMaxIPTableSizeParameterName, &MaxSize) != STATUS_SUCCESS )
    {
        MaxSize = DEFAULT_MAX_IP_TABLE_SIZE;
    }

    MaxEntries =  MaxSize / sizeof(IP_TABLE_ENTRY);
    DBGPRINT(COMPAT, ("Capping IP forwarding table at %i entries (%i bytes of memory)\n", MaxEntries, MaxSize));

    gIPForwardingTable = BrdgHashCreateTable( BrdgCompHashIPAddress, NUM_HASH_BUCKETS, sizeof(IP_TABLE_ENTRY),
                                              MaxEntries, MAX_IP_ENTRY_AGE, MAX_IP_ENTRY_AGE, sizeof(IPADDRESS) );

    if( gIPForwardingTable == NULL )
    {
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE IP TABLE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Our Pending-ARP table uses ARP_TABLE_KEY structures as a key, but we still use the BrdgCompHashIPAddress
    // routine to hash the keys. This will result in the hash being based on the first part of the key alone (the
    // target IP address), which is what we want, since all the entries for a single target must end up in the
    // same bucket for our multi-match retrieval to work.
    //

    // See if the registry specifies a max table size for the ARP table
    if( BrdgReadRegDWord(&gRegistryPath, gMaxARPTableSizeParameterName, &MaxSize) != STATUS_SUCCESS )
    {
        MaxSize = DEFAULT_MAX_ARP_TABLE_SIZE;
    }

    MaxEntries =  MaxSize / sizeof(ARP_TABLE_ENTRY);
    DBGPRINT(COMPAT, ("Capping Pending-ARP table at %i entries (%i bytes of memory)\n", MaxEntries, MaxSize));
    gPendingARPTable = BrdgHashCreateTable( BrdgCompHashIPAddress, NUM_HASH_BUCKETS, sizeof(ARP_TABLE_ENTRY),
                                            MaxEntries, MAX_ARP_ENTRY_AGE, MAX_ARP_ENTRY_AGE, sizeof(ARP_TABLE_KEY) );

    if( gPendingARPTable == NULL )
    {
        BrdgHashFreeHashTable( gIPForwardingTable );
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE ARP TABLE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // See if the registry specifies a max table size for the DHCP table
    if( BrdgReadRegDWord(&gRegistryPath, gMaxDHCPTableSizeParameterName, &MaxSize) != STATUS_SUCCESS )
    {
        MaxSize = DEFAULT_MAX_DHCP_TABLE_SIZE;
    }

    MaxEntries =  MaxSize / sizeof(DHCP_TABLE_ENTRY);
    DBGPRINT(COMPAT, ("Capping Pending-DHCP table at %i entries (%i bytes of memory)\n", MaxEntries, MaxSize));
    gPendingDHCPTable = BrdgHashCreateTable( BrdgCompHashXID, NUM_DHCP_HASH_BUCKETS, sizeof(DHCP_TABLE_ENTRY),
                                             MaxEntries, MAX_DHCP_ENTRY_AGE, MAX_DHCP_ENTRY_AGE, sizeof(ULONG) );

    if( gPendingDHCPTable == NULL )
    {
        BrdgHashFreeHashTable( gIPForwardingTable );
        BrdgHashFreeHashTable( gPendingARPTable );
        DBGPRINT(COMPAT, ("FAILED TO ALLOCATE DHCP TABLE!\n"));
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0L, 0L, NULL, 0L, NULL );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize synchronization objects
    NdisInitializeReadWriteLock( &gLocalIPAddressListLock );
    NdisAllocateSpinLock( &gTCPIPLock );
    BrdgInitializeWaitRef( &gTCPIPRefcount, FALSE );

    // We start out with no connection to TCPIP so the waitref needs to be in the shutdown state
    BrdgShutdownWaitRefOnce( &gTCPIPRefcount );

    return STATUS_SUCCESS;
}

VOID
BrdgCompCleanup()
/*++

Routine Description:

    One-time cleanup for the compatibility module

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_STATE          LockState;

    // Detach from TCPIP
    BrdgCompDetachFromTCPIP(NULL);

    // Dump the next-hop cache
    BrdgFreeCache( &gNextHopCache );

    // Dump the forwarding hash table
    BrdgHashFreeHashTable( gIPForwardingTable );
    gIPForwardingTable = NULL;

    // Dump the pending-ARP hash table
    BrdgHashFreeHashTable( gPendingARPTable );
    gPendingARPTable = NULL;

    // Dump the pending-DHCP table
    BrdgHashFreeHashTable( gPendingDHCPTable );
    gPendingDHCPTable = NULL;

    // Clean up the list of network addresses.
    NdisAcquireReadWriteLock( &gLocalIPAddressListLock, TRUE /*Read-Write*/, &LockState );

    if( gLocalIPAddressListLength > 0L )
    {
        NdisFreeMemory( gLocalIPAddressList, gLocalIPAddressListLength, 0 );
        gLocalIPAddressList = NULL;
        gLocalIPAddressListLength = 0L;
    }

    NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );
}

VOID
BrdgCompScrubAdapter(
                     IN PADAPT           pAdapt
                     )
/*++

Routine Description:

    Removes all table entries that refer to a given adapter; called when that
    adapter is being removed (future references to this adapter are illegal)

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINT(COMPAT, ("Scrubbing Adapter %p from the compatibility tables...\n", pAdapt));
    
    // Remove all entries referencing this adapter from the IP table
    BrdgHashRemoveMatching( gIPForwardingTable, BrdgCompIPEntriesMatchAdapter, pAdapt );
    
    // Remove all entries referencing this adapter from the pending-ARP table
    BrdgHashRemoveMatching( gPendingARPTable, BrdgCompARPEntriesMatchAdapter, pAdapt );
    
    // Remove all entries referencing this adapter from the DHCP table
    BrdgHashRemoveMatching( gPendingDHCPTable, BrdgCompDHCPEntriesMatchAdapter, pAdapt );
}

VOID BrdgCompScrubAllAdapters()
/*++

Routine Description:

    This function cleans all the adapters from the IP tables (this is in the case of a GPO changing
    our bridging settings)
  
Arguments:

    None

Return Value:

    None

--*/
{
    PADAPT                      pAdapt = NULL;
    LOCK_STATE                  LockStateAdapterList;
    
    //
    // We don't want an adapter to go away while we're running through the list of adapters.
    //
    NdisAcquireReadWriteLock(&gAdapterListLock, FALSE /* Read Only */, &LockStateAdapterList);
    
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Scrub the adapter from the Compatibility tables.
        BrdgCompScrubAdapter(pAdapt);
    }
    
    NdisReleaseReadWriteLock(&gAdapterListLock, &LockStateAdapterList);
}


VOID
BrdgCompNotifyMACAddress(
    IN PUCHAR           pBridgeMACAddr
    )
/*++

Routine Description:

    Called by the miniport module to notify us of the MAC address of the miniport

Arguments:

    pBridgeMACAddr      Our MAC address

Return Value:

    None

--*/
{
    ETH_COPY_NETWORK_ADDRESS( &gCompMACAddress, pBridgeMACAddr );
    gCompHaveMACAddress = TRUE;
}

BOOLEAN
BrdgCompRequiresCompatWork(
    IN PADAPT           pAdapt,
    IN PUCHAR           pPacketData,
    IN UINT             dataSize
    )
/*++

Routine Description:

    Called during the processing of inbound packets to determine whether a
    packet will require compatibility-mode work.

    The compatibility code requires that its packets be flat, whereas packets
    indicated from underlying miniports can be arbitrarily fragmented. The
    forwarding engine uses the result of this call to determine whether an
    inbound packet must be copied to a flat data buffer in a copy packet that
    we own or whether it can be handled along fast-track paths that don't
    care about packet fragmentation.

Arguments:

    pAdapt              Adapter on which the packet was received
    pPacketDataq        A pointer to the beginning of the packet data
    dataSize            The amount of data pointed to

Return Value:

    TRUE: The forwarding engine should call BrdgCompProcessInboundPacket at
    a later time to process this packet

    FALSE: BrdgCompProcessInboundPacket should never be called for this packet

--*/
{
    UINT                result;
    USHORT              etherType;

    // Weird runty packets are of no use to anyone
    if( dataSize < ETHERNET_HEADER_SIZE )
    {
        return FALSE;
    }

    //
    // No compatibility-mode work is required if there are no compatibility-mode
    // adapters.
    //
    if( !gCompatAdaptersExist )
    {
        return FALSE;
    }

    // All frames that arrive on a compatibility adapter are processed
    if( pAdapt->bCompatibilityMode )
    {
        return TRUE;
    }

    // Broadcast or multicast frames always require compatibility processing
    if( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
    {
        return TRUE;
    }

    //
    // The packet was unicast. If it wasn't sent to the adapter's MAC address,
    // it does not require compatibility-mode processing.
    //
    ETH_COMPARE_NETWORK_ADDRESSES_EQ( pPacketData, pAdapt->MACAddr, &result );

    if( result != 0 )
    {
        return FALSE;
    }

    //
    // The packet is only of interest if it is ARP or IP (on a non-compat
    // adapter)
    //
    etherType = BrdgCompGetEtherType( pPacketData );
    return (BOOLEAN)( (etherType == ARP_ETHERTYPE) || (etherType == IP_ETHERTYPE) );
}

BOOLEAN
BrdgCompProcessInboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pAdapt,
    IN BOOLEAN          bCanRetain
    )
/*++

Routine Description:

    Called to hand an inbound packet to the compatibility module for processing.

    If the packet arrived on a non-compatibility adapter, the compatibility
    code should NEVER indicate the packet, as that will be done by the
    regular forwarding engine code. On the other hand, if the packet
    arrived on a compatibility-mode adapter, the compatibility code MUST
    indicate the packet if appropriate. Why the disparity? A packet
    arriving on a compatibility adapter will likely require editing before
    indication, whereas a packet arriving on a non-compatibility adapter
    will not.

    The compatibility module may retain the packet if bCanRetain is TRUE
    (in which case we must return TRUE). If bCanRetain is FALSE, the
    compatibility code may NOT retain the packet. If it needs to forward
    the packet data or indicate the packet, it must make a copy
    packet and use that instead of the original.

Arguments:

    pPacket             The received packet
    pAdapt              The adapter the packet was received on
    bCanRetain          Whether we can hang on to the packet

Return Value:

    TRUE: The packet was retained (should never be returned if bCanRetain == FALSE)
    The caller should not use this packet or attempt to free it.

    FALSE: The packet was not retained. The caller still has ownership of the
    packet and should arrange for it to be freed when appropriate.

--*/
{
    PNDIS_BUFFER        pBuffer;
    PUCHAR              pBufferData;
    UINT                bufferLen = 0;
    UINT                totLen;
    USHORT              etherType;
    BOOLEAN             bRetained;

    NdisGetFirstBufferFromPacketSafe( pPacket, &pBuffer, &pBufferData, &bufferLen,
                                      &totLen, NormalPagePriority );

    if( pBufferData == NULL )
    {
        // The packet was empty or the system is under severe memory pressure
        // We didn't retain the packet.
        return FALSE;
    }

    if( totLen < ETHERNET_HEADER_SIZE )
    {
        return FALSE;
    }

    // The packet should be flat
    SAFEASSERT( totLen == bufferLen );
    etherType = BrdgCompGetEtherType( pBufferData );

    if( etherType == ARP_ETHERTYPE )
    {
        bRetained = BrdgCompProcessInboundARPPacket( pPacket, pAdapt, bCanRetain, pBufferData, bufferLen );
    }
    else
    {
        bRetained = BrdgCompProcessInboundNonARPPacket( pPacket, pAdapt, bCanRetain, pBufferData, bufferLen );
    }

    if( !bCanRetain )
    {
        SAFEASSERT( !bRetained );
    }

    return bRetained;
}


VOID
BrdgCompProcessOutboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pTargetAdapt
    )
/*++

Routine Description:

    Called to hand an outbound packet to the compatibility module for processing.

    Because the packet passed to us is from an overlying protocol driver, we
    are not allowed to do anything with it. The packet may be arbitrarily
    fragmented, and its data buffers must be treated as read-only.

    This function is only called if a packet is bound for an adapter in
    compatibility mode (so we can do any necessary packet editing) or for a packet
    for which we have no known outbound adapter (i.e., it is a packet we are
    flooding).

    In the case that pTargetAdapt == NULL (a flood), the compatibility code is
    responsible for sending the packet out all *compatibility mode* adapters.
    Sending the packet out regular-mode adapters is the job of the regular
    code in the forwarding engine.

Arguments:

    pPacket             The outbound packet
    pTargetAdapt        The target adapter, as determined by a previous lookup in
                        the MAC forwarding table. This can be NULL to indicate
                        a flood.

Return Value:

    None

--*/
{
    PNDIS_PACKET        pCopyPacket;
    PUCHAR              pCopyPacketData;
    UINT                copyPacketSize;

    // There's no point in calling us for a packet that is bound for a MAC
    // address which is known to be reachable on a non-compat adapter
    SAFEASSERT( (pTargetAdapt == NULL) || (pTargetAdapt->bCompatibilityMode) );

    // There is no work to do if there are no compatibility adapters
    if( !gCompatAdaptersExist )
    {
        return;
    }

    // Prepare the flattened copy packet so our functions can edit
    // the packet as appropriate. The packet will be counted as a local-source
    // transmission when / if it is used.
    pCopyPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pCopyPacketData, &copyPacketSize, TRUE );

    if( pCopyPacket != NULL )
    {
        BOOLEAN             bRetained = FALSE;

        if( copyPacketSize >= ETHERNET_HEADER_SIZE )
        {
            USHORT              etherType;

            etherType = BrdgCompGetEtherType(pCopyPacketData);

            if( etherType == ARP_ETHERTYPE )
            {
                bRetained = BrdgCompProcessOutboundARPPacket(pCopyPacket, pCopyPacketData, copyPacketSize, pTargetAdapt);
            }
            else
            {
                bRetained = BrdgCompProcessOutboundNonARPPacket(pCopyPacket, pCopyPacketData, copyPacketSize, pTargetAdapt);
            }
        }
        // else the packet was really small!

        if( ! bRetained )
        {
            // The functions above decided not to hang on to the packet after all.
            // Release it.
            BrdgFwdReleaseCompatPacket( pCopyPacket );
        }
    }
    // Else we didn't get a packet
}


VOID
BrdgCompNotifyNetworkAddresses(
    IN PNETWORK_ADDRESS_LIST    pAddressList,
    IN ULONG                    infoLength
    )
/*++

Routine Description:

    Called by the miniport code when we get an OID indicating our network-layer
    addresses to us. We copy out the list of our IP addresses. The buffer
    passed to us can also be formatted in such a way as to indicate that we
    should dump our list of network addresses.

Arguments:

    pAddressList                The data buffer passed down in the OID
    infoLength                  The size of the buffer

Return Value:

    None

--*/
{
    PIPADDRESS                  pOldList;
    UINT                        oldListLength;
    LOCK_STATE                  LockState;

    if( infoLength < sizeof(NETWORK_ADDRESS_LIST) - sizeof(NETWORK_ADDRESS) )
    {
        // The structure is too small to hold anything interesting.
        return;
    }

    if( pAddressList->AddressCount > 0 )
    {
        USHORT                          i, numAddresses, copiedAddresses = 0;
        NETWORK_ADDRESS UNALIGNED       *pNetAddress;
        NDIS_STATUS                     Status;
        PIPADDRESS                      pNewList;

        //
        // Make sure the structure can hold the number of addresses it claims to.
        // NETWORK_ADDRESS_LIST is defined with one NETWORK_ADDRESS at its tail,
        // so knock one off pAddressList->AddressCount when calculating the
        // size of the total structure.
        //
        if( infoLength < sizeof(NETWORK_ADDRESS_LIST) +
                         ( sizeof(NETWORK_ADDRESS) * (pAddressList->AddressCount - 1) ) )
        {
            // The structure is too small to contain the number of addresses
            // it claims to.

            SAFEASSERT( FALSE );
            return;
        }

        // Make a first pass to count the number of IP addresses in the list
        pNetAddress = pAddressList->Address;

        for( i = 0, numAddresses = 0; i < pAddressList->AddressCount; i++ )
        {
            if( pNetAddress->AddressType == NDIS_PROTOCOL_ID_TCP_IP )
            {
                numAddresses++;
            }

            pNetAddress = (NETWORK_ADDRESS UNALIGNED*)(((PUCHAR)pNetAddress) + pNetAddress->AddressLength);
        }

        if( numAddresses == 0 )
        {
            // There are no IP addresses in this list. Nothing to do.
            return;
        }

        // Allocate enough room to hold the addresses
        Status = NdisAllocateMemoryWithTag( &pNewList, sizeof(IPADDRESS) * numAddresses, 'gdrB' );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(COMPAT, ("NdisAllocateMemoryWithTag failed while recording IP address list\n"));

            // Clobber the old list with a NULL, since we know that the old list is outdated,
            // but we failed to record the new info
            pNewList = NULL;
        }
        else
        {
            SAFEASSERT( pNewList != NULL );

            // Copy the IP addresses to our list
            pNetAddress = pAddressList->Address;

            for( i = 0; i < pAddressList->AddressCount; i++ )
            {
                if( pNetAddress->AddressType == NDIS_PROTOCOL_ID_TCP_IP )
                {
                    NETWORK_ADDRESS_IP UNALIGNED    *pIPAddr;
                    PUCHAR                           pIPNetAddr;

                    SAFEASSERT( copiedAddresses < numAddresses );

                    pIPAddr = (NETWORK_ADDRESS_IP UNALIGNED*)&pNetAddress->Address[0];
                    pIPNetAddr = (PUCHAR)&pIPAddr->in_addr;

                    // IP passes down the IP address in the opposite byte order that we use
                    pNewList[copiedAddresses] = 0L;
                    pNewList[copiedAddresses] |= pIPNetAddr[3];
                    pNewList[copiedAddresses] |= pIPNetAddr[2] << 8;
                    pNewList[copiedAddresses] |= pIPNetAddr[1] << 16;
                    pNewList[copiedAddresses] |= pIPNetAddr[0] << 24;

                    DBGPRINT(COMPAT, ("Noted local IP address %i.%i.%i.%i\n",
                                      pIPNetAddr[0], pIPNetAddr[1], pIPNetAddr[2], pIPNetAddr[3] ));

                    copiedAddresses++;
                }

                pNetAddress = (NETWORK_ADDRESS UNALIGNED*)(((PUCHAR)pNetAddress) + pNetAddress->AddressLength);
            }

            SAFEASSERT( copiedAddresses == numAddresses );
        }

        // Swap in the new list (even if it's NULL)
        NdisAcquireReadWriteLock( &gLocalIPAddressListLock, TRUE /*Read-write*/, &LockState );

        pOldList = gLocalIPAddressList;
        oldListLength = gLocalIPAddressListLength;

        gLocalIPAddressList = pNewList;

        if( pNewList != NULL )
        {
            gLocalIPAddressListLength = sizeof(IPADDRESS) * numAddresses;
        }
        else
        {
            gLocalIPAddressListLength = 0L;
        }

        NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );

        // Ditch the old list if there was one
        if( pOldList != NULL )
        {
            SAFEASSERT( oldListLength > 0L );
            NdisFreeMemory( pOldList, oldListLength, 0 );
        }

        // Only attach to TCPIP if we actually learned some IP addresses
        if( numAddresses > 0 )
        {
            // We are at DISPATCH_LEVEL in this function. Defer the call to BrdgCompAttachToTCPIP
            // so we open a channel of communication to the TCPIP driver.
            BrdgDeferFunction( BrdgCompAttachToTCPIP, NULL );
        }
    }
    else
    {
        // This is a request to clear out our list of network-layer
        // addresses.
        if( pAddressList->AddressType == NDIS_PROTOCOL_ID_TCP_IP )
        {
            DBGPRINT(COMPAT, ("Flushing list of IP addresses\n"));

            // Dump our list of network addresses
            NdisAcquireReadWriteLock( &gLocalIPAddressListLock, TRUE /*Read-write*/, &LockState );

            pOldList = gLocalIPAddressList;
            oldListLength = gLocalIPAddressListLength;

            gLocalIPAddressList = NULL;
            gLocalIPAddressListLength = 0L;

            NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );

            if( oldListLength > 0L )
            {
                SAFEASSERT( pOldList != NULL );
                NdisFreeMemory( pOldList, oldListLength, 0 );
            }

            // Detach from the TCPIP driver at lower IRQL
            BrdgDeferFunction( BrdgCompDetachFromTCPIP, NULL );
        }
    }
}

// ===========================================================================
//
// PRIVATE UTILITY FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgCompRouteChangeCompletion(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                pirp,
    PVOID               Context
    )
/*++

Routine Description:

    Called when the IRP we post to TCPIP.SYS completes, indicating a change
    in the IP routing table

Arguments:

    DeviceObject        Unused
    pirp                The completed IRP
    Context             Unused


Return Value:

    STATUS_SUCCESS, indicating we are done with this IRP
    STATUS_MORE_PROCESSING_REQUIRED when we reuse this IRP by reposting it

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PDEVICE_OBJECT          pdo;
    PFILE_OBJECT            pfo;

    DBGPRINT(COMPAT, ("IP route table changed; flushing route cache.\n"));

    // Flush the route cache
    BrdgClearCache( &gNextHopCache );

    //
    // If gIPRouteChangeIRP != pirp, it indicates that we are either detached
    // from TCPIP (gIPRouteChangeIRP == NULL) or we have detached and
    // reattached (gIPRouteChangeIRP != NULL && gIPRouteChangeIRP != pirp).
    // In either case, we should stop reusing this IRP to post route-change
    // notification requests.
    //
    if( (gIPRouteChangeIRP == pirp) && (BrdgCompAcquireTCPIP(NULL, NULL, &pdo, &pfo)) )
    {
        NTSTATUS            status;

        //
        // Reinitialize the IRP structure and submit it again
        // for further notification.
        //

        pirp->Cancel = FALSE;
        pirp->IoStatus.Status = 0;
        pirp->IoStatus.Information = 0;
        pirp->AssociatedIrp.SystemBuffer = NULL;
        IoSetCompletionRoutine( pirp, BrdgCompRouteChangeCompletion,
                                NULL, TRUE, FALSE, FALSE );

        IrpSp = IoGetNextIrpStackLocation(pirp);
        IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_IP_RTCHANGE_NOTIFY_REQUEST;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;

        status = IoCallDriver(pdo, pirp);
        BrdgCompReleaseTCPIP();

        if (!NT_SUCCESS(status))
        {
            // We failed to call TCPIP. Release the IRP.
            DBGPRINT(COMPAT, ("Failed to call TCPIP for route notification: %08x\n", status));
            return STATUS_SUCCESS;
        }
        else
        {
            // We keep the IRP since we reposted it to TCPIP
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    else
    {
        // We must be detaching or detached from TCPIP. Don't repost the IRP.
        DBGPRINT(COMPAT, ("Stopping our route change notifications...\n"));
        return STATUS_SUCCESS;
    }
}


VOID
BrdgCompAttachToTCPIP(
    IN PVOID            ignored
    )
/*++

Routine Description:

    Establishes a connection to TCPIP for sending future route-lookup requests.
    Opens a connection to the TCPIP driver and posts an IRP for route change
    notifications.

Arguments:

    ignored             ignored


Return Value:

    None

--*/
{
    NTSTATUS            status;
    HANDLE              TCPFileHandle, IPFileHandle;
    PFILE_OBJECT        pTCPFileObject, pIPFileObject;
    PDEVICE_OBJECT      pTCPDeviceObject, pIPDeviceObject;
    BOOLEAN             bAbort = FALSE;

    // Check if there is already a connection open to TCP
    if( BrdgCompAcquireTCPIP(NULL, NULL, NULL, NULL) )
    {
        BrdgCompReleaseTCPIP();
        return;
    }

    // There doesn't appear to currently be a connection to the TCPIP driver.
    // Open one.
    status = BrdgOpenDevice( DD_TCP_DEVICE_NAME, &pTCPDeviceObject, &TCPFileHandle, &pTCPFileObject );

    if( ! NT_SUCCESS(status) )
    {
        DBGPRINT(ALWAYS_PRINT, ("Couldn't open TCP device: %08x\n", status));
        return;
    }

    status = BrdgOpenDevice( DD_IP_DEVICE_NAME, &pIPDeviceObject, &IPFileHandle, &pIPFileObject );

    if( ! NT_SUCCESS(status) )
    {
        DBGPRINT(ALWAYS_PRINT, ("Couldn't open IP device: %08x\n", status));
        BrdgCloseDevice(TCPFileHandle, pTCPFileObject, pTCPDeviceObject);
        return;
    }

    NdisAcquireSpinLock( &gTCPIPLock );

    if( gTCPDeviceObject == NULL )
    {
        SAFEASSERT( gTCPFileHandle == NULL );
        SAFEASSERT( gTCPFileObject == NULL );
        SAFEASSERT( gIPDeviceObject == NULL );
        SAFEASSERT( gIPFileHandle == NULL );
        SAFEASSERT( gIPFileObject ==  NULL );

        // Swap in the info we just obtained.
        gTCPDeviceObject = pTCPDeviceObject;
        gTCPFileHandle = TCPFileHandle;
        gTCPFileObject = pTCPFileObject;
        gIPDeviceObject = pIPDeviceObject;
        gIPFileHandle = IPFileHandle;
        gIPFileObject = pIPFileObject;

        // Let people acquire the TCPIP driver
        BrdgResetWaitRef( &gTCPIPRefcount );
    }
    else
    {
        // Someone else opened TCPIP.SYS between our initial call to BrdgCompAcquireTCPIP
        // and now. This should be rather rare.
        SAFEASSERT( gTCPFileHandle != NULL );
        SAFEASSERT( gTCPFileObject != NULL );
        SAFEASSERT( gIPDeviceObject != NULL );
        SAFEASSERT( gIPFileHandle != NULL );
        SAFEASSERT( gIPFileObject !=  NULL );

        bAbort = TRUE;
    }

    NdisReleaseSpinLock( &gTCPIPLock );

    if( bAbort )
    {
        // Need to back out of the attempt to open TCPIP.SYS
        BrdgCloseDevice( TCPFileHandle, pTCPFileObject, pTCPDeviceObject );
        BrdgCloseDevice( IPFileHandle, pIPFileObject, pIPDeviceObject );
    }
    else
    {
        if( BrdgCompAcquireTCPIP(NULL, NULL, &pIPDeviceObject, &pIPFileObject) )
        {
            NTSTATUS        status;
            PIRP            pirp;

            // Set up the route-change notification IRP
            pirp = IoBuildDeviceIoControlRequest( IOCTL_IP_RTCHANGE_NOTIFY_REQUEST, pIPDeviceObject,
                                                  NULL, 0, NULL, 0, FALSE, NULL, NULL );

            if( pirp == NULL )
            {
                DBGPRINT(COMPAT, ("Failed to allocate an IRP for route-change notification!\n"));
            }
            else
            {
                if( InterlockedExchangePointer(&gIPRouteChangeIRP, pirp) != NULL )
                {
                    //
                    // Oops; someone else created an IRP to post to TCPIP at the same time as us.
                    // Abort our attempt.
                    //
                    IoCompleteRequest( pirp, IO_NO_INCREMENT );
                }
                else
                {
                    IoSetCompletionRoutine( pirp, BrdgCompRouteChangeCompletion, NULL, TRUE, FALSE, FALSE );

                    status = IoCallDriver( pIPDeviceObject, pirp );

                    if( ! NT_SUCCESS(status) )
                    {
                        DBGPRINT(COMPAT, ("Failed to post IRP to TCPIP for route-change notification: %08x\n", status));
                    }
                    else
                    {
                        DBGPRINT(COMPAT, ("Posted route-change notification request to TCPIP\n"));
                    }
                }
            }

            BrdgCompReleaseTCPIP();
        }
        // else someone shut down the connection to TCPIP very quickly after we set it up
    }
}

VOID
BrdgCompDetachFromTCPIP(
    IN PVOID            ignored
    )
/*++

Routine Description:

    Severs the current connection, if any, to TCPIP.SYS.

Arguments:

    ignored             ignored

Return Value:

    None

--*/
{
    HANDLE              TCPFileHandle, IPFileHandle;
    PFILE_OBJECT        pTCPFileObject, pIPFileObject;
    PDEVICE_OBJECT      pTCPDeviceObject, pIPDeviceObject;
    PIRP                pRouteIRP;

    // Wait for everyone to be done using the driver
    // Ignore return value because we are multi-shutdown-safe.
    BrdgShutdownWaitRef( &gTCPIPRefcount );

    // Cancel the IRP we use for route change notifications.
    pRouteIRP = InterlockedExchangePointer( &gIPRouteChangeIRP, NULL );

    // pRouteIRP can be NULL if someone is shutting down the connection
    // at the same time as us, or if the connection was already shut down
    if( pRouteIRP != NULL )
    {
        IoCancelIrp( pRouteIRP );
    }

    // Flush the route cache
    BrdgClearCache( &gNextHopCache );

    // Copy out the pointers and NULL them
    NdisAcquireSpinLock( &gTCPIPLock );
    TCPFileHandle = gTCPFileHandle;
    gTCPFileHandle = NULL;
    pTCPFileObject = gTCPFileObject;
    gTCPFileObject = NULL;
    pTCPDeviceObject = gTCPDeviceObject;
    gTCPDeviceObject = NULL;
    IPFileHandle = gIPFileHandle;
    gIPFileHandle = NULL;
    pIPFileObject = gIPFileObject;
    gIPFileObject = NULL;
    pIPDeviceObject = gIPDeviceObject;
    gIPDeviceObject = NULL;
    NdisReleaseSpinLock( &gTCPIPLock );

    // The global pointers can be NULL if someone else is shutting down the
    // connection concurrently with us, or if the connection was already
    // shut down.
    if( pTCPFileObject != NULL )
    {
        SAFEASSERT( TCPFileHandle != NULL );
        SAFEASSERT( pTCPDeviceObject != NULL );
        SAFEASSERT( IPFileHandle != NULL );
        SAFEASSERT( pIPFileObject != NULL );
        SAFEASSERT( pIPDeviceObject != NULL );

        BrdgCloseDevice( TCPFileHandle, pTCPFileObject, pTCPDeviceObject );
        BrdgCloseDevice( IPFileHandle, pIPFileObject, pIPDeviceObject );
    }
    else
    {
        SAFEASSERT( TCPFileHandle == NULL );
        SAFEASSERT( pTCPDeviceObject == NULL );
        SAFEASSERT( IPFileHandle == NULL );
        SAFEASSERT( pIPFileObject == NULL );
        SAFEASSERT( pIPDeviceObject == NULL );
    }
}

BOOLEAN
BrdgCompIsUnicastIPAddress(
    IN IPADDRESS        ip
    )
/*++

Routine Description:

    Determines whether a given IP address is a unicast address (i.e., one that
    can reasonably designate a single station)

Arguments:

    ip                  The IP address

Return Value:

    TRUE: The address appears to be a unicast address
    FALSE: The opposite is true

--*/
{
    UCHAR               highByte;

    // The broadcast address is not cool
    if( ip == 0xFFFFFFFF )
    {
        return FALSE;
    }

    // The zero address is no good
    if( ip == 0L )
    {
        return FALSE;
    }

    // Any class D (multicast) or class E (currently undefined) is similarly uncool
    highByte = (UCHAR)(ip >> 24);
    if( (highByte & 0xF0) == 0xE0 || (highByte & 0xF0) == 0xF0 )
    {
        return FALSE;
    }

    // Check each address class to see if this is a net-directed (or all-subnets)
    // broadcast
    if( (highByte & 0x80) && ((ip & 0x00FFFFFF) == 0x00FFFFFFFF) )
    {
        // Class A net-directed or all-subnets broadcast.
        return FALSE;
    }
    else if( ((highByte & 0xC0) == 0x80) && ((ip & 0x0000FFFF) == 0x0000FFFF) )
    {
        // Class B net-directed or all-subnets broadcast.
        return FALSE;
    }
    else if( ((highByte & 0xE0) == 0xC) && ((UCHAR)ip == 0xFF) )
    {
        // Class C net-directed or all-subnets broadcast.
        return FALSE;
    }

    //
    // This address appears to be OK, although note that since we have no way of
    // knowing the subnet prefix in use on the local links, we cannot detect
    // subnet-directed broadcasts.
    //
    return TRUE;
}

BOOLEAN
BrdgCompGetNextHopForTarget(
    IN IPADDRESS                ipTarget,
    OUT PIPADDRESS              pipNextHop
    )
/*++

Routine Description:

    Calls into the TCPIP.SYS driver to determine the next-hop address for a
    given target IP.

Arguments:

    ipTarget                    The target address
    pipNextHop                  Receives the next-hop address

Return Value:

    TRUE if the next-hop lookup succeeded and *pipNextHop is valid, FALSE
    otherwise.

--*/
{
    BOOLEAN                     rc = FALSE;

    // First look for the information in our next-hop cache
    *pipNextHop = BrdgProbeCache( &gNextHopCache, (UINT32)ipTarget );

    if( *pipNextHop != 0L )
    {
        if( *pipNextHop != NO_ADDRESS )
        {
            // The cache contained a valid next hop
            rc = TRUE;
        }
        else
        {
            // We asked TCPIP before about this target address and it
            // told us it doesn't know.
            rc = FALSE;
        }
    }
    else
    {
        PDEVICE_OBJECT      pdo;
        PFILE_OBJECT        pfo;

        if( BrdgCompAcquireTCPIP(&pdo, &pfo, NULL, NULL) )
        {
            PIRP            pirp;

            pirp = IoAllocateIrp( pdo->StackSize, FALSE );

            if( pirp != NULL )
            {
                TCP_REQUEST_QUERY_INFORMATION_EX    trqiBuffer;
                IPRouteLookupData                   *pRtLookupData;
                TDIObjectID                         *lpObject;
                IPRouteEntry                        routeEntry;
                PIO_STACK_LOCATION                  irpSp;
                NTSTATUS                            status;

                RtlZeroMemory (&trqiBuffer, sizeof (trqiBuffer));

                pRtLookupData = (IPRouteLookupData *)trqiBuffer.Context;
                pRtLookupData->SrcAdd  = 0;

                // IP uses the opposite byte ordering from us.
                ((PUCHAR)&pRtLookupData->DestAdd)[0] = ((PUCHAR)&ipTarget)[3];
                ((PUCHAR)&pRtLookupData->DestAdd)[1] = ((PUCHAR)&ipTarget)[2];
                ((PUCHAR)&pRtLookupData->DestAdd)[2] = ((PUCHAR)&ipTarget)[1];
                ((PUCHAR)&pRtLookupData->DestAdd)[3] = ((PUCHAR)&ipTarget)[0];

                lpObject = &trqiBuffer.ID;
                lpObject->toi_id = IP_MIB_SINGLE_RT_ENTRY_ID;
                lpObject->toi_class = INFO_CLASS_PROTOCOL;
                lpObject->toi_type = INFO_TYPE_PROVIDER;
                lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
                lpObject->toi_entity.tei_instance = 0;

                irpSp = IoGetNextIrpStackLocation(pirp);
                SAFEASSERT( irpSp != NULL );

                irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_TCP_QUERY_INFORMATION_EX;
                irpSp->DeviceObject = pdo;
                irpSp->FileObject = pfo;
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer = &trqiBuffer;
                irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(trqiBuffer);
                irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(routeEntry);

                pirp->UserBuffer = &routeEntry;
                pirp->RequestorMode = KernelMode;
                IoSetCompletionRoutine( pirp, BrdgCompCompleteRouteLookupIRP, NULL, TRUE, TRUE, TRUE );

                status = IoCallDriver( pdo, pirp );

                // STATUS_PENDING will bugcheck the machine since we passed buffers that
                // are on the stack.
                SAFEASSERT( status != STATUS_PENDING );

                if( status == STATUS_SUCCESS )
                {
                    //
                    // TCPIP signals failure by setting the interface designator
                    // on the reply to 0xFFFFFFFF
                    //
                    if( routeEntry.ire_index != 0xFFFFFFFF )
                    {
                        // IP uses the opposite byte ordering from us.
                        ((PUCHAR)pipNextHop)[3] = ((PUCHAR)&routeEntry.ire_nexthop)[0];
                        ((PUCHAR)pipNextHop)[2] = ((PUCHAR)&routeEntry.ire_nexthop)[1];
                        ((PUCHAR)pipNextHop)[1] = ((PUCHAR)&routeEntry.ire_nexthop)[2];
                        ((PUCHAR)pipNextHop)[0] = ((PUCHAR)&routeEntry.ire_nexthop)[3];

                        if( ! BrdgCompIsLocalIPAddress(*pipNextHop) )
                        {
                            // Poke the new data into the cache
                            BrdgUpdateCache( &gNextHopCache, ipTarget, *pipNextHop );
                            rc = TRUE;
                        }
                        else
                        {
                            THROTTLED_DBGPRINT(COMPAT, ("TCPIP gave a bridge IP address as next hop for %i.%i.%i.%i\n",
                                                       ((PUCHAR)&ipTarget)[3], ((PUCHAR)&ipTarget)[2], ((PUCHAR)&ipTarget)[1],
                                                       ((PUCHAR)&ipTarget)[0] ));

                            BrdgUpdateCache( &gNextHopCache, ipTarget, NO_ADDRESS );
                        }
                    }
                    else
                    {
                        // Poke a negative entry into the cache so we don't keep trying to look this up.
                        THROTTLED_DBGPRINT(COMPAT, ("TCPIP found no route entry for %i.%i.%i.%i\n", ((PUCHAR)&ipTarget)[3], ((PUCHAR)&ipTarget)[2],
                                                   ((PUCHAR)&ipTarget)[1], ((PUCHAR)&ipTarget)[0] ));

                        BrdgUpdateCache( &gNextHopCache, ipTarget, NO_ADDRESS );
                    }
                }
                else
                {
                    DBGPRINT(COMPAT, ("TPCIP failed route lookup IRP: %08x\n", status));
                }
            }
            else
            {
                DBGPRINT(COMPAT, ("Failed to allocate an IRP in BrdgCompGetNextHopForTarget!\n"));
            }

            // We are done talking to TCPIP
            BrdgCompReleaseTCPIP();
        }
        // else no open channel to TCPIP
    }

    return rc;
}

BOOLEAN
BrdgCompIsLocalIPAddress(
    IN IPADDRESS                ipAddr
    )
/*++

Routine Description:

    Determines whether a given IP address is one of our local addresses.

Arguments:

    ipAddr                      The address

Return Value:

    TRUE if the given address is on our list of local addresses, FALSE
    otherwise

--*/
{
    LOCK_STATE                  LockState;
    ULONG                       i;
    PIPADDRESS                  pAddr = (PIPADDRESS)gLocalIPAddressList;
    BOOLEAN                     bFound = FALSE;

    NdisAcquireReadWriteLock( &gLocalIPAddressListLock, FALSE/*Read only*/, &LockState );

    // There should be an integral number of IP addresses in the list!
    SAFEASSERT( (gLocalIPAddressListLength % sizeof(IPADDRESS)) == 0 );
    SAFEASSERT( (gLocalIPAddressListLength == 0) || (gLocalIPAddressList != NULL) );

    for( i = 0L; i < gLocalIPAddressListLength / sizeof(IPADDRESS); i++ )
    {
        if( pAddr[i] == ipAddr )
        {
            bFound = TRUE;
            break;
        }
    }

    NdisReleaseReadWriteLock( &gLocalIPAddressListLock, &LockState );

    return bFound;
}


BOOLEAN
BrdgCompSendToMultipleAdapters(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pOriginalAdapt,
    IN PUCHAR                   pPacketData,
    IN BOOLEAN                  bCanRetain,
    IN BOOLEAN                  bAllAdapters,
    IN PPER_ADAPT_EDIT_FUNC     pEditFunc,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Sends a packet (or a copy thereof) to multiple adapters. Usually used to send around
    a broadcast packet.

Arguments:

    pPacket                     The packet to send (or to send a copy of)
    pOriginalAdapt              The adapter the packet was originally received on (so
                                    we can skip it). This can be NULL
    pPacketData                 A pointer to the packet's data buffer
    bCanRetain                  Whether we can retain the packet
    bAllAdapters                TRUE: Send to all adapters FALSE: send only to
                                    adapters in compatibility mode
    pEditFunc                   Optional function that gets called before sending to
                                    each adapter (to edit the packet)
    pData                       Cookie to pass to pEditFunc as context

Return Value:

    TRUE if pPacket was retained, FALSE otherwise

--*/
{
    UINT                        numTargets = 0L, i;
    PADAPT                      pAdapt;
    PADAPT                      SendList[MAX_ADAPTERS];
    LOCK_STATE                  LockState;
    BOOLEAN                     bSentOriginal = FALSE;   // Whether we have sent the packet we were given yet

    //
    // First we need a list of the adapters we intend to send this packet to
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

    // Note each adapter to send to
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Don't need to acquire the global adapter characteristics lock to read the
        // media state because we don't care about the global consistency of the
        // adapters' characteristics here
        if( (pAdapt != pOriginalAdapt) &&
            (pAdapt->MediaState == NdisMediaStateConnected) &&  // Don't send to disconnected adapters
            (pAdapt->State == Forwarding) &&                    // Adapter must be in relaying state
            (! pAdapt->bResetting) )                            // Adapter must not be resetting
        {
            // If we're not trying to send to every single adapter, make sure
            // this one is in compatibility mode
            if( bAllAdapters || (pAdapt->bCompatibilityMode) )
            {
                if( numTargets < MAX_ADAPTERS )
                {
                    // We will use this adapter outside the list lock; bump its refcount
                    BrdgAcquireAdapterInLock(pAdapt);
                    SendList[numTargets] = pAdapt;
                    numTargets++;
                }
                else
                {
                    // Too many copies to send!
                    SAFEASSERT( FALSE );
                }
            }
        }
    }

    // Can let go of the adapter list now; we have copied out all the target adapters
    // and incremented the refcount for the adapters we will be using.
    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    for( i = 0; i < numTargets; i++ )
    {
        PNDIS_PACKET            pPacketToSend;
        PUCHAR                  pPacketToSendData;

        if( bCanRetain && (! bSentOriginal) && (i == (numTargets - 1)) )
        {
            //
            // Use the packet we were given.
            // We must do this only with the last adapter since we need to be
            // able to copy from it for every adapter before the last one.
            //
            pPacketToSend = pPacket;
            pPacketToSendData = pPacketData;
            bSentOriginal = TRUE;
        }
        else
        {
            UINT                pPacketToSendSize;

            // Duplicate the original packet yet another time so we have an editable
            // copy for this target adapter
            pPacketToSend = BrdgFwdMakeCompatCopyPacket(pPacket, &pPacketToSendData, &pPacketToSendSize, FALSE);
        }

        if( pPacketToSend != NULL )
        {
            BrdgCompEditAndSendPacket( pPacketToSend, pPacketToSendData, SendList[i], pEditFunc, pData );
        }

        // Done with this adapter
        BrdgReleaseAdapter( SendList[i] );
    }

    return bSentOriginal;
}

VOID
BrdgCompRefreshOrInsertIPEntry(
    IN IPADDRESS            IPAddr,
    IN PADAPT               pAdapt,
    IN PUCHAR               pMACAddr
    )
/*++

Routine Description:

    Inserts a new entry into the IP forwarding table or refreshes an existing entry

Arguments:

    IPAddr                  The address to insert
    pAdapt                  The adapter to associate with the IP address
    pMACAddr                The MAC address to associate with the IP address

Return Value:

    None

--*/
{
    PIP_TABLE_ENTRY         pEntry;
    BOOLEAN                 bIsNewEntry;
    LOCK_STATE              LockState;

    if( BrdgCompIsUnicastIPAddress(IPAddr) )
    {
        pEntry = (PIP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gIPForwardingTable, (PUCHAR)&IPAddr,
                                                           &bIsNewEntry, &LockState );

        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // This is a brand new table entry. Initialize it.
                NdisAllocateSpinLock( &pEntry->lock );
                pEntry->pAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->macAddr, pMACAddr );

                DBGPRINT(COMPAT, ("Learned the location of %i.%i.%i.%i\n", ((PUCHAR)&IPAddr)[3], ((PUCHAR)&IPAddr)[2],
                                  ((PUCHAR)&IPAddr)[1], ((PUCHAR)&IPAddr)[0]));
            }
            else
            {
                // This is an existing entry and we may only have a read lock
                // held on the hash table. Use the entry's spin lock to protect
                // us while we monkey with the contents
                NdisAcquireSpinLock( &pEntry->lock );

                pEntry->pAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->macAddr, pMACAddr );

                NdisReleaseSpinLock( &pEntry->lock );
            }

            // Since we got a non-NULL result we must release the table lock
            NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
        }
    }
    else
    {
        //
        // We shouldn't be getting called with non-unicast source IP addresses
        //
        THROTTLED_DBGPRINT(COMPAT, ("WARNING: Not noting non-unicast source IP address %i.%i.%i.%i from adapter %p!\n",
                                    ((PUCHAR)&IPAddr)[3], ((PUCHAR)&IPAddr)[2], ((PUCHAR)&IPAddr)[1], ((PUCHAR)&IPAddr)[0],
                                    pAdapt ));
    }
}

PUCHAR
BrdgCompIsBootPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PIP_HEADER_INFO          piphi
    )
/*++

Routine Description:

    Determines whether a given packet is a BOOTP packet

Arguments:

    pPacketData                 Pointer to the packet's data buffer
    packetLen                   Amount of data at pPacketDaa
    piphi                       Info about the IP header of this packet

Return Value:

    A pointer to the BOOTP payload within the packet, or NULL if the packet was not
    a BOOTP Packet.

--*/
{
    // After the IP header, there must be enough room for a UDP header and
    // a basic BOOTP packet
    if( packetLen < ETHERNET_HEADER_SIZE + (UINT)piphi->headerSize + SIZE_OF_UDP_HEADER +
                    SIZE_OF_BASIC_BOOTP_PACKET)
    {
        return NULL;
    }

    // Protocol must be UDP
    if( piphi->protocol != UDP_PROTOCOL )
    {
        return NULL;
    }

    // Jump to the beginning of the UDP packet by skipping the IP header
    pPacketData += ETHERNET_HEADER_SIZE + piphi->headerSize;

    // The first two bytes are the source port and should be the
    // BOOTP Client port (0x0044) or the BOOTP Server port (0x0043)
    if( (pPacketData[0] != 00) ||
        ((pPacketData[1] != 0x44) && (pPacketData[1] != 0x43)) )
    {
        return NULL;
    }

    // The next two bytes are the destination port and should be the BOOTP
    // server port (0x0043) or the BOOTP client port (0x44)
    if( (pPacketData[2] != 00) ||
        ((pPacketData[3] != 0x43) && (pPacketData[3] != 0x44)) )
    {
        return NULL;
    }

    // Skip ahead to the beginning of the BOOTP packet
    pPacketData += SIZE_OF_UDP_HEADER;

    // The first byte is the op code and should be 0x01 for a request
    // or 0x02 for a reply
    if( pPacketData[0] > 0x02 )
    {
        return NULL;
    }

    // The next byte is the hardware type and should be 0x01 for Ethernet
    if( pPacketData[1] != 0x01 )
    {
        return NULL;
    }

    // The next byte is the address length and should be 0x06 for Ethernet
    if( pPacketData[2] != 0x06 )
    {
        return NULL;
    }

    // Everything checks out; this looks like a BOOTP request packet.
    return pPacketData;
}

BOOLEAN
BrdgCompDecodeIPHeader(
    IN PUCHAR                   pHeader,
    OUT PIP_HEADER_INFO         piphi
    )
/*++

Routine Description:

    Decodes basic information from the IP header (no options)

Arguments:

    pHeader                     Pointer to an IP header
    piphi                       Receives the info

Return Value:

    TRUE: header was valid
    FALSE: packet is not an IP packet

--*/
{
    // First nibble of the header encodes the packet version, which must be 4.
    if( (*pHeader >> 4) != 0x04 )
    {
        return FALSE;
    }

    // Next nibble of the header encodes the length of the header in 32-bit words.
    // This length must be at least 20 bytes or something is amiss.
    piphi->headerSize = (*pHeader & 0x0F) * 4;
    if( piphi->headerSize < 20 )
    {
        return FALSE;
    }

    // Retrieve the protocol byte (offset 10)
    piphi->protocol = pHeader[9];

    // The source IP address begins at the 12th byte (most significant byte first)
    piphi->ipSource = 0L;
    piphi->ipSource |= pHeader[12] << 24;
    piphi->ipSource |= pHeader[13] << 16;
    piphi->ipSource |= pHeader[14] << 8;
    piphi->ipSource |= pHeader[15];

    // The destination IP address is next
    piphi->ipTarget = 0L;
    piphi->ipTarget |= pHeader[16] << 24;
    piphi->ipTarget |= pHeader[17] << 16;
    piphi->ipTarget |= pHeader[18] << 8;
    piphi->ipTarget |= pHeader[19];

    return TRUE;
}

BOOLEAN
BrdgCompDecodeARPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     dataLen,
    OUT PARPINFO                pARPInfo
    )
/*++

Routine Description:

    Decodes an ARP packet

Arguments:

    pPacketData                 Pointer to a packet's data buffer
    dataLen                     Amount of data at pPacketData
    pARPInfo                    Receives the info

Return Value:

    TRUE: packet was valid
    FALSE: packet is not an ARP packet

--*/
{
    SAFEASSERT( pPacketData != NULL );
    SAFEASSERT( pARPInfo != NULL );

    // We can't process this if it's too small
    if( dataLen < SIZE_OF_ARP_PACKET )
    {
        return FALSE;
    }

    // Check the ethertype for consistency (0x0806 is ARP)
    if( (pPacketData[12] != 0x08) || (pPacketData[13] != 0x06) )
    {
        return FALSE;
    }

    // Check the hardware type for consistency (0x0001 is classic Ethernet;
    // 802 has a seperate value)
    if( (pPacketData[14] != 0x00) || (pPacketData[15] != 0x01) )
    {
        return FALSE;
    }

    // Check the protocol type for consistency (0x0800 is IPv4)
    if( (pPacketData[16] != 0x08) || (pPacketData[17] != 0x00) )
    {
        return FALSE;
    }

    // Check the length of the hardware address for consistency (must be 6 bytes)
    if( pPacketData[18] != 0x06 )
    {
        return FALSE;
    }

    // Check the length of the protocol address for consistency (must be 4 bytes)
    if( pPacketData[19] != 0x04 )
    {
        return FALSE;
    }

    // Next two bytes are the operation (0x0001 == request, 0x0002 == reply)
    if( pPacketData[20] != 0x00 )
    {
        return FALSE;
    }

    if( pPacketData[21] == 0x01 )
    {
        pARPInfo->type = ArpRequest;
    }
    else if( pPacketData[21] == 0x02 )
    {
        pARPInfo->type = ArpReply;
    }
    else
    {
        return FALSE;
    }

    // Next 6 bytes are the sender's MAC address
    pARPInfo->macSource[0] = pPacketData[22];
    pARPInfo->macSource[1] = pPacketData[23];
    pARPInfo->macSource[2] = pPacketData[24];
    pARPInfo->macSource[3] = pPacketData[25];
    pARPInfo->macSource[4] = pPacketData[26];
    pARPInfo->macSource[5] = pPacketData[27];

    // Next 4 bytes are the sender's protocol address (most significant byte first)
    pARPInfo->ipSource = 0;
    pARPInfo->ipSource |= pPacketData[28] << 24;
    pARPInfo->ipSource |= pPacketData[29] << 16;
    pARPInfo->ipSource |= pPacketData[30] << 8;
    pARPInfo->ipSource |= pPacketData[31];

    //
    // Next 6 bytes are the target's MAC address. For a request, these bytes are
    // meaningless.
    //
    pARPInfo->macTarget[0] = pPacketData[32];
    pARPInfo->macTarget[1] = pPacketData[33];
    pARPInfo->macTarget[2] = pPacketData[34];
    pARPInfo->macTarget[3] = pPacketData[35];
    pARPInfo->macTarget[4] = pPacketData[36];
    pARPInfo->macTarget[5] = pPacketData[37];

    // Next 4 bytes are the sender's protocol address (most significant byte first)
    pARPInfo->ipTarget = 0;
    pARPInfo->ipTarget |= pPacketData[38] << 24;
    pARPInfo->ipTarget |= pPacketData[39] << 16;
    pARPInfo->ipTarget |= pPacketData[40] << 8;
    pARPInfo->ipTarget |= pPacketData[41];

    return TRUE;
}

VOID
BrdgCompTransmitDeferredARP(
    IN PVOID                    pData
    )
/*++

Routine Description:

    Transmits an ARP packet whose transmission was deferred

Arguments:

    pData                       Info on the deferred ARP packet to
                                be transmitted

Return Value:

    None

--*/
{
    PDEFERRED_ARP               pda = (PDEFERRED_ARP)pData;

    BrdgCompTransmitARPPacket( pda->pTargetAdapt, &pda->ai );

    // We incremented this adapter's refcount when setting up the
    // function deferral
    BrdgReleaseAdapter( pda->pTargetAdapt );

    // Free the memory for this request
    NdisFreeMemory( pda, sizeof(DEFERRED_ARP), 0 );
}

VOID
BrdgCompTransmitARPPacket(
    IN PADAPT                   pAdapt,
    IN PARPINFO                 pARPInfo
    )
/*++

Routine Description:

    Transmits an ARP packet

Arguments:

    pAdapt                      Adapter to transmit on
    pARPInfo                    The info to transmit as an ARP packet

Return Value:

    None

--*/
{
    NDIS_STATUS                 Status;
    UCHAR                       ARPPacket[SIZE_OF_ARP_PACKET];

    SAFEASSERT( pAdapt != NULL );
    SAFEASSERT( pARPInfo != NULL );
    SAFEASSERT( (pARPInfo->type == ArpRequest) || (pARPInfo->type == ArpReply) );

    //
    // Fill in the destination MAC address. If the operation is a discovery,
    // the target MAC address is the broadcast address. If it is a reply, the
    // target MAC address is the target machine's MAC address.
    //
    if( pARPInfo->type == ArpRequest )
    {
        ARPPacket[0] = ARPPacket[1] = ARPPacket[2] = ARPPacket[3] =
            ARPPacket[4] = ARPPacket[5] = 0xFF;
    }
    else
    {
        ARPPacket[0] = pARPInfo->macTarget[0];
        ARPPacket[1] = pARPInfo->macTarget[1];
        ARPPacket[2] = pARPInfo->macTarget[2];
        ARPPacket[3] = pARPInfo->macTarget[3];
        ARPPacket[4] = pARPInfo->macTarget[4];
        ARPPacket[5] = pARPInfo->macTarget[5];
    }

    // Fill in the source MAC address
    ARPPacket[6] = pARPInfo->macSource[0];
    ARPPacket[7] = pARPInfo->macSource[1];
    ARPPacket[8] = pARPInfo->macSource[2];
    ARPPacket[9] = pARPInfo->macSource[3];
    ARPPacket[10] = pARPInfo->macSource[4];
    ARPPacket[11] = pARPInfo->macSource[5];

    // Next 2 bytes are the EtherType (0x0806 == ARP)
    ARPPacket[12] = 0x08;
    ARPPacket[13] = 0x06;

    // Next 2 bytes are 0x0001 for classic Ethernet
    // (802 has a seperate value)
    ARPPacket[14] = 0x00;
    ARPPacket[15] = 0x01;

    // Next 2 bytes indicate that this is ARP for IPv4 traffic
    ARPPacket[16] = 0x08;
    ARPPacket[17] = 0x00;

    // Next byte indicates the length of the hardware address (6 bytes)
    ARPPacket[18] = 0x6;

    // Next byte indicates the length of the protocol address (4 bytes)
    ARPPacket[19] = 0x4;

    // Next byte is the operation (1 == request, 2 == reply)
    if( pARPInfo->type == ArpRequest )
    {
        ARPPacket[20] = 0x00;
        ARPPacket[21] = 0x01;
    }
    else
    {
        ARPPacket[20] = 0x00;
        ARPPacket[21] = 0x02;
    }

    // Next 6 bytes are the sender's MAC address (LSB first)
    ARPPacket[22] = pARPInfo->macSource[0];
    ARPPacket[23] = pARPInfo->macSource[1];
    ARPPacket[24] = pARPInfo->macSource[2];
    ARPPacket[25] = pARPInfo->macSource[3];
    ARPPacket[26] = pARPInfo->macSource[4];
    ARPPacket[27] = pARPInfo->macSource[5];

    // Next 4 bytes are the sender's protocol address (most significant byte first)
    ARPPacket[28] = (UCHAR)((pARPInfo->ipSource >> 24) & 0xFF);
    ARPPacket[29] = (UCHAR)((pARPInfo->ipSource >> 16) & 0xFF);
    ARPPacket[30] = (UCHAR)((pARPInfo->ipSource >> 8) & 0xFF);
    ARPPacket[31] = (UCHAR)(pARPInfo->ipSource & 0xFF);

    //
    // Next 6 bytes are the target's MAC address. For a request, these bytes are
    // ignored and set to zero.
    //
    if( pARPInfo->type == ArpRequest )
    {
        ARPPacket[32] = ARPPacket[33] = ARPPacket[34] = ARPPacket[35] =
            ARPPacket[36] = ARPPacket[37] = 0x00;
    }
    else
    {
        // MAC address is transmitted LSB first.
        ARPPacket[32] = pARPInfo->macTarget[0];
        ARPPacket[33] = pARPInfo->macTarget[1];
        ARPPacket[34] = pARPInfo->macTarget[2];
        ARPPacket[35] = pARPInfo->macTarget[3];
        ARPPacket[36] = pARPInfo->macTarget[4];
        ARPPacket[37] = pARPInfo->macTarget[5];
    }

    // Next 4 bytes are the target's protocol address (most significant byte first)
    ARPPacket[38] = (UCHAR)((pARPInfo->ipTarget >> 24) & 0xFF);
    ARPPacket[39] = (UCHAR)((pARPInfo->ipTarget >> 16) & 0xFF);
    ARPPacket[40] = (UCHAR)((pARPInfo->ipTarget >> 8) & 0xFF);
    ARPPacket[41] = (UCHAR)(pARPInfo->ipTarget & 0xFF);

    // Send the finished packet
    Status = BrdgFwdSendBuffer( pAdapt, ARPPacket, sizeof(ARPPacket) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(COMPAT, ("ARP packet send failed: %08x\n", Status));
    }
}

//
// pTargetAdapt comes back with incremented refcount if
// *pbIsRequest == FALSE and *pTargetAdapt != NULL
//
BOOLEAN
BrdgCompPreprocessBootPPacket(
    IN PUCHAR                   pPacketData,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   pBootPData,     // Actual BOOTP packet
    IN PADAPT                   pAdapt,         // Receiving adapt (or NULL for outbound from local machine)
    OUT PBOOLEAN                pbIsRequest,
    OUT PADAPT                 *ppTargetAdapt,  // Only if bIsRequest == FALSE
    OUT PUCHAR                  targetMAC       // Only if bIsRequest == FALSE
    )
/*++

Routine Description:

    Does preliminary processing of a BOOTP packet common to the inbound and outbound case

Arguments:

    pPacketData                 Pointer to a packet's data buffer
    piphi                       Info on the packet's IP header
    pBootPData                  Pointer to the BOOTP payload within the packet
    pAdapt                      Receiving adapter (or NULL if this packet is outbound from
                                    the local machine)
    pbIsRequest                 Receives a flag indicating if this is a BOOTP request
    ppTargetAdapt               Receives the target adapter this packet should be relayed to
                                    (only valid if bIsRequest == FALSE and return == TRUE)
    targetMAC                   The MAC address this packet should be relayed to (valid under
                                    same conditions as ppTargetAdapt)

Return Value:

    TRUE : packet was processed successfully
    FALSE : an error occured or something is wrong with the packet

--*/
{
    PDHCP_TABLE_ENTRY           pEntry;
    ULONG                       xid;
    LOCK_STATE                  LockState;

    SAFEASSERT( pbIsRequest != NULL );
    SAFEASSERT( ppTargetAdapt != NULL );
    SAFEASSERT( targetMAC != NULL );

    // Decode the xid (bytes 5 through 8)
    xid = 0L;
    xid |= pBootPData[4] << 24;
    xid |= pBootPData[5] << 16;
    xid |= pBootPData[6] << 8;
    xid |= pBootPData[7];

    // Byte 0 is the operation; 1 for a request, 2 for a reply
    if( pBootPData[0] == 0x01 )
    {
        BOOLEAN                 bIsNewEntry;

        // This is a request. We need to note the correspondence betweeen
        // this client's XID and its adapter and MAC address
        pEntry = (PDHCP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gPendingDHCPTable, (PUCHAR)&xid, &bIsNewEntry,
                                                             &LockState );

        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // Initialize the entry.
                // The client's hardware address is at offset 29
                NdisAllocateSpinLock( &pEntry->lock );
                ETH_COPY_NETWORK_ADDRESS( pEntry->requestorMAC, &pBootPData[28] );
                pEntry->pRequestorAdapt = pAdapt;   // Can be NULL for local machine

                DBGPRINT(COMPAT, ("Saw new DHCP XID: %x\n", xid));
            }
            else
            {
                //
                // An entry already existed for this XID. This is fine if the existing information
                // matches what we're trying to record, but it's also possible that two stations
                // decided independently to use the same XID, or that the same station changed
                // apparent MAC address and/or adapter due to topology changes. Our scheme breaks
                // down under these circumstances.
                //
                // Either way, use the most recent information possible; clobber the existing
                // information with the latest.
                //

                NdisAcquireSpinLock( &pEntry->lock );

#if DBG
                {
                    UINT            Result;
                    ETH_COMPARE_NETWORK_ADDRESSES_EQ( pEntry->requestorMAC, &pBootPData[28], &Result );

                    // Warn if the data changed, as this probably signals a problem
                    if( Result != 0 )
                    {
                        DBGPRINT(COMPAT, ("[COMPAT] WARNING: Station with MAC address %02x:%02x:%02x:%02x:%02x:%02x is using DHCP XID %x at the same time as station %02x:%02x:%02x:%02x:%02x:%02x!\n",
                                          pBootPData[28], pBootPData[29], pBootPData[30], pBootPData[31], pBootPData[32], pBootPData[33],
                                          xid, pEntry->requestorMAC[0], pEntry->requestorMAC[1], pEntry->requestorMAC[2],
                                          pEntry->requestorMAC[3], pEntry->requestorMAC[4], pEntry->requestorMAC[5] ));
                    }
                    else if( pEntry->pRequestorAdapt != pAdapt )
                    {
                        DBGPRINT(COMPAT, ("[COMPAT] WARNING: Station with MAC address %02x:%02x:%02x:%02x:%02x:%02x appeared to change from adapter %p to adapter %p during DHCP request!\n",
                                           pBootPData[28], pBootPData[29], pBootPData[30],
                                           pBootPData[31], pBootPData[32], pBootPData[33],
                                           pEntry->pRequestorAdapt, pAdapt ));
                    }
                }
#endif

                ETH_COPY_NETWORK_ADDRESS( pEntry->requestorMAC, &pBootPData[28] );
                pEntry->pRequestorAdapt = pAdapt;   // Can be NULL for local machine

                NdisReleaseSpinLock( &pEntry->lock );
            }

            NdisReleaseReadWriteLock( &gPendingDHCPTable->tableLock, &LockState );
        }
        else
        {
            // This packet could not be processed
            DBGPRINT(COMPAT, ("Couldn't create table entry for BOOTP packet!\n"));
            return FALSE;
        }

        *pbIsRequest = TRUE;
        // ppTargetAdapt and targetMAC are not defined for this case
        return TRUE;
    }
    else if ( pBootPData[0] == 0x02 )
    {
        // Look up the xid for this transaction to recover the MAC address of the client
        pEntry = (PDHCP_TABLE_ENTRY)BrdgHashFindEntry( gPendingDHCPTable, (PUCHAR)&xid, &LockState );

        if( pEntry != NULL )
        {
            NdisAcquireSpinLock( &pEntry->lock );
            ETH_COPY_NETWORK_ADDRESS( targetMAC, pEntry->requestorMAC );
            *ppTargetAdapt = pEntry->pRequestorAdapt;
            NdisReleaseSpinLock( &pEntry->lock );

            //
            // We will use this adapter outside the table lock. NULL is a permissible
            // value that indicates that the local machine is the requestor for
            // this xid.
            //
            if( *ppTargetAdapt != NULL )
            {
                BrdgAcquireAdapterInLock( *ppTargetAdapt );
            }

            NdisReleaseReadWriteLock( &gPendingDHCPTable->tableLock, &LockState );
        }

        if( pEntry != NULL )
        {
            *pbIsRequest = FALSE;
            return TRUE;
        }
        else
        {
            DBGPRINT(COMPAT, ("Couldn't find a table entry for XID %x!\n", xid));
            return FALSE;
        }
    }
    else
    {
        // Someone passed us a crummy packet
        return FALSE;
    }
}


// ===========================================================================
//
// INBOUND PACKET PROCESSING
//
// ===========================================================================

VOID
BrdgCompSendProxyARPRequests(
    IN PARPINFO                 pai,
    IN PADAPT                   pOriginalAdapt,
    IN BOOLEAN                  bSendToNonCompat
    )
/*++

Routine Description:

    Floods ARP requests out appropriate adapters in response to an ARP request
    for which we did not have information about the target.

Arguments:

    pai                         Info on the inbound request
    pOriginalAdapt              Adapter the request was indicated on
    bSendToNonCompat            Whether we need to send the request to all adapters
                                    or just compatibility adapters


Return Value:

    None

--*/
{
    UINT                        numTargets = 0L, i;
    PADAPT                      pAdapt;
    PADAPT                      SendList[MAX_ADAPTERS];
    LOCK_STATE                  LockState;

    SAFEASSERT( pai->type == ArpRequest );

    //
    // First we need a list of the adapters we intend to send this packet to
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

    // Note each adapter to send to
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Don't need to acquire the global adapter characteristics lock to read the
        // media state because we don't care about the global consistency of the
        // adapters' characteristics here
        if( (pAdapt != pOriginalAdapt ) &&                      // Don't send on the original adapter
            (pAdapt->MediaState == NdisMediaStateConnected) &&  // Don't send to disconnected adapters
            (pAdapt->State == Forwarding) &&                    // Adapter must be in relaying state
            (! pAdapt->bResetting) )                            // Adapter must not be resetting
        {
            // If we're not trying to send to every single adapter, make sure
            // this one is in compatibility mode
            if( bSendToNonCompat || (pAdapt->bCompatibilityMode) )
            {
                if( numTargets < MAX_ADAPTERS )
                {
                    // We will use this adapter outside the list lock; bump its refcount
                    BrdgAcquireAdapterInLock(pAdapt);
                    SendList[numTargets] = pAdapt;
                    numTargets++;
                }
                else
                {
                    // Too many copies to send!
                    SAFEASSERT( FALSE );
                }
            }
        }
    }

    // Can let go of the adapter list now; we have copied out all the target adapters
    // and incremented the refcount for the adapters we will be using.
    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    for( i = 0; i < numTargets; i++ )
    {
        // For each adapter, the source MAC address is the adapter's MAC address
        ETH_COPY_NETWORK_ADDRESS( pai->macSource, SendList[i]->MACAddr );

        // Send the ARP request
        BrdgCompTransmitARPPacket( SendList[i], pai );

        // Done with this adapter
        BrdgReleaseAdapter( SendList[i] );
    }
}

VOID
BrdgCompAnswerPendingARP(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Sends a reply to a station that is waiting for an ARP reply. Called when we find
    an entry to this effect in our pending-ARP table.

    We do not send an ARP reply to the discovering station if it turns out that the
    station it is looking for is on the same segment as it.

Arguments:

    pEntry                      The entry in the pending-ARP table telling us about
                                    the station waiting for information

    pData                       The adapter we received an ARP reply on that
                                    triggered this operation


Return Value:

    None

--*/
{
    PARP_TABLE_ENTRY            pate = (PARP_TABLE_ENTRY)pEntry;
    PADAPT                      pReceivedAdapt = (PADAPT)pData;
    PARP_TABLE_KEY              pKey;

    pKey = (PARP_TABLE_KEY)pate->hte.key;

    if( pKey->ipReqestor != 0L )
    {
        PADAPT                  pOriginalAdapt;
        UCHAR                   originalMAC[ETH_LENGTH_OF_ADDRESS];

        // Copy the information out of the table entry
        NdisAcquireSpinLock( &pate->lock );
        pOriginalAdapt = pate->pOriginalAdapt;
        ETH_COPY_NETWORK_ADDRESS( originalMAC, pate->originalMAC );
        NdisReleaseSpinLock( &pate->lock );

        //
        // The station we just discovered must be on a different segment
        // from the discovering station for us to send back a reply.
        //
        if( pOriginalAdapt != pReceivedAdapt )
        {
            PDEFERRED_ARP           pda;
            NDIS_STATUS             Status;

            // The adapters are different. We should send a reply.
            // We need to defer the actual transmission of the reply so we
            // don't perform it with a lock held on the pending ARP
            // table.
            Status = NdisAllocateMemoryWithTag( &pda, sizeof(DEFERRED_ARP), 'gdrB' );

            if( Status == NDIS_STATUS_SUCCESS )
            {
                pda->pTargetAdapt = pOriginalAdapt;

                // We will use the adapter pointer outside the table lock
                BrdgAcquireAdapterInLock( pda->pTargetAdapt );

                pda->ai.ipTarget = pKey->ipReqestor;
                ETH_COPY_NETWORK_ADDRESS( pda->ai.macTarget, originalMAC );

                // Pretend to be the IP address the requestor is looking for
                pda->ai.ipSource = pKey->ipTarget;
                ETH_COPY_NETWORK_ADDRESS( pda->ai.macSource, pda->pTargetAdapt->MACAddr );

                pda->ai.type = ArpReply;

                // Queue up the call to BrdgCompTransmitDeferredARP
                BrdgDeferFunction( BrdgCompTransmitDeferredARP, pda );
            }
            else
            {
                // We failed the allocation. Not much we can do.
                DBGPRINT(COMPAT, ("Memory allocation failed in BrdgCompAnswerPendingARP!\n"));
            }
        }
        // else the discovering station and the station we discovered are on the same
        // adapter; don't reply.
    }
    else
    {
        // This entry exists only to indicate that the local machine is also trying to discover
        // this IP address. Ignore it.
    }
}


BOOLEAN
BrdgCompIndicateInboundARPReply(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Indicates an ARP reply to the local machine

Arguments:

    pPacket                     The ARP reply packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    PUCHAR                      pTargetMAC;
    UINT                        Result;

    if( ! bCanRetain )
    {
        // We're not allowed to use the packet we're given to indicate.
        // Allocate a new one to hold the data.
        pPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pPacketData, &packetLen, FALSE );

        if( pPacket == NULL )
        {
            // We failed to get a packet.
            return FALSE;
        }
    }

    // Rewrite the target MAC address in the ARP reply. This portion
    // of the packet is at offset 32.
    pTargetMAC = pPacketData + 32;

    // Check to see if the target MAC address is the adapter's MAC address,
    // as it should be
    ETH_COMPARE_NETWORK_ADDRESSES_EQ( pTargetMAC, pAdapt->MACAddr, &Result );

    if( Result == 0 )
    {
        // Rewrite the target MAC address to the bridge's MAC address
        ETH_COPY_NETWORK_ADDRESS( pTargetMAC, gCompMACAddress );
    }
    else
    {
        DBGPRINT(COMPAT, ("WARNING: Mismatch between frame MAC target and ARP payload target in ARP reply!\n"));
    }

    BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );

    return bCanRetain;
}

PADAPT
BrdgCompFindTargetAdapterForIPAddress(
    IN PNDIS_PACKET             pPacket)
/*++

Routine Description:

    Finds the correct target adapter based on the IP address

Arguments:

    pPacket                     The IP packet containing the address information.

Return Value:

    The TargetAdapter if we found one in the table, or NULL if we did not.

--*/
{
    PIP_TABLE_ENTRY             pipte = NULL;
    LOCK_STATE                  LockState;
    PADAPT                      TargetAdapt = NULL;
    IP_HEADER_INFO              iphi;
    PNDIS_BUFFER                pBuffer;
    PUCHAR                      pPacketData;
    UINT                        packetLen = 0;
    UINT                        totLen;
    USHORT                      etherType;
    
    NdisGetFirstBufferFromPacketSafe( pPacket, &pBuffer, &pPacketData, &packetLen,
                                      &totLen, NormalPagePriority );
    
    if( pPacketData == NULL )
    {
        // The packet was empty or the system is under severe memory pressure
        // We didn't retain the packet.
        return NULL;
    }
    
    if( totLen < ETHERNET_HEADER_SIZE )
    {
        return NULL;
    }
    
    // The packet should be flat
    SAFEASSERT( totLen == packetLen );

    etherType = BrdgCompGetEtherType( pPacketData );
    
    if( etherType == IP_ETHERTYPE )
    {   
        SAFEASSERT( (pPacket != NULL) && (pPacketData != NULL) );
    
        if( packetLen >= MINIMUM_SIZE_FOR_IP )
        {
            if( BrdgCompDecodeIPHeader(pPacketData + ETHERNET_HEADER_SIZE, &iphi) )
            {
                pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&iphi.ipTarget,
                                                            &LockState );
                if (pipte != NULL)
                {
                    TargetAdapt = pipte->pAdapt;
                    
                    // Release the table lock.
                    NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
                }
            }
        }    
    }
    return TargetAdapt;
}

BOOLEAN
BrdgCompProcessInboundARPRequest(
    IN PARPINFO                 pai,
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Processes an inbound ARP request

Arguments:

    pai                         The decoded info
    pPacket                     The ARP request packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    PIP_TABLE_ENTRY             pipte;
    LOCK_STATE                  LockState;
    BOOLEAN                     bSendReply = FALSE;

    SAFEASSERT( pai->type == ArpRequest );

    // See if we already have the target IP address in our table
    pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&pai->ipTarget,
                                                &LockState );

    if( pipte != NULL )
    {
        //
        // Compare the adapter the target is reachable on to the adapter that
        // we got the request on while we still have the table lock.
        //
        // We should only send an ARP reply if the requesting station is on
        // a different adapter than the station he is trying to discover.
        //
        bSendReply = (BOOLEAN)(pipte->pAdapt != pAdapt);

        // Release the table lock.
        NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
    }

    if( bSendReply )
    {
        IPADDRESS           ipTransmitter = pai->ipSource;

        DBGPRINT(COMPAT, ("ANSWERING ARP request for %i.%i.%i.%i\n",
                          ((PUCHAR)&pai->ipTarget)[3], ((PUCHAR)&pai->ipTarget)[2],
                          ((PUCHAR)&pai->ipTarget)[1], ((PUCHAR)&pai->ipTarget)[0] ));

        // We found the target station. Use our ARPINFO structure to build a
        // reply right back to the sending station.
        pai->type = ArpReply;

        // Pretend to be the IP station the transmitting station is asking for
        pai->ipSource = pai->ipTarget;

        // Send to the requesting station
        ETH_COPY_NETWORK_ADDRESS( pai->macTarget, pai->macSource );
        pai->ipTarget = ipTransmitter;

        // Fill in the adapter's own MAC address as the source
        ETH_COPY_NETWORK_ADDRESS( pai->macSource, pAdapt->MACAddr );

        // Transmit the answer right now!
        BrdgCompTransmitARPPacket( pAdapt, pai );
    }
    else
    {
        // We didn't find the address the transmitting station is asking for.
        // We'll need to proxy the request onto other adapters to discover
        // the target station.

        // We need to proxy onto regular adapters too if the original adapter
        // was compatibility-mode.
        BOOLEAN             bSendToNonCompat = pAdapt->bCompatibilityMode;
        PARP_TABLE_ENTRY    pEntry;
        LOCK_STATE          LockState;
        BOOLEAN             bIsNewEntry;
        ARP_TABLE_KEY       atk;

        // Record the fact that we've proxied out this request
        atk.ipReqestor = pai->ipSource;
        atk.ipTarget = pai->ipTarget;
        pEntry = (PARP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gPendingARPTable, (PUCHAR)&atk,
                                                            &bIsNewEntry, &LockState );

        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // This is a new table entry, as expected. Initialize it.
                NdisAllocateSpinLock( &pEntry->lock );
                pEntry->pOriginalAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->originalMAC, pai->macSource );
            }
            else
            {
                // There was already a pending-ARP entry for this source and target
                // IP address. Refresh the information in the entry on the slim
                // chance that the requesting machine has changed apparent MAC
                // address or adapter due to topology changes or the like.
                NdisAcquireSpinLock( &pEntry->lock );
                pEntry->pOriginalAdapt = pAdapt;
                ETH_COPY_NETWORK_ADDRESS( pEntry->originalMAC, pai->macSource );
                NdisReleaseSpinLock( &pEntry->lock );
            }

            // We are responsible for releasing the table lock since
            // BrdgHashRefreshOrInsert() came back non-NULL
            NdisReleaseReadWriteLock( &gPendingARPTable->tableLock, &LockState );
        }

        // This function twiddles the ARPINFO structure you pass it,
        // but that's OK by us.
        BrdgCompSendProxyARPRequests( pai, pAdapt, bSendToNonCompat );
    }

    // Always indicate ARP requests to the local machine so it can note the
    // information about the sender and reply if it wants.
    return BrdgCompIndicatePacketOrPacketCopy( pPacket, pPacketData, bCanRetain, pAdapt, NULL, NULL );
}

// Returns whether the packet was retained
BOOLEAN
BrdgCompProcessInboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Processes an inbound ARP packet

Arguments:

    pPacket                     The ARP request packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    ARPINFO                     ai;

    if( BrdgCompDecodeARPPacket(pPacketData, packetLen, &ai) )
    {
        BOOLEAN                 bRetained;

        // Regardless of what kind of packet this is, we always note
        // the correspondence between the sender's IP address and
        // MAC address.
        BrdgCompRefreshOrInsertIPEntry( ai.ipSource, pAdapt, ai.macSource );

        // Always see if the information we just learned would let us
        // proxy back a reply to a station doing a discovery.
        BrdgHashPrefixMultiMatch( gPendingARPTable, (PUCHAR)&ai.ipSource, sizeof(IPADDRESS),
                                  BrdgCompAnswerPendingARP, pAdapt );

        if( ai.type == ArpReply )
        {
            BOOLEAN             bIndicateReply;
            ARP_TABLE_KEY       atk;
            LOCK_STATE          LockState;

            //
            // The packet is an ARP reply.
            //

            // See if there's a table entry indicating that the local machine is trying to
            // resolve this target address
            atk.ipTarget = ai.ipSource;
            atk.ipReqestor = 0L;

            if( BrdgHashFindEntry(gPendingARPTable, (PUCHAR)&atk, &LockState) != NULL )
            {
                bIndicateReply = TRUE;
                NdisReleaseReadWriteLock( &gPendingARPTable->tableLock, &LockState );
            }
            else
            {
                bIndicateReply = FALSE;
            }

            // We can't indicate the reply if we don't have the bridge's overall
            // MAC address available
            if( bIndicateReply && gCompHaveMACAddress )
            {
                bRetained = BrdgCompIndicateInboundARPReply( pPacket, pAdapt, bCanRetain, pPacketData, packetLen );
            }
            else
            {
                bRetained = FALSE;
            }
        }
        else
        {
            //
            // The packet is an ARP request.
            //

            // This function trashes ai, but that's OK.
            bRetained = BrdgCompProcessInboundARPRequest( &ai, pPacket, pAdapt, bCanRetain, pPacketData, packetLen );
        }

        // Sanity
        if( ! bCanRetain )
        {
            SAFEASSERT( !bRetained );
        }

        return bRetained;
    }
    else
    {
        // The inbound ARP packet is somehow invalid. Process it as a regular packet
        // (which should indicate it to the local machine) in case it's carrying something
        // we don't understand.
        return BrdgCompProcessInboundNonARPPacket( pPacket, pAdapt, bCanRetain, pPacketData, packetLen );
    }
}

BOOLEAN
BrdgCompProcessInboundIPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PIP_HEADER_INFO          piphi,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PPER_ADAPT_EDIT_FUNC     pEditFunc,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Processes an inbound IP packet

Arguments:

    pPacket                     The IP packet
    piphi                       Decoded IP header information
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer
    pEditFunc                   Optional function that must be called
                                    for each adapter before transmission
    pData                       Context cookie for pEditFunc


Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bRetained;
    PIP_TABLE_ENTRY             pipte;
    LOCK_STATE                  LockState;

    //
    // We refresh our forwarding table with each IP packet we see. Find the entry
    // for this IP address
    //
    if( BrdgCompIsUnicastIPAddress(piphi->ipSource) )
    {
        pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&piphi->ipSource, &LockState );

        if( pipte != NULL )
        {
            BOOLEAN             bInfoMatches = FALSE;

            //
            // Make sure the information in this entry is correct. If it's not, we do NOT clobber the old
            // information, nor do we refresh the old entry; we want it to time out in due course.
            //
            // We only create IP forwarding table entries in response to ARP packets, as that is the only
            // officially sanctioned way of learning the correspondence between an IP address and a MAC address.
            //
            NdisAcquireSpinLock( &pipte->lock );
            if( pipte->pAdapt == pAdapt )
            {
                UINT            Result;

                ETH_COMPARE_NETWORK_ADDRESSES_EQ( pipte->macAddr, &pPacketData[ETH_LENGTH_OF_ADDRESS], &Result );

                if( Result == 0 )
                {
                    bInfoMatches = TRUE;
                }
            }
            NdisReleaseSpinLock( &pipte->lock );

            if( bInfoMatches )
            {
                // Refresh the entry
                BrdgHashRefreshEntry( (PHASH_TABLE_ENTRY)pipte );
            }
            else
            {
                // The info is mismatched; let the entry fester
                THROTTLED_DBGPRINT(COMPAT, ("WARNING: Saw a packet from %i.%i.%i.%i that did not match its forwarding table entry! Table is %02x:%02x:%02x:%02x:%02x:%02x, packet is %02x:%02x:%02x:%02x:%02x:%02x\n",
                                            ((PUCHAR)&piphi->ipSource)[3], ((PUCHAR)&piphi->ipSource)[2], ((PUCHAR)&piphi->ipSource)[1],
                                            ((PUCHAR)&piphi->ipSource)[0], pipte->macAddr[0], pipte->macAddr[1], pipte->macAddr[2],
                                            pipte->macAddr[3], pipte->macAddr[4], pipte->macAddr[5], pPacketData[ETH_LENGTH_OF_ADDRESS],
                                            pPacketData[ETH_LENGTH_OF_ADDRESS + 1], pPacketData[ETH_LENGTH_OF_ADDRESS + 2], pPacketData[ETH_LENGTH_OF_ADDRESS + 3],
                                            pPacketData[ETH_LENGTH_OF_ADDRESS + 4], pPacketData[ETH_LENGTH_OF_ADDRESS + 5] ));
            }

            NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );
        }
        else
        {
            // CONSIDER: Make a forwarding table entry here? Are there cases where this would be undesirable?
            //
            //THROTTLED_DBGPRINT(COMPAT, ("WARNING: Saw IP packet before ARP from %i.%i.%i.%i\n",
            //                            ((PUCHAR)&piphi->ipSource)[3], ((PUCHAR)&piphi->ipSource)[2], ((PUCHAR)&piphi->ipSource)[1],
            //                            ((PUCHAR)&piphi->ipSource)[0] ));
        }
    }
    else
    {
        //
        // The source IP address on this packet is to be ignored.
        // Just about the only thing we expect is the zero address
        //
        if( piphi->ipSource != 0L )
        {
            THROTTLED_DBGPRINT(COMPAT, ("Saw a packet with a non-unicast source IP address %i.%i.%i.%i on adapter %p!\n",
                                        ((PUCHAR)&piphi->ipSource)[3], ((PUCHAR)&piphi->ipSource)[2], ((PUCHAR)&piphi->ipSource)[1],
                                        ((PUCHAR)&piphi->ipSource)[0], pAdapt));
        }
    }

    //
    // Now that we have refreshed the IP forwarding table entry for the sending station,
    // figure out where to send the packet based on its destination.
    //

    // The target MAC address is the first thing in the Ethernet frame
    if( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
    {
        //
        // Packet is broadcast / multicast at the Ethernet level.
        //
        // We need to send it on all other compatibility-mode adapters
        // (and regular adapters too if this came in on a compatibility
        // adapter)
        //

        bRetained = BrdgCompSendToMultipleAdapters( pPacket, pAdapt, pPacketData,
                                                    bCanRetain && (!pAdapt->bCompatibilityMode), // TRUE == can retain
                                                    // If this is a compat adapter, send to all adapters
                                                    pAdapt->bCompatibilityMode,
                                                    pEditFunc, pData );

        if( (!bCanRetain) || (pAdapt->bCompatibilityMode) )
        {
            SAFEASSERT( !bRetained );
        }

        if( pAdapt->bCompatibilityMode )
        {
            // It's our job to indicate this packet.
            bRetained = BrdgCompIndicatePacketOrPacketCopy(pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
        }
        // else the regular-mode processing will indicate this frame
    }
    else
    {
        //
        // Packet is unicast at the Ethernet level. Verify that it's targeted at a unicast IP address.
        //
        BOOLEAN         bIsUnicast = BrdgCompIsUnicastIPAddress(piphi->ipTarget);

        if( !bIsUnicast )
        {
            //
            // Strange; this packet is unicast to us at the Ethernet level but is for a
            // broadcast, multicast or zero target IP address.
            //
            // We will have no entries for this in our forwarding table, and we assume the
            // IP stack will have no next-hop information for this address, so we just indicate
            // it right away and let the IP driver figure out what this thing is.
            //
            THROTTLED_DBGPRINT(COMPAT, ("Packet with non-unicast target IP address %i.%i.%i.%i received in unicast Ethernet frame on adapter %p",
                                        ((PUCHAR)&piphi->ipTarget)[3], ((PUCHAR)&piphi->ipTarget)[2], ((PUCHAR)&piphi->ipTarget)[1],
                                        ((PUCHAR)&piphi->ipTarget)[0], pAdapt ));

            // Process the packet below as if it were unicast to us.
        }

        if( (!bIsUnicast) || BrdgCompIsLocalIPAddress(piphi->ipTarget) )
        {
            //
            // It's only appropriate for us to indicate the packet if the adapter
            // on which the packet was received is a compatibility-mode adapter.
            // Otherwise, the packet is indicated along regular codepaths without
            // the need to edit it in any way.
            //
            if( pAdapt->bCompatibilityMode )
            {
                bRetained = BrdgCompIndicatePacketOrPacketCopy(pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
            }
            else
            {
                bRetained = FALSE;
            }
        }
        else
        {
            //
            // This packet is not for us. Look it up in our forwarding table to see if
            // we know where the target machine is.
            //
            pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&piphi->ipTarget, &LockState );

            if( pipte != NULL )
            {
                PADAPT          pTargetAdapt;
                UCHAR           targetMAC[ETH_LENGTH_OF_ADDRESS];

                // Copy out the information we need within the spin lock
                NdisAcquireSpinLock( &pipte->lock );
                pTargetAdapt = pipte->pAdapt;
                ETH_COPY_NETWORK_ADDRESS( targetMAC, pipte->macAddr );
                NdisReleaseSpinLock( &pipte->lock );

                // We will use the adapter outside the table lock
                BrdgAcquireAdapterInLock( pTargetAdapt );

                // Done with the table entry
                NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );

                // It is strange to receive traffic that needs to be retransmitted on the same adapter.
                if( pTargetAdapt == pAdapt )
                {
                    THROTTLED_DBGPRINT(COMPAT, ("WARNING: retransmitting traffic for %i.%i.%i.%i on Adapter %p\n",
                                                ((PUCHAR)&piphi->ipTarget)[3], ((PUCHAR)&piphi->ipTarget)[2],
                                                ((PUCHAR)&piphi->ipTarget)[1], ((PUCHAR)&piphi->ipTarget)[0], pAdapt));
                }

                bRetained = BrdgCompEditAndSendPacketOrPacketCopy(pPacket, pPacketData, bCanRetain, targetMAC,
                                                                  pTargetAdapt, pEditFunc, pData );

                BrdgReleaseAdapter( pTargetAdapt );
            }
            else
            {
                IPADDRESS           ipNextHop;

                //
                // This packet was unicast to us at the Ethernet level but is for an IP address
                // that isn't in our forwarding table. Assuming the transmitting station had a
                // good reason for sending us this packet, and that our forward tables are working
                // correctly and aren't corrupt, two possibilities remain:
                //
                // a) The packet needs to be routed off the subnet by the local machine (this is
                //    why the target IP address doesn't appear in our tables; one does not ARP for
                //    an off-subnet machine before transmitting to it; one sends packets to one's
                //    default gateway)
                //
                // b) The packet needs to be routed off the subnet by some other machine. Unfortunately
                //    we don't know which one, since all packets that come to us have the same target
                //    MAC address and the target IP address is no use; what we really want is the
                //    first-hop IP address.
                //
                // To sort this out, we call TCPIP to do a route lookup for the packet's target IP
                // address. If the resulting next-hop IP address appears in our forwarding table
                // (i.e., it is reachable on the bridged network), we send the packet on to that
                // destination. If TCPIP gives us no first-hop, or the first-hop isn't in our table
                // (as would occur if the next hop is reachable through some non-bridged adapter)
                // we indicate the packet so TCPIP can deal with it. In such a case, the packet is
                // either not routable (and IP will drop it) or was meant to be routed by the local
                // machine (in which case IP will route it to its next hop).
                //

                if( BrdgCompGetNextHopForTarget(piphi->ipTarget, &ipNextHop) )
                {
                    // We got a next-hop address. See if that address is in our forwarding table.
                    pipte = (PIP_TABLE_ENTRY)BrdgHashFindEntry( gIPForwardingTable, (PUCHAR)&ipNextHop, &LockState );

                    if( pipte != NULL )
                    {
                        PADAPT          pNextHopAdapt;
                        UCHAR           nextHopMAC[ETH_LENGTH_OF_ADDRESS];

                        // Must copy out the information inside the entry's spin lock
                        NdisAcquireSpinLock( &pipte->lock );
                        pNextHopAdapt = pipte->pAdapt;
                        ETH_COPY_NETWORK_ADDRESS( nextHopMAC, pipte->macAddr );
                        NdisReleaseSpinLock( &pipte->lock );

                        // We will use the adapter outside the table lock
                        BrdgAcquireAdapterInLock( pNextHopAdapt );

                        // We're done with the forwarding table
                        NdisReleaseReadWriteLock( &gIPForwardingTable->tableLock, &LockState );

                        // Something strange is afoot if the next hop is reachable through the same adapter
                        if( pNextHopAdapt == pAdapt )
                        {
                            THROTTLED_DBGPRINT(COMPAT, ("WARNING: retransmitting traffic for %i.%i.%i.%i on Adapter %p to next-hop %i.%i.%i.%i\n",
                                                        ((PUCHAR)&piphi->ipTarget)[3], ((PUCHAR)&piphi->ipTarget)[2],
                                                        ((PUCHAR)&piphi->ipTarget)[1], ((PUCHAR)&piphi->ipTarget)[0], pAdapt,
                                                        ((PUCHAR)&ipNextHop)[3], ((PUCHAR)&ipNextHop)[2],
                                                        ((PUCHAR)&ipNextHop)[1], ((PUCHAR)&ipNextHop)[0]));
                        }

                        // Send the packet out the appropriate adapter
                        bRetained = BrdgCompEditAndSendPacketOrPacketCopy(  pPacket, pPacketData, bCanRetain, nextHopMAC,
                                                                            pNextHopAdapt, pEditFunc, pData );

                        BrdgReleaseAdapter( pNextHopAdapt );
                    }
                    else
                    {
                        //
                        // The next hop isn't in our forwarding table. This means that the next hop machine
                        // isn't reachable on the bridged network, unless we're in a screwy state with
                        // respect to the transmitting machine (i.e., it never ARPed for the router it
                        // wanted because it had a static ARP entry or some other such weirdness).
                        // At any rate, conclude at this point that the local machine should handle the packet.
                        //
                        bRetained = BrdgCompIndicatePacketOrPacketCopy( pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
                    }
                }
                else
                {
                    //
                    // No usable next-hop information. Conclude that the packet should be handled by
                    // the local machine. Indicate.
                    //
                    bRetained = BrdgCompIndicatePacketOrPacketCopy( pPacket, pPacketData, bCanRetain, pAdapt, pEditFunc, pData );
                }
            }
        }
    }

    if( !bCanRetain )
    {
        SAFEASSERT( !bRetained );
    }

    return bRetained;
}

// Returns whether the packet was retained
BOOLEAN
BrdgCompProcessInboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen
    )
/*++

Routine Description:

    Processes an inbound non-ARP packet

Arguments:

    pPacket                     The packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer


Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bRetained = FALSE;
    IP_HEADER_INFO              iphi;

    SAFEASSERT( (pPacket != NULL) && (pPacketData != NULL) );

    if( packetLen >= MINIMUM_SIZE_FOR_IP )
    {
        if( BrdgCompDecodeIPHeader(pPacketData + ETHERNET_HEADER_SIZE, &iphi) )
        {
            PUCHAR              pBootPData;

            pBootPData = BrdgCompIsBootPPacket( pPacketData, packetLen, &iphi );

            if ( pBootPData != NULL )
            {
                // This is a BOOTP packet; do BOOTP-specific processing
                bRetained = BrdgCompProcessInboundBootPPacket( pPacket, pAdapt, bCanRetain, pPacketData, packetLen, &iphi, pBootPData );
            }
            else
            {
                // Do generic IP processing
                bRetained = BrdgCompProcessInboundIPPacket(pPacket, &iphi, pAdapt, bCanRetain, pPacketData, packetLen, NULL, NULL);
            }
        }
    }

    if( !bCanRetain )
    {
        SAFEASSERT( !bRetained );
    }

    return bRetained;
}

BOOLEAN
BrdgCompProcessInboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PADAPT                   pAdapt,
    IN BOOLEAN                  bCanRetain,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PIP_HEADER_INFO          piphi,
    IN PUCHAR                   pBootPData
    )
/*++

Routine Description:

    Processes an inbound BOOTP packet

Arguments:

    pPacket                     The packet
    pAdapt                      The receiving adapter
    bCanRetain                  If we can retain the packet
    pPacketData                 The packet's data buffer
    packetLen                   Size of data in buffer
    piphi                       Decoded IP header info
    pBootPData                  Pointer to BOOTP payload within the packet


Return Value:

    Whether we retained the packet

--*/
{
    UCHAR                       targetMAC[ETH_LENGTH_OF_ADDRESS];
    BOOLEAN                     bIsRequest;
    PADAPT                      pTargetAdapt = NULL;

    if( BrdgCompPreprocessBootPPacket(pPacketData, piphi, pBootPData, pAdapt, &bIsRequest, &pTargetAdapt, targetMAC) )
    {
        if( bIsRequest )
        {
            //
            // This is a request packet. It can be processed as a regular inbound IP packet,
            // subject to appropriate rewriting at each step.
            //
            SAFEASSERT( pTargetAdapt == NULL );
            return BrdgCompProcessInboundIPPacket( pPacket, piphi, pAdapt, bCanRetain, pPacketData, packetLen,
                                                   BrdgCompRewriteBootPPacketForAdapt, piphi );
        }
        else
        {
            BOOLEAN                 bUsingCopyPacket, bRetained;

            //
            // This is a reply packet. We can rewrite it once for all purposes.
            //

            // Make a copy if necessary so we can edit.
            if( ! bCanRetain )
            {
                pPacket = BrdgFwdMakeCompatCopyPacket( pPacket, &pPacketData, &packetLen, FALSE );

                if( (pPacket == NULL) || (pPacketData == NULL) )
                {
                    // Free the target adapter before bailing out
                    if( pTargetAdapt !=  NULL )
                    {
                        BrdgReleaseAdapter( pTargetAdapt );
                    }

                    return FALSE;
                }

                bUsingCopyPacket = TRUE;
            }
            else
            {
                bUsingCopyPacket = FALSE;
            }

            // Rewrite the packet to the retrieved MAC address.
            BrdgCompRewriteBootPClientAddress( pPacketData, piphi, targetMAC );

            if( pTargetAdapt != NULL )
            {
                // If the reply was sent by broadcast, respect this, even if we think
                // we know the unicast MAC address of the target.
                if( ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
                {
                    // Broadcast around the reply
                    bRetained = BrdgCompSendToMultipleAdapters( pPacket, pAdapt, pPacketData, TRUE, pAdapt->bCompatibilityMode,
                                                                NULL, NULL );
                }
                else
                {
                    // Unicast back the reply
                    ETH_COPY_NETWORK_ADDRESS( pPacketData, targetMAC );
                    BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );

                    bRetained = TRUE;
                }

                // The target adapter came back with an incremented refcount
                BrdgReleaseAdapter( pTargetAdapt );
            }
            else
            {
                // This reply is for the local machine!
                UINT                Result;

                // The recorded MAC address should be the MAC address of the bridge.
                SAFEASSERT( gCompHaveMACAddress );
                ETH_COMPARE_NETWORK_ADDRESSES_EQ( targetMAC, gCompMACAddress, &Result );
                SAFEASSERT( Result == 0 );

                // Indicate the edited reply
                BrdgCompIndicatePacket( pPacket, pPacketData, pAdapt );
                bRetained = TRUE;
            }

            if( bUsingCopyPacket )
            {
                if( !bRetained )
                {
                    // Our copy packet was not retained.
                    BrdgFwdReleaseCompatPacket( pPacket );
                }

                // If we were using a copy packet, we definitely did not retain the packet passed in
                bRetained = FALSE;
            }

            return bRetained;
        }
    }
    else
    {
        // Something went wrong in the preprocessing.
        return FALSE;
    }
}



// ===========================================================================
//
// OUTBOUND PACKET PROCESSING
//
// ===========================================================================


BOOLEAN
BrdgCompProcessOutboundNonARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    )
/*++

Routine Description:

    Processes an outbound non-ARP packet. This function may retain the
    given packet if it wishes.

Arguments:

    pPacket                     The packet
    pPacketData                 The packet's data buffer
    packetLen                   Length of the data buffer
    pTargetAdapt                The target adapter, as determined
                                    by a previous MAC-table lookup


Return Value:

    Whether we retained the packet

--*/
{
    IP_HEADER_INFO              iphi;
    BOOLEAN                     bRetained = FALSE, bIsMulticast;

    if( packetLen >= MINIMUM_SIZE_FOR_IP &&
        BrdgCompDecodeIPHeader(pPacketData + ETHERNET_HEADER_SIZE, &iphi) )
    {
        PUCHAR                  pBootPData;

        pBootPData = BrdgCompIsBootPPacket(pPacketData, packetLen, &iphi);

        if( pBootPData != NULL )
        {
            // Do special BOOTP processing
            return BrdgCompProcessOutboundBootPPacket( pPacket, pPacketData, packetLen, pTargetAdapt, pBootPData, &iphi );
        }
    }

    bIsMulticast = (BOOLEAN)(ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData));

    // We edit and transmit the packet even if it doesn't appear to be IP.
    if( (pTargetAdapt == NULL) || bIsMulticast )
    {
        // Don't expect a target adapter when the outbound frame is broadcast
        if( bIsMulticast )
        {
            SAFEASSERT( pTargetAdapt == NULL );
        }

        // We need to send this packet to all compat adapters.
        bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE, /*Can retain*/
                                                    FALSE /* Compat-mode adapters only*/,
                                                    NULL /*No editing function*/, NULL );
    }
    else
    {
        BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );

        // The packet has been handed off to the forwarding engine
        bRetained = TRUE;
    }

    return bRetained;
}

BOOLEAN
BrdgCompProcessOutboundARPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt
    )
/*++

Routine Description:

    Processes an outbound ARP packet. This function may retain the
    given packet if it wishes.

Arguments:

    pPacket                     The packet
    pPacketData                 The packet's data buffer
    packetLen                   Length of the data buffer
    pTargetAdapt                The target adapter, as determined
                                    by a previous MAC-table lookup

Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bRetained = FALSE, bIsMulticast;
    ARPINFO                     ai;

    if( packetLen < SIZE_OF_ARP_PACKET )
    {
        // Packet is too small to be ARP; process as non-ARP
        return BrdgCompProcessOutboundNonARPPacket( pPacket, pPacketData, packetLen, pTargetAdapt );
    }

    if( BrdgCompDecodeARPPacket(pPacketData, packetLen, &ai) )
    {
        if( ai.type == ArpRequest )
        {
            ARP_TABLE_KEY           atk;
            PARP_TABLE_ENTRY        pEntry;
            LOCK_STATE              LockState;
            BOOLEAN                 bIsNewEntry;

            // Note that the local machine is trying to resolve this target IP address by
            // inserting or refreshing an entry with 0.0.0.0 as the requestor
            atk.ipReqestor = 0L;    // Special value for local machine
            atk.ipTarget = ai.ipTarget;

            pEntry = (PARP_TABLE_ENTRY)BrdgHashRefreshOrInsert( gPendingARPTable, (PUCHAR)&atk, &bIsNewEntry,
                                                                &LockState );

            if( pEntry != NULL )
            {
                if( bIsNewEntry)
                {
                    // Even though this entry isn't really ever used, initialize it so
                    // functions walking across table entries don't get confused or crash.
                    NdisAllocateSpinLock( &pEntry->lock );
                    pEntry->pOriginalAdapt = NULL;
                    pEntry->originalMAC[0] = pEntry->originalMAC[1] = pEntry->originalMAC[2] =
                        pEntry->originalMAC[3] = pEntry->originalMAC[4] =pEntry->originalMAC[5] = 0;
                }

                NdisReleaseReadWriteLock( &gPendingARPTable->tableLock, &LockState );
            }
        }

        // Check if this frame looks like it should be relayed to all compat adapters
        bIsMulticast = (BOOLEAN)(ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData));

        if( (pTargetAdapt == NULL) || bIsMulticast )
        {
            // Don't expect a target adapter when the outbound frame is broadcast
            if( bIsMulticast )
            {
                SAFEASSERT( pTargetAdapt == NULL );
            }

            // We need to send this packet to all compat adapters.
            bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE,/*Can retain*/
                                                        FALSE /* Compat-mode adapters only*/,
                                                        BrdgCompRewriteOutboundARPPacket, NULL );
        }
        else
        {
            // Edit the packet for the outbound adapter
            BrdgCompRewriteOutboundARPPacket( pPacketData, pTargetAdapt, NULL );

            // Send the packet on its way
            BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );

            // The packet has been handed off to the forwarding engine
            bRetained = TRUE;
        }
    }
    else
    {
        // The packet didn't look like an ARP packet. Process it otherwise.
        return BrdgCompProcessOutboundNonARPPacket( pPacket, pPacketData, packetLen, pTargetAdapt );
    }

    return bRetained;
}

BOOLEAN
BrdgCompProcessOutboundBootPPacket(
    IN PNDIS_PACKET             pPacket,
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PADAPT                   pTargetAdapt,
    IN PUCHAR                   pBootPData,
    IN PIP_HEADER_INFO          piphi
    )
/*++

Routine Description:

    Processes an outbound BOOTP packet. This function may retain the
    given packet if it wishes.

Arguments:

    pPacket                     The packet
    pPacketData                 The packet's data buffer
    packetLen                   Length of the data buffer
    pTargetAdapt                The target adapter, as determined
                                    by a previous MAC-table lookup
    pBootPData                  Pointer to the BOOTP payload within the packet
    piphi                       Decoded info from the packet's IP header

Return Value:

    Whether we retained the packet

--*/
{
    BOOLEAN                     bIsRequest, bRetained;
    PADAPT                      pRequestorAdapt = NULL;
    UCHAR                       macRequestor[ETH_LENGTH_OF_ADDRESS];

    if( BrdgCompPreprocessBootPPacket( pPacketData, piphi, pBootPData, NULL, &bIsRequest, &pRequestorAdapt, macRequestor ) )
    {
        if( bIsRequest )
        {
            //
            // This is a BOOTP request. Transmit as appropriate but rewrite for each adapter.
            //
            SAFEASSERT( pRequestorAdapt == NULL );

            if( (pTargetAdapt == NULL) || ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
            {
                bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE, FALSE, BrdgCompRewriteBootPPacketForAdapt,
                                                            piphi );
            }
            else
            {
                // Rewrite the packet before transmission
                BrdgCompRewriteBootPPacketForAdapt( pPacketData, pTargetAdapt, piphi );

                // Unicast out the packet
                BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );
                bRetained = TRUE;
            }
        }
        else
        {
            //
            // This is a BOOTP reply. No editing is necessary; just send it.
            //
            if( (pTargetAdapt == NULL) || ETH_IS_BROADCAST(pPacketData) || ETH_IS_MULTICAST(pPacketData) )
            {
                bRetained = BrdgCompSendToMultipleAdapters( pPacket, NULL, pPacketData, TRUE, FALSE, NULL, NULL );
            }
            else
            {
                UINT            Result;

                // Verify for sanity that the target we're sending it to matches the information
                // in the table.
                ETH_COMPARE_NETWORK_ADDRESSES_EQ( macRequestor, pPacketData, &Result );
                SAFEASSERT( Result == 0 );
                SAFEASSERT( pTargetAdapt == pRequestorAdapt );

                // This packet is unicast, probably part of an established conversation with a
                // DHCP server.
                BrdgCompSendPacket( pPacket, pPacketData, pTargetAdapt );
                bRetained = TRUE;
            }

            // This comes back with its refcount incremented
            if( pRequestorAdapt != NULL )
            {
                BrdgReleaseAdapter( pRequestorAdapt );
            }
        }
    }
    else
    {
        // Preprocessing failed
        bRetained = FALSE;
    }

    return bRetained;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgcomp.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgsta.h

Abstract:

    Ethernet MAC level bridge
    Compatibility-Mode section header file

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    September 2000 - Original version

--*/

// ===========================================================================
//
// TYPES
//
// ===========================================================================

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgCompDriverInit();

VOID
BrdgCompCleanup();

PADAPT
BrdgCompFindTargetAdapterForIPAddress(
    IN PNDIS_PACKET     ipTarget);

BOOLEAN
BrdgCompRequiresCompatWork(
    IN PADAPT           pAdapt,
    IN PUCHAR           pPacketData,
    IN UINT             dataSize
    );

BOOLEAN
BrdgCompProcessInboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pAdapt,
    IN BOOLEAN          bCanRetain
    );

VOID
BrdgCompProcessOutboundPacket(
    IN PNDIS_PACKET     pPacket,
    IN PADAPT           pTargetAdapt
    );

VOID
BrdgCompNotifyNetworkAddresses(
    IN PNETWORK_ADDRESS_LIST    pAddressList,
    IN ULONG                    infoLength
    );

VOID
BrdgCompNotifyMACAddress(
    IN PUCHAR           pBridgeMACAddr
    );

VOID
BrdgCompScrubAdapter(
    IN PADAPT           pAdapt
    );

VOID 
BrdgCompScrubAllAdapters();

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Whether or not ANY compatibility-mode adapters exist.
// Must be updated with a write lock on the global adapter list.
extern BOOLEAN          gCompatAdaptersExist;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgctl.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgctl.c

Abstract:

    Ethernet MAC level bridge.
    IOCTL processing code

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Apr  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"

#include "brdgmini.h"
#include "brdgtbl.h"
#include "brdgctl.h"
#include "brdgfwd.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgsta.h"

// IoSetCancelRoutine causes these warnings; disable them
#pragma warning( disable: 4054 )
#pragma warning( disable: 4055 )

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

//
// Maximum number of notifications we will queue up if the user-mode
// code hasn't given us any IRPs to use
//
#define MAX_NOTIFY_QUEUE_LENGTH                     20

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

// Structure for queueing a notification
typedef struct _DEFERRED_NOTIFY
{

    BSINGLE_LIST_ENTRY          List;               // For queuing
    UINT                        DataSize;           // Size of data at end

    BRIDGE_NOTIFY_HEADER        Header;             // The notification header
    // DataSize bytes of data follows

} DEFERRED_NOTIFY, *PDEFERRED_NOTIFY;

// Type of function to pass to BrdgCtlCommonNotify
typedef VOID (*PNOTIFY_COPY_FUNC)(PVOID, PVOID);

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Queue of pending notifications
BSINGLE_LIST_HEAD               gNotificationsList;
NDIS_SPIN_LOCK                  gNotificationsListLock;

// Queue of pending notification IRPs
LIST_ENTRY                      gIRPList;
NDIS_SPIN_LOCK                  gIRPListLock;

// A flag controlling whether new entries are allowed onto the queue of pending
// notifications or not. != 0 means new entries are allowed
ULONG                           gAllowQueuedNotifies = 0L;

// ===========================================================================
//
// LOCAL PROTOTYPES
//
// ===========================================================================

PIRP
BrdgCtlDequeuePendingIRP();

VOID
BrdgCtlCopyAdapterInfo(
    OUT PBRIDGE_ADAPTER_INFO        pInfo,
    IN PADAPT                       pAdapt
    );

NTSTATUS
BrdgCtlQueueAndPendIRP(
    IN PIRP             pIrp
    );

PADAPT
BrdgCtlValidateAcquireAdapter(
    IN BRIDGE_ADAPTER_HANDLE   Handle
    );

VOID
BrdgCtlEmptyIRPList(
    PLIST_ENTRY     pList
    );

VOID
BrdgCtlCancelPendingIRPs();

VOID
BrdgCtlReleaseQueuedNotifications();

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgCtlDriverInit()
/*++

Routine Description:

    Main driver entry point. Called at driver load time

Arguments:

    None

Return Value:

    Status of our initialization. A status != STATUS_SUCCESS aborts the
    driver load and we don't get called again.

--*/
{
    BrdgInitializeSingleList( &gNotificationsList );
    InitializeListHead( &gIRPList );

    NdisAllocateSpinLock( &gNotificationsListLock );
    NdisAllocateSpinLock( &gIRPListLock );

    return STATUS_SUCCESS;
}

VOID
BrdgCtlHandleCreate()
/*++

Routine Description:

    Called when a user-mode component opens our device object. We allow notifications
    to be queued up until we are closed.

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINT(CTL, ("BrdgCtlHandleCreate()\n"));

    // Permit notifications to be queued
    InterlockedExchangeULong( &gAllowQueuedNotifies, 1L );
}

VOID
BrdgCtlHandleCleanup()
/*++

Routine Description:

    Called when our device object has no more references to it. We disallow notification
    queuing and flush existing queued notifications and pending IRPs.

Arguments:

    None

Return Value:

    None

--*/
{
    // Forbid new notifications from being queued
    ULONG prev = InterlockedExchangeULong( &gAllowQueuedNotifies, 0L );

    DBGPRINT(CTL, ("BrdgCtlHandleCleanup()\n"));

    // Write in this roundabout way otherwise compiler complains about
    // prev not being used in the FRE build
    if( prev == 0L )
    {
        SAFEASSERT( FALSE );
    }

    // Complete any pending IRPs
    BrdgCtlCancelPendingIRPs();

    // Ditch any queued notifications
    BrdgCtlReleaseQueuedNotifications();
}

VOID
BrdgCtlCommonNotify(
    IN PADAPT                       pAdapt,
    IN BRIDGE_NOTIFICATION_TYPE     Type,
    IN ULONG                        DataSize,
    IN OPTIONAL PNOTIFY_COPY_FUNC   pFunc,
    IN PVOID                        Param1
    )
/*++

Routine Description:

    Common processing for notifications to user-mode

    This routine completes a pending IRP from user mode if one is
    available. Otherwise, it queues up a new DEFERRED_NOTIFY
    structure with the notification data.

Arguments:

    pAdapt                          The adapter involved in the notification
    Type                            Type of notification

    DataSize                        Required amount of data required to store
                                    the notification information

    pFunc                           A function that can copy the notification
                                    data to an IRP's buffer or a new DEFERRED_NOTIFY
                                    structure. Can be NULL if no copying is
                                    required.

    Param1                          A context pointer to pass to the helper
                                    function

Return Value:

    None

--*/
{
    PIRP                            pIrp;

    // Check if there is an IRP waiting to receive this notification
    pIrp = BrdgCtlDequeuePendingIRP();

    if( pIrp != NULL )
    {
        PBRIDGE_NOTIFY_HEADER       pHeader;

        // There's an IRP waiting to be completed. Fill it in
        pHeader = (PBRIDGE_NOTIFY_HEADER)pIrp->AssociatedIrp.SystemBuffer;

        // Fill in the notification header
        pHeader->Handle = (BRIDGE_ADAPTER_HANDLE)pAdapt;
        pHeader->NotifyType = Type;

        // Fill in the remaining data if necessary
        if( pFunc != NULL )
        {
            (*pFunc)( ((PUCHAR)pIrp->AssociatedIrp.SystemBuffer) + sizeof(BRIDGE_NOTIFY_HEADER), Param1 );
        }

        // Complete the IRP
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = sizeof(BRIDGE_NOTIFY_HEADER) + DataSize;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    else
    {
        // No pending IRP. Queue up the notification if that's currently allowed.
        if( gAllowQueuedNotifies )
        {
            NDIS_STATUS                     Status;
            PDEFERRED_NOTIFY                pNewNotify, pOldEntry = NULL;

            Status = NdisAllocateMemoryWithTag( &pNewNotify, sizeof(DEFERRED_NOTIFY) + DataSize, 'gdrB' );

            if( Status != NDIS_STATUS_SUCCESS )
            {
                DBGPRINT(CTL, ("Failed to allocate memory for an adapter change notification: %08x\n", Status));
                return;
            }

            // Fill in the notification
            pNewNotify->DataSize = DataSize;
            pNewNotify->Header.Handle = (BRIDGE_ADAPTER_HANDLE)pAdapt;
            pNewNotify->Header.NotifyType = Type;

            // Fill the remaining data if necessary
            if( pFunc != NULL )
            {
                (*pFunc)( ((PUCHAR)pNewNotify) + sizeof(DEFERRED_NOTIFY), Param1 );
            }

            NdisAcquireSpinLock( &gNotificationsListLock );
            SAFEASSERT( BrdgQuerySingleListLength(&gNotificationsList) <= MAX_NOTIFY_QUEUE_LENGTH );

            // Enforce the maximum notification queue length
            if( BrdgQuerySingleListLength(&gNotificationsList) == MAX_NOTIFY_QUEUE_LENGTH )
            {
                // Dequeue and ditch the head (oldest) notification
                pOldEntry = (PDEFERRED_NOTIFY)BrdgRemoveHeadSingleList( &gNotificationsList );
            }

            // Enqueue our entry
            BrdgInsertTailSingleList( &gNotificationsList, &pNewNotify->List );

            NdisReleaseSpinLock( &gNotificationsListLock );

            if( pOldEntry != NULL )
            {
                // Release the old entry that we bumped off
                NdisFreeMemory( pOldEntry, sizeof(DEFERRED_NOTIFY) + pOldEntry->DataSize, 0 );
            }
        }
    }
}

VOID
BrdgCtlNotifyAdapterChange(
    IN PADAPT                       pAdapt,
    IN BRIDGE_NOTIFICATION_TYPE     Type
    )
/*++

Routine Description:

    Produces a notification to user-mode signalling a change in an adapter.

Arguments:

    pAdapt                          The adapter involved
    Type                            Type of notification

Return Value:

    None

--*/
{
    if( Type == BrdgNotifyRemoveAdapter )
    {
        // We don't pass any additional data in the notification for remove events
        BrdgCtlCommonNotify( pAdapt, Type, 0, NULL, NULL );
    }
    else
    {
       BrdgCtlCommonNotify( pAdapt, Type, sizeof(BRIDGE_ADAPTER_INFO), BrdgCtlCopyAdapterInfo, pAdapt );
    }
}

NTSTATUS
BrdgCtlHandleIoDeviceControl(
    IN PIRP                 Irp,
    IN PFILE_OBJECT         FileObject,
    IN OUT PVOID            Buffer,
    IN ULONG                InputBufferLength,
    IN ULONG                OutputBufferLength,
    IN ULONG                IoControlCode,
    OUT PULONG              Information
    )
/*++

Routine Description:

    This routine handles all Device-control requests.

Arguments:

    Irp                     The IRP
    FileObject              The file object of the bridge
    Buffer                  Input / output buffer
    InputBufferLength       Size of inbound data
    OutputBufferLength      Maximum allowable output data
    IoControlCode           The control code

    Information             Code-specific information returned
                            (usually the number of written bytes or
                            bytes required on overflow)

Return Value:

    Status of the operation

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;

    *Information = 0;

    switch (IoControlCode)
    {
        //
        // Request for notification
        //
    case BRIDGE_IOCTL_REQUEST_NOTIFY:
        {
            PDEFERRED_NOTIFY                pDeferred = NULL;

            if( OutputBufferLength < sizeof(BRIDGE_NOTIFY_HEADER) + MAX_PACKET_SIZE )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                // See if there is a pending notification waiting for an IRP
                NdisAcquireSpinLock( &gNotificationsListLock );

                if( BrdgQuerySingleListLength(&gNotificationsList) > 0L )
                {
                    PBSINGLE_LIST_ENTRY     pList = BrdgRemoveHeadSingleList(&gNotificationsList);

                    if( pList != NULL )
                    {
                        pDeferred = CONTAINING_RECORD( pList, DEFERRED_NOTIFY, List );
                    }
                    else
                    {
                        // Should be impossible
                        SAFEASSERT(FALSE);
                    }
                }

                NdisReleaseSpinLock( &gNotificationsListLock );

                if( pDeferred != NULL )
                {
                    UINT                SizeToCopy = sizeof(BRIDGE_NOTIFY_HEADER) + pDeferred->DataSize;

                    // We have a notification to return immediately
                    NdisMoveMemory( Buffer, &pDeferred->Header, SizeToCopy );
                    *Information = SizeToCopy;

                    // Free the holding structure
                    NdisFreeMemory( pDeferred, sizeof(DEFERRED_NOTIFY) + pDeferred->DataSize, 0 );
                }
                else
                {
                    // No pending notification to send. queue the IRP for use later
                    status = BrdgCtlQueueAndPendIRP( Irp );
                }
            }
        }
        break;

        //
        // Request to be notified about all adapters
        //
    case BRIDGE_IOCTL_GET_ADAPTERS:
        {
            // Send a notification for each adapter
            PADAPT              pAdapt;
            LOCK_STATE          LockState;

            NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read only*/, &LockState );

            for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
            {
                BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyEnumerateAdapters );
            }

            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
        }
        break;

        //
        // Request for an adapter's device name
        //
    case BRIDGE_IOCTL_GET_ADAPT_DEVICE_NAME:
        {
            if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG       bytesToCopy;

                    // We need enough room to add a trailing NULL
                    if( OutputBufferLength < pAdapt->DeviceName.Length + sizeof(WCHAR) )
                    {
                        if( OutputBufferLength >= sizeof(WCHAR) )
                        {
                            bytesToCopy = OutputBufferLength - sizeof(WCHAR);
                        }
                        else
                        {
                            bytesToCopy = 0L;
                        }

                        status = STATUS_BUFFER_OVERFLOW;
                    }
                    else
                    {
                        bytesToCopy = pAdapt->DeviceName.Length;
                    }

                    if( bytesToCopy > 0L )
                    {
                        NdisMoveMemory( Buffer, pAdapt->DeviceName.Buffer, bytesToCopy );
                    }

                    // Put a trailing NULL WCHAR at the end
                    *((PWCHAR)((PUCHAR)Buffer + bytesToCopy)) = 0x0000;

                    // Tell the caller how many bytes we wrote / are needed
                    *Information = pAdapt->DeviceName.Length + sizeof(WCHAR);

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

        //
        // Request for an adapter's friendly name
        //
    case BRIDGE_IOCTL_GET_ADAPT_FRIENDLY_NAME:
        {
            if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG       bytesToCopy;

                    // We need enough room to add a trailing NULL
                    if( OutputBufferLength < pAdapt->DeviceDesc.Length + sizeof(WCHAR) )
                    {
                        if( OutputBufferLength >= sizeof(WCHAR) )
                        {
                            bytesToCopy = OutputBufferLength - sizeof(WCHAR);
                        }
                        else
                        {
                            bytesToCopy = 0L;
                        }

                        status = STATUS_BUFFER_OVERFLOW;
                    }
                    else
                    {
                        bytesToCopy = pAdapt->DeviceDesc.Length;
                    }

                    if( bytesToCopy > 0L )
                    {
                        NdisMoveMemory( Buffer, pAdapt->DeviceDesc.Buffer, bytesToCopy );
                    }

                    // Put a trailing NULL WCHAR at the end
                    *((PWCHAR)((PUCHAR)Buffer + bytesToCopy)) = 0x0000;

                    // Tell the caller how many bytes we wrote / are needed
                    *Information = pAdapt->DeviceDesc.Length + sizeof(WCHAR);

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

        //
        // Request to retrieve the bridge's MAC address
        //
    case BRIDGE_IOCTL_GET_MAC_ADDRESS:
        {
            if( OutputBufferLength < ETH_LENGTH_OF_ADDRESS )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                if( ! BrdgMiniReadMACAddress((PUCHAR)Buffer) )
                {
                    // We don't actually have a MAC address right now
                    // (shouldn't really be possible since the user-mode code would have
                    // to be making this request before we bound to any adapters)
                    status = STATUS_UNSUCCESSFUL;
                }
                else
                {
                    *Information = ETH_LENGTH_OF_ADDRESS;
                }
            }
        }
        break;

        //
        // Request to retrieve packet-handling statistics
        //
    case BRIDGE_IOCTL_GET_PACKET_STATS:
        {
            if( OutputBufferLength < sizeof(BRIDGE_PACKET_STATISTICS) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PBRIDGE_PACKET_STATISTICS       pStats = (PBRIDGE_PACKET_STATISTICS)Buffer;

                // These are only statistics and have no associated locks so just read them
                // without protection
                pStats->TransmittedFrames = gStatTransmittedFrames;
                pStats->TransmittedErrorFrames = gStatTransmittedErrorFrames;
                pStats->TransmittedBytes = gStatTransmittedBytes;
                pStats->DirectedTransmittedFrames = gStatDirectedTransmittedFrames;
                pStats->MulticastTransmittedFrames = gStatMulticastTransmittedFrames;
                pStats->BroadcastTransmittedFrames = gStatBroadcastTransmittedFrames;
                pStats->DirectedTransmittedBytes = gStatDirectedTransmittedBytes;
                pStats->MulticastTransmittedBytes = gStatMulticastTransmittedBytes;
                pStats->BroadcastTransmittedBytes = gStatBroadcastTransmittedBytes;
                pStats->IndicatedFrames = gStatIndicatedFrames;
                pStats->IndicatedDroppedFrames = gStatIndicatedDroppedFrames;
                pStats->IndicatedBytes = gStatIndicatedBytes;
                pStats->DirectedIndicatedFrames = gStatDirectedIndicatedFrames;
                pStats->MulticastIndicatedFrames = gStatMulticastIndicatedFrames;
                pStats->BroadcastIndicatedFrames = gStatBroadcastIndicatedFrames;
                pStats->DirectedIndicatedBytes = gStatDirectedIndicatedBytes;
                pStats->MulticastIndicatedBytes = gStatMulticastIndicatedBytes;
                pStats->BroadcastIndicatedBytes = gStatBroadcastIndicatedBytes;
                pStats->ReceivedFrames = gStatReceivedFrames;
                pStats->ReceivedBytes = gStatReceivedBytes;
                pStats->ReceivedCopyFrames = gStatReceivedCopyFrames;
                pStats->ReceivedCopyBytes = gStatReceivedCopyBytes;
                pStats->ReceivedNoCopyFrames = gStatReceivedNoCopyFrames;
                pStats->ReceivedNoCopyBytes = gStatReceivedNoCopyBytes;

                *Information = sizeof(BRIDGE_PACKET_STATISTICS);
            }
        }
        break;

        //
        // Request to retrieve packet-handling statistics for an adapter
        //
    case BRIDGE_IOCTL_GET_ADAPTER_PACKET_STATS:
        {
            if( (InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE)) ||
                (OutputBufferLength < sizeof(BRIDGE_ADAPTER_PACKET_STATISTICS)) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    PBRIDGE_ADAPTER_PACKET_STATISTICS       pStats = (PBRIDGE_ADAPTER_PACKET_STATISTICS)Buffer;

                    // These are only statistics and have no associated locks so just read them
                    // without protection
                    pStats->SentFrames = pAdapt->SentFrames;
                    pStats->SentBytes = pAdapt->SentBytes;
                    pStats->SentLocalFrames = pAdapt->SentLocalFrames;
                    pStats->SentLocalBytes = pAdapt->SentLocalBytes;
                    pStats->ReceivedFrames = pAdapt->ReceivedFrames;
                    pStats->ReceivedBytes = pAdapt->ReceivedBytes;

                    *Information = sizeof(BRIDGE_ADAPTER_PACKET_STATISTICS);

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

        //
        // Request to retrieve buffer-handling statistics
        //
    case BRIDGE_IOCTL_GET_BUFFER_STATS:
        {
            if( OutputBufferLength < sizeof(BRIDGE_BUFFER_STATISTICS) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                BrdgBufGetStatistics((PBRIDGE_BUFFER_STATISTICS)Buffer);

                *Information = sizeof(BRIDGE_BUFFER_STATISTICS);
            }
        }
        break;

        //
        // Request to retrieve the contents of the forwarding table for
        // a particular adapter
        //
    case BRIDGE_IOCTL_GET_TABLE_ENTRIES:
        {
            if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG       ReqdBytes;

                    // Try to read the contents of the forwarding table for this adapter
                    ReqdBytes = BrdgTblReadTable( pAdapt, Buffer, OutputBufferLength );

                    if( ReqdBytes > OutputBufferLength )
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }

                    *Information = ReqdBytes;

                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

    case BRIDGE_IOCTL_GET_ADAPTER_STA_INFO:
        {
            if( gDisableSTA )
            {
                // Can't collect STA information when it's not running!
                status = STATUS_INVALID_PARAMETER;
            }
            else if( InputBufferLength < sizeof(BRIDGE_ADAPTER_HANDLE) ||
                     OutputBufferLength < sizeof(BRIDGE_STA_ADAPTER_INFO) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                PADAPT      pAdapt = BrdgCtlValidateAcquireAdapter(*((PBRIDGE_ADAPTER_HANDLE)Buffer));

                if( pAdapt == NULL )
                {
                    // The handle passed in doesn't actually indicate an adapter
                    status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    BrdgSTAGetAdapterSTAInfo( pAdapt, (PBRIDGE_STA_ADAPTER_INFO)Buffer );
                    *Information = sizeof(BRIDGE_STA_ADAPTER_INFO);
                    BrdgReleaseAdapter(pAdapt);
                }
            }
        }
        break;

    case BRIDGE_IOCTL_GET_GLOBAL_STA_INFO:
        {
            if( gDisableSTA )
            {
                // Can't collect STA information when it's not running!
                status = STATUS_INVALID_PARAMETER;
            }
            else if( OutputBufferLength < sizeof(BRIDGE_STA_GLOBAL_INFO) )
            {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                BrdgSTAGetSTAInfo( (PBRIDGE_STA_GLOBAL_INFO)Buffer );
                *Information = sizeof(BRIDGE_STA_GLOBAL_INFO);
            }
        }
        break;

    default:
        {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    }

    return status;
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgCtlCopyAdapterInfo(
    OUT PBRIDGE_ADAPTER_INFO        pInfo,
    IN PADAPT                       pAdapt
    )
/*++

Routine Description:

    Helper function for BrdgCtlCommonNotify. Copies data about an adapter
    to a buffer.

Arguments:

    pInfo                           Structure to fill with information
    pAdapt                          Adapter to copy from

Return Value:

    None

--*/
{
    LOCK_STATE          LockState;

    // Take a read lock on gAdapterCharacteristicsLock to ensure that all these
    // are consistent
    NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, FALSE/*Read only*/, &LockState );

    pInfo->LinkSpeed = pAdapt->LinkSpeed;
    pInfo->MediaState = pAdapt->MediaState;
    pInfo->State = pAdapt->State;

    NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

    // These values don't change after assignment, and so need no lock.
    ETH_COPY_NETWORK_ADDRESS( pInfo->MACAddress, pAdapt->MACAddr );
    pInfo->PhysicalMedium = pAdapt->PhysicalMedium;
}

PADAPT
BrdgCtlValidateAcquireAdapter(
    IN BRIDGE_ADAPTER_HANDLE   Handle
    )
/*++

Routine Description:

    Checks to ensure that a BRIDGE_ADAPTER_HANDLE passed from user-mode code
    actually corresponds to an adapter still in our list.

    If the adapter is found, its refcount is incremented.

Arguments:

    Handle                      A handle from user-mode code

Return Value:

    The handle recast as a PADAPT, or NULL if the adapter could not be found.

--*/
{
    PADAPT              pAdapt = (PADAPT)Handle, anAdapt;
    LOCK_STATE          LockState;

    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read only*/, &LockState );

    for( anAdapt = gAdapterList; anAdapt != NULL; anAdapt = anAdapt->Next )
    {
        if( anAdapt == pAdapt )
        {
            // The adapter is in the list. Increment its refcount inside the lock
            // and return
            BrdgAcquireAdapterInLock( pAdapt );
            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
            return pAdapt;
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    return NULL;
}

VOID
BrdgCtlCancelIoctl(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                pIrp
    )
/*++

Routine Description:

    IRP Cancellation function

Arguments:

    DeviceObject        The bridge's device-object

    pIrp                The IRP to be cancelled

Return Value:

    none.

Environment:

    Invoked with the cancel spin-lock held by the I/O manager.
    It is this routine's responsibility to release the lock.

--*/
{
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    // Take the IRP off our list
    NdisAcquireSpinLock( &gIRPListLock );
    RemoveEntryList( &pIrp->Tail.Overlay.ListEntry );
    InitializeListHead( &pIrp->Tail.Overlay.ListEntry );
    NdisReleaseSpinLock( &gIRPListLock );

    // Complete the IRP
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
}


NTSTATUS
BrdgCtlQueueAndPendIRP(
    IN PIRP             pIrp
    )
/*++

Routine Description:

    Safely inserts an IRP into our queue of pending IRPs.

Arguments:

    pIrp                The IRP to queue

Return Value:

    The status to return from IRP processing (can be STATUS_CANCELLED
    if the IRP was cancelled right after we received it. Otherwise
    is STATUS_PENDING so caller knows the IRP is pending).

--*/
{
    KIRQL               CancelIrql;

    // If the IRP has already been cancelled, forget it.
    IoAcquireCancelSpinLock( &CancelIrql );
    NdisDprAcquireSpinLock( &gIRPListLock );

    if ( pIrp->Cancel )
    {
        NdisDprReleaseSpinLock( &gIRPListLock );
        IoReleaseCancelSpinLock(CancelIrql);
        return STATUS_CANCELLED;
    }

    // Queue the IRP
    InsertTailList( &gIRPList, &pIrp->Tail.Overlay.ListEntry);

    // Install our cancel-routine
    IoMarkIrpPending( pIrp );
    IoSetCancelRoutine( pIrp, BrdgCtlCancelIoctl );

    NdisDprReleaseSpinLock( &gIRPListLock );
    IoReleaseCancelSpinLock( CancelIrql );

    return STATUS_PENDING;
}

PIRP
BrdgCtlDequeuePendingIRP()
/*++

Routine Description:

    Safely dequeues an IRP on our pending list for use to communicate
    a notification

Return Value:

    A dequeued IRP if one was available; NULL otherwise.

--*/
{
    PLIST_ENTRY                     Link;
    PIRP                            pIrp = NULL;

    while( pIrp == NULL )
    {
        NdisAcquireSpinLock( &gIRPListLock );

        if ( IsListEmpty(&gIRPList) )
        {
            NdisReleaseSpinLock( &gIRPListLock );
            return NULL;
        }

        // Dequeue a pending IRP
        Link = RemoveHeadList( &gIRPList );
        pIrp = CONTAINING_RECORD( Link, IRP, Tail.Overlay.ListEntry );

        // After this call, it is safe for our cancel routine to call
        // RemoveHeadList again on this IRP
        InitializeListHead( Link );

        // Make the IRP uncancellable so we can complete it.
        if( IoSetCancelRoutine( pIrp, NULL ) == NULL )
        {
            // This IRP must have already been cancelled but our cancel
            // routine hasn't gotten control yet. Loop again to get a
            // usable IRP.
            pIrp = NULL;
        }

        NdisReleaseSpinLock( &gIRPListLock );
    }

    return pIrp;
}

VOID
BrdgCtlCancelPendingIRPs()
/*++

Routine Description:

    Cancels all pending IRPs

Return Value:

    None

--*/
{
    PIRP            pIrp;

    NdisAcquireSpinLock( &gIRPListLock );

    while ( !IsListEmpty(&gIRPList) )
    {
        //
        // Take the next IRP off the list
        //
        pIrp = CONTAINING_RECORD( gIRPList.Flink, IRP, Tail.Overlay.ListEntry );
        RemoveEntryList( &pIrp->Tail.Overlay.ListEntry );

        // Clean up the ListEntry in case our cancel routine gets called
        InitializeListHead( &pIrp->Tail.Overlay.ListEntry );

        // Cancel it if necessary
        if ( IoSetCancelRoutine( pIrp, NULL ) != NULL )
        {
            // Our cancel routine will not be called. Complete this IRP ourselves.
            NdisReleaseSpinLock( &gIRPListLock );

            // Complete the IRP
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );

            // Resume emptying the list
            NdisAcquireSpinLock( &gIRPListLock );
        }
        // else our cancel routine will be called for this IRP
    }

    NdisReleaseSpinLock( &gIRPListLock );
}

VOID
BrdgCtlReleaseQueuedNotifications()
/*++

Routine Description:

    Frees any queued notifications

Return Value:

    None

--*/
{
    BSINGLE_LIST_HEAD       list;

    NdisAcquireSpinLock( &gNotificationsListLock );

    // Grab a copy of the whole list head
    list = gNotificationsList;

    // Set the list head back to empty
    BrdgInitializeSingleList( &gNotificationsList );

    NdisReleaseSpinLock( &gNotificationsListLock );

    // Now free all the items on the list
    while( BrdgQuerySingleListLength(&list) > 0L )
    {
        PDEFERRED_NOTIFY        pDeferred = NULL;
        PBSINGLE_LIST_ENTRY     pList = BrdgRemoveHeadSingleList(&list);

        if( pList != NULL )
        {
            pDeferred = CONTAINING_RECORD( pList, DEFERRED_NOTIFY, List );
            NdisFreeMemory( pDeferred, sizeof(DEFERRED_NOTIFY) + pDeferred->DataSize, 0 );
        }
        else
        {
            // Should be impossible
            SAFEASSERT(FALSE);
        }
    }
}

VOID
BrdgCtlCleanup()
/*++

Routine Description:

    Cleanup routine; called at shutdown

    This function is guaranteed to be called exactly once

Return Value:

    None

--*/
{
    BrdgCtlCancelPendingIRPs();
    BrdgCtlReleaseQueuedNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgdbg.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgdbg.h

Abstract:

    Ethernet MAC level bridge.
    Debugging header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    December  2000 - Original version

--*/

// Alias for KeGetCurrentIrql()
#define CURRENT_IRQL            (KeGetCurrentIrql())
            
// Module identifiers for debug spew control
#define MODULE_ALWAYS_PRINT     0x0000000
#define MODULE_GENERAL          0x0000001
#define MODULE_FWD              0x0000002
#define MODULE_PROT             0x0000004
#define MODULE_MINI             0x0000008
#define MODULE_BUF              0x0000010
#define MODULE_STA              0x0000020
#define MODULE_COMPAT           0x0000040
#define MODULE_CTL              0x0000080
#define MODULE_TDI              0x0000100
#define MODULE_GPO              0x0000200

// Spew control flags
extern ULONG                    gSpewFlags;

#if DBG
// Interval for debug messages that risk flooding the debugger console (i.e.,
// per-packet status messages)
#define DBG_PRINT_INTERVAL      1000
extern ULONG                    gLastThrottledPrint;

extern BOOLEAN                  gSoftAssert;
extern LARGE_INTEGER            gTime;
extern const LARGE_INTEGER      gCorrection;
extern TIME_FIELDS              gTimeFields;

// HACKHACK: Calling RtlSystemTimeToLocalTime or ExSystemTimeToLocalTime appears to be
// forbidden for WDM drivers, so just subtract a constant amount from the system time
// to recover Pacific Time.
_inline VOID
BrdgDbgPrintDateTime()
{
    KeQuerySystemTime( &gTime );
    gTime.QuadPart -= gCorrection.QuadPart;
    RtlTimeToTimeFields( &gTime, &gTimeFields );
    DbgPrint( "%02i/%02i/%04i %02i:%02i:%02i : ", gTimeFields.Month, gTimeFields.Day,
              gTimeFields.Year, gTimeFields.Hour, gTimeFields.Minute,
              gTimeFields.Second );
}

#define DBGPRINT( Module, Args )                \
{                                               \
    if( (MODULE_ ## Module == MODULE_ALWAYS_PRINT) || (gSpewFlags & MODULE_ ## Module) )         \
    {                                           \
        DbgPrint( "## BRIDGE[" #Module "] " );  \
        BrdgDbgPrintDateTime();                 \
        DbgPrint Args;                          \
    }                                           \
}

#define SAFEASSERT( test )  \
if( ! (test) )              \
{                           \
    if( gSoftAssert )       \
    {                       \
        DBGPRINT(ALWAYS_PRINT, ("ASSERT FAILED: " #test " at " __FILE__ " line %i -- Continuing anyway!\n", __LINE__)); \
    }                       \
    else                    \
    {                       \
        ASSERT( test );     \
    }                       \
}

_inline BOOLEAN
BrdgCanThrottledPrint()
{
    ULONG               NowTime;

    NdisGetSystemUpTime( &NowTime );

    if( NowTime - gLastThrottledPrint > DBG_PRINT_INTERVAL )
    {
        // It's been longer than the interval
        gLastThrottledPrint = NowTime;
        return TRUE;
    }
    else
    {
        // It has not been longer than the interval
        return FALSE;
    }
}

#define THROTTLED_DBGPRINT( Module, Args ) if(BrdgCanThrottledPrint()) { DBGPRINT(Module, Args); }

#else

#define DBGPRINT( Module, Args )
#define THROTTLED_DBGPRINT( Module, Args )
#define SAFEASSERT( test )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgfwd.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgfwd.h

Abstract:

    Ethernet MAC level bridge.
    Forwarding engine section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgFwdDriverInit();

VOID
BrdgFwdCleanup();

NDIS_STATUS
BrdgFwdSendBuffer(
    IN PADAPT               pAdapt,
    IN PUCHAR               pPacketData,
    IN UINT                 DataSize
    );

// This serves as a ProtocolReceive function
NDIS_STATUS
BrdgFwdReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               pHeader,
    IN  UINT                HeaderSize,
    IN  PVOID               pLookAheadBuffer,
    IN  UINT                LookAheadSize,
    IN  UINT                PacketSize
    );

// This serves as a ProtocolTransferDataComplete function
VOID
BrdgFwdTransferComplete(
    IN NDIS_HANDLE          ProtocolBindingContext,
    IN PNDIS_PACKET         pPacket,
    IN NDIS_STATUS          Status,
    IN UINT                 BytesTransferred
    );

// This serves as a ProtocolReceivePacket function
INT
BrdgFwdReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet
    );

// This serves as a MiniportSendPackets function
NDIS_STATUS
BrdgFwdSendPacket(
    IN PNDIS_PACKET         pPacket
    );

// This serves as a ProtocolSendComplete function
VOID
BrdgFwdSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pPacket,
    IN  NDIS_STATUS         Status
    );

// This serves as a MiniportReturnPacket function
VOID
BrdgFwdReturnIndicatedPacket(
    IN NDIS_HANDLE          MiniportAdapterContext,
    IN PNDIS_PACKET         pPacket
    );

// Compatibility-mode support functions
PNDIS_PACKET
BrdgFwdMakeCompatCopyPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PUCHAR             *pPacketData,
    OUT PUINT               packetDataSize,
    BOOLEAN                 bCountAsLocalSend
    );

VOID
BrdgFwdSendPacketForCompat(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    );

VOID BrdgFwdReleaseCompatPacket(
    IN PNDIS_PACKET         pPacket
    );

VOID
BrdgFwdIndicatePacketForCompat(
    IN PNDIS_PACKET         pPacket
    );

BOOLEAN
BrdgFwdBridgingNetworks();

VOID
BrdgFwdChangeBridging(
    IN BOOLEAN Bridging
    );

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

extern PHASH_TABLE          gMACForwardingTable;

extern UCHAR                gBridgeAddress[ETH_LENGTH_OF_ADDRESS];

// Thread synchronization
extern KEVENT               gThreadsCheckAdapters[MAXIMUM_PROCESSORS];

// Whether we hang on to NIC packets when possible or not
extern BOOLEAN              gRetainNICPackets;

// Statistics
extern LARGE_INTEGER        gStatTransmittedFrames;
extern LARGE_INTEGER        gStatTransmittedErrorFrames;
extern LARGE_INTEGER        gStatTransmittedBytes;
extern LARGE_INTEGER        gStatDirectedTransmittedFrames;
extern LARGE_INTEGER        gStatMulticastTransmittedFrames;
extern LARGE_INTEGER        gStatBroadcastTransmittedFrames;
extern LARGE_INTEGER        gStatDirectedTransmittedBytes;
extern LARGE_INTEGER        gStatMulticastTransmittedBytes;
extern LARGE_INTEGER        gStatBroadcastTransmittedBytes;
extern LARGE_INTEGER        gStatIndicatedFrames;
extern LARGE_INTEGER        gStatIndicatedDroppedFrames;
extern LARGE_INTEGER        gStatIndicatedBytes;
extern LARGE_INTEGER        gStatDirectedIndicatedFrames;
extern LARGE_INTEGER        gStatMulticastIndicatedFrames;
extern LARGE_INTEGER        gStatBroadcastIndicatedFrames;
extern LARGE_INTEGER        gStatDirectedIndicatedBytes;
extern LARGE_INTEGER        gStatMulticastIndicatedBytes;
extern LARGE_INTEGER        gStatBroadcastIndicatedBytes;

extern LARGE_INTEGER        gStatReceivedFrames;
extern LARGE_INTEGER        gStatReceivedBytes;
extern LARGE_INTEGER        gStatReceivedCopyFrames;
extern LARGE_INTEGER        gStatReceivedCopyBytes;
extern LARGE_INTEGER        gStatReceivedNoCopyFrames;
extern LARGE_INTEGER        gStatReceivedNoCopyBytes;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgfwd.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgfwd.c

Abstract:

    Ethernet MAC level bridge.
    Forwarding engine section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgprot.h"
#include "brdgmini.h"
#include "brdgtbl.h"
#include "brdgfwd.h"
#include "brdgbuf.h"
#include "brdgctl.h"
#include "brdgsta.h"
#include "brdgcomp.h"

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

//
// Number of queued packets we will process back-to-back at DISPATCH level before
// dropping back to PASSIVE to let the scheduler run
//
#define MAX_PACKETS_AT_DPC      10

// The STA multicast address
UCHAR                           STA_MAC_ADDR[ETH_LENGTH_OF_ADDRESS] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x00 };

// The flags we change on packet descriptor when sending them. For a fast-track
// send, these flags should be put back the way they were before returning
// the overlying protocol's packet descriptor.
#define CHANGED_PACKET_FLAGS    (NDIS_FLAGS_LOOPBACK_ONLY | NDIS_FLAGS_DONT_LOOPBACK)

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

//
// Pointers to the KTHREAD structure for each active thread
//
PVOID                   gThreadPtrs[MAXIMUM_PROCESSORS];

//
// The number of created threads
//
UINT                    gNumThreads = 0L;

// Global kill signal for threads
KEVENT                  gKillThreads;

//
// These auto-reset events signal the queue-draining threads to re-enumerate the
// adapter list (strobed when the adapter list is changed)
//
KEVENT                  gThreadsCheckAdapters[MAXIMUM_PROCESSORS];

//
// DEBUG-ONLY: Set this to a particular MAC address to break when receiving a packet
// from that address.
//
#if DBG
BOOLEAN                 gBreakOnMACAddress = FALSE;
UCHAR                   gBreakMACAddress[ETH_LENGTH_OF_ADDRESS] = {0, 0, 0, 0, 0, 0};
BOOLEAN                 gBreakIfNullPPI = FALSE;
#endif

//
// XPSP1: 565471
// We start out with this disabled.  Once we know that it's allowed, we re-allow bridging to 
// take place.
//
BOOLEAN gBridging = FALSE;
 
BOOLEAN gPrintPacketTypes = FALSE;

extern BOOLEAN gHaveID;

// ===========================================================================
//
// STATISTICS
//
// ===========================================================================

LARGE_INTEGER   gStatTransmittedFrames = { 0L, 0L };            // Local-source frames sent successfully to at least
                                                                // one adapter

LARGE_INTEGER   gStatTransmittedErrorFrames = { 0L, 0L };       // Local-source frames not sent AT ALL due to errors

LARGE_INTEGER   gStatTransmittedBytes = { 0L, 0L };             // Local-source bytes sent successfully to at least
                                                                // one adapter

// Breakdown of transmitted frames
LARGE_INTEGER   gStatDirectedTransmittedFrames = { 0L, 0L };
LARGE_INTEGER   gStatMulticastTransmittedFrames = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastTransmittedFrames = { 0L, 0L };

// Breakdown of transmitted bytes
LARGE_INTEGER   gStatDirectedTransmittedBytes = { 0L, 0L };
LARGE_INTEGER   gStatMulticastTransmittedBytes = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastTransmittedBytes = { 0L, 0L };


LARGE_INTEGER   gStatIndicatedFrames = { 0L, 0L };              // # of inbound frames indicated up

LARGE_INTEGER   gStatIndicatedDroppedFrames = { 0L, 0L };       // # of inbound frames we would have indicated but couldn't
                                                                // because of resources / error

LARGE_INTEGER   gStatIndicatedBytes = { 0L, 0L };               // # of inbound bytes indicated up

// Breakdown of indicated frames
LARGE_INTEGER   gStatDirectedIndicatedFrames = { 0L, 0L };
LARGE_INTEGER   gStatMulticastIndicatedFrames = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastIndicatedFrames = { 0L, 0L };

// Breakdown of indicated bytes
LARGE_INTEGER   gStatDirectedIndicatedBytes = { 0L, 0L };
LARGE_INTEGER   gStatMulticastIndicatedBytes = { 0L, 0L };
LARGE_INTEGER   gStatBroadcastIndicatedBytes = { 0L, 0L };

//
// The following stats are not reported to NDIS; they're here for our own amusement
//
LARGE_INTEGER   gStatReceivedFrames = { 0L, 0L };               // Total # of processed inbound packets
LARGE_INTEGER   gStatReceivedBytes = { 0L, 0L };                // Total inbound processed bytes

LARGE_INTEGER   gStatReceivedCopyFrames = { 0L, 0L };           // Total # of processed inbound packets WITH COPY
LARGE_INTEGER   gStatReceivedCopyBytes = { 0L, 0L };            // Total inbound processed bytes WITH COPY

LARGE_INTEGER   gStatReceivedNoCopyFrames = { 0L, 0L };         // Total # of processed inbound packets WITHOUT COPY
LARGE_INTEGER   gStatReceivedNoCopyBytes = { 0L, 0L };          // Total inbound processed bytes WITHOUT COPY

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

// Undocumented kernel function
extern KAFFINITY
KeSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );

VOID
BrdgFwdSendOnLink(
    IN  PADAPT          pAdapt,
    IN  PNDIS_PACKET    pPacket
    );

VOID
BrdgFwdReleaseBasePacket(
    IN PNDIS_PACKET         pPacket,
    PPACKET_INFO            ppi,
    PACKET_OWNERSHIP        Own,
    NDIS_STATUS             Status
    );

// This is the type of function to be passed to BrdgFwdHandlePacket()
typedef PNDIS_PACKET (*PPACKET_BUILD_FUNC)(PPACKET_INFO*, PADAPT, PVOID, PVOID, UINT, UINT);

NDIS_STATUS
BrdgFwdHandlePacket(
    IN PACKET_DIRECTION     PacketDirection,
    IN PADAPT               pTargetAdapt,
    IN PADAPT               pOriginalAdapt,
    IN BOOLEAN              bShouldIndicate,
    IN NDIS_HANDLE          MiniportHandle,
    IN PNDIS_PACKET         pBasePacket,
    IN PPACKET_INFO         ppi,
    IN PPACKET_BUILD_FUNC   pFunc,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    );

VOID
BrdgFwdWrapPacketForReceive(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    );

VOID
BrdgFwdWrapPacketForSend(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    );

// The type of function to pass to BrdgFwdCommonAllocAndWrapPacket
typedef VOID (*PWRAPPER_FUNC)(PNDIS_PACKET, PNDIS_PACKET);

PNDIS_PACKET
BrdgFwdCommonAllocAndWrapPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt,
    IN PWRAPPER_FUNC        pFunc
    );

VOID
BrdgFwdTransferComplete(
    IN NDIS_HANDLE          ProtocolBindingContext,
    IN PNDIS_PACKET         pPacket,
    IN NDIS_STATUS          Status,
    IN UINT                 BytesTransferred
    );

BOOLEAN
BrdgFwdNoCopyFastTrackReceive(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt,
    IN NDIS_HANDLE          MiniportHandle,
    IN PUCHAR               DstAddr,
    OUT BOOLEAN             *bRetainPacket
    );

PNDIS_PACKET
BrdgFwdMakeCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PVOID                pHeader,
    IN PVOID                pData,
    IN UINT                 HeaderSize,
    IN UINT                 DataSize,
    IN UINT                 SizeOfPacket,
    IN BOOLEAN              bCountAsReceived,
    IN PADAPT               pOwnerAdapt,
    PVOID                   *ppBuf
    );

PNDIS_PACKET
BrdgFwdMakeNoCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    );

PNDIS_PACKET
BrdgFwdMakeSendBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    );

// This is the per-processor queue-draining function
VOID
BrdgFwdProcessQueuedPackets(
    IN PVOID                Param1
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Tells us if we're allowed to bridge, or if GPO's are currently disallowing 
// bridging
//

__forceinline
BOOLEAN
BrdgFwdBridgingNetworks()
{
    return gBridging;
}

//
// Frees a packet that was used to wrap a base packet
//
__forceinline
VOID
BrdgFwdFreeWrapperPacket(
    IN PNDIS_PACKET     pPacket,
    IN PPACKET_INFO     ppi,
    IN PADAPT           pQuotaOwner
    )
{
    SAFEASSERT( BrdgBufIsWrapperPacket(pPacket) );
    BrdgBufUnchainCopyBuffers( pPacket );
    BrdgBufFreeWrapperPacket( pPacket, ppi, pQuotaOwner );
}

//
// Frees a base packet that wraps a packet descriptor from an overlying protocol
// or underlying NIC that we were allowed to hang on to
//
__forceinline
VOID
BrdgFwdFreeBaseWrapperPacket(
    IN PNDIS_PACKET     pPacket,
    IN PPACKET_INFO     ppi
    )
{
    SAFEASSERT( BrdgBufIsWrapperPacket(pPacket) );
    BrdgBufUnchainCopyBuffers( pPacket );
    BrdgBufFreeBaseWrapperPacket( pPacket, ppi );
}

//
// Allocates a new wrapper packet, chains on buffer descriptors so that the new
// packet points to the same data buffers as the old packet, and copies per-packet
// information appropriate for using the new packet for indications
//
__forceinline
PNDIS_PACKET
BrdgFwdAllocAndWrapPacketForReceive(
    IN PNDIS_PACKET         pPacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt
    )
{
    return BrdgFwdCommonAllocAndWrapPacket( pPacket, pppi, pTargetAdapt, BrdgFwdWrapPacketForReceive );
}

//
// Allocates a new wrapper packet, chains on buffer descriptors so that the new
// packet points to the same data buffers as the old packet, and copies per-packet
// information appropriate for using the new packet for transmits
//
__forceinline
PNDIS_PACKET
BrdgFwdAllocAndWrapPacketForSend(
    IN PNDIS_PACKET         pPacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt
    )
{
    return BrdgFwdCommonAllocAndWrapPacket( pPacket, pppi, pTargetAdapt, BrdgFwdWrapPacketForSend );
}

//
// Checks if an address is one of the reserved group addresses for the Spanning Tree Algorithm.
//
__forceinline
BOOLEAN
BrdgFwdIsSTAGroupAddress(
    IN PUCHAR               pAddr
    )
{
    return( (pAddr[0] == STA_MAC_ADDR[0]) && (pAddr[1] == STA_MAC_ADDR[1]) &&
            (pAddr[2] == STA_MAC_ADDR[2]) && (pAddr[3] == STA_MAC_ADDR[4]) &&
            (pAddr[4] == STA_MAC_ADDR[4]) );
}

//
// Checks that PacketDirection has been assigned
//
__forceinline
VOID
BrdgFwdValidatePacketDirection(
    IN PACKET_DIRECTION     Direction
    )
{
    SAFEASSERT( (Direction == BrdgPacketInbound) || (Direction == BrdgPacketOutbound) ||
                (Direction == BrdgPacketCreatedInBridge) );
}

//
// Queues a packet for deferred processing
//
_inline
VOID
BrdgFwdQueuePacket(
    IN PPACKET_Q_INFO       ppqi,
    IN PADAPT               pAdapt
    )
{
    BOOLEAN                 bSchedule = FALSE, bIncremented;

    // The queue lock protects the bServiceInProgress flag
    NdisAcquireSpinLock( &pAdapt->QueueLock );

    // Add the packet to the queue
    BrdgInsertTailSingleList( &pAdapt->Queue, &ppqi->List );
    bIncremented = BrdgIncrementWaitRef( &pAdapt->QueueRefcount );
    SAFEASSERT( bIncremented );
    if (bIncremented)
    {
        SAFEASSERT( (ULONG)pAdapt->QueueRefcount.Refcount == pAdapt->Queue.Length );

        // Check if anyone is already working on the queue
        if( !pAdapt->bServiceInProgress )
        {
            // Signal the queue event so someone will wake up
            pAdapt->bServiceInProgress = TRUE;
            bSchedule = TRUE;
        }
    }

    NdisReleaseSpinLock( &pAdapt->QueueLock );

    if( bSchedule )
    {
        KeSetEvent( &pAdapt->QueueEvent, EVENT_INCREMENT, FALSE );
    }
}

//
// Decrements a base packet's refcount and calls BrdgFwdReleaseBasePacket if the refcount
// reaches zero
//
_inline
BOOLEAN
BrdgFwdDerefBasePacket(
    IN PADAPT           pQuotaOwner,    // Can be NULL to not count quota
    IN PNDIS_PACKET     pBasePacket,
    IN PPACKET_INFO     ppi,
    IN NDIS_STATUS      Status
    )
{
    BOOLEAN             rc = FALSE;
    LONG                RefCount;

    SAFEASSERT( pBasePacket != NULL );
    SAFEASSERT( ppi != NULL );

    RefCount = NdisInterlockedDecrement( &ppi->u.BasePacketInfo.RefCount );
    SAFEASSERT( RefCount >= 0 );

    if( RefCount == 0 )
    {
        BrdgFwdReleaseBasePacket( pBasePacket, ppi, BrdgBufGetPacketOwnership( pBasePacket ), Status );
        rc = TRUE;
    }

    // Do quota bookkeeping if necessary
    if( pQuotaOwner != NULL )
    {
        BrdgBufReleaseBasePacketQuota( pBasePacket, pQuotaOwner );
    }

    return rc;
}

//
// Updates statistics to reflect a transmitted packet
//
_inline
VOID
BrdgFwdCountTransmittedPacket(
    IN PADAPT               pAdapt,
    IN PUCHAR               DstAddr,
    IN ULONG                PacketSize
    )
{
    SAFEASSERT( DstAddr != NULL );

    ExInterlockedAddLargeStatistic( &gStatTransmittedFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatTransmittedBytes, PacketSize );

    ExInterlockedAddLargeStatistic( &pAdapt->SentFrames, 1L );
    ExInterlockedAddLargeStatistic( &pAdapt->SentBytes, PacketSize );

    ExInterlockedAddLargeStatistic( &pAdapt->SentLocalFrames, 1L );
    ExInterlockedAddLargeStatistic( &pAdapt->SentLocalBytes, PacketSize );

    if( ETH_IS_MULTICAST(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatMulticastTransmittedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatMulticastTransmittedBytes, PacketSize );

        if( ETH_IS_BROADCAST(DstAddr) )
        {
            ExInterlockedAddLargeStatistic( &gStatBroadcastTransmittedFrames, 1L );
            ExInterlockedAddLargeStatistic( &gStatBroadcastTransmittedBytes, PacketSize );
        }
    }
    else
    {
        ExInterlockedAddLargeStatistic( &gStatDirectedTransmittedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatDirectedTransmittedBytes, PacketSize );
    }
}

//
// Updates statistics to reflect an indicated packet
//
_inline
VOID
BrdgFwdCountIndicatedPacket(
    IN PUCHAR               DstAddr,
    IN ULONG                PacketSize
    )
{
    ExInterlockedAddLargeStatistic( &gStatIndicatedFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatIndicatedBytes, PacketSize );

    if( ETH_IS_MULTICAST(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatMulticastIndicatedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatMulticastIndicatedBytes, PacketSize );

        if( ETH_IS_BROADCAST(DstAddr) )
        {
            ExInterlockedAddLargeStatistic( &gStatBroadcastIndicatedFrames, 1L );
            ExInterlockedAddLargeStatistic( &gStatBroadcastIndicatedBytes, PacketSize );
        }
    }
    else
    {
        ExInterlockedAddLargeStatistic( &gStatDirectedIndicatedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatDirectedIndicatedBytes, PacketSize );
    }
}

//
// Indicates a packet, counting it as such.
//
_inline
VOID
BrdgFwdIndicatePacket(
    IN PNDIS_PACKET         pPacket,
    IN NDIS_HANDLE          MiniportHandle
    )
{
    PVOID                   pHeader = BrdgBufGetPacketHeader(pPacket);

    SAFEASSERT( MiniportHandle != NULL );

    if( pHeader != NULL )
    {
        BrdgFwdCountIndicatedPacket( pHeader, BrdgBufTotalPacketSize(pPacket) );
    }
    // pHeader can only == NULL under heavy system stress

    NdisMIndicateReceivePacket( MiniportHandle, &pPacket, 1 );
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================


NTSTATUS
BrdgFwdDriverInit()
/*++

Routine Description:

    Initialization code.

    A return status other than STATUS_SUCCESS causes the driver load to abort.
    Any event causing an error return code must be logged.

    Must be called at PASSIVE_LEVEL

Arguments:

    None

Return Value:

    None

--*/
{
    INT             i;
    HANDLE          ThreadHandle;
    NTSTATUS        Status;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Initialize our thread synchronization primitives
    KeInitializeEvent( &gKillThreads, NotificationEvent, FALSE );

    for(i = 0; i < KeNumberProcessors; i++)
    {
        KeInitializeEvent( &gThreadsCheckAdapters[i], SynchronizationEvent, FALSE );

        // Spin up a thread for this processor
        Status = PsCreateSystemThread( &ThreadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL,
                                       BrdgFwdProcessQueuedPackets, (PVOID)(INT_PTR)i );

        if(! NT_SUCCESS(Status) )
        {
            // Abort startup
            NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_THREAD_CREATION_FAILED, 0L, 0L, NULL,
                                    sizeof(NTSTATUS), &Status );
            DBGPRINT(FWD, ("Failed to create a system thread: %08x\n", Status));
            BrdgFwdCleanup();
            return Status;
        }

        // Retrieve a pointer to the thread object and reference it so we can wait for
        // its termination safely.
        Status = ObReferenceObjectByHandle( ThreadHandle, STANDARD_RIGHTS_ALL, NULL, KernelMode,
                                            &gThreadPtrs[i], NULL );

        if(! NT_SUCCESS(Status) )
        {
            // Abort startup
            NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_THREAD_REF_FAILED, 0L, 0L, NULL,
                                    sizeof(NTSTATUS), &Status );
            DBGPRINT(FWD, ("Couldn't retrieve a thread pointer: %08x\n", Status));
            BrdgFwdCleanup();
            return Status;
        }

        gNumThreads++;
    }

    return STATUS_SUCCESS;
}

VOID
BrdgFwdCleanup()
/*++

Routine Description:

    Unload-time orderly cleanup

    This function is guaranteed to be called exactly once

    Must be called at < DISPATCH_LEVEL since we wait on an event

Arguments:

    None

Return Value:

    None

--*/
{
    KWAIT_BLOCK         WaitBlocks[MAXIMUM_WAIT_OBJECTS];
    NTSTATUS            Status;
    UINT                i;

    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);

    // Signal the threads to exit
    KeSetEvent( &gKillThreads, EVENT_INCREMENT, FALSE );

    // Block waiting for all threads to exit
    Status = KeWaitForMultipleObjects( gNumThreads, gThreadPtrs, WaitAll, Executive,
                                       KernelMode, FALSE, NULL, WaitBlocks );

    if( ! NT_SUCCESS(Status) )
    {
        // This really shouldn't happen
        DBGPRINT(FWD, ("KeWaitForMultipleObjects failed in BrdgFwdCleanup! %08x\n", Status));
        SAFEASSERT(FALSE);
    }

    // Dereference all thread objects to allow them to be destroyed
    for( i = 0; i < gNumThreads; i++ )
    {
        ObDereferenceObject( gThreadPtrs[i] );
    }
}

PNDIS_PACKET
BrdgFwdMakeCompatCopyPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PUCHAR             *pPacketData,
    OUT PUINT               packetDataSize,
    BOOLEAN                 bCountAsLocalSend
    )
/*++

Routine Description:

    Allocates a copy packet and fills it with a copy of the data from the given base
    packet. Used by the compatibility-mode code to make a copy packet that it can
    edit easily

Arguments:

    pBasePacket             Packet to copy from
    pPacketData             Receives a pointer to the flat data buffer of the new packet
    packetDataSize          Receives the size of the copied data
    bBasePacketIsInbound    TRUE if the packet being copied is outbound from higher-level
                            protocols; the packet will be counted as a miniport
                            transmission if / when it is send out an adapter.
                            FALSE causes the packet to not be counted as a local transmission.

Return Value:

    The new packet

--*/
{
    PNDIS_PACKET            pCopyPacket;
    PPACKET_INFO            ppi;
    UINT                    copiedBytes;

    // Find out how much data is in the base packet
    NdisQueryPacket( pBasePacket, NULL, NULL, NULL, packetDataSize );

    // Make a base copy packet with no data in it
    pCopyPacket = BrdgFwdMakeCopyBasePacket( &ppi, NULL, NULL, 0, 0, *packetDataSize, FALSE, NULL, pPacketData );

    if( pCopyPacket == NULL )
    {
        return NULL;
    }

    SAFEASSERT( ppi != NULL );
    SAFEASSERT( *pPacketData != NULL );

    // Set the original direction flags
    if( bCountAsLocalSend )
    {
        ppi->Flags.OriginalDirection = BrdgPacketOutbound;
    }
    else
    {
        ppi->Flags.OriginalDirection = BrdgPacketCreatedInBridge;
    }

    // Copy the data from the base packet to the copy packet
    NdisCopyFromPacketToPacket( pCopyPacket, 0, *packetDataSize, pBasePacket, 0, &copiedBytes );

    if( copiedBytes != *packetDataSize )
    {
        // We couldn't copy all the data. Bail out.
        THROTTLED_DBGPRINT(FWD, ("Failed to copy into a copy packet for compatibility processing\n"));
        BrdgFwdReleaseBasePacket(pCopyPacket, ppi, BrdgBufGetPacketOwnership(pCopyPacket), NDIS_STATUS_RESOURCES);
        return NULL;
    }

    // Put a pointer to the ppi where we expect to find it on completion
    *((PPACKET_INFO*)pCopyPacket->ProtocolReserved) = ppi;
    *((PPACKET_INFO*)pCopyPacket->MiniportReserved) = ppi;

    // Do fixups usually performed by BrdgFwdHandlePacket()
    ppi->u.BasePacketInfo.RefCount = 1L;
    ppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

    // The packet is now ready to be sent. We expect the compatibility code to do its work
    // and call BrdgFwdSendPacketForComp() to transmit the packet.
    return pCopyPacket;
}

VOID
BrdgFwdSendPacketForCompat(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Transmits a packet on behalf of the compatibility-mode module.
    The packet must have been previously allocated with BrdgFwdMakeCompatCopyPacket.

Arguments:

    pPacket                 The packet to transmit
    pAdapt                  The adapter to transmit on

Return Value:

    None

--*/
{
    PPACKET_INFO            ppi;
    NDIS_STATUS             status;

    // Make sure the packet hasn't been monkeyed with inappropriately
    ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved);
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    // Make sure this is a one-shot packet
    ppi->u.BasePacketInfo.RefCount = 1L;

    // We must do a quota check before sending the packet, as the packet completion
    // logic assumes all sent packets have been assigned to their outbound adapters
    if( BrdgBufAssignBasePacketQuota(pPacket, pAdapt) )
    {
        // We passed quota. Transmit the packet.
        BrdgFwdSendOnLink( pAdapt, pPacket );
    }
    else
    {
        // We didn't pass quota. Fail the transmission.
        DBGPRINT(FWD, ("Failed to send a compatibility packet because of quota failure\n"));
        status = NDIS_STATUS_RESOURCES;
        BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_RESOURCES);
    }
}

VOID
BrdgFwdIndicatePacketForCompat(
    IN PNDIS_PACKET         pPacket
    )
/*++

Routine Description:

    Indicates a packet on behalf of the compatibility-mode module.
    The packet must be a base copy packet that we own.

Arguments:

    pPacket                 The packet to indicate

Return Value:

    None

--*/
{
    PPACKET_INFO            ppi;
    NDIS_STATUS             status;
    NDIS_HANDLE             MiniportHandle;

    // Make sure the packet is a base packet and isn't out of
    // whack
    ppi = *((PPACKET_INFO*)pPacket->MiniportReserved);
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    // Packets that come to us for indication from the compatibility
    // module are our own base packets that haven't had their refcount
    // set yet. Set the packet's refcount to 1, since its buffers
    // should never be shared.
    ppi->u.BasePacketInfo.RefCount = 1L;

    MiniportHandle = BrdgMiniAcquireMiniportForIndicate();

    if( MiniportHandle != NULL )
    {
        // Check the quota for the local miniport
        if( BrdgBufAssignBasePacketQuota(pPacket, LOCAL_MINIPORT) )
        {
            // We passed quota.
            BrdgFwdIndicatePacket( pPacket, MiniportHandle );
        }
        else
        {
            // We didn't pass quota. Fail the transmission.
            DBGPRINT(FWD, ("Failed to indicate a compatibility packet because of quota failure\n"));
            status = NDIS_STATUS_RESOURCES;
            BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_RESOURCES);
        }

        BrdgMiniReleaseMiniportForIndicate();
    }
    else
    {
        // No miniport. Ditch the packet.
        BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_SUCCESS);
    }
}

VOID BrdgFwdReleaseCompatPacket(
    IN PNDIS_PACKET         pPacket
    )
/*++

Routine Description:

    Releases a packet previously allocated with BrdgFwdMakeCompatCopyPacket.

Arguments:

    pPacket                 The packet to release

Return Value:

    None

--*/
{
    PPACKET_INFO            ppi;

    // Retrieve the PACKET_INFO pointer
    ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved);
    SAFEASSERT( ppi->pOwnerPacket == pPacket );
    SAFEASSERT( ppi->Flags.bIsBasePacket );
    BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
BrdgFwdSendBuffer(
    IN PADAPT               pAdapt,
    IN PUCHAR               pPacketData,
    IN UINT                 DataSize
    )
/*++

Routine Description:

    Sends a raw buffer on a particular adapter. Used to send frames in response
    to user-mode requests.

Arguments:

    pAdapt                  The adapter to send on
    pPacketData             The frame
    DataSize                The size of the supplied frame

Return Value:

    Status of the packet transmission

--*/
{
    PNDIS_PACKET            pPacket;
    PPACKET_INFO            ppi;

    // Build a packet around this buffer
    pPacket = BrdgFwdMakeCopyBasePacket( &ppi, pPacketData, NULL, DataSize, 0, DataSize, FALSE, NULL, NULL );

    if( pPacket == NULL )
    {
        return NDIS_STATUS_RESOURCES;
    }

    SAFEASSERT( ppi != NULL );

    // We must do a quota check before sending the packet, as the packet completion
    // logic assumes all sent packets have been assigned to their outbound adapters
    if( ! BrdgBufAssignBasePacketQuota(pPacket, pAdapt) )
    {
        // We didn't pass quota. Fail the transmission.
        DBGPRINT(FWD, ("Failed to send a raw buffer because of quota failure\n"));
        BrdgFwdReleaseBasePacket(pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), NDIS_STATUS_RESOURCES);
        return NDIS_STATUS_RESOURCES;
    }

    // Put a pointer to the ppi where we expect to find it on completion
    *((PPACKET_INFO*)pPacket->ProtocolReserved) = ppi;

    // Do fixups usually performed by BrdgFwdHandlePacket()
    ppi->u.BasePacketInfo.RefCount = 1L;
    ppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

    // Send the packet
    BrdgFwdSendOnLink( pAdapt, pPacket );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
BrdgFwdReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               pHeader,
    IN  UINT                HeaderSize,
    IN  PVOID               pLookAheadBuffer,
    IN  UINT                LookAheadSize,
    IN  UINT                PacketSize
    )
/*++

Routine Description:

    NDIS copy-path entry point. Receives an inbound packet on the copy path.

    Because the indicated data buffers are valid only for the duration of this
    function, we must copy the indicated data to our own packet descriptor
    before proceeding.

Arguments:

    ProtocolBindingContext  The receiving adapter
    MacReceiveContext       Must be passed as a param to certain Ndis APIs
    pHeader                 Packet header buffer
    HeaderSize              Size of pHeader
    pLookAheadBuffer        Buffer with packet data
    LookAheadSize           Size of pLookAheadBuffer
    PacketSize              Total packet size

Return Value:

    Status of the receive (cannot be NDIS_STATUS_PENDING)

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext, TargetAdapt = NULL;
    PUCHAR              SrcAddr = ((PUCHAR)pHeader) + ETH_LENGTH_OF_ADDRESS, DstAddr = pHeader;
    PNDIS_PACKET        pNewPacket;
    PPACKET_INFO        ppi;
    PPACKET_Q_INFO      ppqi;
    UINT                SizeOfPacket = HeaderSize + PacketSize;
    BOOLEAN             bIsSTAPacket = FALSE, bIsUnicastToBridge = FALSE, bRequiresCompatWork = FALSE;
    UINT                result;

#if DBG
    // Paranoia check for incorrectly looped-back packets
    {
        PNDIS_PACKET    pPacket = NdisGetReceivedPacket(pAdapt->BindingHandle, MacReceiveContext);

        if( pPacket != NULL )
        {
            SAFEASSERT( BrdgBufGetPacketOwnership(pPacket) == BrdgNotOwned );
        }
    }

    // Break on packets from gBreakMACAddress
    if( gBreakOnMACAddress )
    {
        ETH_COMPARE_NETWORK_ADDRESSES_EQ( SrcAddr, gBreakMACAddress, &result );

        if( result == 0 )
        {
            KdBreakPoint();
        }
    }
#endif
    //
    // We don't accept packets that are sent from our MAC address to us.
    //
    ETH_COMPARE_NETWORK_ADDRESSES_EQ( SrcAddr, gBridgeAddress, &result );

    if (0 == result)
    {
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    // Don't accept packets if we are shutting down or this adapter is being torn down or reset
    if( (gShuttingDown) || (pAdapt->bResetting) || (! BrdgAcquireAdapter(pAdapt)) )
    {
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    // Must have at least a complete Ethernet header!
    if( HeaderSize < ETHERNET_HEADER_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Too-small header seen in BrdgFwdReceive!\n"));
        BrdgReleaseAdapter( pAdapt );
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    // Packet can't be larger than the maximum size we can handle
    if( SizeOfPacket > MAX_PACKET_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Too-large packet seen in BrdgFwdReceive!\n"));
        BrdgReleaseAdapter( pAdapt );
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    //
    // If this is an STA packet, we go through all the receive motions regardless of
    // our state
    //
    if( BrdgFwdIsSTAGroupAddress(DstAddr) )
    {
        if( DstAddr[5] == STA_MAC_ADDR[5] )
        {
            bIsSTAPacket = TRUE;
            TargetAdapt = NULL;
        }
        else
        {
            // Packet was sent to a reserved multicast address that we don't use.
            // We mustn't forward the frame.
            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }
    }

    if( ! bIsSTAPacket )
    {
        // Note the MAC address of the frame if this adapter is learning
        if( (pAdapt->State == Learning) || (pAdapt->State == Forwarding) )
        {
            BrdgTblNoteAddress(SrcAddr, pAdapt);
        }

        //
        // Check if we are accepting packets or not
        //
        if( pAdapt->State != Forwarding )
        {
            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }

        //
        // Look up the target in our table.
        // ** TargetAdapt comes back with its refcount incremented!
        //
        TargetAdapt = BrdgTblFindTargetAdapter( DstAddr );

        // If the target host is known to be on the same segment as the received
        // packet, there is no need to forward the packet.
        //
        // Also bail out here if the target adapter is resetting
        if( (TargetAdapt == pAdapt) ||
            ((TargetAdapt != NULL) && (TargetAdapt->bResetting)) )
        {
            BrdgReleaseAdapter( TargetAdapt );
            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }

        // Learn if this packet requires compatibility-mode processing later
        // (this forces us to copy the packet to our own buffers and queue it)
        bRequiresCompatWork = BrdgCompRequiresCompatWork( pAdapt, pHeader, HeaderSize );

        // If the packet came in on a compatibility adapter, or is going to
        // a compatibility-mode adapter, but the compatibility code is not
        // interested in it, there is nothing further to be done with the packet.
        if( (pAdapt->bCompatibilityMode || ((TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode)))
                &&
            (! bRequiresCompatWork) )
        {
            if( TargetAdapt != NULL )
            {
                BrdgReleaseAdapter( TargetAdapt );
            }

            BrdgReleaseAdapter( pAdapt );
            return NDIS_STATUS_NOT_ACCEPTED;
        }

        bIsUnicastToBridge = BrdgMiniIsUnicastToBridge(DstAddr);

        // Sanity
        if( bIsUnicastToBridge && (TargetAdapt != NULL) )
        {
            //
            // This indicates that someone else on the network is using our MAC address,
            // or that there is an undetected loop such that we are seeing our own traffic!
            // Either way, this is very bad.
            //
            THROTTLED_DBGPRINT(FWD, ("*** Have a table entry for our own MAC address! PROBABLE NET LOOP!\n"));

            // Ditch the target adapter since we won't be using it
            BrdgReleaseAdapter( TargetAdapt );
            TargetAdapt = NULL;
        }
    }
    // else was STA packet; continue processing below

    //
    // There is no fast-track on the copy-receive path. Copy the packet data into our
    // own descriptor and queue the packet for processing later.
    //
    if (LookAheadSize == PacketSize)
    {
        // A normal, non-fragmented indicate. Copy the data to a new packet.
        pNewPacket = BrdgFwdMakeCopyBasePacket( &ppi, pHeader, pLookAheadBuffer, HeaderSize, LookAheadSize,
                                                SizeOfPacket, TRUE, pAdapt, NULL );

        if( pNewPacket == NULL )
        {
            // We failed to get a copy packet to wrap this data
            goto failure;
        }

        SAFEASSERT( ppi != NULL );

        if (bRequiresCompatWork && (TargetAdapt == NULL) && !bIsUnicastToBridge)
        {
            TargetAdapt = BrdgCompFindTargetAdapterForIPAddress(pNewPacket);
            if (TargetAdapt && !BrdgAcquireAdapter(TargetAdapt))
            {
                return NDIS_STATUS_NOT_ACCEPTED;
            }
        }

        // Queue the new packet for processing
        ppqi = (PPACKET_Q_INFO)&pNewPacket->ProtocolReserved;

        ppqi->u.pTargetAdapt = TargetAdapt;
        ppqi->pInfo = ppi;
        ppqi->Flags.bIsSTAPacket = bIsSTAPacket;
        ppqi->Flags.bFastTrackReceive = FALSE;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bIsUnicastToBridge )
        {
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bIsUnicastToBridge = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
        }
        else
        {
            ppqi->Flags.bIsUnicastToBridge = FALSE;
            ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
        }

        BrdgFwdQueuePacket( ppqi, pAdapt );
    }
    else
    {
        NDIS_STATUS         Status;
        UINT                transferred;
        PNDIS_BUFFER        pBufDesc;
        PUCHAR              pBuf;

        //
        // This is an unusual code path in this day and age; the underlying driver
        // is an old NDIS driver that still does fragmented receives.
        //
        SAFEASSERT( LookAheadSize < PacketSize );

        // Get copy packet and copy in the header data (but NOT the lookahead)
        pNewPacket = BrdgFwdMakeCopyBasePacket( &ppi, pHeader, NULL, HeaderSize, 0, SizeOfPacket, TRUE, pAdapt, &pBuf );

        if( pNewPacket == NULL )
        {
            // We failed to get a copy packet
            goto failure;
        }

        SAFEASSERT( ppi != NULL );
        SAFEASSERT( pBuf != NULL );

        //
        // NdisTransferData is kind of a crummy API; it won't copy the entire packet
        // (i.e., you have to copy the header separately), and it won't let you specify
        // an offset in the receiving packet to copy to. The NIC wants to copy into the
        // beginning of the first buffer chained to the packet.
        //
        // Because of this silliness, we copy the header into the beginning of our copy
        // packet's data buffer (done in the call to BrdgFwdMakeCopyBasePacket above).
        //
        // Then we grab a NEW buffer descriptor, point it to the area of the data buffer
        // *after* the header, and chain it to the front of the packet. Then we request
        // that all data (other than the header) be copied.
        //
        // In BrdgFwdTransferComplete, we rip off the leading buffer descriptor and
        // dispose of it, leaving a single buffer descriptor that correctly describes
        // the (single) data buffer, now containing all data.
        //
        pBufDesc = BrdgBufAllocateBuffer( pBuf + HeaderSize, PacketSize );

        if( pBufDesc == NULL )
        {
            BrdgFwdReleaseBasePacket( pNewPacket, ppi, BrdgBufGetPacketOwnership(pNewPacket),
                                      NDIS_STATUS_FAILURE );

            goto failure;
        }

        // Chain this to the front of the packet where it will be used during the copy
        NdisChainBufferAtFront( pNewPacket, pBufDesc );

        // Set up the queuing structure in the packet's ProtocolReserved area
        ppqi = (PPACKET_Q_INFO)&pNewPacket->ProtocolReserved;
        ppqi->u.pTargetAdapt = TargetAdapt;
        ppqi->pInfo = ppi;
        ppqi->Flags.bIsSTAPacket = bIsSTAPacket;
        ppqi->Flags.bFastTrackReceive = FALSE;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bIsUnicastToBridge )
        {
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bIsUnicastToBridge = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
        }
        else
        {
            ppqi->Flags.bIsUnicastToBridge = FALSE;
            ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
        }

        // Ask the NIC to copy the packet's data into the new packet
        NdisTransferData( &Status, pAdapt->BindingHandle, MacReceiveContext, 0, PacketSize,
                          pNewPacket, &transferred );

        if( Status == NDIS_STATUS_SUCCESS )
        {
            // Call BrdgFwdTransferComplete by hand to postprocess the packet.
            BrdgFwdTransferComplete( (NDIS_HANDLE)pAdapt, pNewPacket, Status, transferred );
        }
        else if( Status != NDIS_STATUS_PENDING )
        {
            // The transfer failed for some reason.
            NdisUnchainBufferAtFront( pNewPacket, &pBufDesc );

            if( pBufDesc != NULL )
            {
                NdisFreeBuffer( pBufDesc );
            }
            else
            {
                SAFEASSERT( FALSE );
            }

            BrdgFwdReleaseBasePacket( pNewPacket, ppi, BrdgBufGetPacketOwnership(pNewPacket),
                                      NDIS_STATUS_FAILURE );

            goto failure;
        }
        // else BrdgFwdTransferComplete will be called to postprocess the packet.
    }

    BrdgReleaseAdapter( pAdapt );
    return NDIS_STATUS_SUCCESS;

failure:
    if( TargetAdapt != NULL )
    {
        BrdgReleaseAdapter( TargetAdapt );
    }

    if( BrdgMiniShouldIndicatePacket(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
    }

    BrdgReleaseAdapter( pAdapt );
    return NDIS_STATUS_NOT_ACCEPTED;
}

VOID
BrdgFwdTransferComplete(
    IN NDIS_HANDLE          ProtocolBindingContext,
    IN PNDIS_PACKET         pPacket,
    IN NDIS_STATUS          Status,
    IN UINT                 BytesTransferred
    )
/*++

Routine Description:

    NDIS entry point, registered in BrdgProtRegisterProtocol. Called when a
    call to NdisTransferData() that returned NDIS_STATUS_PENDING completes
    (we also call this by hand to postprocess a call that completes immediately).

    If the data copy from the underlying NIC was successful, the packet is
    queued for processing on the owner adapter's queue. Otherwise the packet
    is released.

Arguments:

    ProtocolBindingContext      The receiving adapter
    pPacket                     The base packet into which data was being copied
    Status                      Status of the copy
    BytesTransferred            Number of transferred bytes (unused)

Return Value:

    None

--*/
{
    PADAPT                  pAdapt = (PADAPT)ProtocolBindingContext;
    PPACKET_Q_INFO          ppqi = (PPACKET_Q_INFO)&pPacket->ProtocolReserved;
    PNDIS_BUFFER            pBuf;

    SAFEASSERT( pAdapt != NULL );
    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( ppqi->pInfo != NULL );
    SAFEASSERT( ppqi->pInfo->pOwnerPacket == pPacket );
    SAFEASSERT( ppqi->Flags.bFastTrackReceive == FALSE );

    // Remove the extra buffer descriptor on the front of the packet and dispose of it
    // (see comments in BrdgFwdReceive() for details)
    NdisUnchainBufferAtFront( pPacket, &pBuf );

    if( pBuf != NULL )
    {
        NdisFreeBuffer( pBuf );
    }
    else
    {
        // Should never happen
        SAFEASSERT( FALSE );
    }

    // We should still have the original buffer descriptor describing the entire data buffer
    // chained to the packet
    SAFEASSERT( BrdgBufPacketHeadBuffer(pPacket) != NULL );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // The copy failed. Undo everything.
        if( ppqi->u.pTargetAdapt != NULL )
        {
            BrdgReleaseAdapter( ppqi->u.pTargetAdapt );
        }

        if( ppqi->Flags.bShouldIndicate )
        {
            ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
        }

        BrdgFwdReleaseBasePacket( pPacket, ppqi->pInfo, BrdgBufGetPacketOwnership(pPacket), Status );
    }
    else
    {
        // Success! Queue the packet for processing
        BrdgFwdQueuePacket( ppqi, pAdapt );
    }
}

INT
BrdgFwdReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pPacket
    )
/*++

Routine Description:

    NDIS no-copy entry point

    Receives a packet on the no-copy path

Arguments:

    ProtocolBindingContext  The adapter on which the packet is received
    pPacket                 The received packet

Return Value:

    The number of times we will call NdisReturnPackets() to free this packet.
    We return 0 to complete immediately or 1 to pend.

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext, TargetAdapt;
    UINT                PacketSize;
    PNDIS_BUFFER        Buffer;
    PUCHAR              DstAddr, SrcAddr;
    UINT                Size;
    PPACKET_Q_INFO      ppqi;
    INT                 rc;
    BOOLEAN             bForceCopy = FALSE, bFastTrack = FALSE, bIsUnicastToBridge = FALSE,
                        bRequiresCompatWork = FALSE;

    // Paranoia check for incorrectly looped-back packets
    SAFEASSERT( BrdgBufGetPacketOwnership(pPacket) == BrdgNotOwned );

    // Don't receive packets if we are shutting down or this adapter is being torn down or reset
    if ( gShuttingDown || (pAdapt->bResetting) || (! BrdgAcquireAdapter(pAdapt)) )
    {
        return 0;
    }

    NdisQueryPacket(pPacket, NULL, NULL, &Buffer, &PacketSize);

    if (!Buffer)
    {
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    NdisQueryBufferSafe(Buffer, &DstAddr, &Size, NormalPagePriority);

    if( DstAddr == NULL )
    {
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Must have at least a complete Ethernet header!
    if( Size < ETHERNET_HEADER_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Packet smaller than Ethernet header seen!\n"));
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Packet can't be larger than the maximum we can handle
    if( Size > MAX_PACKET_SIZE )
    {
        THROTTLED_DBGPRINT(FWD, ("Over-large packet seen!\n"));
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    SrcAddr = DstAddr + ETH_LENGTH_OF_ADDRESS;

#if DBG
    // Break on packets from gBreakMACAddress
    if( gBreakOnMACAddress )
    {
        UINT result;

        ETH_COMPARE_NETWORK_ADDRESSES_EQ( SrcAddr, gBreakMACAddress, &result );

        if( result == 0 )
        {
            KdBreakPoint();
        }
    }
#endif

    //
    // If this is an STA packet, don't process it, but hand it off
    //
    if( BrdgFwdIsSTAGroupAddress(DstAddr) )
    {
        if( (! gDisableSTA) && (DstAddr[5] == STA_MAC_ADDR[5]))
        {
            if (BrdgFwdBridgingNetworks())
            {
                // Hand off this packet for processing
                BrdgSTAReceivePacket( pAdapt, pPacket );
            }
        }

        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Note the MAC address of the frame if this adapter is learning
    if( (pAdapt->State == Learning) || (pAdapt->State == Forwarding) )
    {
        BrdgTblNoteAddress(SrcAddr, pAdapt);
    }

    //
    // Check if we are accepting packets or not
    //
    if( pAdapt->State != Forwarding )
    {
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Look up the target in our table
    TargetAdapt = BrdgTblFindTargetAdapter( DstAddr );

    // If the target host is known to be on the same segment as the received
    // packet, there is no need to forward the packet.
    //
    // Also bail out if the target adapter is resetting
    if( (TargetAdapt == pAdapt) ||
        ((TargetAdapt != NULL) && (TargetAdapt->bResetting)) )
    {
        BrdgReleaseAdapter( TargetAdapt );
        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    // Check if the packet will require compatibility-mode processing
    bRequiresCompatWork = BrdgCompRequiresCompatWork( pAdapt, DstAddr, Size );

    // If a packet requires compatibility work, we MUST copy it so the
    // compatibility code has a flat, editable buffer to work with.
    if( bRequiresCompatWork )
    {
        bForceCopy = TRUE;
    }

    // If the packet came in on a compatibility adapter, or is going to
    // a compatibility-mode adapter, but the compatibility code is not
    // interested in it, there is nothing further to be done with the packet.
    if( (pAdapt->bCompatibilityMode || ((TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode)))
            &&
        (! bRequiresCompatWork) )
    {
        if( TargetAdapt != NULL )
        {
            BrdgReleaseAdapter( TargetAdapt );
        }

        BrdgReleaseAdapter( pAdapt );
        return 0;
    }

    //
    // If this packet is a unicast packet ONLY for the local machine,
    // we can fast-track it by just passing through the indication to
    // upper-layer protocols.
    //
    // We can't pull this stunt if the packet requires compatibility-mode
    // processing.
    //

    bIsUnicastToBridge = BrdgMiniIsUnicastToBridge(DstAddr);

    if( bIsUnicastToBridge && (!bRequiresCompatWork) )
    {
        NDIS_HANDLE         MiniportHandle;
        BOOLEAN             bRemaining, bRetain;

        if( TargetAdapt != NULL )
        {
            //
            // This indicates that someone else on the network is using our MAC address,
            // or that there is an undetected loop such that we are seeing our own traffic!
            // Either way, this is very bad.
            //
            THROTTLED_DBGPRINT(FWD, ("** Have a table entry for our own MAC address! PROBABLE NET LOOP!\n"));

            // We won't be needing the target adapter
            BrdgReleaseAdapter( TargetAdapt );
            TargetAdapt = NULL;
        }

        MiniportHandle = BrdgMiniAcquireMiniportForIndicate();

        if( MiniportHandle == NULL )
        {
            // Nothing to do with this packet since we don't have a miniport to
            // indicate it with!
            BrdgReleaseAdapter( pAdapt );
            return 0;
        }

        //
        // Figure out if it's possible to fast-track this packet
        //
        NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

        if( bRemaining )
        {
            //
            // We can fast-track right away if the packet queue for this adapter
            // is empty. Otherwise, we would be cutting ahead of other packets from this
            // adapter.
            //
            if( ! pAdapt->bServiceInProgress )
            {
                // We can fast-track this packet right now.

                if( BrdgFwdNoCopyFastTrackReceive(pPacket, pAdapt, MiniportHandle, DstAddr, &bRetain) )
                {
                    // bRetain tells us whether to retain ownership of this packet or not
                    BrdgReleaseAdapter( pAdapt );
                    BrdgMiniReleaseMiniportForIndicate();
                    return bRetain ? 1 : 0;
                }
                else
                {
                    // This should never happen since we checked to see if there was stack room
                    SAFEASSERT( FALSE );

                    bForceCopy = TRUE;
                    bFastTrack = FALSE;
                }
            }
            else
            {
                // We want to fast-track this packet but the processing queue is not
                // empty. Flag it for fast-tracking in the queue draining thread.
                bFastTrack = TRUE;
                bForceCopy = FALSE;
            }
        }
        else
        {
            // Force this packet to be copied into a base packet since
            // we know it can't be fast-tracked.
            bForceCopy = TRUE;
            bFastTrack = FALSE;
        }

        // Allow the miniport to shut down
        BrdgMiniReleaseMiniportForIndicate();
    }

    //
    // We couldn't fast-track the packet. We will have to queue it for processing.
    //

    if ( bForceCopy || !bFastTrack || (NDIS_GET_PACKET_STATUS(pPacket) == NDIS_STATUS_RESOURCES) )
    {
        // We must copy this packet's data.
        PNDIS_PACKET        pNewPacket;
        PPACKET_INFO        ppi;
        UINT                copied;

        // Get a new copy packet with nothing copied in yet.
        pNewPacket = BrdgFwdMakeCopyBasePacket( &ppi, NULL, NULL, 0, 0, PacketSize, TRUE, pAdapt, NULL );

        if( pNewPacket == NULL )
        {
            // Failed to get a copy packet to hold the data.
            goto failure;
        }

        SAFEASSERT( ppi != NULL );

        // Copy data out of the old packet into the new one
        NdisCopyFromPacketToPacket( pNewPacket, 0, PacketSize, pPacket, 0, &copied );

        if( copied != PacketSize )
        {
            BrdgFwdReleaseBasePacket( pNewPacket, ppi, BrdgBufGetPacketOwnership(pNewPacket),
                                      NDIS_STATUS_FAILURE );

            goto failure;
        }

        if (bRequiresCompatWork && (TargetAdapt == NULL) && !bIsUnicastToBridge)
        {
            TargetAdapt = BrdgCompFindTargetAdapterForIPAddress(pNewPacket);
            if (TargetAdapt && !BrdgAcquireAdapter(TargetAdapt))
            {
                TargetAdapt = NULL;
            }
        }        

        // Queue the new base packet for processing
        ppqi = (PPACKET_Q_INFO)&pNewPacket->ProtocolReserved;
        ppqi->pInfo = ppi;
        ppqi->u.pTargetAdapt = TargetAdapt;
        ppqi->Flags.bIsSTAPacket = FALSE;
        ppqi->Flags.bFastTrackReceive = FALSE;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bIsUnicastToBridge )
        {
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bIsUnicastToBridge = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
        }
        else
        {
            ppqi->Flags.bIsUnicastToBridge = FALSE;
            ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
        }

        // The NIC gets its packet back immediately since we copied its data
        rc = 0;
    }
    else
    {
        // Queue the original packet for processing
        ppqi = (PPACKET_Q_INFO)&pPacket->ProtocolReserved;
        ppqi->pInfo = NULL;
        ppqi->Flags.bIsSTAPacket = FALSE;
        ppqi->Flags.bIsUnicastToBridge = bIsUnicastToBridge;
        ppqi->Flags.bRequiresCompatWork = bRequiresCompatWork;

        if( bFastTrack )
        {
            SAFEASSERT( bIsUnicastToBridge );
            SAFEASSERT( TargetAdapt == NULL );
            ppqi->Flags.bFastTrackReceive = TRUE;
            ppqi->Flags.bShouldIndicate = TRUE;
            ppqi->u.pOriginalAdapt = pAdapt;
        }
        else
        {
            ppqi->Flags.bFastTrackReceive = FALSE;
            ppqi->u.pTargetAdapt = TargetAdapt;

            if( bIsUnicastToBridge )
            {
                SAFEASSERT( TargetAdapt == NULL );
                ppqi->Flags.bShouldIndicate = TRUE;
            }
            else
            {
                ppqi->Flags.bShouldIndicate = BrdgMiniShouldIndicatePacket(DstAddr);
            }
        }

        // We require the use of the packet until our processing is complete
        rc = 1;
    }

    // Queue the packet for processing
    BrdgFwdQueuePacket( ppqi, pAdapt );

    BrdgReleaseAdapter( pAdapt );
    return rc;

failure:
    if( TargetAdapt != NULL )
    {
        BrdgReleaseAdapter( TargetAdapt );
    }

    if( BrdgMiniShouldIndicatePacket(DstAddr) )
    {
        ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
    }

    BrdgReleaseAdapter( pAdapt );

    // We are done with this packet
    return 0;
}

NDIS_STATUS
BrdgFwdSendPacket(
    IN PNDIS_PACKET     pPacket
    )
/*++

Routine Description:

    Called to handle the transmission of a packet from an overlying protocol

Arguments:

    pPacket             The packet to send

Return Value:

    Status of the send (NDIS_STATUS_PENDING means the send will be completed later)

--*/
{
    PNDIS_BUFFER        Buffer;
    PUCHAR              DstAddr;
    UINT                Size;
    PADAPT              TargetAdapt;
    BOOLEAN             bRemaining;
    NDIS_STATUS         Status;
    PNDIS_PACKET_STACK  pStack;

    NdisQueryPacket(pPacket, NULL, NULL, &Buffer, NULL);
    NdisQueryBufferSafe(Buffer, &DstAddr, &Size, NormalPagePriority);

    if( DstAddr == NULL )
    {
        return NDIS_STATUS_RESOURCES;
    }

    //
    // See if we know the adapter to reach the target through
    //
    TargetAdapt = BrdgTblFindTargetAdapter( DstAddr );

    // Fail silently if the target adapter is resetting
    if( (TargetAdapt != NULL) && (TargetAdapt->bResetting) )
    {
        BrdgReleaseAdapter( TargetAdapt );
        return NDIS_STATUS_SUCCESS;
    }

    // Do compatibility processing, unless the packet is going to
    // a known target that isn't on a compatibility adapter (in
    // which case no compatibility processing is required).
    if( (TargetAdapt == NULL) || (TargetAdapt->bCompatibilityMode) )
    {
        BrdgCompProcessOutboundPacket( pPacket, TargetAdapt );
    }

    // If the target adapter is in compatibility-mode, no processing
    // other than the compatibility processing is required.
    if( (TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode) )
    {
        // We're done with this packet!
        BrdgReleaseAdapter( TargetAdapt );
        return NDIS_STATUS_SUCCESS;
    }

    //
    // We can fast-track the packet if there is an NDIS stack slot available
    // for use and there is a single target adapter to send on.
    //
    pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

    if( (TargetAdapt != NULL) && bRemaining && (pStack != NULL) )
    {
        // We fiddle with some of the packet flags when sending a packet. Remember the
        // state of the flags we change so we can restore them before handing back the
        // packet when the send completes.
        *((PUINT)(pStack->IMReserved)) = NdisGetPacketFlags(pPacket) & CHANGED_PACKET_FLAGS;

        // Just fast-track it out the target adapter
        BrdgFwdSendOnLink( TargetAdapt, pPacket );

        // Done with the adapter pointer
        BrdgReleaseAdapter( TargetAdapt );

        // We retain the buffers until we're done
        return NDIS_STATUS_PENDING;
    }

    //
    // Can't fast-track for whatever reason. We need to take the slow path through BrdgFwdHandlePacket
    //
    Status = BrdgFwdHandlePacket( BrdgPacketOutbound, TargetAdapt, NULL /* No source adapter */, FALSE /* Do not indicate */,
                                  NULL /*No miniport handle because no indication*/, NULL, NULL, /*No base packet yet*/
                                  BrdgFwdMakeSendBasePacket, pPacket, NULL, 0, 0 );

    if( TargetAdapt != NULL )
    {
        // We're done with this adapter pointer
        BrdgReleaseAdapter( TargetAdapt );
    }

    return Status;
}

VOID
BrdgFwdCleanupPacket(
    IN  PADAPT              pAdapt,
    IN  PNDIS_PACKET        pPacket,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    NDIS entry point called when a packet transmission has completed

Arguments:

    ProtocolBindingContext  The adapter on which the packet was send
    pPacket                 The transmitted packet
    Status                  The status of the send

Return Value:

    None

--*/
{
    PACKET_OWNERSHIP        Own;

    // Find out whether we own this packet
    Own = BrdgBufGetPacketOwnership(pPacket);

    if( Own == BrdgNotOwned )
    {
        NDIS_HANDLE             MiniportHandle;
        PNDIS_PACKET_STACK      pStack;
        BOOLEAN                 bRemaining;

        // This packet must have been a fast-track send. Return it to
        // its upper-layer owner.

        // Restore the flags that we change on a packet send by retrieving the
        // stored state of these flags that we stashed in IMReserved in
        // BrdgFwdSendPacket.
        pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

        if( (pStack != NULL) && bRemaining )
        {
            NdisClearPacketFlags( pPacket, CHANGED_PACKET_FLAGS );
            NdisSetPacketFlags( pPacket, *((PUINT)(pStack->IMReserved)) );
        }
        else
        {
            // There was stack room on the way down so this shouldn't happen.
            SAFEASSERT( FALSE );
        }

        if( Status == NDIS_STATUS_SUCCESS )
        {
            PVOID               pHeader = BrdgBufGetPacketHeader(pPacket);

            if( pHeader != NULL )
            {
                BrdgFwdCountTransmittedPacket( pAdapt, pHeader, BrdgBufTotalPacketSize(pPacket) );
            }
            // pHeader can only be NULL under heavy system stress
        }
        else
        {
            ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
        }

        // NDIS should prevent the miniport from shutting down while
        // there is still a send pending.
        MiniportHandle = BrdgMiniAcquireMiniport();
        SAFEASSERT( MiniportHandle != NULL );
        NdisMSendComplete( MiniportHandle, pPacket, Status );
        BrdgMiniReleaseMiniport();
    }
    else
    {
        //
        // We allocated this packet ourselves.
        //

        // Recover the info pointer from our reserved area in the packet header
        PPACKET_INFO        ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved),
                            baseppi;
        PNDIS_PACKET        pBasePacket;

        if( ppi->Flags.bIsBasePacket == FALSE )
        {
            // This packet is using buffers from another packet.
            baseppi = ppi->u.pBasePacketInfo;
            SAFEASSERT( baseppi != NULL );
            pBasePacket = baseppi->pOwnerPacket;
            SAFEASSERT( pBasePacket != NULL );
        }
        else
        {
            // This packet tracks its own buffers.
            pBasePacket = pPacket;
            baseppi = ppi;
        }

        // Contribute to the composite status of this packet
        if( Status == NDIS_STATUS_SUCCESS )
        {
            baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_SUCCESS;
        }

        {
            UCHAR               DstAddr[ETH_LENGTH_OF_ADDRESS];
            UINT                PacketSize;
            PVOID               pHeader = BrdgBufGetPacketHeader(pBasePacket);
            NDIS_STATUS         PacketStatus;
            PACKET_DIRECTION    PacketDirection;

            // Pull out some information before we try to free the packet
            if( pHeader != NULL )
            {
                ETH_COPY_NETWORK_ADDRESS( DstAddr, pHeader );
            }
            // pHeader can only == NULL under heavy system stress

            PacketStatus = baseppi->u.BasePacketInfo.CompositeStatus;
            PacketDirection = baseppi->Flags.OriginalDirection;
            BrdgFwdValidatePacketDirection( PacketDirection );
            PacketSize = BrdgBufTotalPacketSize(pBasePacket);

            // Now deref the packet
            if( BrdgFwdDerefBasePacket( pAdapt, pBasePacket, baseppi, PacketStatus ) )
            {
                // The base packet was freed. Now ILLEGAL to reference pHeader, baseppi or pBasepacket

                if( PacketDirection == BrdgPacketOutbound )
                {
                    // This was a local-source packet.
                    if( PacketStatus == NDIS_STATUS_SUCCESS )
                    {
                        if( pHeader != NULL )
                        {
                            BrdgFwdCountTransmittedPacket( pAdapt, DstAddr, PacketSize );
                        }
                    }
                    else
                    {
                        ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
                    }
                }
                else
                {
                    // This was a relayed packet.
                    ExInterlockedAddLargeStatistic( &pAdapt->SentFrames, 1L );
                    ExInterlockedAddLargeStatistic( &pAdapt->SentBytes, PacketSize );
                }
            }
        }

        if( pBasePacket != pPacket )
        {
            // Owned copy packets are always base packets, so this should be a no-copy packet.
            SAFEASSERT( Own == BrdgOwnWrapperPacket );
            BrdgFwdFreeWrapperPacket( pPacket, ppi, pAdapt );
        }
    }
}



VOID
BrdgFwdSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        pPacket,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    NDIS entry point called when a packet transmission has completed

Arguments:

    ProtocolBindingContext  The adapter on which the packet was send
    pPacket                 The transmitted packet
    Status                  The status of the send

Return Value:

    None

--*/
{
    PADAPT                  pAdapt = (PADAPT)ProtocolBindingContext;

    SAFEASSERT( pAdapt != NULL );

    if (pAdapt)
    {
        if( Status != NDIS_STATUS_SUCCESS )
        {
            THROTTLED_DBGPRINT(FWD, ("Packet send failed with %08x\n", Status));
        }
    
        BrdgFwdCleanupPacket(pAdapt, pPacket, Status);

        BrdgDecrementWaitRef(&pAdapt->Refcount);
    }
}


VOID
BrdgFwdReturnIndicatedPacket(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN PNDIS_PACKET     pPacket
    )
/*++

Routine Description:

    NDIS entry point called when a packet indication has completed

Arguments:

    MiniportAdapterContext  Ignored
    pPacket                 The transmitted packet

Return Value:

    None

--*/
{
    PACKET_OWNERSHIP    Own;

    // Find out whether we own this packet
    Own = BrdgBufGetPacketOwnership(pPacket);

    if( Own == BrdgNotOwned )
    {
        // This packet must have been a fast-track receive. Return it to
        // its lower-layer owner.
        BOOLEAN                 bRemaining;
        PNDIS_PACKET_STACK      pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);
        PADAPT                  pOwnerAdapt;

        // If we fast-tracked this packet, it MUST have had room for us to stash our
        // pointer to the owning adapter
        SAFEASSERT( pStack != NULL );
        SAFEASSERT( bRemaining );

        if (pStack)
        {
            // We incremented the owning adapter's refcount when we first received the packet
            pOwnerAdapt = (PADAPT)pStack->IMReserved[0];
            SAFEASSERT( pOwnerAdapt != NULL );

            // Here you go
            NdisReturnPackets( &pPacket, 1 );

            // Release the owning NIC after the packet release
            BrdgReleaseAdapter( pOwnerAdapt );
        }
        else
        {
            // if pStack is NULL, then we just return the packet as we can't determine the owning adapter.

            // Here you go
            NdisReturnPackets( &pPacket, 1 );            
        }
        // Illegal to refer to pPacket now
        pPacket = NULL;
    }
    else
    {
        // Recover our packet info block from our reserved area in the packet header
        PPACKET_INFO        ppi = *((PPACKET_INFO*)pPacket->MiniportReserved);

        // Indications are always made with the base packet
        SAFEASSERT( ppi->Flags.bIsBasePacket );

        // Let go of the base packet
        BrdgFwdDerefBasePacket( LOCAL_MINIPORT, pPacket, ppi, ppi->u.BasePacketInfo.CompositeStatus );
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

BOOLEAN
BrdgFwdServiceQueue(
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Services the inbound packet queue of a particular adapter

    This routine raises IRQL to DISPATCH to service the queue. It will
    service up to MAX_PACKETS_AT_DPC packets at DISPATCH and then
    return, even if the adapter's queue has not been drained.

    The bServiceInProgress flag is cleared if this routine manages to
    drain the adapter's queue. If the queue is non-empty when the
    routine exits, the bServiceInProgress flag is left set.

Arguments:

    pAdapt                  The adapter to service

Return Value:

    TRUE == the adapter's queue was drained FALSE == there are still queued
    packets to be serviced in the adapter's queue.

--*/
{
    PPACKET_Q_INFO          pqi;
    NDIS_HANDLE             MiniportHandle = NULL;
    KIRQL                   oldIrql;
    ULONG                   HandledPackets = 0L;
    BOOLEAN                 bQueueWasEmptied;

    SAFEASSERT( pAdapt != NULL );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    // We should only be scheduled when there's something to deal with
    SAFEASSERT( BrdgQuerySingleListLength(&pAdapt->Queue) > 0 );
    SAFEASSERT( pAdapt->bServiceInProgress );

    // Get a handle on the miniport for the entire function duration
    MiniportHandle = BrdgMiniAcquireMiniportForIndicate();

    //
    // The queue lock protects bServiceInProgress as well. Use it to dequeue
    // packets and update the flag atomically.
    //
    NdisDprAcquireSpinLock( &pAdapt->QueueLock);

    pqi = (PPACKET_Q_INFO)BrdgRemoveHeadSingleList(&pAdapt->Queue);

    while( pqi != NULL )
    {
        PNDIS_PACKET        pPacket;
        PADAPT              TargetAdapt = NULL, OriginalAdapt = NULL;

        //
        // QueueRefcount reflects the number of elements in the processing queue
        // so people can block on it becoming empty
        //
        BrdgDecrementWaitRef( &pAdapt->QueueRefcount );
        SAFEASSERT( (ULONG)pAdapt->QueueRefcount.Refcount == pAdapt->Queue.Length );

        NdisDprReleaseSpinLock( &pAdapt->QueueLock );

        // Demultiplex the union
        if( pqi->Flags.bFastTrackReceive )
        {
            OriginalAdapt = pqi->u.pOriginalAdapt;
        }
        else
        {
            TargetAdapt = pqi->u.pTargetAdapt;
        }

        // Recover the packet pointer from the ProtocolReserved offset
        pPacket = CONTAINING_RECORD(pqi, NDIS_PACKET, ProtocolReserved);

        // Deal with this packet
        if( pqi->pInfo != NULL )
        {
            if( pqi->Flags.bIsSTAPacket )
            {
                if( ! gDisableSTA && BrdgFwdBridgingNetworks() )
                {
                    // Hand this packet off to the STA code
                    BrdgSTAReceivePacket( pAdapt, pPacket );
                }

                // We're done with this packet
                BrdgFwdReleaseBasePacket( pPacket, pqi->pInfo, BrdgBufGetPacketOwnership(pPacket),
                                          NDIS_STATUS_SUCCESS );

                // It is an error to use any of these variables now
                pPacket = NULL;
                pqi = NULL;
            }
            else
            {
                BOOLEAN         bShouldIndicate = pqi->Flags.bShouldIndicate,
                                bIsUnicastToBridge = pqi->Flags.bIsUnicastToBridge,
                                bRequiresCompatWork = pqi->Flags.bRequiresCompatWork,
                                bCompatOnly;
                NDIS_STATUS     Status;
                PPACKET_INFO    ppi = pqi->pInfo;
                BOOLEAN         bRetained = FALSE;

                //
                // This is an already-wrapped packet from the copy path.
                //
                SAFEASSERT( ! pqi->Flags.bFastTrackReceive );

                // Before passing this packet along for processing, we must put a pointer to the packet's
                // info block back into its MiniportReserved and ProtocolReserved areas so completion
                // routines can recover the info block.
                //
                SAFEASSERT( ppi->pOwnerPacket == pPacket );
                *((PPACKET_INFO*)pPacket->ProtocolReserved) = ppi;
                *((PPACKET_INFO*)pPacket->MiniportReserved) = ppi;

                // It is an error to use pqi anymore since it points into the ProtocolReserved area
                pqi = NULL;

                // If this packet arrived on a compatibility adapter or is bound for a
                // compatibility adapter, only compatibility-mode work is required.
                bCompatOnly = (BOOLEAN)((pAdapt->bCompatibilityMode) ||
                              ((TargetAdapt != NULL) && (TargetAdapt->bCompatibilityMode)));

                // Do compatibility work first if required
                if( bRequiresCompatWork )
                {
                    bRetained = BrdgCompProcessInboundPacket( pPacket, pAdapt, bCompatOnly );
                    Status = NDIS_STATUS_SUCCESS;
                }
                else
                {
                    // Packet shouldn't have gotten here if there's nothing to do with it
                    SAFEASSERT( ! bCompatOnly );
                    bRetained = FALSE;
                    Status = NDIS_STATUS_SUCCESS;
                }

                if( ! bCompatOnly )
                {
                    // We told the compatibility module not to retain the packet
                    SAFEASSERT( ! bRetained );

                    if( bIsUnicastToBridge )
                    {
                        SAFEASSERT( TargetAdapt == NULL );
                        bRetained = FALSE;
                        Status = NDIS_STATUS_FAILURE;

                        if( MiniportHandle != NULL )
                        {
                            if( BrdgBufAssignBasePacketQuota(pPacket, LOCAL_MINIPORT) )
                            {
                                // Do fixups usually done in BrdgFwdHandlePacket
                                ppi->u.BasePacketInfo.RefCount = 1L;
                                ppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

                                // Indicate the packet up
                                BrdgFwdIndicatePacket( pPacket, MiniportHandle );
                                bRetained = TRUE;
                            }
                            else
                            {
                                THROTTLED_DBGPRINT(FWD, ("Local miniport over quota on queued receive!\n"));
                            }
                        }
                    }
                    else
                    {
                        if ((NULL == TargetAdapt) && pAdapt->bCompatibilityMode)
                        {
                            TargetAdapt = BrdgCompFindTargetAdapterForIPAddress(pPacket);
                            if (TargetAdapt && !BrdgAcquireAdapter(TargetAdapt))
                            {
                                TargetAdapt = NULL;
                            }                            
                        }

                        // Hand off this packet for general processing
                        Status = BrdgFwdHandlePacket( BrdgPacketInbound, TargetAdapt, pAdapt, bShouldIndicate,
                                                      MiniportHandle, pPacket, ppi, NULL, NULL, NULL, 0, 0 );

                        if( Status == NDIS_STATUS_PENDING )
                        {
                            bRetained = TRUE;
                        }
                        else
                        {
                            // The base packet we previously created was not actually used by BrdgFwdHandlePacket.
                            bRetained = FALSE;
                        }
                    }
                }

                // If our processing did not retain the packet for later release, release it now.
                if( ! bRetained )
                {
                    BrdgFwdReleaseBasePacket( pPacket, ppi, BrdgBufGetPacketOwnership(pPacket), Status );
                }
            }
        }
        else
        {
            // Can't have unwrapped STA packets
            SAFEASSERT( ! pqi->Flags.bIsSTAPacket );

            // Can't have unwrapped packets for compatibility processing
            SAFEASSERT( ! pqi->Flags.bRequiresCompatWork );

            // Packet should not be here (unwrapped) if it arrived from a compatibility-mode
            // adapter.
            SAFEASSERT( ! pAdapt->bCompatibilityMode );

            // BrdgFwdReceivePacket should copy unicast packets that can't be fast-tracked
            // into base packets before queuing them; we shouldn't end up with unwrapped
            // packets that are unicast to the bridge but aren't tagged for fast-tracking.
            if( pqi->Flags.bIsUnicastToBridge )
            {
                SAFEASSERT( pqi->Flags.bFastTrackReceive );
            }

            if( pqi->Flags.bFastTrackReceive )
            {
                BOOLEAN     bRetained = FALSE;

                SAFEASSERT( pqi->Flags.bIsUnicastToBridge );

                if( MiniportHandle != NULL )
                {
                    PUCHAR      DstAddr = BrdgBufGetPacketHeader(pPacket);

                    if( DstAddr != NULL )
                    {
                        // This is unicast to the bridge only; we are asked to try to fast-track it straight up to
                        // overlying protocols.
                        if( BrdgFwdNoCopyFastTrackReceive(pPacket, OriginalAdapt, MiniportHandle, DstAddr, &bRetained ) )
                        {
                            // We had better be able to retain ownership of the original packet because we've already
                            // hung on to it past the return of FwdReceivePacket!
                            SAFEASSERT( bRetained );
                        }
                        else
                        {
                            // BrdgFwdReceivePacket is supposed to make sure packets can be fast-tracked
                            // before queuing them up
                            SAFEASSERT( FALSE );
                        }
                    }
                    // DstAddr can only == NULL under heavy system stress
                }

                if( !bRetained )
                {
                    // Error of some sort or the miniport isn't available for indications. Ditch the packet.
                    NdisReturnPackets( &pPacket, 1 );

                    // Illegal to refer to the packet now
                    pPacket = NULL;
                }
            }
            else
            {
                NDIS_STATUS     Status;

                // Packet should not be here (unwrapped) if it is bound for a compatibility-mode adapter.
                SAFEASSERT( ! TargetAdapt->bCompatibilityMode );

                // This is not a packet unicast to the bridge. Do the more general processing.
                Status = BrdgFwdHandlePacket( BrdgPacketInbound, TargetAdapt, pAdapt, pqi->Flags.bShouldIndicate,
                                              MiniportHandle, NULL, NULL, BrdgFwdMakeNoCopyBasePacket, pPacket, pAdapt, 0, 0 );

                if( Status != NDIS_STATUS_PENDING )
                {
                    // The unwrapped packet from the underlying NIC was not used. Release it now.
                    NdisReturnPackets( &pPacket, 1 );

                    // Illegal to refer to the packet now
                    pPacket = NULL;
                }
            }
        }

        // Release the target adapter if there was one
        if( TargetAdapt )
        {
            BrdgReleaseAdapter( TargetAdapt );
        }

        // Acquire the spin lock before either exiting or grabbing the next packet
        NdisDprAcquireSpinLock( &pAdapt->QueueLock );

        // If we've processed too many packets, bail out even if the queue is not empty
        HandledPackets++;

        if( HandledPackets >= MAX_PACKETS_AT_DPC )
        {
            break;
        }

        // Get the next packet off the queue
        pqi = (PPACKET_Q_INFO)BrdgRemoveHeadSingleList(&pAdapt->Queue);
    }

    //
    // Clear bServiceInProgress only if we emptied the queue. Otherwise, leave it set to
    // prevent spurious signalling of the QueueEvent, which would cause more than one
    // draining thread to service the same queue!
    //
    if( BrdgQuerySingleListLength(&pAdapt->Queue) == 0L )
    {
        bQueueWasEmptied = TRUE;
        pAdapt->bServiceInProgress = FALSE;
    }
    else
    {
        bQueueWasEmptied = FALSE;
    }

    NdisDprReleaseSpinLock( &pAdapt->QueueLock );

    // Let go of the miniport until next time
    if( MiniportHandle != NULL )
    {
        BrdgMiniReleaseMiniportForIndicate();
    }

    KeLowerIrql(oldIrql);

    return bQueueWasEmptied;
}

VOID
BrdgFwdProcessQueuedPackets(
    IN PVOID                Param1
    )
/*++

Routine Description:

    Per-adapter inbound packet queue draining function

    There is one instance of this function running per processor.
    This routine sleeps until there is work to be done, and then calls
    BrdgFwdServiceQueue to service whichever adapter needs attention.
    It does this by blocking against the QueueEvent object for each
    adapter's queue, as well as the global gKillThreads and the
    gThreadsCheckAdapters event for this processor.

    When the block returns, there is an event needing attention; it
    may be the fact that the thread has been signaled to exit, that
    this thread is supposed to re-enumerate adapters, or that an
    adapter needs its inbound queue serviced.

    This routine increments the refcount of every adapter that it
    sleeps against; the gThreadsCheckAdapters event causes the thread
    to re-examine the adapter list and release its refcount on any
    adapters that were removed (or notice new additions).

    Must be called at < DISPATCH_LEVEL since we wait on an event

Arguments:

    Param1              The processor on which we should execute
                        (is not necessarily the processor on which
                        we are first scheduled)

Return Value:

    None

--*/
{
    // Double cast to tell the IA64 compiler we really mean to truncate
    UINT                Processor = (UINT)(ULONG_PTR)Param1;
    PVOID               WaitObjects[MAXIMUM_WAIT_OBJECTS];
    KWAIT_BLOCK         WaitBlocks[MAXIMUM_WAIT_OBJECTS];
    ULONG               numWaitObjects;
    BOOLEAN             bDie = FALSE;
    PVOID               pThread = KeGetCurrentThread();

    // Constants
    const ULONG         KILL_EVENT = 0L, CHECK_EVENT = 1L;

    DBGPRINT(FWD, ("Spinning up a thread on processor %i\n", Processor));

    // Elevate our priority
    KeSetPriorityThread(pThread, LOW_REALTIME_PRIORITY);

    // Attach ourselves to our designated processor
    KeSetAffinityThread(pThread, (KAFFINITY)(1<<Processor));

    // Start off waiting against just the kill event and the re-enumerate event.
    WaitObjects[KILL_EVENT] = &gKillThreads;
    WaitObjects[CHECK_EVENT] = &gThreadsCheckAdapters[Processor];
    numWaitObjects = 2L;

    while( ! bDie )
    {
        NTSTATUS        Status;
        ULONG           firedObject;

        //
        // Block until we are told to exit, re-enumerate, or until a processor's
        // queue signals that it needs servicing.
        //
        SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
        Status = KeWaitForMultipleObjects( numWaitObjects, WaitObjects, WaitAny, Executive,
                                           KernelMode, FALSE, NULL, WaitBlocks );

        if( ! NT_SUCCESS(Status) )
        {
            // This really shouldn't happen
            DBGPRINT(FWD, ("KeWaitForMultipleObjects failed! %08x\n", Status));
            SAFEASSERT(FALSE);

            // Pretend this was a signal to exit
            firedObject = KILL_EVENT;
        }
        else
        {
            firedObject = (ULONG)Status - (ULONG)STATUS_WAIT_0;
        }

        if( firedObject == KILL_EVENT )
        {
            // We are asked to exit.
            DBGPRINT(FWD, ("Exiting queue servicing thread on processor %i\n", Processor));
            bDie = TRUE;
        }
        else if( firedObject == CHECK_EVENT )
        {
            LOCK_STATE      LockState;
            UINT            i;
            PADAPT          pAdapt;

            DBGPRINT(FWD, ("Re-enumerating adapters on processor %i\n", Processor));

            // We must re-enumerate the list of adapters. First decrement the refcount on any
            // adapters we're already holding
            for( i = 2; i < numWaitObjects; i++ )
            {
                pAdapt = CONTAINING_RECORD( WaitObjects[i], ADAPT, QueueEvent );
                BrdgReleaseAdapter( pAdapt );
            }

            numWaitObjects = 2;

            // Now walk the adapter list and retrieve a pointer to each one's queue event.
            NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read only*/, &LockState );

            for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
            {
                // We will be using this adapter outside the list lock
                BrdgAcquireAdapterInLock(pAdapt);
                WaitObjects[numWaitObjects] = &pAdapt->QueueEvent;
                numWaitObjects++;
            }

            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
        }
        else
        {
            // An adapter needs queue servicing.
            PADAPT      pAdapt = CONTAINING_RECORD( WaitObjects[firedObject], ADAPT, QueueEvent );

            if( ! BrdgFwdServiceQueue( pAdapt ) )
            {
                // The adapter's queue was serviced but not emptied. Signal the queue event so
                // someone (maybe us!) will be scheduled to service the queue
                KeSetEvent( &pAdapt->QueueEvent, EVENT_INCREMENT, FALSE );
            }
        }
    }

    // Shoot ourselves in the head
    PsTerminateSystemThread( STATUS_SUCCESS );
}

PNDIS_PACKET
BrdgFwdMakeSendBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    )
/*++

Routine Description:

    Passed as a parameter to BrdgFwdHandlePacket and called back as necessary

    Builds a base packet from a packet outbound from overlying protocols

Arguments:

    pppi                    The info block of the new base packet or NULL if the
                            allocation failed

    Target                  The adapter to "charge" the new base packet to
    Param1                  The outbound packet
    Param2 - Param4         Unused

Return Value:

    The new base packet or NULL if the allocation failed (usually because the
    target adapter didn't pass quota)

--*/
{
    PNDIS_PACKET            pPacket = (PNDIS_PACKET)Param1;
    PNDIS_PACKET            pNewPacket;

    SAFEASSERT( pPacket != NULL );

    // Get a wrapper packet to be the base packet
    pNewPacket = BrdgFwdAllocAndWrapPacketForSend( pPacket, pppi, Target );

    if( pNewPacket == NULL )
    {
        // We didn't pass quota for this target
        return NULL;
    }

    // Stuff a pointer to the packet's info block into both the ProtocolReserved
    // and the MiniportReserved areas so we can recover the info block no matter
    // how we plan to use this packet
    *((PPACKET_INFO*)pNewPacket->ProtocolReserved) = *pppi;
    *((PPACKET_INFO*)pNewPacket->MiniportReserved) = *pppi;

    SAFEASSERT( *pppi != NULL );
    (*pppi)->u.BasePacketInfo.pOriginalPacket = pPacket;
    (*pppi)->u.BasePacketInfo.pOwnerAdapter = NULL;
    (*pppi)->Flags.OriginalDirection = BrdgPacketOutbound;
    (*pppi)->Flags.bIsBasePacket = TRUE;

    // Signal that the underlying NIC can hang on to the buffers
    NDIS_SET_PACKET_STATUS( pNewPacket, NDIS_STATUS_SUCCESS );

    return pNewPacket;
}

PNDIS_PACKET
BrdgFwdMakeNoCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               Target,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    )
/*++

Routine Description:

    Passed as a parameter to BrdgFwdHandlePacket and called back as necessary

    Builds a new base packet from a packet received on the no-copy path

Arguments:

    pppi                    The info block for the new packet or NULL if the alloc
                            failed

    Target                  The adapter to "charge" the new packet to
    Param1                  The originally indicated packet descriptor
    Param2                  The adapter on which the packet was received
    Param3, Param4          Unused

Return Value:

    A new base packet or NULL if the allocation failed (usually because the
    target adapter did not pass quota)

--*/
{
    PNDIS_PACKET            pPacket = (PNDIS_PACKET)Param1;
    PADAPT                  pOwnerAdapt = (PADAPT)Param2;
    PNDIS_PACKET            NewPacket;

    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( pOwnerAdapt != NULL );

    // Get a new wrapper packet
    NewPacket = BrdgFwdAllocAndWrapPacketForReceive( pPacket, pppi, Target );

    if (NewPacket == NULL)
    {
        // We didn't pass quota for this target
        return NULL;
    }

    SAFEASSERT( *pppi != NULL );

    // Stuff a pointer to the packet's info block into both the ProtocolReserved
    // and the MiniportReserved areas so we can recover the info block no matter
    // how we plan to use this packet
    *((PPACKET_INFO*)NewPacket->ProtocolReserved) = *pppi;
    *((PPACKET_INFO*)NewPacket->MiniportReserved) = *pppi;

    //
    // We must ensure that the adapter we just got this packet from is not unbound until we are
    // done with its packet. Bump the adapter's refcount here. The adapter's refcount will be
    // decremented again when this base packet is freed.
    //
    BrdgReacquireAdapter( pOwnerAdapt );
    (*pppi)->u.BasePacketInfo.pOwnerAdapter = pOwnerAdapt;

    (*pppi)->u.BasePacketInfo.pOriginalPacket = pPacket;
    (*pppi)->Flags.OriginalDirection = BrdgPacketInbound;
    (*pppi)->Flags.bIsBasePacket = TRUE;

    // Make sure the packet indicates that it's OK to hang on to buffers
    NDIS_SET_PACKET_STATUS( NewPacket, NDIS_STATUS_SUCCESS );

    // Count this packet as received
    ExInterlockedAddLargeStatistic( &gStatReceivedFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatReceivedBytes, BrdgBufTotalPacketSize(pPacket) );
    ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyFrames, 1L );
    ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyBytes, BrdgBufTotalPacketSize(pPacket) );

    ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedFrames, 1L );
    ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedBytes, BrdgBufTotalPacketSize(pPacket) );

    return NewPacket;
}

PNDIS_PACKET
BrdgFwdMakeCopyBasePacket(
    OUT PPACKET_INFO        *pppi,
    IN PVOID                pHeader,
    IN PVOID                pData,
    IN UINT                 HeaderSize,
    IN UINT                 DataSize,
    IN UINT                 SizeOfPacket,
    IN BOOLEAN              bCountAsReceived,
    IN PADAPT               pOwnerAdapt,
    PVOID                   *ppBuf
    )
/*++

Routine Description:

    Builds a new copy packet to hold inbound data on the copy path or on the
    no-copy path if a packet arrives with STATUS_RESOURCES.

    The new packet has NO ATTRIBUTED QUOTA to any adapter. This is because
    at the time of the initial receive, a target adapter is not yet known
    and the inbound data must be wrapped in a copy packet to be queued for
    processing.

    The cost of the base packet is assigned to target adapters as it is
    processed in the queue-draining thread.

Arguments:

    pppi                    Output of the new info block associated with the
                            new packet (NULL if alloc failed)

    pHeader                 Pointer to the header buffer originally indicated
                            Can be NULL to not copy the header

    pData                   Pointer to the data buffer originally indicated
                            Can be NULL to not copy the data buffer

    HeaderSize              Size of the header buffer
    DataSize                Size of the data buffer

    SizeOfPacket            Size to set the packet's buffer to. Can be different
                            from HeaderSize+DataSize if the caller plans to
                            copy more data in later

    bCountAsReceived        Whether to count this packet as received

    pOwnerAdapt             Adapter this packet was received on (purely for
                            statistics purposes). Can be NULL if bCountAsReceived == FALSE

    ppBuf                   (optionally) receives a pointer to the data buffer
                            of the freshly allocated packet

Return Value:

    A new base packet or NULL if the allocation failed

--*/
{
    PNDIS_PACKET            NewPacket;
    PNDIS_BUFFER            pBuffer;
    PVOID                   pvBuf;
    UINT                    bufLength;

    // Get a copy packet to carry the data
    NewPacket = BrdgBufGetBaseCopyPacket( pppi );

    if (NewPacket == NULL)
    {
        // Our copy packet pool is full!
        return NULL;
    }

    SAFEASSERT( *pppi != NULL );

    // Get a pointer to the preallocated buffer in this packet
    pBuffer = BrdgBufPacketHeadBuffer(NewPacket);
    SAFEASSERT( pBuffer != NULL );
    NdisQueryBufferSafe( pBuffer, &pvBuf, &bufLength, NormalPagePriority );

    if( pvBuf == NULL )
    {
        // This shouldn't be possible because the data buffer should have been
        // alloced from kernel space
        SAFEASSERT(FALSE);
        BrdgBufFreeBaseCopyPacket( NewPacket, *pppi );
        *pppi = NULL;
        return NULL;
    }

    SAFEASSERT( bufLength == MAX_PACKET_SIZE );

    if( ppBuf != NULL )
    {
        *ppBuf = pvBuf;
    }

    // Copy the packet data into our own preallocated buffers
    if( pHeader != NULL )
    {
        NdisMoveMemory(pvBuf, pHeader, HeaderSize);
    }
    else
    {
        SAFEASSERT( HeaderSize == 0 );
    }

    if( pData != NULL )
    {
        NdisMoveMemory((PUCHAR)pvBuf + HeaderSize, pData, DataSize);
    }
    else
    {
        SAFEASSERT( DataSize == 0 );
    }

    // Tweak the size of the buffer so it looks like the right length
    NdisAdjustBufferLength(pBuffer, SizeOfPacket);

    (*pppi)->u.BasePacketInfo.pOriginalPacket = NULL;
    (*pppi)->u.BasePacketInfo.pOwnerAdapter = NULL;
    (*pppi)->Flags.OriginalDirection = BrdgPacketInbound;
    (*pppi)->Flags.bIsBasePacket = TRUE;

    // Make the header size correct
    NDIS_SET_PACKET_HEADER_SIZE(NewPacket, ETHERNET_HEADER_SIZE);

    // Indicate that upper-layer protocols can hang on to these buffers
    NDIS_SET_PACKET_STATUS( NewPacket, NDIS_STATUS_SUCCESS );

    // Count this packet as received
    if( bCountAsReceived )
    {
        ExInterlockedAddLargeStatistic( &gStatReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedBytes, SizeOfPacket );
        ExInterlockedAddLargeStatistic( &gStatReceivedCopyFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedCopyBytes, SizeOfPacket );

        SAFEASSERT( pOwnerAdapt != NULL );
        ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &pOwnerAdapt->ReceivedBytes, SizeOfPacket );
    }

    return NewPacket;
}

VOID
BrdgFwdSendOnLink(
    IN  PADAPT          pAdapt,
    IN  PNDIS_PACKET    pPacket
    )
/*++

Routine Description:

    Sends a packet to a particular adapter

Arguments:

    pAdapt              The adapter to send to
    pPacket             The packet to send

Return Value:

    None

--*/
{
    PPACKET_INFO ppi;
    PACKET_DIRECTION PacketDirection = BrdgPacketImpossible;
    BOOLEAN Bridging = BrdgFwdBridgingNetworks();
    BOOLEAN Incremented = FALSE;

    // Make sure this doesn't loop back
    NdisClearPacketFlags( pPacket, NDIS_FLAGS_LOOPBACK_ONLY );
    NdisSetPacketFlags( pPacket, NDIS_FLAGS_DONT_LOOPBACK );
    
    //
    // Logic is like this:
    // If the packet is an Outbound packet then we send it.
    // If the packet has been created in the bridge, then we check
    // the base packet to see if it is outbound, if it is then we send the packet.
    //

    if (!Bridging)
    {
        if (BrdgBufGetPacketOwnership(pPacket) != BrdgNotOwned)
        {
            ppi = *((PPACKET_INFO*)pPacket->MiniportReserved);
            if (!ppi)
            {
                ppi = *((PPACKET_INFO*)pPacket->ProtocolReserved);
            }

            if (ppi)
            {
                if (((ppi->Flags.OriginalDirection == BrdgPacketOutbound) || 
                    ((ppi->Flags.OriginalDirection == BrdgPacketCreatedInBridge) && 
                     (ppi->u.pBasePacketInfo != NULL && 
                      ppi->u.pBasePacketInfo->Flags.OriginalDirection == BrdgPacketOutbound)
                    )
                    )
                   )
                {
                    PacketDirection = BrdgPacketOutbound;
                }
            }
            else
            {
                // If it doesn't contain a ppi then it never came through the bridge, so it's being transmitted locally.
                PacketDirection = BrdgPacketOutbound;
    #if DBG
                if (gBreakIfNullPPI)
                {
                    KdBreakPoint();
                }
    #endif // DBG
            }
        }
        else
        {
            PacketDirection = BrdgPacketOutbound;
        }
    }
    
    Incremented = BrdgIncrementWaitRef(&pAdapt->Refcount);

    if (Incremented && 
        (PacketDirection == BrdgPacketOutbound || Bridging))
    {

#if DBG
        if (gPrintPacketTypes)
        {
            if (PacketDirection == BrdgPacketOutbound)
            {
                THROTTLED_DBGPRINT(FWD, ("Sending Outbound packet\r\n"));
            }
            else
            {
                THROTTLED_DBGPRINT(FWD, ("Forwarding packet\r\n"));
            }
        }
#endif // DBG

        // Send!
        NdisSendPackets( pAdapt->BindingHandle, &pPacket, 1 );
    }
    else
    {

#if DBG
        if (Bridging && gPrintPacketTypes)
        {
            THROTTLED_DBGPRINT(FWD, ("Not allowed to send packet\r\n"));
        }
#endif // DBG
        
        //
        // We incremented this, but we're not going to be going through any path that
        // decrements this, so we need to do this here.
        //
        if (Incremented)
        {
            BrdgDecrementWaitRef(&pAdapt->Refcount);
        }

        BrdgFwdCleanupPacket(pAdapt, pPacket, NDIS_STATUS_CLOSING);
    }
}

VOID
BrdgFwdReleaseBasePacket(
    IN PNDIS_PACKET         pPacket,
    PPACKET_INFO            ppi,
    IN PACKET_OWNERSHIP     Own,
    IN NDIS_STATUS          Status
    )
/*++

Routine Description:

    Frees a base packet. Called when a base packet's refcount reaches zero.

Arguments:

    pPacket                 The base packet to free
    ppi                     The packet's info block
    Own                     The result of a call to BrdgBufGetPacketOwnership(pPacket)

    Status                  The status to be returned to the entity owning the
                            original packet wrapped by the base packet (if any)

Return Value:

    None

--*/
{
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    if( Own == BrdgOwnCopyPacket )
    {
        // This packet was allocated to wrap copied buffers. Free it back to our pool.
        BrdgFwdValidatePacketDirection( ppi->Flags.OriginalDirection );
        BrdgBufFreeBaseCopyPacket( pPacket, ppi );
    }
    else
    {
        // This packet was allocated to wrap a protocol or miniport's buffers.
        // Return the packet to its original owner.
        SAFEASSERT( Own == BrdgOwnWrapperPacket );
        SAFEASSERT( ppi->u.BasePacketInfo.pOriginalPacket != NULL );

        if( ppi->Flags.OriginalDirection == BrdgPacketInbound )
        {
            // Wraps a lower-layer miniport packet.
            NdisReturnPackets( &ppi->u.BasePacketInfo.pOriginalPacket, 1 );

            // We incremented the adapter's refcount when we first received the packet
            // to prevent the adapter from shutting down while we still held some of
            // its packets
            SAFEASSERT( ppi->u.BasePacketInfo.pOwnerAdapter != NULL );
            BrdgReleaseAdapter( ppi->u.BasePacketInfo.pOwnerAdapter );
        }
        else
        {
            NDIS_HANDLE         MiniportHandle;

            // Wraps a higher-layer protocol packet
            SAFEASSERT( ppi->Flags.OriginalDirection == BrdgPacketOutbound );

            // Shuttle back per-packet information before returning the original descriptor
            NdisIMCopySendCompletePerPacketInfo (ppi->u.BasePacketInfo.pOriginalPacket, pPacket);

            // Give back the original descriptor.
            // NDIS should prevent the miniport from shutting down while there is still an
            // indicate pending.
            MiniportHandle = BrdgMiniAcquireMiniport();
            SAFEASSERT( MiniportHandle != NULL );
            if (MiniportHandle)
            {
                NdisMSendComplete( MiniportHandle, ppi->u.BasePacketInfo.pOriginalPacket, Status );
                BrdgMiniReleaseMiniport();
            }
        }

        // Don't forget to free the wrapper packet as well
        BrdgFwdFreeBaseWrapperPacket( pPacket, ppi );
    }
}

VOID
BrdgFwdWrapPacketForReceive(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    )
/*++

Routine Description:

    Copies state information into a wrapper packet for the purposes of indicating
    the new packet up to overlying protocols

Arguments:

    pOriginalPacket         The packet to copy state out of
    pNewPacket              The wrapper packet to copy state into

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;

    // Copy other header and OOB data
    NDIS_SET_ORIGINAL_PACKET(pNewPacket, NDIS_GET_ORIGINAL_PACKET(pOriginalPacket));
    NdisSetPacketFlags( pNewPacket, NdisGetPacketFlags(pOriginalPacket) );
    Status = NDIS_GET_PACKET_STATUS(pOriginalPacket);
    NDIS_SET_PACKET_STATUS(pNewPacket, Status);
    NDIS_SET_PACKET_HEADER_SIZE(pNewPacket, NDIS_GET_PACKET_HEADER_SIZE(pOriginalPacket));
}

VOID
BrdgFwdWrapPacketForSend(
    IN PNDIS_PACKET         pOriginalPacket,
    IN PNDIS_PACKET         pNewPacket
    )
/*++

Routine Description:

    Copies state information into a wrapper packet for the purposes of transmitting the
    new packet to underlying NICs

Arguments:

    pOriginalPacket         The packet to copy state out of
    pNewPacket              The wrapper packet to copy state into

Return Value:

    None

--*/
{
    PVOID                   MediaSpecificInfo = NULL;
    ULONG                   MediaSpecificInfoSize = 0;

    NdisSetPacketFlags( pNewPacket, NdisGetPacketFlags(pOriginalPacket) );

    //
    // Copy the OOB Offset from the original packet to the new
    // packet.
    //
    NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(pNewPacket),
                   NDIS_OOB_DATA_FROM_PACKET(pOriginalPacket),
                   sizeof(NDIS_PACKET_OOB_DATA));

    //
    // Copy the per packet info into the new packet
    // This includes ClassificationHandle, etc.
    // Make sure other stuff is not copied !!!
    //
    NdisIMCopySendPerPacketInfo(pNewPacket, pOriginalPacket);

    //
    // Copy the Media specific information
    //
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(pOriginalPacket,
                                        &MediaSpecificInfo,
                                        &MediaSpecificInfoSize);

    if (MediaSpecificInfo || MediaSpecificInfoSize)
    {
        NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(pNewPacket,
                                            MediaSpecificInfo,
                                            MediaSpecificInfoSize);
    }
}

PNDIS_PACKET
BrdgFwdCommonAllocAndWrapPacket(
    IN PNDIS_PACKET         pBasePacket,
    OUT PPACKET_INFO        *pppi,
    IN PADAPT               pTargetAdapt,
    IN PWRAPPER_FUNC        pFunc
    )
/*++

Routine Description:

    Common logic for creating a wrapper packet

    Creates a new wrapper packet and calls the supplied function to copy
    state information from the original packet into the wrapper

Arguments:

    pBasePacket             The packet to wrap
    pppi                    Returns the new wrapper packet's info block or
                            NULL if the allocation fails

    pTargetAdapt            The adapter to charge the new wrapper packet (and
                            the cost of hanging onto the base packet) to

    pFunc                   The function to call to copy state from the original
                            packet to the new wrapper

Return Value:

    The newly allocated wrapper packet or NULL if the allocation failed (usually
    because the target adapter did not pass quota)

--*/
{
    PNDIS_PACKET            pNewPacket;
    NDIS_STATUS             Status;

    SAFEASSERT( pTargetAdapt != NULL );

    // Must first determine if the target can handle the quota of
    // holding onto the base packet.
    //
    // If we do not own the base packet, this has no effect.
    if( ! BrdgBufAssignBasePacketQuota(pBasePacket, pTargetAdapt) )
    {
        *pppi = NULL;
        return NULL;
    }

    // Try to get a wrapper packet
    pNewPacket = BrdgBufGetWrapperPacket( pppi, pTargetAdapt );

    if( pNewPacket == NULL )
    {
        SAFEASSERT( *pppi == NULL );

        // Reverse the previous accounting for holding onto the base packet
        BrdgBufReleaseBasePacketQuota( pBasePacket, pTargetAdapt );
        return NULL;
    }

    SAFEASSERT( *pppi != NULL );

    // Point the new packet to the old buffers
    Status = BrdgBufChainCopyBuffers( pNewPacket, pBasePacket );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgBufReleaseBasePacketQuota( pBasePacket, pTargetAdapt );
        BrdgBufFreeWrapperPacket( pNewPacket, *pppi, pTargetAdapt );
        *pppi = NULL;
        return NULL;
    }

    // Stuff a pointer to the packet's info block into both the ProtocolReserved
    // and the MiniportReserved areas so we can recover the info block no matter
    // how we plan to use this packet
    *((PPACKET_INFO*)pNewPacket->ProtocolReserved) = *pppi;
    *((PPACKET_INFO*)pNewPacket->MiniportReserved) = *pppi;

    // Copy whatever state needs to be copied for the direction this packet is heading
    (*pFunc)(pBasePacket, pNewPacket);

    return pNewPacket;
}

//
// Paranoid checking of base packets
//
#if DBG
_inline VOID
BrdgFwdCheckBasePacket(
    IN PNDIS_PACKET         pPacket,
    IN PPACKET_INFO         ppi
    )
{
    SAFEASSERT( ppi != NULL );

    // Packets should come prepared so the PACKET_INFO structure is recoverable from
    // both the MiniportReserved and ProtocolReserved areas, so it won't matter whether
    // we use the packet for a send or an indicate.
    SAFEASSERT( *((PPACKET_INFO*)pPacket->ProtocolReserved) == ppi );
    SAFEASSERT( *((PPACKET_INFO*)pPacket->MiniportReserved) == ppi );

    // The base packet refcounts its own buffers
    SAFEASSERT( ppi->Flags.bIsBasePacket );

    // The base packet must allow the upper-layer protocol to hang onto its buffers
    SAFEASSERT( NDIS_GET_PACKET_STATUS( pPacket ) == NDIS_STATUS_SUCCESS );
}
#else
#define BrdgFwdCheckBasePacket(A,B) {}
#endif


NDIS_STATUS
BrdgFwdHandlePacket(
    IN PACKET_DIRECTION     PacketDirection,
    IN PADAPT               pTargetAdapt,
    IN PADAPT               pOriginalAdapt,
    IN BOOLEAN              bShouldIndicate,
    IN NDIS_HANDLE          MiniportHandle,
    IN PNDIS_PACKET         pBasePacket,
    IN PPACKET_INFO         baseppi,
    IN PPACKET_BUILD_FUNC   pFunc,
    IN PVOID                Param1,
    IN PVOID                Param2,
    IN UINT                 Param3,
    IN UINT                 Param4
    )
/*++

Routine Description:

    Common logic for handling packets that cannot be fast-tracked

    A base packet can optionally be passed in. This is only done when handling
    packets from the copy path or the no-copy path when packets arrived with
    STATUS_RESOURCES set, since those types of packets must be wrapped just to
    be queued for processing.

    If a base packet is passed in, it is assumed that NO QUOTA has been assigned
    to any adapter for that base packet. The cost of the base packet is assigned
    to any prospective target via BrdgBufAssignBasePacketQuota().

    If a base packet is not passed in, a function pointer must be supplied that
    can build a base packet on demand from the supplied parameters. When base
    packets are built on the fly, they DO require immediate quota assignments.

    Note that if a base packet is passed in, it is possible for this function to
    release the base packet itself (via BrdgFwdReleaseBasePacket) and return
    NDIS_STATUS_PENDING.

Arguments:

    PacketDirection         The original direction of the packet being handled

    pTargetAdapt            The adapter corresponding to the packet's target
                            MAC address, or NULL if not known. A non-NULL value
                            implies that bShouldIndicate == FALSE, since it doesn't
                            make sense for a unicast packet bound for another
                            adapter to require indication to the local machine.

    pOriginalAdapt          The adapter on which the original packet was received

    bShouldIndicate         Whether the packet should be indicated to overlying protocols

    MiniportHandle          The handle to our local miniport (CALLER IS RESPONSIBLE
                            FOR ENSURING THE MINIPORT'S EXISTENCE DURING THIS CALL!)

    pBasePacket             The base packet to use if one has already been built (this
                            occurs on the copy-receive path)

    baseppi                 The base packet's PACKET_INFO if one exists.

    pFunc                   A function that, when passed Param1 - Param4, can build
                            a base packet from the originally received packet for
                            a particular target adapter.

    Param1 - Param4         Parameters to pass to pFunc

    If a base packet is not supplied, pFunc must be non-NULL. Conversely, if a base
    packet is supplied, pFunc should be NULL because it will never be called.

Return Value:

    NDIS_STATUS_PENDING     Indicates that the base packet passed in was used successfully
                            or that a base packet was successfully built and used with
                            the help of pFunc. The base packet and any wrapper packets
                            build by BrdgFwdHandlePacket will be automatically deallocated
                            in the future; the caller need not take any additional action.

    OTHER RETURN CODE       No targets were found or none passed quota check. If a base
                            packet was passed in, the caller should free it. If there is
                            an underlying packet that was to be used to build a base packet,
                            the caller should free it.

--*/
{
    BOOLEAN                 dataRetained = FALSE;
    PACKET_DIRECTION        tmpPacketDirection;

    tmpPacketDirection = PacketDirection;

    SAFEASSERT( (PacketDirection == BrdgPacketInbound) ||
                (PacketDirection == BrdgPacketOutbound) );

    SAFEASSERT( (pBasePacket != NULL) || (pFunc != NULL) );

    SAFEASSERT( (pTargetAdapt == NULL) || (bShouldIndicate == FALSE) );

    if( pBasePacket != NULL )
    {
        SAFEASSERT( baseppi != NULL );
        BrdgFwdCheckBasePacket( pBasePacket, baseppi );
    }

    if( bShouldIndicate )
    {
        // Don't try to indicate if the miniport doesn't exist
        if( MiniportHandle == NULL )
        {
            // Count this as a failed indicate
            ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
            bShouldIndicate = FALSE;
        }
    }

    // Not allowed to pass in a target adapter in compatibility-mode, since
    // only the compatibility-mode code is supposed to deal with those.
    if( pTargetAdapt != NULL )
    {
        SAFEASSERT( !pTargetAdapt->bCompatibilityMode );
    }

    if( (pTargetAdapt != NULL) && (! bShouldIndicate) )
    {
        // This packet is going to a single destination.
        if( pBasePacket != NULL )
        {
            // We were passed in a base packet. See if the target adapter can accept
            // the quota of the base packet.
            if( ! BrdgBufAssignBasePacketQuota(pBasePacket, pTargetAdapt) )
            {
                // The target is over quota and can't accept this packet. We will
                // return an error code to indicate that we never used the caller's base
                // packet.
                pBasePacket = NULL;
                baseppi = NULL;
            }
            // else we continue processing below
        }
        else
        {
            // Alloc a base packet with the supplied function
            SAFEASSERT( pFunc != NULL );
            pBasePacket = (*pFunc)(&baseppi, pTargetAdapt, Param1, Param2, Param3, Param4);
        }

        if( pBasePacket != NULL )
        {
            // Paranoia
            BrdgFwdCheckBasePacket( pBasePacket, baseppi );
            baseppi->u.BasePacketInfo.RefCount = 1L;
            baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;
            BrdgFwdSendOnLink( pTargetAdapt, pBasePacket );

            // We're using the base packet or the underlying packet used to build the
            // base packet
            dataRetained = TRUE;
        }
        else
        {
            THROTTLED_DBGPRINT(FWD, ("Over quota for single target adapter\n"));

            if( PacketDirection == BrdgPacketOutbound )
            {
                // This was a failed local-source transmit
                ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
            }
        }
    }
    else
    {
        //
        // Our packet isn't bound for a single destination. Do the slow processing.
        //
        UINT                numTargets = 0L, actualTargets, i;
        PADAPT              pAdapt;
        PADAPT              SendList[MAX_ADAPTERS];
        LOCK_STATE          LockState;
        BOOLEAN             sentBase = FALSE;   // Whether we have sent the base packet yet

        //
        // First we need a list of the adapters we intend to send this packet to
        //

        NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

        // Always indicate with the base packet
        if( bShouldIndicate )
        {
            SendList[0] = LOCAL_MINIPORT;
            numTargets = 1L;
        }

        if( pTargetAdapt != NULL )
        {
            BrdgReacquireAdapter( pTargetAdapt );
            SendList[numTargets] = pTargetAdapt;
            numTargets++;
        }
        else
        {
            // Note each adapter to send to
            for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
            {
                // Don't need to acquire the global adapter characteristics lock to read the
                // media state because we don't care about the global consistency of the
                // adapters' characteristics here
                if( (pAdapt != pOriginalAdapt) &&
                    (pAdapt->MediaState == NdisMediaStateConnected) &&  // Don't send to disconnected adapters
                    (pAdapt->State == Forwarding) &&                    // Adapter must be in relaying state
                    (! pAdapt->bResetting) &&                           // Adapter must not be resetting
                    (! pAdapt->bCompatibilityMode) )                    // Adapter can't be in compat-mode
                {
                    if( numTargets < MAX_ADAPTERS )
                    {
                        // We will use this adapter outside the list lock; bump its refcount
                        BrdgAcquireAdapterInLock(pAdapt);
                        SendList[numTargets] = pAdapt;
                        numTargets++;
                    }
                    else
                    {
                        // Too many copies to send!
                        SAFEASSERT( FALSE );
                    }
                }
            }
        }

        // Can let go of the adapter list now; we have copied out all the target adapters
        // and incremented the refcount for the adapters we will be using.
        NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

        if( numTargets == 0 )
        {
            //
            // Nowhere to send the packet! Nothing to do.
            //
            // This should not happen often. If the packet is a local send, our media status
            // should be DISCONNECTED, so there should be no transmits from above.
            //

            if( PacketDirection == BrdgPacketOutbound )
            {
                // This was a failed local-source transmit (although the caller probably
                // shouldn't have sent the packet in the first place since our media status
                // should be DISCONNECTED
                ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
            }

            //
            // Indicate to the caller that no send occurred
            //
            return NDIS_STATUS_NO_CABLE;
        }

        actualTargets = numTargets;

        // If we had a base packet passed in, set its refcount now that we know how many
        // adapters we will be targeting
        if( pBasePacket != NULL )
        {
            baseppi->u.BasePacketInfo.RefCount = actualTargets;
            baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

            // We now need ownership of the base packet passed in; even if all our send
            // attempts fail, we will release the base packet ourselves below, so the
            // caller should not dispose of the base packet himself.
            dataRetained = TRUE;
        }

        //
        // Walk the list of targets and try to send to each
        //
        for( i = 0L; i < numTargets; i++ )
        {
            PADAPT              OutAdapt = SendList[i];
            PNDIS_PACKET        pPacketToSend = NULL;
            PPACKET_INFO        ppiToSend = NULL;

            SAFEASSERT(tmpPacketDirection == PacketDirection);

            if( pBasePacket == NULL )
            {
                //
                // We weren't passed in a base packet and we haven't built one yet. Build one now
                // that we have a specific target adapter.
                //
                pBasePacket = (*pFunc)(&baseppi, OutAdapt, Param1, Param2, Param3, Param4);

                if( pBasePacket != NULL )
                {
                    // Paranoia
                    BrdgFwdCheckBasePacket( pBasePacket, baseppi );
                    SAFEASSERT( actualTargets > 0L );
                    baseppi->u.BasePacketInfo.RefCount = actualTargets;
                    baseppi->u.BasePacketInfo.CompositeStatus = NDIS_STATUS_FAILURE;

                    pPacketToSend = pBasePacket;
                    ppiToSend = baseppi;
                    sentBase = TRUE;
                }
                else
                {
                    // We failed to build a base packet. Just pretend there was one less target
                    // for the next time through
                    actualTargets--;
                }
            }
            else
            {
                if( ! sentBase )
                {
                    //
                    // We have a base packet but we haven't sent it yet. Send to this target if quota allows.
                    //
                    if( BrdgBufAssignBasePacketQuota(pBasePacket, OutAdapt) )
                    {
                        // This target can accept the base packet.
                        pPacketToSend = pBasePacket;
                        ppiToSend = baseppi;
                        sentBase = TRUE;
                    }
                    else
                    {
                        // The target is over quota and can't accept this packet.
                        pPacketToSend = NULL;
                        ppiToSend = NULL;

                        // bookkeeping on the base packet done below
                    }
                }
                else
                {
                    //
                    // We have a base packet and we have already sent it. Use wrapper packets for each additional
                    // send.
                    //
                    if( baseppi->Flags.OriginalDirection == BrdgPacketInbound )
                    {
                        pPacketToSend = BrdgFwdAllocAndWrapPacketForReceive( pBasePacket, &ppiToSend, OutAdapt );
                    }
                    else
                    {
                        SAFEASSERT( baseppi->Flags.OriginalDirection == BrdgPacketOutbound );
                        pPacketToSend = BrdgFwdAllocAndWrapPacketForSend( pBasePacket, &ppiToSend, OutAdapt );
                    }

                    if( pPacketToSend != NULL )
                    {
                        // Signal that the upper-layer protocol can hang on to these buffers
                        NDIS_SET_PACKET_STATUS(pPacketToSend, NDIS_STATUS_SUCCESS);

                        // Set up the wrapper's info block
                        SAFEASSERT( ppiToSend != NULL );
                        ppiToSend->Flags.OriginalDirection = BrdgPacketCreatedInBridge;
                        ppiToSend->Flags.bIsBasePacket = FALSE;
                        ppiToSend->u.pBasePacketInfo = baseppi;
                    }
                    // else bookkeeping done below
                }
            }

            if( pPacketToSend == NULL )
            {
                // Record the failed attempt as appropriate
                SAFEASSERT( ppiToSend == NULL );

                if( OutAdapt == LOCAL_MINIPORT )
                {
                    THROTTLED_DBGPRINT(FWD, ("Over quota for local miniport during processing\n"));
                    ExInterlockedAddLargeStatistic( &gStatIndicatedDroppedFrames, 1L );
                }
                else
                {
                    THROTTLED_DBGPRINT(FWD, ("Over quota for adapter during processing\n"));
                }

                if( pBasePacket != NULL )
                {
                    // We failed to send or wrap the base packet to this target. Do bookkeeping.
                    SAFEASSERT( baseppi != NULL );

                    if( BrdgFwdDerefBasePacket( NULL/*The cost of the base packet never got assigned to OutAdapt*/,
                                                pBasePacket, baseppi, NDIS_STATUS_FAILURE ) )
                    {
                        // We should have been the last target in the list to cause the base packet
                        // to actually be freed.
                        SAFEASSERT( i == numTargets - 1 );
                        pBasePacket = NULL;
                        baseppi = NULL;

                        // We just disposed of the caller's base packet, so we should not cause him to
                        // try to do that again on return
                        SAFEASSERT( dataRetained );
                    }
                }
            }
            else
            {
                // We have a packet to send.
                SAFEASSERT( ppiToSend != NULL );

                if( OutAdapt == LOCAL_MINIPORT )
                {
                    // We are indicating this packet
                    SAFEASSERT( MiniportHandle != NULL );
                    BrdgFwdIndicatePacket( pPacketToSend, MiniportHandle );
                }
                else
                {
                    // We are sending to an adapter, not the local miniport
                    BrdgFwdSendOnLink( OutAdapt, pPacketToSend );
                }

                // We definitely need ownership of the underlying data since we just handed it off
                // to a target
                dataRetained = TRUE;
            }

            if( OutAdapt != LOCAL_MINIPORT )
            {
                // We're done with this adapter now
                BrdgReleaseAdapter( OutAdapt );
            }
        }

        if( ! dataRetained )
        {
            // If we're not claiming ownership of the underlying data, we had better not have
            // actually used it
            SAFEASSERT( ! sentBase );

            if( PacketDirection == BrdgPacketOutbound )
            {
                // This was a failed local-source transmit
                ExInterlockedAddLargeStatistic( &gStatTransmittedErrorFrames, 1L );
            }
        }
        else
        {
            // If we are claiming owernship of the underlying data, we must have used it or
            // disposed of the base packet ourselves.
            SAFEASSERT( sentBase || (pBasePacket == NULL) );
        }
    }

    // Tell the caller whether we are hanging into his data or not
    return dataRetained ? NDIS_STATUS_PENDING : NDIS_STATUS_FAILURE;
}

BOOLEAN
BrdgFwdNoCopyFastTrackReceive(
    IN PNDIS_PACKET         pPacket,
    IN PADAPT               pAdapt,
    IN NDIS_HANDLE          MiniportHandle,
    IN PUCHAR               DstAddr,
    OUT BOOLEAN             *bRetainPacket
    )
/*++

Routine Description:

    Called to indicate a packet descriptor from an underlying NIC straight up to
    overlying protocols without wrapping.

Arguments:

    pPacket                 The packet to indicate
    pAdapt                  The adapter that owns this packet descriptor
    MiniportHandle          The miniport handle (must be != NULL)
    DstAddr                 The target MAC address of the packet

    bRetainPacket           Whether the caller should retain ownership of the
                            given packet descriptor or not. TRUE if the original
                            packet's status was not STATUS_RESOURCES, FALSE otherwise.
                            Undefined if return value != TRUE

Return Value:

    TRUE if the indication succeeded, FALSE otherwise.

--*/
{
    BOOLEAN                 bRemaining;
    NDIS_STATUS             Status;
    PNDIS_PACKET_STACK      pStack;

    SAFEASSERT( pPacket != NULL );
    SAFEASSERT( pAdapt != NULL );
    SAFEASSERT( MiniportHandle != NULL );
    SAFEASSERT( bRetainPacket != NULL );

    *bRetainPacket = FALSE;

    // The fast-track is possible only if NDIS has room left in its packet stack
    pStack = NdisIMGetCurrentPacketStack(pPacket, &bRemaining);

    if ( bRemaining )
    {
        Status = NDIS_GET_PACKET_STATUS(pPacket);

        if( Status != NDIS_STATUS_RESOURCES )
        {
            SAFEASSERT( (Status == NDIS_STATUS_SUCCESS) || (Status == NDIS_STATUS_PENDING) );

            //
            // The upper-layer protocol gets to hang on to this packet until it's done.
            // We must ensure that this adapter is not allowed to shut down while we are
            // still holding its packet. As a special case for fast-track receives, we
            // stash a pointer to the adapter's PADAPT struct in the magic NDIS stack
            // area reserved for intermediate drivers. This allows us to decrement the
            // adapter's refcount when the indication completes.
            //
            BrdgReacquireAdapter( pAdapt );
            pStack->IMReserved[0] = (ULONG_PTR)pAdapt;

            // Tell the caller to retain ownership of the packet
            *bRetainPacket = TRUE;
        }
        else
        {
            // Paranoia: zero out the area we use to stash the PADAPT pointer in case
            // we get confused about the path this packet took
            pStack->IMReserved[0] = 0L;

            // Tell the owner not to retain ownership of the packet
            *bRetainPacket = FALSE;
        }

        // Count the packet as received
        ExInterlockedAddLargeStatistic( &gStatReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedBytes, BrdgBufTotalPacketSize(pPacket) );
        ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyFrames, 1L );
        ExInterlockedAddLargeStatistic( &gStatReceivedNoCopyBytes, BrdgBufTotalPacketSize(pPacket) );
        ExInterlockedAddLargeStatistic( &pAdapt->ReceivedFrames, 1L );
        ExInterlockedAddLargeStatistic( &pAdapt->ReceivedBytes, BrdgBufTotalPacketSize(pPacket) );

        // Hand up to overlying protocols
        BrdgFwdIndicatePacket( pPacket, MiniportHandle );

        // Fast-track succeeded.
        return TRUE;
    }

    // Can't fast-track.
    return FALSE;
}

//
// Changes Bridging Status due to a GPO change
//

VOID
BrdgFwdChangeBridging(
    IN BOOLEAN Bridging
                      )
{
    //
    // Since we don't want to empty our tables if the settings are the same, we check
    // this before updating anything.  If nothing has changed, we just return
    //
    if (gBridging != Bridging)
    {
        gBridging = Bridging;
        // Remove all MAC addresses from tables
        BrdgTblScrubAllAdapters();
        // Remove all IP addresses from tables
        BrdgCompScrubAllAdapters();
        if (!Bridging)
        {
            DBGPRINT(FWD, ("Bridging is now OFF.\r\n"));
            if (gHaveID)
            {
                BrdgSTACancelTimersGPO();
            }
        }
        else
        {
            DBGPRINT(FWD, ("Bridging is now ON.\r\n"));
            if (gHaveID)
            {
                BrdgSTARestartTimersGPO();
                BrdgSTAResetSTAInfoGPO();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgctl.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgctl.h

Abstract:

    Ethernet MAC level bridge.
    IOCTL processing code header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Apr  2000 - Original version

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgCtlDriverInit();

VOID
BrdgCtlCleanup();

VOID
BrdgCtlHandleCreate();

VOID
BrdgCtlHandleCleanup();

NTSTATUS
BrdgCtlHandleIoDeviceControl(
    IN PIRP                         Irp,
    IN PFILE_OBJECT                 FileObject,
    IN OUT PVOID                    Buffer,
    IN ULONG                        InputBufferLength,
    IN ULONG                        OutputBufferLength,
    IN ULONG                        IoControlCode,
    OUT PULONG                      Information
    );

VOID
BrdgCtlNotifyAdapterChange(
    IN PADAPT                       pAdapt,
    IN BRIDGE_NOTIFICATION_TYPE     Type
    );

VOID
BrdgCtlNotifySTAPacket(
    IN PADAPT                       pAdapt,
    IN PNDIS_PACKET                 pPacket
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdghash.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdghash.h

Abstract:

    Ethernet MAC level bridge.
    Hash table implementation header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    October  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

#define MAX_SUPPORTED_KEYSIZE           8               // Key can be up to 8 bytes

//
// Structure of a table entry
//
typedef struct _HASH_TABLE_ENTRY
{

    struct _HASH_TABLE_ENTRY           *Next;
    ULONG                               LastSeen;       // Result of NdisGetSystemUpTime()
    UCHAR                               key[MAX_SUPPORTED_KEYSIZE];

    // User's data follows

} HASH_TABLE_ENTRY, *PHASH_TABLE_ENTRY;


// The prototype of a hash function
typedef ULONG (*PHASH_FUNCTION)(PUCHAR pKey);

// The prototype of a matching function
typedef BOOLEAN (*PHASH_MATCH_FUNCTION)(PHASH_TABLE_ENTRY, PVOID);

// The prototype of a data-copy function
typedef VOID (*PHASH_COPY_FUNCTION)(PHASH_TABLE_ENTRY, PUCHAR);

// The prototype of a function used in calls to BrdgHashPrefixMultiMatch
typedef VOID (*PMULTIMATCH_FUNC)(PHASH_TABLE_ENTRY, PVOID);

//
// Structure of the table itself
//
typedef struct _HASH_TABLE
{
    NPAGED_LOOKASIDE_LIST       entryPool;

    //
    // The consistency of the buckets is protected by the tableLock.
    //
    // The LastSeen field in each entry is volatile and is updated
    // with interlocked instructions.
    //
    NDIS_RW_LOCK                tableLock;

    // These fields never change after creation
    PHASH_FUNCTION              pHashFunction;
    PHASH_TABLE_ENTRY          *pBuckets;
    ULONG                       numBuckets, entrySize;
    UINT                        keySize;
    BRIDGE_TIMER                timer;
    ULONG_PTR                   maxEntries;
    ULONG                       maxTimeoutAge;      // Maximum possible timeoutAge

    // These fields change but are protected by the tableLock.
    ULONG_PTR                   numEntries;
    ULONG                       nextTimerBucket;

    // This field is manipulated with InterlockExchange() instructions
    // to avoid having to take the table lock to change it.
    ULONG                       timeoutAge;

    // In debug builds, this tracks how many entries are in each bucket
    // so we can tell whether the table is well balanced
#if DBG
    PUINT                       bucketSizes;
#endif
} HASH_TABLE, *PHASH_TABLE;



// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

PHASH_TABLE
BrdgHashCreateTable(
    IN PHASH_FUNCTION           pHashFunction,
    IN ULONG                    numBuckets,
    IN ULONG                    entrySize,
    IN ULONG                    maxEntries,
    IN ULONG                    startTimeoutAge,
    IN ULONG                    maxTimeoutAge,
    IN UINT                     keySize
    );

VOID
BrdgHashFreeHashTable(
    IN PHASH_TABLE      pTable
    );

PHASH_TABLE_ENTRY
BrdgHashFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    IN LOCK_STATE              *pLockState
    );

PHASH_TABLE_ENTRY
BrdgHashRefreshOrInsert(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    OUT BOOLEAN                *pIsNewEntry,
    OUT PLOCK_STATE             pLockState
    );

VOID
BrdgHashRemoveMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    PVOID                       pData
    );

ULONG
BrdgHashCopyMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    IN PHASH_COPY_FUNCTION      pCopyFunction,
    IN ULONG                    copyUnitSize,
    IN PVOID                    pData,
    IN PUCHAR                   pBuffer,
    IN ULONG                    BufferLength
    );

VOID
BrdgHashPrefixMultiMatch(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pPrefixKey,
    IN UINT                     prefixLen,
    IN PMULTIMATCH_FUNC         pFunc,
    IN PVOID                    pData
    );

// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Changes the timeout value for a hash table
//
__forceinline
VOID
BrdgHashChangeTableTimeout(
    IN PHASH_TABLE              pTable,
    IN ULONG                    timeout
    )
{
    InterlockedExchange( (PLONG)&pTable->timeoutAge, (LONG)timeout );
}

//
// Refreshes a table entry held by the caller.
// ASSUMES the caller holds a read or write lock on the table
// enclosing this entry!
//
__forceinline
VOID
BrdgHashRefreshEntry(
    IN PHASH_TABLE_ENTRY        pEntry
    )
{
    ULONG                       CurrentTime;

    NdisGetSystemUpTime( &CurrentTime );
    InterlockedExchange( (PLONG)&pEntry->LastSeen, (LONG)CurrentTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgmini.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgmini.c

Abstract:

    Ethernet MAC level bridge.
    Miniport section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgmini.h"
#include "brdgfwd.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgsta.h"
#include "brdgcomp.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// NDIS Wrapper handle
NDIS_HANDLE     gNDISWrapperHandle = NULL;

// Handle to our miniport driver
NDIS_HANDLE     gMiniPortDriverHandle = NULL;

// ----------------------------------------------
// The handle of the miniport (NULL if not initialized)
NDIS_HANDLE     gMiniPortAdapterHandle = NULL;

// Refcount to allow waiting for other code to finish using the miniport
WAIT_REFCOUNT   gMiniPortAdapterRefcount;

// Refcount indicating whether the bridge miniport is media-connected
WAIT_REFCOUNT   gMiniPortConnectedRefcount;

// Refcount indicating whether the bridge miniport is in the middle of a media
// state toggle.
WAIT_REFCOUNT   gMiniPortToggleRefcount;
// ----------------------------------------------
//
// Refcount for use in passing through requests to underlying NICs
// This works because NDIS doesn't make requests re-entrantly. That
// is, only one SetInfo operation can be pending at any given time.
//
LONG            gRequestRefCount;
// ----------------------------------------------
// Virtual characteristics of the bridge adapter
ULONG           gBridgeLinkSpeed = 10000L,          // Start at 1Mbps, since reporting
                                                    // zero makes some components unhappy.
                                                    // Measured in 100's of bps.
                gBridgeMediaState = NdisMediaStateDisconnected;

// MAC Address of the bridge. This does not change once
// it has been set.
UCHAR           gBridgeAddress[ETH_LENGTH_OF_ADDRESS];

// Whether we have chosen an address yet
BOOLEAN         gHaveAddress;

// Current bridge packet filter
ULONG           gPacketFilter = 0L;

// Current multicast list
PUCHAR          gMulticastList = NULL;
ULONG           gMulticastListLength = 0L;

// Device name of the bridge miniport (from the registry)
PWCHAR          gBridgeDeviceName = NULL;
ULONG           gBridgeDeviceNameSize = 0L;

// RW lock to protect all above bridge variables
NDIS_RW_LOCK    gBridgeStateLock;
//-----------------------------------------------
// Name of the registry entry for the device name
const PWCHAR    gDeviceNameEntry = L"Device";

// Description of our miniport
const PCHAR     gDriverDescription = "Microsoft MAC Bridge Virtual NIC";
// ----------------------------------------------
// Device object so user-mode code can talk to us
PDEVICE_OBJECT  gDeviceObject = NULL;

// NDIS handle to track the device object
NDIS_HANDLE     gDeviceHandle = NULL;
// ----------------------------------------------

// List of supported OIDs
NDIS_OID        gSupportedOIDs[] =
{
    // General characteristics
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,

    // Set only characteristics (relayed)
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    OID_GEN_TRANSPORT_HEADER_OFFSET,

    // General statistics
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_DIRECTED_BYTES_XMIT,
    OID_GEN_DIRECTED_FRAMES_XMIT,
    OID_GEN_MULTICAST_BYTES_XMIT,
    OID_GEN_MULTICAST_FRAMES_XMIT,
    OID_GEN_BROADCAST_BYTES_XMIT,
    OID_GEN_BROADCAST_FRAMES_XMIT,
    OID_GEN_DIRECTED_BYTES_RCV,
    OID_GEN_DIRECTED_FRAMES_RCV,
    OID_GEN_MULTICAST_BYTES_RCV,
    OID_GEN_MULTICAST_FRAMES_RCV,
    OID_GEN_BROADCAST_BYTES_RCV,
    OID_GEN_BROADCAST_FRAMES_RCV,

    // Ethernet characteristics
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,

    // Ethernet statistics
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,

    // PnP OIDs
    OID_PNP_QUERY_POWER,
    OID_PNP_SET_POWER,

    // tcp oids
    OID_TCP_TASK_OFFLOAD

};



// 1394 specific related global variables
#define OID_1394_ENTER_BRIDGE_MODE                  0xFF00C914
#define OID_1394_EXIT_BRIDGE_MODE                   0xFF00C915

// Set when the bridge knows that tcpip has been loaded
// set on receiving the OID_TCP_TASK_OFFLOAD Oid
BOOLEAN g_fIsTcpIpLoaded = FALSE;


// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgMiniHalt(
    IN NDIS_HANDLE      MiniportAdapterContext
    );

NDIS_STATUS
BrdgMiniInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN PNDIS_MEDIUM     MediumArray,
    IN UINT             MediumArraySize,
    IN NDIS_HANDLE      MiniportAdapterHandle,
    IN NDIS_HANDLE      WrapperConfigurationContext
    );

NDIS_STATUS
BrdgMiniQueryInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesWritten,
    OUT PULONG          BytesNeeded
    );

NDIS_STATUS
BrdgMiniReset(
    OUT PBOOLEAN        AddressingReset,
    IN NDIS_HANDLE      MiniportAdapterContext
    );

VOID
BrdgMiniSendPackets(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN PPNDIS_PACKET    PacketArray,
    IN UINT             NumberOfPackets
    );

NDIS_STATUS
BrdgMiniSetInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesRead,
    OUT PULONG          BytesNeeded
    );

BOOLEAN
BrdgMiniAddrIsInMultiList(
    IN PUCHAR               pTargetAddr
    );

VOID
BrdgMiniRelayedRequestComplete(
    PNDIS_REQUEST_BETTER        pRequest,
    PVOID                       unused
    );

VOID
BrdgMiniReAcquireMiniport();

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================


NTSTATUS
BrdgMiniDriverInit()
/*++

Routine Description:

    Load-time initialization function

    Must run at PASSIVE_LEVEL since we call NdisRegisterDevice().

Arguments:

    None

Return Value:

    Status of initialization. A return code != STATUS_SUCCESS causes driver load
    to fail. Any event causing a failure return code must be logged, as it
    prevents us from loading successfully.

--*/
{
    NDIS_MINIPORT_CHARACTERISTICS   MiniPortChars;
    NDIS_STATUS                     NdisStatus;
    PDRIVER_DISPATCH                DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];
    NDIS_STRING                     DeviceName, LinkName;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    NdisInitializeReadWriteLock( &gBridgeStateLock );
    BrdgInitializeWaitRef( &gMiniPortAdapterRefcount, FALSE );
    BrdgInitializeWaitRef( &gMiniPortConnectedRefcount, TRUE );
    BrdgInitializeWaitRef( &gMiniPortToggleRefcount, FALSE );

    // Put the miniport refcount into shutdown mode (so a refcount can't be acquired)
    // since we don't have a miniport yet
    BrdgShutdownWaitRefOnce( &gMiniPortAdapterRefcount );

    // We start out disconnected so shutdown the media-connect waitref too.
    BrdgShutdownWaitRefOnce( &gMiniPortConnectedRefcount );

    NdisInitUnicodeString( &DeviceName, DEVICE_NAME );
    NdisInitUnicodeString( &LinkName, SYMBOLIC_NAME );

    // Must first tell NDIS we're a miniport driver and initializing
    NdisMInitializeWrapper( &gNDISWrapperHandle, gDriverObject, &gRegistryPath, NULL );

    // Fill in the description of our miniport
    NdisZeroMemory(&MiniPortChars, sizeof(MiniPortChars));
    MiniPortChars.MajorNdisVersion = 5;
    MiniPortChars.MinorNdisVersion = 0;

    MiniPortChars.HaltHandler = BrdgMiniHalt;
    MiniPortChars.InitializeHandler  = BrdgMiniInitialize;
    MiniPortChars.QueryInformationHandler  = BrdgMiniQueryInfo;
    MiniPortChars.ResetHandler = BrdgMiniReset;
    MiniPortChars.SendPacketsHandler = BrdgMiniSendPackets;
    MiniPortChars.SetInformationHandler  = BrdgMiniSetInfo;

    //
    // Wire the ReturnPacketHandler straight into the forwarding engine
    //
    MiniPortChars.ReturnPacketHandler = BrdgFwdReturnIndicatedPacket;

    // Create a virtual NIC
    NdisStatus = NdisIMRegisterLayeredMiniport( gNDISWrapperHandle, &MiniPortChars, sizeof(MiniPortChars),
                                                &gMiniPortDriverHandle );


    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_MINIPORT_REGISTER_FAILED, 0, 0, NULL,
                                sizeof(NDIS_STATUS), &NdisStatus );
        DBGPRINT(MINI, ("Failed to create an NDIS virtual NIC: %08x\n", NdisStatus));
        NdisTerminateWrapper( gNDISWrapperHandle, NULL );
        return NdisStatus;
    }

    //
    // Initialize Dispatch Table array before setting selected members
    //
    NdisZeroMemory( DispatchTable, sizeof( DispatchTable ) );

    //
    // Register a device object and symbolic link so user-mode code can talk to us
    //
    DispatchTable[IRP_MJ_CREATE] = BrdgDispatchRequest;
    DispatchTable[IRP_MJ_CLEANUP] = BrdgDispatchRequest;
    DispatchTable[IRP_MJ_CLOSE] = BrdgDispatchRequest;
    DispatchTable[IRP_MJ_DEVICE_CONTROL] = BrdgDispatchRequest;

    NdisStatus = NdisMRegisterDevice( gNDISWrapperHandle, &DeviceName, &LinkName, DispatchTable,
                                      &gDeviceObject, &gDeviceHandle );

    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_DEVICE_CREATION_FAILED, 0, 0, NULL,
                                sizeof(NDIS_STATUS), &NdisStatus );
        DBGPRINT(MINI, ("Failed to create a device object and sym link: %08x\n", NdisStatus));
        NdisIMDeregisterLayeredMiniport( gMiniPortDriverHandle );
        NdisTerminateWrapper( gNDISWrapperHandle, NULL );
        return NdisStatus;
    }

    // Register the unload function
    NdisMRegisterUnloadHandler(gNDISWrapperHandle, BrdgUnload);

    return STATUS_SUCCESS;
}

VOID
BrdgMiniCleanup()
/*++

Routine Description:

    Unload-time orderly shutdown function

    This function is guaranteed to be called exactly once

    Must run at PASSIVE_LEVEL since we call NdisIMDeInitializeDeviceInstance

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_STATUS     NdisStatus;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    DBGPRINT(MINI, ("BrdgMiniCleanup\n"));

    if( gMiniPortAdapterHandle != NULL )
    {
        SAFEASSERT( gNDISWrapperHandle != NULL );

        // This should cause a call to BrdgMiniHalt where gMiniPortAdapterHandle
        // is NULLed out

        NdisStatus = NdisIMDeInitializeDeviceInstance( gMiniPortAdapterHandle );
        SAFEASSERT( NdisStatus == NDIS_STATUS_SUCCESS );
    }
    else
    {
        //
        // Tear down our device object. This is normally done when the miniport
        // shuts down, but in scenarios where the miniport was never created,
        // the device object still exists at this point.
        //
        NDIS_HANDLE     Scratch = gDeviceHandle;

        if( Scratch != NULL )
        {
            // Tear down the device object
            gDeviceHandle = gDeviceObject = NULL;
            NdisMDeregisterDevice( Scratch );
        }
    }

    // Unregister ourselves as an intermediate driver
    NdisIMDeregisterLayeredMiniport( gMiniPortDriverHandle );
}

BOOLEAN
BrdgMiniIsBridgeDeviceName(
    IN PNDIS_STRING         pDeviceName
    )
/*++

Routine Description:

    Compares a device name to the current device name of the bridge miniport.

    This actually requires that we allocate memory, so it should be called sparingly.

Arguments:

    pDeviceName             The name of a device

Return Value:

    TRUE if the names match (case is ignored), FALSE otherwise.

--*/
{
    LOCK_STATE              LockState;
    BOOLEAN                 rc = FALSE;
    NDIS_STATUS             Status;
    ULONG                   BridgeNameCopySize = 0L;
    PWCHAR                  pBridgeNameCopy = NULL;

    // The bridge device name must be read inside the gBridgeStateLock
    NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE/*Read access*/, &LockState );

    if( gBridgeDeviceName != NULL )
    {
        if( gBridgeDeviceNameSize > 0 )
        {
            // Alloc memory for the copy of the name
            Status = NdisAllocateMemoryWithTag( &pBridgeNameCopy, gBridgeDeviceNameSize, 'gdrB' );

            if( Status == NDIS_STATUS_SUCCESS )
            {
                // Copy the name
                NdisMoveMemory( pBridgeNameCopy, gBridgeDeviceName, gBridgeDeviceNameSize );
                BridgeNameCopySize = gBridgeDeviceNameSize;
            }
            else
            {
                SAFEASSERT( pBridgeNameCopy == NULL );
            }
        }
        else
        {
            SAFEASSERT( FALSE );
        }
    }

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    if( pBridgeNameCopy != NULL )
    {
        NDIS_STRING         NdisStr;

        NdisInitUnicodeString( &NdisStr, pBridgeNameCopy );

        if( NdisEqualString( &NdisStr, pDeviceName, TRUE/*Ignore case*/ ) )
        {
            rc = TRUE;
        }

        NdisFreeMemory( pBridgeNameCopy, BridgeNameCopySize, 0 );
    }

    return rc;
}

VOID
BrdgMiniInstantiateMiniport()
/*++

Routine Description:

    Instantiates the virtual NIC we expose to overlying protocols.

    At least one adapter must be in the global adapter list, since we build
    our MAC address with the MAC address of the first bound adapter.

    Must run at < DISPATCH_LEVEL since we call NdisIMInitializeDeviceInstanceEx

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    NTSTATUS                NtStatus;
    NDIS_STRING             NdisString;
    LOCK_STATE              LockState;
    PWCHAR                  pDeviceName;
    ULONG                   DeviceNameSize;

    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);

    DBGPRINT(MINI, ("About to instantiate the miniport...\n"));

    //
    // Retrieve our device name from the registry
    // (it is written there by our notify object during install)
    //
    NtStatus = BrdgReadRegUnicode( &gRegistryPath, gDeviceNameEntry, &pDeviceName, &DeviceNameSize );

    if( NtStatus != STATUS_SUCCESS )
    {
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING, 0, 0, NULL,
                                sizeof(NTSTATUS), &NtStatus );
        DBGPRINT(MINI, ("Failed to retrieve the miniport's device name: %08x\n", NtStatus));
        return;
    }

    SAFEASSERT( pDeviceName != NULL );
    DBGPRINT(MINI, ("Initializing miniport with device name %ws\n", pDeviceName));

    NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

    if( ! gHaveAddress )
    {
        // We don't have a MAC address yet. This is fatal.
        NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );
        DBGPRINT(MINI, ("Failed to determine a MAC address: %08x\n", Status));
        NdisFreeMemory( pDeviceName, DeviceNameSize, 0 );
        return;
    }

    //
    // Save the device name in our global for use until we reinitialize.
    // Must do this before calling NdisIMInitializeDeviceInstanceEx, since NDIS calls
    // BrdgProtBindAdapter in the context of our call to NdisIMInitializeDeviceInstanceEx
    // and we want to consult the bridge's device name when binding
    //

    if( gBridgeDeviceName != NULL )
    {
        // Free the old name
        NdisFreeMemory( gBridgeDeviceName, gBridgeDeviceNameSize, 0 );
    }

    gBridgeDeviceName = pDeviceName;
    gBridgeDeviceNameSize = DeviceNameSize;

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    // Go ahead and intantiate the miniport.
    NdisInitUnicodeString( &NdisString, pDeviceName );
    Status = NdisIMInitializeDeviceInstanceEx(gMiniPortDriverHandle, &NdisString, NULL);

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Log this error since it means we can't create the miniport
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_MINIPORT_INIT_FAILED, 0L, 0L, NULL,
                                sizeof(NDIS_STATUS), &Status );

        DBGPRINT(MINI, ("NdisIMInitializeDeviceInstanceEx failed: %08x\n", Status));

        // Destroy the stored device name for the miniport
        NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

        if( gBridgeDeviceName != NULL )
        {
            // Free the old name
            NdisFreeMemory( gBridgeDeviceName, gBridgeDeviceNameSize, 0 );
        }

        gBridgeDeviceName = NULL;
        gBridgeDeviceNameSize = 0L;

        NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
    }
}

BOOLEAN
BrdgMiniShouldIndicatePacket(
    IN PUCHAR               pTargetAddr
    )
/*++

Routine Description:

    Determines whether an inbound packet should be indicated to overlying protocols through
    our virtual NIC

Arguments:

    pTargetAddr             The target MAC address of a packet

Return Value:

    TRUE          :         The packet should be indicated
    FALSE         :         The packet should not be indicated

--*/
{
    BOOLEAN                 bIsBroadcast, bIsMulticast, bIsLocalUnicast, rc = FALSE;
    LOCK_STATE              LockState;

    if( gMiniPortAdapterHandle == NULL )
    {
        // Yikes! The miniport isn't set up yet. Definitely don't indicate!
        return FALSE;
    }

    bIsBroadcast = ETH_IS_BROADCAST(pTargetAddr);
    bIsMulticast = ETH_IS_MULTICAST(pTargetAddr);
    bIsLocalUnicast = BrdgMiniIsUnicastToBridge(pTargetAddr);

    // Get read access to the packet filter
    NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read-only*/, &LockState );

    do
    {
        // Promiscuous / ALL_LOCAL means indicate everything
        if( (gPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) != 0 )
        {
            rc = TRUE;
            break;
        }

        if( ((gPacketFilter & NDIS_PACKET_TYPE_BROADCAST) != 0) && bIsBroadcast )
        {
            rc = TRUE;
            break;
        }

        if( ((gPacketFilter & NDIS_PACKET_TYPE_DIRECTED) != 0) && bIsLocalUnicast )
        {
            rc = TRUE;
            break;
        }

        if( bIsMulticast )
        {
            if( (gPacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) != 0 )
            {
                rc = TRUE;
                break;
            }
            else if( (gPacketFilter & NDIS_PACKET_TYPE_MULTICAST) != 0 )
            {

                rc = BrdgMiniAddrIsInMultiList( pTargetAddr );
            }
        }
    }
    while (FALSE);

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    return rc;
}

BOOLEAN
BrdgMiniIsUnicastToBridge (
    IN PUCHAR               Address
    )
/*++

Routine Description:

    Determines whether a given packet is a directed packet unicast straight to
    the bridge's host machine

Arguments:

    Address                 The target MAC address of a packet

Return Value:

    TRUE            :       This is a directed packet destined for the local machine
    FALSE           :       The above is not true

--*/
{
    UINT                    Result;

    if( gHaveAddress )
    {
        // Not necessary to acquire a lock to read gBridgeAddress since it cannot
        // change once it is set.
        ETH_COMPARE_NETWORK_ADDRESSES_EQ( Address, gBridgeAddress, &Result );
    }
    else
    {
        // We have no MAC address, so this can't be addressed to us!
        Result = 1;         // Inequality
    }

    return (BOOLEAN)(Result == 0);   // Zero is equality
}

VOID
BrdgMiniAssociate()
/*++

Routine Description:

    Associates our miniport with our protocol

    Must run at PASSIVE_LEVEL

Arguments:

    None

Return Value:

    None

--*/
{
    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Associate ourselves with the protocol section in NDIS's tortured mind
    NdisIMAssociateMiniport( gMiniPortDriverHandle, gProtHandle );
}

VOID
BrdgMiniDeferredMediaDisconnect(
    IN PVOID            arg
    )
/*++

Routine Description:

    Signals a media-disconnect to NDIS

    Must run at PASSIVE IRQL, since we have to wait for all packet indications
    to complete before indicating media-disconnect.

Arguments:

    arg                 The bridge miniport handle (must be released)

Return Value:

    None

--*/
{
    NDIS_HANDLE         MiniportHandle = (NDIS_HANDLE)arg;

    if( BrdgShutdownBlockedWaitRef(&gMiniPortConnectedRefcount) )
    {
        // Nobody can indicate packets anymore.

        LOCK_STATE      LockState;

        //
        // Close a timing window: we may have just gone media-connect but our high-IRQL
        // processing may not yet have reset the wait-refcount. Serialize here so it's
        // impossible for us to signal a disconnect to NDIS after we have actually
        // gone media-connect.
        //
        // This RELIES on high-IRQL processing acquiring gBridgeStateLock to set
        // gBridgeMediaState to NdisMediaStateConnected BEFORE signalling the
        // media-connected state to NDIS.
        //
        NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read access*/, &LockState );

        if( gBridgeMediaState == NdisMediaStateDisconnected )
        {
            DBGPRINT(MINI, ("Signalled media-disconnect from deferred function\n"));
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0L );
        }
        else
        {
            DBGPRINT(MINI, ("Aborted deferred media-disconnect: media state inconsistent\n"));
        }

        NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
    }
    else
    {
        // Someone set us back to the connected state before we got executed
        DBGPRINT(MINI, ("Aborted deferred media-disconnect: wait-ref reset\n"));
    }

    BrdgMiniReleaseMiniport();
}

VOID
BrdgMiniDeferredMediaToggle(
    IN PVOID            arg
    )
/*++

Routine Description:

    Signals a media-disconnect to NDIS followed quickly by a media-connect. Used
    to indicate to upper-layer protocols like TCPIP that the bridge may have
    disconnected from a network segment it could previously reach, or that we may
    now be able to reach a network segment that we couldn't before.

    Must run at PASSIVE IRQL, since we have to wait for all packet indications
    to complete before indicating media-disconnect.

Arguments:

    arg                 The bridge miniport handle (must be released)

Return Value:

    None

--*/
{
    NDIS_HANDLE         MiniportHandle = (NDIS_HANDLE)arg;

    // We need a guarantee that the miniport is media-connect to be able to do
    // the toggle properly.
    if( BrdgIncrementWaitRef(&gMiniPortConnectedRefcount) )
    {
        // Stop people from indicating packets
        if( BrdgShutdownWaitRef(&gMiniPortToggleRefcount) )
        {
            DBGPRINT(MINI, ("Doing deferred media toggle\n"));

            // Toggle our media state with NDIS
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0L );
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_CONNECT, NULL, 0L );

            // Allow people to indicate packets again
            BrdgResetWaitRef( &gMiniPortToggleRefcount );
        }
        else
        {
            DBGPRINT(MINI, ("Multiple toggles in progress simultaneously\n"));
        }

        BrdgDecrementWaitRef( &gMiniPortConnectedRefcount );
    }
    // else the miniport isn't media-connect, so the toggle makes no sense.

    BrdgMiniReleaseMiniport();
}

VOID
BrdgMiniUpdateCharacteristics(
    IN BOOLEAN              bConnectivityChange
    )
/*++

Routine Description:

    Recalculates the link speed and media status (connected / disconnected) that
    our virtual NIC exposes to overlying protocols

Arguments:

    bConnectivityChange     Whether the change that prompted this call is a change
                            in connectivity (i.e., we acquired or lost an adapter).

Return Value:

    None

--*/
{
    LOCK_STATE              LockState, ListLockState, AdaptersLockState;
    PADAPT                  pAdapt;
    ULONG                   MediaState = NdisMediaStateDisconnected;
    ULONG                   FastestSpeed = 0L;
    BOOLEAN                 UpdateSpeed = FALSE, UpdateMediaState = FALSE;
    NDIS_HANDLE             MiniportHandle;

    // Need to read the adapter list and also have the adapters' characteristics not change
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read-only*/, &ListLockState );
    NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, FALSE /*Read-only*/, &AdaptersLockState );

    pAdapt = gAdapterList;

    while( pAdapt != NULL )
    {
        // An adapter must be connected and actively handling packets to change our
        // virtual media state.
        if( (pAdapt->MediaState == NdisMediaStateConnected) && (pAdapt->State == Forwarding) )
        {
            // We're connected if at least one NIC is connected
            MediaState = NdisMediaStateConnected;

            // The NIC must be connected for us to consider its speed
            if( pAdapt->LinkSpeed > FastestSpeed )
            {
                FastestSpeed = pAdapt->LinkSpeed;
            }
        }

        pAdapt = pAdapt->Next;
    }

    NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &AdaptersLockState );
    NdisReleaseReadWriteLock( &gAdapterListLock, &ListLockState );

    // Update the characteristics
    NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE /*Write access*/, &LockState );

    //
    // Only update our virtual link speed if we actually got at least one real speed
    // from our NICs. If everything is disconnected, the resulting FastestSpeed is
    // zero. In this case, we don't want to actually report a zero speed up to
    // overlying protocols; we stick at the last known speed until someone reconnects.
    //
    if( (gBridgeLinkSpeed != FastestSpeed) && (FastestSpeed != 0L) )
    {
        UpdateSpeed = TRUE;
        gBridgeLinkSpeed = FastestSpeed;
        DBGPRINT(MINI, ("Updated bridge speed to %iMbps\n", FastestSpeed / 10000));
    }

    if( gBridgeMediaState != MediaState )
    {
        UpdateMediaState = TRUE;
        gBridgeMediaState = MediaState;

        if( MediaState == NdisMediaStateConnected )
        {
            DBGPRINT(MINI, ("CONNECT\n"));
        }
        else
        {
            DBGPRINT(MINI, ("DISCONNECT\n"));
        }
    }

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

    MiniportHandle = BrdgMiniAcquireMiniport();

    if( MiniportHandle != NULL )
    {
        if( UpdateMediaState )
        {
            // Our link state has changed.
            if( MediaState == NdisMediaStateConnected )
            {
                //
                // Tell NDIS we will be indicating packets again.
                //
                // NOTE: BrdgMiniDeferredMediaDisconnect RELIES on us doing this after
                // having updated gBridgeMediaState inside gBridgeStateLock so it can
                // close the timing window between this call and the BrdgResetWaitRef() call.
                //
                NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_MEDIA_CONNECT, NULL, 0L );

                // Re-enable packet indication.
                BrdgResetWaitRef( &gMiniPortConnectedRefcount );
            }
            else
            {
                SAFEASSERT( MediaState == NdisMediaStateDisconnected );

                // Stop people from indicating packets
                BrdgBlockWaitRef( &gMiniPortConnectedRefcount );

                // We hand MiniportHandle to our deferred function
                BrdgMiniReAcquireMiniport();

                // Have to do the media-disconnect indication at PASSIVE level, since we must
                // first wait for everyone to finish indicating packets.
                if( BrdgDeferFunction( BrdgMiniDeferredMediaDisconnect, MiniportHandle ) != NDIS_STATUS_SUCCESS )
                {
                    // Failed to defer the function. Avoid leaking a refcount
                    BrdgMiniReleaseMiniport();
                }
            }
        }
        else if( bConnectivityChange )
        {
            //
            // There was no actual change to our media state. However, if the change that prompted this call
            // is a connectivity change and our media state is currently CONNECTED, we toggle it to
            // DISCONNECTED and back again to "hint" to upper-layer protocols like IP that the underlying
            // network may have changed. For example, in IP's case, a DHCP server may have become visible
            // (or a previously visible server may have disappeared) because of a connectivity change.
            // The hint causes IP to look for a DHCP server afresh.
            //
            if( MediaState == NdisMediaStateConnected )
            {
                // We hand MiniportHandle to our deferred function
                BrdgMiniReAcquireMiniport();

                // Toggle has to be done at PASSIVE level.
                if( BrdgDeferFunction( BrdgMiniDeferredMediaToggle, MiniportHandle ) != NDIS_STATUS_SUCCESS )
                {
                    // Failed to defer the function. Avoid leaking a refcount
                    BrdgMiniReleaseMiniport();
                }
            }
        }

        if( UpdateSpeed )
        {
            // Tell overlying protocols that our speed has changed
            NdisMIndicateStatus( MiniportHandle, NDIS_STATUS_LINK_SPEED_CHANGE, &FastestSpeed, sizeof(ULONG) );
        }

        BrdgMiniReleaseMiniport();
    }
}

NDIS_HANDLE
BrdgMiniAcquireMiniportForIndicate()
/*++

Routine Description:

    Acquires the bridge miniport handle for the purpose of indicating packets.
    In addition to guaranteeing that the miniport will exist until the caller calls
    BrdgMiniReleaseMiniportForIndicate(), the caller is also allowed to indicate
    packets using the returned miniport handle until the miniport is released.

Arguments:

    None

Return Value:

    The NDIS handle for the virtual NIC. This can be used to indicate packets
    until a reciprocal call to BrdgMiniReleaseMiniportForIndicate().

--*/
{
    if( BrdgIncrementWaitRef(&gMiniPortAdapterRefcount) )
    {
        SAFEASSERT( gMiniPortAdapterHandle != NULL );

        // The miniport needs to be media-connect to indicate packets.
        if( BrdgIncrementWaitRef(&gMiniPortConnectedRefcount) )
        {
            // A media-state toggle had better not be in progress
            if( BrdgIncrementWaitRef(&gMiniPortToggleRefcount) )
            {
                // Caller can use the miniport
                return gMiniPortAdapterHandle;
            }
            // else miniport exists but is toggling its state

            BrdgDecrementWaitRef( &gMiniPortConnectedRefcount );
        }
        // else miniport exists but is media-disconnected

        BrdgDecrementWaitRef( &gMiniPortAdapterRefcount );
    }
    // else miniport does not exist.

    return NULL;
}

NDIS_HANDLE
BrdgMiniAcquireMiniport()
/*++

Routine Description:

    Increments the miniport's refcount so it cannot be torn down until a corresponding
    BrdgMiniReleaseMiniport() call is made.

    The caller may NOT use the returned miniport handle to indicate packets, since the
    miniport is not guaranteed to be in an appropriate state.

Arguments:

    None

Return Value:

    The NDIS handle for the virtual NIC. This can be used safely until a reciprocal call
    to BrdgMiniReleaseMiniport().

--*/
{
    if( gMiniPortAdapterHandle && BrdgIncrementWaitRef(&gMiniPortAdapterRefcount) )
    {
        return gMiniPortAdapterHandle;
    }
    // else miniport does not exist.

    return NULL;
}

VOID
BrdgMiniReAcquireMiniport()
/*++

Routine Description:

    Reacquires the miniport (caller must have previously called BrdgMiniAcquireMiniport()
    and not yet called BrdgMiniReleaseMiniport().

Arguments:

    None

Return Value:

    None. The caller should already be holding a handle for the miniport.

--*/
{
    BrdgReincrementWaitRef(&gMiniPortAdapterRefcount);
}

VOID
BrdgMiniReleaseMiniport()
/*++

Routine Description:

    Decrements the miniport's refcount. The caller should no longer use the handle
    previously returned by BrdgMiniAcquireMiniport().

Arguments:

    None

Return Value:

    None

--*/
{
    BrdgDecrementWaitRef( &gMiniPortAdapterRefcount );
}

VOID
BrdgMiniReleaseMiniportForIndicate()
/*++

Routine Description:

    Decrements the miniport's refcount. The caller should no longer use the handle
    previously returned by BrdgMiniAcquireMiniportForIndicate().

Arguments:

    None

Return Value:

    None

--*/
{
    BrdgDecrementWaitRef( &gMiniPortToggleRefcount );
    BrdgDecrementWaitRef( &gMiniPortConnectedRefcount );
    BrdgDecrementWaitRef( &gMiniPortAdapterRefcount );
}


BOOLEAN
BrdgMiniReadMACAddress(
    OUT PUCHAR              pAddr
    )
/*++

Routine Description:

    Reads the bridge miniport's MAC address.

Arguments:

    Address of a buffer to receive the address

Return Value:

    TRUE if the value was copied out successfully
    FALSE if we don't yet have a MAC address (nothing was copied)

--*/
{
    BOOLEAN                 rc;

    if( gHaveAddress )
    {
        // Not necessary to acquire a lock to read the address since
        // it cannot change once it is set
        ETH_COPY_NETWORK_ADDRESS( pAddr, gBridgeAddress );
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    return rc;
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgMiniInitFromAdapter(
    IN PADAPT               pAdapt
    )
/*++

Routine Description:

    Called by the protocol section to give us a chance to establish the bridge's
    MAC address when a new adapter arrives. If we succeed in determining a MAC
    address from the given adapter, we in turn call the STA module to tell it
    our MAC address, which it needs as early as possible.

    The MAC address of the bridge is set as the MAC address of the given adapter
    with the "locally administered" bit set. This should (hopefully) make the
    address unique in the local network as well as unique within our machine.

    This function is called for every new adapter but we only need to initialize
    once.

Arguments:

    pAdapt                  An adapter to use to initialize

Return Value:

    Status of the operation

--*/
{
    if( ! gHaveAddress )
    {
        LOCK_STATE              LockState;

        NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

        // Possible for the gHaveAddress flag to have changed before acquiring the lock
        if( ! gHaveAddress )
        {
            // Copy out the NIC's MAC address
            ETH_COPY_NETWORK_ADDRESS( gBridgeAddress, pAdapt->MACAddr );

            //
            // Set the second-least significant bit of the NIC's MAC address. This moves the address
            // into the locally administered space.
            //
            gBridgeAddress[0] |= (UCHAR)0x02;

            DBGPRINT(MINI, ("Using MAC Address %02x-%02x-%02x-%02x-%02x-%02x\n",
                      (UINT)gBridgeAddress[0], (UINT)gBridgeAddress[1], (UINT)gBridgeAddress[2],
                      (UINT)gBridgeAddress[3], (UINT)gBridgeAddress[4], (UINT)gBridgeAddress[5]));

            gHaveAddress = TRUE;

            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            if( !gDisableSTA )
            {
                // We are responsible for calling the STA module to complete its initialization once
                // we know our MAC address.
                BrdgSTADeferredInit( gBridgeAddress );
            }

            // We are also responsible for letting the compatibility-mode code know about our
            // MAC address once it is set.
            BrdgCompNotifyMACAddress( gBridgeAddress );
        }
        else
        {
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
        }
    }
}

BOOLEAN
BrdgMiniAddrIsInMultiList(
    IN PUCHAR               pTargetAddr
    )
/*++

Routine Description:

    Determines whether a given multicast address is in the list of addresses that
    we must indicate to overlying protocols

    The caller is responsible for synchronization; it must have AT LEAST a read lock on
    gBridgeStateLock.

Arguments:

    pTargetAddr             The address to analyze

Return Value:

    TRUE            :       This address is a multicast address that we have been asked
                            to indicate

    FALSE           :       The above is not true

--*/
{
    PUCHAR                  pCurAddr = gMulticastList;
    ULONG                   i;
    BOOLEAN                 rc = FALSE;

    // The list must have an integral number of addresses!
    SAFEASSERT( (gMulticastListLength % ETH_LENGTH_OF_ADDRESS) == 0 );

    for( i = 0;
         i < (gMulticastListLength / ETH_LENGTH_OF_ADDRESS);
         i++, pCurAddr += ETH_LENGTH_OF_ADDRESS
       )
    {
        UINT   Result;
        ETH_COMPARE_NETWORK_ADDRESSES_EQ( pTargetAddr, pCurAddr, &Result );

        if( Result == 0 )
        {
            rc = TRUE;
            break;
        }
    }

    return rc;
}

VOID
BrdgMiniHalt(
    IN NDIS_HANDLE      MiniportAdapterContext
    )
/*++

Routine Description:

    Called when the virtual NIC is de-instantiated. We NULL out the miniport handle and
    stall the tear-down until everyone is done using the miniport.

    Must be called at PASSIVE_LEVEL since we wait on an event

Arguments:

    MiniportAdapterContext  Ignored

Return Value:

    None

--*/
{
    NDIS_HANDLE     Scratch = gDeviceHandle;
    LOCK_STATE      LockState;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    DBGPRINT(MINI, ("BrdgMiniHalt\n"));

    if( Scratch != NULL )
    {
        // Tear down the device object
        gDeviceHandle = gDeviceObject = NULL;
        NdisMDeregisterDevice( Scratch );
    }

    if( gMiniPortAdapterHandle != NULL )
    {
        // Stall before returning until everyone is done using the miniport handle.
        // This also prevents people from acquiring the miniport handle.
        BrdgShutdownWaitRefOnce( &gMiniPortAdapterRefcount );
        gMiniPortAdapterHandle = NULL;
        DBGPRINT(MINI, ("Done stall\n"));
    }

    NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE/*Write access*/, &LockState );

    if( gBridgeDeviceName != NULL )
    {
        NdisFreeMemory( gBridgeDeviceName, gBridgeDeviceNameSize, 0 );
        gBridgeDeviceName = NULL;
        gBridgeDeviceNameSize = 0L;
    }

    // Ditch our packet filter and multicast list
    gPacketFilter = 0L;

    if( gMulticastList != NULL )
    {
        SAFEASSERT( gMulticastListLength > 0L );
        NdisFreeMemory( gMulticastList, gMulticastListLength, 0 );
        gMulticastList = NULL;
        gMulticastListLength = 0L;
    }

    NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
}

NDIS_STATUS
BrdgMiniInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN PNDIS_MEDIUM     MediumArray,
    IN UINT             MediumArraySize,
    IN NDIS_HANDLE      MiniPortAdapterHandle,
    IN NDIS_HANDLE      WrapperConfigurationContext
    )
/*++

Routine Description:

    NDIS entry point called to initialize our virtual NIC following a call to
    NdisIMInitializeDeviceInstance

    Must run at PASSIVE_LEVEL since we call NdisMSetAttributesEx

Arguments:

    OpenErrorStatus                 Where to return the specific error code if an open fails
    SelectedMediumIndex             Where to specify which media we selected from MediumArray
    MediumArray                     A list of media types to choose from
    MediumArraySize                 Number of entries in MediumArray
    MiniPortAdapterHandle           The handle for our virtual NIC (we save this)
    WrapperConfigurationContext     Not used

Return Value:

    Status of the initialization. A result != NDIS_STATUS_SUCCESS fails the NIC initialization
    and the miniport is not exposed to upper-layer protocols

--*/
{
    UINT                i;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);
    DBGPRINT(MINI, ("BrdgMiniInitialize\n"));

    for( i = 0; i < MediumArraySize; i++ )
    {
        if( MediumArray[i] == NdisMedium802_3 ) // Ethernet
        {
            *SelectedMediumIndex = NdisMedium802_3;
            break;
        }
    }

    if( i == MediumArraySize )
    {
        // Log this error since it's fatal
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_ETHERNET_NOT_OFFERED, 0L, 0L, NULL, 0L, NULL );
        DBGPRINT(MINI, ("Ethernet not offered; failing\n"));
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    NdisMSetAttributesEx(   MiniPortAdapterHandle,
                            NULL,
                            0,                                      // CheckForHangTimeInSeconds
                            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT    |
                            NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                            NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                            NDIS_ATTRIBUTE_DESERIALIZE |
                            NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                            0);

    // Save the adapter handle for future use
    gMiniPortAdapterHandle = MiniPortAdapterHandle;

    // Allow people to acquire the miniport
    BrdgResetWaitRef( &gMiniPortAdapterRefcount );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
BrdgMiniReset(
    OUT PBOOLEAN        AddressingReset,
    IN NDIS_HANDLE      MiniportAdapterContext
    )
/*++

Routine Description:

    NDIS entry point called reset our miniport. We do nothing in response to this.

Arguments:

    AddressingReset             Whether NDIS needs to prod us some more by calling MiniportSetInformation
                                after we return to restore various pieces of state

    MiniportAdapterContext      Ignored

Return Value:

    Status of the reset

--*/
{
    DBGPRINT(MINI, ("BrdgMiniReset\n"));
    return NDIS_STATUS_SUCCESS;
}

VOID
BrdgMiniSendPackets(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN PPNDIS_PACKET    PacketArray,
    IN UINT             NumberOfPackets
    )
/*++

Routine Description:

    NDIS entry point called to send packets through our virtual NIC.

    We just call the forwarding logic code to handle each packet.

Arguments:

    MiniportAdapterContext      Ignored
    PacketArray                 Array of packet pointers to send
    NumberOfPacket              Like it says

Return Value:

    None

--*/
{
    UINT                i;
    NDIS_STATUS         Status;

    for (i = 0; i < NumberOfPackets; i++)
    {
        PNDIS_PACKET    pPacket = PacketArray[i];

        // Hand this packet to the forwarding engine for processing
        Status = BrdgFwdSendPacket( pPacket );

        if( Status != NDIS_STATUS_PENDING )
        {
            // The forwarding engine completed immediately

            // NDIS should prevent the miniport from being shut down
            // until we return from this function
            SAFEASSERT( gMiniPortAdapterHandle != NULL );
            NdisMSendComplete(gMiniPortAdapterHandle, pPacket, Status);
        }
        // else the forwarding engine will call NdisMSendComplete()
    }
}

NDIS_STATUS
BrdgMiniQueryInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesWritten,
    OUT PULONG          BytesNeeded
    )
/*++

Routine Description:

    NDIS entry point called to retrieve various pieces of info from our miniport

Arguments:

    MiniportAdapterContext      Ignored
    Oid                         The request code
    InformationBuffer           Place to return information
    InformationBufferLength     Size of InformationBuffer
    BytesWritten                Output of the number of written bytes
    BytesNeeded                 If the provided buffer is too small, this is how many we need.

Return Value:

    Status of the request

--*/
{
    // Macros for use in this function alone
    #define REQUIRE_AT_LEAST(n) \
        { \
            if(InformationBufferLength < (n)) \
            { \
                *BytesNeeded = (n); \
                return NDIS_STATUS_INVALID_LENGTH; \
            }\
        }

    #define RETURN_BYTES(p,n) \
        { \
            NdisMoveMemory( InformationBuffer, (p), (n) ); \
            *BytesWritten = (n); \
            return NDIS_STATUS_SUCCESS; \
        }

    switch( Oid )
    {
    // General characteristics
    case OID_GEN_SUPPORTED_LIST:
        {
            REQUIRE_AT_LEAST( sizeof(gSupportedOIDs) );
            RETURN_BYTES( gSupportedOIDs, sizeof(gSupportedOIDs));
        }
        break;

    case OID_GEN_HARDWARE_STATUS:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            *((ULONG*)InformationBuffer) = NdisHardwareStatusReady;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MEDIA_SUPPORTED:
    case OID_GEN_MEDIA_IN_USE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // We support Ethernet only
            *((ULONG*)InformationBuffer) = NdisMedium802_3;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_TRANSMIT_BUFFER_SPACE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Lie and claim to have 15K of send space, a common
            // Ethernet card value.
            // REVIEW: Is there a better value?
            *((ULONG*)InformationBuffer) = 15 * 1024;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_RECEIVE_BUFFER_SPACE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Lie and claim to have 150K of receive space, a common
            // Ethernet card value.
            // REVIEW: Is there a better value?
            *((ULONG*)InformationBuffer) = 150 * 1024;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MAXIMUM_SEND_PACKETS:
    case OID_802_3_MAXIMUM_LIST_SIZE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Return a generic large integer
            // REVIEW: Is there a better value to hand out?
            *((ULONG*)InformationBuffer) = 0x000000FF;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MAXIMUM_FRAME_SIZE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Ethernet payloads can be up to 1500 bytes
            *((ULONG*)InformationBuffer) = 1500L;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // We indicate full packets up to NDIS, so these values are the same and
    // equal to the maximum size of a packet
    case OID_GEN_MAXIMUM_LOOKAHEAD:
    case OID_GEN_CURRENT_LOOKAHEAD:

    // These are also just the maximum total size of a frame
    case OID_GEN_MAXIMUM_TOTAL_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
    case OID_GEN_TRANSMIT_BLOCK_SIZE:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // Ethernet frames with header can be up to 1514 bytes
            *((ULONG*)InformationBuffer) = 1514L;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MAC_OPTIONS:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // We have no internal loopback support
            *((ULONG*)InformationBuffer) = NDIS_MAC_OPTION_NO_LOOPBACK;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_LINK_SPEED:
        {
            LOCK_STATE          LockState;
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );
            *((ULONG*)InformationBuffer) = gBridgeLinkSpeed;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Ethernet characteristics
    case OID_802_3_PERMANENT_ADDRESS:
    case OID_802_3_CURRENT_ADDRESS:
        {
            SAFEASSERT( gHaveAddress );

            // Don't need a read lock because the address shouldn't change once set
            REQUIRE_AT_LEAST( sizeof(gBridgeAddress) );
            RETURN_BYTES( gBridgeAddress, sizeof(gBridgeAddress));
        }
        break;

    case OID_GEN_MEDIA_CONNECT_STATUS:
        {
            LOCK_STATE          LockState;
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );
            *((ULONG*)InformationBuffer) = gBridgeMediaState;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;


    case OID_GEN_VENDOR_ID:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // We don't have an IEEE-assigned ID so use this constant
            *((ULONG*)InformationBuffer) = 0xFFFFFF;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_VENDOR_DESCRIPTION:
        {
            UINT    len = (UINT)strlen( gDriverDescription ) + 1;
            REQUIRE_AT_LEAST( len );
            RETURN_BYTES( gDriverDescription, len);
        }
        break;

    case OID_GEN_VENDOR_DRIVER_VERSION:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );

            // We are version 1.0
            *((ULONG*)InformationBuffer) = 0x00010000;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DRIVER_VERSION:
        {
            REQUIRE_AT_LEAST( sizeof(USHORT) );

            // We are using version 5.0 of NDIS
            *((USHORT*)InformationBuffer) = 0x0500;
            *BytesWritten = sizeof(USHORT);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    //
    // General Statistics
    //
    case OID_GEN_XMIT_OK:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of local-sourced sent frames
            *((ULONG*)InformationBuffer) = gStatTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_XMIT_ERROR:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of local-sourced frames sent with errors
            *((ULONG*)InformationBuffer) = gStatTransmittedErrorFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_RCV_OK:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of indicated frames
            *((ULONG*)InformationBuffer) = gStatIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Answer the same for these two
    case OID_GEN_RCV_NO_BUFFER:
    case OID_GEN_RCV_ERROR:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatIndicatedDroppedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_BYTES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            *((ULONG*)InformationBuffer) = gStatDirectedTransmittedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_FRAMES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatDirectedTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_BYTES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastTransmittedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_FRAMES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_BYTES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastTransmittedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_FRAMES_XMIT:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastTransmittedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_BYTES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatDirectedIndicatedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_DIRECTED_FRAMES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatDirectedIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_BYTES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastIndicatedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_MULTICAST_FRAMES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatMulticastIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_BYTES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastIndicatedBytes.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_BROADCAST_FRAMES_RCV:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // Reply with the number of packets we wanted to indicate but couldn't
            *((ULONG*)InformationBuffer) = gStatBroadcastIndicatedFrames.LowPart;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Ethernet statistics
    case OID_802_3_RCV_ERROR_ALIGNMENT:
    case OID_802_3_XMIT_ONE_COLLISION:
    case OID_802_3_XMIT_MORE_COLLISIONS:
        {
            REQUIRE_AT_LEAST( sizeof(ULONG) );
            // We have no way of collecting this information sensibly from lower NICs, so
            // pretend these types of events never happen.
            *((ULONG*)InformationBuffer) = 0L;
            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_CURRENT_PACKET_FILTER:
        {
            LOCK_STATE          LockState;

            REQUIRE_AT_LEAST( sizeof(ULONG) );

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );
            *((ULONG*)InformationBuffer) = gPacketFilter;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            *BytesWritten = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_802_3_MULTICAST_LIST:
        {
            LOCK_STATE          LockState;

            NdisAcquireReadWriteLock( &gBridgeStateLock, FALSE /*Read only*/, &LockState );

            if(InformationBufferLength < gMulticastListLength)
            {
                *BytesNeeded = gMulticastListLength;
                NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );
                return NDIS_STATUS_INVALID_LENGTH;
            }

            NdisMoveMemory( InformationBuffer, gMulticastList, gMulticastListLength );
            *BytesWritten = gMulticastListLength;
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_PNP_QUERY_POWER:
        {
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_TCP_TASK_OFFLOAD:
        {
            // Mark that Tcp.ip has been loaded
            g_fIsTcpIpLoaded = TRUE;
            // Set the underlying 1394 miniport to ON
            BrdgSetMiniportsToBridgeMode(NULL,TRUE);
            return NDIS_STATUS_NOT_SUPPORTED;
        }
        break;
    }


    // We don't understand the OID
    return NDIS_STATUS_NOT_SUPPORTED;

#undef REQUIRE_AT_LEAST
#undef RETURN_BYTES
}

NDIS_STATUS
BrdgMiniSetInfo(
    IN NDIS_HANDLE      MiniportAdapterContext,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesRead,
    OUT PULONG          BytesNeeded
    )
/*++

Routine Description:

    NDIS entry point called to set various pieces of info to our miniport

Arguments:

    MiniportAdapterContext      Ignored
    Oid                         The request code
    InformationBuffer           Input information buffer
    InformationBufferLength     Size of InformationBuffer
    BytesRead                   Number of bytes read from InformationBuffer
    BytesNeeded                 If the provided buffer is too small, this is how many we need.

Return Value:

    Status of the request

--*/
{
    LOCK_STATE              LockState;
    NDIS_STATUS             Status;

    switch( Oid )
    {
    case OID_GEN_CURRENT_PACKET_FILTER:
        {
            SAFEASSERT( InformationBufferLength == sizeof(ULONG) );

            // Get write access to the packet filter
            NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE /*Read-Write*/, &LockState );
            gPacketFilter = *((ULONG*)InformationBuffer);
            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            DBGPRINT(MINI, ("Set the packet filter to %08x\n", gPacketFilter));
            *BytesRead = sizeof(ULONG);
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_802_3_MULTICAST_LIST:
        {
            PUCHAR              pOldList, pNewList;
            ULONG               oldListLength;

            // The incoming buffer should contain an integral number of Ethernet MAC
            // addresses
            SAFEASSERT( (InformationBufferLength % ETH_LENGTH_OF_ADDRESS) == 0 );

            DBGPRINT(MINI, ("Modifying the multicast list; now has %i entries\n",
                      InformationBufferLength / ETH_LENGTH_OF_ADDRESS));

            // Alloc and copy to the new multicast list
            if( InformationBufferLength > 0 )
            {
                Status = NdisAllocateMemoryWithTag( &pNewList, InformationBufferLength, 'gdrB' );

                if( Status != NDIS_STATUS_SUCCESS )
                {
                    DBGPRINT(MINI, ("NdisAllocateMemoryWithTag failed while recording multicast list\n"));
                    return NDIS_STATUS_NOT_ACCEPTED;
                }

                // Copy the list
                NdisMoveMemory( pNewList, InformationBuffer, InformationBufferLength );
            }
            else
            {
                pNewList = NULL;
            }

            // Swap in the new list
            NdisAcquireReadWriteLock( &gBridgeStateLock, TRUE /*Read-Write*/, &LockState );

            pOldList = gMulticastList;
            oldListLength = gMulticastListLength;

            gMulticastList = pNewList;
            gMulticastListLength = InformationBufferLength;

            NdisReleaseReadWriteLock( &gBridgeStateLock, &LockState );

            // Free the old multicast list if there was one
            if( pOldList != NULL )
            {
                NdisFreeMemory( pOldList, oldListLength, 0 );
            }

            *BytesRead = InformationBufferLength;
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:
    case OID_GEN_PROTOCOL_OPTIONS:
        {
            // We accept these but do nothing
            return NDIS_STATUS_SUCCESS;
        }
        break;

    // Overlying protocols telling us about their network addresses
    case OID_GEN_NETWORK_LAYER_ADDRESSES:
        {
            // Let the compatibility-mode code note the addresses
            BrdgCompNotifyNetworkAddresses( InformationBuffer, InformationBufferLength );
        }
        //
        // DELIBERATELY FALL THROUGH
        //

    // All relayed OIDs go here
    case OID_GEN_TRANSPORT_HEADER_OFFSET:
        {
            LOCK_STATE              LockState;
            PADAPT                  Adapters[MAX_ADAPTERS], pAdapt;
            LONG                    NumAdapters = 0L, i;
            PNDIS_REQUEST_BETTER    pRequest;
            NDIS_STATUS             Status, rc;

            // We read the entire request
            *BytesRead = InformationBufferLength;

            // Pass these straight through to underlying NICs
            NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

            // Make a list of the adapters to send the request to
            pAdapt = gAdapterList;

            while( pAdapt != NULL )
            {
                if( NumAdapters < MAX_ADAPTERS )
                {
                    Adapters[NumAdapters] = pAdapt;

                    // We will be using this adapter outside the list lock
                    BrdgAcquireAdapterInLock( pAdapt );
                    NumAdapters++;
                }
                else
                {
                    SAFEASSERT( FALSE );
                    DBGPRINT(MINI, ("Too many adapters to relay a SetInfo request to!\n"));
                }

                pAdapt = pAdapt->Next;
            }

            // The refcount is the number of requests we will make
            gRequestRefCount = NumAdapters;

            NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

            if( NumAdapters == 0 )
            {
                // Nothing to do!
                rc = NDIS_STATUS_SUCCESS;
            }
            else
            {
                // Request will pend unless all adapters return immediately
                rc = NDIS_STATUS_PENDING;

                for( i = 0L; i < NumAdapters; i++ )
                {
                    // Allocate memory for the request
                    Status = NdisAllocateMemoryWithTag( &pRequest, sizeof(NDIS_REQUEST_BETTER), 'gdrB' );

                    if( Status != NDIS_STATUS_SUCCESS )
                    {
                        LONG            NewCount = InterlockedDecrement( &gRequestRefCount );

                        DBGPRINT(MINI, ("NdisAllocateMemoryWithTag failed while relaying an OID\n"));

                        if( NewCount == 0 )
                        {
                            // This could only have happened with the last adapter
                            SAFEASSERT( i == NumAdapters - 1 );

                            // We're all done since everyone else has completed too
                            rc = NDIS_STATUS_SUCCESS;
                        }

                        // Let go of the adapter
                        BrdgReleaseAdapter( Adapters[i] );
                        continue;
                    }

                    // Set up the request as a mirror of ours
                    pRequest->Request.RequestType = NdisRequestSetInformation;
                    pRequest->Request.DATA.SET_INFORMATION.Oid = Oid ;
                    pRequest->Request.DATA.SET_INFORMATION.InformationBuffer = InformationBuffer;
                    pRequest->Request.DATA.SET_INFORMATION.InformationBufferLength = InformationBufferLength;
                    NdisInitializeEvent( &pRequest->Event );
                    NdisResetEvent( &pRequest->Event );
                    pRequest->pFunc = BrdgMiniRelayedRequestComplete;
                    pRequest->FuncArg = NULL;

                    // Fire it off
                    NdisRequest( &Status, Adapters[i]->BindingHandle, &pRequest->Request );

                    // Let go of the adapter; NDIS should not permit it to be unbound while
                    // a request is in progress
                    BrdgReleaseAdapter( Adapters[i] );

                    if( Status != NDIS_STATUS_PENDING )
                    {
                        // The cleanup function won't get called
                        BrdgMiniRelayedRequestComplete( pRequest, NULL );
                    }
                }
            }

            //
            // Paranoia for future maintainance: can't refer to pointer parameters
            // at this point, as the relayed requests may have completed already, making
            // them stale.
            //
            InformationBuffer = NULL;
            BytesRead = NULL;
            BytesNeeded = NULL;

            return rc;
        }
        break;

    case OID_PNP_SET_POWER:
        {
            return NDIS_STATUS_SUCCESS;
        }
        break;
    }

    return NDIS_STATUS_NOT_SUPPORTED;
}

VOID
BrdgMiniRelayedRequestComplete(
    PNDIS_REQUEST_BETTER        pRequest,
    PVOID                       unused
    )
/*++

Routine Description:

    Called when a SetInformation request that we relayed completes.

Arguments:

    pRequest                    The NDIS_REQUEST_BETTER structure we allocated
                                in BrdgMiniSetInformation().

    unused                      Unused

Return Value:

    Status of the request

--*/
{
    LONG        NewCount = InterlockedDecrement( &gRequestRefCount );

    if( NewCount == 0 )
    {
        // NDIS Should not permit the miniport to shut down with a request
        // in progress
        SAFEASSERT( gMiniPortAdapterHandle != NULL );

        // The operation always succeeds
        NdisMSetInformationComplete( gMiniPortAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    // Free the request structure since we allocated it ourselves
    NdisFreeMemory( pRequest, sizeof(PNDIS_REQUEST_BETTER), 0 );
}




VOID
BrdgMiniLocalRequestComplete(
    PNDIS_REQUEST_BETTER        pRequest,
    PVOID                       pContext
    )
/*++

Routine Description:

    Called when bridge allocated request completes.

Arguments:

    pRequest    The NDIS_REQUEST_BETTER structure we allocated
                in BrdgSetMiniportsToBridgeMode.
    Context     pAdapt structure

Return Value:

    Status of the request

--*/
{
    PADAPT pAdapt = (PADAPT)pContext;

    // Let go of the adapter;
    BrdgReleaseAdapter( pAdapt);

    // Free the request structure since we allocated it ourselves
    NdisFreeMemory( pRequest, sizeof(PNDIS_REQUEST_BETTER), 0 );
}

VOID
BrdgSetMiniportsToBridgeMode(
    PADAPT pAdapt,
    BOOLEAN fSet
    )
/*++

Routine Description:

    Sends a 1394 specific OID to the miniport informing it that TCP/IP
    has been activated

Arguments:

    pAdapt -    If adapt is not NULL, send Request to this adapt.
                Otherwise send it to all of them.
    fSet -      if True, then set Bridge Mode ON, otherwise set it OFF

Return Value:

    Status of the request

--*/
{

    LOCK_STATE              LockState;
    PADAPT                  Adapters[MAX_ADAPTERS];
    LONG                    NumAdapters = 0L, i;
    NDIS_OID                Oid;

    if (pAdapt != NULL)
    {
        if (pAdapt->PhysicalMedium == NdisPhysicalMedium1394)
        {
            // We have a 1394 adapt, ref it and send the request to it
            if (BrdgAcquireAdapter (pAdapt))
            {
                Adapters[0] = pAdapt;
                NumAdapters = 1;
            }
        }
    }
    else
    {
        // walk through the list and Acquire all the 1394 adapts
        NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*Read only*/, &LockState );

        // Make a list of the adapters to send the request to
        pAdapt = gAdapterList;

        while( pAdapt != NULL )
        {
            if( NumAdapters < MAX_ADAPTERS && pAdapt->PhysicalMedium == NdisPhysicalMedium1394)
            {
                Adapters[NumAdapters] = pAdapt;

                // We will be using this adapter outside the list lock
                BrdgAcquireAdapterInLock( pAdapt ); // cannot fail
                NumAdapters++;
            }
            pAdapt = pAdapt->Next;
        }

        NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
    }

    if (NumAdapters == 0)
    {
        return;
    }

    if (fSet == TRUE)
    {
        Oid = OID_1394_ENTER_BRIDGE_MODE ;
        DBGPRINT(MINI, ("Setting 1394 miniport bridge mode - ON !\n"));
    }
    else
    {
        Oid = OID_1394_EXIT_BRIDGE_MODE ;
        DBGPRINT(MINI, ("Setting 1394 miniport bridge mode - OFF !\n"));
    }

    for( i = 0L; i < NumAdapters; i++ )
    {
        NDIS_STATUS Status;
        PNDIS_REQUEST_BETTER pRequest;

        Status = NdisAllocateMemoryWithTag( &pRequest, sizeof(NDIS_REQUEST_BETTER), 'gdrB' );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(MINI, ("NdisAllocateMemoryWithTag failed while allocating a request structure \n"));

            // Let go of the adapter
            BrdgReleaseAdapter( Adapters[i] );
            continue;
        }

        // Set up the request
        pRequest->Request.RequestType = NdisRequestSetInformation;
        pRequest->Request.DATA.SET_INFORMATION.Oid = Oid;
        pRequest->Request.DATA.SET_INFORMATION.InformationBuffer = NULL;
        pRequest->Request.DATA.SET_INFORMATION.InformationBufferLength = 0 ;
        NdisInitializeEvent( &pRequest->Event );
        NdisResetEvent( &pRequest->Event );
        pRequest->pFunc = BrdgMiniLocalRequestComplete;
        pRequest->FuncArg = Adapters[i];

        // Fire it off
        NdisRequest( &Status, Adapters[i]->BindingHandle, &pRequest->Request );

        if( Status != NDIS_STATUS_PENDING )
        {
            // The cleanup function won't get called
            BrdgMiniLocalRequestComplete( pRequest, Adapters[i] );
        }

    } // end of for loop

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdggpo.c ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdggpo.c

Abstract:

    Ethernet MAC level bridge.
    Group Policy code for Network Bridge.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    April  2002 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <tdikrnl.h>
#include <ntstatus.h>
#include <wchar.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdggpo.h"

#include "brdgsta.h"
#include "brdgmini.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgctl.h"
#include "brdgtdi.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

BRDG_GPO_GLOBALS g_BrdgGpoGlobals;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

const WCHAR HiveListKey[]           = {L"\\Registry\\Machine\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\HIVELIST"};
const WCHAR SoftwareHiveKey[]       = {L"\\REGISTRY\\MACHINE\\SOFTWARE"};
const WCHAR PolicyBaseKey[]         = {L"\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\Windows"};
const WCHAR NetworkPoliciesKey[]    = {L"\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\Windows\\Network Connections"};
const WCHAR GroupPolicyKey[]        = {L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy"};
const WCHAR BridgePolicyValue[]     = {L"NC_AllowNetBridge_NLA"};
const WCHAR TcpipInterfacesKey[]    = {L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"};
const WCHAR HistoryKey[]            = {L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"};

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
static
BrdgGpoRegNotify(
    IN  PVOID               Context
    );

NTSTATUS
BrdgGpoBuildNotifyForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify,
    IN LPWSTR                   Identifier,
    IN LPWSTR                   RegKeyName,
    IN LPWSTR                   RegValueName,
    IN PWORKER_THREAD_ROUTINE   ApcRoutine,
    IN PVOID                    ApcContext,
    IN ULONG                    CompletionFilter,
    IN BOOLEAN                  WatchTree,
    IN PBRDG_GPO_REG_CALLBACK   FunctionCallback,
    IN BOOLEAN                  Recurring,
    IN PBOOLEAN                 SuccessfulRegistration,
    IN PBRDG_GPO_REGISTER       FunctionRegister);
                                  
NTSTATUS
BrdgGpoRegisterForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify);

NTSTATUS
BrdgGpoRequestNotification(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoProcessNotifications(
IN PVOID                Context);

PLIST_ENTRY
BrdgGpoGetNotifyListHead();

PKEVENT
BrdgGpoGetNotifyEvent();

PKEVENT
BrdgGpoGetKillEvent();

PNDIS_RW_LOCK
BrdgGpoGetNotifyListLock();

NTSTATUS
BrdgGpoFindNotify(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_RW_LOCK           ListLock,
    IN  LPWSTR                  Identifier,
    OUT PBRDG_GPO_NOTIFY_KEY*   Notify
    );

NTSTATUS
BrdgGpoInitializeNotifyList(
    OUT PLIST_ENTRY*    ListHead,
    OUT PNDIS_RW_LOCK*  ListLock,
    OUT PKEVENT*        WaitEvent,
    OUT PKEVENT*        KillEvent);

VOID
BrdgGpoFreeNotifyList();

BOOLEAN
BrdgGpoAllowedToBridge();

VOID
BrdgGpoUpdateBridgeMode(
    BOOLEAN NetworkMatch);

VOID
BrdgGpoCheckForMatchAndUpdateMode();

NTSTATUS
BrdgGpoRegisterForGroupPolicyNetworkNameNotification();

NTSTATUS
BrdgGpoRegisterForWindowsGroupPolicyNotification();

NTSTATUS
BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();

NTSTATUS
BrdgGpoRegisterForGroupPolicyNotification();

VOID
BrdgGpoRegisterForHiveListNotification();

NTSTATUS
BrdgGpoAllocateAndInitializeNotifyStruct(
    OUT PBRDG_GPO_NOTIFY_KEY* Notify);

NTSTATUS 
BrdgGpoUpdateGroupPolicyNetworkName();

VOID
BrdgGpoFreeNotifyStructAndData(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

BOOLEAN
BrdgGpoWaitingOnSoftwareHive();
                                
//
// We need this if the regkey for Network Connections Group Policy doesn't exist yet.
//

VOID
BrdgGpoWindowsGroupPolicyChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoNetworkConnectionsGroupPolicyChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoGroupPolicyChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoTcpipInterfacesChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoGroupPolicyNetworkNameChangeCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoHiveListCallback(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoQueryNetworkConnectionsValue(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoQueryTcpipInterfacesValues(
    IN PBRDG_GPO_NOTIFY_KEY Notify);

VOID
BrdgGpoQueryGroupPolicyNetworkName(
    IN PBRDG_GPO_NOTIFY_KEY Notify);


// ===========================================================================
//
// BRIDGE GPO IMPLEMENTATION
//
// ===========================================================================

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGELK, BrdgGpoRegNotify) 
#endif 

NTSTATUS
BrdgGpoDriverInit()
/*++

Routine Description:

    Driver load-time initialization

Return Value:

    Status of initialization

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS            status;
    HANDLE              ThreadHandle;

    DBGPRINT(GPO, ("BrdgGpoDriverInit\r\n"));

    g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer = NULL;

    status = BrdgGpoInitializeNetworkList();

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to initialize Network List\r\n"));
        goto cleanup;
    }

    status = BrdgGpoInitializeNotifyList(   &g_BrdgGpoGlobals.QueueInfo.NotifyList,
                                            &g_BrdgGpoGlobals.QueueInfo.NotifyListLock,
                                            &g_BrdgGpoGlobals.QueueInfo.NotifyEvent,
                                            &g_BrdgGpoGlobals.QueueInfo.KillEvent);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to initialize Notify List\r\n"));
        goto cleanup;
    }
    
    //
    // Since the Software hive is not up at this point, we use this to make sure we only register for
    // Group Policy changes once (we'll handle this in the Add Address notification, since the software
    // hive is up by the time this gets called.  Will check with reg guys to see if there's a way to know
    // when the software hive is up.  We'll use the timer to re-attempt the registration until it is up.
    //
    
    g_BrdgGpoGlobals.NotificationsThread = NULL;
    g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges = FALSE;
    g_BrdgGpoGlobals.WaitingOnSoftwareHive = TRUE;

    // Create a thread for handling the notifications.
    status = PsCreateSystemThread(  &ThreadHandle,
                                    THREAD_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    BrdgGpoProcessNotifications,
                                    &g_BrdgGpoGlobals.QueueInfo);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to created Notification Processing thread\r\n"));
        goto cleanup;
    }
    
    // Retrieve a pointer to the thread object and reference it so we can wait for
    // its termination safely.
    status = ObReferenceObjectByHandle( ThreadHandle, STANDARD_RIGHTS_ALL, NULL, KernelMode,
                                        &g_BrdgGpoGlobals.NotificationsThread, NULL );

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to reference thread handle\r\n"));
        goto cleanup;
    }
    
cleanup:

    if (!NT_SUCCESS(status))
    {
        BrdgGpoCleanup();
    }
 
    return status;
}

VOID
BrdgGpoCleanup()
/*++

Routine Description:

    Driver shutdown cleanup

Return Value:

    None

Locking Constraints:

Top-level function. Assumes no locks are held by caller.
            
--*/
{
    NTSTATUS                status;
    PNPAGED_LOOKASIDE_LIST  LookasideQueueList;
    LOCK_STATE              LockState;
    PLIST_ENTRY             pListEntry;
    PNDIS_RW_LOCK           ListLock;
    PLIST_ENTRY             ListHead;
    PLIST_ENTRY             QueuedList;
    PBRDG_GPO_QUEUED_NOTIFY QueuedNotify;

    DBGPRINT(GPO, ("BrdgGpoCleanup\r\n"));

    g_BrdgGpoGlobals.ProcessingNotifications = FALSE;
    
    LookasideQueueList = ExAllocatePoolWithTag(NonPagedPool, sizeof(NPAGED_LOOKASIDE_LIST), 'gdrB');
    if (NULL == LookasideQueueList)
    {
        return;
    }

    QueuedList = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (NULL == QueuedList)
    {
        ExFreePool(LookasideQueueList);
        return;
    }

    ListHead = BrdgGpoGetNotifyListHead();
    ListLock = BrdgGpoGetNotifyListLock();

    ExInitializeNPagedLookasideList(LookasideQueueList, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    sizeof(BRDG_GPO_QUEUED_NOTIFY), 
                                    'grbQ',
                                    0);

    InitializeListHead(QueuedList);

    DBGPRINT(GPO, ("Acquiring Read-Write Lock and clearing list\r\n"));
    //
    // We use a temporary list to close each key, since we can't close them at
    // DISPATCH_LEVEL
    //
    NdisAcquireReadWriteLock(ListLock, TRUE /* Write-access */, &LockState);

    //
    // Loop through the list of notifications that we have.
    //
    for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NOTIFY_KEY    Notify;

        Notify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);

        //
        // We're going to be shutting this down soon, so block it now
        // so that no-one else can increment this.
        //
        BrdgBlockWaitRef(&Notify->RefCount);

        //
        // We don't want any notifications the fire to run either.
        //
        Notify->Recurring = FALSE;

        QueuedNotify = ExAllocateFromNPagedLookasideList(LookasideQueueList);
        QueuedNotify->Notify = Notify;

        InsertTailList(QueuedList, &QueuedNotify->ListEntry);
    }
    
    while (!IsListEmpty(ListHead))
    {
        //
        // We'll be freeing this from our sencondary list.
        //
        pListEntry = RemoveHeadList(ListHead);
    }

    NdisReleaseReadWriteLock(ListLock, &LockState);

    DBGPRINT(GPO, ("Closing and Freeing Notifications\r\n"));
    
    //
    // We're back at PASSIVE_LEVEL so we can now do the registration for the changes.
    //
    
    for (pListEntry = QueuedList->Flink; pListEntry != QueuedList; pListEntry = pListEntry->Flink)
    {
        HANDLE                  hKey;
        PBRDG_GPO_NOTIFY_KEY    Notify;

        QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);
        
        Notify = QueuedNotify->Notify;
        
        DBGPRINT(GPO, ("Closing Regkey and Freeing Notification: %S\r\n", Notify->Identifier.Buffer));
        
        hKey = Notify->RegKey;
        Notify->RegKey = NULL;

        if (hKey)
        {
            ZwClose(hKey);
        }
        
        DBGPRINT(GPO, ("Refcount for %S \t-\t %d\r\n", Notify->Identifier.Buffer, Notify->RefCount.Refcount));

        //
        // Since we're freeing this notification, we decrement the refcount
        //
        BrdgDecrementWaitRef(&Notify->RefCount);
        
        //
        // This will block until the ref count is zero.  Any attempts to increment the waitref will
        // fail.
        //
        BrdgShutdownWaitRef(&Notify->RefCount);

        //
        // We NULL these out so that the free routine below doesn't try to remove us from
        // the notify list.
        //
        QueuedNotify->Notify->ListEntry.Blink = NULL;
        QueuedNotify->Notify->ListEntry.Flink = NULL;
        
        //
        // Free the data associated with this struct, and the struct itself.
        //
        BrdgGpoFreeNotifyStructAndData(QueuedNotify->Notify);
    }

    //
    // Free the temporary list.
    //
    while (!IsListEmpty(QueuedList))
    {
        pListEntry = RemoveHeadList(QueuedList);

        QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);

        ExFreeToNPagedLookasideList(LookasideQueueList, QueuedNotify);
    }

    if (g_BrdgGpoGlobals.NotificationsThread)
    {
        //
        // Set the Event to kill the thread so that the notifications are no longer waiting.
        //
        KeSetEvent(BrdgGpoGetKillEvent(), EVENT_INCREMENT, TRUE);
        status = KeWaitForSingleObject(g_BrdgGpoGlobals.NotificationsThread, Executive, KernelMode, TRUE, NULL);

        KeLowerIrql(0);

        //
        // De-reference the thread handle to allow the thread to be destroyed.
        //
        ObDereferenceObject(g_BrdgGpoGlobals.NotificationsThread);

        SAFEASSERT(NT_SUCCESS(status));
    }


    DBGPRINT(GPO, ("Freeing List structures\r\n"));

    ExDeleteNPagedLookasideList(LookasideQueueList);

    ExFreePool(LookasideQueueList);
    ExFreePool(QueuedList);

    //
    // Free any remaining data.
    //
    if (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer)
    {
        ExFreePool(g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer);
    }

    status = BrdgGpoEmptyNetworkList(g_BrdgGpoGlobals.ListHeadNetworks, g_BrdgGpoGlobals.NetworkListLock);
    SAFEASSERT(NT_SUCCESS(status));

    if (g_BrdgGpoGlobals.ListHeadNetworks)
    {
        ExFreePool(g_BrdgGpoGlobals.ListHeadNetworks);
    }
    if (g_BrdgGpoGlobals.NetworkListLock)
    {
        ExFreePool(g_BrdgGpoGlobals.NetworkListLock);
    }

    BrdgGpoFreeNotifyList();

    DBGPRINT(GPO, ("BrdgGpoCleanup complete\r\n"));
}

BOOLEAN
BrdgGpoWaitingOnSoftwareHive()
{
    return g_BrdgGpoGlobals.WaitingOnSoftwareHive;
}

NTSTATUS
BrdgGpoRegisterForAdapterAddressChangeNotification(
    IN  LPWSTR                  NetworkIdentifier,
    IN  LPWSTR                  RegKeyName)
{
    NTSTATUS                status;
    PBRDG_GPO_NOTIFY_KEY    Notify;

    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                NetworkIdentifier,
                                &Notify);
    
    if (NT_SUCCESS(status) && (STATUS_OBJECT_NAME_EXISTS != status))
    {
        UNICODE_STRING      RegKey;

        RtlInitUnicodeString(&RegKey, RegKeyName);

        if ((STATUS_OBJECT_NAME_EXISTS != status) && NT_SUCCESS(status))
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);

            if (NT_SUCCESS(status))
            {
                Notify->Recurring = TRUE;

                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            NetworkIdentifier,
                                                            RegKeyName,
                                                            L"DhcpDomain",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_LAST_SET,
                                                            FALSE,
                                                            BrdgGpoTcpipInterfacesChangeCallback,
                                                            TRUE,
                                                            NULL,
                                                            NULL);

            }
        }
    }

    if (NT_SUCCESS(status))
    {
        SAFEASSERT(Notify);
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }        
#if DBG
        if (Notify)
        {
            SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
        }
#endif
    }

    return status;
}

NTSTATUS
BrdgGpoNewAddressNotification(
    IN PWSTR    DeviceId
    )
/*++

Routine Description:

    Called when a our TDI AddAddress handler receives a new IP Address.

Arguments:
    DeviceID - GUID Identifying the adapter

Return Value:

    NTSTATUS - Possible values include:
                STATUS_INSUFFICIENT_RESOURCES (not enough memory)
                STATUS_SUCCESS
                

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;

    DBGPRINT(GPO, ("BrdgGpoNewAddressNotification\r\n"));
    
    if (FALSE == g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges)
    {
        BrdgGpoRegisterForHiveListNotification();
        BrdgGpoRegisterForGroupPolicyNotification();
        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
        BrdgGpoRegisterForWindowsGroupPolicyNotification();
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();

        g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges = TRUE;        
    }

    DBGPRINT(GPO, ("Device: %S\r\n", DeviceId));

    if (NULL != DeviceId)
    {
        PBRDG_GPO_NETWORKS  Network = NULL;
        UNICODE_STRING      RegKey;
        PWCHAR              NetworkIdentifier = NULL;
        PWCHAR              RegNetworkName = NULL;
        PWCHAR              NetworkName = NULL;
        ULONG               NetworkNameLen = 0;
        PWCHAR              RegString = NULL;

        status = ( NdisAllocateMemoryWithTag( &RegString,
                                            ((UINT)wcslen(TcpipInterfacesKey) + 1 + (UINT)wcslen(DeviceId) + 1) * sizeof(WCHAR), 
                                            'gdrB'));
        if (NT_SUCCESS(status))
        {
            wcscpy(RegString, TcpipInterfacesKey);
            wcscat(RegString, L"\\");
            wcsncat(RegString, DeviceId, MAX_GUID_LEN - 1);

            NetworkIdentifier = DeviceId;

            RtlInitUnicodeString(&RegKey, RegString);
        
            status = BrdgReadRegUnicode(&RegKey,
                                        L"DhcpDomain",
                                        &RegNetworkName,
                                        &NetworkNameLen);
        
            if (!NT_SUCCESS(status) || (0 == NetworkNameLen))
            {
                //  
                // Either we didn't get a network name back, or the name is blank.
                // in both cases we go to the ipaddress and subnetmask to determine
                // the network that we're on.
                // We AND the two together to get this.
                // For example: Address: 10.251.1.3 Subnet: 255.0.0.0 gives us a 
                // network of: 10.0.0.0
                //
                status = BrdgGpoGetCurrentNetwork(&RegKey, &RegNetworkName);
            }

            if (NT_SUCCESS(status))
            {
                ULONG NetworkNameByteLen =(ULONG) ((wcslen(RegNetworkName) + 1) * sizeof(WCHAR));

                //
                // Copy the network name from the reg into a NonPagedPool string 
                // (since it will be accessed at DISPATCH_LEVEL)
                //

                NetworkName = ExAllocatePoolWithTag(NonPagedPool, NetworkNameByteLen, 'gdrB');
                if(NetworkName)
                {
                    RtlZeroMemory(NetworkName, NetworkNameByteLen);
                    RtlCopyMemory(NetworkName, RegNetworkName, NetworkNameByteLen);
                }

                //
                // Check if we match the current GP network.
                //
                if ((0 != g_BrdgGpoGlobals.GroupPolicyNetworkName.Length) &&
                    (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer))
                {
                    if(_wcsicmp(g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer, NetworkName) == 0)
                    {
                        //
                        // We do match the network.
                        //
                        BrdgGpoUpdateBridgeMode(BRDG_ON_SAME_NETWORK);
                    }
                    else
                    {
                        //
                        // No, we're not, so look at other adapters
                        //
                        BrdgGpoCheckForMatchAndUpdateMode();
                    }                        
                }
                else
                {
                    //
                    // We don't have a Group Policy network.
                    //
                    BrdgGpoUpdateBridgeMode(BRDG_ON_DIFFERENT_NETWORK);
                }

                status = BrdgGpoAllocateAndInitializeNetwork(   &Network,
                                                                NetworkIdentifier,
                                                                RegNetworkName);

                if (NT_SUCCESS(status))
                {
                    //
                    // We first try to insert the Network into the list
                    //
                    status = BrdgGpoInsertNetwork(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                    &Network->ListEntry,
                                                    g_BrdgGpoGlobals.NetworkListLock);

                    if (STATUS_DUPLICATE_NAME == status)
                    {
                        UNICODE_STRING Identifier;

                        //
                        // This Network already exists in the list, so we free it update the
                        // NetworkName in the existing entry.
                        //

                        BrdgGpoFreeNetworkAndData(Network);
                        Network = NULL;

                        RtlInitUnicodeString(&Identifier, NetworkIdentifier);
                        status = BrdgGpoUpdateNetworkName(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                            &Identifier,
                                                            NetworkName,
                                                            g_BrdgGpoGlobals.NetworkListLock);
                    }
                    else if (!NT_SUCCESS(status))
                    {
                        BrdgGpoFreeNetworkAndData(Network);
                        Network = NULL;
                    }
                }

                //
                // We've made a copy of this, so let's free it.
                //
                NdisFreeMemory(RegNetworkName, NetworkNameLen, 0);
            }
            
            if (NetworkName)
            {
                ExFreePool(NetworkName);
            }

            if (NT_SUCCESS(status))
            {
                status = BrdgGpoRegisterForAdapterAddressChangeNotification(NetworkIdentifier,
                                                                            RegString);
            }

#if DBG
            if (Network)
            {
                SAFEASSERT(Network->ListEntry.Blink && Network->ListEntry.Flink);
            }
#endif
            NdisFreeMemory(RegString, (UINT)wcslen(RegString) + 1, 0);
        }
    }
    
    return status;
}

// ===========================================================================
//
// REGISTRY CHANGE NOTIFICATION FUNCTIONS
//
// ===========================================================================

__forceinline
PLIST_ENTRY
BrdgGpoGetNotifyListHead()
/*++

Routine Description:

    
Arguments:

    None.

Return Value:

    Returns a pointer to the head of the Notifications List.

--*/
{
    return g_BrdgGpoGlobals.QueueInfo.NotifyList;
}

__forceinline
PKEVENT
BrdgGpoGetNotifyEvent()
/*++

Routine Description:

    
Arguments:

    None.

Return Value:

    Returns a pointer to the Event used for signaling the Processing 
    Thread to start processing notification requests.

--*/
{
    return g_BrdgGpoGlobals.QueueInfo.NotifyEvent;
}

__forceinline
PKEVENT
BrdgGpoGetKillEvent()
/*++

Routine Description:
    
Arguments:


Return Value:

  Returns a pointer to the Event used for signaling the Processing 
  Thread to exit.
  
--*/
{
    return g_BrdgGpoGlobals.QueueInfo.KillEvent;
}

__forceinline
PNDIS_RW_LOCK
BrdgGpoGetNotifyListLock()
/*++

Routine Description:
    
Arguments:


Return Value:

    Returns a pointer to the Read-Write lock that protects the 
    notification request list.

--*/
{
    return g_BrdgGpoGlobals.QueueInfo.NotifyListLock;
}

__forceinline
BOOLEAN
BrdgGpoProcessingNotifications()
/*++

Routine Description:
    
Arguments:


Return Value:

    TRUE    -   We're still processing Notifications (ie. we're not shutting down).
    FALSE   -   We're shutting down, don't add anything else to the list.

--*/
{
    return g_BrdgGpoGlobals.ProcessingNotifications;
}

NTSTATUS
BrdgGpoFindNotify(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_RW_LOCK           ListLock,
    IN  LPWSTR                  Identifier,
    OUT PBRDG_GPO_NOTIFY_KEY*   Notify
                  )
/*++

Routine Description:

    Since we don't want to have duplicate Notifications in the list, 
    this function is used to find an existing item if has already been added.
  
Arguments:

    ListHead    -   Pointer to the head of a Notifications list.

    ListLock    -   Read-Write lock for protecting the list.

    Identifier  -   A unique identifier associated with the item.  For NICs this is the
                    GUID assigned to the NIC.  For other items like the Group Policies, 
                    it is just a name we assign for example: "GroupPolicyNetworkName".
    Notify      -   An out param the contains either a pointer to the Notify we found,
                    or NULL if we didn't find a matching entry.

Return Value:

    STATUS_SUCCESS              We didn't find a matching entry.
    STATUS_OBJECT_NAME_EXISTS   We found a match, so we'll use that instead 
                                of allocating a new item.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    LOCK_STATE      LockState;
    PLIST_ENTRY     pListEntry;

    if (NULL != Notify)
    {
        *Notify = NULL;
    }

    if (NULL == ListHead ||
        NULL == ListLock ||
        NULL == Identifier ||
        NULL == Notify
        )
    {
        return STATUS_INVALID_PARAMETER;
    }

    BrdgGpoAcquireNetworkListLock(ListLock, FALSE /* Read */, &LockState);
    
    for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NOTIFY_KEY    CurrentNotify;
        
        CurrentNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);
        if ((CurrentNotify->Identifier.Buffer) &&
            (0 == _wcsicmp(CurrentNotify->Identifier.Buffer, Identifier)))
        {
            *Notify = CurrentNotify;
            status = STATUS_OBJECT_NAME_EXISTS;
            break;
        }
    }
    
    BrdgGpoReleaseNetworkListLock(ListLock, &LockState);
    
    return status;
}

NTSTATUS
BrdgGpoInitializeNotifyList(
    OUT PLIST_ENTRY*    ListHead,
    OUT PNDIS_RW_LOCK*  ListLock,
    OUT PKEVENT*        WaitEvent,
    OUT PKEVENT*        KillEvent)
/*++

Routine Description:
    
      Initializes the Notifications List and associated objects.

Arguments:

    ListHead    -   [OUT] Pointer to the list head that we'll allocate.

    ListLock    -   [OUT] Pointer to the Read-Write lock that we'll allocate.

    WaitEvent   -   [OUT] Pointer to the WaitEvent we'll allocate

    KillEvent   -   [OUT] Pointer to the KillEvent we'll allocate

Return Value:

    STATUS_INSUFFICIENT_RESOURCES   (unable to allocate everything).
    STATUS_INVALID_PARAMETER        (we were passed a NULL pointer to a pointer).
    STATUS_SUCCESS                  (we were able to allocate everything successfully).

--*/
{
    NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
    PLIST_ENTRY     pListHead;
    PNDIS_RW_LOCK   pListLock;
    PKEVENT         pWaitEvent;
    PKEVENT         pKillEvent;

    if (NULL == ListHead || 
        NULL == ListLock ||
        NULL == WaitEvent ||
        NULL == KillEvent)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *ListHead = NULL;
    *ListLock = NULL;
    *WaitEvent = NULL;
    *KillEvent = NULL;
    pListHead = NULL;
    pListLock = NULL;
    pWaitEvent = NULL;
    pKillEvent = NULL;
    
    pListHead = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (pListHead)
    {
        InitializeListHead(pListHead);
        pListLock = ExAllocatePoolWithTag(NonPagedPool, sizeof(NDIS_RW_LOCK), 'gdrB');
        if (pListLock)
        {
            NdisInitializeReadWriteLock(pListLock);

            pWaitEvent = ExAllocatePoolWithTag(NonPagedPool, sizeof(KEVENT), 'gdrB');

            if (pWaitEvent)
            {
                KeInitializeEvent(pWaitEvent, SynchronizationEvent, FALSE);

                pKillEvent = ExAllocatePoolWithTag(NonPagedPool, sizeof(KEVENT), 'gdrB');
                if (pKillEvent)
                {
                    KeInitializeEvent(pKillEvent, SynchronizationEvent, FALSE);

                    *ListHead = pListHead;
                    *ListLock = pListLock;
                    *WaitEvent = pWaitEvent;
                    *KillEvent = pKillEvent;
                    g_BrdgGpoGlobals.ProcessingNotifications = TRUE;

                    status = STATUS_SUCCESS;
                }
            }
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (pListHead)
        {
            ExFreePool(pListHead);
        }
        if (pListLock)
        {
            ExFreePool(pListLock);
        }
        if (pWaitEvent)
        {
            ExFreePool(pWaitEvent);
        }
        if (pKillEvent)
        {
            ExFreePool(pKillEvent);
        }
        
    }

    return status;
}

VOID
BrdgGpoFreeNotifyList()
/*++

Routine Description:

    Frees the notify list and all it's associated entries.

Arguments:

    None.
                          
Return Value:

    None.

--*/
{
    if (g_BrdgGpoGlobals.QueueInfo.NotifyList)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.NotifyList);
        g_BrdgGpoGlobals.QueueInfo.NotifyList = NULL;
    }
    if (g_BrdgGpoGlobals.QueueInfo.NotifyListLock)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.NotifyListLock);
        g_BrdgGpoGlobals.QueueInfo.NotifyListLock = NULL;
    }
    if (g_BrdgGpoGlobals.QueueInfo.NotifyEvent)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.NotifyEvent);
        g_BrdgGpoGlobals.QueueInfo.NotifyEvent = NULL;
    }
    if (g_BrdgGpoGlobals.QueueInfo.KillEvent)
    {
        ExFreePool(g_BrdgGpoGlobals.QueueInfo.KillEvent);
        g_BrdgGpoGlobals.QueueInfo.KillEvent = NULL;
    }
}

NTSTATUS
BrdgGpoRequestNotification(
    IN PBRDG_GPO_NOTIFY_KEY Notify)
/*++

Routine Description:

    Adds the Notification request to the list and signals the processing thread
    to re-check the list and register for any outstanding notifications.

Arguments:

    Notify  -   Notify struct that contains all the information necessary to register 
                for registry key changes.
                          
Return Value:

    STATUS_SHUTDOWN_IN_PROGRESS -   We're no longer processing notifications as we're 
                                    shutting down.
    STATUS_UNSUCCESSFUL         -   We were unable to get a valid list or lock.

    STATUS_SUCCESS              -   We successfully notified the processing thread to 
                                    request notification on this item.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PLIST_ENTRY     ListHead;
    PNDIS_RW_LOCK   ListLock;
    LOCK_STATE      LockState;
    PLIST_ENTRY     pListEntry;
    PKEVENT         WaitEvent;
    BOOLEAN         NewEntry = TRUE;
    BOOLEAN         ShuttingDown = FALSE;

    ListLock = BrdgGpoGetNotifyListLock();
    ListHead = BrdgGpoGetNotifyListHead();

    if (NULL == ListLock || NULL == ListHead)
    {
        return STATUS_UNSUCCESSFUL;
    }

    NdisAcquireReadWriteLock(ListLock, TRUE /* Write */, &LockState);

    ShuttingDown = !BrdgGpoProcessingNotifications();

    for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NOTIFY_KEY    CurrentNotify;
        
        CurrentNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);
        if (0 == _wcsicmp(CurrentNotify->Identifier.Buffer, Notify->Identifier.Buffer))
        {
            NewEntry = FALSE;
            break;
        }
    }

    if (!ShuttingDown)
    {
        if (NewEntry)
        {
            InsertTailList(ListHead, &Notify->ListEntry);
        }

        Notify->Modified = TRUE;
    }

    NdisReleaseReadWriteLock(ListLock, &LockState);

    if (ShuttingDown)
    {
        status = STATUS_SHUTDOWN_IN_PROGRESS;
    }
    else
    {
        WaitEvent = BrdgGpoGetNotifyEvent();

        KeSetEvent(WaitEvent, 0, FALSE);
    }

    return status;
}

VOID
BrdgGpoProcessNotifications(
    IN PVOID                Context)
/*++

Routine Description:

    This is the processing thread worker function that is responsible to doing 
    all notifications that we are interested in.

    WARNING: Don't try to remove this thread or have it exit until you're 
             no longer interested in notifications.  The registery 
             notifications mechanism stores the notifications information
             in the _ETHREAD structure, so exiting the thread loses all
             remaining notifications.

Arguments:

    Context -   PBRDG_GPO_THREAD_PARAMS structure that contains a pointer to the
                notify list, it's lock and the notify and kill events.
                          
Return Value:

    None.

--*/
{
    PBRDG_GPO_THREAD_PARAMS ThreadParms = (PBRDG_GPO_THREAD_PARAMS) Context;
    BOOLEAN                 Exiting = FALSE;
    PNDIS_RW_LOCK           ListLock;
    PLIST_ENTRY             ListHead;
    PVOID                   WaitObjects[2];
    PLIST_ENTRY             QueuedList;
    PBRDG_GPO_QUEUED_NOTIFY QueuedNotify;
    PNPAGED_LOOKASIDE_LIST  LookasideQueueList;

    DBGPRINT(GPO, ("Notification Processing Thread Routine Running\r\n"));

    //
    // The lookaside list and Queuedlist need to live in NonPaged Pool because we utilize them 
    // at DISPATCH_LEVEL
    //
    LookasideQueueList = ExAllocatePoolWithTag(NonPagedPool, sizeof(NPAGED_LOOKASIDE_LIST), 'gdrB');
    if (NULL == LookasideQueueList)
    {
        return;
    }

    QueuedList = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (NULL == QueuedList)
    {
        ExFreePool(LookasideQueueList);
        return;
    }

    ExInitializeNPagedLookasideList(LookasideQueueList, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    sizeof(BRDG_GPO_QUEUED_NOTIFY), 
                                    'grbQ',
                                    0);

    InitializeListHead(QueuedList);

    //
    //  We passed in the list through the context of this thread.
    //
    ListHead = ThreadParms->NotifyList;
    ListLock = ThreadParms->NotifyListLock;
    WaitObjects[0]= (PVOID)ThreadParms->NotifyEvent;
    WaitObjects[1]= (PVOID)ThreadParms->KillEvent;

    while (!Exiting)
    {
        NTSTATUS                status;
        LOCK_STATE              LockState;
        PLIST_ENTRY             pListEntry;
        ULONG                   FiredEvent;

        //
        // We only do this if we're still processing notifications, otherwise we're waiting on 
        // the kill event.
        //
        if (BrdgGpoProcessingNotifications())
        {
            //
            // We use a temporary list to fire off the notifications, since we can't
            // register for RegKey notifications at DISPATCH_LEVEL.
            // 

            NdisAcquireReadWriteLock(ListLock, FALSE /* Read-only */, &LockState);

            //
            // Loop through the list of notifications looking for any that have changed.
            //

            for (pListEntry = ListHead->Flink; pListEntry != ListHead; pListEntry = pListEntry->Flink)
            {
                PBRDG_GPO_NOTIFY_KEY    Notify;

                Notify = CONTAINING_RECORD(pListEntry, BRDG_GPO_NOTIFY_KEY, ListEntry);
                if (TRUE == Notify->Modified)
                {
                    //
                    // We've found an item that has changed, add it to the list that we'll
                    // use to do the actual work from (at PASSIVE_LEVEL).
                    //

                    if (FALSE == Notify->PendingNotification)
                    {
                        //
                        // We double increment this.  Once for the list we're adding it to and once for
                        // the notification.  We'll decrement it again once we're completely done with it 
                        // in our list below.
                        //
                        if (BrdgIncrementWaitRef(&Notify->RefCount))
                        {
                            if (BrdgIncrementWaitRef(&Notify->RefCount))
                            {
                                QueuedNotify = ExAllocateFromNPagedLookasideList(LookasideQueueList);
                                QueuedNotify->Notify = Notify;
                                InsertTailList(QueuedList, &QueuedNotify->ListEntry);
                            }
                            else
                            {
                                //
                                // Only one increment succeeded, so we re-release it so that it can be freed
                                // since we're probably shutting down.
                                //
                                BrdgDecrementWaitRef(&Notify->RefCount);
                            }
                        }
                    }

                    //
                    // We're going to handle this request so set the Modified value to FALSE
                    // so that we don't do anything with it if we run through the list again 
                    // due to another item being added.
                    //
                    Notify->Modified = FALSE;
                }
            }

            NdisReleaseReadWriteLock(ListLock, &LockState);

            //
            // We're back at PASSIVE_LEVEL so we can now do the registration for the changes.
            //

            for (pListEntry = QueuedList->Flink; pListEntry != QueuedList; pListEntry = pListEntry->Flink)
            {
                QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);
            
                DBGPRINT(GPO, ("Processing Notification: %S\r\n", QueuedNotify->Notify->Identifier.Buffer));

                //
                // Do the actual registration for the key change notification.  Since we can also be
                // passed in a pointer to a BOOLEAN that is used elsewhere, we set that accordingly
                // if we have one.
                //

                DBGPRINT(GPO, ("Refcount for %S \t-\t %d\r\n", QueuedNotify->Notify->Identifier.Buffer, QueuedNotify->Notify->RefCount));
                
                status = BrdgGpoRegisterForRegKeyChange(QueuedNotify->Notify);
                if (QueuedNotify->Notify->SuccessfulRegistration)
                {
                    *(QueuedNotify->Notify->SuccessfulRegistration) = (BOOLEAN)NT_SUCCESS(status);
                    BrdgGpoCheckForMatchAndUpdateMode();
                    if (QueuedNotify->Notify->FunctionRegister)
                    {
                        NTSTATUS tmpStatus;
                        tmpStatus = QueuedNotify->Notify->FunctionRegister();
                        DBGPRINT(GPO, ("Function returned: 0x%x\r\n", tmpStatus));
                    }
                }

                if (NT_SUCCESS(status))
                {
                    InterlockedExchange(&QueuedNotify->Notify->PendingNotification, TRUE);
                }
                else
                {
                    InterlockedExchange(&QueuedNotify->Notify->PendingNotification, FALSE);
                    //
                    // We failed the request, so decrement the refcount.
                    //
                    BrdgDecrementWaitRef(&QueuedNotify->Notify->RefCount);
                }
                //
                // We're done with the item in the list, so decrement the refcount.
                //
                BrdgDecrementWaitRef(&QueuedNotify->Notify->RefCount);
            }

            //
            // Free the temporary list.
            //
            while (!IsListEmpty(QueuedList))
            {
                pListEntry = RemoveHeadList(QueuedList);
            
                QueuedNotify = CONTAINING_RECORD(pListEntry, BRDG_GPO_QUEUED_NOTIFY, ListEntry);

                ExFreeToNPagedLookasideList(LookasideQueueList, QueuedNotify);
            }
        }
        
        //
        // We're done, we'll wait here until the event has fired, ie, one of the items needs to be re-registered,
        // or a new item has been added to the list and we need to register for notifications.
        //
        status = KeWaitForMultipleObjects(2, WaitObjects, WaitAny, Executive, KernelMode, FALSE, FALSE, NULL);

        if (!NT_SUCCESS(status))
        {
            FiredEvent = 1L;  // We're going to terminate the thread.
            DBGPRINT(GPO, ("KeWaitForMultipleObjects returned an error"));
        }
        else
        {
            FiredEvent = (ULONG)status - (ULONG)STATUS_WAIT_0;
        }

        if (1L == FiredEvent)
        {
            Exiting = TRUE;
        }
    }

    ExDeleteNPagedLookasideList(LookasideQueueList);

    ExFreePool(LookasideQueueList);
    ExFreePool(QueuedList);

    DBGPRINT(GPO, ("Notification Processing Thread Routine Exiting\r\n"));

    // We're done, kill this thread.
    PsTerminateSystemThread( STATUS_SUCCESS );
}


NTSTATUS
BrdgGpoRegisterForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify)
{
    NTSTATUS status;

    if (!BrdgGpoProcessingNotifications())
    {
        return STATUS_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Call our notify worker function (this does the real request for notification).
    //
    status = BrdgGpoNotifyRegKeyChange( Notify,
                                        (PIO_APC_ROUTINE)(ULONG_PTR)&Notify->RegChangeWorkItem,
                                        Notify->WorkItemContext,
                                        Notify->CompletionFilter,
                                        Notify->WatchTree);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", Notify->RegKeyName.Buffer, status));
    }

    return status;
}

NTSTATUS
BrdgGpoBuildNotifyForRegKeyChange(
    IN PBRDG_GPO_NOTIFY_KEY     Notify,
    IN LPWSTR                   Identifier,
    IN LPWSTR                   RegKeyName,
    IN LPWSTR                   RegValueName,
    IN PWORKER_THREAD_ROUTINE   ApcRoutine,
    IN PVOID                    ApcContext,
    IN ULONG                    CompletionFilter,
    IN BOOLEAN                  WatchTree,
    IN PBRDG_GPO_REG_CALLBACK   FunctionCallback,
    IN BOOLEAN                  Recurring,
    IN PBOOLEAN                 SuccessfulRegistration,
    IN PBRDG_GPO_REGISTER       FunctionRegister
    )
/*++

Routine Description:
    
    Builds a Notify structure used for Registry Key and Value changes.

Arguments:

    Notify                  -   If ReRegister is FALSE, then this structure has simply been 
                                initialized with some basic information.  The rest will be 
                                filled in here.  If ReRegister is TRUE, then this structure 
                                contains all the information necessary to redo the notification
                                request, this saves us having to pass all the data in each time.

    Identifier              -   Identifies this Notify structure.  Can be a name, or a GUID for an adapter.
    
    RegKeyName              -   The Registry key that we're interesting in waiting on.

    RegValueName            -   The Value that we need (or "Default" if we don't care about it")

    ApcRoutine              -   The routine that we which to be notified on.

    ApcContext              -   Information that we want to be passed back (we expect a valid Notify Struct).

    CompletionFilter        -   What type of change we're interested in.  ie. New Subkey added, or Value changed etc.

    WatchTree               -   Do we want to what for changes on all subkeys as well.

    FunctionCallback        -   Our own internal callback functions

    Recurring               -   Do we want to re-do the notification once we're done handling it.

    SuccessfulRegistration  -   A pointer to a BOOLEAN that we set if the registration is successful.

Return Value:

    STATUS_SUCCESS or a specific error code.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    LPWSTR      lpszIdentifier = NULL;
    LPWSTR      lpszRegKeyName = NULL;
    LPWSTR      lpszRegValueName = NULL;
    
    if (NULL == Notify || 
        NULL == Identifier || 
        NULL == RegKeyName || 
        NULL == RegValueName || 
        NULL == ApcRoutine ||  
        NULL == ApcContext || 
        NULL == FunctionCallback
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // This buffer is not used by ZwNotifyChangeKey.  So no need to really allocate anything for it.
    //
    Notify->Buffer = 0L;
    Notify->BufferSize = sizeof(ULONG);

    //
    // We Allocate these from NonPagedPool because they're passed as part of a struct that can be used at
    // DISPATCH_LEVEL
    //
    lpszIdentifier = ExAllocatePoolWithTag(NonPagedPool, (wcslen(Identifier) + 1) * sizeof(WCHAR), 'gdrB');
    if (lpszIdentifier)
    {
        lpszRegKeyName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(RegKeyName) + 1) * sizeof(WCHAR), 'gdrB');
        if (lpszRegKeyName)
        {
            lpszRegValueName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(RegValueName) + 1) * sizeof(WCHAR), 'gdrB');
            if (lpszRegValueName)
            {
                BOOLEAN Success;
                
                RtlZeroMemory(lpszIdentifier, (wcslen(Identifier) + 1) * sizeof(WCHAR));
                RtlZeroMemory(lpszRegKeyName, (wcslen(RegKeyName) + 1) * sizeof(WCHAR));
                RtlZeroMemory(lpszRegValueName, (wcslen(RegValueName) + 1) * sizeof(WCHAR));

                //
                // We need to allocate new strings because the RtlInitUnicodeString function just sets its buffer
                // to the LPWSTR we pass it and these values need to be used outside the scope of these functions.
                //
                wcscpy(lpszIdentifier, Identifier);
                wcscpy(lpszRegKeyName, RegKeyName);
                wcscpy(lpszRegValueName, RegValueName);

                //
                // Set the strings inside our struct.  This enables us to fully rebuild the information required
                // for keeping track of the different keys that we need to be notified about.
                //
                RtlInitUnicodeString(&Notify->Identifier, lpszIdentifier);
                RtlInitUnicodeString(&Notify->RegKeyName, lpszRegKeyName);
                RtlInitUnicodeString(&Notify->RegValue, lpszRegValueName);

                //
                // Recurring will tell us if we need to re-register once a change is fired.
                //
                Notify->Recurring = Recurring;

                //
                // Rather than have the BrdgGpoRegNotify function do everything, we have seperate functions
                // for each one.  This also means that we don't have to keep all of them in the paged-locked 
                // section, since they will be called at PASSIVE_LEVEL.
                //
                Notify->FunctionCallback = FunctionCallback;

                //
                // We are using a Workitem to get called back on.  We pass in the notify structure
                // which has enough info to re-notify if necessary.  The context is generally just
                // the Deferred work queue.
                //
                ExInitializeWorkItem(&Notify->RegChangeWorkItem, ApcRoutine, Notify);
                Notify->WorkItemContext = ApcContext;

                //
                // We store the WatchTree and CompletionFilter so that we can renotify needing any
                // additional parameters, since we're probably ddoing this from a different thread.
                //
                Notify->WatchTree = WatchTree;
                Notify->CompletionFilter = CompletionFilter;

                //
                // We set this once we have successfully registered for notification on the key of 
                // interest.
                //
                Notify->SuccessfulRegistration = SuccessfulRegistration;

                //
                // Increment this once so that we can decrement it in the cleanup code and have it only go to Zero then.
                //
                BrdgInitializeWaitRef(&Notify->RefCount, FALSE);

                //
                // Since we're initializing this object, there is no way that this should fail.
                //
                Success = BrdgIncrementWaitRef(&Notify->RefCount);
                SAFEASSERT(Success);
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    else
    {
        return STATUS_INSUFFICIENT_RESOURCES;                
    }

    if (!NT_SUCCESS(status))
    {
        if (lpszIdentifier)
        {
            ExFreePool(lpszIdentifier);
        }
        if (lpszRegKeyName)
        {
            ExFreePool(lpszRegKeyName);
        }
        if (lpszRegValueName)
        {
            ExFreePool(lpszRegValueName);
        }
    }

    return status;    
}

NTSTATUS
BrdgGpoNotifyRegKeyChange(
                          IN      PBRDG_GPO_NOTIFY_KEY    Notify,
                          IN      PIO_APC_ROUTINE         ApcRoutine,
                          IN      PVOID                   ApcContext,
                          IN      ULONG                   CompletionFilter,
                          IN      BOOLEAN                 WatchTree)
/*++

Routine Description:

    This calls ZwNotifyChangeKey to register us for notifications on individual keys. 
    We close the key in the callback functions because you can only listen once per handle.

Arguments:

    Notify              -   Structure containing relevant information about the notification.  Allows us to
                            know what values to read to get the relevant data that we need.
    ApcRoutine          -   The routine that we which to be notified on.

    ApcContext          -   Information that we want to be passed back (we expect a valid Notify Struct).

    CompletionFilter    -   What type of change we're interested in.  ie. New Subkey added, or Value changed etc.

    WatchTree           -   Do we want to what for changes on all subkeys as well.
                          
Return Value:

    STATUS_SUCCESS or a specific error code.

--*/
{
    OBJECT_ATTRIBUTES   ObAttr;
    NTSTATUS            status;
    
    InitializeObjectAttributes(&ObAttr, &Notify->RegKeyName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);
    
    status = ZwOpenKey( &Notify->RegKey,
        KEY_READ | KEY_NOTIFY | KEY_WRITE,
        &ObAttr);
    
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Opened Regkey successfully\r\n"));
        status = ZwNotifyChangeKey( Notify->RegKey,
                                    NULL,
                                    ApcRoutine,
                                    ApcContext,
                                    &Notify->IoStatus,
                                    CompletionFilter,
                                    WatchTree,
                                    &Notify->Buffer,
                                    Notify->BufferSize,
                                    TRUE
                                    );
    }
    else
    {
        //
        // Set it to NULL so that we don't try to close it accidentally during shutdown.
        //
        Notify->RegKey = NULL;
    }
    
    return status;
}

VOID
static
BrdgGpoRegNotify(
                 IN  PVOID               Context)
/*++

Routine Description:
    
    This is the central callback function that we are notified on.

    This is called on an Executive worker thread at PASSIVE_LEVEL.
Arguments:

    Context -   Is just our Notify structure that we passed in 
                to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    PBRDG_GPO_NOTIFY_KEY    Notify = (PBRDG_GPO_NOTIFY_KEY)Context;
    
    DBGPRINT(GPO, ("APC routine called\r\n"));
    DBGPRINT(GPO, ("Current IRQL: %d\r\n", CURRENT_IRQL));
    
    if (Notify)
    {
        LONG RefCount;
        InterlockedExchange(&Notify->PendingNotification, FALSE);
        Notify->FunctionCallback(Notify);
        RefCount = Notify->RefCount.Refcount - 1;
        DBGPRINT(GPO, ("Refcount for %S \t-\t %d\r\n", Notify->Identifier.Buffer, RefCount));
        BrdgDecrementWaitRef(&Notify->RefCount);
    }
}

NTSTATUS
BrdgGpoAllocateAndInitializeNotifyStruct(
    OUT PBRDG_GPO_NOTIFY_KEY* Notify)
/*++

Routine Description:
    
    Allocates and initializes the Notify struct to all zeros.

Arguments:

    Notify  -   A pointer to pointer to a Notify struct that is allocated
                from NonPagedPool.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES   -   Not enough memory to filfull the request.
    STATUS_INVALID_PARAMETER        -   We were passed a NULL Pointer to pointer 
                                        to a Notify struct.
    STATUS_SUCCESS                  -   We successfully allocated space for the structure.

--*/
{
    NTSTATUS    status = STATUS_INSUFFICIENT_RESOURCES;

    if (NULL == Notify)
    {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // We allocate this from NonPagedPool because it will be accessed at DISPATCH_LEVEL
    //
    *Notify = ExAllocatePoolWithTag(NonPagedPool, sizeof(BRDG_GPO_NOTIFY_KEY), 'gdrB');
    if (*Notify)
    {
        //
        // Zero it out so that we don't try and free invalid strings when we free it.
        //
        RtlZeroMemory(*Notify, sizeof(BRDG_GPO_NOTIFY_KEY));
        status = STATUS_SUCCESS;
    }
    return status;
}

VOID
BrdgGpoFreeNotifyStructAndData(
    IN PBRDG_GPO_NOTIFY_KEY Notify)
/*++

Routine Description:
    
    Frees all data associated with a Notify struct and then frees the struct
    itself.

    Note:   This will not free a structure that is still in a list.
            If you need to free something, use RemoveListEntry and then
            set the Notify->ListEntry Blink and Flink = NULL and then call
            this.

    WARNING:
            Since it's possible that this structure is still being used by
            the a waiting registration, it's better to leave them alone until
            shutdown as it's possible that a notification may be fired once 
            this has been freed and that will result in a system crash since
            the struct will be invalid.

Arguments:

    Notify  -   A pointer to the Notify struct to be freed.

Return Value:

    None.

--*/
{
    if (Notify)
    {
        if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
        {
            if (Notify->Identifier.Buffer)
            {
                ExFreePool(Notify->Identifier.Buffer);
            }
            if (Notify->RegKeyName.Buffer)
            {
                ExFreePool(Notify->RegKeyName.Buffer);
            }
            if (Notify->RegValue.Buffer)
            {
                ExFreePool(Notify->RegValue.Buffer);
            }
            ExFreePool(Notify);
        }
        else
        {
            if (BrdgGpoProcessingNotifications())
            {
                DBGPRINT(GPO, ("Attempt to free a Notify that is still in a list\r\nWhile we're still processing Notifications\r\n"));
            }
        }
    }
}

// ===========================================================================
//
// NOTIFICATION REGISTRATION FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgGpoRegisterForGroupPolicyNetworkNameNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\History"
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                status;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    UNICODE_STRING          RegKeyName;
    PWCHAR                  RegValue;
    ULONG                   DataLen;

    if (g_BrdgGpoGlobals.RegisteredForGroupPolicyHistoryChanges)
    {
        DBGPRINT(GPO, ("Already Registered for Group Policy Network Name Notification\r\n"));
        return STATUS_SUCCESS;
    }
    
    DBGPRINT(GPO, ("BrdgGpoRegisterForGroupPolicyNetworkNameNotification\r\n"));

    RtlInitUnicodeString(&RegKeyName, (LPWSTR) HistoryKey);
    
    //
    // Read the current value from the Registry.
    //
    status = BrdgReadRegUnicode(&RegKeyName,
                                L"NetworkName",
                                &RegValue,
                                &DataLen);
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Group Policy Network Name: %S\r\n", RegValue));
        
        if (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer)
        {
            ExFreePool(g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer);
        }

        //
        // Success.  Now store the value for later use.
        //
        RtlInitUnicodeString(&g_BrdgGpoGlobals.GroupPolicyNetworkName, RegValue);
        
        //
        // Since something changed, we'll just re-verify that we're in
        // the correct bridging mode.
        //        
        BrdgGpoCheckForMatchAndUpdateMode();
    }
    else
    {
        //
        // We failed to get a value for this. It probably isn't there yet - this can happen if this 
        // is the first boot after joining a domain.  We'll be waiting on this key so if we get one later
        // we'll update this value.
        //
        g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer = NULL;
        g_BrdgGpoGlobals.GroupPolicyNetworkName.Length = 0;
        g_BrdgGpoGlobals.GroupPolicyNetworkName.MaximumLength = 0;
    }
 
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"GroupPolicyNetworkName",
                                &Notify);
    if (NT_SUCCESS(status))    
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"GroupPolicyNetworkName",
                                                            (LPWSTR)HistoryKey,
                                                            L"NetworkName",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_LAST_SET,
                                                            FALSE,
                                                            BrdgGpoGroupPolicyNetworkNameChangeCallback,
                                                            TRUE,
                                                            &g_BrdgGpoGlobals.RegisteredForGroupPolicyHistoryChanges,
                                                            BrdgGpoUpdateGroupPolicyNetworkName);
            }
        }

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to Build notification on %S.  Status: 0x%x\r\n", NetworkPoliciesKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
    if (Notify)
    {
        SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
    }
#endif
    
    return status;
}

NTSTATUS
BrdgGpoRegisterForGroupPolicyNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy"

    This is the parent to the History key and is always on a system.
    If will be notified if the History Key is created in which case
    we will register for notifications on that key.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    
    DBGPRINT(GPO, ("BrdgGpoRegisterForGroupPolicyNotification\r\n"));
    
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"GroupPolicyParent",
                                &Notify);
    if (NT_SUCCESS(status))
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"GroupPolicyParent",
                                                            (LPWSTR)GroupPolicyKey,
                                                            L"Default",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_NAME,
                                                            FALSE,
                                                            BrdgGpoGroupPolicyChangeCallback,
                                                            TRUE,
                                                            &g_BrdgGpoGlobals.RegisteredForGroupPolicyChanges,
                                                            BrdgGpoRegisterForGroupPolicyNetworkNameNotification);
            }
        }
        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", GroupPolicyKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
    if (Notify)
    {
        SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
    }
#endif

    return status;
}

NTSTATUS
BrdgGpoRegisterForWindowsGroupPolicyNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    HKLM\SOFTWARE\Policies\Microsoft\Windows

    If this gets notified, then we'll attempt to wait on the 
    Network Connections key below this.
    
Arguments:

    None.

Return Value:

      STATUS_INSUFFICIENT_RESOURCES   -   Not enough memory to allocate the structure.
      STATUS_SUCCESS                  -   We were able to post the request successfully.
                                          This doesn't mean we've successfully requested 
                                          notification though, it only means we've added it 
                                          to the Notifications list and have signaled the 
                                          processing thread to attempt a notification.
  
--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;

    DBGPRINT(GPO, ("BrdgGpoRegisterForWindowsGroupPolicyNotification\r\n"));
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"WindowsGroupPolicies",
                                &Notify);
    if (NT_SUCCESS(status))
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"WindowsGroupPolicies",
                                                            (LPWSTR)PolicyBaseKey,
                                                            (LPWSTR)L"Default",
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_NAME,
                                                            FALSE,
                                                            BrdgGpoWindowsGroupPolicyChangeCallback,
                                                            TRUE,
                                                            NULL,
                                                            BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification);
            }
        }

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", PolicyBaseKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
    if (Notify)
    {
        SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
    }
#endif
    
    return status;
}

VOID
BrdgGpoRegisterForHiveListNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\System\CurrentControlSet\Control\HiveList"

    Each time this is fired we attempt to open the Software hive, if this
    open is successful then we request notification on all the keys that
    we are interested in under the software hive.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    UNICODE_STRING          Software;
    OBJECT_ATTRIBUTES       ObAttr;
    HANDLE                  hKey;
    
    DBGPRINT(GPO, ("BrdgGpoRegisterForHiveListNotification\r\n"));

    //
    // We attempt to open this key now in case the hives are already loaded.
    //

    RtlInitUnicodeString(&Software, SoftwareHiveKey);
    
    InitializeObjectAttributes( &ObAttr,
                                &Software,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );
    
    status = ZwOpenKey(&hKey, KEY_READ, &ObAttr);
    
    if (NT_SUCCESS(status))
    {
        //
        // The software hive is already loaded, no need to register for changes
        // to this.  Just attempt to register for all other changes.
        //

        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
        BrdgGpoRegisterForWindowsGroupPolicyNotification();
        BrdgGpoRegisterForGroupPolicyNotification();
        
        //
        // To avoid turning the bridge on and then off again, we set this just after 
        // verifying the Network Connections policy setting.
        //
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();
        g_BrdgGpoGlobals.WaitingOnSoftwareHive = FALSE;
        
        ZwClose(hKey);
    }
    else
    {
        //
        // We don't want to allocate these twice, so we first try to find an existing notify struct.
        //
        status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                    BrdgGpoGetNotifyListLock(),
                                    L"HiveList",
                                    &Notify);
        if (NT_SUCCESS(status))
        {
            if (STATUS_OBJECT_NAME_EXISTS != status)
            {
                //
                // The item doesn't exist yet, so allocate it from the NonPagedPool and 
                // attempt build a notification request.
                //
                status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
                if (NT_SUCCESS(status))
                {
                    status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                                L"HiveList",
                                                                (LPWSTR)HiveListKey,
                                                                (LPWSTR)L"Default",
                                                                BrdgGpoRegNotify,
                                                                (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                                REG_NOTIFY_CHANGE_LAST_SET,
                                                                FALSE,
                                                                BrdgGpoHiveListCallback,
                                                                TRUE,
                                                                NULL,
                                                                NULL);
                }
            }
            if (!NT_SUCCESS(status))
            {
                DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", PolicyBaseKey, status));
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
            else
            {
                SAFEASSERT(Notify);
                //
                // We have a valid Notify structure, post a notification request to the
                // processing thread.
                //
                status = BrdgGpoRequestNotification(Notify);
                if (STATUS_SHUTDOWN_IN_PROGRESS == status)
                {
                    if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                    {
                        BrdgDecrementWaitRef(&Notify->RefCount);
                        BrdgGpoFreeNotifyStructAndData(Notify);
                        Notify = NULL;
                    }
                }
                else if (!NT_SUCCESS(status))
                {
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
        }
    
#if DBG
        if (Notify)
        {
            SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
        }
#endif
    }
}

NTSTATUS
BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification()
/*++

Routine Description:
    
    Registers for the changes on the following registry key:
    "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Network Connections"

    We also read any value that may already be there and act upon it.
  
Arguments:

    None.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES   -   Not enough memory to allocate the structure.
    STATUS_SUCCESS                  -   We were able to post the request successfully.
                                        This doesn't mean we've successfully requested 
                                        notification though, it only means we've added it 
                                        to the Notifications list and have signaled the 
                                        processing thread to attempt a notification.

--*/
{
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;
    PBRDG_GPO_NOTIFY_KEY    Notify = NULL;
    UNICODE_STRING          RegKeyName;
    ULONG                   RegValue;

    if (g_BrdgGpoGlobals.RegisteredForNetworkConnectionsGroupPolicyChanges)
    {
        DBGPRINT(GPO, ("Already Registered for Network Connections Group Policy Notification\r\n"));
        return STATUS_SUCCESS;
    }

    DBGPRINT(GPO, ("BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification\r\n"));
    
    RtlInitUnicodeString(&RegKeyName, (LPWSTR)NetworkPoliciesKey);
    //
    // Read the current value from the Registry.
    //
    status = BrdgReadRegDWord(  &RegKeyName,
                                (LPWSTR)BridgePolicyValue,
                                &RegValue);
    
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Bridge Policy Setting: %d\r\n", RegValue));
        
        //
        // Since something changed, we'll just re-verify that we're in
        // the correct bridging mode.
        //
        BrdgGpoCheckForMatchAndUpdateMode();
    }
    
    //
    // We don't want to allocate these twice, so we first try to find an existing notify struct.
    //
    status = BrdgGpoFindNotify( BrdgGpoGetNotifyListHead(),
                                BrdgGpoGetNotifyListLock(),
                                L"NetworkConnectionsGroupPolicies",
                                &Notify);
    if (NT_SUCCESS(status))
    {
        if (STATUS_OBJECT_NAME_EXISTS != status)
        {
            status = BrdgGpoAllocateAndInitializeNotifyStruct(&Notify);
            if (NT_SUCCESS(status))
            {
                status = BrdgGpoBuildNotifyForRegKeyChange( Notify,
                                                            L"NetworkConnectionsGroupPolicies",
                                                            (LPWSTR)NetworkPoliciesKey,
                                                            (LPWSTR)BridgePolicyValue,
                                                            BrdgGpoRegNotify,
                                                            (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                                                            REG_NOTIFY_CHANGE_LAST_SET,
                                                            FALSE,
                                                            BrdgGpoNetworkConnectionsGroupPolicyChangeCallback,
                                                            TRUE,
                                                            &g_BrdgGpoGlobals.RegisteredForNetworkConnectionsGroupPolicyChanges,
                                                            NULL);
            }
        }

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(GPO, ("Unable to register for notification on %S.  Status: 0x%x\r\n", NetworkPoliciesKey, status));
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
        else
        {
            SAFEASSERT(Notify);
            status = BrdgGpoRequestNotification(Notify);
            if (STATUS_SHUTDOWN_IN_PROGRESS == status)
            {
                if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
                {
                    BrdgDecrementWaitRef(&Notify->RefCount);
                    BrdgGpoFreeNotifyStructAndData(Notify);
                    Notify = NULL;
                }
            }
            else if (!NT_SUCCESS(status))
            {
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
    }

#if DBG
        if (Notify)
        {
            SAFEASSERT(Notify->ListEntry.Blink && Notify->ListEntry.Flink);
        }
#endif

    return status;
}

// ===========================================================================
//
// REGISTRY CHANGE CALLBACK FUNCTIONS
//
// ===========================================================================

VOID
BrdgGpoTcpipInterfacesChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the an the TcpIp interfaces key changes for 
    and adapter that we're interested in (any Non-NdisWan adapter).

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PWCHAR   RegValue;
    ULONG    StringLen = 0;

    DBGPRINT(GPO, ("BrdgGpoTcpipInterfacesChangeCallback\r\n"));
    
    DBGPRINT(GPO, ("Called for Key: %S re-registering.\r\n", Notify->RegKeyName.Buffer));
    
    //
    // Read the current value from the Registry.
    //
    status = BrdgReadRegUnicode(&Notify->RegKeyName,
                                Notify->RegValue.Buffer,
                                &RegValue,
                                &StringLen);

    if (!NT_SUCCESS(status))
    {
        status = BrdgGpoGetCurrentNetwork(  &Notify->RegKeyName,
                                            &RegValue);
        if (NT_SUCCESS(status))
        {
            StringLen = (UINT)wcslen(RegValue);
        }
    }

    if (NT_SUCCESS(status))
    {
        PBRDG_GPO_NETWORKS  Network;
        LPWSTR              NetworkName;
        
        DBGPRINT(GPO, ("Current Network: %S\r\n", RegValue));

        NetworkName = ExAllocatePoolWithTag(NonPagedPool, (StringLen + 1) * sizeof(WCHAR), 'gdrB');

        if (NULL != NetworkName)
        {
            RtlZeroMemory(NetworkName, (StringLen + 1) * sizeof(WCHAR));
            wcscpy(NetworkName, RegValue);
            
            //
            // Try to find a match for the current network identifier (generally the adapter guid)
            //
            status = BrdgGpoFindNetwork(g_BrdgGpoGlobals.ListHeadNetworks,
                                        &Notify->Identifier,
                                        g_BrdgGpoGlobals.NetworkListLock,
                                        &Network);
            
            if (STATUS_NOT_FOUND == status)
            {
                //
                // No match so this is a new key (very unlikely code path).
                //
                status = BrdgGpoAllocateAndInitializeNetwork(   &Network,
                                                                Notify->Identifier.Buffer,
                                                                NetworkName);
                if (NT_SUCCESS(status))
                {
                    status = BrdgGpoInsertNetwork(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                    &Network->ListEntry,
                                                    g_BrdgGpoGlobals.NetworkListLock);
                
                    if (!NT_SUCCESS(status))
                    {
                        BrdgGpoFreeNetworkAndData(Network);
                        Network = NULL;
                    }
                }
            }
            else
            {
                //
                // This is expected to happen most times, if not always.
                //
                status = BrdgGpoUpdateNetworkName(  g_BrdgGpoGlobals.ListHeadNetworks,
                                                    &Notify->Identifier,
                                                    NetworkName,
                                                    g_BrdgGpoGlobals.NetworkListLock);
                
            }

#if DBG
            if (Network)
            {
                SAFEASSERT(Network->ListEntry.Blink && Network->ListEntry.Flink);
            }
#endif
            
            if (NetworkName)
            {
                ExFreePool(NetworkName);
            }

            NdisFreeMemory(RegValue, StringLen, 0);
        }
    }
    else
    {
        //
        // We change the name to NULL since the key appears to have disappeared.
        //
        status = BrdgGpoUpdateNetworkName(  g_BrdgGpoGlobals.ListHeadNetworks,
                                            &Notify->Identifier,
                                            NULL,
                                            g_BrdgGpoGlobals.NetworkListLock);
    }
    
    //
    // Since something changed, we'll just re-verify that we're in
    // the correct bridging mode.
    //
    BrdgGpoCheckForMatchAndUpdateMode();
    
    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twices/
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        //
        // Re-register.  The notify object contains enough info to do this.
        //
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }        
    }
}

VOID
BrdgGpoWindowsGroupPolicyChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Windows Group Policy key changes.

    We attempt to register for the Network Connections key changes
    if we haven't already done so.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    DBGPRINT(GPO, ("BrdgGpoWindowsGroupPolicyChangeCallback\r\n"));

    if (!g_BrdgGpoGlobals.RegisteredForNetworkConnectionsGroupPolicyChanges)
    {
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();
    }

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twices/
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        NTSTATUS    status;
        
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}

VOID
BrdgGpoHiveListCallback(
    IN  PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the HiveList key changes.

    If it does, we attempt to open the software hive. If that succeeds then
    we attempt to register for the keys that we're interested in under
    the Software Hive.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      Software;
    OBJECT_ATTRIBUTES   ObAttr;
    HANDLE              hKey;

    DBGPRINT(GPO, ("BrdgGpoHiveListCallback\r\n"));

    RtlInitUnicodeString(&Software, SoftwareHiveKey);

    InitializeObjectAttributes( &ObAttr,
                                &Software,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    status = ZwOpenKey(&hKey, KEY_READ, &ObAttr);

    if (NT_SUCCESS(status))
    {
        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
        BrdgGpoRegisterForWindowsGroupPolicyNotification();
        BrdgGpoRegisterForGroupPolicyNotification();

        //
        // To avoid turning the bridge on and then off again, we set this just after 
        // verifying the Network Connections policy setting.
        //
        
        BrdgGpoRegisterForNetworkConnectionsGroupPolicyNotification();
        g_BrdgGpoGlobals.WaitingOnSoftwareHive = FALSE;
        Notify->Recurring = FALSE;
        ZwClose(hKey);
    }

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twices/
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }

    if (TRUE == Notify->Recurring)
    {
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}    


VOID
BrdgGpoGroupPolicyChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Group Policy key changes.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    DBGPRINT(GPO, ("BrdgGpoGroupPolicyChangeCallback\r\n"));

    if (!g_BrdgGpoGlobals.RegisteredForGroupPolicyHistoryChanges)
    {
        BrdgGpoRegisterForGroupPolicyNetworkNameNotification();
    }

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twice.
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        NTSTATUS    status;

        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}    

VOID
BrdgGpoNetworkConnectionsGroupPolicyChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Network Connection Policy key changes.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS    status;
    ULONG       RegValue;
    
    DBGPRINT(GPO, ("BrdgGpoNetworkConnectionsGroupPolicyChangeCallback\r\n"));

    DBGPRINT(GPO, ("Called for Key: %S re-registering.\r\n", Notify->RegKeyName.Buffer));

    status = BrdgReadRegDWord(  &Notify->RegKeyName,
                                Notify->RegValue.Buffer, 
                                &RegValue);
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Bridge Policy Setting: %d\r\n", RegValue));
    }

    //
    // Since something changed, we'll just re-verify that we're in
    // the correct bridging mode.
    //
    BrdgGpoCheckForMatchAndUpdateMode();

    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twice.
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }
    }
}    

NTSTATUS 
BrdgGpoUpdateGroupPolicyNetworkName()
{
    NTSTATUS        status = STATUS_OBJECT_NAME_NOT_FOUND;
    PWCHAR          RegValue = NULL;
    LPWSTR          GroupPolicyNetwork = NULL;
    ULONG           DataLen = 0;
    UNICODE_STRING  RegKeyName;
    
    RtlInitUnicodeString(&RegKeyName, HistoryKey);

    //
    // Read the current value from the registry
    //
    status = BrdgReadRegUnicode(&RegKeyName,
                                L"NetworkName", 
                                &RegValue, 
                                &DataLen);
    
    if (NT_SUCCESS(status))
    {
        DBGPRINT(GPO, ("Group Policy Network Name: %S\r\n", RegValue));
        
        //
        // Almost always checked at DISPATCH_LEVEL, so we allocate from NonPagedPool
        //
        GroupPolicyNetwork = ExAllocatePoolWithTag(NonPagedPool, (DataLen + 1) * sizeof(WCHAR), 'gdrB');
        
        if (GroupPolicyNetwork)
        {
            if (NULL != g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer)
            {
                ExFreePool( g_BrdgGpoGlobals.GroupPolicyNetworkName.Buffer);
            }
            
            RtlZeroMemory(GroupPolicyNetwork, (DataLen + 1) * sizeof(WCHAR));
            
            wcsncpy(GroupPolicyNetwork, RegValue, DataLen);
            
            RtlInitUnicodeString(&g_BrdgGpoGlobals.GroupPolicyNetworkName, GroupPolicyNetwork);
            
            //
            // Since something changed, we'll just re-verify that we're in
            // the correct bridging mode.
            //            
            BrdgGpoCheckForMatchAndUpdateMode();
        }
        NdisFreeMemory(RegValue, DataLen, 0);        
    }

    return status;
}

VOID
BrdgGpoGroupPolicyNetworkNameChangeCallback(
    PBRDG_GPO_NOTIFY_KEY Notify
    )
/*++

Routine Description:
    
    Called back if the Group Policy History key changes.

Arguments:

    Notify -   Notify structure that we passed in 
               to ZwNotifyChangeKey

Return Value:

    None.

--*/
{
    NTSTATUS    status;
    
    //
    // Read the current value from the registry
    //
    
    status = BrdgGpoUpdateGroupPolicyNetworkName();
    //
    // We set this to NULL if we're closing it for shutdown, since we 
    // shouldn't close it twice.
    //
    if (Notify->RegKey)
    {
        ZwClose(Notify->RegKey);
        Notify->RegKey = NULL;
    }
    
    if (TRUE == Notify->Recurring)
    {
        status = BrdgGpoRequestNotification(Notify);
        if (STATUS_SHUTDOWN_IN_PROGRESS == status)
        {
            if (!Notify->ListEntry.Blink && !Notify->ListEntry.Flink)
            {
                BrdgDecrementWaitRef(&Notify->RefCount);
                BrdgGpoFreeNotifyStructAndData(Notify);
                Notify = NULL;
            }
        }
        else if (!NT_SUCCESS(status))
        {
            BrdgGpoFreeNotifyStructAndData(Notify);
            Notify = NULL;
        }        
    }
}

// ===========================================================================
//
// GROUP POLICY NETWORK VERIFICATION FUNCTIONS
//
// ===========================================================================

BOOLEAN
BrdgGpoAllowedToBridge()
/*++

Routine Description:
    
    Checks the Network Connections policy key for the Bridge Policy setting.

    
Arguments:

    None.
    
Return Value:

    TRUE if we couldn't find a Policy Value, or the Value is 1.
    FALSE if the policy exists and contains a value of 0.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  RegKey;
    ULONG           RegValue;
    BOOLEAN         CanBridge = TRUE;  // If there is no key then we're allowed to bridge.

    RtlInitUnicodeString(&RegKey, NetworkPoliciesKey);
    
    status = BrdgReadRegDWord(&RegKey, (LPWSTR) BridgePolicyValue, &RegValue);

    if (NT_SUCCESS(status))
    {
        if (FALSE == RegValue)
        {
            CanBridge = FALSE;
        }
    }
    
    return CanBridge;
}

VOID
BrdgGpoUpdateBridgeMode(
    BOOLEAN NetworkMatch
    )
/*++

Routine Description:

    Checks for a Network Match and if we're not allowed to bridge then 
    turns bridging off, otherwise it turns it on.
    
Arguments:

    NetworkMatch    -   Do we have a match for the group policy network?
    
Return Value:

    None.

--*/
{
    //
    // If we're still waiting on the software hive then
    // we shouldn't do any further processing for this.
    //
    if (BrdgGpoWaitingOnSoftwareHive())
    {
        return;
    }

    if (NetworkMatch && !BrdgGpoAllowedToBridge())
    {
        BrdgFwdChangeBridging(FALSE);
    }
    else
    {
        BrdgFwdChangeBridging(TRUE);
    }
}

VOID
BrdgGpoCheckForMatchAndUpdateMode()
/*++

Routine Description:
    
    This looks for a matching network and group policy network and
    attempts to update the bridging status accordingly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS    status;

    if (NULL != g_BrdgGpoGlobals.ListHeadNetworks)
    {
        status = BrdgGpoMatchNetworkName(   g_BrdgGpoGlobals.ListHeadNetworks, 
                                            &g_BrdgGpoGlobals.GroupPolicyNetworkName,
                                            g_BrdgGpoGlobals.NetworkListLock);
        
        if (BRDG_STATUS_EMPTY_LIST != status)
        {
            if (STATUS_SUCCESS == status)
            {
                //
                // We found a match.  Check if we're allowed to run.
                //
                BrdgGpoUpdateBridgeMode(BRDG_ON_SAME_NETWORK);
            }
            else if (STATUS_NO_MATCH == status)
            {
                //
                // No match, but we may need to turn bridging back on.
                //
                BrdgGpoUpdateBridgeMode(BRDG_ON_DIFFERENT_NETWORK);
            }
            else
            {
                // We should never get here.
                SAFEASSERT(FALSE);
            }
        }
        else if (BrdgGpoAllowedToBridge())
        {
            BrdgFwdChangeBridging(TRUE);
        }
    }
}

NTSTATUS BrdgGpoGetCurrentNetwork(
    IN  PUNICODE_STRING RegKeyName,
    OUT PWCHAR*         NetworkName)
/*++

Routine Description:
    
    Determines the current network that we are on.  This either uses the DHCP Domain name,
    or the IP Address ANDed with the Subnet mask.
    
    For example: 10.251.1.3 AND 255.0.0.0 results in a network of 10.0.0.0
    
    This routine MUST be called at IRQL = PASSIVE_LEVEL.

Arguments:

    RegKeyName  (IN)    -   The RegistryKey for the adapter we're interested in.
    
    NetworkName (OUT)   -   The network we're currently one.
    

Return Value(s):

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER
    STATUS_NO_IP_ADDRESSES - if we've released the only address we have.
    
    Out of memory can also be returned.

--*/
{
    NTSTATUS    status;
    PWCHAR      lpszNetworkName = NULL;
    BOOLEAN     HaveNetwork = FALSE;
    BOOLEAN     HaveDhcpDomain = FALSE;
    WCHAR       BaseNetwork[MAX_IP4_STRING_LEN];
    PWCHAR      DhcpIPAddress = NULL;
    ULONG       DhcpIPAddrLen = 0;
    
    if (!RegKeyName || !NetworkName)
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(BaseNetwork, MAX_IP4_STRING_LEN * sizeof(WCHAR));

    *NetworkName = NULL;
    
    //
    // We don't have a valid Network Name.  Attempt to build one
    // from the DhcpIPAddess and DhcpSubnetMask.
    //
    status = BrdgReadRegUnicode(RegKeyName,
                                L"DhcpIPAddress",
                                &DhcpIPAddress,
                                &DhcpIPAddrLen);
    if (NT_SUCCESS(status))
    {
        PWCHAR  DhcpSubnetMask = NULL;
        ULONG   DhcpSubnetMaskLen = 0;

        status = BrdgReadRegUnicode(RegKeyName, 
                                    L"DhcpSubnetMask",
                                    &DhcpSubnetMask,
                                    &DhcpSubnetMaskLen);
        if (NT_SUCCESS(status))
        {
            LPWSTR Terminator;
            in_addr ipaddr;
            in_addr subnet;
            //
            // We and the two values together to get the Network.
            // For example: 10.251.1.3 AND 255.0.0.0 gives 10.0.0.0
            //
            status = BrdgTdiIpv4StringToAddress(DhcpIPAddress, 
                                                FALSE,
                                                &Terminator,
                                                &ipaddr);

            if (NT_SUCCESS(status))
            {
                in_addr network;
                status = BrdgTdiIpv4StringToAddress(DhcpSubnetMask,
                                                    FALSE,
                                                    &Terminator,
                                                    &subnet);
                network.S_un.S_addr = ipaddr.S_un.S_addr & subnet.S_un.S_addr;
                DBGPRINT(GPO, 
                        ("in_addr  = %u.%u.%u.%u\r\n",
                          network.S_un.S_un_b.s_b1, network.S_un.S_un_b.s_b2,
                          network.S_un.S_un_b.s_b3, network.S_un.S_un_b.s_b4));
                
                //
                // Do we have a valid IPaddress
                //
                if (0 != ipaddr.S_un.S_addr)
                {
                    _snwprintf( BaseNetwork,
                                MAX_IP4_STRING_LEN,
                                L"%u.%u.%u.%u",
                                network.S_un.S_un_b.s_b1,
                                network.S_un.S_un_b.s_b2,
                                network.S_un.S_un_b.s_b3,
                                network.S_un.S_un_b.s_b4);
                    HaveNetwork = TRUE;
                }
            }
        }
    }

    if (!HaveNetwork)
    {
        PWCHAR  IPAddress = NULL;
        ULONG   IPAddrLen = 0;

        status = BrdgReadRegUnicode(RegKeyName,
                                    L"IPAddress",
                                    &IPAddress,
                                    &IPAddrLen);
        if (NT_SUCCESS(status))
        {
            PWCHAR  SubnetMask = NULL;
            ULONG   SubnetMaskLen = 0;
        
            status = BrdgReadRegUnicode(RegKeyName, 
                                        L"SubnetMask",
                                        &SubnetMask,
                                        &SubnetMaskLen);
            if (NT_SUCCESS(status))
            {
                LPWSTR Terminator;
                in_addr ipaddr;
                in_addr subnet;

                //
                // We and the two values together to get the Network.
                // For example: 10.251.1.3 AND 255.0.0.0 gives 10.0.0.0
                //
                status = BrdgTdiIpv4StringToAddress(IPAddress, 
                                                    FALSE,
                                                    &Terminator,
                                                    &ipaddr);
            
                if (NT_SUCCESS(status))
                {
                    in_addr network;
                    status = BrdgTdiIpv4StringToAddress(SubnetMask,
                                                        FALSE,
                                                        &Terminator,
                                                        &subnet);

                    network.S_un.S_addr = ipaddr.S_un.S_addr & subnet.S_un.S_addr;

                    DBGPRINT(GPO, 
                            ("in_addr  = %u.%u.%u.%u\r\n",
                            network.S_un.S_un_b.s_b1, network.S_un.S_un_b.s_b2,
                            network.S_un.S_un_b.s_b3, network.S_un.S_un_b.s_b4));
                
                    //
                    // Do we have a valid IPaddress
                    //
                    if (0 != ipaddr.S_un.S_addr)
                    {
                        _snwprintf( BaseNetwork,
                                    MAX_IP4_STRING_LEN,
                                    L"%u.%u.%u.%u",
                                    network.S_un.S_un_b.s_b1,
                                    network.S_un.S_un_b.s_b2,
                                    network.S_un.S_un_b.s_b3,
                                    network.S_un.S_un_b.s_b4);
                        HaveNetwork = TRUE;
                    }
                }
            }
        }
    }

    if (!HaveNetwork)
    {
        //
        // Returning this will cause us not to update the network name this
        // card.
        //
        status = STATUS_NO_IP_ADDRESSES;
    }
    else if (HaveDhcpDomain)
    {
        *NetworkName = lpszNetworkName;
        status = STATUS_SUCCESS;
    }
    else
    {
        status = NdisAllocateMemoryWithTag(NetworkName,
                                           ((UINT)wcslen(BaseNetwork) + 1) * sizeof(WCHAR), 
                                           'gdrB');
        wcscpy(*NetworkName, BaseNetwork);
    }

    return status;
}


// ===========================================================================
//
// NETWORK LIST MANIPULATION FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgGpoInitializeNetworkList()
/*++

Routine Description:
    
    Initializes the Network List and Lock.

    This can can be called at any IRQL (but since it's called from driver entry, 
    it will most likely be called at PASSIVE_LEVEL).

Arguments:

    None.

Return Value(s):

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;

    g_BrdgGpoGlobals.ListHeadNetworks = ExAllocatePoolWithTag(NonPagedPool, sizeof(LIST_ENTRY), 'gdrB');
    if (NULL != g_BrdgGpoGlobals.ListHeadNetworks)
    {
        InitializeListHead(g_BrdgGpoGlobals.ListHeadNetworks);
        g_BrdgGpoGlobals.NetworkListLock = ExAllocatePoolWithTag(NonPagedPool, sizeof(NDIS_RW_LOCK), 'gdrB');
        if (g_BrdgGpoGlobals.NetworkListLock)
        {
            NdisInitializeReadWriteLock(g_BrdgGpoGlobals.NetworkListLock);
            status = STATUS_SUCCESS;
        }
        else
        {
            ExFreePool(g_BrdgGpoGlobals.ListHeadNetworks);
        }
    }

    return status;
}

VOID
BrdgGpoUninitializeNetworkList()
/*++

Routine Description:
    
    Frees the memory associated with the Network List.

    This can be called at IRQL <= DISPATCH_LEVEL but is likely
    to be called at PASSIVE_LEVEL as it's during shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ExFreePool(g_BrdgGpoGlobals.ListHeadNetworks);
    ExFreePool(g_BrdgGpoGlobals.NetworkListLock);
}


VOID
BrdgGpoAcquireNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN      BOOLEAN          fWrite,
    IN OUT  PLOCK_STATE      LockState
    )
/*++

Routine Description:
    
    Acquires the NetworkList read-write lock.  We support a NULL Lock
    as it allows us to acquire for write and then call functions that 
    need the lock for read without locking up the system (by 
    supplying NULL for the lock).

    This can be called at IRQL <= DISPATCH_LEVEL

Arguments:

    NetworkListLock     -   Read-Write Lock to be acquired.

    fWrite              -   TRUE == Write Access, FALSE == Read Access

    LockState           -   Opaque value used by NDIS.


Return Value:

    None.

--*/
{
    if (NetworkListLock)
    {
        NdisAcquireReadWriteLock(NetworkListLock, fWrite, LockState);
    }
}

VOID
BrdgGpoReleaseNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN OUT  PLOCK_STATE      LockState
    )
/*++

Routine Description:
    
    Releases the NetworkList read-write lock.  We support a NULL Lock
    as it allows us to acquire for write and then call functions that 
    need the lock for read without locking up the system (by 
    supplying NULL for the lock).

    This can be called at IRQL <= DISPATCH_LEVEL

Arguments:

    NetworkListLock     -   Read-Write Lock to be released.

    LockState           -   Opaque value used by NDIS.

Return Value:

    None.

--*/
{
    if (NetworkListLock)
    {
        NdisReleaseReadWriteLock(NetworkListLock, LockState);
    }
}

NTSTATUS
BrdgGpoAllocateAndInitializeNetwork(
    IN OUT PBRDG_GPO_NETWORKS*  Network,
    IN PWCHAR                   Identifier,
    IN PWCHAR                   NetworkName
    )
/*++

Routine Description:

    Allocates the memory needed for a Network structure from the NonPaged pool
    and copies the data into the structure.

    Must be called at IRQL <= APC_LEVEL.
    
Arguments:

    Network     -   The structure to be allocated and initialized with the data.

    Identifier  -   The AdapterID for this network structure.

    NetworkName -   The current network that we are on.  This can be NULL if we 
                    haven't determined a network yet.

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PBRDG_GPO_NETWORKS  pNetwork;
    NTSTATUS            status = STATUS_INSUFFICIENT_RESOURCES;
    
    *Network = NULL;

    if (!BrdgGpoProcessingNotifications())
    {
        return STATUS_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Everything in this struct will be used at DISPATCH_LEVEL, so all of it is
    // allocated from the NonPagedPool
    //
    pNetwork = ExAllocatePoolWithTag(NonPagedPool, sizeof(BRDG_GPO_NETWORKS), 'gdrB');
    if (NULL != pNetwork)
    {
        PUNICODE_STRING pIdentifier = NULL;
        PUNICODE_STRING pNetworkName = NULL;
        LPWSTR lpszIdentifier = NULL;
        LPWSTR lpszNetworkName = NULL;

        pIdentifier = ExAllocatePoolWithTag(NonPagedPool, sizeof(UNICODE_STRING), 'gdrB');
        if (pIdentifier)
        {
            pNetworkName = ExAllocatePoolWithTag(NonPagedPool, sizeof(UNICODE_STRING), 'gdrB');
            if (pNetworkName)
            {
                lpszIdentifier = ExAllocatePoolWithTag(NonPagedPool, (wcslen(Identifier) + 1) * sizeof(WCHAR), 'gdrB');
                if (lpszIdentifier)
                {
                    RtlZeroMemory(lpszIdentifier, wcslen(Identifier) + 1);
                    wcscpy(lpszIdentifier, Identifier);

                    //
                    // A NULL Network name is valid, so we only allocate it if we are passed one.
                    //

                    if (NetworkName)
                    {
                        lpszNetworkName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(NetworkName) + 1) * sizeof(WCHAR), 'gdrB');
                        if (lpszNetworkName)
                        {
                            RtlZeroMemory(lpszNetworkName, wcslen(NetworkName) + 1);
                            wcscpy(lpszNetworkName, NetworkName);
                        }
                    }

                    //
                    // This is a Logical AND operation:
                    // Either we have both or we have neither.  We can't have one and not the other, if we do 
                    // then we didn't succeed the last allocate.
                    //
                    if ((NetworkName && lpszNetworkName) || (!NetworkName && !lpszNetworkName))
                    {
                        RtlInitUnicodeString(pIdentifier, lpszIdentifier);
                        //
                        // This may be NULL, but that's fine, since it means we'll add it when it gets written.
                        //
                        RtlInitUnicodeString(pNetworkName, lpszNetworkName);

                        pNetwork->Identifier = pIdentifier;
                        pNetwork->NetworkName = pNetworkName;
                        pNetwork->ListEntry.Blink = NULL;
                        pNetwork->ListEntry.Flink = NULL;

                        *Network = pNetwork;
                        status = STATUS_SUCCESS;
                    }
                }
            }
        }

        if (!NT_SUCCESS(status))
        {
            if (lpszIdentifier)
            {
                ExFreePool(lpszIdentifier);
            }
            if (pIdentifier)
            {
                ExFreePool(pIdentifier);
            }
            if (pNetworkName)
            {
                ExFreePool(pNetworkName);
            }
            if (pNetwork)
            {
                ExFreePool(pNetwork);
            }
        }
    }

    return status;
}

VOID
BrdgGpoFreeNetworkAndData(
    IN  PBRDG_GPO_NETWORKS  Network)
/*++

Routine Description:
    
    This frees any data associated with a particular network.

    This can be called IRQL <= DISPATCH_LEVEL.

Arguments:

    Network -   Structure containing an ID and Network name
                for an adapter.

Return Value:

    None.

--*/
{
    //
    // First free the data associated with this entry
    //
    if (Network->Identifier)
    {
        if (Network->Identifier->Buffer)
        {
            ExFreePool(Network->Identifier->Buffer);
        }
        ExFreePool(Network->Identifier);
    }
    if (Network->NetworkName)
    {
        if (Network->NetworkName->Buffer)
        {
            ExFreePool(Network->NetworkName->Buffer);
        }
        ExFreePool(Network->NetworkName);
    }
    //
    // Now free the structure
    //
    ExFreePool(Network);
}

NTSTATUS
BrdgGpoEmptyNetworkList(
    IN      PLIST_ENTRY         NetworkList,
    IN      PNDIS_RW_LOCK       NetworkListLock)
/*++

Routine Description:
    
    Empties the existing list and frees all the items.
    Do not acquire the list lock before calling this function.

Arguments:

    NetworkList     -   The list of current networks.

    NetworkListLock -   Ndis Read Write Lock for synchronizing changes to the list.

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    LOCK_STATE              LockState;

    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);
    //
    // Loop through the list deleting the entries.
    //
    while (!IsListEmpty(NetworkList))
    {
        PBRDG_GPO_NETWORKS  Network;
        PLIST_ENTRY         pListEntry;

        pListEntry = RemoveHeadList(NetworkList);

        Network = CONTAINING_RECORD(pListEntry, BRDG_GPO_NETWORKS, ListEntry);
        BrdgGpoFreeNetworkAndData(Network);
    }

    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);

    return status;
}
                     
NTSTATUS
BrdgGpoInsertNetwork(
    IN PLIST_ENTRY              NetworkList,
    IN PLIST_ENTRY              Network,
    IN PNDIS_RW_LOCK            NetworkListLock)
/*++

Routine Description:
    
    This routine is responsible for adding a new Network to the list.  
    If someone attempts to insert an existing item, an error is returned.
    The caller is responsible for calling BrdgGpoUpdateNetworkName instead.

    This routine can be called at IRQL <= DISPATCH_LEVEL.

Arguments:

    NetworkList     -   The list of current networks.

    Network         -   The new Network entry to add to the list.
  
    NetworkListLock -   Ndis Read Write Lock for synchronizing changes to the list.
    
Return Value:

    STATUS_SHUTDOWN_IN_PROGRESS -   We're busy shutting down, so the item was not added.
    STATUS_INVALID_PARAMETER    -   One or more of the parameters was NULL.
    STATUS_DUPLICATE_NAME       -   This entry already exists in the list.
    STATUS_SUCCESS              -   We successfully added the entry to the list.


--*/
{
    PBRDG_GPO_NETWORKS          pNetwork = NULL;
    PBRDG_GPO_NETWORKS          NewNetwork = NULL;
    LOCK_STATE                  LockState;
    NTSTATUS                    status;
    BOOLEAN                     ShuttingDown;

    if (!NetworkList || !Network || !NetworkListLock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Lock the list for update
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);

    ShuttingDown = !BrdgGpoProcessingNotifications();

    if (!ShuttingDown)
    {
        NewNetwork = CONTAINING_RECORD(Network, BRDG_GPO_NETWORKS, ListEntry);
    
        //
        // We do this to prevent us accidentally inserting a duplicate item.  We grab the lock before so that
        // we can't insert the same item twice.
        //
        status = BrdgGpoFindNetwork(    NetworkList,
                                        NewNetwork->Identifier,
                                        NULL,  // We have already grabbed the lock for Write access.
                                        &pNetwork);

        if (STATUS_NOT_FOUND == status)
        {
            InsertTailList(NetworkList, Network);
            status = STATUS_SUCCESS;
        }
        else if (STATUS_SUCCESS == status)
        {
            status = STATUS_DUPLICATE_NAME;
        }
    }
    else
    {
        status = STATUS_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Release the lock, we're done updating
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);
    
    return status;
}

NTSTATUS
BrdgGpoDeleteNetwork(
    IN PLIST_ENTRY              NetworkList,
    IN PUNICODE_STRING          NetworkIdentifier,
    IN PNDIS_RW_LOCK            NetworkListLock)
/*++

Routine Description:
    
    Deletes an existing network entry.

Arguments:

    NetworkList         -   The list of current networks.

    NetworkIdentifier   -   A unique identifier that identifies which Network entry to remove.
    
    NetworkListLock     -   Ndis Read Write Lock for synchronizing changes to the list.

Return Value:

    STATUS_NOT_FOUND    -   We couldn't find and entry matching the identifier.
    STATUS_SUCCESS      -   We were able to remove the entry successfully.

*/
{
    PBRDG_GPO_NETWORKS          pNetwork = NULL;
    LOCK_STATE                  LockState;
    NTSTATUS                    status = STATUS_NOT_FOUND;
   
    //
    // Lock the list for update
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);
    
    //
    // Find the entry;
    //
    status = BrdgGpoFindNetwork(    NetworkList,
                                    NetworkIdentifier,
                                    NULL,  // We have already grabbed the lock for Write access.
                                    &pNetwork);
    
    if (NT_SUCCESS(status))
    {
        RemoveEntryList(&pNetwork->ListEntry);
        BrdgGpoFreeNetworkAndData(pNetwork);

        pNetwork = NULL;
        status = STATUS_SUCCESS;
    }
    
    //
    // Release the lock, we're done updating
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);
    
    return status;
}

NTSTATUS
BrdgGpoFindNetwork(
    IN  PLIST_ENTRY         NetworkList,
    IN  PUNICODE_STRING     NetworkIdentifier,
    IN  PNDIS_RW_LOCK       NetworkListLock,
    OUT PBRDG_GPO_NETWORKS* Network
                   )
/*++

Routine Description:

    Finds a particular Network in the list of networks.
  
Arguments:

    NetworkList         -   The list of current networks.

    NetworkIdentifier   -   A unique identifier that identifies which Network entry to remove.

    NetworkListLock     -   Ndis Read Write Lock for synchronizing changes to the list.

    Network             -   The item if found, NULL otherwise.
    
Return Value:

    STATUS_NOT_FOUND    -   No entry matching the identifier could be found.
    STATUS_SUCCESS      -   The entry was successfully found.

--*/
{
    PLIST_ENTRY         pListEntry;
    LOCK_STATE          LockState;
    NTSTATUS            status = STATUS_NOT_FOUND;
    
    if (!NetworkIdentifier || !Network)  // We can have a NULL list lock.
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Set the value to NULL so it isn't accidentally used by someone who doesn't realise
    // that they didn't really get a record back.
    //
    *Network = NULL;
    
    if (IsListEmpty(NetworkList))
    {
        return STATUS_NOT_FOUND;
    }

    //
    // Lock the list for read
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, FALSE /* Read-only */, &LockState);

    //
    // Loop through the list looking for an entry with the same identifier
    //
    for (pListEntry = NetworkList->Flink; pListEntry != NetworkList; pListEntry = pListEntry->Flink)
    {
        PBRDG_GPO_NETWORKS CurrentNetwork;

        CurrentNetwork = CONTAINING_RECORD(pListEntry, BRDG_GPO_NETWORKS, ListEntry);

        //
        // Compare this entries network to the network name that was passed in.
        //

        if ((NULL != CurrentNetwork->NetworkName->Buffer) && 
            (0 == _wcsicmp(CurrentNetwork->Identifier->Buffer, NetworkIdentifier->Buffer)))
        {
            *Network = CurrentNetwork;
            status = STATUS_SUCCESS;
            break;
        }
    }

    //
    // Release the lock, we're done searching
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);

    return status;
}

NTSTATUS
BrdgGpoMatchNetworkName(
    IN  PLIST_ENTRY         NetworkList,
    IN  PUNICODE_STRING     NetworkName,
    IN  PNDIS_RW_LOCK       NetworkListLock
                       )
/*++

Routine Description:
    

    Enumerates through the list looking for a match for the supplied Network Name.
    
    This can be called on IRQL <= DISPATCH_LEVEL
    
Arguments:

    NetworkList     -   The list through which to enumerate.

    NetworkName     -   The name to look for.

    NetworkListLock -   The NDIS read-write lock for the list.


Return Value:

    STATUS_NO_MATCH -   No match could be found.
    STATUS_SUCCESS  -   We found a matching Network Name.

--*/
{
    PLIST_ENTRY         pListEntry;
    LOCK_STATE          LockState;
    NTSTATUS            status = STATUS_NO_MATCH;

    if (!NetworkList || !NetworkName || !NetworkListLock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Lock the list for read
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, FALSE /* Read */, &LockState);

    if (!IsListEmpty(NetworkList))
    {
        //
        // Loop through the list looking for an entry with the same NetworkName
        //
        for (pListEntry = NetworkList->Flink; pListEntry != NetworkList; pListEntry = pListEntry->Flink)  
        {
            PBRDG_GPO_NETWORKS  CurrentNetwork;

            CurrentNetwork = CONTAINING_RECORD(pListEntry, BRDG_GPO_NETWORKS, ListEntry);
        
            //
            // The network name can be empty, so we don't want to compare if this is the case.
            //
            if ((NULL != CurrentNetwork->NetworkName->Buffer) && 
                (NULL != NetworkName->Buffer) &&
                (0 == _wcsicmp(CurrentNetwork->NetworkName->Buffer, NetworkName->Buffer)))
            {
                status = STATUS_SUCCESS;
                break;
            }
        }
    }
    else
    {
        status = BRDG_STATUS_EMPTY_LIST;
    }

    //
    // Release the lock, we're done searching
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);    

    return status;
}

NTSTATUS
BrdgGpoUpdateNetworkName(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         Identifier,
    IN  PWCHAR                  NetworkName,
    IN  PNDIS_RW_LOCK           NetworkListLock
                        )
/*++

Routine Description:

    Finds a particular Network in the list of networks.
  
Arguments:

    NetworkList         -   The list of current networks.

    Identifier          -   A unique identifier that identifies which Network entry to update.

    NetworkName         -   The new network name for this identifier.

    NetworkListLock     -   Ndis Read Write Lock for synchronizing changes to the list.

Return Value:

    STATUS_NOT_FOUND    -   No entry matching the identifier could be found.
    STATUS_SUCCESS      -   The entry was successfully found.

--*/
{
    PBRDG_GPO_NETWORKS  pNetwork;
    NTSTATUS            status = STATUS_SUCCESS;
    LOCK_STATE          LockState;
    PUNICODE_STRING     pNetworkName = NULL;
    LPWSTR              lpszNetworkName = NULL;
    
    if (!NetworkList || !Identifier || !NetworkListLock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate space for the new network name from NonPagedPool 
    // (it will be accessed from DISPATCH_LEVEL
    //
    pNetworkName = ExAllocatePool(NonPagedPool, sizeof(UNICODE_STRING));
    if (pNetworkName)
    {
        RtlZeroMemory(pNetworkName, sizeof(UNICODE_STRING));
        if (NetworkName)
        {
            lpszNetworkName = ExAllocatePoolWithTag(NonPagedPool, (wcslen(NetworkName) + 1) * sizeof(WCHAR), 'gdrB');
            if (NULL == lpszNetworkName)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                wcscpy(lpszNetworkName, NetworkName);
            }
        }

        if (NT_SUCCESS(status))
        {
            RtlInitUnicodeString(pNetworkName, lpszNetworkName);
        }
        else
        {
            //
            // We failed to allocate the actual string, so free the PUNICODE_STRING
            // as well.
            //
            ExFreePool(pNetworkName);
            return status;
        }
    }
    else
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
   
    //
    // Lock the list for update (this will pend until all readers have released the lock).
    //
    BrdgGpoAcquireNetworkListLock(NetworkListLock, TRUE /* Write-access */, &LockState);

    //
    // We pass NULL as the RW-Lock here because we've already locked it and 
    // we don't want this entry going away while we're still busy with it 
    // (which could happen between a find and an update if we locked twice).
    //
    status = BrdgGpoFindNetwork(NetworkList, Identifier, NULL, &pNetwork);
    if (NT_SUCCESS(status))
    {
        //
        // We first free the current networkname associated with this networkid.
        //
        if (pNetwork->NetworkName->Buffer)
        {
            ExFreePool(pNetwork->NetworkName->Buffer);
        }
        ExFreePool(pNetwork->NetworkName);
    
        //
        // We do this even if we were passed a NULL network name (ie.  the Value/Key has been deleted).
        // Since this means we're probably not on the same network or we've gone to static address and,
        // GPO wise, we're not on the same network.
        //
        pNetwork->NetworkName = pNetworkName;
    }
    else
    {
        ExFreePool(pNetworkName);
    }

    //
    // We're done with the update, so we can release the lock.
    //
    BrdgGpoReleaseNetworkListLock(NetworkListLock, &LockState);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgmini.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgmini.h

Abstract:

    Ethernet MAC level bridge.
    Miniport section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================


NTSTATUS
BrdgMiniDriverInit();

VOID
BrdgMiniInstantiateMiniport();

BOOLEAN
BrdgMiniShouldIndicatePacket(
    IN PUCHAR               pTargetAddr
    );

BOOLEAN
BrdgMiniIsUnicastToBridge (
    IN PUCHAR               Address
    );

VOID
BrdgMiniUpdateCharacteristics(
    IN BOOLEAN              bConnectivityChange
    );

NDIS_HANDLE
BrdgMiniAcquireMiniport();

NDIS_HANDLE
BrdgMiniAcquireMiniportForIndicate();

VOID
BrdgMiniReleaseMiniport();

VOID
BrdgMiniReleaseMiniportForIndicate();

BOOLEAN
BrdgMiniReadMACAddress(
    OUT PUCHAR              pAddr
    );

VOID
BrdgMiniInitFromAdapter(
    IN PADAPT               pAdapt
    );

BOOLEAN
BrdgMiniIsBridgeDeviceName(
    IN PNDIS_STRING         pDeviceName
    );

VOID
BrdgMiniAssociate();

VOID
BrdgMiniCleanup();

VOID
BrdgSetMiniportsToBridgeMode(
    PADAPT pAdapt,
    BOOLEAN fSet
    );

// ===========================================================================
//
// PUBLIC GLOBALS
//
// ===========================================================================

// The device name of our miniport (NULL if not initialized)
extern PWCHAR               gBridgeDeviceName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgpkt.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgpkt.h

Abstract:

    Ethernet MAC level bridge.
    Packet structure definitions

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

typedef enum
{
    BrdgPacketImpossible = 0,       // We zero PACKET_INFO structures on free so make zero invalid
    BrdgPacketInbound,
    BrdgPacketOutbound,
    BrdgPacketCreatedInBridge
} PACKET_DIRECTION;

// Special pointer value to indicate local miniport
#define LOCAL_MINIPORT ((PADAPT)-1)

//
// This is the structure of the ProtocolReserved area of a packet queued for inbound processing
//
// This structure MUST be less than PROTOCOL_RESERVED_SIZE_IN_PACKET in size (currently 4*sizeof(PVOID))
// since we store this structure in the ProtocolReserved section of NDIS_PACKET.
//
typedef struct _PACKET_Q_INFO
{

    BSINGLE_LIST_ENTRY      List;               // Used to queue up the packets

    union
    {
        // If bFastTrackReceive == FALSE
        PADAPT                  pTargetAdapt;   // The target adapter if one was found in the
                                                // forwarding table. Its refcount is bumped when it
                                                // is looked up, and is decremented after processing
                                                // completes in the queue-draining thread

        // If bFastTrackReceive == TRUE
        PADAPT                  pOriginalAdapt; // The adapter on which this packet was originally
                                                // received.
    } u;

    struct _PACKET_INFO     *pInfo;             // NULL if this is a NIC's packet descriptor on loan
                                                // != NULL if we got the packet on the copy path and
                                                // had to wrap it with our own descriptor

    struct
    {
        BOOLEAN bIsUnicastToBridge : 1;         // This packet is unicast to the bridge and should be
                                                // indicated straight up when dequeued. The packet can
                                                // be a retained NIC packet or a wrapped packet.

        BOOLEAN bFastTrackReceive : 1;          // Only used when bIsUnicastToBridge == TRUE. Signals that
                                                // this packet should be fast-track indicated. When FALSE,
                                                // the packet is a base packet and can be indicated normally.

        BOOLEAN bShouldIndicate : 1;            // Whether this packet should be indicated up to the local
                                                // machine (used when bIsUnicastToBridge == FALSE)

        BOOLEAN bIsSTAPacket : 1;               // This packet was sent to the Spanning Tree Algorithm
                                                // reserved multicast address. It should be indicated
                                                // to user mode and NOT forwarded.

        BOOLEAN bRequiresCompatWork : 1;        // This packet will require compatibility-mode processing
                                                // when it gets dequeued. This IMPLIES bFastTrackReceive == FALSE,
                                                // since the fact that a packet requires compatibility-mode
                                                // processing should have forced us to copy the packet data
                                                // to our own data buffer. The compatibility-mode code
                                                // expects to receive a flat, EDITABLE packet.

    } Flags;

} PACKET_Q_INFO, *PPACKET_Q_INFO;

//
// This is the structure of the info block associated with every
// packet that we allocate.
//
typedef struct _PACKET_INFO
{
    //
    // List and pOwnerPacket are maintained by the buffering code. They should not be modified
    // during processing and transmission.
    //
    BSINGLE_LIST_ENTRY      List;               // Used to keep queues of packets

    PNDIS_PACKET            pOwnerPacket;       // Backpointer to the packet associated with this block

    //
    // All following fields are used by the forwarding code for packet processing.
    //
    struct
    {
        UINT                bIsBasePacket : 1;  // Whether this packet is a base packet
                                                // (Controls which variant of the union below to use)

        UINT                OriginalDirection:2;// Actually of type PACKET_DIRECTION but force to unsigned
                                                // otherwise Bad Things occur
                                                //
                                                // Whether this packet was originally received from a
                                                // lower-layer NIC, from a higher-layer protocol, or
                                                // created as a wrapper inside the bridge
    } Flags;

    union
    {
        //
        // This part of the union is valid if the bIsBasePacket field is NOT set
        //
        struct _PACKET_INFO     *pBasePacketInfo;   // If != NULL, this packet is using buffers refcounted by
                                                    // another packet, whose info block is indicated.

        struct
        {
            //
            // This part of the union is valid if the bIsBasePacket field IS set
            //

            PNDIS_PACKET            pOriginalPacket;    // If != NULL, pOriginalPacket == a packet from a miniport
                                                        // or protocol that needs to be returned when we're done

            PADAPT                  pOwnerAdapter;      // The adapter that owns pOriginalPacket. If != NULL, we
                                                        // got this packet from an underlying NIC and bumped up
                                                        // its refcount when we first received the packet. This
                                                        // ensures that a NIC is not unbound while we are still
                                                        // holding some of its packets. pOwnerAdapter's refcount
                                                        // is decremented after returning the original packet.

            LONG                    RefCount;           // Refcount for this packet's buffers (decremented by all
                                                        // dependent packets)

            NDIS_STATUS             CompositeStatus;    // Overall status of the packet. For packets sent to multiple
                                                        // adapters, this is initialized to NDIS_STATUS_FAILURE
                                                        // and any successful send sets it to NDIS_STATUS_SUCCESS.
                                                        // Thus, it is SUCCESS if at least one send succeeded.
        } BasePacketInfo;
    } u;

} PACKET_INFO, *PPACKET_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdggpo.h ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdgtdi.h

Abstract:

    Ethernet MAC level bridge.
    Gpo registration for address notifications.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    March  2002 - Original version

--*/

// ===========================================================================
//
// DEFINES
//
// ===========================================================================

#define MAX_GUID_LEN                39
#define MAX_IP4_STRING_LEN          17
#define BRDG_ON_SAME_NETWORK        TRUE
#define BRDG_ON_DIFFERENT_NETWORK   FALSE
#define BRDG_STATUS_EMPTY_LIST      ((NTSTATUS)(0x0000000F))

// ===========================================================================
//
// TYPES
//
// ===========================================================================

typedef struct _BRDG_GPO_NETWORKS BRDG_GPO_NETWORKS, *PBRDG_GPO_NETWORKS;

typedef struct _BRDG_GPO_NETWORKS
{
    LIST_ENTRY                  ListEntry;
    PUNICODE_STRING             Identifier;
    PUNICODE_STRING             NetworkName;
} BRDG_GPO_NETWORKS, *PBRDG_GPO_NETWORKS;

typedef struct _BRDG_GPO_THREAD_PARAMS
{
    PLIST_ENTRY                 NotifyList;
    PNDIS_RW_LOCK               NotifyListLock;
    PKEVENT                     NotifyEvent;
    PKEVENT                     KillEvent;
} BRDG_GPO_THREAD_PARAMS, *PBRDG_GPO_THREAD_PARAMS;

typedef struct _BRDG_GPO_GLOBALS
{
    UNICODE_STRING              GroupPolicyNetworkName;
    BOOLEAN                     RegisteredForGroupPolicyChanges;
    BOOLEAN                     RegisteredForGroupPolicyHistoryChanges;
    BOOLEAN                     RegisteredForNetworkConnectionsGroupPolicyChanges;
    BOOLEAN                     PolicyBridge;
    BOOLEAN                     WaitingOnSoftwareHive;
    BOOLEAN                     ProcessingNotifications;
    PNDIS_RW_LOCK               NetworkListLock;
    BRIDGE_TIMER                RegistrationTimer;
    PLIST_ENTRY                 ListHeadNetworks;
    PLIST_ENTRY                 ListHeadNotify;
    PNDIS_RW_LOCK               NotifyListLock;
    HANDLE                      NotificationsThread;
    BRDG_GPO_THREAD_PARAMS      QueueInfo;
} BRDG_GPO_GLOBALS, *PBRDG_GPO_GLOBALS;

// The joys of a multi-pass compiler allow us to not have 
// to forward declare this.  If you need a single pass compile
// you'll have to add a forward to the struct below.
typedef VOID (*PBRDG_GPO_REG_CALLBACK)(PBRDG_GPO_NOTIFY_KEY);

typedef NTSTATUS (*PBRDG_GPO_REGISTER)();

typedef struct _BRDG_GPO_NOTIFY_KEY
{
    LIST_ENTRY                  ListEntry;
    HANDLE                      RegKey;
    ULONG                       Buffer;
    ULONG                       BufferSize;
    IO_STATUS_BLOCK             IoStatus;
    UNICODE_STRING              RegValue;
    UNICODE_STRING              RegKeyName;
    UNICODE_STRING              Identifier;
    WORK_QUEUE_ITEM             RegChangeWorkItem;
    PVOID                       WorkItemContext;
    BOOLEAN                     Recurring;
    PBRDG_GPO_REG_CALLBACK      FunctionCallback;
    BOOLEAN                     WatchTree;
    ULONG                       CompletionFilter;
    BOOLEAN                     Modified;
    PBOOLEAN                    SuccessfulRegistration;
    WAIT_REFCOUNT               RefCount;
    LONG                        PendingNotification;
    PBRDG_GPO_REGISTER          FunctionRegister;
} BRDG_GPO_NOTIFY_KEY, *PBRDG_GPO_NOTIFY_KEY;

typedef struct _BRDG_GPO_QUEUED_NOTIFY
{
    LIST_ENTRY                  ListEntry;
    PBRDG_GPO_NOTIFY_KEY        Notify;
} BRDG_GPO_QUEUED_NOTIFY, *PBRDG_GPO_QUEUED_NOTIFY;


// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgGpoDriverInit();

VOID
BrdgGpoCleanup();

NTSTATUS
BrdgGpoNewAddressNotification(
    IN PWSTR    DeviceId
    );

NTSTATUS
BrdgGpoNotifyRegKeyChange(
    IN      PBRDG_GPO_NOTIFY_KEY    Notify,
    IN      PIO_APC_ROUTINE         ApcRoutine,
    IN      PVOID                   ApcContext,
    IN      ULONG                   CompletionFilter,
    IN      BOOLEAN                 WatchTree);

NTSTATUS
BrdgGpoInitializeNetworkList();

VOID
BrdgGpoUninitializeNetworkList();

VOID
BrdgGpoAcquireNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN      BOOLEAN          fWrite,
    IN OUT  PLOCK_STATE      LockState);

VOID
BrdgGpoReleaseNetworkListLock(
    IN      PNDIS_RW_LOCK    NetworkListLock,
    IN OUT  PLOCK_STATE      LockState);

NTSTATUS
BrdgGpoAllocateAndInitializeNetwork(
    IN OUT PBRDG_GPO_NETWORKS*  Network,
    IN PWCHAR                   Identifier,
    IN PWCHAR                   NetworkName);

NTSTATUS
BrdgGpoInsertNetwork(
    IN      PLIST_ENTRY         NetworkList,
    IN      PLIST_ENTRY         Network,
    IN      PNDIS_RW_LOCK       NetworkListLock);

VOID
BrdgGpoFreeNetworkAndData(
    IN      PBRDG_GPO_NETWORKS  Network);

NTSTATUS
BrdgGpoDeleteNetwork(
    IN      PLIST_ENTRY         NetworkList,
    IN      PUNICODE_STRING     NetworkIdentifier,
    IN      PNDIS_RW_LOCK       NetworkListLock);
                     
NTSTATUS
BrdgGpoFindNetwork(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         NetworkIdentifier,
    IN  PNDIS_RW_LOCK           NetworkListLock,
    OUT PBRDG_GPO_NETWORKS*     Network);

NTSTATUS
BrdgGpoMatchNetworkName(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         NetworkName,
    IN  PNDIS_RW_LOCK           NetworkListLock);

NTSTATUS
BrdgGpoUpdateNetworkName(
    IN  PLIST_ENTRY             NetworkList,
    IN  PUNICODE_STRING         Identifier,
    IN  PWCHAR                  NetworkName,
    IN  PNDIS_RW_LOCK           NetworkListLock);
                         
NTSTATUS
BrdgGpoEmptyNetworkList(
    IN OUT  PLIST_ENTRY         NetworkList,
    IN      PNDIS_RW_LOCK       NetworkListLock);

NTSTATUS BrdgGpoGetCurrentNetwork(
    IN  PUNICODE_STRING RegKeyName,
    OUT PWCHAR*         NetworkName);


//
// Notify filter values
//
#define REG_NOTIFY_CHANGE_NAME          (0x00000001L) // Create or delete (child)
#define REG_NOTIFY_CHANGE_ATTRIBUTES    (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET      (0x00000004L) // time stamp
#define REG_NOTIFY_CHANGE_SECURITY      (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER                 \
    (REG_NOTIFY_CHANGE_NAME          |\
    REG_NOTIFY_CHANGE_ATTRIBUTES    |\
    REG_NOTIFY_CHANGE_LAST_SET      |\
REG_NOTIFY_CHANGE_SECURITY)

typedef enum _REG_ACTION {
        KeyAdded,
        KeyRemoved,
        KeyModified
} REG_ACTION;

typedef struct _REG_NOTIFY_INFORMATION {
    ULONG           NextEntryOffset;
    REG_ACTION      Action;
    ULONG           KeyLength;
    WCHAR           Key[1];     // Variable size
} REG_NOTIFY_INFORMATION, *PREG_NOTIFY_INFORMATION;

NTSTATUS
ZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event,
    IN PIO_APC_ROUTINE ApcRoutine,
    IN PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdghash.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdghash.c

Abstract:

    Ethernet MAC level bridge.
    Hash Table section

    This module implements a flexible hash table with support
    for timing out entries automatically

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    October  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgHashTimer(
    IN  PVOID                   DeferredContext
    );

PHASH_TABLE_ENTRY
BrdgHashInternalFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey
    );

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Interval at which the timer runs to clean out table entries
#define TIMER_INTERVAL          (10 * 1000)         // 10 seconds in milliseconds

// Maximum number of table entries the timer should look at each time through
#define MAX_TIMER_EXAMINES      1000

// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Returns TRUE if the two keys of the given length are equal.
//
__forceinline
BOOLEAN
BrdgHashKeysAreEqual(
    IN PUCHAR                   pKeyA,
    IN PUCHAR                   pKeyB,
    IN UINT                     keyLen
    )
{
    BOOLEAN                     bEqual = TRUE;
    UINT                        i;

    for( i = 0; i < keyLen; i++ )
    {
        if( pKeyA[i] != pKeyB[i] )
        {
            bEqual = FALSE;
            break;
        }
    }

    return bEqual;
}

//
// Copies the data at pSrcKey to pDestKey
//
__forceinline
VOID
BrdgHashCopyKey(
    IN PUCHAR                   pDestKey,
    IN PUCHAR                   pSrcKey,
    IN UINT                     keyLen
    )
{
    UINT                        i;

    for( i = 0; i < keyLen; i++ )
    {
        pDestKey[i] = pSrcKey[i];
    }
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

PHASH_TABLE
BrdgHashCreateTable(
    IN PHASH_FUNCTION           pHashFunction,
    IN ULONG                    numBuckets,
    IN ULONG                    entrySize,
    IN ULONG                    maxEntries,
    IN ULONG                    startTimeoutAge,
    IN ULONG                    maxTimeoutAge,
    IN UINT                     keySize
    )
/*++

Routine Description:

    Initializes a hash table.

Arguments:

    pHashFunction               The function that can hash a key to a bucket number
    numBuckets                  The number of hash buckets to use
    entrySize                   The total size of each bucket entry (must be at
                                    least sizeof(HASH_TABLE_ENTRY) )
    maxEntries                  A maximum number of entries to enforce
    startTimeoutAge             The starting timeout value for table entries
                                    (can be changed later)
    maxTimeoutAge               The highest value the timeout age will ever be
                                    (for sanity checking timestamp delta
                                    calculations)
    keySize                     The size of key to use

Return Value:

    The new hash table or NULL if a memory allocation failed

--*/
{
    NDIS_STATUS                 Status;
    PHASH_TABLE                 pTable;
    ULONG                       i;

    SAFEASSERT( pHashFunction != NULL );
    SAFEASSERT( keySize <= MAX_SUPPORTED_KEYSIZE );
    SAFEASSERT( entrySize >= sizeof(HASH_TABLE_ENTRY) );

    // Allocate memory for the table info
    Status = NdisAllocateMemoryWithTag( &pTable, sizeof(HASH_TABLE), 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        return NULL;
    }

    SAFEASSERT( pTable != NULL );

    // Allocate memory for the list of bucket heads
    Status = NdisAllocateMemoryWithTag( (PVOID*)&pTable->pBuckets, sizeof(PHASH_TABLE_ENTRY) * numBuckets, 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisFreeMemory( pTable, sizeof(HASH_TABLE), 0 );
        return NULL;
    }

    SAFEASSERT( pTable->pBuckets != NULL );

    // Zero out the bucket heads
    for( i = 0L; i < numBuckets; i++ )
    {
        pTable->pBuckets[i] = NULL;
    }

#if DBG
    // Allocate memory for the list where we keep track of the number
    // of items currently in each bucket (debug only)
    Status = NdisAllocateMemoryWithTag( &pTable->bucketSizes, sizeof(UINT) * numBuckets, 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisFreeMemory( pTable->pBuckets, sizeof(PHASH_TABLE_ENTRY) * numBuckets, 0 );
        NdisFreeMemory( pTable, sizeof(HASH_TABLE), 0 );
        return NULL;
    }

    SAFEASSERT( pTable->bucketSizes != NULL );

    // Zero out the bucket counts
    for( i = 0L; i < numBuckets; i++ )
    {
        pTable->bucketSizes[i] = 0;
    }
#endif

    pTable->pHashFunction = pHashFunction;
    pTable->entrySize = entrySize;
    pTable->numBuckets = numBuckets;
    pTable->maxEntries = maxEntries;
    pTable->numEntries = 0L;
    pTable->nextTimerBucket = 0L;
    pTable->keySize = keySize;
    pTable->timeoutAge = startTimeoutAge;
    pTable->maxTimeoutAge = maxTimeoutAge;

    NdisInitializeReadWriteLock( &pTable->tableLock );

    // Initialize the lookaside list for allocating entries
    NdisInitializeNPagedLookasideList( &pTable->entryPool, NULL, NULL, 0, entrySize, 'hsaH', 0 );

    // Initialize and start the timer
    SAFEASSERT( pTable->timeoutAge != 0L );
    SAFEASSERT( pTable->maxTimeoutAge >= pTable->timeoutAge );
    BrdgInitializeTimer( &pTable->timer, BrdgHashTimer, pTable );
    BrdgSetTimer( &pTable->timer, TIMER_INTERVAL, TRUE /*Recurring*/ );

    return pTable;
}

VOID
BrdgHashFreeHashTable(
    IN PHASH_TABLE      pTable
    )
/*++

Routine Description:

    Frees an existing hash table structure. Must be called at
    low IRQL. Caller is responsible for ensuring that no other
    thread can access the table after this function is called.

Arguments:

    pTable              The table to free

Return Value:

    None

--*/
{
    // Cancel the timer
    BrdgShutdownTimer( &pTable->timer );

    // Dump all memory for the hash table entries
    NdisDeleteNPagedLookasideList( &pTable->entryPool );

    // Dump the memory used for the bucket heads
    NdisFreeMemory( pTable->pBuckets, sizeof(PHASH_TABLE_ENTRY) * pTable->numBuckets, 0 );
    pTable->pBuckets = NULL;

#if DBG
    // Dump the memory used to track the number of entries in each bucket
    NdisFreeMemory( pTable->bucketSizes, sizeof(UINT) * pTable->numBuckets, 0 );
    pTable->bucketSizes = NULL;
#endif

    // Dump the memory for the table itself
    NdisFreeMemory( pTable, sizeof(HASH_TABLE), 0 );
}


PHASH_TABLE_ENTRY
BrdgHashFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    IN LOCK_STATE              *pLockState
    )
/*++

Routine Description:

    Finds the table entry with the given key.

    If this function returns with a non-NULL result, THE TABLE LOCK IS STILL HELD!

    This allows the table entry to be examined without the risk of it being removed
    from the table. The caller can copy out any data it is interested in before
    releasing the RW lock

Arguments:

    pTable                      The table to search in
    pKey                        The key to find
    pLockState                  Receives the table lock state


Return Value:

    The entry whose key matches pKey or NULL if no entry matches

--*/
{
    PHASH_TABLE_ENTRY           pEntry;

    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE /*Read only*/, pLockState);

    pEntry = BrdgHashInternalFindEntry(pTable, pKey);

    if( pEntry != NULL )
    {
        ULONG                   LastSeen = pEntry->LastSeen;
        ULONG                   CurrentTime;

        // Always get the current time after having read LastSeen so we know that
        // CurrentTime > LastSeen.
        NdisGetSystemUpTime( &CurrentTime );

        // Check to make sure the entry hasn't expired before using it
        // This can happen if our timer function hasn't gotten around to removing
        // this entry yet
        //
        // There is no sensible maximum removal time for hash table entries
        if( BrdgDeltaSafe(LastSeen, CurrentTime, MAXULONG) >= pTable->timeoutAge )
        {
            // We're going to return NULL, so release the table lock
            NdisReleaseReadWriteLock( &pTable->tableLock, pLockState );
            pEntry = NULL;
        }
        else
        {
            // RETURN WITHOUT RELEASING LOCK!
        }
    }
    else
    {
        NdisReleaseReadWriteLock( &pTable->tableLock, pLockState );
    }

    return pEntry;
}

PHASH_TABLE_ENTRY
BrdgHashRefreshOrInsert(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey,
    OUT BOOLEAN                *pIsNewEntry,
    OUT PLOCK_STATE             pLockState
    )
/*++

Routine Description:

    Inserts a new entry with the given key or refreshes an existing entry
    that already has that key.

    Care is taken to avoid taking a write lock (and blocking other procs
    from accessing the table) if at all possible.

    The return value is the entry corresponding to the key, or the new
    entry that has been linked into the table; the pIsNewEntry value
    distinguishes the cases.

    THE FUNCTION RETURNS WITH THE TABLE LOCK IS HELD IF THE RETURNED
    VALUE IS != NULL.

    A NULL return value indicates that the table is full or an error
    occured allocating a new entry. The lock is not held in such a case.

    If the return value is not NULL:

        If *pIsNewEntry is FALSE, the returned value is an existing entry.
        A READ LOCK may be held (under certain circumstances a write lock
        is held, but the caller should assume the weaker lock). The
        caller may  take the opportunity to refresh data in the existing
        entry, but he should take care to allow for synchronization of the
        data, as other threads may be reading the data.

        If *pIsNewEntry is TRUE, the returned value is a new entry, and
        a WRITE LOCK is held. The caller may initialize the new table entry
        in any way he wishes without worrying about other threads reading
        the entry.

    THE CALLER IS REPONSIBLE FOR FREEING THE TABLE LOCK IF THE RETURN
    VALUE IS != NULL!

Arguments:

    pTable                      The table

    pKey                        The key

    pIsNewEntry                 TRUE if the returned entry is a newly
                                    allocated entry needing initialization
                                FALSE if the returned entry is an existing
                                    entry

    pLockState                  Receives the state of the table lock

Return Value:

    The existing entry (so the caller can refresh it) or the new entry
    (so the caller can initialize it), or NULL, signalling that the
    table is full or an error occurred.

--*/
{
    PHASH_TABLE_ENTRY           pRetVal = NULL;
    ULONG                       hash;
    ULONG                       CurrentTime;

    SAFEASSERT( pIsNewEntry != NULL );
    SAFEASSERT( pLockState != NULL );

    NdisGetSystemUpTime( &CurrentTime );

    // First see if an entry already exists that we can tweak without taking a write lock
    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE /*Read only*/, pLockState);

    pRetVal = BrdgHashInternalFindEntry(pTable, pKey);

    if( pRetVal != NULL )
    {
        // It was already recorded. Update the LastSeen with interlocked instructions.
        InterlockedExchangeULong( &pRetVal->LastSeen, CurrentTime );

        // Return without releasing the lock to let the caller refresh the entry
        *pIsNewEntry = FALSE;
    }
    else
    {
        // Sanity
        SAFEASSERT( pTable->numEntries <= pTable->maxEntries );

        if( pTable->numEntries == pTable->maxEntries )
        {
            // The table is full. Don't put anything more in.
            THROTTLED_DBGPRINT(GENERAL, ("Table %p full at %i entries!\n", pTable, pTable->maxEntries));

            // Release the lock; we will return NULL.
            NdisReleaseReadWriteLock(&pTable->tableLock, pLockState);
        }
        else
        {
            // We will need a write lock to link in a new entry, so release the read lock.
            NdisReleaseReadWriteLock(&pTable->tableLock, pLockState);

            // Allocate the new table entry outside a lock for perf. Note that it's possible
            // we'll have to dealloc this without using it below.
            pRetVal = NdisAllocateFromNPagedLookasideList( &pTable->entryPool );

            if( pRetVal == NULL )
            {
                DBGPRINT(GENERAL, ("Allocation failed in BrdgHashRefreshOrInsert\n"));
                // We will return NULL and we are not holding the lock.
            }
            else
            {
                PHASH_TABLE_ENTRY       pSneakedEntry;

                // Fill in the new entry
                pRetVal->LastSeen = CurrentTime;
                BrdgHashCopyKey( pRetVal->key, pKey, pTable->keySize );

                // We will need a write lock to add the entry
                NdisAcquireReadWriteLock(&pTable->tableLock, TRUE /*Read-Write*/, pLockState);

                // An entry could have been made between the release of the read lock
                // and the acquisition of the write lock. Check for this.
                pSneakedEntry = BrdgHashInternalFindEntry(pTable, pKey);

                if( pSneakedEntry != NULL )
                {
                    // Someone snuck in with a new entry for this key.
                    // This code path should be unusual. Just refresh the entry's values.
                    InterlockedExchangeULong( &pSneakedEntry->LastSeen, CurrentTime );

                    // Ditch the tentatively allocated new entry
                    NdisFreeToNPagedLookasideList( &pTable->entryPool, pRetVal );

                    // We will return the sneaked entry and the caller can refresh it
                    pRetVal = pSneakedEntry;
                    *pIsNewEntry = FALSE;
                }
                else
                {
                    // Nobody snuck in between the lock release and acquire to make a new
                    // entry for this key. Link in the new entry we alloced above.
                    hash = (*pTable->pHashFunction)(pKey);

                    // Insert at the head of the bucket's list
                    pRetVal->Next = pTable->pBuckets[hash];
                    pTable->pBuckets[hash] = pRetVal;
#if DBG
                    pTable->bucketSizes[hash]++;
#endif
                    pTable->numEntries++;

                    // We will return the new entry, which the caller will initialize.
                    *pIsNewEntry = TRUE;
                }

                // Return without the lock to let the user initialize or update the entry
            }
        }
    }

    return pRetVal;
}


VOID
BrdgHashRemoveMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    PVOID                       pData
    )
/*++

Routine Description:

    Deletes all table entries that match, according to a supplied matching
    function. This should be called sparingly as it requies walking the
    entire table with a write lock held.

Arguments:

    pTable                      The table

    pMatchFunc                  A function that return TRUE if an entry meets
                                    its criteria or FALSE otherwise

    pData                       A cookie to pass to pMatchFunc

Return Value:

    None

--*/
{
    PHASH_TABLE_ENTRY           pEntry, *pPrevPtr;
    ULONG                       i;
    LOCK_STATE                  LockState;

    NdisAcquireReadWriteLock( &pTable->tableLock, TRUE /*Write access*/, &LockState);

    for (i = 0; i < pTable->numBuckets; i++)
    {
        pEntry = pTable->pBuckets[i];
        pPrevPtr = &pTable->pBuckets[i];

        while( pEntry != NULL )
        {
            if( (*pMatchFunc)(pEntry, pData) )
            {
                PHASH_TABLE_ENTRY      pNextEntry;

                pNextEntry = pEntry->Next;

                // Remove from the list
                SAFEASSERT( pPrevPtr != NULL );
                *pPrevPtr = pEntry->Next;

                // Deallocate
                NdisFreeToNPagedLookasideList( &pTable->entryPool, pEntry );

                pEntry = pNextEntry;
#if DBG
                pTable->bucketSizes[i]--;
#endif
                SAFEASSERT( pTable->numEntries >= 1L );
                pTable->numEntries--;
            }
            else
            {
                pPrevPtr = &pEntry->Next;
                pEntry = pEntry->Next;
            }
        }
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );
}

ULONG
BrdgHashCopyMatching(
    IN PHASH_TABLE              pTable,
    IN PHASH_MATCH_FUNCTION     pMatchFunc,
    IN PHASH_COPY_FUNCTION      pCopyFunction,
    IN ULONG                    copyUnitSize,
    IN PVOID                    pData,
    IN PUCHAR                   pBuffer,
    IN ULONG                    BufferLength
    )
/*++

Routine Description:

    Copies data out of table entries that meet certain criteria into a buffer.
    This should be called sparingly, as it requires walking the entire
    table (albeit with only a read lock held).

Arguments:

    pTable                      The table
    pMatchFunc                  A function that returns TRUE if it is
                                    interested in copying data out of an
                                    entry and FALSE otherwise
    pCopyFunction               A function that copies whatever it is
                                    interested in out of a chosen entry
                                    and into a data buffer
    copyUnitSize                The size of the data copied out of each entry
    pData                       A cookie to pass to the two supplied functions
    pBuffer                     A buffer to copy into
    BufferLength                Room available at pBuffer

Return Value:

    The number of bytes necessary to store all matching data. If the returned value is
    <= BufferLength, all entries  were written to pBuffer.

    If the returned value is > BufferLength, BufferLength - (BufferLength %  copyUnitSize)
    bytes were written to pBuffer and there are additional entries that did not fit.

--*/
{
    PHASH_TABLE_ENTRY           pEntry;
    ULONG                       i;
    LOCK_STATE                  LockState;
    ULONG                       EntryLimit, WrittenEntries, TotalEntries;

    EntryLimit = BufferLength / copyUnitSize;
    WrittenEntries = TotalEntries = 0L;

    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE/*Read only*/, &LockState);

    for (i = 0L; i < pTable->numBuckets; i++)
    {
        pEntry = pTable->pBuckets[i];

        while( pEntry != NULL )
        {
            if( (*pMatchFunc)(pEntry, pData) )
            {
                if( WrittenEntries < EntryLimit )
                {
                    (*pCopyFunction)(pEntry, pBuffer);
                    pBuffer += copyUnitSize;
                    WrittenEntries++;
                }

                TotalEntries++;
            }

            pEntry = pEntry->Next;
        }
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );

    return TotalEntries * copyUnitSize;
}

VOID
BrdgHashPrefixMultiMatch(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pPrefixKey,
    IN UINT                     prefixLen,
    IN PMULTIMATCH_FUNC         pFunc,
    IN PVOID                    pData
    )
/*++

Routine Description:

    Locates all table entries whose keys BEGIN with the given key
    prefix and calls pFunc for each one.

    For this to work, the caller must have previously set up the
    hash table with a hash function that uses only the prefix portion
    of the keys for hashing (i.e., this function relies on all the
    desired entries being in the same hash bucket).

Arguments:

    pTable                      The table
    pPrefixKey                  The key prefix
    prefixLen                   The length of the prefix
    pFunc                       A function to call for each match
    pData                       An argument to pass to pFunc

Return Value:

    None.

--*/
{
    ULONG                       hash = (*pTable->pHashFunction)(pPrefixKey);
    PHASH_TABLE_ENTRY           pEntry = NULL;
    LOCK_STATE                  LockState;

    NdisAcquireReadWriteLock( &pTable->tableLock, FALSE /*Read only*/, &LockState );

    SAFEASSERT( hash < pTable->numBuckets );
    SAFEASSERT( prefixLen <= pTable->keySize );

    pEntry = pTable->pBuckets[hash];

    while( pEntry != NULL )
    {
        // Check if the prefix of the key matches
        if( BrdgHashKeysAreEqual(pEntry->key, pPrefixKey, prefixLen) )
        {
            (*pFunc)(pEntry, pData);
        }

        pEntry = pEntry->Next;
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

PHASH_TABLE_ENTRY
BrdgHashInternalFindEntry(
    IN PHASH_TABLE              pTable,
    IN PUCHAR                   pKey
    )
/*++

Routine Description:

    Locates the table entry with a given key

    CALLER IS RESPONSIBLE FOR OBTAINING THE TABLE LOCK

Arguments:

    pTable                      The table
    pKey                        The key to locate

Return Value:

    The entry matching the given key or NULL if none was found.

--*/
{
    ULONG                       hash = (*pTable->pHashFunction)(pKey);
    PHASH_TABLE_ENTRY           pEntry = NULL, pFoundEntry = NULL;

    SAFEASSERT( hash < pTable->numBuckets );

    pEntry = pTable->pBuckets[hash];

    while( pEntry != NULL )
    {
        if( BrdgHashKeysAreEqual(pEntry->key, pKey, pTable->keySize) )
        {
            pFoundEntry = pEntry;
            break;
        }

        pEntry = pEntry->Next;
    }

    return pEntry;
}

VOID
BrdgHashTimer(
    IN  PVOID                   tablePointer
    )
/*++

Routine Description:

    This function is called periodically (currently every 10 seconds)
    to age out table entries.

    The function checks after traversing each bucket whether it has
    examined more than MAX_TIMER_EXAMINES. If it has, it exits. The bucket
    to be examined on the next invocation is stored in the nextTimerBucket
    field of the hash table..

    This can still result in a worst-case of the timer function examining
    an unbounded number of entries, but if the table entries are reasonably
    well balanced and the order of the number of entries is the same or less
    as the order of MAX_TIMER_EXAMINES, the timer function should limit
    itself to a number of examines resembling MAX_TIMER_EXAMINES per
    invocation.

Arguments:

    tablePointer                A pointer to the table to traverse
    All others                  Ignored

Return Value:

    None

--*/
{
    PHASH_TABLE                 pTable = (PHASH_TABLE)tablePointer;
    PHASH_TABLE_ENTRY           pEntry, *pPrevPtr;
    ULONG                       i, seenEntries = 0L;
    LOCK_STATE                  LockState;

    // Get write access to the table
    NdisAcquireReadWriteLock( &pTable->tableLock, TRUE /*Read-Write*/, &LockState);

    if( pTable->nextTimerBucket >= pTable->numBuckets )
    {
        // Start again at the beginning
        pTable->nextTimerBucket = 0L;
    }

    for (i = pTable->nextTimerBucket; i < pTable->numBuckets; i++)
    {
        pEntry = pTable->pBuckets[i];
        pPrevPtr = &pTable->pBuckets[i];

        while( pEntry != NULL )
        {
            ULONG       LastSeen = pEntry->LastSeen;
            ULONG       CurrentTime;

            // Always read the current time after reading LastSeen, so we know
            // CurrentTime > LastSeen.
            NdisGetSystemUpTime( &CurrentTime );

            // There is no sensible maximum removal time for hash table entries
            if( BrdgDeltaSafe(LastSeen, CurrentTime, MAXULONG) >= pTable->timeoutAge )
            {
                // Entry is too old. Remove it.
                PHASH_TABLE_ENTRY       pNextEntry = pEntry->Next;

                SAFEASSERT( pPrevPtr != NULL );

                // Remove from list
                *pPrevPtr = pNextEntry;
                NdisFreeToNPagedLookasideList( &pTable->entryPool, pEntry );

                pEntry = pNextEntry;
#if DBG
                pTable->bucketSizes[i]--;
#endif
                SAFEASSERT( pTable->numEntries >= 1L );
                pTable->numEntries--;
            }
            else
            {
                pPrevPtr = &pEntry->Next;
                pEntry = pEntry->Next;
            }

            seenEntries++;
        }

        pTable->nextTimerBucket = i + 1;

        if( seenEntries >= MAX_TIMER_EXAMINES )
        {
            // We've looked at too many table entries. Bail out.
            break;
        }
    }

    NdisReleaseReadWriteLock( &pTable->tableLock, &LockState );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgprot.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgprot.c

Abstract:

    Ethernet MAC level bridge.
    Protocol section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/
#pragma warning( push, 3 )
#include <ndis.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgprot.h"
#include "brdgmini.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgbuf.h"
#include "brdgctl.h"
#include "brdgsta.h"
#include "brdgcomp.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// NDIS handle for our identity as a protocol
NDIS_HANDLE             gProtHandle = NULL;

NDIS_MEDIUM             gMediumArray[1] =
                            {
                                NdisMedium802_3     // Ethernet only, can add other media later
                            };

// The adapter list and associated lock
PADAPT                  gAdapterList = {0};
NDIS_RW_LOCK            gAdapterListLock;

// Whether we have called the miniport sections BindsComplete() function yet
// 0 == no, 1 == yes
LONG                    gHaveInitedMiniport = 0L;

// A lock for all the adapters' link speed and media connect characteristics
NDIS_RW_LOCK            gAdapterCharacteristicsLock;

// Number of adapters. Doesn't change if a lock is held on gAdapterListLock
ULONG                   gNumAdapters = 0L;

// Name of the registry value that forces an adapter into compatibility mode
NDIS_STRING             gForceCompatValueName = NDIS_STRING_CONST("ForceCompatibilityMode");

#if DBG
// Boolean to force all adapters into compatibility mode
BOOLEAN                 gAllAdaptersCompat = FALSE;
const PWCHAR            gForceAllCompatPropertyName = L"ForceAllToCompatibilityMode";
#endif

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgProtOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    );

VOID
BrdgProtCloseAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

VOID
BrdgProtStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

VOID
BrdgProtStatusComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

VOID
BrdgProtReceiveComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

VOID
BrdgProtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    );

VOID
BrdgProtUnbindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    );

NDIS_STATUS
BrdgProtPnPEvent(
    IN NDIS_HANDLE              ProtocolBindingContext,
    IN PNET_PNP_EVENT           NetPnPEvent
    );

VOID
BrdgProtUnload(VOID);


UINT
BrdgProtCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Signals the queue-draining threads that there has been a change in the
// adapter list
//
__forceinline
VOID
BrdgProtSignalAdapterListChange()
{
    INT         i;

    for( i = 0; i < KeNumberProcessors; i++ )
    {
        KeSetEvent( &gThreadsCheckAdapters[i], EVENT_INCREMENT, FALSE );
    }
}

//
// Writes an entry to the event log that indicates an error on a specific
// adapter.
//
// Can be used after we have successfully retrieved the adapter's friendly name.
//
__inline
VOID
BrdgProtLogAdapterErrorFriendly(
    IN NDIS_STATUS          ErrorCode,
    IN PADAPT               pAdapt,
    IN NDIS_STATUS          ErrorStatus
    )
{
    PWCHAR                  StringPtr = pAdapt->DeviceDesc.Buffer;
    NdisWriteEventLogEntry( gDriverObject, ErrorCode, 0, 1, &StringPtr, sizeof(NDIS_STATUS), &ErrorStatus );
}

//
// Writes an entry to the event log that indicates an error on a specific
// adapter.
//
// Reports the adapter's device name, so can be used before we have successfully retrieved
// the adapter's friendly name.
//
__inline
VOID
BrdgProtLogAdapterError(
    IN NDIS_STATUS          ErrorCode,
    IN PADAPT               pAdapt,
    IN NDIS_STATUS          ErrorStatus
    )
{
    PWCHAR                  StringPtr = pAdapt->DeviceName.Buffer;
    NdisWriteEventLogEntry( gDriverObject, ErrorCode, 0, 1, &StringPtr, sizeof(NDIS_STATUS), &ErrorStatus );
}

// Removes all references to an adapter from our various tables
__forceinline
VOID
BrdgProtScrubAdapter(
    IN PADAPT               pAdapt
    )
{
    BrdgTblScrubAdapter( pAdapt );
    BrdgCompScrubAdapter( pAdapt );
}

// Returns the number of adapters that are currently bridged.
ULONG
BrdgProtGetAdapterCount()
{
    return gNumAdapters;
}


// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgProtDriverInit()
/*++

Routine Description:

    Initialization routine for the protocol section.
    Must be called at PASSIVE level because we call NdisRegisterProtocol().

Arguments:

    None

Return Value:

    STATUS_SUCCESS to continue initialization or an error
    code to abort driver startup

--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS   ProtChars;
    NDIS_STATUS                     NdisStatus;
    NDIS_STRING                     Name;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Initialize locks
    NdisInitializeReadWriteLock( &gAdapterListLock );
    NdisInitializeReadWriteLock( &gAdapterCharacteristicsLock );

    //
    // Register the protocol.
    //
    NdisZeroMemory(&ProtChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    ProtChars.MajorNdisVersion = 5;
    ProtChars.MinorNdisVersion = 0;

    //
    // Make sure the protocol-name matches the service-name under which this protocol is installed.
    // This is needed to ensure that NDIS can correctly determine the binding and call us to bind
    // to miniports below.
    //
    NdisInitUnicodeString(&Name, PROTOCOL_NAME);
    ProtChars.Name = Name;
    ProtChars.OpenAdapterCompleteHandler = BrdgProtOpenAdapterComplete;
    ProtChars.CloseAdapterCompleteHandler = BrdgProtCloseAdapterComplete;
    ProtChars.RequestCompleteHandler = BrdgProtRequestComplete;
    ProtChars.ReceiveCompleteHandler = BrdgProtReceiveComplete;
    ProtChars.StatusHandler = BrdgProtStatus;
    ProtChars.StatusCompleteHandler = BrdgProtStatusComplete;
    ProtChars.BindAdapterHandler = BrdgProtBindAdapter;
    ProtChars.UnbindAdapterHandler = BrdgProtUnbindAdapter;
    ProtChars.PnPEventHandler = BrdgProtPnPEvent;
    ProtChars.UnloadHandler = BrdgProtUnload;
    ProtChars.CoReceivePacketHandler = BrdgProtCoReceive;

    //
    // These entry points are provided by the forwarding engine
    //
    ProtChars.ReceiveHandler = BrdgFwdReceive;
    ProtChars.TransferDataCompleteHandler = BrdgFwdTransferComplete;
    ProtChars.ReceivePacketHandler = BrdgFwdReceivePacket;
    ProtChars.SendCompleteHandler = BrdgFwdSendComplete;

    // Register ourselves
    NdisRegisterProtocol(&NdisStatus,
                         &gProtHandle,
                         &ProtChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        // This is a fatal error. Log it.
        NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED, 0, 0, NULL,
                                sizeof(NDIS_STATUS), &NdisStatus );
        DBGPRINT(PROT, ("Failed to register the protocol driver with NDIS: %08x\n", NdisStatus));
        return STATUS_UNSUCCESSFUL;
    }

#if DBG
    {
        NTSTATUS        Status;
        ULONG           Value;

        // Check if we're supposed to force all adapters into compat mode
        Status = BrdgReadRegDWord( &gRegistryPath, gForceAllCompatPropertyName, &Value );

        if( (Status == STATUS_SUCCESS) && (Value != 0L) )
        {
            DBGPRINT(COMPAT, ("FORCING ALL ADAPTERS TO COMPATIBILITY MODE!\n"));
            gAllAdaptersCompat = TRUE;
        }
    }
#endif

    return STATUS_SUCCESS;
}

VOID
BrdgProtRequestComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_REQUEST       NdisRequest,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion handler for the previously posted request.

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure

    NdisRequest             The posted request (this should actually
                            be a pointer to an NDIS_REQUEST_BETTER
                            structure)

    Status                  Completion status

Return Value:

    None

--*/
{
    PNDIS_REQUEST_BETTER    pRequest = (PNDIS_REQUEST_BETTER)NdisRequest;

    // Communicate final status to blocked caller
    pRequest->Status = Status;

    //
    // Call the completion function if there is one.
    // Having a completion function and blocking against the
    // event are mutually exclusive, not least because the
    // completion function may free the memory block
    // holding the event.
    //
    if( pRequest->pFunc != NULL )
    {
        (*pRequest->pFunc)(pRequest, pRequest->FuncArg);
    }
    else
    {
        NdisSetEvent( &pRequest->Event );
    }
}

NDIS_STATUS
BrdgProtDoRequest(
    NDIS_HANDLE             BindingHandle,
    BOOLEAN                 bSet,
    NDIS_OID                Oid,
    PVOID                   pBuffer,
    UINT                    BufferSize
    )
/*++

Routine Description:

    Calls NdisRequest to retrieve or set information from an underlying NIC,
    and blocks until the call completes.

    Must be called at PASSIVE level because we wait on an event.

Arguments:

    BindingHandle           Handle to the NIC
    bSet                    TRUE == set info, FALSE == query info
    Oid                     Request code
    pBuffer                 Output buffer
    BufferSize              Size of output buffer


Return Value:

    Status of the request

--*/
{
    NDIS_STATUS             Status;
    NDIS_REQUEST_BETTER     Request;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    Request.Request.RequestType = bSet ? NdisRequestSetInformation : NdisRequestQueryInformation;
    Request.Request.DATA.QUERY_INFORMATION.Oid = Oid ;
    Request.Request.DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
    Request.Request.DATA.QUERY_INFORMATION.InformationBufferLength = BufferSize;

    NdisInitializeEvent( &Request.Event );
    NdisResetEvent( &Request.Event );
    Request.pFunc = NULL;
    Request.FuncArg = NULL;

    NdisRequest( &Status, BindingHandle, &Request.Request);

    if ( Status == NDIS_STATUS_PENDING )
    {
        NdisWaitEvent( &Request.Event, 0 /*Wait forever*/ );
        Status = Request.Status;
    }

    return Status;
}

VOID
BrdgProtCleanup()
/*++

Routine Description:

    Called during driver unload to do an orderly shutdown

    This function is guaranteed to be called exactly once

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_STATUS     NdisStatus;

    // Deregister ourselves as a protocol. This will cause calls to BrdgProtUnbindAdapter
    // for all open adapters.
    if (gProtHandle != NULL)
    {
        NDIS_HANDLE     TmpHandle = gProtHandle;

        gProtHandle = NULL;
        NdisDeregisterProtocol(&NdisStatus, TmpHandle);
        SAFEASSERT( NdisStatus == NDIS_STATUS_SUCCESS );
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgProtUnload(VOID)
{
    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);
    BrdgShutdown();
}

NDIS_STATUS
BrdgProtCompleteBindAdapter(
    IN PADAPT                   pAdapt
    )
/*++

Routine Description:

    Called by BrdgProtOpenAdapterComplete to complete the process of binding
    to an underlying NIC

    Must be called at < DISPATCH_LEVEL because we call BrdgMiniInstantiateMiniport().

Arguments:

    pAdapt                      The adapter to finish setting up

Return Value:

    Status of the operation. If the return code is != NDIS_STATUS_SUCCESS, the binding
    is aborted and this adapter is not used again. Any error must be logged since it
    causes us to fail to bind to an adapter.

--*/
{
    NDIS_STATUS                 Status;
    LOCK_STATE                  LockState;

    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);

    //
    // Query the adapter's friendly name.
    //
    Status = NdisQueryAdapterInstanceName(&pAdapt->DeviceDesc, pAdapt->BindingHandle);

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // We failed.
        BrdgProtLogAdapterError( EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Failed to get an adapter's friendly name: %08x\n", Status));
        return Status;
    }

    //
    // Get the adapter's media state (connected / disconnected)
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_GEN_MEDIA_CONNECT_STATUS,
                                &pAdapt->MediaState, sizeof(pAdapt->MediaState) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Some old crummy drivers don't support this OID
        pAdapt->MediaState = NdisMediaStateConnected;
    }

    //
    // Get the adapter's link speed
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_GEN_LINK_SPEED,
                                &pAdapt->LinkSpeed, sizeof(pAdapt->LinkSpeed) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Couldn't get an adapter's link speed: %08x\n", Status));
        return Status;
    }

    //
    // Get the adapter's MAC address
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_802_3_PERMANENT_ADDRESS,
                                &pAdapt->MACAddr, sizeof(pAdapt->MACAddr) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Couldn't get an adapter's MAC address: %08x\n", Status));
        return Status;
    }

    //
    // Get the adapter's physical medium
    //
    Status = BrdgProtDoRequest( pAdapt->BindingHandle, FALSE/*Query*/, OID_GEN_PHYSICAL_MEDIUM,
                                &pAdapt->PhysicalMedium, sizeof(pAdapt->PhysicalMedium) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Most drivers don't actually support OID_GEN_PHYSICAL_MEDIUM yet. Fall back on
        // NO_MEDIUM when the driver can't report anything.
        pAdapt->PhysicalMedium = BRIDGE_NO_MEDIUM;
    }


    //
    // Give the miniport section a look at this adapter so it can set its MAC address
    //
    BrdgMiniInitFromAdapter( pAdapt );

    //
    // If pAdapt->bCompatibilityMode is already TRUE, it means that we found a reg
    // key during the initial bind phase that forces this adapter to compatibility mode
    // or that we force all adapters into compatibility mode.
    //
    if( !pAdapt->bCompatibilityMode )
    {
        ULONG       Filter = NDIS_PACKET_TYPE_PROMISCUOUS;

        // Attempt to put the adapter into promiscuous receive mode. If it fails this OID,
        // we put the adapter into compatibility mode

        if( BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER,
                               &Filter, sizeof(Filter) ) != NDIS_STATUS_SUCCESS )
        {
            // The adapter doesn't seem to be able to do promiscuous mode. Put it in
            // compatibility mode.
            DBGPRINT(PROT, ("Adapter %p failed to go promiscuous; putting it in COMPATIBILITY MODE\n", pAdapt));
            pAdapt->bCompatibilityMode = TRUE;
        }
        else
        {
            // Set the filter back to nothing for now
            Filter = 0L;
            BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER, &Filter, sizeof(Filter) );
        }
    }


    // If the STA isn't active, make this adapter live now.
    if( gDisableSTA )
    {
        pAdapt->State = Forwarding;

        // Put the adapter into its initial state
        BrdgProtDoAdapterStateChange( pAdapt );
    }
    // Else we initialize the adapter's STA functions below

    //
    // Link the adapter into the queue
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, TRUE /* Write access */, &LockState );

    pAdapt->Next = gAdapterList;
    gAdapterList = pAdapt;
    gNumAdapters++;

    // Must update this inside the write lock on the adapter list
    if( pAdapt->bCompatibilityMode )
    {
        gCompatAdaptersExist = TRUE;
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    if (g_fIsTcpIpLoaded == TRUE)
    {
        // Inform the 1394 miniport that tcpip has been loaded
        BrdgSetMiniportsToBridgeMode(pAdapt, TRUE);
    }

    if( ! gDisableSTA )
    {
        //
        // Let the STA section initialize this adapter. This has to be done after the adapter
        // has been linked into the global list.
        //
        BrdgSTAInitializeAdapter( pAdapt );
    }

    // Tell the draining threads to take notice of the new adapter
    BrdgProtSignalAdapterListChange();

    // Update the miniport's idea of our virtual media state and link speed
    BrdgMiniUpdateCharacteristics( TRUE /*Is a connectivity change*/ );

    // Tell user-mode code about the new adapter
    BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyAddAdapter );

    // If we haven't yet called the miniport's InstantiateMiniport() function, do it now, since we have
    // at least one adapter in the list
    if( InterlockedCompareExchange(&gHaveInitedMiniport, 1L, 0L) == 0L )
    {
        // Miniport wasn't previously initialized
        BrdgMiniInstantiateMiniport();
    }

    // We're all done, so let people use the adapter
    pAdapt->bResetting = FALSE;

    DBGPRINT(PROT, ("BOUND SUCCESSFULLY to adapter %ws\n", pAdapt->DeviceDesc.Buffer));

    return NDIS_STATUS_SUCCESS;
}

VOID
BrdgProtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )
/*++

Routine Description:

    Called by NDIS to bind to a miniport below.

    Must be called at PASSIVE_LEVEL because we call NdisOpenAdapter().

Arguments:

    Status          - Return status of bind here.
    BindContext     - Can be passed to NdisCompleteBindAdapter if this call is pended.
    DeviceName      - Device name to bind to. This is passed to NdisOpenAdapter.
    SystemSpecific1 - Can be passed to NdisOpenProtocolConfiguration to read per-binding information
    SystemSpecific2 - Unused for NDIS 5.0.


Return Value:

    NDIS_STATUS_PENDING if this call is pended. In this case call NdisCompleteBindAdapter to complete.
    Anything else completes this call synchronously

--*/
{
    PADAPT                          pAdapt = NULL;
    NDIS_STATUS                     Sts;
    UINT                            MediumIndex;
    LONG                            AdaptSize;
    NDIS_HANDLE                     ConfigHandle;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    // Don't do any new binds if we're shutting down
    if( gShuttingDown )
    {
        DBGPRINT(PROT, ("REFUSING to bind to new adapter during shutdown!\n"));
        *Status = NDIS_STATUS_NOT_ACCEPTED;
        return;
    }

    // Make sure we're not being asked to bind to ourselves!
    if( BrdgMiniIsBridgeDeviceName(DeviceName) )
    {
        DBGPRINT(PROT, ("REFUSING to bind to SELF!\n"));
        *Status = NDIS_STATUS_NOT_ACCEPTED;
        return;
    }

    //
    // Allocate memory for the Adapter structure.
    //
    AdaptSize = sizeof(ADAPT) + DeviceName->MaximumLength;
    NdisAllocateMemoryWithTag(&pAdapt, AdaptSize, 'gdrB');

    if (pAdapt == NULL)
    {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    //
    // Initialize the adapter structure
    //
    NdisZeroMemory(pAdapt, AdaptSize);
    pAdapt->AdaptSize = AdaptSize;
    pAdapt->DeviceName.Buffer = (WCHAR *)((PUCHAR)pAdapt + sizeof(ADAPT));
    pAdapt->DeviceName.MaximumLength = DeviceName->MaximumLength;
    pAdapt->DeviceName.Length = DeviceName->Length;
    NdisMoveMemory(pAdapt->DeviceName.Buffer, DeviceName->Buffer, DeviceName->Length);
    NdisInitializeEvent( &pAdapt->Event );
    NdisResetEvent( &pAdapt->Event );
    NdisAllocateSpinLock( &pAdapt->QueueLock );
    BrdgInitializeSingleList( &pAdapt->Queue );
    pAdapt->bServiceInProgress = FALSE;
    pAdapt->bSTAInited = FALSE;

    // Start out with this TRUE so no one can use the adapter until we're done
    // initializing it
    pAdapt->bResetting = TRUE;

    // Zero out statistics
    pAdapt->SentFrames.LowPart = pAdapt->SentFrames.HighPart = 0L;
    pAdapt->SentBytes.LowPart = pAdapt->SentBytes.HighPart = 0L;
    pAdapt->SentLocalFrames.LowPart = pAdapt->SentLocalFrames.HighPart = 0L;
    pAdapt->SentLocalBytes.LowPart = pAdapt->SentLocalBytes.HighPart = 0L;
    pAdapt->ReceivedFrames.LowPart = pAdapt->ReceivedFrames.HighPart = 0L;
    pAdapt->ReceivedBytes.LowPart = pAdapt->ReceivedBytes.HighPart = 0L;

    // The adapter starts off disabled
    pAdapt->State = Disabled;

    // Initialize quota information
    BrdgBufInitializeQuota( &pAdapt->Quota );

    BrdgInitializeWaitRef( &pAdapt->Refcount, FALSE );
    BrdgInitializeWaitRef( &pAdapt->QueueRefcount, FALSE );

    KeInitializeEvent( &pAdapt->QueueEvent, SynchronizationEvent, FALSE );

    pAdapt->bCompatibilityMode = FALSE;

#if DBG
    if( gAllAdaptersCompat )
    {
        pAdapt->bCompatibilityMode = TRUE;
    }
    else
    {
#endif
        // Check if a registry entry forces this adapter to compatibility mode
        NdisOpenProtocolConfiguration( Status, &ConfigHandle, SystemSpecific1);

        if( *Status == NDIS_STATUS_SUCCESS )
        {
            PNDIS_CONFIGURATION_PARAMETER   pncp;

            NdisReadConfiguration( Status, &pncp, ConfigHandle, &gForceCompatValueName, NdisParameterHexInteger );

            if( (*Status == NDIS_STATUS_SUCCESS) && (pncp->ParameterData.IntegerData != 0L ) )
            {
                DBGPRINT(PROT, ("Forcing adapter into COMPATIBILITY MODE as per registry entry\n"));
                pAdapt->bCompatibilityMode = TRUE;
            }

            NdisCloseConfiguration( ConfigHandle );
        }
        else
        {
            DBGPRINT(PROT, ("Failed to open protocol configuration for an adapter: %8x\n", *Status));
        }
#if DBG
    }
#endif

    //
    // Now open the adapter below
    //
    NdisOpenAdapter(Status,
                    &Sts,
                    &pAdapt->BindingHandle,
                    &MediumIndex,
                    gMediumArray,
                    sizeof(gMediumArray)/sizeof(NDIS_MEDIUM),
                    gProtHandle,
                    pAdapt,
                    DeviceName,
                    0,
                    NULL);

    if ( *Status == NDIS_STATUS_PENDING )
    {
        // The bind will complete later in BrdgProtOpenAdapterComplete
    }
    else
    {
        // Complete the bind right away
        BrdgProtOpenAdapterComplete( (NDIS_HANDLE)pAdapt, *Status, *Status );
    }
}

VOID
BrdgProtOpenAdapterComplete(
    IN  NDIS_HANDLE          ProtocolBindingContext,
    IN  NDIS_STATUS          Status,
    IN  NDIS_STATUS          OpenErrorStatus
    )
/*++

Routine Description:

    Completion routine for NdisOpenAdapter issued from within the BrdgProtBindAdapter. Simply
    unblock the caller.

    Must be called at PASSIVE_LEVEL because we wait on an event.

Arguments:

    ProtocolBindingContext  Pointer to the adapter
    Status                  Status of the NdisOpenAdapter call
    OpenErrorStatus         Secondary status(ignored by us).

Return Value:

    None

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    if( Status != NDIS_STATUS_SUCCESS )
    {
        // Log this error since it means we can't use the adapter.
        BrdgProtLogAdapterError( EVENT_BRIDGE_ADAPTER_BIND_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("BIND FAILURE: Failed to open adapter: %08x, %08x\n", Status, OpenErrorStatus));
        NdisFreeMemory( pAdapt, pAdapt->AdaptSize, 0 );
    }
    else
    {
        // BrdgProtCompleteBindAdapter must log any fatal errors
        Status = BrdgProtCompleteBindAdapter( pAdapt );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(PROT, ("BIND FAILURE: Couldn't complete adapter initialization: %08x\n", Status));

            BrdgSetMiniportsToBridgeMode (pAdapt, FALSE);  // Turn bridge mode off on pAdapt

            NdisCloseAdapter( &Status, pAdapt->BindingHandle );

            if ( Status == NDIS_STATUS_PENDING )
            {
                NdisWaitEvent( &pAdapt->Event, 0/*Wait forever*/ );
            }

            NdisFreeMemory( pAdapt, pAdapt->AdaptSize, 0 );
        }
    }
}

VOID
BrdgProtUnbindAdapter(
    OUT PNDIS_STATUS        pStatus,
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         UnbindContext
    )
/*++

Routine Description:

    Called by NDIS when we are required to unbind to the adapter below.

    Must be called at PASSIVE_LEVEL because we wait on an event

Arguments:

    pStatus                  Placeholder for return status
    ProtocolBindingContext  Pointer to the adapter structure
    UnbindContext           Context for NdisUnbindComplete() if this pends

Return Value:

    None

--*/
{
    PADAPT                  *pTmp, pAnAdapt, pAdapt =(PADAPT)ProtocolBindingContext;
    LOCK_STATE              LockState;
    ULONG                   Filter;
    BOOLEAN                 bFound = FALSE, bCompatAdaptersExist;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);

    DBGPRINT(PROT, ("UNBINDING Adapter %p :\n", pAdapt));
    DBGPRINT(PROT, ("%ws\n", pAdapt->DeviceDesc.Buffer));

    // Set the Underlying miniports to Off
    BrdgSetMiniportsToBridgeMode(pAdapt,FALSE);

    // Shut off all packet reception as the first order of business
    Filter = 0L;
    BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER,
                       &Filter, sizeof(Filter) );

    // Take this adapter out of the queue
    NdisAcquireReadWriteLock( &gAdapterListLock, TRUE /* Write access */, &LockState );

    for (pTmp = &gAdapterList; *pTmp != NULL; pTmp = &(*pTmp)->Next)
    {
        if (*pTmp == pAdapt)
        {
            *pTmp = pAdapt->Next;
            bFound = TRUE;
            break;
        }
    }

    gNumAdapters--;
    SAFEASSERT ( bFound );

    // Find out if there are any compat-mode adapters left
    bCompatAdaptersExist = FALSE;

    for( pAnAdapt = gAdapterList; pAnAdapt != NULL; pAnAdapt = pAnAdapt->Next)
    {
        if( pAnAdapt->bCompatibilityMode )
        {
            bCompatAdaptersExist = TRUE;
        }
    }

    // Must update this inside the write lock
    gCompatAdaptersExist = bCompatAdaptersExist;

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    //
    // Now no code will attempt to target this adapter for floods.
    //

    // Scrub this adapter from our tables so no one will attempt to target it.
    BrdgProtScrubAdapter( pAdapt );

    // Stop packet forwarding on this adapter
    if( gDisableSTA )
    {
        pAdapt->State = Disabled;
    }
    else
    {
        // Have the STA shut down its operations on this adapter
        BrdgSTAShutdownAdapter( pAdapt );
    }

    //
    // Prevent new packets from being processed on this adapter
    //
    BrdgBlockWaitRef( &pAdapt->Refcount );

    //
    // Wait for this adapter's queue to be drained by the worker threads.
    //
    BrdgShutdownWaitRefOnce( &pAdapt->QueueRefcount );

    //
    // Signal the change in adapter list to the queue-draining threads.
    // This will remove this adapter from the threads' list of queues they block against.
    //
    BrdgProtSignalAdapterListChange();

    //
    // Must wait for adapter refcount to go to zero before closing down the adapter.
    // This doesn't mean all requests have completed, just that none of our code is
    // holding this adapter's pointer anymore.
    //
    // Our receive functions bump up the refcount while they're processing an
    // inbound packet, so when the refcount drops to zero we should also have completed
    // any in-progress handling of received packets.
    //
    // The queue-draining threads also increment the refcount for adapters they are
    // using, so this wait is our guarantee that all threads have stopped using this
    // adapter as well.
    //
    BrdgShutdownWaitRefOnce( &pAdapt->Refcount );
    SAFEASSERT( pAdapt->Refcount.Refcount == 0L );

    //
    // Close this binding. This will pend till all NDIS requests in progress are
    // completed.
    //
    NdisResetEvent( &pAdapt->Event );
    NdisCloseAdapter( pStatus, pAdapt->BindingHandle );

    if ( *pStatus == NDIS_STATUS_PENDING )
    {
        NdisWaitEvent( &pAdapt->Event, 0 /*Wait forever*/ );
    }

    // Tell user-mode code the adapter left (this call should not attempt to read from
    // pAdapt)
    BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyRemoveAdapter );

    // Free adapter resources
    if (pAdapt->DeviceDesc.Buffer != NULL)
    {
        NdisFreeMemory(pAdapt->DeviceDesc.Buffer, pAdapt->DeviceDesc.MaximumLength, 0);
    }

    NdisFreeMemory(pAdapt, pAdapt->AdaptSize, 0);

    DBGPRINT(PROT, ("Unbind complete.\n"));

    // Have the miniport update in light of the missing adapter
    BrdgMiniUpdateCharacteristics( TRUE /*Is a connectivity change*/ );

    *pStatus = NDIS_STATUS_SUCCESS;
}

VOID
BrdgProtDoAdapterStateChange(
    IN PADAPT                   pAdapt
    )
/*++

Routine Description:

    Adjusts an adapter's packet filter and multicast list based on its current state.

    If the adapter is Forwarding or Learning, the adapter is put in promiscuous mode so
    all packets are received.

    If the adapter is Blocking or Listening, the adapter is set to receive only the STA
    multicast packets.

    Errors are logged since this is a vital operation

Arguments:

    pAdapt                  The adapter

Return Value:

    Status code of the operation

--*/

{
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    ULONG                   Filter;
    PORT_STATE              State = pAdapt->State;      // Freeze this value
    BOOLEAN                 bReceiveAllMode = (BOOLEAN)((State == Forwarding) || (State == Learning));

    if( ! bReceiveAllMode )
    {
        //
        // Even if we're not forwarding packets off this interface, we still need to listen
        // for Spanning Tree Algorithm traffic
        //
        Status = BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_802_3_MULTICAST_LIST,
                                    STA_MAC_ADDR, sizeof(STA_MAC_ADDR) );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_FILTER_FAILED, pAdapt, Status );
            DBGPRINT(PROT, ("Failed to set adapter %p's multicast list: %08x\n", pAdapt, Status));
            return;
        }
    }

    // Now set the packet filter appropriately
    if( pAdapt->bCompatibilityMode )
    {
        //
        // Compatibility adapters can't do promiscuous properly. Our compatibility
        // code relies only on them receiving traffic unicast to this machine, as
        // well as all broadcast and multicast traffic.
        //
        Filter = bReceiveAllMode ? NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_ALL_MULTICAST : NDIS_PACKET_TYPE_MULTICAST;
    }
    else
    {
        Filter = bReceiveAllMode ? NDIS_PACKET_TYPE_PROMISCUOUS : NDIS_PACKET_TYPE_MULTICAST;
    }

    Status =  BrdgProtDoRequest( pAdapt->BindingHandle, TRUE/*Set*/, OID_GEN_CURRENT_PACKET_FILTER,
                                 &Filter, sizeof(Filter) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        BrdgProtLogAdapterErrorFriendly( EVENT_BRIDGE_ADAPTER_FILTER_FAILED, pAdapt, Status );
        DBGPRINT(PROT, ("Failed to set adapter %p's packet filter: %08x\n", pAdapt, Status));
    }

    // Tell the miniport about the change so it can change the bridge's characteristics if it wants.
    BrdgMiniUpdateCharacteristics( FALSE /*Not a physical connectivity change*/ );
}

VOID
BrdgProtCloseAdapterComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion for the CloseAdapter call. Just unblocks waiting code

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    Status                  Completion status

Return Value:

    None.

--*/
{
    PADAPT  pAdapt =(PADAPT)ProtocolBindingContext;
    NdisSetEvent( &pAdapt->Event );
}

VOID
BrdgProtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of received buffers.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    None

--*/
{
    //
    // Nothing to do here
    //
}


VOID
BrdgProtStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Handles status indications from underlying adapters

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{
    PADAPT    pAdapt =(PADAPT)ProtocolBindingContext;

    switch( GeneralStatus )
    {
    case NDIS_STATUS_MEDIA_DISCONNECT:
    case NDIS_STATUS_MEDIA_CONNECT:
        {
            if( pAdapt != NULL )
            {
                LOCK_STATE      LockState;

                ULONG MediaState = (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) ?
                                    NdisMediaStateConnected :
                                    NdisMediaStateDisconnected;

                if( GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT )
                {
                    // Scrub the disconnected adapter from our tables. We will
                    // have to relearn its hosts
                    BrdgProtScrubAdapter( pAdapt );
                }

                if( ! gDisableSTA )
                {
                    // The STA needs to know when adapters connect and disconnect
                    if( MediaState == NdisMediaStateConnected )
                    {
                        BrdgSTAEnableAdapter( pAdapt );
                    }
                    else
                    {
                        BrdgSTADisableAdapter( pAdapt );
                    }
                }

                // A global lock is used for adapter characteristics, since they must be read
                // all at once by the miniport
                NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, TRUE /*Write access*/, &LockState );
                pAdapt->MediaState = MediaState;
                NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

                // See if this makes any difference to our overall state
                BrdgMiniUpdateCharacteristics( TRUE /*Is a connectivity change*/ );

                // Tell user-mode code that the adapter media state changed
                BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyMediaStateChange );
            }
            else
            {
                DBGPRINT(PROT, ("BrdgProtStatus called for link status with NULL adapter!\n"));
            }
        }
        break;

    case NDIS_STATUS_LINK_SPEED_CHANGE:
        {
            if( (pAdapt != NULL) &&
                (StatusBuffer != NULL) &&
                (StatusBufferSize >= sizeof(ULONG)) )
            {
                LOCK_STATE      LockState;

                // A global lock is used for adapter characteristics, since they must be read
                // all at once by the miniport
                NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, TRUE /*Write access*/, &LockState );
                pAdapt->LinkSpeed = *((ULONG*)StatusBuffer);
                NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

                if( ! gDisableSTA )
                {
                    // Tell the STA about the change so it can tweak the cost of this link
                    BrdgSTAUpdateAdapterCost( pAdapt, *((ULONG*)StatusBuffer) );
                }

                // See if this makes any difference to our overall state
                BrdgMiniUpdateCharacteristics( FALSE /*Not a connectivity change*/ );

                // Tell user-mode code that the adapter speed changed
                BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyLinkSpeedChange );
            }
            else
            {
                DBGPRINT(PROT, ("BrdgProtStatus called for link speed with bad params!\n"));
            }
        }
        break;

    case NDIS_STATUS_RESET_START:
        {
            DBGPRINT(PROT, ("Adapter %p RESET START\n", pAdapt));
            pAdapt->bResetting = TRUE;
        }
        break;

    case NDIS_STATUS_RESET_END:
        {
            DBGPRINT(PROT, ("Adapter %p RESET END\n", pAdapt));
            pAdapt->bResetting = FALSE;
        }
        break;

    default:
        {
            DBGPRINT(PROT, ("Unhandled status indication: %08x\n", GeneralStatus));
        }
        break;
    }
}


VOID
BrdgProtStatusComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext
    )
/*++

Routine Description:

    NDIS entry point called when a status indication completes.
    We do nothing in response to this.

Arguments:

    ProtocolBindingContext  The adapter involved

Return Value:

    None

--*/
{
    //
    // Nothing to do here
    //
}

VOID
BrdgProtInstantiateMiniport(
    IN PVOID        unused
    )
/*++

Routine Description:

    Deferrable function to call BrdgMiniInstantiateMiniport(), which must run
    at low IRQL

    Must run at < DISPATCH_LEVEL

Arguments:

    unused          Unused

Return Value:

    None

--*/
{
    SAFEASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    BrdgMiniInstantiateMiniport();
}

NDIS_STATUS
BrdgProtPnPEvent(
    IN NDIS_HANDLE      ProtocolBindingContext,
    IN PNET_PNP_EVENT   NetPnPEvent
    )
/*++

Routine Description:

    NDIS entry point called to indicate a PnP event to us

Arguments:

    ProtocolBindingContext  The adapter involved
    NetPnPEvent             The event

Return Value:

    Our status code in response to the event (should be NDIS_STATUS_SUCCESS or
    NDIS_STATUS_UNSUPPORTED)

--*/
{
    PADAPT          pAdapt = (PADAPT)ProtocolBindingContext;

    switch( NetPnPEvent->NetEvent )
    {
    case NetEventBindsComplete:
    case NetEventSetPower:
    case NetEventQueryPower:
    case NetEventCancelRemoveDevice:
    case NetEventBindList:
    case NetEventQueryRemoveDevice:
    case NetEventPnPCapabilities:
        {
            return NDIS_STATUS_SUCCESS;
        }
        break;

    case NetEventReconfigure:
        {
            if( pAdapt == NULL )
            {
                NDIS_HANDLE         MiniportHandle;

                //
                // A NetEventReconfigure event with a NULL binding context is either a
                // global indication of config changes or a signal from NDIS to restart
                // our miniport (for example, if it got disabled and then re-enabled).
                //
                // We're only interested in the case of a signal to restart our miniport.
                // We'll assume this can only happen after we have initialized it the
                // first time around.
                //
                // This is wierd, I know.
                //

                MiniportHandle = BrdgMiniAcquireMiniport();

                if( gHaveInitedMiniport && (MiniportHandle == NULL) )
                {
                    // Our miniport isn't initialized. Fire it up again.
                    // We can't do this at the high IRQL we're currently at, so defer the function.
                    DBGPRINT(PROT, ("Restarting miniport in response to NULL NetEventReconfigure signal\n"));
                    BrdgDeferFunction( BrdgProtInstantiateMiniport, NULL );
                }

                if( MiniportHandle != NULL )
                {
                    BrdgMiniReleaseMiniport();
                }
            }

            return NDIS_STATUS_SUCCESS;
        }
        break;
    }

    DBGPRINT(PROT, ("Unsupported PnP Code: %i\n", NetPnPEvent->NetEvent));
    return NDIS_STATUS_NOT_SUPPORTED;
}


UINT
BrdgProtCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    NDIS entry point called to indicate packets that are being sent
    on the Co-Ndis path.

Arguments:


Return Value:
    Return 0 as this is a do-nothing function

--*/
{

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgprot.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgprot.h

Abstract:

    Ethernet MAC level bridge.
    Protocol section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgProtDriverInit();

VOID
BrdgProtRequestComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  NDIS_STATUS             Status
    );

VOID
BrdgProtDoAdapterStateChange(
    IN PADAPT                   pAdapt
    );

VOID
BrdgProtCleanup();

ULONG
BrdgProtGetAdapterCount();


// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Controls access to all the adapters' link speed, media state, etc
extern NDIS_RW_LOCK             gAdapterCharacteristicsLock;

// Number of bound adapters. Cannot change while a lock is held on gAdapterListLock
extern ULONG                    gNumAdapters;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgsta.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgsta.h

Abstract:

    Ethernet MAC level bridge
    Spanning-Tree Algorithm header file

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    June 2000 - Original version

--*/

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgSTADriverInit();

VOID
BrdgSTACleanup();

VOID
BrdgSTADeferredInit(
    IN PUCHAR           pBridgeMACAddress
    );

VOID
BrdgSTAEnableAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAInitializeAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTADisableAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAShutdownAdapter(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAUpdateAdapterCost(
    IN PADAPT           pAdapt,
    ULONG               LinkSpeed
    );

VOID
BrdgSTAReceivePacket(
    IN PADAPT           pAdapt,
    IN PNDIS_PACKET     pPacket
    );

VOID
BrdgSTAGetAdapterSTAInfo(
    IN PADAPT                   pAdapt,
    PBRIDGE_STA_ADAPTER_INFO    pInfo
    );

VOID
BrdgSTAGetSTAInfo(
    PBRIDGE_STA_GLOBAL_INFO     pInfo
    );

VOID
BrdgSTACancelTimersGPO();

VOID
BrdgSTARestartTimersGPO();

VOID
BrdgSTAResetSTAInfoGPO();

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// If TRUE, the STA is disabled for the lifetime of the bridge.
// This global does not change after initialization time.
extern BOOLEAN          gDisableSTA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgsta.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    brdgsta.c

Abstract:

    Ethernet MAC level bridge.
    Spanning Tree Algorithm section

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    June 2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgsta.h"

#include "brdgmini.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgctl.h"

// ===========================================================================
//
// TYPES
//
// ===========================================================================

// BPDU types
typedef enum
{
    ConfigBPDU,
    TopologyChangeBPDU
} BPDU_TYPE;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

// These values measured in STA units (1/256ths of a second)
#define DEFAULT_MAX_AGE                 (8 * 256)       // 8 seconds
#define DEFAULT_HELLO_TIME              (2 * 256)       // 2 seconds
#define DEFAULT_FORWARD_DELAY           (5 * 256)       // 5 seconds
#define MESSAGE_AGE_INCREMENT           1               // 1 STA time unit

// These values measured in milliseconds
#define HOLD_TIMER_PERIOD               (1 * 1000)      // 1 second in milliseconds

// Normal size, in bytes, of a full-size (non-TCN) STA packet
#define CONFIG_BPDU_PACKET_SIZE         35

// Size, in bytes, of a TCN STA packet
#define TCN_BPDU_PACKET_SIZE            4

// The name of the registry entry that causes the STA to be disabled
const PWCHAR                            gDisableSTAParameterName = L"DisableSTA";

// The size of an 802.3 header with LLC
#define _802_3_HEADER_SIZE              17

// Value to be added to port IDs; must leave the bottom byte clear to store
// actual port ID
#define PORT_PRIORITY                   0x8000

// ===========================================================================
//
// STRUCTURES
//
// ===========================================================================

//
// This structure holds the information for a complete BPDU (although
// it is not laid out as the BPDU is actually transmitted on the wire)
//
typedef struct _CONFIG_BPDU
{
    BPDU_TYPE           Type;
    UCHAR               RootID[BRIDGE_ID_LEN];
    PATH_COST           RootCost;
    UCHAR               BridgeID[BRIDGE_ID_LEN];
    PORT_ID             PortID;
    STA_TIME            MessageAge;
    STA_TIME            MaxAge;
    STA_TIME            HelloTime;
    STA_TIME            ForwardDelay;
    BOOLEAN             bTopologyChangeAck;
    BOOLEAN             bTopologyChange;
} CONFIG_BPDU, *PCONFIG_BPDU;

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Global spin lock protects all STA data accesses (for data stored in adapters
// as well as globals)
NDIS_SPIN_LOCK          gSTALock;

// The bridge we believe is the root bridge
UCHAR                   gDesignatedRootID[BRIDGE_ID_LEN];

// Our own unique ID
UCHAR                   gOurID[BRIDGE_ID_LEN];

// Whether our ID has been set yet
BOOLEAN                 gHaveID = FALSE;

// Our cost to reach the root
PATH_COST               gRootCost = 0;

// Our root port (adapter)
PADAPT                  gRootAdapter = NULL;

// Whether we have detected a topology change
BOOLEAN                 gTopologyChangeDetected = FALSE;

// Whether we tell other bridges that the topology has changed
BOOLEAN                 gTopologyChange = FALSE;

// Current bridge maximum message age
STA_TIME                gMaxAge = DEFAULT_MAX_AGE;

// Current bridge Hello time
STA_TIME                gHelloTime = DEFAULT_HELLO_TIME;

// Current bridge forward delay
STA_TIME                gForwardDelay = DEFAULT_FORWARD_DELAY;

// Every adapter must have a unique ID number, but there is no requirement that
// that number be unique over the lifetime of the bridge. This array is used as
// a bitfield that records which IDs are in use.
ULONG                   gUsedPortIDs[MAX_ADAPTERS / sizeof(ULONG) / 8];

//
// Timers
//
BRIDGE_TIMER            gTopologyChangeTimer;
BRIDGE_TIMER            gTopologyChangeNotificationTimer;
BRIDGE_TIMER            gHelloTimer;

// TRUE if the STA is disabled for the lifetime of the bridge
BOOLEAN                 gDisableSTA = FALSE;

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

VOID
BrdgSTARootSelection();

VOID
BrdgSTADesignatedPortSelection();

BOOLEAN
BrdgSTAPortStateSelection();

VOID
BrdgSTAGenerateConfigBPDUs();

VOID
BrdgSTABecomeDesignatedPort(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAProcessTCNBPDU(
    IN PADAPT           pAdapt
    );

VOID
BrdgSTAProcessConfigBPDU(
    IN PADAPT       pAdapt,
    IN PCONFIG_BPDU pbpdu
    );

BOOLEAN
BrdgSTATopologyChangeDetected();

VOID
BrdgSTACopyFromPacketToBuffer(
    OUT PUCHAR                      pPacketOut,
    IN ULONG                        BufferSize,
    OUT PULONG                      pWrittenCount,
    IN PNDIS_PACKET                 pPacketIn
    );

VOID
BrdgSTADeferredSetAdapterState(
    IN PVOID                Arg
    );

VOID
BrdgSTAHelloTimerExpiry(
    IN PVOID            Unused
    );

VOID
BrdgSTAMessageAgeTimerExpiry(
    IN PVOID            Context
    );

VOID
BrdgSTAForwardDelayTimerExpiry(
    IN PVOID            Context
    );

VOID
BrdgSTATopologyChangeNotificationTimerExpiry(
    IN PVOID            Unused
    );

VOID
BrdgSTATopologyChangeTimerExpiry(
    IN PVOID            Unused
    );

VOID
BrdgSTAHoldTimerExpiry(
    IN PVOID            Context
    );

VOID
BrdgSTATransmitTCNPacket();

VOID
BrdgSTASetAdapterState(
    IN PADAPT               pAdapt,
    IN PORT_STATE           NewState
    );

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Does a complete re-evaluation of STA info
//
// ASSUMES the caller has acquired gSTALock
//
__forceinline
VOID
BrdgSTAConfigUpdate()
{
    BrdgSTARootSelection();
    BrdgSTADesignatedPortSelection();
}

//
// Sets an NDIS timer using a time expressed in STA units
//
// No requirements on caller-held locks
//
__forceinline
VOID
BrdgSTASetTimerWithSTATime(
    IN PBRIDGE_TIMER    pTimer,
    IN STA_TIME         Time,
    IN BOOLEAN          bRecurring
    )
{
    BrdgSetTimer( pTimer, Time * 1000 / 256, bRecurring );
}

//
// Compares two bridge IDs.
//
//      -1      :       A < B
//      0       :       A == B
//      1       :       A > B
//
// No requirements on caller-held locks
//
__forceinline
INT
BrdgSTABridgeIDCmp(
    IN PUCHAR           pIDa,
    IN PUCHAR           pIDb
    )
{
    UINT        i;

    for( i = 0; i < BRIDGE_ID_LEN; i++ )
    {
        if( pIDa[i] > pIDb[i] )
        {
            return 1;
        }
        else if( pIDa[i] < pIDb[i] )
        {
            return -1;
        }
    }

    return 0;
}

//
// Returns whether or not we currently believe ourselves to be the root
// bridge.
//
// ASSUMES the caller has acquired gSTALock
//
__forceinline
BOOLEAN
BrdgSTAWeAreRoot()
{
    SAFEASSERT( gHaveID );
    return (BOOLEAN)(BrdgSTABridgeIDCmp( gOurID, gDesignatedRootID ) == 0);
}

//
// Copies a bridge ID from pIDSrc to pIDDest.
//
// No requirements on caller-held locks
//
__forceinline
VOID
BrdgSTACopyID(
    IN PUCHAR           pIDDest,
    IN PUCHAR           pIDSrc
    )
{
    UINT        i;

    for( i = 0; i < BRIDGE_ID_LEN; i++ )
    {
        pIDDest[i] = pIDSrc[i];
    }
}

//
// Calculates the STA path cost from an adapter's link speed.
// Follows IEEE 802.1D-1990 recommendation that the link cost be set
// to 1000 / (Speed in Mbits/s).
//
// No requirements on caller-held locks
//
__forceinline
PATH_COST
BrdgSTALinkCostFromLinkSpeed(
    IN ULONG            LinkSpeed
    )
{
    ULONG               retVal;

    // Link speed is reported in units of 100bps
    if( LinkSpeed == 0L )
    {
        // Avoid div by zero and return very high path cost
        DBGPRINT(STA, ("Zero link speed reported\n"));
        retVal = 0xFFFFFFFF;
    }
    else
    {
        retVal = (PATH_COST)(10000000L / LinkSpeed);
    }

    if( retVal == 0L )
    {
        // STA spec calls for path costs to always be at least 1
        return 1L;
    }
    else
    {
        return retVal;
    }
}

//
// Updates the global gTopologyChange flag. When this flag is set,
// we must use a forwarding table timeout value equal to the bridge's
// current forwarding delay. When the flag is not set, we use
// the table's default timeout value.
//
// ASSUMES the caller has acquired gSTALock
//
__forceinline
VOID
BrdgSTAUpdateTopologyChange(
    IN BOOLEAN          NewValue
    )
{
    if( gTopologyChange != NewValue )
    {
        gTopologyChange = NewValue;

        if( gTopologyChange )
        {
            // Convert the forward delay to ms
            BrdgTblSetTimeout( gForwardDelay * 1000 / 256 );
        }
        else
        {
            BrdgTblRevertTimeout();
        }
    }
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgSTAGetAdapterSTAInfo(
    IN PADAPT                   pAdapt,
    PBRIDGE_STA_ADAPTER_INFO    pInfo
    )
/*++

Routine Description:

    Copies STA information for a particular adapter into a structure

    Called to collect information for user-mode components

Arguments:

    pAdapt                      The adapter
    pInfo                       Structure to receive STA information

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NdisAcquireSpinLock( &gSTALock );

    pInfo->ID = pAdapt->STAInfo.ID;
    pInfo->PathCost = pAdapt->STAInfo.PathCost;
    BrdgSTACopyID( pInfo->DesignatedRootID, pAdapt->STAInfo.DesignatedRootID );
    pInfo->DesignatedCost = pAdapt->STAInfo.DesignatedCost;
    BrdgSTACopyID( pInfo->DesignatedBridgeID, pAdapt->STAInfo.DesignatedBridgeID );
    pInfo->DesignatedPort = pAdapt->STAInfo.DesignatedPort;

    NdisReleaseSpinLock( &gSTALock );
}

VOID
BrdgSTAGetSTAInfo(
    PBRIDGE_STA_GLOBAL_INFO     pInfo
    )
/*++

Routine Description:

    Copies global STA information into a structure

    Called to collect information for user-mode components

Arguments:

    pInfo                       Structure to receive STA information

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NdisAcquireSpinLock( &gSTALock );

    SAFEASSERT( gHaveID );

    BrdgSTACopyID( pInfo->OurID, gOurID );
    BrdgSTACopyID( pInfo->DesignatedRootID, gDesignatedRootID );
    pInfo->RootCost = gRootCost;
    pInfo->RootAdapter = (BRIDGE_ADAPTER_HANDLE)gRootAdapter;
    pInfo->bTopologyChangeDetected = gTopologyChangeDetected;
    pInfo->bTopologyChange = gTopologyChange;
    pInfo->MaxAge = gMaxAge;
    pInfo->HelloTime = gHelloTime;
    pInfo->ForwardDelay = gForwardDelay;

    NdisReleaseSpinLock( &gSTALock );
}

VOID
BrdgSTAUpdateAdapterCost(
    IN PADAPT           pAdapt,
    ULONG               LinkSpeed
    )
/*++

Routine Description:

    Updates an adapter's path cost to reflect an updated link speed

Arguments:

    pAdapt              The adapter
    LinkSpeed           The adapter's new link speed

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BOOLEAN             bTransmitTCN = FALSE;

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->bSTAInited )
    {
        pAdapt->STAInfo.PathCost = BrdgSTALinkCostFromLinkSpeed(LinkSpeed);

        // Do a global re-evaluation of STA info
        BrdgSTAConfigUpdate();
        bTransmitTCN = BrdgSTAPortStateSelection();
    }
    else
    {
        DBGPRINT(STA, ("BrdgSTAUpdateAdapterCost() called with uninitialized adapter; ignoring!\n"));
    }

    NdisReleaseSpinLock( &gSTALock );

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

NTSTATUS
BrdgSTADriverInit()
/*++

Routine Description:

    Driver load-time initialization

Return Value:

    Status of initialization

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS            NtStatus;
    UINT                i;
    ULONG               regValue;

    NdisAllocateSpinLock( &gSTALock );

    BrdgInitializeTimer( &gTopologyChangeTimer, BrdgSTATopologyChangeTimerExpiry, NULL );
    BrdgInitializeTimer( &gTopologyChangeNotificationTimer, BrdgSTATopologyChangeNotificationTimerExpiry, NULL );
    BrdgInitializeTimer( &gHelloTimer, BrdgSTAHelloTimerExpiry, NULL );

    // We haven't used any port IDs yet...
    for( i = 0; i < sizeof(gUsedPortIDs) / sizeof(ULONG); i++ )
    {
        gUsedPortIDs[i] = 0;
    }

    // Check if we're supposed to disable the STA
    NtStatus = BrdgReadRegDWord( &gRegistryPath, gDisableSTAParameterName, &regValue );

    if( (NtStatus == STATUS_SUCCESS) &&
        (regValue != 0L) )
    {
        gDisableSTA = TRUE;
        DBGPRINT(STA, ("DISABLING SPANNING TREE ALGORITHM\n"));
    }

    return STATUS_SUCCESS;
}

VOID
BrdgSTADeferredInit(
    IN PUCHAR           pBridgeMACAddress
    )
/*++

Routine Description:

    Second initialization pass; called when we determine the bridge's
    MAC address (which is needed for STA operations)

Arguments:

    pBridgeMACAddress   The bridge miniport's MAC address

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    UINT                i;

    // Our identifier consists of our MAC address preceeded with 0x8000
    gOurID[0] = 0x80;
    gOurID[1] = 0x00;

    for( i = BRIDGE_ID_LEN - ETH_LENGTH_OF_ADDRESS; i < BRIDGE_ID_LEN; i++ )
    {
        gOurID[i] = pBridgeMACAddress[i - (BRIDGE_ID_LEN - ETH_LENGTH_OF_ADDRESS)];
    }

    // Set the root bridge ID as our own to start out with
    BrdgSTACopyID( gDesignatedRootID, gOurID );
    gHaveID = TRUE;

    if (BrdgFwdBridgingNetworks())
    {
        // Don't use locks; rely on this function being non-reentrant and always run
        // before any other functions
        if( BrdgSTAPortStateSelection() )
        {
            BrdgSTATransmitTCNPacket();
        }

        BrdgSTAGenerateConfigBPDUs();
        BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE );   
    }
}

VOID
BrdgSTACleanup()
/*++

Routine Description:

    Driver unload-time cleanup

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BrdgShutdownTimer( &gTopologyChangeTimer );
    BrdgShutdownTimer( &gTopologyChangeNotificationTimer );
    BrdgShutdownTimer( &gHelloTimer );
}

VOID
BrdgSTAEnableAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Enables STA operations on an adapter. Can be called multiple times
    (in conjunction with BrdgSTADisableAdapter()) for a given adapter

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BOOLEAN             bTransmitTCN = FALSE;

    DBGPRINT(STA, ("ENABLING adapter %p\n", pAdapt));

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->bSTAInited )
    {
        BrdgSTABecomeDesignatedPort(pAdapt);
        BrdgSTASetAdapterState( pAdapt, Blocking );

        pAdapt->STAInfo.bTopologyChangeAck = FALSE;
        pAdapt->STAInfo.bConfigPending = FALSE;

        bTransmitTCN = BrdgSTAPortStateSelection();
    }
    else
    {
        DBGPRINT(STA, ("BrdgSTAEnableAdapter() called with uninitialized adapter; ignoring!\n"));
    }

    NdisReleaseSpinLock( &gSTALock );

    if( bTransmitTCN && BrdgFwdBridgingNetworks())
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTAInitializeAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    One-time initialization for a new adatper

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.
    ASSUMES the adapter has already been added to the global list

--*/
{
    if( BrdgAcquireAdapter(pAdapt) )
    {
        UINT            i, j;

        // Adapters should always be disabled when being initialized, either because they are
        // brand new and this is how they start out, or as a way of checking that they were
        // correctly stopped when they were last disconnected.
        SAFEASSERT( pAdapt->State == Disabled );

        pAdapt->STAInfo.PathCost = BrdgSTALinkCostFromLinkSpeed(pAdapt->LinkSpeed);

        BrdgInitializeTimer( &pAdapt->STAInfo.MessageAgeTimer, BrdgSTAMessageAgeTimerExpiry, pAdapt );
        BrdgInitializeTimer( &pAdapt->STAInfo.ForwardDelayTimer, BrdgSTAForwardDelayTimerExpiry, pAdapt );
        BrdgInitializeTimer( &pAdapt->STAInfo.HoldTimer, BrdgSTAHoldTimerExpiry, pAdapt );
        pAdapt->STAInfo.LastConfigTime = 0L;

        // Find an unused port number in the bitfield
        NdisAcquireSpinLock( &gSTALock );
        for( i = 0; i < sizeof(gUsedPortIDs) / sizeof(ULONG); i++ )
        {
            for( j = 0; j < sizeof(ULONG) * 8; j++ )
            {
                if( (gUsedPortIDs[i] & (1 << j)) == 0 )
                {
                    pAdapt->STAInfo.ID = (PORT_ID)(PORT_PRIORITY | ((i * sizeof(ULONG) * 8) + j));
                    DBGPRINT(STA, ("Adapter %p gets ID %i\n", pAdapt, pAdapt->STAInfo.ID));
                    gUsedPortIDs[i] |= (1 << j);
                    goto doneID;
                }
            }
        }

        // Should be impossible to not have an available ID
        SAFEASSERT( FALSE );
        pAdapt->STAInfo.ID = PORT_PRIORITY | 0xFF;

doneID:
        // Set this before releasing the lock
        pAdapt->bSTAInited = TRUE;

        NdisReleaseSpinLock( &gSTALock );

        // Start the adapter off enabled / disabled based on its media state
        // The enable / disable functions take locks
        if( pAdapt->MediaState == NdisMediaStateConnected )
        {
            BrdgSTAEnableAdapter( pAdapt );
        }
        else
        {
            SAFEASSERT( pAdapt->MediaState == NdisMediaStateDisconnected );
            BrdgSTADisableAdapter( pAdapt );
        }
    }
    else
    {
        SAFEASSERT( FALSE );
    }
}

VOID
BrdgSTADisableAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Disable STA operation on an adapter. Can be called multiple times
    (in conjunction with BrdgSTAEnableAdapter()) on a given adapter

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    BOOLEAN             bWereRoot, bTransmitTCN = FALSE;

    DBGPRINT(STA, ("DISABLING adapter %p\n", pAdapt));

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->bSTAInited )
    {
        bWereRoot = BrdgSTAWeAreRoot();

        BrdgSTABecomeDesignatedPort(pAdapt);
        BrdgSTASetAdapterState( pAdapt, Disabled );

        pAdapt->STAInfo.bTopologyChangeAck = FALSE;
        pAdapt->STAInfo.bConfigPending = FALSE;

        BrdgCancelTimer( &pAdapt->STAInfo.MessageAgeTimer );
        pAdapt->STAInfo.LastConfigTime = 0L;
        BrdgCancelTimer( &pAdapt->STAInfo.ForwardDelayTimer );

        BrdgSTAConfigUpdate();
        bTransmitTCN = BrdgSTAPortStateSelection();

        if( BrdgSTAWeAreRoot() && (! bWereRoot) )
        {
            // We're the root bridge now
            DBGPRINT(STA, ("Became root through disabling of adapter %p\n", pAdapt));

            gMaxAge = DEFAULT_MAX_AGE;
            gHelloTime = DEFAULT_HELLO_TIME;
            gForwardDelay = DEFAULT_FORWARD_DELAY;

            bTransmitTCN = BrdgSTATopologyChangeDetected();
            BrdgCancelTimer( &gTopologyChangeNotificationTimer );

            // Don't do packet sends with a spin lock held
            NdisReleaseSpinLock( &gSTALock );

            if (BrdgFwdBridgingNetworks())
            {
                BrdgSTAGenerateConfigBPDUs();
                BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE );
            }
        }
        else
        {
            NdisReleaseSpinLock( &gSTALock );
        }
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
        DBGPRINT(STA, ("BrdgSTADisableAdapter() called with uninitialized adapter; ignoring!\n"));
    }

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTAShutdownAdapter(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    One-time teardown of an adapter

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.
    ASSUMES the adapter has been taken out of the global list

--*/
{
    UINT                i;
    PORT_ID             ActualID = pAdapt->STAInfo.ID & (~PORT_PRIORITY);

    // Shouldn't be possible to go through a formal shutdown without
    // having completed initialization.
    SAFEASSERT( pAdapt->bSTAInited );

    // Shutdown all this adapter's timers
    BrdgShutdownTimer( &pAdapt->STAInfo.HoldTimer );
    BrdgShutdownTimer( &pAdapt->STAInfo.ForwardDelayTimer );
    BrdgShutdownTimer( &pAdapt->STAInfo.MessageAgeTimer );

    // Disable the adapter
    BrdgSTADisableAdapter( pAdapt );

    // Note that this adapter's port ID is now free
    NdisAcquireSpinLock( &gSTALock );
    i = (UINT)(ActualID / (sizeof(ULONG) * 8));
    SAFEASSERT( i < sizeof(gUsedPortIDs) / sizeof(ULONG) );
    gUsedPortIDs[i] &= ~(1 << (ActualID % (sizeof(ULONG) * 8)));
    NdisReleaseSpinLock( &gSTALock );

    // We're all done with this adapter structure
    SAFEASSERT( gRootAdapter != pAdapt );
    BrdgReleaseAdapter( pAdapt );
}

VOID
BrdgSTAReceivePacket(
    IN PADAPT           pAdapt,
    IN PNDIS_PACKET     pPacket
    )
/*++

Routine Description:

    Function to handle the processing of a packet received on the reserved
    STA multicast channel

Arguments:

    pAdapt              The adapter the packet was received on
    pPacket             The received packet

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    UCHAR               STAPacket[CONFIG_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE];
    ULONG               written;
    SHORT               dataLen;

    // Copy the data from the packet into our data buffer
    BrdgSTACopyFromPacketToBuffer( STAPacket, sizeof(STAPacket), &written, pPacket );

    if( written < TCN_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE )
    {
        THROTTLED_DBGPRINT(STA, ("Undersize STA packet received on %p\n", pAdapt));
        return;
    }

    // The LLC header must identify the STA protocol
    if( (STAPacket[14] != 0x42) || (STAPacket[15] != 0x42) )
    {
        THROTTLED_DBGPRINT(STA, ("Packet with bad protocol type received on %p\n", pAdapt));
        return;
    }

    // Bytes 13 and 14 encode the length of data.
    dataLen = STAPacket[12] << 8;
    dataLen |= STAPacket[13];

    // The first two bytes are the protocol identifier and must be zero.
    // The third byte is the version identifier and must be zero.

    if( (STAPacket[_802_3_HEADER_SIZE] != 0) ||
        (STAPacket[_802_3_HEADER_SIZE + 1] != 0) ||
        (STAPacket[_802_3_HEADER_SIZE + 2] != 0) )
    {
        THROTTLED_DBGPRINT(STA, ("Invalid STA packet received\n"));
        return;
    }

    if( STAPacket[_802_3_HEADER_SIZE + 3] == 0x80 )
    {
        // The length of the frame with LLC header must be 7 bytes for a TCN BPDU
        if( dataLen != 7 )
        {
            THROTTLED_DBGPRINT(STA, ("Bad header size for TCN BPDU on %p\n", pAdapt));
            return;
        }

        // This is a Topology Change BPDU.
        BrdgSTAProcessTCNBPDU( pAdapt );
    }
    else if( STAPacket[_802_3_HEADER_SIZE + 3] == 0x00 )
    {
        CONFIG_BPDU         bpdu;

        if( written < CONFIG_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE )
        {
            THROTTLED_DBGPRINT(STA, ("Undersize config BPDU received on %p\n", pAdapt));
            return;
        }

        // The length of the frame with LLC header must be 38 bytes for a Config BPDU
        if( dataLen != 38 )
        {
            THROTTLED_DBGPRINT(STA, ("Bad header size for Config BPDU on %p\n", pAdapt));
            return;
        }

        bpdu.Type = ConfigBPDU;

        // The high bit of byte 5 encodes the topology change acknowledge flag
        bpdu.bTopologyChangeAck = (BOOLEAN)((STAPacket[_802_3_HEADER_SIZE + 4] & 0x80) != 0);

        // The low bit of byte 5 encodes the topology change flag
        bpdu.bTopologyChange = (BOOLEAN)((STAPacket[_802_3_HEADER_SIZE + 4] & 0x01) != 0);

        // Bytes 6 thru 13 encode the root bridge ID
        bpdu.RootID[0] = STAPacket[_802_3_HEADER_SIZE + 5];
        bpdu.RootID[1] = STAPacket[_802_3_HEADER_SIZE + 6];
        bpdu.RootID[2] = STAPacket[_802_3_HEADER_SIZE + 7];
        bpdu.RootID[3] = STAPacket[_802_3_HEADER_SIZE + 8];
        bpdu.RootID[4] = STAPacket[_802_3_HEADER_SIZE + 9];
        bpdu.RootID[5] = STAPacket[_802_3_HEADER_SIZE + 10];
        bpdu.RootID[6] = STAPacket[_802_3_HEADER_SIZE + 11];
        bpdu.RootID[7] = STAPacket[_802_3_HEADER_SIZE + 12];

        // Bytes 14 thru 17 encode the root path cost
        bpdu.RootCost = 0;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 13] << 24;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 14] << 16;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 15] << 8;
        bpdu.RootCost |= STAPacket[_802_3_HEADER_SIZE + 16];

        // Bytes 18 thru 15 encode the designated bridge ID
        bpdu.BridgeID[0] = STAPacket[_802_3_HEADER_SIZE + 17];
        bpdu.BridgeID[1] = STAPacket[_802_3_HEADER_SIZE + 18];
        bpdu.BridgeID[2] = STAPacket[_802_3_HEADER_SIZE + 19];
        bpdu.BridgeID[3] = STAPacket[_802_3_HEADER_SIZE + 20];
        bpdu.BridgeID[4] = STAPacket[_802_3_HEADER_SIZE + 21];
        bpdu.BridgeID[5] = STAPacket[_802_3_HEADER_SIZE + 22];
        bpdu.BridgeID[6] = STAPacket[_802_3_HEADER_SIZE + 23];
        bpdu.BridgeID[7] = STAPacket[_802_3_HEADER_SIZE + 24];

        // Bytes 26 and 27 encode the port identifier
        bpdu.PortID = 0;
        bpdu.PortID |= STAPacket[_802_3_HEADER_SIZE + 25] << 8;
        bpdu.PortID |= STAPacket[_802_3_HEADER_SIZE + 26];

        // Bytes 28 and 29 encode the message age
        bpdu.MessageAge = 0;
        bpdu.MessageAge |= STAPacket[_802_3_HEADER_SIZE + 27] << 8;
        bpdu.MessageAge |= STAPacket[_802_3_HEADER_SIZE + 28];

        // Bytes 30 and 31 encode the Max Age
        bpdu.MaxAge = 0;
        bpdu.MaxAge |= STAPacket[_802_3_HEADER_SIZE + 29] << 8;
        bpdu.MaxAge |= STAPacket[_802_3_HEADER_SIZE + 30];

        if( bpdu.MaxAge == 0 )
        {
            THROTTLED_DBGPRINT(STA, ("Ignoring BPDU packet with zero MaxAge on adapter %p\n", pAdapt));
            return;
        }

        // Bytes 32 and 33 encode the Hello Time
        bpdu.HelloTime = 0;
        bpdu.HelloTime |= STAPacket[_802_3_HEADER_SIZE + 31] << 8;
        bpdu.HelloTime |= STAPacket[_802_3_HEADER_SIZE + 32];

        if( bpdu.HelloTime == 0 )
        {
            THROTTLED_DBGPRINT(STA, ("Ignoring BPDU packet with zero HelloTime on adapter %p\n", pAdapt));
            return;
        }

        // Bytes 34 and 35 encode the forwarding delay
        bpdu.ForwardDelay = 0;
        bpdu.ForwardDelay |= STAPacket[_802_3_HEADER_SIZE + 33] << 8;
        bpdu.ForwardDelay |= STAPacket[_802_3_HEADER_SIZE + 34];

        if( bpdu.ForwardDelay == 0 )
        {
            THROTTLED_DBGPRINT(STA, ("Ignoring BPDU packet with zero ForwardDelay on adapter %p\n", pAdapt));
            return;
        }

        BrdgSTAProcessConfigBPDU( pAdapt, &bpdu );
    }
    else
    {
        THROTTLED_DBGPRINT(STA, ("Packet with unrecognized BPDU type received on %p\n", pAdapt));
        return;
    }
}

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

VOID
BrdgSTASetAdapterState(
    IN PADAPT               pAdapt,
    IN PORT_STATE           NewState
    )
/*++

Routine Description:

    Updates an adapter's forwarding state correctly

    This function is designed to be callable at high IRQL, so it defers
    the actual call to BrdgProtDoAdapterStateChange, which must be called
    at low IRQL.

Arguments:

    pAdapt              The adapter the packet was received on
    pPacket             The received packet

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/

{
    LOCK_STATE              LockState;
    BOOLEAN                 bailOut = FALSE;
    
    // Set the adapter's new state.
    NdisAcquireReadWriteLock( &gAdapterCharacteristicsLock, TRUE/*Write access*/, &LockState );
    if( pAdapt->State == NewState )
    {
        bailOut = TRUE;
    }
    else
    {
        pAdapt->State = NewState;
    }
    NdisReleaseReadWriteLock( &gAdapterCharacteristicsLock, &LockState );

    // Don't do additional work if the adapter is already in the requested state
    if( bailOut )
    {
        return;
    }

#if DBG
    switch( NewState )
    {
    case Blocking:
        DBGPRINT(STA, ("Adapter %p becomes BLOCKING\n", pAdapt));
        break;

    case Listening:
        DBGPRINT(STA, ("Adapter %p becomes LISTENING\n", pAdapt));
        break;

    case Learning:
        DBGPRINT(STA, ("Adapter %p becomes LEARNING\n", pAdapt));
        break;

    case Forwarding:
        DBGPRINT(STA, ("Adapter %p becomes FORWARDING\n", pAdapt));
        break;
    }
#endif

    //
    // We will be hanging onto the adapter pointer in order to defer the call
    // to BrdgSTADeferredSetAdapterState.
    //
    if( BrdgAcquireAdapter(pAdapt) )
    {
        NDIS_STATUS     Status;

        // We need to defer the call to BrdgProtDoAdapterStateChange since it must run
        // at PASSIVE_IRQL
        Status = BrdgDeferFunction( BrdgSTADeferredSetAdapterState, pAdapt );

        if( Status != NDIS_STATUS_SUCCESS )
        {
            DBGPRINT(STA, ("Unable to defer call to BrdgSTADeferredSetAdapterState\n", pAdapt));
            BrdgReleaseAdapter( pAdapt );
        }
        // else adapter will be released in BrdgSTADeferredSetAdapterState
    }
    else
    {
        DBGPRINT(STA, ("Adapter %p already shutting down when attempted to set adapter state\n", pAdapt));
    }
}

VOID
BrdgSTADeferredSetAdapterState(
    IN PVOID                Arg
    )
/*++

Routine Description:

    Deferred function from BrdgSTASetAdapterState; does housekeeping associated with
    changing an adapter's forwarding state.

    Must be called at PASSIVE

Arguments:

    Arg                     The adapter that needs updating

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/
{
    PADAPT                  pAdapt = (PADAPT)Arg;

    SAFEASSERT( CURRENT_IRQL == PASSIVE_LEVEL );

    BrdgProtDoAdapterStateChange( pAdapt );

    // Tell user-mode about the change
    BrdgCtlNotifyAdapterChange( pAdapt, BrdgNotifyAdapterStateChange );

    // Adapter was acquired in BrdgSTASetAdapterState()
    BrdgReleaseAdapter( pAdapt );
}

VOID
BrdgSTATransmitConfigBPDUPacket(
    IN PADAPT                       pAdapt,
    PCONFIG_BPDU                    pbpdu
    )
/*++

Routine Description:

    Transmits a config BPDU packet on a particular adapter

Arguments:

    pAdapt                          The adapter to transmit on
    pbpdu                           A structure describing the BPDU information

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/
{
    UCHAR                           STAPacket[CONFIG_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE];
    NDIS_STATUS                     Status;

    if (BrdgProtGetAdapterCount() < 2)
    {
        return;
    }

    if (!BrdgFwdBridgingNetworks())
    {
        DBGPRINT(STA, ("Not Transmitting STA Packet (we're not bridging)\r\n"));
        return;
    }

    //
    // First encode the Ethernet header.
    //
    // Destination MAC address of packet must be STA multicast address
    STAPacket[0] = STA_MAC_ADDR[0];
    STAPacket[1] = STA_MAC_ADDR[1];
    STAPacket[2] = STA_MAC_ADDR[2];
    STAPacket[3] = STA_MAC_ADDR[3];
    STAPacket[4] = STA_MAC_ADDR[4];
    STAPacket[5] = STA_MAC_ADDR[5];

    // The the source MAC address to the adapter's own MAC address
    STAPacket[6] = pAdapt->MACAddr[0];
    STAPacket[7] = pAdapt->MACAddr[1];
    STAPacket[8] = pAdapt->MACAddr[2];
    STAPacket[9] = pAdapt->MACAddr[3];
    STAPacket[10] = pAdapt->MACAddr[4];
    STAPacket[11] = pAdapt->MACAddr[5];

    // Next two bytes are the size of the frame (38 bytes)
    STAPacket[12] = 0x00;
    STAPacket[13] = 0x26;

    // Next two bytes are the LLC DSAP and SSAP fields, set to 0x42 for STA
    STAPacket[14] = 0x42;
    STAPacket[15] = 0x42;

    // Next byte is the LLC frame type, 3 for unnumbered
    STAPacket[16] = 0x03;

    //
    // Now we are encoding the payload.
    //
    // First 4 bytes are the protocol identifier, version and BPDU type, all zero
    STAPacket[_802_3_HEADER_SIZE] = STAPacket[_802_3_HEADER_SIZE + 1] =
        STAPacket[_802_3_HEADER_SIZE + 2] = STAPacket[_802_3_HEADER_SIZE + 3] = 0x00;

    // Byte 5 encodes the Topology Change Ack flag in the high bit and the
    // Topology Change flag in the low bit.
    STAPacket[_802_3_HEADER_SIZE + 4] = 0;

    if( pbpdu->bTopologyChangeAck )
    {
        STAPacket[_802_3_HEADER_SIZE + 4] |= 0x80;
    }

    if( pbpdu->bTopologyChange )
    {
        STAPacket[_802_3_HEADER_SIZE + 4] |= 0x01;
    }

    // Bytes 6-13 encode the root bridge ID
    STAPacket[_802_3_HEADER_SIZE + 5] = pbpdu->RootID[0];
    STAPacket[_802_3_HEADER_SIZE + 6] = pbpdu->RootID[1];
    STAPacket[_802_3_HEADER_SIZE + 7] = pbpdu->RootID[2];
    STAPacket[_802_3_HEADER_SIZE + 8] = pbpdu->RootID[3];
    STAPacket[_802_3_HEADER_SIZE + 9] = pbpdu->RootID[4];
    STAPacket[_802_3_HEADER_SIZE + 10] = pbpdu->RootID[5];
    STAPacket[_802_3_HEADER_SIZE + 11] = pbpdu->RootID[6];
    STAPacket[_802_3_HEADER_SIZE + 12] = pbpdu->RootID[7];

    // Bytes 14 - 17 encode the root path cost
    STAPacket[_802_3_HEADER_SIZE + 13] = (UCHAR)(pbpdu->RootCost >> 24);
    STAPacket[_802_3_HEADER_SIZE + 14] = (UCHAR)(pbpdu->RootCost >> 16);
    STAPacket[_802_3_HEADER_SIZE + 15] = (UCHAR)(pbpdu->RootCost >> 8);
    STAPacket[_802_3_HEADER_SIZE + 16] = (UCHAR)(pbpdu->RootCost);

    // Bytes 18-25 encode the designated bridge ID
    STAPacket[_802_3_HEADER_SIZE + 17] = pbpdu->BridgeID[0];
    STAPacket[_802_3_HEADER_SIZE + 18] = pbpdu->BridgeID[1];
    STAPacket[_802_3_HEADER_SIZE + 19] = pbpdu->BridgeID[2];
    STAPacket[_802_3_HEADER_SIZE + 20] = pbpdu->BridgeID[3];
    STAPacket[_802_3_HEADER_SIZE + 21] = pbpdu->BridgeID[4];
    STAPacket[_802_3_HEADER_SIZE + 22] = pbpdu->BridgeID[5];
    STAPacket[_802_3_HEADER_SIZE + 23] = pbpdu->BridgeID[6];
    STAPacket[_802_3_HEADER_SIZE + 24] = pbpdu->BridgeID[7];

    // Bytes 26 and 27 encode the port identifier
    STAPacket[_802_3_HEADER_SIZE + 25] = (UCHAR)(pbpdu->PortID >> 8);
    STAPacket[_802_3_HEADER_SIZE + 26] = (UCHAR)(pbpdu->PortID);

    // Bytes 28 and 29 encode the message age
    STAPacket[_802_3_HEADER_SIZE + 27] = (UCHAR)(pbpdu->MessageAge >> 8);
    STAPacket[_802_3_HEADER_SIZE + 28] = (UCHAR)(pbpdu->MessageAge);

    // Bytes 30 and 31 encode the max age
    STAPacket[_802_3_HEADER_SIZE + 29] = (UCHAR)(pbpdu->MaxAge >> 8);
    STAPacket[_802_3_HEADER_SIZE + 30] = (UCHAR)(pbpdu->MaxAge);

    // Bytes 32 and 33 encode the hello time
    STAPacket[_802_3_HEADER_SIZE + 31] = (UCHAR)(pbpdu->HelloTime >> 8);
    STAPacket[_802_3_HEADER_SIZE + 32] = (UCHAR)(pbpdu->HelloTime);

    // Bytes 34 and 35 encode the forward delay
    STAPacket[_802_3_HEADER_SIZE + 33] = (UCHAR)(pbpdu->ForwardDelay >> 8);
    STAPacket[_802_3_HEADER_SIZE + 34] = (UCHAR)(pbpdu->ForwardDelay);

    // Send the finished packet
    Status = BrdgFwdSendBuffer( pAdapt, STAPacket, sizeof(STAPacket) );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(STA, ("BPDU packet send failed: %08x\n", Status));
    }
}

VOID
BrdgSTATransmitTCNPacket()
/*++

Routine Description:

    Transmits a Topology Change Notification BPDU packet on the root adapter

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has NOT acquired gSTALock

--*/
{
    UCHAR                           STAPacket[TCN_BPDU_PACKET_SIZE + _802_3_HEADER_SIZE];
    NDIS_STATUS                     Status;
    PADAPT                          pRootAdapter;
    BOOLEAN                         bAcquired;

    if (BrdgProtGetAdapterCount() < 2)
    {
        return;
    }

    if (!BrdgFwdBridgingNetworks())
    {
        DBGPRINT(STA, ("Not Transmitting STA Packet (we're not bridging)\r\n"));
        return;
    }

    NdisAcquireSpinLock( &gSTALock );

    // Freeze this value for the rest of the function
    pRootAdapter = gRootAdapter;

    if( pRootAdapter == NULL )
    {
        NdisReleaseSpinLock( &gSTALock );
        return;
    }

    bAcquired = BrdgAcquireAdapter( pRootAdapter );
    NdisReleaseSpinLock( &gSTALock );

    if( ! bAcquired )
    {
        SAFEASSERT( FALSE );
        return;
    }

    SAFEASSERT( gHaveID );

    //
    // First encode the Ethernet header.
    //
    // Destination MAC address of packet must be STA multicast address
    STAPacket[0] = STA_MAC_ADDR[0];
    STAPacket[1] = STA_MAC_ADDR[1];
    STAPacket[2] = STA_MAC_ADDR[2];
    STAPacket[3] = STA_MAC_ADDR[3];
    STAPacket[4] = STA_MAC_ADDR[4];
    STAPacket[5] = STA_MAC_ADDR[5];

    // Set the packet's MAC address to the adapter's own MAC address
    STAPacket[6] = pRootAdapter->MACAddr[0];
    STAPacket[7] = pRootAdapter->MACAddr[1];
    STAPacket[8] = pRootAdapter->MACAddr[2];
    STAPacket[9] = pRootAdapter->MACAddr[3];
    STAPacket[10] = pRootAdapter->MACAddr[4];
    STAPacket[11] = pRootAdapter->MACAddr[5];

    // Next two bytes are the size of the frame (7 bytes)
    STAPacket[12] = 0x00;
    STAPacket[13] = 0x07;

    // Next two bytes are the LLC DSAP and SSAP fields, set to 0x42 for STA
    STAPacket[14] = 0x42;
    STAPacket[15] = 0x42;

    // Next byte is the LLC frame type, 3 for unnumbered
    STAPacket[16] = 0x03;

    //
    // Now we are encoding the payload.
    //
    // First 3 bytes are the protocol identifier and protocol version number, all zero
    STAPacket[_802_3_HEADER_SIZE] = STAPacket[_802_3_HEADER_SIZE + 1] =
        STAPacket[_802_3_HEADER_SIZE + 2] = 0x00;

    // Byte 4 is the BPDU type, which is 0x80 for TCN.
    STAPacket[_802_3_HEADER_SIZE + 3] = 0x80;

    // Send the finished packet
    Status = BrdgFwdSendBuffer( pRootAdapter, STAPacket, sizeof(STAPacket) );

    // We are done with the root adapter
    BrdgReleaseAdapter( pRootAdapter );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        THROTTLED_DBGPRINT(STA, ("BPDU packet send failed: %08x\n", Status));
    }
}

VOID
BrdgSTACopyFromPacketToBuffer(
    OUT PUCHAR                      pPacketOut,
    IN ULONG                        BufferSize,
    OUT PULONG                      pWrittenCount,
    IN PNDIS_PACKET                 pPacketIn
    )
/*++

Routine Description:

    Copies data out of a packet descriptor into a flat buffer

Arguments:

    pPacketOut                      Data buffer to copy info
    BufferSize                      Size of pPacketOut
    pWrittenCount                   Number of bytes actually written
    pPacketIn                       Packet to copy from

Return Value:

    None

Locking Constraints:

    No requirements on caller-held locks

--*/
{
    PNDIS_BUFFER                    pBuf;

    *pWrittenCount = 0L;
    pBuf = BrdgBufPacketHeadBuffer(pPacketIn);

    while( pBuf != NULL )
    {
        PVOID                       pData;
        UINT                        Len;

        NdisQueryBufferSafe( pBuf, &pData, &Len, NormalPagePriority );

        if( pData != NULL )
        {
            ULONG                   BytesToWrite;

            if( *pWrittenCount + Len > BufferSize )
            {
                BytesToWrite = BufferSize - *pWrittenCount;
            }
            else
            {
                BytesToWrite = Len;
            }

            NdisMoveMemory( pPacketOut, pData, BytesToWrite );
            pPacketOut += BytesToWrite;
            *pWrittenCount += BytesToWrite;

            if( BytesToWrite < Len )
            {
                // We're full, so we're done.
                return;
            }
        }
        else
        {
            // Shouldn't happen
            SAFEASSERT( FALSE );
        }

        NdisGetNextBuffer( pBuf, &pBuf );
    }
}

VOID
BrdgSTATransmitConfig(
    PADAPT      pAdapt
    )
/*++

Routine Description:

    Transmits a config BPDU on a particular adapter. Collects appropriate
    information and calls BrdgSTATransmitConfigBPDUPacket().

Arguments:

    pAdapt                      The adapter to transmit on

Return Value:

    None

Locking Constraints:

    ASSUMES the caller DOES NOT hold gSTALock

--*/
{
    NdisAcquireSpinLock( &gSTALock );

    if( BrdgTimerIsRunning( &pAdapt->STAInfo.HoldTimer ) )
    {
        // We have sent a config packet recently. Wait until the hold timer
        // expires before sending another one so we don't flood other bridges.
        pAdapt->STAInfo.bConfigPending = TRUE;

        NdisReleaseSpinLock( &gSTALock );
    }
    else
    {
        CONFIG_BPDU     bpdu;

        // Fill out the BPDU information structure
        bpdu.Type = ConfigBPDU;
        SAFEASSERT( gHaveID );
        BrdgSTACopyID( bpdu.RootID, gDesignatedRootID );
        bpdu.RootCost = gRootCost;
        BrdgSTACopyID( bpdu.BridgeID, gOurID );
        bpdu.PortID = pAdapt->STAInfo.ID;

        if( BrdgSTAWeAreRoot() )
        {
            // We are the root, so the age of this config information is zero.
            bpdu.MessageAge = 0;
        }
        else
        {
            // The MessageAge field is to be set to the age of the last received
            // config BPDU on the root port.
            if( (gRootAdapter != NULL) && BrdgAcquireAdapter(gRootAdapter) )
            {
                ULONG       CurrentTime, deltaTime;

                NdisGetSystemUpTime( &CurrentTime );

                // The message age timer should be running on the root adapter if
                // we are not root.
                SAFEASSERT( BrdgTimerIsRunning(&gRootAdapter->STAInfo.MessageAgeTimer) );
                SAFEASSERT( gRootAdapter->STAInfo.LastConfigTime != 0L );

                // The last parameter is the max acceptable delta. We should have
                // received the last piece of config information from the root no more
                // than gMaxAge STA units ago, since if it was longer than that, we
                // should have become root. Allow an additional second for processing.
                deltaTime = BrdgDeltaSafe( gRootAdapter->STAInfo.LastConfigTime, CurrentTime,
                                           (ULONG)(((gMaxAge * 1000) / 256) + 1000) );

                // STA times are in 1/256ths of a second.
                bpdu.MessageAge = (STA_TIME)((deltaTime * 256) / 1000);

                // MESSAGE_AGE_INCREMENT allows for the transmission time, etc.
                bpdu.MessageAge += MESSAGE_AGE_INCREMENT;

                BrdgReleaseAdapter(gRootAdapter);
            }
            else
            {
                // Why isn't there a root port if we're not root?
                SAFEASSERT( FALSE );
                bpdu.MessageAge = 0;
            }

        }

        bpdu.MaxAge = gMaxAge;
        bpdu.HelloTime = gHelloTime;
        bpdu.ForwardDelay = gForwardDelay;

        // Are we supposed to acknowledge a topology change signal?
        bpdu.bTopologyChangeAck = pAdapt->STAInfo.bTopologyChangeAck;

        // We just sent out the topology change ack if there was one to send
        pAdapt->STAInfo.bTopologyChangeAck = FALSE;

        bpdu.bTopologyChange = gTopologyChange;

        // Start the hold timer to make sure another BPDU isn't sent prematurely
        pAdapt->STAInfo.bConfigPending = FALSE;

        // Don't send a packet with the spin lock held
        NdisReleaseSpinLock( &gSTALock );

        // Send off the config BPDU
        BrdgSTATransmitConfigBPDUPacket( pAdapt, &bpdu );

        BrdgSetTimer( &pAdapt->STAInfo.HoldTimer, HOLD_TIMER_PERIOD, FALSE /*Not periodic*/ );
    }
}

BOOLEAN
BrdgSTASupersedesPortInfo(
    IN PADAPT               pAdapt,
    IN PCONFIG_BPDU         pbpdu
    )
/*++

Routine Description:

    Determines whether a given bpdu's information supersedes the information
    already associated with a particular adapter

Arguments:

    pAdapt                  The adapter
    pbpdu                   Received BPDU information to examine

Return Value:

    TRUE if the given information supersedes (i.e., is better) than the information
    previously held by the adapter. FALSE otherwise.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    INT                     cmp;

    /*  The information advertised on a given link supersedes the existing information for that
        link if the following conditions hold (applied in order; TRUE at any step causes immediate
        success)

        (1) The advertised root has a lower ID than the previous root
        (2) The advertised root is the same as the previous root and the new cost-to-root is
            lower than the previous value
        (3) The root IDs and costs are the same, and the ID of the advertising bridge is
            lower than the previous value
        (4) The root ID, cost-to-root and bridge IDs are the same and the advertising bridge
            is not us
        (5) The root ID, cost-to-root, bridge IDs are the same, the bridge is us, and the
            advertised port number is lower than the previous value (this happens if we have
            more than one port on the same physical link and we see the advertisement from
            our other port).
    */

    // Compare the advertised root ID to the adapter's previous designated root ID
    cmp = BrdgSTABridgeIDCmp( pbpdu->RootID, pAdapt->STAInfo.DesignatedRootID );

    if( cmp == -1 )                                                             // (1)
    {
        return TRUE;
    }
    else if( cmp == 0 )
    {
        if( pbpdu->RootCost < pAdapt->STAInfo.DesignatedCost )                  // (2)
        {
            return TRUE;
        }
        else if( pbpdu->RootCost == pAdapt->STAInfo.DesignatedCost )
        {
            // Compare the advertised bridge ID to the previous designated bridge ID
            cmp = BrdgSTABridgeIDCmp( pbpdu->BridgeID, pAdapt->STAInfo.DesignatedBridgeID );

            if( cmp == -1 )
            {
                return TRUE;                                                    // (3)
            }
            else if( cmp == 0 )
            {
                SAFEASSERT( gHaveID );

                // Compare the advertised bridge ID to our own ID
                cmp = BrdgSTABridgeIDCmp( pbpdu->BridgeID, gOurID );

                if( cmp != 0 )
                {
                    return TRUE;                                                // (4)
                }
                else if( cmp == 0 )
                {
                    return (BOOLEAN)(pbpdu->PortID <= pAdapt->STAInfo.DesignatedPort); // (5)
                }
            }
        }
    }

    return FALSE;
}

VOID
BrdgSTARecordConfigInfo(
    IN PADAPT               pAdapt,
    IN PCONFIG_BPDU         pbpdu
    )
/*++

Routine Description:

    Associates the information from a received BPDU with a particular adapter

Arguments:

    pAdapt                  The adapter
    pbpdu                   Received BPDU information to record

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    ULONG                   msgAgeInMs = (pbpdu->MessageAge / 256) * 1000;

    // Update the port's information with the new data
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedRootID, pbpdu->RootID );
    pAdapt->STAInfo.DesignatedCost = pbpdu->RootCost;
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedBridgeID, pbpdu->BridgeID );
    pAdapt->STAInfo.DesignatedPort = pbpdu->PortID;

    // Start the message age timer. It is specified to expire after
    // gMaxAge - MessageAge STA time units.
    if( pbpdu->MessageAge < gMaxAge )
    {
        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.MessageAgeTimer,
                                    gMaxAge - pbpdu->MessageAge, FALSE /*Not periodic*/ );
    }
    else
    {
        // How odd. The message was already too old. Start the timer so that it
        // will expire immediately.

        THROTTLED_DBGPRINT(STA, ("Received over-age BPDU (%i / %i) on adapter %p", pbpdu->MessageAge,
                            gMaxAge, pAdapt));

        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.MessageAgeTimer, 0, FALSE /*Not periodic*/ );
    }

    NdisGetSystemUpTime( &pAdapt->STAInfo.LastConfigTime );

    // Roll back by the age of the info we got.
    SAFEASSERT( msgAgeInMs < pAdapt->STAInfo.LastConfigTime );
    pAdapt->STAInfo.LastConfigTime -= msgAgeInMs;
}

VOID
BrdgSTARecordTimeoutInfo(
    IN PCONFIG_BPDU         pbpdu
    )
/*++

Routine Description:

    Records timeout information conveyed by a BPDU received from the root bridge

Arguments:

    pbpdu                   Received BPDU information to record

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    gMaxAge = pbpdu->MaxAge;
    gHelloTime = pbpdu->HelloTime;
    gForwardDelay = pbpdu->ForwardDelay;
    BrdgSTAUpdateTopologyChange( pbpdu->bTopologyChange );
}

VOID
BrdgSTAGenerateConfigBPDUs()
/*++

Routine Description:

    Sends configuration BPDUs out every designated port

Arguments:

    pbpdu                   Received BPDU information to record

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT hold gSTALock

--*/
{
    LOCK_STATE          LockState;
    PADAPT              Adapters[MAX_ADAPTERS];
    INT                 cmpID;
    PADAPT              pAdapt;
    UINT                numAdapters = 0, i;

    NdisAcquireSpinLock( &gSTALock );
    SAFEASSERT( gHaveID );
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( (pAdapt->bSTAInited) && (pAdapt->State != Disabled) )
        {
            cmpID = BrdgSTABridgeIDCmp( pAdapt->STAInfo.DesignatedBridgeID, gOurID );

            if( (cmpID == 0) && (pAdapt->STAInfo.ID == pAdapt->STAInfo.DesignatedPort) )
            {
                // This adapter is a designated port. We will send a config BPDU out it.
                BrdgAcquireAdapterInLock( pAdapt );
                Adapters[numAdapters] = pAdapt;
                numAdapters++;
            }
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
    NdisReleaseSpinLock( &gSTALock );

    // Send a BPDU out every adapter that we chose
    for( i = 0; i < numAdapters; i++ )
    {
        BrdgSTATransmitConfig(Adapters[i]);
        BrdgReleaseAdapter(Adapters[i]);
    }
}

VOID
BrdgSTARootSelection()
/*++

Routine Description:

    Examines the information associated with every bridge port to determine
    the root bridge ID and root port

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    LOCK_STATE          LockState;
    PADAPT              pAdapt, pRootAdapt = NULL;
    INT                 cmp;

    SAFEASSERT( gHaveID );
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( (pAdapt->bSTAInited) &&  (pAdapt->State != Disabled) )
        {
            /*
                We consider the information advertised on each link to determine which port should
                be the new root port. If no link advertises sufficiently attractive information, we declare
                ourselves to be the root. A port is acceptable as the root port if all the following
                conditions hold:

                (1) The port receiving the advertisement must not be a designated port
                (2) The link's advertised root must have a lower ID than us
                (3) The link's advertised root ID must be lower than the advertised root ID on any other link
                (4) If the advertised root ID is the same as another advertised root, the cost-to-root
                    must be lower
                (5) If the root ID and cost are the same, the designated bridge on the port must have a
                    lower ID than the designated bridge on other ports (this chooses arbitrarily
                    between two bridges that can reach the root with the same cost)
                (6) If the root ID, cost-to-root and designated bridge IDs are the same, the designated
                    port must be less than on other ports (this happens if two links have the same
                    designated bridge)
                (7) If the root ID, cost-to-root, designated bridge ID and designated port IDs are all
                    the same, the port number of the port itself must be lower (this only happens if
                    we have more than one port onto the same physical link; we pick the lower-numbered
                    one as the root port)
            */

            cmp = BrdgSTABridgeIDCmp( pAdapt->STAInfo.DesignatedBridgeID, gOurID );

            if( (cmp != 0) || (pAdapt->STAInfo.ID != pAdapt->STAInfo.DesignatedPort) )          // (1)
            {
                cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedRootID, gOurID);

                if( cmp == -1 )                                                                 // (2)
                {
                    BOOLEAN         betterRoot = FALSE;

                    if( pRootAdapt == NULL )
                    {
                        // Hadn't seen a root better than ourselves before now; take this one.
                        betterRoot = TRUE;
                    }
                    else
                    {
                        // Compare the advertised root ID to our previous best
                        cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedRootID, pRootAdapt->STAInfo.DesignatedRootID);

                        if( cmp == -1 )                                                         // (3)
                        {
                            betterRoot = TRUE;
                        }
                        else if( cmp == 0 )
                        {
                            PATH_COST       thisCost = pAdapt->STAInfo.DesignatedCost + pAdapt->STAInfo.PathCost,
                                            prevBestCost = pRootAdapt->STAInfo.DesignatedCost + pRootAdapt->STAInfo.PathCost;

                            if( thisCost < prevBestCost )
                            {
                                betterRoot = TRUE;                                              // (4)
                            }
                            else if( thisCost == prevBestCost )
                            {
                                // Compare the IDs of the designated bridge
                                cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, pRootAdapt->STAInfo.DesignatedBridgeID);

                                if( cmp == -1 )
                                {
                                    betterRoot = TRUE;                                          // (5)
                                }
                                else if( cmp == 0 )
                                {
                                    if( pAdapt->STAInfo.DesignatedPort < pRootAdapt->STAInfo.DesignatedPort )
                                    {
                                        betterRoot = TRUE;                                      // (6)
                                    }
                                    else if( pAdapt->STAInfo.DesignatedPort == pRootAdapt->STAInfo.DesignatedPort )
                                    {
                                        if( pAdapt->STAInfo.ID < pRootAdapt->STAInfo.ID )
                                        {
                                            betterRoot = TRUE;                                  // (7)
                                        }
                                        else
                                        {
                                            // Sanity-check that the two adapters' IDs are different!
                                            SAFEASSERT( pAdapt->STAInfo.ID != pRootAdapt->STAInfo.ID );
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if( betterRoot )
                    {
                        // We have a better root port.
                        pRootAdapt = pAdapt;
                    }
                }
            }
        }
    }

    if( pRootAdapt == NULL )
    {
        gRootAdapter = NULL;
        BrdgSTACopyID( gDesignatedRootID, gOurID );
        gRootCost = 0;
    }
    else
    {
        gRootAdapter = pRootAdapt;
        BrdgSTACopyID( gDesignatedRootID, pRootAdapt->STAInfo.DesignatedRootID );
        gRootCost = pRootAdapt->STAInfo.DesignatedCost + pRootAdapt->STAInfo.PathCost;
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
}

VOID
BrdgSTABecomeDesignatedPort(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Sets the information associated with an adapter to make it a designated port

Arguments:

    pAdapt              The adapter to make designated

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    SAFEASSERT( gHaveID );
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedRootID, gDesignatedRootID );
    pAdapt->STAInfo.DesignatedCost = gRootCost;
    BrdgSTACopyID( pAdapt->STAInfo.DesignatedBridgeID, gOurID );
    pAdapt->STAInfo.DesignatedPort = pAdapt->STAInfo.ID;
}

VOID
BrdgSTADesignatedPortSelection()
/*++

Routine Description:

    Examines the information associated with each port to determine
    which should become designated ports

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    LOCK_STATE          LockState;
    PADAPT              pAdapt;
    INT                 cmp;

    SAFEASSERT( gHaveID );
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( pAdapt->bSTAInited )
        {
            BOOLEAN         becomeDesignated = FALSE;

            /*  We consider each port to determine whether it should become a designated port
                (if it previously was not one). A port becomes a designated port if the
                following conditions hold:

                (1) The port is the link's designated port by advertised info
                (2) The link's previous designated root is not the correct root
                (3) Our cost-to-root is lower than the current cost advertised on the link
                (4) We have a same cost-to-root but a lower ID than the current designated
                    bridge on the link
                (5) We have the same cost-to-root and ID as the designated bridge on the link
                    but a lower port number (this only happens if we have two or more ports
                    on the same physical link)
            */

            // See if the link's designated bridge is already us
            cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID);

            if( (cmp == 0) && (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
            {
                becomeDesignated = TRUE;                                    // (1)
            }
            else
            {
                // Compare the link's advertised root to the one we believe is root
                cmp = BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedRootID, gDesignatedRootID);

                if( cmp != 0 )
                {
                    becomeDesignated = TRUE;                                    // (2)
                }
                else if( gRootCost < pAdapt->STAInfo.DesignatedCost )
                {
                    becomeDesignated = TRUE;                                    // (3)
                }
                else if( gRootCost == pAdapt->STAInfo.DesignatedCost )
                {
                    // Compare the link's designated bridge to our own ID
                    cmp = BrdgSTABridgeIDCmp(gOurID, pAdapt->STAInfo.DesignatedBridgeID);

                    if( cmp == -1 )
                    {
                        becomeDesignated = TRUE;                                // (4)
                    }
                    else if( cmp == 0 )
                    {
                        if( pAdapt->STAInfo.ID < pAdapt->STAInfo.DesignatedPort )
                        {
                            becomeDesignated = TRUE;                            // (5)
                        }
                        else
                        {
                            // If this SAFEASSERT fires, we should have succeeded on test (1)
                            SAFEASSERT( pAdapt->STAInfo.ID > pAdapt->STAInfo.DesignatedPort );
                        }
                    }
                }
            }

            if( becomeDesignated )
            {
                BrdgSTABecomeDesignatedPort( pAdapt );
            }
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
}

BOOLEAN
BrdgSTATopologyChangeDetected()
/*++

Routine Description:

    Takes appropriate action when a topology change is detected. If we are
    the root, this consists of setting the TopologyChange flag in future
    BPDUs until the expiry of the gTopologyChangeTimer. If we are not the
    root, this consists of sending a TCN BPDU periodically until it is
    acknowledged

Arguments:

    None

Return Value:

    TRUE means the caller should arrange to send a TCN BPDU from outside the
    gSTALock. FALSE means it is not necessary to send such a packet.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    BOOLEAN         rc = FALSE;

    if( BrdgSTAWeAreRoot() )
    {
        BrdgSTAUpdateTopologyChange( TRUE );
        BrdgSTASetTimerWithSTATime( &gTopologyChangeTimer, DEFAULT_MAX_AGE + DEFAULT_FORWARD_DELAY, FALSE /*Not periodic*/ );
    }
    else
    {
        rc = TRUE;
        BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
    }

    gTopologyChangeDetected = TRUE;

    return rc;
}

VOID
BrdgSTAMakeForwarding(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Starts the process of putting an adapter in the forwarding state.

    Adapters must pass through the Listening and Learning states before entering
    the Forwarding state.

Arguments:

    pAdapt              The adapter

Return Value:

    None

Locking Constraints:

    None

--*/
{
    if( pAdapt->State == Blocking )
    {
        BrdgSTASetAdapterState( pAdapt, Listening );
        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.ForwardDelayTimer, gForwardDelay, FALSE /*Not periodic*/ );
    }
}

BOOLEAN
BrdgSTAMakeBlocking(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Puts an adapter in the blocking state

Arguments:

    pAdapt              The adapter

Return Value:

    TRUE means the caller should arrange to send a TCN BPDU from outside the
    gSTALock. FALSE means it is not necessary to send such a packet.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    BOOLEAN             rc = FALSE;

    if( pAdapt->State != Blocking )
    {
        if( (pAdapt->State == Forwarding) ||
            (pAdapt->State == Learning) )
        {
            rc = BrdgSTATopologyChangeDetected();
        }

        BrdgSTASetAdapterState( pAdapt, Blocking );
        BrdgCancelTimer( &pAdapt->STAInfo.ForwardDelayTimer );
    }

    return rc;
}

BOOLEAN
BrdgSTAPortStateSelection()
/*++

Routine Description:

    Examines all ports and puts them in an appropriate state

Arguments:

    None

Return Value:

    TRUE means the caller should arrange to send a TCN BPDU from outside the
    gSTALock. FALSE means it is not necessary to send such a packet.

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    BOOLEAN             rc = FALSE;
    LOCK_STATE          LockState;
    PADAPT              pAdapt;

    SAFEASSERT( gHaveID );

    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE /*read only*/, &LockState );

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        if( pAdapt->bSTAInited )
        {
            if( pAdapt == gRootAdapter )
            {
                pAdapt->STAInfo.bConfigPending = FALSE;
                pAdapt->STAInfo.bTopologyChangeAck = FALSE;
                BrdgSTAMakeForwarding( pAdapt );
            }
            else if( (BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0) &&
                     (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
            {
                // This port is a designated port.
                BrdgCancelTimer( &pAdapt->STAInfo.MessageAgeTimer );
                pAdapt->STAInfo.LastConfigTime = 0L;
                BrdgSTAMakeForwarding( pAdapt );
            }
            else
            {
                pAdapt->STAInfo.bConfigPending = FALSE;
                pAdapt->STAInfo.bTopologyChangeAck = FALSE;
                rc = BrdgSTAMakeBlocking( pAdapt );
            }
        }
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );

    return rc;
}

VOID
BrdgSTATopologyChangeAcknowledged()
/*++

Routine Description:

    Called when we receive an acknowledgement from the root bridge that
    our topology change notification has been noted.

Arguments:

    None

Return Value:

    None

Locking Constraints:

    ASSUMES the caller has acquired gSTALock

--*/
{
    DBGPRINT(STA, ("BrdgSTATopologyChangeAcknowledged\n"));
    gTopologyChangeDetected = FALSE;
    BrdgCancelTimer( &gTopologyChangeNotificationTimer );
}

VOID
BrdgSTAAcknowledgeTopologyChange(
    IN PADAPT       pAdapt
    )
/*++

Routine Description:

    Called when we are the root bridge to send a config BPDU acknowledging
    another bridge's topology change notification

Arguments:

    pAdapt          The adapter on which the TCN was received

Return Value:

    None

Locking Constraints:

    ASSUMES the caller DOES NOT have gSTALock

--*/
{
    DBGPRINT(STA, ("BrdgSTAAcknowledgeTopologyChange\n"));
    pAdapt->STAInfo.bTopologyChangeAck = TRUE;
    BrdgSTATransmitConfig( pAdapt );
}

VOID
BrdgSTAProcessConfigBPDU(
    IN PADAPT       pAdapt,
    IN PCONFIG_BPDU pbpdu
    )
/*++

Routine Description:

    Processes received BPDU information

Arguments:

    pAdapt          The adapter on which the BPDU was received
    pbpdu           The received information

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    BOOLEAN         bWasRoot;

    NdisAcquireSpinLock( &gSTALock );

    bWasRoot = BrdgSTAWeAreRoot();

    if( BrdgSTASupersedesPortInfo(pAdapt, pbpdu) )
    {
        BOOLEAN     bTransmitTCN = FALSE;

        // The new information is better than what we had before. Use it.
        BrdgSTARecordConfigInfo(pAdapt, pbpdu);
        BrdgSTAConfigUpdate();
        bTransmitTCN = BrdgSTAPortStateSelection();

        if( bWasRoot && (! BrdgSTAWeAreRoot()) )
        {
            // We used to be the root bridge but now we're not!
            DBGPRINT(STA, ("Saw superseding information that made us NOT root on adapter %p\n", pAdapt));

            BrdgCancelTimer( &gHelloTimer );

            if( gTopologyChangeDetected )
            {
                BrdgCancelTimer( &gTopologyChangeTimer );
                bTransmitTCN = TRUE;
                BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
            }
        }

        if( pAdapt == gRootAdapter )
        {
            // This is the root port. Heed config information from the root and pass along
            // its information.
            BrdgSTARecordTimeoutInfo( pbpdu );

            if( pbpdu->bTopologyChangeAck )
            {
                BrdgSTATopologyChangeAcknowledged();
            }

            // Don't send packets from inside the spin lock
            NdisReleaseSpinLock( &gSTALock );

            BrdgSTAGenerateConfigBPDUs();
        }
        else
        {
            NdisReleaseSpinLock( &gSTALock );
        }

        if( bTransmitTCN )
        {
            BrdgSTATransmitTCNPacket();
        }
    }
    else
    {
        // The received information does not supersede our previous info
        SAFEASSERT( gHaveID );

        if( (BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0) &&
            (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
        {
            NdisReleaseSpinLock( &gSTALock );

            // This is the designated port for this link, and the information we just received
            // is inferior to the information we already have. Reply by sending out our own info.
            BrdgSTATransmitConfig(pAdapt);
        }
        else
        {
            NdisReleaseSpinLock( &gSTALock );
        }
    }
}

VOID
BrdgSTAProcessTCNBPDU(
    IN PADAPT           pAdapt
    )
/*++

Routine Description:

    Processes a received TopologyChangeNotification BPDU

Arguments:

    pAdapt          The adapter on which the TCN was received

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    DBGPRINT(STA, ("BrdgSTAProcessTCNBPDU()\n"));
    SAFEASSERT( gHaveID );

    NdisAcquireSpinLock( &gSTALock );

    if( (BrdgSTABridgeIDCmp(pAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0) &&
        (pAdapt->STAInfo.DesignatedPort == pAdapt->STAInfo.ID) )
    {
        BOOLEAN             bTransmitTCN = FALSE;

        // This is a designated port.
        bTransmitTCN = BrdgSTATopologyChangeDetected();
        NdisReleaseSpinLock( &gSTALock );

        if( bTransmitTCN )
        {
            BrdgSTATransmitTCNPacket();
        }

        BrdgSTAAcknowledgeTopologyChange(pAdapt);
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
    }
}

VOID
BrdgSTAHelloTimerExpiry(
    IN PVOID            Unused
    )
/*++

Routine Description:

    Called when the Hello Timer expires. Sends another Config BPDU.

Arguments:

    Unused

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    BrdgSTAGenerateConfigBPDUs();
}

VOID
BrdgSTAMessageAgeTimerExpiry(
    IN PVOID            Context
    )
/*++

Routine Description:

    Called when the Message Age Timer expires. Recalculates STA information
    given the fact that no bridge is being heard on the given port anymore.

Arguments:

    Context             The adapter on which the timer expired

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    PADAPT              pAdapt;
    BOOLEAN             bWasRoot, bTransmitTCN = FALSE;

    NdisAcquireSpinLock( &gSTALock );

    pAdapt = (PADAPT)Context;
    pAdapt->STAInfo.LastConfigTime = 0L;
    bWasRoot = BrdgSTAWeAreRoot();

    BrdgSTABecomeDesignatedPort(pAdapt);
    BrdgSTAConfigUpdate();
    bTransmitTCN = BrdgSTAPortStateSelection();

    if( BrdgSTAWeAreRoot() && (! bWasRoot) )
    {
        DBGPRINT(STA, ("Became root through message age timer expiry of %p\n", pAdapt));

        // We just became root.
        gMaxAge = DEFAULT_MAX_AGE;
        gHelloTime = DEFAULT_HELLO_TIME;
        gForwardDelay = DEFAULT_FORWARD_DELAY;

        bTransmitTCN = BrdgSTATopologyChangeDetected();
        BrdgCancelTimer( &gTopologyChangeNotificationTimer );

        NdisReleaseSpinLock( &gSTALock );

        BrdgSTAGenerateConfigBPDUs();
        BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE /*Periodic*/ );
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
    }

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTAForwardDelayTimerExpiry(
    IN PVOID            Context
    )
/*++

Routine Description:

    Called when the Forward Delay Timer expires. Continues stepping an
    adapter through the process of becoming Forwarding.

Arguments:

    Context             The adapter on which the timer expired

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    PADAPT              pAdapt = (PADAPT)Context;
    BOOLEAN             bTransmitTCN = FALSE;

    NdisAcquireSpinLock( &gSTALock );

    SAFEASSERT( gHaveID );

    if( pAdapt->State == Listening )
    {
        // Move to learning state
        BrdgSTASetAdapterState( pAdapt, Learning );
        BrdgSTASetTimerWithSTATime( &pAdapt->STAInfo.ForwardDelayTimer, gForwardDelay, FALSE /*Not periodic*/ );
    }
    else if( pAdapt->State == Learning )
    {
        LOCK_STATE      LockState;
        PADAPT          anAdapt;

        // Move to forwarding state
        BrdgSTASetAdapterState( pAdapt, Forwarding );

        // If we are the designated port on any link, we need to signal a topology change
        // notification.
        NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read-only*/, &LockState );

        for( anAdapt = gAdapterList; anAdapt != NULL; anAdapt = anAdapt->Next )
        {
            if( anAdapt->bSTAInited )
            {
                if( BrdgSTABridgeIDCmp(anAdapt->STAInfo.DesignatedBridgeID, gOurID) == 0 )
                {
                    bTransmitTCN = BrdgSTATopologyChangeDetected();
                }
            }
        }

        NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
    }

    NdisReleaseSpinLock( &gSTALock );

    if( bTransmitTCN )
    {
        BrdgSTATransmitTCNPacket();
    }
}

VOID
BrdgSTATopologyChangeNotificationTimerExpiry(
    IN PVOID            Unused
    )
/*++

Routine Description:

    Called when the Topology Change Notification Timer expires.
    Transmits another TCN packet.

Arguments:

    Unused

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    if (BrdgFwdBridgingNetworks())
    {
        BrdgSTATransmitTCNPacket();
        BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
    }
}

VOID
BrdgSTATopologyChangeTimerExpiry(
    IN PVOID            Unused
    )
/*++

Routine Description:

    Called when the Topology Change Timer expires. Stops setting the TopologyChange
    flag in outbound Config BPDUs.

Arguments:

    Unused

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    NdisAcquireSpinLock( &gSTALock );
    gTopologyChangeDetected = FALSE;
    BrdgSTAUpdateTopologyChange( FALSE );
    NdisReleaseSpinLock( &gSTALock );
}

VOID
BrdgSTAHoldTimerExpiry(
    IN PVOID            Context
    )
/*++

Routine Description:

    Called when the Hold Timer expires. Sends a Config BPDU.

Arguments:

    Context             The adapter on which the timer expired

Return Value:

    None

Locking Constraints:

    ASSUMES the caller does NOT have gSTALock

--*/
{
    PADAPT              pAdapt = (PADAPT)Context;

    NdisAcquireSpinLock( &gSTALock );

    if( pAdapt->STAInfo.bConfigPending )
    {
        NdisReleaseSpinLock( &gSTALock );
        BrdgSTATransmitConfig( pAdapt );
    }
    else
    {
        NdisReleaseSpinLock( &gSTALock );
    }
}

VOID
BrdgSTACancelTimersGPO()
{
    LOCK_STATE LockState;
    PADAPT pAdapt = NULL;

    //
    // We need to cancel the general STA timers.
    //
    BrdgCancelTimer( &gTopologyChangeTimer );
    BrdgCancelTimer( &gTopologyChangeNotificationTimer );
    BrdgCancelTimer( &gHelloTimer );

    //
    // And the individual HoldTimers and MessageAgeTimers
    //
    NdisAcquireReadWriteLock( &gAdapterListLock, FALSE/*Read-only*/, &LockState );
    
    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // This will only cancel the timer if it is running.
        BrdgCancelTimer(&pAdapt->STAInfo.HoldTimer);
        BrdgCancelTimer(&pAdapt->STAInfo.MessageAgeTimer);
    }

    NdisReleaseReadWriteLock( &gAdapterListLock, &LockState );
}

VOID
BrdgSTARestartTimersGPO()
{
    BrdgSTASetTimerWithSTATime( &gHelloTimer, gHelloTime, TRUE );
}

VOID
BrdgSTAResetSTAInfoGPO()
{
    BOOLEAN PortSelection = FALSE;
    
    NdisAcquireSpinLock(&gSTALock);

    PortSelection = BrdgSTAPortStateSelection();

    // Release the spinlock before we send packets over the wire.
    NdisReleaseSpinLock(&gSTALock);

    BrdgSTASetTimerWithSTATime( &gTopologyChangeNotificationTimer, DEFAULT_HELLO_TIME, FALSE /*Not periodic*/ );
    
    if (PortSelection)
    { 
       BrdgSTATransmitTCNPacket();
    }

    if (!BrdgSTAWeAreRoot())
    {
        // Set the timer on the root adapter to expire immediately, this will force us to re-determine
        // our state.
        BrdgSTASetTimerWithSTATime( &gRootAdapter->STAInfo.MessageAgeTimer, 0, FALSE /*Not periodic*/ );
    }
    else
    {
        BrdgSTAGenerateConfigBPDUs();
    }
    BrdgSTARestartTimersGPO();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgslist.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bdgslist.h

Abstract:

    Ethernet MAC level bridge
    Singly-linked list implementation

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/


//
// A singly-linked list with a length counter
//
typedef struct _BSINGLE_LIST_ENTRY
{
    struct _BSINGLE_LIST_ENTRY      *Next;
} BSINGLE_LIST_ENTRY, *PBSINGLE_LIST_ENTRY;

typedef struct _BSINGLE_LIST_HEAD
{
    PBSINGLE_LIST_ENTRY             Head;
    PBSINGLE_LIST_ENTRY             Tail;
    ULONG                           Length;
} BSINGLE_LIST_HEAD, *PBSINGLE_LIST_HEAD;

//
// Singly-linked list functions
//
__forceinline VOID
BrdgInitializeSingleList(
    PBSINGLE_LIST_HEAD      Head
    )
{
    Head->Head = Head->Tail = NULL;
    Head->Length = 0L;
}

__forceinline ULONG
BrdgQuerySingleListLength(
    PBSINGLE_LIST_HEAD      Head
    )
{
    return Head->Length;
}

__forceinline VOID
BrdgInsertHeadSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry
    )
{
    Entry->Next = Head->Head;
    Head->Head = Entry;

    if( Head->Tail == NULL )
    {
        Head->Tail = Entry;
    }

    Head->Length++;
}

__forceinline VOID
BrdgInterlockedInsertHeadSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry,
    PNDIS_SPIN_LOCK         Lock
    )
{
    NdisAcquireSpinLock( Lock );
    BrdgInsertHeadSingleList( Head, Entry );
    NdisReleaseSpinLock( Lock );
}

__forceinline VOID
BrdgInsertTailSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry
    )
{
    Entry->Next = NULL;

    if( Head->Tail != NULL )
    {
        Head->Tail->Next = Entry;
    }

    if( Head->Head == NULL )
    {
        Head->Head = Entry;
    }

    Head->Tail = Entry;
    Head->Length++;
}

__forceinline VOID
BrdgInterlockedInsertTailSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PBSINGLE_LIST_ENTRY     Entry,
    PNDIS_SPIN_LOCK         Lock
    )
{
    NdisAcquireSpinLock( Lock );
    BrdgInsertTailSingleList( Head, Entry );
    NdisReleaseSpinLock( Lock );
}

__forceinline PBSINGLE_LIST_ENTRY
BrdgRemoveHeadSingleList(
    PBSINGLE_LIST_HEAD      Head
    )
{
    PBSINGLE_LIST_ENTRY     Entry = Head->Head;

    if( Entry != NULL )
    {
        Head->Head = Entry->Next;

        if( Head->Tail == Entry )
        {
            Head->Tail = NULL;
        }

        Head->Length--;
    }

    return Entry;
}

__forceinline PBSINGLE_LIST_ENTRY
BrdgInterlockedRemoveHeadSingleList(
    PBSINGLE_LIST_HEAD      Head,
    PNDIS_SPIN_LOCK         Lock
    )
{
    PBSINGLE_LIST_ENTRY      Entry;

    NdisAcquireSpinLock( Lock );
    Entry = BrdgRemoveHeadSingleList( Head );
    NdisReleaseSpinLock( Lock );

    return Entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgtbl.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgtbl.c

Abstract:

    Ethernet MAC level bridge.
    MAC Table section

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include <netevent.h>

#include "bridge.h"
#include "brdgtbl.h"

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

// Default age at which entries are removed from table
#define DEFAULT_MAX_TBL_AGE     (300 * 1000)        // 5 minutes in milliseconds

//
// Default cap on forwarding table size
//
#define DEFAULT_MAX_TBL_MEMORY  (500 * 1024)        // 500K in bytes

//
// Registry values that hold our config values
//
const PWCHAR                    gMaxTableMemoryParameterName = L"MaxTableMemory";

// Structure of a table entry
typedef struct _MAC_FWDTABLE_ENTRY
{

    HASH_TABLE_ENTRY            hte;
    PADAPT                      pAdapt;

} MAC_FWDTABLE_ENTRY, *PMAC_FWDTABLE_ENTRY;

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// The MAC forwarding table
PHASH_TABLE                     gMACForwardingTable;

// Number of hash buckets (needs to be N^2 for the hash function to work)
#define NUM_HASH_BUCKETS        256

// ===========================================================================
//
// PRIVATE FUNCTIONS
//
// ===========================================================================

// These would all be inlines except that we have to pass pointers to them

//
// Our hash function for Ethernet addresses. Uses the lower bits of byte #4.
//
// This hash function requires NUM_HASH_BUCKETS buckets; don't change this
// without updating the number of hash buckets available.
//
ULONG
BrdgTblHashAddress(
    IN PUCHAR               pAddr
    )
{
    return *((pAddr)+ETH_LENGTH_OF_ADDRESS-2) & (NUM_HASH_BUCKETS-1);
}

//
// Returns TRUE if the pAdapt field in two entries match
//
BOOLEAN
BrdgTblEntriesMatch(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pAdapt
    )
{
    return (BOOLEAN)(((PMAC_FWDTABLE_ENTRY)pEntry)->pAdapt == (PADAPT)pAdapt);
}

//
// Copies the MAC address from a table entry to a data buffer.
//
VOID
BrdgTblCopyEntries(
    PHASH_TABLE_ENTRY           pEntry,
    PUCHAR                      pDest
    )
{
    PMAC_FWDTABLE_ENTRY         pMACEntry = (PMAC_FWDTABLE_ENTRY)pEntry;

    // The MAC address is the key. Copy it to the target buffer.
    ETH_COPY_NETWORK_ADDRESS( pDest, pMACEntry->hte.key );
}

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

NTSTATUS
BrdgTblDriverInit()
/*++

Routine Description:

    Load-time initialization function

Arguments:

    None

Return Value:

    Status of initialization. A return code != STATUS_SUCCESS aborts driver load.

--*/
{
    NTSTATUS            NtStatus;
    ULONG               MaxMemory, MaxEntries;

    NtStatus = BrdgReadRegDWord( &gRegistryPath, gMaxTableMemoryParameterName, &MaxMemory );

    if( NtStatus != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Failed to read MaxTableMemory value: %08x\n", NtStatus));
        MaxMemory = DEFAULT_MAX_TBL_MEMORY;
        DBGPRINT(GENERAL, ( "Using DEFAULT maximum memory of %i\n", MaxMemory ));
    }

    MaxEntries = MaxMemory / sizeof(MAC_FWDTABLE_ENTRY);
    DBGPRINT(GENERAL, ( "Forwarding table cap set at %i entries (%iK of memory)\n", MaxEntries, MaxMemory / 1024 ));

    gMACForwardingTable = BrdgHashCreateTable( BrdgTblHashAddress, NUM_HASH_BUCKETS, sizeof(MAC_FWDTABLE_ENTRY),
                                               MaxEntries, DEFAULT_MAX_TBL_AGE, DEFAULT_MAX_TBL_AGE,
                                               ETH_LENGTH_OF_ADDRESS );

    if( gMACForwardingTable == NULL )
    {
        DBGPRINT(FWD, ("FAILED TO ALLOCATE MAC TABLE!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

//
// Creates a new table entry associating the given MAC address with the given
// adapter, or refreshes an existing entry.
//
VOID
BrdgTblNoteAddress(
    IN PUCHAR                   pAddr,
    IN PADAPT                   pAdapt
    )
/*++

Routine Description:

    Creates a new table entry associating the given MAC address with the given
    adapter, or refreshes an existing entry.

Arguments:

    pAddr                       The MAC address to look up
    pAdapt                      The adapter to associate it with

Return Value:

    None

--*/
{
    PMAC_FWDTABLE_ENTRY         pEntry;
    BOOLEAN                     bIsNewEntry;
    LOCK_STATE                  LockState;

    // Refuse to record non-unicast addresses
    if( ETH_IS_MULTICAST(pAddr) )
    {
        THROTTLED_DBGPRINT(FWD, ("## BRIDGE ## Not recording multicast address in BrdgTblNoteAddress\n"));
        return;
    }

    pEntry = (PMAC_FWDTABLE_ENTRY)BrdgHashRefreshOrInsert( gMACForwardingTable, pAddr, &bIsNewEntry, &LockState);

    if( pEntry != NULL )
    {
        // Regardless of whether or not this is a new table entry or an existing one,
        // just cram in the adapter pointer with an interlocked instruction.
        InterlockedExchangePointer( &pEntry->pAdapt, pAdapt );

        // Since the function came back != NULL, we must release the table lock.
        NdisReleaseReadWriteLock( &gMACForwardingTable->tableLock, &LockState );
    }
}


PADAPT
BrdgTblFindTargetAdapter(
    IN PUCHAR                   pAddr
    )
/*++

Routine Description:

    Locates the adapter corresponding to a particular MAC address.

    If an adapter is found, this function returns a PADAPT pointer after
    having INCREMENTED THE REFCOUNT for that adapter. This is to ensure that
    the adapter is not unbound until the caller is done using it. The caller
    should be sure to decrement the PADAPT's refcount when it is done using
    the pointer.

Arguments:

    pAddr                       The MAC address to look up

Return Value:

    A pointer to the ADAPT structure describing the adapter associated with
    the given MAC address, with its refcount INCREMENTED, or NULL if an
    entry associating the given MAC address to an adapter was not found.

--*/
{
    PMAC_FWDTABLE_ENTRY         pEntry;
    LOCK_STATE                  LockState;
    PADAPT                      pAdapt = NULL;

    pEntry = (PMAC_FWDTABLE_ENTRY)BrdgHashFindEntry( gMACForwardingTable, pAddr, &LockState );

    if( pEntry != NULL )
    {
        // Read this once since it can be changed even while we hold the RW lock
        pAdapt = pEntry->pAdapt;
        SAFEASSERT( pAdapt != NULL );

        //
        // Increment this adapter's refcount while inside the RW lock for the table.
        // This lets us close a race condition window for unbinding the adapter;
        // the caller will hang on to the returned PADAPT after we return, leading
        // to problems if the adapter is unbound before our caller is done using
        // the PADAPT structure.
        //
        BrdgAcquireAdapterInLock( pAdapt );

        // Release the table lock
        NdisReleaseReadWriteLock( &gMACForwardingTable->tableLock, &LockState );
    }

    return pAdapt;
}

//
// This function cleans all the adapters from the tables (this is in the case of a GPO changing
// our bridging settings)
//

VOID
BrdgTblScrubAllAdapters()
{
    PADAPT                      pAdapt = NULL;
    LOCK_STATE                  LockStateMACTable;
    LOCK_STATE                  LockStateAdapterList;

    //
    // We don't want the table to be modified while we're doing this, and we also don't want an adapter
    // to go away while we're enumerating the list of adapters.
    //
    NdisAcquireReadWriteLock(&gMACForwardingTable->tableLock, FALSE /*Read Only*/, &LockStateMACTable);
    NdisAcquireReadWriteLock(&gAdapterListLock, FALSE /*Read Only*/, &LockStateAdapterList);

    for( pAdapt = gAdapterList; pAdapt != NULL; pAdapt = pAdapt->Next )
    {
        // Scrub adapter from the table.
        BrdgTblScrubAdapter(pAdapt);
    }

    NdisReleaseReadWriteLock(&gAdapterListLock, &LockStateAdapterList);
    NdisReleaseReadWriteLock(&gMACForwardingTable->tableLock, &LockStateMACTable);
}

VOID
BrdgTblCleanup()
/*++

Routine Description:

    Unload-time orderly shutdown

    This function is guaranteed to be called exactly once

Arguments:

    None

Return Value:

    None

--*/
{
    SAFEASSERT( gMACForwardingTable != NULL );
    BrdgHashFreeHashTable( gMACForwardingTable );
    gMACForwardingTable = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgtdi.h ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdgtdi.h

Abstract:

    Ethernet MAC level bridge.
    Tdi registration for address notifications.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    March  2002 - Original version

--*/


// ===========================================================================
//
// TYPES
//
// ===========================================================================

typedef struct _BRDG_TDI_GLOBALS
{
    UNICODE_STRING              ClientName;
    TDI_CLIENT_INTERFACE_INFO   ciiBridge;
    HANDLE                      hBindingHandle;
} BRDG_TDI_GLOBALS, *PBRDG_TDI_GLOBALS;

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgTdiDriverInit();

VOID
BrdgTdiCleanup();

typedef struct _in_addr {
    union {
        struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
        struct { USHORT s_w1,s_w2; } S_un_w;
        ULONG S_addr;
    } S_un;
} in_addr;

NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength);



#define s_addr  S_un.S_addr

BOOLEAN IsLower(WCHAR c);
BOOLEAN IsDigit(WCHAR c);
BOOLEAN IsXDigit(WCHAR c);

NTSTATUS
BrdgTdiIpv4StringToAddress(
    IN LPWSTR String,
    IN BOOLEAN Strict,
    OUT LPWSTR *Terminator,
    OUT in_addr *Addr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgtbl.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgtbl.h

Abstract:

    Ethernet MAC level bridge.
    MAC Table section
    PUBLIC header

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/
    
// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// The MAC forwarding table
extern PHASH_TABLE                      gMACForwardingTable;

// Default age at which entries are removed from table
#define DEFAULT_MAX_TBL_AGE             (300 * 1000)        // 5 minutes in milliseconds

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

//
// These need to be exposed here to make the inlines below work.
// Pretend they're not here.
//

VOID
BrdgTableRefreshInsertEntry(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pData
    );

BOOLEAN
BrdgTblEntriesMatch(
    IN PHASH_TABLE_ENTRY        pEntry,
    IN PVOID                    pAdapt
    );

VOID
BrdgTblCopyEntries(
    PHASH_TABLE_ENTRY           pEntry,
    PUCHAR                      pDest
    );

VOID
BrdgTblNoteAddress(
    IN PUCHAR                   pAddr,
    IN PADAPT                   pAdapt
    );

// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Changes the forwarding table timeout value.
//
__forceinline
VOID
BrdgTblSetTimeout(
    IN ULONG                    Timeout
    )
{
    DBGPRINT(FWD, ("Adopting a shorter table timeout value of %ims\n", Timeout));
    SAFEASSERT( gMACForwardingTable != NULL );
    BrdgHashChangeTableTimeout( gMACForwardingTable, Timeout );
}

//
// Sets the table timeout value back to its default
//
__forceinline
VOID
BrdgTblRevertTimeout()
{
    DBGPRINT(FWD, ("Reverting to default timeout value of %ims\n", DEFAULT_MAX_TBL_AGE));
    SAFEASSERT( gMACForwardingTable != NULL );
    BrdgHashChangeTableTimeout( gMACForwardingTable, DEFAULT_MAX_TBL_AGE );
}

//
// Removes all entries that reference the given adapter
//
__forceinline
VOID
BrdgTblScrubAdapter(
    IN PADAPT           pAdapt
    )
{
    DBGPRINT(FWD, ("Scrubbing adapter %p from the MAC table...\n", pAdapt));
    BrdgHashRemoveMatching( gMACForwardingTable, BrdgTblEntriesMatch, pAdapt );
}

//
// Copies all the MAC addresses that appear in the forwarding table that
// are associated with the given adapter to the given data buffer.
//
// The return value is the room necessary to hold all the data. If the
// return value is <= BufferLength, the buffer was sufficiently large
// to hold the data and it was all copied.
//
__forceinline
ULONG
BrdgTblReadTable(
    IN PADAPT                   pAdapt,
    IN PUCHAR                   pBuffer,
    IN ULONG                    BufferLength
    )
{
    return BrdgHashCopyMatching( gMACForwardingTable, BrdgTblEntriesMatch, BrdgTblCopyEntries,
                                 ETH_LENGTH_OF_ADDRESS, pAdapt, pBuffer, BufferLength );
}

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgTblDriverInit();

PADAPT
BrdgTblFindTargetAdapter(
    IN PUCHAR                   pAddr
    );

VOID
BrdgTblCleanup();

VOID
BrdgTblScrubAllAdapters();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgstad.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgstad.h

Abstract:

    Ethernet MAC level bridge.
    STA type and structure declarations file

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    June 2000 - Original version

--*/

//
// A number of type and constant definitions are in bioctl.h, which must be
// included before this file.
//

// ===========================================================================
//
// STRUCTURES
//
// ===========================================================================

// STA information associated with every port (adapter)
typedef struct _STA_ADAPT_INFO
{
    // Unique ID for this port
    PORT_ID             ID;

    // Cost of this link
    ULONG               PathCost;

    // The bridge reported as root on this link
    UCHAR               DesignatedRootID[BRIDGE_ID_LEN];

    // The reported cost to reach the root on this link
    PATH_COST           DesignatedCost;

    // The designated bridge on this link
    UCHAR               DesignatedBridgeID[BRIDGE_ID_LEN];

    // The designated port on this link
    PORT_ID             DesignatedPort;

    // Topology Change Acknowledge for this link
    BOOLEAN             bTopologyChangeAck;

    // Whether a BPDU transmit was attempted while not allowed
    // because of the maximum inter-BPDU time enforcement
    BOOLEAN             bConfigPending;

    // Timer to age out the last received config information on this link
    BRIDGE_TIMER        MessageAgeTimer;

    // Timestamp of when the last config we received was generated
    // (this is gMaxAge - (time left on MessageAgeTimer) ms ago)
    // When the message age timer is not running, this is set to 0L.
    ULONG               LastConfigTime;

    // Timer for transitioning between port states
    BRIDGE_TIMER        ForwardDelayTimer;

    // Timer for preventing BPDUs from being transmitted too frequently
    BRIDGE_TIMER        HoldTimer;

} STA_ADAPT_INFO, *PSTA_ADAPT_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgtdi.c ===
/*++

Copyright(c) 1999-2002  Microsoft Corporation

Module Name:

    brdgtdi.c

Abstract:

    Ethernet MAC level bridge.
    Tdi registration for address notifications.

Author:

    Salahuddin J. Khan (sjkhan)
    
Environment:

    Kernel mode

Revision History:

    March  2002 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <tdikrnl.h>
#include <ntstatus.h>
#include <wchar.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgtdi.h"

#include "brdgsta.h"
#include "brdgmini.h"
#include "brdgprot.h"
#include "brdgbuf.h"
#include "brdgfwd.h"
#include "brdgtbl.h"
#include "brdgctl.h"
#include "brdggpo.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

BRDG_TDI_GLOBALS g_BrdgTdiGlobals;

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

#define MAX_GUID_LEN        39
#define MAX_IP4_STRING_LEN  17

const WCHAR TcpipAdaptersKey[]    = {L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters"};

// ===========================================================================
//
// PRIVATE PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgTdiPnpPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    );

VOID
BrdgTdiBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING DeviceName,
    IN PWSTR MultiSZBindList
    );

VOID
BrdgTdiAddAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    );

VOID
BrdgTdiDelAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    );

VOID
TSPrintTaAddress(PTA_ADDRESS  pTaAddress);

// ===========================================================================
//
// INLINE FUNCTIONS
//
// ===========================================================================

__forceinline
BOOLEAN
IsLower(WCHAR c)
{
    return (BOOLEAN)((c >= L'a') && (c <= 'z'));
}

__forceinline
BOOLEAN
IsDigit(WCHAR c)
{
    return (BOOLEAN)((c >= L'0') && (c <= '9'));
}

__forceinline
BOOLEAN
IsXDigit(WCHAR c)
{
    return (BOOLEAN)( ((c >= L'0') && (c <= '9')) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F')) );
}

// ===========================================================================
//
// BRIDGE TDI IMPLEMENTATION
//
// ===========================================================================

VOID
BrdgTdiInitializeClientInterface(
    IN PTDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo,
    IN PUNICODE_STRING            ClientName
    )
{
    DBGPRINT(TDI, ("BrdgTdiInitializeClientInterface\r\n"));
    ClientInterfaceInfo->MajorTdiVersion = TDI_CURRENT_MAJOR_VERSION;
    ClientInterfaceInfo->MinorTdiVersion = TDI_CURRENT_MINOR_VERSION;
    ClientInterfaceInfo->ClientName = ClientName;
    ClientInterfaceInfo->PnPPowerHandler = BrdgTdiPnpPowerHandler;
    ClientInterfaceInfo->BindingHandler = BrdgTdiBindingHandler;
    ClientInterfaceInfo->AddAddressHandlerV2 = BrdgTdiAddAddressHandler;
    ClientInterfaceInfo->DelAddressHandlerV2 = BrdgTdiDelAddressHandler;
}

NTSTATUS
BrdgTdiDriverInit()
/*++

Routine Description:

    Driver load-time initialization

Return Value:

    Status of initialization

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS            status;

    DBGPRINT(TDI, ("BrdgTdiDriverInit\r\n"));
    
    RtlInitUnicodeString(&g_BrdgTdiGlobals.ClientName, L"Bridge");

    RtlZeroMemory(&g_BrdgTdiGlobals.ciiBridge, sizeof(TDI_CLIENT_INTERFACE_INFO));

    BrdgTdiInitializeClientInterface(&g_BrdgTdiGlobals.ciiBridge, &g_BrdgTdiGlobals.ClientName);

    status = BrdgGpoDriverInit();
        
    if (!NT_SUCCESS(status))
    {
        BrdgTdiCleanup();
    }
    else
    {
        status = TdiRegisterPnPHandlers(&g_BrdgTdiGlobals.ciiBridge, 
                                        sizeof(TDI_CLIENT_INTERFACE_INFO), 
                                        &g_BrdgTdiGlobals.hBindingHandle);
    }

    return status;
}

VOID
BrdgTdiCleanup()
/*++

Routine Description:

    Driver shutdown cleanup

Return Value:

    None

Locking Constraints:

    Top-level function. Assumes no locks are held by caller.

--*/
{
    NTSTATUS status;
    
    status = TdiDeregisterPnPHandlers(g_BrdgTdiGlobals.hBindingHandle);
    
    SAFEASSERT(NT_SUCCESS(status));

    BrdgGpoCleanup();
}

NTSTATUS
BrdgTdiPnpPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    )
{
    DBGPRINT(TDI, ("BrdgTdiPnpPowerHandler\r\n"));
    return STATUS_SUCCESS;
}

VOID
BrdgTdiBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING DeviceName,
    IN PWSTR MultiSZBindList
    )
{
    DBGPRINT(TDI, ("BrdgTdiBindingHandler\r\n"));
}

VOID
BrdgTdiAddAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    )
/*++

Routine Description:
    
    Called if a new address is added.

Arguments:

    Address     -   New address that has been added.
    
    DeviceName  -   The device that this is changing for.

    Context     -   Not something we're interested in for now.

Return Value:

    None.

--*/

{
    DBGPRINT(TDI, ("BrdgTdiAddAddressHandler\r\n"));

    if ((Address->AddressType == TDI_ADDRESS_TYPE_IP))
    {
        if (NULL != DeviceName->Buffer)
        {
            //
            // Find the start of the GUID
            //
            PWCHAR DeviceId = wcsrchr(DeviceName->Buffer, L'{');
            if (NULL != DeviceId)
            {
                NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
                LPWSTR          AdapterPath;

                AdapterPath = ExAllocatePoolWithTag(PagedPool, 
                                                    (wcslen(TcpipAdaptersKey) + 1 + wcslen(DeviceId) + 1) * sizeof(WCHAR), 
                                                    'gdrB');
                if (AdapterPath)
                {
                    OBJECT_ATTRIBUTES   ObAttr;
                    UNICODE_STRING      Adapter;
                    HANDLE              hKey;
                    
                    wcscpy(AdapterPath, TcpipAdaptersKey);
                    wcscat(AdapterPath, L"\\");
                    wcscat(AdapterPath, DeviceId);

                    RtlInitUnicodeString(&Adapter, AdapterPath);

                    InitializeObjectAttributes( &ObAttr,
                                                &Adapter,
                                                OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
                                                NULL,
                                                NULL);

                    status = ZwOpenKey(&hKey,
                                       KEY_READ,
                                       &ObAttr);

                    if (NT_SUCCESS(status))
                    {
                        ZwClose(hKey);
                        //
                        // This is a valid adapter on this machine.  Otherwise it could be an NdisAdapter etc and
                        // we don't pay attention to these for group policies.
                        //
                        BrdgGpoNewAddressNotification(DeviceId);
                    }

                    ExFreePool(AdapterPath);
                }
            }
        }
#if DBG
        TSPrintTaAddress(Address);
#endif
    }
}

VOID
BrdgTdiDelAddressHandler(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    )
{
    DBGPRINT(TDI, ("BrdgTdiDelAddressHandler\r\n"));
    //
    // We don't delete the current list of networks that we have since we need them to make
    // an accurate assessment on whether to follow the GPO.  Instead, the AddAddressHandler
    // will simply update the existing network address for the ID's and if this results in 
    // a different network then we'll change the bridge mode.
    //
}

VOID
TSPrintTaAddress(PTA_ADDRESS  pTaAddress)
{
   BOOLEAN  fShowAddress = TRUE;

   DbgPrint("AddressType = TDI_ADDRESS_TYPE_");
   switch (pTaAddress->AddressType)
   {
      case TDI_ADDRESS_TYPE_UNSPEC:
         DbgPrint("UNSPEC\n");
         break;
      case TDI_ADDRESS_TYPE_UNIX:
         DbgPrint("UNIX\n");
         break;

      case TDI_ADDRESS_TYPE_IP:
         DbgPrint("IP\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IP   pTdiAddressIp = (PTDI_ADDRESS_IP)pTaAddress->Address;
            PUCHAR            pucTemp       = (PUCHAR)&pTdiAddressIp->in_addr;
            DbgPrint("sin_port = 0x%04x\n"
                        "in_addr  = %u.%u.%u.%u\n",
                         pTdiAddressIp->sin_port,
                         pucTemp[0], pucTemp[1],
                         pucTemp[2], pucTemp[3]);
         }
         break;

      case TDI_ADDRESS_TYPE_IMPLINK:
         DbgPrint("IMPLINK\n");
         break;
      case TDI_ADDRESS_TYPE_PUP:
         DbgPrint("PUP\n");
         break;
      case TDI_ADDRESS_TYPE_CHAOS:
         DbgPrint("CHAOS\n");
         break;

      case TDI_ADDRESS_TYPE_IPX:
         DbgPrint("IPX\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IPX  pTdiAddressIpx = (PTDI_ADDRESS_IPX)pTaAddress->Address;
            DbgPrint("NetworkAddress = 0x%08x\n"
                        "NodeAddress    = %u.%u.%u.%u.%u.%u\n"
                        "Socket         = 0x%04x\n",
                         pTdiAddressIpx->NetworkAddress,
                         pTdiAddressIpx->NodeAddress[0],
                         pTdiAddressIpx->NodeAddress[1],
                         pTdiAddressIpx->NodeAddress[2],
                         pTdiAddressIpx->NodeAddress[3],
                         pTdiAddressIpx->NodeAddress[4],
                         pTdiAddressIpx->NodeAddress[5],
                         pTdiAddressIpx->Socket);
                  
         }
         break;

      case TDI_ADDRESS_TYPE_NBS:
         DbgPrint("NBS\n");
         break;
      case TDI_ADDRESS_TYPE_ECMA:
         DbgPrint("ECMA\n");
         break;
      case TDI_ADDRESS_TYPE_DATAKIT:
         DbgPrint("DATAKIT\n");
         break;
      case TDI_ADDRESS_TYPE_CCITT:
         DbgPrint("CCITT\n");
         break;
      case TDI_ADDRESS_TYPE_SNA:
         DbgPrint("SNA\n");
         break;
      case TDI_ADDRESS_TYPE_DECnet:
         DbgPrint("DECnet\n");
         break;
      case TDI_ADDRESS_TYPE_DLI:
         DbgPrint("DLI\n");
         break;
      case TDI_ADDRESS_TYPE_LAT:
         DbgPrint("LAT\n");
         break;
      case TDI_ADDRESS_TYPE_HYLINK:
         DbgPrint("HYLINK\n");
         break;

      case TDI_ADDRESS_TYPE_APPLETALK:
         DbgPrint("APPLETALK\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_APPLETALK  pTdiAddressAppleTalk = (PTDI_ADDRESS_APPLETALK)pTaAddress->Address;

            DbgPrint("Network = 0x%04x\n"
                        "Node    = 0x%02x\n"
                        "Socket  = 0x%02x\n",
                         pTdiAddressAppleTalk->Network,
                         pTdiAddressAppleTalk->Node,
                         pTdiAddressAppleTalk->Socket);
         }
         break;

      case TDI_ADDRESS_TYPE_NETBIOS:
         DbgPrint("NETBIOS\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETBIOS pTdiAddressNetbios = (PTDI_ADDRESS_NETBIOS)pTaAddress->Address;
            UCHAR                pucName[17];

            //
            // make sure we have a zero-terminated name to print...
            //
            RtlCopyMemory(pucName, pTdiAddressNetbios->NetbiosName, 16);
            pucName[16] = 0;
            DbgPrint("NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_");
            switch (pTdiAddressNetbios->NetbiosNameType)
            {
               case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
                  DbgPrint("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
                  DbgPrint("GROUP\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
                  DbgPrint("QUICK_UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
                  DbgPrint("QUICK_GROUP\n");
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n", 
                               pTdiAddressNetbios->NetbiosNameType);
                  break;
            }
            DbgPrint("NetbiosName = %s\n", pucName);
         }
         break;

      case TDI_ADDRESS_TYPE_8022:
         DbgPrint("8022\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_8022    pTdiAddress8022 = (PTDI_ADDRESS_8022)pTaAddress->Address;
            
            DbgPrint("Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
                         pTdiAddress8022->MACAddress[0],
                         pTdiAddress8022->MACAddress[1],
                         pTdiAddress8022->MACAddress[2],
                         pTdiAddress8022->MACAddress[3],
                         pTdiAddress8022->MACAddress[4],
                         pTdiAddress8022->MACAddress[5]);

         }
         break;

      case TDI_ADDRESS_TYPE_OSI_TSAP:
         DbgPrint("OSI_TSAP\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_OSI_TSAP   pTdiAddressOsiTsap = (PTDI_ADDRESS_OSI_TSAP)pTaAddress->Address;
            ULONG                   ulSelectorLength;
            ULONG                   ulAddressLength;
            PUCHAR                  pucTemp = pTdiAddressOsiTsap->tp_addr;

            DbgPrint("TpAddrType = ISO_");
            switch (pTdiAddressOsiTsap->tp_addr_type)
            {
               case ISO_HIERARCHICAL:
                  DbgPrint("HIERARCHICAL\n");
                  ulSelectorLength = pTdiAddressOsiTsap->tp_tsel_len;
                  ulAddressLength  = pTdiAddressOsiTsap->tp_taddr_len;
                  break;
               case ISO_NON_HIERARCHICAL:
                  DbgPrint("NON_HIERARCHICAL\n");
                  ulSelectorLength = 0;
                  ulAddressLength  = pTdiAddressOsiTsap->tp_taddr_len;
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n",
                               pTdiAddressOsiTsap->tp_addr_type);
                  ulSelectorLength = 0;
                  ulAddressLength  = 0;
                  break;
            }
            if (ulSelectorLength)
            {
               ULONG    ulCount;

               DbgPrint("TransportSelector:  ");
               for (ulCount = 0; ulCount < ulSelectorLength; ulCount++)
               {
                  DbgPrint("%02x ", *pucTemp);
                  ++pucTemp;
               }
               DbgPrint("\n");
            }
            if (ulAddressLength)
            {
               ULONG    ulCount;

               DbgPrint("TransportAddress:  ");
               for (ulCount = 0; ulCount < ulAddressLength; ulCount++)
               {
                  DbgPrint("%02x ", *pucTemp);
                  ++pucTemp;
               }
               DbgPrint("\n");
            }
         }
         break;

      case TDI_ADDRESS_TYPE_NETONE:
         DbgPrint("NETONE\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETONE  pTdiAddressNetone = (PTDI_ADDRESS_NETONE)pTaAddress->Address;
            UCHAR                pucName[21];

            //
            // make sure have 0-terminated name
            //
            RtlCopyMemory(pucName,
                          pTdiAddressNetone->NetoneName,
                          20);
            pucName[20] = 0;
            DbgPrint("NetoneNameType = TDI_ADDRESS_NETONE_TYPE_");
            switch (pTdiAddressNetone->NetoneNameType)
            {
               case TDI_ADDRESS_NETONE_TYPE_UNIQUE:
                  DbgPrint("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETONE_TYPE_ROTORED:
                  DbgPrint("ROTORED\n");
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n", 
                               pTdiAddressNetone->NetoneNameType);
                  break;
            }
            DbgPrint("NetoneName = %s\n",
                         pucName);
         }
         break;

      case TDI_ADDRESS_TYPE_VNS:
         DbgPrint("VNS\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_VNS  pTdiAddressVns = (PTDI_ADDRESS_VNS)pTaAddress->Address;

            DbgPrint("NetAddress:  %02x-%02x-%02x-%02x\n",
                         pTdiAddressVns->net_address[0],
                         pTdiAddressVns->net_address[1],
                         pTdiAddressVns->net_address[2],
                         pTdiAddressVns->net_address[3]);
            DbgPrint("SubnetAddr:  %02x-%02x\n"
                        "Port:        %02x-%02x\n"
                        "Hops:        %u\n",
                         pTdiAddressVns->subnet_addr[0],
                         pTdiAddressVns->subnet_addr[1],
                         pTdiAddressVns->port[0],
                         pTdiAddressVns->port[1],
                         pTdiAddressVns->hops);


         }
         break;

      case TDI_ADDRESS_TYPE_NETBIOS_EX:
         DbgPrint("NETBIOS_EX\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETBIOS_EX pTdiAddressNetbiosEx = (PTDI_ADDRESS_NETBIOS_EX)pTaAddress->Address;
            UCHAR                   pucEndpointName[17];
            UCHAR                   pucNetbiosName[17];

            //
            // make sure we have zero-terminated names to print...
            //
            RtlCopyMemory(pucEndpointName,
                          pTdiAddressNetbiosEx->EndpointName,
                          16);
            pucEndpointName[16] = 0;
            RtlCopyMemory(pucNetbiosName, 
                          pTdiAddressNetbiosEx->NetbiosAddress.NetbiosName, 
                          16);
            pucNetbiosName[16] = 0;

            DbgPrint("EndpointName    = %s\n"
                        "NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_",
                         pucEndpointName);

            switch (pTdiAddressNetbiosEx->NetbiosAddress.NetbiosNameType)
            {
               case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
                  DbgPrint("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
                  DbgPrint("GROUP\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
                  DbgPrint("QUICK_UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
                  DbgPrint("QUICK_GROUP\n");
                  break;
               default:
                  DbgPrint("INVALID [0x%04x]\n", 
                               pTdiAddressNetbiosEx->NetbiosAddress.NetbiosNameType);
                  break;
            }
            DbgPrint("NetbiosName = %s\n", pucNetbiosName);
         }
         break;

      case TDI_ADDRESS_TYPE_IP6:
         DbgPrint("IPv6\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IP6  pTdiAddressIp6 = (PTDI_ADDRESS_IP6)pTaAddress->Address;
            PUCHAR            pucTemp        = (PUCHAR)&pTdiAddressIp6->sin6_addr;

            DbgPrint("SinPort6 = 0x%04x\n"
                        "FlowInfo = 0x%08x\n"
                        "ScopeId  = 0x%08x\n",
                         pTdiAddressIp6->sin6_port,
                         pTdiAddressIp6->sin6_flowinfo,
                         pTdiAddressIp6->sin6_scope_id);

            DbgPrint("In6_addr = %x%02x:%x%02x:%x%02x:%x%02x:",
                         pucTemp[0], pucTemp[1],
                         pucTemp[2], pucTemp[3],
                         pucTemp[4], pucTemp[5],
                         pucTemp[6], pucTemp[7]);
            DbgPrint("%x%02x:%x%02x:%x%02x:%x%02x\n",
                         pucTemp[8],  pucTemp[9],
                         pucTemp[10], pucTemp[11],
                         pucTemp[12], pucTemp[13],
                         pucTemp[14], pucTemp[15]);
         }
         break;

      default:
         DbgPrint("UNKNOWN [0x%08x]\n", pTaAddress->AddressType);
         break;
   }

   if (fShowAddress)
   {
      PUCHAR    pucTemp = pTaAddress->Address;
      ULONG     ulCount;

      DbgPrint("AddressLength = %d\n"
                  "Address       = ",
                   pTaAddress->AddressLength);

      for (ulCount = 0; ulCount < pTaAddress->AddressLength; ulCount++)
      {
         DbgPrint("%02x ", *pucTemp);
         pucTemp++;
      }

      DbgPrint("\n");
   }
}

NTSTATUS
BrdgTdiIpv4StringToAddress(
    IN LPWSTR String,
    IN BOOLEAN Strict,
    OUT LPWSTR *Terminator,
    OUT in_addr *Addr)

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

    Addr - Receives a pointer to the structure to fill in with
        a suitable binary representation of the Internet address given. 

Return Value:

    TRUE if parsing was successful. FALSE otherwise.

--*/

{
    ULONG val, n;
    LONG base;
    WCHAR c;
    ULONG parts[4], *pp = parts;
    BOOLEAN sawDigit;

again:
    //
    // We must see at least one digit for address to be valid.
    //
    sawDigit = FALSE; 

    //
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*String == L'0') 
    {
        String++;
        if (IsDigit(*String)) 
        {
            base = 8;
        } else if (*String == L'x' || *String == L'X') 
        {
            base = 16;
            String++;
        } else 
        {
            //
            // It is still decimal but we saw the digit
            // and it was 0.
            //
            sawDigit = TRUE;
        }
    }
    if (Strict && (base != 10)) 
    {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    do
    {
        ULONG newVal;
        
        c = *String;
        
        if (IsDigit(c) && ((c - L'0') < base)) {
            newVal = (val * base) + (c - L'0');
        } else if ((base == 16) && IsXDigit(c)) {
            newVal = (val << 4) + (c + 10 - (IsLower(c) ? L'a' : L'A'));
        } else {
            break;
        }

        //
        // Protect from overflow
        //
        if (newVal < val) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        String++;
        sawDigit = TRUE;
        val = newVal;
    } while (c != L'\0');

    if (*String == L'.')
    {
        //
        // Internet format:
        //      a.b.c.d
        //      a.b.c   (with c treated as 16-bits)
        //      a.b     (with b treated as 24 bits)
        //
        if (pp >= parts + 3) 
        {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        *pp++ = val, String++;

        //
        // Check if we saw at least one digit.
        //
        if (!sawDigit) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }

        goto again;
    } while (c != L'\0');

    //
    // Check if we saw at least one digit.
    //
    if (!sawDigit) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    *pp++ = val;

    //
    // Concoct the address according to
    // the number of parts specified.
    //
    n = (ULONG)(pp - parts);
    if (Strict && (n != 4)) {
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }
    switch ((int) n) {

    case 1:                         /* a -- 32 bits */
        val = parts[0];
        break;

    case 2:                         /* a.b -- 8.24 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:                         /* a.b.c -- 8.8.16 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xffff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                (parts[2] & 0xffff);
        break;

    case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
        if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
            (parts[2] > 0xff) || (parts[3] > 0xff)) {
            *Terminator = String;
            return STATUS_INVALID_PARAMETER;
        }
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        *Terminator = String;
        return STATUS_INVALID_PARAMETER;
    }

    val = RtlUlongByteSwap(val);
    *Terminator = String;
    Addr->s_addr = val;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgtimr.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgtimr.h

Abstract:

    Ethernet MAC level bridge.
    Timer implementation header

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    November  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================
                            
// Bridge timer function definition
typedef VOID (*PBRIDGE_TIMER_FUNC)(PVOID);

typedef struct _BRIDGE_TIMER
{
    NDIS_TIMER              Timer;                  // The actual timer
    NDIS_EVENT              Event;                  // Only used during final shutdown, and even then,
                                                    // only if normal cancellation of the timer fails.

    // Lock protects bShuttingDown, bRunning, bCanceled, bRecurring and bInterval.
    NDIS_SPIN_LOCK          Lock;
    BOOLEAN                 bShuttingDown;          // TRUE if the timer is being shut down for good
    BOOLEAN                 bRunning;               // Whether the timer is currently running
    BOOLEAN                 bCancelPending;         // Whether the timer is being canceled
    BOOLEAN                 bRecurring;             // Whether the timer is recurrant
    UINT                    Interval;               // Timer interval (for use if bRecurring == TRUE)

    // These fields do not change once the timer is initialized
    PBRIDGE_TIMER_FUNC      pFunc;                  // The timer function
    PVOID                   data;                   // Data to pass to pFunc
} BRIDGE_TIMER, *PBRIDGE_TIMER;


// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

VOID
BrdgInitializeTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN PBRIDGE_TIMER_FUNC   pFunc,
    IN PVOID                data
    );
VOID
BrdgSetTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN UINT                 interval,
    IN BOOLEAN              bRecurring
    );

VOID
BrdgShutdownTimer(
    IN PBRIDGE_TIMER        pTimer
    );
VOID
BrdgCancelTimer(
    IN PBRIDGE_TIMER        pTimer
    );


// ===========================================================================
//
// INLINES
//
// ===========================================================================

//
// Returns whether a timer is currently running
//
__forceinline
BOOLEAN
BrdgTimerIsRunning(
    IN PBRIDGE_TIMER            pTimer
    )
{
    return pTimer->bRunning;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgwref.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgwait.h

Abstract:

    Ethernet MAC level bridge
    WAIT_REFCOUNT implementation

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

// ===========================================================================
//
// DECLARATIONS
//
// ===========================================================================

//
// Structure for a refcount that can be waited against (when waiting for 0)
//

typedef enum
{
    WaitRefEnabled = 0,
    WaitRefShuttingDown,
    WaitRefShutdown
} WAIT_REFCOUNT_STATE;

typedef struct _WAIT_REFCOUNT
{
    LONG                    Refcount;               // The refcount
    NDIS_EVENT              Event;                  // Signaled when RefCount hits 0
    WAIT_REFCOUNT_STATE     state;                  // Current state
    BOOLEAN                 bResettable;            // TRUE if it's OK to reset this
                                                    // refcount when state == WaitRefShuttingDown
    NDIS_SPIN_LOCK          lock;                   // Protects fields above

} WAIT_REFCOUNT, *PWAIT_REFCOUNT;

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

VOID
BrdgInitializeWaitRef(
    IN PWAIT_REFCOUNT   pRefcount,
    IN BOOLEAN          bResettable
    );

BOOLEAN
BrdgIncrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

VOID
BrdgReincrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

VOID
BrdgDecrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

VOID
BrdgBlockWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

BOOLEAN
BrdgShutdownBlockedWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

BOOLEAN
BrdgShutdownWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );

//
// Use when it should be impossible for two or more threads of
// execution to simultaneously shut down your waitref.
//
__inline
VOID
BrdgShutdownWaitRefOnce(
    IN PWAIT_REFCOUNT   pRefcount
    )
{
    BOOLEAN bSuccess = FALSE;
    
    bSuccess = BrdgShutdownWaitRef( pRefcount );
    SAFEASSERT( bSuccess );
}

VOID
BrdgResetWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\bridge.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bridge.c

Abstract:

    Ethernet MAC level bridge.

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#include <tdikrnl.h>
#pragma warning( pop )

#include "bridge.h"
#include "brdgprot.h"
#include "brdgmini.h"
#include "brdgbuf.h"
#include "brdgtbl.h"
#include "brdgfwd.h"
#include "brdgctl.h"
#include "brdgsta.h"
#include "brdgcomp.h"
#include "brdgtdi.h"

// ===========================================================================
//
// GLOBALS
//
// ===========================================================================

// Our driver object
PDRIVER_OBJECT          gDriverObject;

// Our registry path
UNICODE_STRING          gRegistryPath;

// Size of the allocated memory at gRegistryPath->Buffer
ULONG                   gRegistryPathBufferSize;

// Whether we're in the process of shutting down (non-zero means true)
LONG                    gShuttingDown = 0L;

// Whether we successfully initialized each subsystem
BOOLEAN                 gInitedSTA = FALSE;
BOOLEAN                 gInitedControl = FALSE;
BOOLEAN                 gInitedTbl = FALSE;
BOOLEAN                 gInitedBuf = FALSE;
BOOLEAN                 gInitedFwd = FALSE;
BOOLEAN                 gInitedProt = FALSE;
BOOLEAN                 gInitedMini = FALSE;
BOOLEAN                 gInitedComp = FALSE;
BOOLEAN                 gInitedTdiGpo = FALSE;

extern BOOLEAN          gBridging;
const PWCHAR            gDisableForwarding = L"DisableForwarding";


#if DBG
// Support for optional "soft asserts"
BOOLEAN                 gSoftAssert = FALSE;

// Fields used for printing current date and time in DBGPRINT
LARGE_INTEGER           gTime;
const LARGE_INTEGER     gCorrection = { 0xAC5ED800, 0x3A }; // 7 hours in 100-nanoseconds
TIME_FIELDS             gTimeFields;

// Used for throttling debug messages that risk overloading the debugger console
ULONG                   gLastThrottledPrint = 0L;

// Spew flags
ULONG                   gSpewFlags = 0L;

// Name of registry value that holds the spew flags settings
const PWCHAR            gDebugFlagRegValueName = L"DebugFlags";

// Used to bypass Tdi/Gpo code if it's breaking on startup.
BOOLEAN                 gGpoTesting = TRUE;
#endif

// ===========================================================================
//
// PRIVATE DECLARATIONS
//
// ===========================================================================

// Structure for deferring a function call
typedef struct _DEFER_REC
{
    NDIS_WORK_ITEM      nwi;
    VOID                (*pFunc)(PVOID);            // The function to defer
} DEFER_REC, *PDEFER_REC;


// ===========================================================================
//
// LOCAL PROTOTYPES
//
// ===========================================================================

NTSTATUS
BrdgDispatchRequest(
    IN  PDEVICE_OBJECT          pDeviceObject,
    IN  PIRP                    pIrp
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPath
    );

NTSTATUS
BrdgAllocateBuffers(
    VOID
    );

VOID
BrdgDeferredShutdown(
    PVOID           pUnused
    );

VOID
BrdgDoShutdown(
    VOID
    );

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgDeferredFunction(
    IN PNDIS_WORK_ITEM          pNwi,
    IN PVOID                    arg
    )
/*++

Routine Description:

    NDIS worker function for deferring a function call

Arguments:

    pNwi                    Structure describing the function to call
    arg                     Argument to pass to the deferred function

Return Value:

    None

--*/
{
    PDEFER_REC                  pdr = (PDEFER_REC)pNwi;

    // Call the originally supplied function
    (*pdr->pFunc)(arg);

    // Release the memory used to store the work item
    NdisFreeMemory( pdr, sizeof(DEFER_REC), 0 );
}

NDIS_STATUS
BrdgDeferFunction(
    VOID            (*pFunc)(PVOID),
    PVOID           arg
    )
/*++

Routine Description:

    Defers the indicated function, calling it at low IRQL with the indicated argument.

Arguments:

    pFunc           The function to call later
    arg             The argument to pass it when it is called

Return Value:

    Status of the attempt to defer the function

--*/
{
    PDEFER_REC                  pdr;
    NDIS_STATUS                 Status;

    Status = NdisAllocateMemoryWithTag( &pdr, sizeof(DEFER_REC), 'gdrB' );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Allocation failed in BrdgDeferFunction(): %08x\n", Status));
        return Status;
    }

    SAFEASSERT( pdr != NULL );

    pdr->pFunc = pFunc;

    NdisInitializeWorkItem( &pdr->nwi, BrdgDeferredFunction, arg );

    Status = NdisScheduleWorkItem( &pdr->nwi );

    if( Status != NDIS_STATUS_SUCCESS )
    {
        NdisFreeMemory( pdr, sizeof(DEFER_REC), 0 );
    }

    return Status;
}


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     pRegistryPath
    )
/*++

Routine Description:

    Main driver entry point. Called at driver load time

Arguments:

    DriverObject            Our driver
    RegistryPath            A reg key where we can keep parameters

Return Value:

    Status of our initialization. A status != STATUS_SUCCESS aborts the
    driver load and we don't get called again.

    Each component is responsible for logging any error that causes the
    driver load to fail.

--*/
{
    NTSTATUS                Status;
    NDIS_STATUS             NdisStatus;
    PUCHAR                  pRegistryPathCopy;

    DBGPRINT(GENERAL, ("DriverEntry\n"));

    // Remember our driver object pointer
    gDriverObject = DriverObject;

    do
    {
        ULONG               ulDisableForwarding = 0L;
        
        // Make a copy of our registry path
        pRegistryPathCopy = NULL;
        gRegistryPathBufferSize = pRegistryPath->Length + sizeof(WCHAR);
        NdisStatus = NdisAllocateMemoryWithTag( &pRegistryPathCopy, gRegistryPathBufferSize, 'gdrB' );

        if( (NdisStatus != NDIS_STATUS_SUCCESS) || (pRegistryPathCopy == NULL) )
        {
            DBGPRINT(GENERAL, ("Unable to allocate memory for saving the registry path: %08x\n", NdisStatus));
            NdisWriteEventLogEntry( gDriverObject, EVENT_BRIDGE_INIT_MALLOC_FAILED, 0, 0, NULL, 0L, NULL );
            Status = NdisStatus;

            // Make the structure valid even though we failed the malloc
            RtlInitUnicodeString( &gRegistryPath, NULL );
            gRegistryPathBufferSize = 0L;
            break;
        }

        // Copy the registry name
        NdisMoveMemory( pRegistryPathCopy, pRegistryPath->Buffer, pRegistryPath->Length );

        // Make sure it's NULL-terminated
        *((PWCHAR)(pRegistryPathCopy + pRegistryPath->Length)) = UNICODE_NULL;

        // Make the UNICODE_STRING structure point to the string
        RtlInitUnicodeString( &gRegistryPath, (PWCHAR)pRegistryPathCopy );

        // Set our debug flags
#if DBG
        BrdgReadRegDWord(&gRegistryPath, gDebugFlagRegValueName, &gSpewFlags);
#endif

        // Initialize the STA part of the driver
        Status = BrdgSTADriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize STA functionality: %08x\n", Status));
            break;
        }

        gInitedSTA = TRUE;

        // Initialize the control part of the driver
        Status = BrdgCtlDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize user-mode control functionality: %08x\n", Status));
            break;
        }

        gInitedControl = TRUE;

        // Initialize the MAC table part of our driver
        Status = BrdgTblDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize MAC table functionality: %08x\n", Status));
            break;
        }

        gInitedTbl = TRUE;

        // Initialize the forwarding engine
        Status = BrdgFwdDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize forwarding engine functionality: %08x\n", Status));
            break;
        }

        gInitedFwd = TRUE;

        // Initialize the buffer management part of our driver
        Status = BrdgBufDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize miniport functionality: %08x\n", Status));
            break;
        }

        gInitedBuf = TRUE;

        // Initialize the miniport part of our driver
        Status = BrdgMiniDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize miniport functionality: %08x\n", Status));
            break;
        }

        gInitedMini = TRUE;

        // Initialize the protocol part of our driver
        Status = BrdgProtDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize protocol functionality: %08x\n", Status));
            break;
        }

        gInitedProt = TRUE;

        // Initialize the compatibility-mode code
        Status = BrdgCompDriverInit();

        if( Status != STATUS_SUCCESS )
        {
            DBGPRINT(GENERAL, ("Unable to initialize compatibility-mode functionality: %08x\n", Status));
            break;
        }

        gInitedComp = TRUE;

        Status = BrdgReadRegDWord(&gRegistryPath, gDisableForwarding, &ulDisableForwarding);
        
        if ((!NT_SUCCESS(Status) || !ulDisableForwarding))
        {    
            //
            // Group policies are only in effect on Professional and up.
            //
            if (!BrdgIsRunningOnPersonal())
            {
    #if DBG
                if (gGpoTesting)
                {
    #endif
                    // Initialize the tdi code
                    Status = BrdgTdiDriverInit();
        
                    if( Status != STATUS_SUCCESS )
                    {
                        DBGPRINT(GENERAL, ("Unable to initialize tdi functionality: %08x\n", Status));
                        break;
                    }
                    gInitedTdiGpo = TRUE;
    #if DBG
                }
    #endif        
            }
            else
            {
                gBridging = TRUE;
            }
        }
        

        // Associate the miniport to the protocol
        BrdgMiniAssociate();

    } while (FALSE);

    if (Status != STATUS_SUCCESS)
    {
        BrdgDoShutdown();
    }

    return(Status);
}

NTSTATUS
BrdgDispatchRequest(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Description:

    Receives control requests from the outside

Arguments:

    pDeviceObject           Our driver
    pIrp                    The IRP to handle

Return Value:

    Status of the operation

--*/
{
    PVOID                   Buffer;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   Size = 0;
    NTSTATUS                status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    Buffer = pIrp->AssociatedIrp.SystemBuffer;
    IrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL )
    {
        // Don't accept IRPs when we're shutting down
        if( gShuttingDown )
        {
            status = STATUS_UNSUCCESSFUL;
            pIrp->IoStatus.Information = 0;
        }
        else
        {
            status = BrdgCtlHandleIoDeviceControl( pIrp, IrpSp->FileObject, Buffer,
                                                   IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                                   IrpSp->Parameters.DeviceIoControl.IoControlCode, &Size );
        }
    }
    else
    {
        if( IrpSp->MajorFunction == IRP_MJ_CREATE )
        {
            BrdgCtlHandleCreate();
        }
        else if( IrpSp->MajorFunction == IRP_MJ_CLEANUP )
        {
            BrdgCtlHandleCleanup();
        }

        // Leave status == STATUS_SUCCESS and Size == 0
    }

    if( status != STATUS_PENDING )
    {
        pIrp->IoStatus.Information = Size;
        pIrp->IoStatus.Status = status;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
BrdgDeferredShutdown(
    PVOID           pUnused
    )
/*++

Routine Description:

    Orderly-shutdown routine if we need to defer that task from high IRQL

Arguments:

    pUnused         Ignored

Return Value:

    None

--*/
{
    BrdgDoShutdown();
}

VOID
BrdgDoShutdown(
    VOID
    )
/*++

Routine Description:

    Called to do an orderly shutdown at unload time

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINT(GENERAL, ("==> BrdgDoShutdown()!\n"));

    // Clean up each of the sections
    if ( gInitedTdiGpo )
    {
        gInitedTdiGpo = FALSE;
        BrdgTdiCleanup();
    }
    
    if( gInitedControl )
    {
        gInitedControl = FALSE;
        BrdgCtlCleanup();
    }

    if( gInitedProt )
    {
        gInitedProt = FALSE;
        BrdgProtCleanup();
    }

    // This needs to be cleaned up after the protocol section
    if( gInitedSTA )
    {
        gInitedSTA = FALSE;
        BrdgSTACleanup();
    }

    if( gInitedMini )
    {
        gInitedMini = FALSE;
        BrdgMiniCleanup();
    }

    if( gInitedTbl )
    {
        gInitedTbl = FALSE;
        BrdgTblCleanup();
    }

    if( gInitedBuf )
    {
        gInitedBuf = FALSE;
        BrdgBufCleanup();
    }

    if( gInitedFwd )
    {
        gInitedFwd = FALSE;
        BrdgFwdCleanup();
    }

    if( gInitedComp )
    {
        gInitedComp = FALSE;
        BrdgCompCleanup();
    }

    if( gRegistryPath.Buffer != NULL )
    {
        NdisFreeMemory( gRegistryPath.Buffer, gRegistryPathBufferSize, 0 );
        gRegistryPath.Buffer = NULL;
    }

    DBGPRINT(GENERAL, ("<== BrdgDoShutdown()\n"));
}

VOID
BrdgUnload(
    IN  PDRIVER_OBJECT      DriverObject
    )
/*++

Routine Description:

    Called to indicate that we are being unloaded and to cause an orderly
    shutdown

Arguments:

    DriverObject            Our driver

Return Value:

    None

--*/
{
    if( ! InterlockedExchange(&gShuttingDown, 1L) )
    {
        BrdgDoShutdown();
    }
    // else was already shutting down; do nothing
}

VOID BrdgShutdown(
    VOID
    )
{
    if( ! InterlockedExchange(&gShuttingDown, 1L) )
    {
        BrdgDoShutdown();
    }
    // else was already shutting down; do nothing
}

NTSTATUS
BrdgReadRegUnicode(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PWCHAR              *String,        // The string from the registry, freshly allocated
    OUT PULONG              StringSize      // Size of allocated memory at String
    )
/*++

Routine Description:

    Reads a Unicode string from a specific registry key and value. Allocates memory
    for the string and returns it.

Arguments:

    KeyName                 The key holding the string
    pValueName              The name of the value holding the string

    String                  A pointer to indicate a freshly allocated buffer containing
                            the requested string on return

    StringSize              Size of the returned buffer

Return Value:

    Status of the operation. String is not valid if return != STATUS_SUCCESS

--*/
{
    NDIS_STATUS                     NdisStatus;
    HANDLE                          KeyHandle;
    OBJECT_ATTRIBUTES               ObjAttrs;
    NTSTATUS                        Status;
    ULONG                           RequiredSize;
    KEY_VALUE_PARTIAL_INFORMATION   *pInfo;
    UNICODE_STRING                  ValueName;

    // Turn the string into a UNICODE_STRING
    RtlInitUnicodeString( &ValueName, pValueName );

    // Describe the key to open
    InitializeObjectAttributes( &ObjAttrs, KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    // Open it
    Status = ZwOpenKey( &KeyHandle, KEY_READ, &ObjAttrs );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Failed to open registry key \"%ws\": %08x\n", KeyName->Buffer, Status));
        return Status;
    }

    // Find out how much memory is necessary to hold the value information
    Status = ZwQueryValueKey( KeyHandle, &ValueName, KeyValuePartialInformation, NULL,
                              0L, &RequiredSize );

    if( (Status != STATUS_BUFFER_OVERFLOW) &&
        (Status != STATUS_BUFFER_TOO_SMALL) )
    {
        DBGPRINT(GENERAL, ("Failed to query for the size of value \"%ws\": %08x\n", ValueName.Buffer, Status));
        ZwClose( KeyHandle );
        return Status;
    }

    // Allocate the indicated amount of memory
    NdisStatus = NdisAllocateMemoryWithTag( (PVOID*)&pInfo, RequiredSize, 'gdrB' );

    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("NdisAllocateMemoryWithTag failed: %08x\n", NdisStatus));
        ZwClose( KeyHandle );
        return STATUS_UNSUCCESSFUL;
    }

    // Actually read out the string
    Status = ZwQueryValueKey( KeyHandle, &ValueName, KeyValuePartialInformation, pInfo,
                              RequiredSize, &RequiredSize );

    ZwClose( KeyHandle );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("ZwQueryValueKey failed: %08x\n", Status));
        NdisFreeMemory( pInfo, RequiredSize, 0 );
        return Status;
    }

    // This had better be a Unicode string with something in it
    if( pInfo->Type != REG_SZ && pInfo->Type != REG_MULTI_SZ)
    {
        SAFEASSERT(FALSE);
        NdisFreeMemory( pInfo, RequiredSize, 0 );
        return STATUS_UNSUCCESSFUL;
    }

    // Allocate memory for the string
    *StringSize = pInfo->DataLength + sizeof(WCHAR);
    NdisStatus = NdisAllocateMemoryWithTag( (PVOID*)String, *StringSize, 'gdrB' );

    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("NdisAllocateMemoryWithTag failed: %08x\n", NdisStatus));
        NdisFreeMemory( pInfo, RequiredSize, 0 );
        return STATUS_UNSUCCESSFUL;
    }

    SAFEASSERT( *String != NULL );

    // Copy the string to the freshly allocated memory
    NdisMoveMemory( *String, &pInfo->Data, pInfo->DataLength );

    // Put a two-byte NULL character at the end
    ((PUCHAR)*String)[pInfo->DataLength] = '0';
    ((PUCHAR)*String)[pInfo->DataLength + 1] = '0';

    // Let go of resources we used on the way
    NdisFreeMemory( pInfo, RequiredSize, 0 );

    return STATUS_SUCCESS;
}

NTSTATUS
BrdgReadRegDWord(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PULONG              Value
    )
/*++

Routine Description:

    Reads a DWORD value out of the registry

Arguments:

    KeyName                 The name of the key holding the value
    pValueName              The name of the value holding the value
    Value                   Receives the value

Return Value:

    Status of the operation. Value is junk if return value != STATUS_SUCCESS

--*/
{
    HANDLE                          KeyHandle;
    OBJECT_ATTRIBUTES               ObjAttrs;
    NTSTATUS                        Status;
    UCHAR                           InfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    ULONG                           RequiredSize;
    UNICODE_STRING                  ValueName;

    // Turn the PWCHAR into a UNICODE_STRING
    RtlInitUnicodeString( &ValueName, pValueName );

    // Describe the key to open
    InitializeObjectAttributes( &ObjAttrs, KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    // Open it
    Status = ZwOpenKey( &KeyHandle, KEY_READ, &ObjAttrs );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("Failed to open registry key \"%ws\": %08x\n", KeyName->Buffer, Status));
        return Status;
    }

    // Actually read out the value
    Status = ZwQueryValueKey( KeyHandle, &ValueName, KeyValuePartialInformation,
                              (PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer,
                              sizeof(InfoBuffer), &RequiredSize );

    ZwClose( KeyHandle );

    if( Status != STATUS_SUCCESS )
    {
        DBGPRINT(GENERAL, ("ZwQueryValueKey failed: %08x\n", Status));
        return Status;
    }

    // This had better be a DWORD value
    if( (((PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer)->Type != REG_DWORD) ||
        (((PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer)->DataLength != sizeof(ULONG)) )
    {
        DBGPRINT(GENERAL, ("Registry parameter %ws not of the requested type!\n"));
        return STATUS_UNSUCCESSFUL;
    }

    *Value = *((PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)&InfoBuffer)->Data);
    return STATUS_SUCCESS;
}

NTSTATUS
BrdgOpenDevice (
    IN LPWSTR           pDeviceNameStr,
    OUT PDEVICE_OBJECT  *ppDeviceObject,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject
    )
/*++

Routine Description:

    Opens specified device driver (control channel) and returns a file object
    and a driver object. The caller should call BrdgCloseDevice() to shut
    down the connection when it's done.

Arguments:

    DeviceNameStr       device to open.
    pFileHandle         Receives a file handle
    ppFileObject        Receives a pointer to the file object
    ppDeviceObject      Receives a pointer to the device object

Return Value:

    NTSTATUS -- Indicates whether the device was opened OK

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      DeviceName;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     iosb;

    // We make calls that can only be performed at PASSIVE_LEVEL.
    SAFEASSERT( CURRENT_IRQL <= PASSIVE_LEVEL );

    RtlInitUnicodeString(&DeviceName, pDeviceNameStr);

    InitializeObjectAttributes(
        &objectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    status = IoCreateFile(
                 pFileHandle,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,                           // eaInfo
                 0,                              // eaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING        // Options
                    | IO_FORCE_ACCESS_CHECK
                 );

    if (NT_SUCCESS(status))
    {
        status = ObReferenceObjectByHandle (
                     *pFileHandle,
                     0L,
                     *IoFileObjectType,
                     KernelMode,
                     (PVOID *)ppFileObject,
                     NULL
                     );

        if (! NT_SUCCESS(status))
        {
            DBGPRINT(ALWAYS_PRINT, ("ObReferenceObjectByHandle FAILED while opening a device: %8x\n", status));
            ZwClose (*pFileHandle);
        }
        else
        {
            // Recover the driver object
            *ppDeviceObject = IoGetRelatedDeviceObject ( *ppFileObject );
            SAFEASSERT( *ppDeviceObject != NULL );

            // Reference the driver handle, too.
            ObReferenceObject( *ppDeviceObject );
        }
    }
    else
    {
        DBGPRINT(ALWAYS_PRINT, ("IoCreateFile FAILED while opening a device: %8x\n", status));
    }

    return status;
}

VOID
BrdgCloseDevice(
    IN HANDLE               FileHandle,
    IN PFILE_OBJECT         pFileObject,
    IN PDEVICE_OBJECT       pDeviceObject
    )
/*++

Routine Description:

    Closes a device

Arguments:

    FileHandle              The file handle
    pFileObject             The file object of the device
    pDeviceObject           The device object of the device

Return Value:

    None

--*/
{
    NTSTATUS                status;

    // We make calls that can only be performed at PASSIVE_LEVEL.
    SAFEASSERT( CURRENT_IRQL <= PASSIVE_LEVEL );

    ObDereferenceObject( pFileObject );
    ObDereferenceObject( pDeviceObject );
    status = ZwClose( FileHandle );

    SAFEASSERT( NT_SUCCESS(status) );
}

VOID
BrdgTimerExpiry(
    IN PVOID        ignored1,
    IN PVOID        data,
    IN PVOID        ignored2,
    IN PVOID        ignored3
    )
/*++

Routine Description:

    Master device expiry function. Calls a timer-specific expiry
    function if one was specified for this timer.

Arguments:

    data            The timer pointer

Return Value:

    None

--*/
{
    PBRIDGE_TIMER   pTimer = (PBRIDGE_TIMER)data;

    NdisAcquireSpinLock( &pTimer->Lock );
    SAFEASSERT( pTimer->bRunning );

     if( pTimer->bCancelPending )
    {
        // This is the rare codepath where a call to NdisCancelTimer() was unable to
        // dequeue our timer entry because we were about to be called.
        DBGPRINT(GENERAL, ("Timer expiry function called with cancelled timer!\n"));

        // Don't call the timer function; just bail out
        pTimer->bRunning = FALSE;
       pTimer->bCancelPending = FALSE;

        NdisReleaseSpinLock( &pTimer->Lock );

        // Unblock BrdgShutdownTimer()
        NdisSetEvent( &pTimer->Event );
    }
    else
    {
        BOOLEAN         bRecurring;
        UINT            interval;

        // Read protected values inside the lock
        bRecurring = pTimer->bRecurring;
        interval = pTimer->Interval;

        // Update bRunning inside the spin lock
        pTimer->bRunning = bRecurring;
        NdisReleaseSpinLock( &pTimer->Lock );

        // Call the timer function
        (*pTimer->pFunc)(pTimer->data);

        if( bRecurring )
        {
            // Start it up again
            NdisSetTimer( &pTimer->Timer, interval );
        }
    }
}

VOID
BrdgInitializeTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN PBRIDGE_TIMER_FUNC   pFunc,
    IN PVOID                data
    )
/*++

Routine Description:

    Sets up a BRIDGE_TIMER.

Arguments:

    pTimer                  The timer
    pFunc                   Expiry function
    data                    Cookie to pass to pFunc

Return Value:

    None

--*/
{
    pTimer->bShuttingDown = FALSE;
    pTimer->bRunning = FALSE;
    pTimer->bCancelPending = FALSE;
    pTimer->pFunc = pFunc;
    pTimer->data = data;

    NdisInitializeTimer( &pTimer->Timer, BrdgTimerExpiry, (PVOID)pTimer );
    NdisInitializeEvent( &pTimer->Event );
    NdisResetEvent( &pTimer->Event );
    NdisAllocateSpinLock( &pTimer->Lock );

    // Leave pTimer->bRecurring alone; it gets a value when the timer is started.
}

VOID
BrdgSetTimer(
    IN PBRIDGE_TIMER        pTimer,
    IN UINT                 interval,
    IN BOOLEAN              bRecurring
    )
/*++

Routine Description:

    Starts a BRIDGE_TIMER ticking.

Arguments:

    pTimer                  The timer
    interval                Time before expiry in ms
    bRecurring              TRUE to restart the timer when it expires

Return Value:

    None

--*/
{
    NdisAcquireSpinLock( &pTimer->Lock );

    if( !pTimer->bShuttingDown && !pTimer->bCancelPending )
    {
        pTimer->bRunning = TRUE;
        pTimer->bCancelPending = FALSE;
        pTimer->Interval = interval;
        pTimer->bRecurring = bRecurring;
        NdisReleaseSpinLock( &pTimer->Lock );

        // Actually start the timer
        NdisSetTimer( &pTimer->Timer, interval );
    }
    else
    {
        NdisReleaseSpinLock( &pTimer->Lock );
        if (pTimer->bShuttingDown)
        {
            DBGPRINT(ALWAYS_PRINT, ("WARNING: Ignoring an attempt to restart a timer in final shutdown!\n"));
        }
    }
}

VOID
BrdgShutdownTimer(
    IN PBRIDGE_TIMER        pTimer
    )
/*++

Routine Description:

    Safely shuts down a timer, waiting to make sure that the timer has been
    completely dequeued or its expiry function has started executing (there
    is no way to guarantee that the expiry function is completely done
    executing, however).

    Must be called at PASSIVE_LEVEL.

Arguments:

    pTimer                  The timer

Return Value:

    None

--*/
{
    // We wait on an event
    SAFEASSERT( CURRENT_IRQL <= PASSIVE_LEVEL );

    NdisAcquireSpinLock( &pTimer->Lock );

    // Forbid future calls to BrdgSetTimer().
    pTimer->bShuttingDown = TRUE;

    if( pTimer->bRunning && !pTimer->bCancelPending)
    {
        BOOLEAN             bCanceled;

        // Make sure the timer expiry function will bail out if it's too late to
        // dequeue the timer and it ends up getting called
        pTimer->bCancelPending = TRUE;

        // This will unblock the timer expiry function, but even if it executes
        // between now and the call to NdisCancelTimer, it should still end up
        // signalling the event we will wait on below.
        NdisReleaseSpinLock( &pTimer->Lock );

        // Try to cancel the timer.
        NdisCancelTimer( &pTimer->Timer, &bCanceled );

        if( !bCanceled )
        {
            //
            // bCancelled can be FALSE if the timer wasn't running in the first place,
            // or if the OS couldn't dequeue the timer (but our expiry function will
            // still be called). Our use of our timer structure's spin lock should
            // guarantee that the timer expiry function will be executed after we
            // released the spin lock above, if we are on this code path. This means
            // that the event we wait on below will be signalled by the timer expiry
            // function.
            //
            DBGPRINT(GENERAL, ("Couldn't dequeue timer; blocking on completion\n"));

            // Wait for the completion function to finish its work
            NdisWaitEvent( &pTimer->Event, 0 /*Wait forever*/ );

            // The completion function should have cleared this
            SAFEASSERT( !pTimer->bRunning );
        }
        else
        {
            pTimer->bRunning = FALSE;
            pTimer->bCancelPending = FALSE;
        }
    }
    else
    {
        // Tried to shutdown a timer that was not running, or is going to be cancelled soon. This is allowed (it does nothing).
        NdisReleaseSpinLock( &pTimer->Lock );
    }
}

VOID
BrdgCancelTimer(
    IN PBRIDGE_TIMER        pTimer
    )
/*++

Routine Description:

    Attempts to cancel a timer, but provides no guarantee that the timer is
    actually stopped on return. It is possible for the timer expiry function
    to fire after this function returns.

Arguments:

    pTimer                  The timer

Return Value:

    None.

--*/
{
    NdisAcquireSpinLock( &pTimer->Lock );
    
    if( pTimer->bRunning && !pTimer->bCancelPending)
    {
        BOOLEAN             bCanceled;
        
        NdisCancelTimer( &pTimer->Timer, &bCanceled );
        
        if( bCanceled )
        {
            pTimer->bRunning = FALSE;
        }
        else
        {
            // Reset this so that BrdgShutdownTimer will block.
            NdisResetEvent(&pTimer->Event);
            pTimer->bCancelPending = TRUE;
        }
        // else timer expiry function will set bRunning to FALSE when it completes.
    }
    // else tried to cancel a timer that was not running. This is allowed (it does nothing).
    
    NdisReleaseSpinLock( &pTimer->Lock );
}

BOOLEAN
BrdgIsRunningOnPersonal(
    VOID
    )
/*++

Routine Description:

    Determines if we're running on a Personal build.
    

Arguments:

    None.

Return Value:

    TRUE if we're on Personal, FALSE if we're not.

--*/
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;
    BOOLEAN IsPersonal = TRUE;
    
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;
    
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);
    
    if (RtlVerifyVersionInfo(&OsVer, VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask) == STATUS_REVISION_MISMATCH) {
        IsPersonal = FALSE;
    }
    
    return IsPersonal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\makefile.inc ===
TARGETPATH=obj$(BUILD_ALT_DIR)

C_DEFINES=$(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE -D_NTSDK=1 -DMPR50=1

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=pch.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj

RCOPTIONS=-N
UMTYPE=windows
ATL_VER=30
USE_STATIC_ATL=1
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\brdgwref.c ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    brdgwait.c

Abstract:

    Ethernet MAC level bridge.
    WAIT_REFCOUNT implementation

Author:

    Mark Aiken

Environment:

    Kernel mode driver

Revision History:

    Feb  2000 - Original version

--*/

#define NDIS_MINIPORT_DRIVER
#define NDIS50_MINIPORT   1
#define NDIS_WDM 1

#pragma warning( push, 3 )
#include <ndis.h>
#include <ntddk.h>
#pragma warning( pop )

#include "bridge.h"

// ===========================================================================
//
// PUBLIC FUNCTIONS
//
// ===========================================================================

VOID
BrdgInitializeWaitRef(
    IN PWAIT_REFCOUNT   pRefcount,
    IN BOOLEAN          bResettable
    )
/*++

Routine Description:

    Initializes a wait-refcount

Arguments:

    pRefcount           The wait-refcount to initialize

Return Value:

    none

--*/
{
    NdisInitializeEvent(&pRefcount->Event);
    pRefcount->Refcount = 0L;
    pRefcount->state = WaitRefEnabled;
    pRefcount->bResettable = bResettable;
    NdisAllocateSpinLock( &pRefcount->lock );

    // The event starts life signaled since the refcount starts at zero
    NdisSetEvent(&pRefcount->Event);
}

BOOLEAN
BrdgIncrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Increments (acquires) a wait-refcount

Arguments:

    pRefcount           The wait-refcount to acquire

Return Value:

    TRUE if the wait-refcount was successfully acquired, FALSE otherwise (this can happen
    if the wait-refcount has been shut down)

--*/
{
    BOOLEAN     bSuccess;
    LONG        Scratch = 0L;

    SAFEASSERT( pRefcount != NULL );
    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefEnabled )
    {
        SAFEASSERT( pRefcount->Refcount >= 0L );
        Scratch = ++pRefcount->Refcount;
        bSuccess = TRUE;
    }
    else
    {
        // The wait-refcount isn't enabled.
        SAFEASSERT( (pRefcount->state == WaitRefShutdown) ||
                    (pRefcount->state == WaitRefShuttingDown) );
        bSuccess = FALSE;
    }

    if( bSuccess && (Scratch == 1L) )
    {
        // We incremented from zero. Reset the event.
        NdisResetEvent( &pRefcount->Event );
    }

    NdisReleaseSpinLock( &pRefcount->lock );

    return bSuccess;
}

VOID
BrdgReincrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Re-increments a wait-refcount. This is guaranteed to succeed.

    It is only legal to use this if the caller has already acquired the
    wait-refcount (i.e., it is guaranteed that the refcount is > 0).

    CALLING THIS WITHOUT HAVING FIRST ACQUIRED THE WAIT-REFCOUNT WITH
    BrdgIncrementWaitRef IS A GREAT WAY TO SCREW UP YOUR CODE!

Arguments:

    pRefcount           The wait-refcount to re-acquire

Return Value:

    none

--*/
{
    LONG        Scratch;

    SAFEASSERT( pRefcount != NULL );
    NdisAcquireSpinLock( &pRefcount->lock );
    SAFEASSERT( (pRefcount->state == WaitRefEnabled) ||
                (pRefcount->state == WaitRefShuttingDown) );
    SAFEASSERT( pRefcount->Refcount >= 0L );
    Scratch = ++pRefcount->Refcount;
    NdisReleaseSpinLock( &pRefcount->lock );

    // Should be impossible for us to have incremented from zero to one
    SAFEASSERT( Scratch >= 2L );
}

VOID
BrdgDecrementWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Decrements (releases) a previously incremented (acquired) wait-refcount.

Arguments:

    pRefcount           The wait-refcount to decrement

Return Value:

    none

--*/
{
    LONG        Scratch;

    SAFEASSERT( pRefcount != NULL );
    NdisAcquireSpinLock( &pRefcount->lock );
    SAFEASSERT( (pRefcount->state == WaitRefEnabled) ||
                (pRefcount->state == WaitRefShuttingDown) );
    Scratch = --pRefcount->Refcount;
    SAFEASSERT( Scratch >= 0L );

    if( Scratch == 0L )
    {
        // Signal anyone waiting for the refount to go to zero
        NdisSetEvent( &pRefcount->Event );
    }

    NdisReleaseSpinLock( &pRefcount->lock );
}

VOID
BrdgBlockWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Puts the wait-refcount in the shutting-down state, making it impossible
    for the refcount to be incremented anymore.

    This can be used to block further acquires of the wait-refcount in
    advance of the shutdown process. Because shutting down the wait-refcount
    involves waiting for it to hit zero, this can be called at high IRQL to
    prevent further acquires of the wait-refcount in advance of a low-IRQL
    call to BrdgShutdownWaitRef().

Arguments:

    pRefcount           The wait-refcount to block

Return Value:

    none

--*/
{
    SAFEASSERT( pRefcount != NULL );

    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefEnabled )
    {
        pRefcount->state = WaitRefShuttingDown;
    }
    else
    {
        // Do nothing; the wait-refcount is already
        // shutting down or is already shut down.
        SAFEASSERT( (pRefcount->state == WaitRefShutdown) ||
                    (pRefcount->state == WaitRefShuttingDown) );
    }

    NdisReleaseSpinLock( &pRefcount->lock );
}

BOOLEAN
BrdgShutdownWaitRefInternal(
    IN PWAIT_REFCOUNT   pRefcount,
    IN BOOLEAN          bRequireBlockedState
    )
/*++

Routine Description:

    Blocks new acquisitions of the wait-refcount and waits for the
    number of consumers to go to zero. If TRUE is returned, the caller
    can free any resources protected by the wait-refcount

Arguments:

    pRefcount               The wait-refcount to shut down

    bRequireBlockedState    TRUE means the shutdown attempt will fail if
                                the wait-refcount isn't in the shutting-down
                                state

Return Value:

    TRUE if the wait-refcount was shut down

    FALSE indicates that either the wait-refcount was reset or that
    another thread of execution had already shut down the wait-refcount.
    In both cases, the shared resources protected by the wait-refcount
    should NOT be freed.

--*/
{
    BOOLEAN         bSuccess;

    SAFEASSERT(CURRENT_IRQL == PASSIVE_LEVEL);
    SAFEASSERT( pRefcount != NULL );

    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefEnabled )
    {
        if( bRequireBlockedState )
        {
            // Caller was expecting the refcount to be shutting
            // down. It must have been reset. That had better
            // be OK!
            SAFEASSERT( pRefcount->bResettable );
            bSuccess = FALSE;
        }
        else
        {
            // Caller doesn't require that the refcount be
            // shutting down. Transition to the shutting-down
            // state.
            pRefcount->state = WaitRefShuttingDown;
            bSuccess = TRUE;
        }
    }
    else if( pRefcount->state == WaitRefShutdown )
    {
        // Someone else already shut down the waitref.
        // This always means failure.
        SAFEASSERT( pRefcount->Refcount == 0L );
        bSuccess = FALSE;
    }
    else
    {
        // The refcount is already shutting down.
        // This is always goodness.
        SAFEASSERT( pRefcount->state == WaitRefShuttingDown );
        bSuccess = TRUE;
    }

    NdisReleaseSpinLock( &pRefcount->lock );

    if( bSuccess )
    {
        // Wait for all consumers to be done
        NdisWaitEvent( &pRefcount->Event, 0/*Wait forever*/ );

        NdisAcquireSpinLock( &pRefcount->lock );

        if( pRefcount->state == WaitRefEnabled )
        {
            // Someone reactivated us while we were sleeping.
            SAFEASSERT( pRefcount->bResettable );
            bSuccess = FALSE;
        }
        else if( pRefcount->state == WaitRefShutdown )
        {
            // Someone else shut us down while we were sleeping.
            SAFEASSERT( pRefcount->Refcount == 0L );
            bSuccess = FALSE;
        }
        else
        {
            if( pRefcount->Refcount == 0L )
            {
                // We completed the shutdown.
                pRefcount->state = WaitRefShutdown;
                bSuccess = TRUE;
            }
            else
            {
                // The waitref must have been reactivated and
                // shut down again while we were asleep!
                SAFEASSERT( pRefcount->bResettable );
                bSuccess = FALSE;
            }
        }

        NdisReleaseSpinLock( &pRefcount->lock );
    }

    return bSuccess;
}

BOOLEAN
BrdgShutdownWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
{
    return BrdgShutdownWaitRefInternal( pRefcount, FALSE );
}

BOOLEAN
BrdgShutdownBlockedWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
{
    return BrdgShutdownWaitRefInternal( pRefcount, TRUE );
}

VOID
BrdgResetWaitRef(
    IN PWAIT_REFCOUNT   pRefcount
    )
/*++

Routine Description:

    Re-enables a wait-refcount. Safe to call in any refcount
    state; if the refcount is shut down, this will re-enable it.
    If the refcount is in the middle of shutting down, this
    will flag it to be re-enabled if the code shutting down the
    waitref is using BrdgShutdownOrResetWaitRef().

Arguments:

    pRefcount           The wait-refcount

Return Value:

    none

--*/
{
    SAFEASSERT( pRefcount != NULL );

    NdisAcquireSpinLock( &pRefcount->lock );

    if( pRefcount->state == WaitRefShutdown )
    {
        // The wait-refcount is completely shut down. We
        // can reactivate it.
        SAFEASSERT( pRefcount->Refcount == 0L );
        pRefcount->state = WaitRefEnabled;
    }
    else if( pRefcount->state == WaitRefShuttingDown )
    {
        if( pRefcount->bResettable )
        {
            // Re-enable. The call to BrdgShutdownWaitRef()
            // or BrdgShutdownBlockedWaitRef() will return
            // FALSE.
            pRefcount->state = WaitRefEnabled;
        }
        else
        {
            // Not allowed to reset this refcount when
            // in the middle of shutting down
            SAFEASSERT( FALSE );
        }
    }
    else
    {
        // The wait-refcount is already enabled
        SAFEASSERT( pRefcount->state == WaitRefEnabled );
    }

    NdisReleaseSpinLock( &pRefcount->lock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnappprt.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N A P P P R T . C P P
//
//  Contents:   CHNetAppProtocol Implementation
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// ATL methods
//

HRESULT
CHNetAppProtocol::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_bstrProtocol) SysFreeString(m_bstrProtocol);

    return S_OK;
}

//
// Object initialization
//

HRESULT
CHNetAppProtocol::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    
    _ASSERT(NULL == m_piwsHomenet);
    _ASSERT(NULL == m_bstrProtocol);
    _ASSERT(NULL != piwsNamespace);
    _ASSERT(NULL != pwcoInstance);

    //
    // Read and cache our builtin value
    //

    hr = GetBooleanValue(
            pwcoInstance,
            c_wszBuiltIn,
            &m_fBuiltIn
            );

    //
    // Store the path to the object
    //

    if (S_OK == hr)
    {
        hr = GetWmiPathFromObject(pwcoInstance, &m_bstrProtocol);
    }

    if (S_OK == hr)
    {
        m_piwsHomenet = piwsNamespace;
        m_piwsHomenet->AddRef();
    }

    return hr;
}

//
// IHNetApplicationProtocol methods
//

STDMETHODIMP
CHNetAppProtocol::GetName(
    OLECHAR **ppszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == ppszwName)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppszwName = NULL;

        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Read the name property from our instance
        //

        hr = pwcoProtocol->Get(
                c_wszName,
                NULL,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Allocate memory for the return string
        //

        *ppszwName = reinterpret_cast<OLECHAR*>(
                        CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                       * sizeof(OLECHAR))
                        );

        if (NULL != *ppszwName)
        {
            wcscpy(*ppszwName, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetName(
    OLECHAR *pszwName
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        return E_ACCESSDENIED;
    }
    else if (NULL == pszwName)
    {
        return E_INVALIDARG;
    }

    // bug 555896:  should limit the length of untrusted input string
    // to some reasonable size.  Am using INTERNET_MAX_HOST_NAME_LENGTH
    // (somewhat arbitrarily), which is 256.

    WCHAR szwName[INTERNET_MAX_HOST_NAME_LENGTH];
    StringCchCopyW (szwName, INTERNET_MAX_HOST_NAME_LENGTH, pszwName);

    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Wrap the passed-in string in a BSTR and a variant
        //

        VariantInit(&vt);
        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = SysAllocString(szwName);
        if (NULL == V_BSTR(&vt))
        {
            hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr)
        {
            //
            // Set the property on the instance
            //

            hr = pwcoProtocol->Put(
                    c_wszName,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetOutgoingIPProtocol(
    UCHAR *pucProtocol
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pucProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszOutgoingIPProtocol,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_UI1 == V_VT(&vt));

        *pucProtocol = V_UI1(&vt);
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetOutgoingIPProtocol(
    UCHAR ucProtocol
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == ucProtocol)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BSTR bstrWQL;
        USHORT usPort;
        
        //
        // Make sure this change doesn't result in a duplicate
        //

        bstrWQL = SysAllocString(c_wszWQL);

        if (NULL != bstrWQL)
        {
            hr = GetOutgoingPort(&usPort);

            if (S_OK == hr)
            {
                if (ApplicationProtocolExists(
                        m_piwsHomenet,
                        bstrWQL,
                        usPort,
                        ucProtocol
                        ))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
                }
            }
            
            SysFreeString(bstrWQL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        VariantInit(&vt);
        V_VT(&vt) = VT_UI1;
        V_UI1(&vt) = ucProtocol;

        hr = pwcoProtocol->Put(
                c_wszOutgoingIPProtocol,
                0,
                &vt,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );         
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetOutgoingPort(
    USHORT *pusPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (NULL == pusPort)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {   
        hr = pwcoProtocol->Get(
                c_wszOutgoingPort,
                0,
                &vt,
                NULL,
                NULL
                );

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // WMI uses V_I4 for it's uint16 type
        //
        
        _ASSERT(VT_I4 == V_VT(&vt));

        *pusPort = static_cast<USHORT>(V_I4(&vt));
        VariantClear(&vt);
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetOutgoingPort(
    USHORT usPort
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == usPort)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BSTR bstrWQL;
        UCHAR ucProtocol;
        
        //
        // Make sure this change doesn't result in a duplicate
        //

        bstrWQL = SysAllocString(c_wszWQL);

        if (NULL != bstrWQL)
        {
            hr = GetOutgoingIPProtocol(&ucProtocol);

            if (S_OK == hr)
            {
                if (ApplicationProtocolExists(
                        m_piwsHomenet,
                        bstrWQL,
                        usPort,
                        ucProtocol
                        ))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
                }
            }
            
            SysFreeString(bstrWQL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }
    
    if (S_OK == hr)
    {
        //
        // WMI uses V_I4 for it's uint16 type
        //
        
        VariantInit(&vt);
        V_VT(&vt) = VT_I4;
        V_I4(&vt) = usPort;

        hr = pwcoProtocol->Put(
                c_wszOutgoingPort,
                0,
                &vt,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetResponseRanges(
    USHORT *puscResponses,
    HNET_RESPONSE_RANGE *prgResponseRange[]
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    USHORT usResponses;
    VARIANT vt;
    IUnknown **rgUnknown;
    IWbemClassObject *pObj;

    if (NULL != prgResponseRange)
    {
        *prgResponseRange = NULL;

        if (NULL != puscResponses)
        {
            *puscResponses = 0;
        }
        else
        {
            hr = E_POINTER;
        }
    }
    else
    {
        hr = E_POINTER;
    }
    
    if (S_OK == hr)
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        //
        // Get the number of response ranges
        //

        hr = pwcoProtocol->Get(
                c_wszResponseCount,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // WMI uses V_I4 for it's uint16 type
            //
            _ASSERT(VT_I4 == V_VT(&vt));

            usResponses = static_cast<USHORT>(V_I4(&vt));
            VariantClear(&vt);
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Allocate enough memory for the output array.
            //

            *prgResponseRange
                = reinterpret_cast<HNET_RESPONSE_RANGE*>(
                    CoTaskMemAlloc(usResponses * sizeof(HNET_RESPONSE_RANGE))
                    );

            if (NULL == *prgResponseRange)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Retrieve the response array
            //

            hr = pwcoProtocol->Get(
                    c_wszResponseArray,
                    0,
                    &vt,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Process the array: for each element, QI for IWbemClassObject
        // and copy the range data into the return struct
        //

        _ASSERT((VT_ARRAY | VT_UNKNOWN) == V_VT(&vt));

        hr = SafeArrayAccessData(
                V_ARRAY(&vt),
                reinterpret_cast<void**>(&rgUnknown)
                );

        if (S_OK == hr)
        {
            for (USHORT i = 0; i < usResponses; i++)
            {
                hr = rgUnknown[i]->QueryInterface(
                        IID_PPV_ARG(IWbemClassObject, &pObj)
                        );

                _ASSERT(S_OK == hr);

                hr = CopyResponseInstanceToStruct(
                        pObj,
                        &(*prgResponseRange)[i]
                        );

                pObj->Release();

                if (FAILED(hr))
                {
                    break;
                }
            }

            SafeArrayUnaccessData(V_ARRAY(&vt));
        }

        VariantClear(&vt);
    }

    if (S_OK == hr)
    {
        *puscResponses = usResponses;
    }
    else if (prgResponseRange && *prgResponseRange)
    {
        CoTaskMemFree(*prgResponseRange);
        *prgResponseRange = NULL;
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetResponseRanges(
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponseRange[]
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;
    VARIANT vt;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't change values for builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else if (0 == uscResponses || NULL == rgResponseRange)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        VariantInit(&vt);
        V_VT(&vt) = VT_ARRAY | VT_UNKNOWN;
        
        hr = ConvertResponseRangeArrayToInstanceSafearray(
                m_piwsHomenet,
                uscResponses,
                rgResponseRange,
                &V_ARRAY(&vt)
                );
                
        if (SUCCEEDED(hr))
        {
            //
            // Put the array and count properties
            //

            hr = pwcoProtocol->Put(
                    c_wszResponseArray,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // WMI uses V_I4 for it's uint16 type
                //
                
                V_VT(&vt) = VT_I4;
                V_I4(&vt) = uscResponses;

                hr = pwcoProtocol->Put(
                        c_wszResponseCount,
                        0,
                        &vt,
                        NULL
                        );
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the instance back to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetBuiltIn(
    BOOLEAN *pfBuiltIn
    )

{
    HRESULT hr = S_OK;

    if (NULL != pfBuiltIn)
    {
        *pfBuiltIn = m_fBuiltIn;
    }
    else
    {
        hr = E_POINTER;
    }
    
    return hr;
}

STDMETHODIMP
CHNetAppProtocol::GetEnabled(
    BOOLEAN *pfEnabled
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;

    if (NULL == pfEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetProtocolObject(&pwcoProtocol);
    }

    if (S_OK == hr)
    {
        hr = GetBooleanValue(
                pwcoProtocol,
                c_wszEnabled,
                pfEnabled
                );

        pwcoProtocol->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetAppProtocol::SetEnabled(
    BOOLEAN fEnable
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoProtocol;

    hr = GetProtocolObject(&pwcoProtocol);

    if (WBEM_S_NO_ERROR == hr)
    {
        hr = SetBooleanValue(
                pwcoProtocol,
                c_wszEnabled,
                fEnable
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoProtocol,
                    WBEM_FLAG_UPDATE_ONLY,
                    NULL,
                    NULL
                    );
        }

        pwcoProtocol->Release();
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Notify service of update.
        //

        UpdateService(IPNATHLP_CONTROL_UPDATE_SETTINGS);
    }
    
    return hr;

}

STDMETHODIMP
CHNetAppProtocol::Delete()

{
    HRESULT hr = S_OK;

    if (TRUE == m_fBuiltIn)
    {
        //
        // Can't delete builtin protocols
        //

        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = m_piwsHomenet->DeleteInstance(
                m_bstrProtocol,
                0,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Notify service of update.
            //

            UpdateService(IPNATHLP_CONTROL_UPDATE_SETTINGS);
        }
    }

    return hr;
}

HRESULT
CHNetAppProtocol::GetProtocolObject(
    IWbemClassObject **ppwcoInstance
    )

{
    _ASSERT(NULL != ppwcoInstance);

    return GetWmiObjectFromPath(
                m_piwsHomenet,
                m_bstrProtocol,
                ppwcoInstance
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnbrgcon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R G C O N . C P P
//
//  Contents:   CHNBridgedConn implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Ojbect initialization
//

HRESULT
CHNBridgedConn::Initialize(
    IWbemServices *piwsNamespace,
    IWbemClassObject *pwcoConnection
    )

{
    return InitializeFromConnection(piwsNamespace, pwcoConnection);
}

//
// IHNetBridgedConnection methods
//

STDMETHODIMP
CHNBridgedConn::GetBridge(
    IHNetBridge **ppBridge
    )

{
    HRESULT                 hr;

    if (NULL != ppBridge)
    {
        *ppBridge = NULL;
        hr = GetBridgeConnection( m_piwsHomenet, ppBridge );
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CHNBridgedConn::RemoveFromBridge(
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        //
        // Unbind ourselves from the bridge
        //

        hr = UnbindFromBridge( pnetcfgExisting );
    }

    if (S_OK == hr)
    {
        //
        // Inform netman that something changed. Error doesn't matter.
        //
        UpdateNetman();
    }

    return hr;
}

HRESULT
CHNBridgedConn::CopyBridgeBindings(
    IN INetCfgComponent     *pnetcfgAdapter,
    IN INetCfgComponent     *pnetcfgBridge
    )
{
    HRESULT                     hr = S_OK;
    INetCfgComponentBindings    *pnetcfgAdapterBindings;

    //
    // Get the adapter's ComponentBindings interface
    //
    hr = pnetcfgAdapter->QueryInterface(
            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgAdapterBindings)
            );

    if (S_OK == hr)
    {
        IEnumNetCfgBindingPath  *penumPaths;

        //
        // Get the list of binding paths for the adapter
        //
        hr = pnetcfgAdapterBindings->EnumBindingPaths(
                EBP_ABOVE,
                &penumPaths
                );

        if (S_OK == hr)
        {
            ULONG               ulCount1, ulCount2;
            INetCfgBindingPath  *pnetcfgPath;

            while( (S_OK == penumPaths->Next(1, &pnetcfgPath, &ulCount1) ) )
            {
                INetCfgComponent        *pnetcfgOwner;

                //
                // Get the owner of this path
                //
                hr = pnetcfgPath->GetOwner( &pnetcfgOwner );

                if (S_OK == hr)
                {
                    INetCfgComponentBindings    *pnetcfgOwnerBindings;

                    //
                    // Need the ComponentBindings interface for the owner
                    //
                    hr = pnetcfgOwner->QueryInterface(
                            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgOwnerBindings)
                            );

                    if (S_OK == hr)
                    {
                        LPWSTR              lpwstrId;

                        //
                        // The rule is, the binding should be disabled if it
                        // represents the bridge protocol or something that
                        // is not bound to the bridge that the adapter is
                        // coming out of.
                        //
                        // If the binding is one that the bridge has, it is
                        // enabled.
                        //
                        // This makes the adapter's bindings mirror those of
                        // the bridge it just left.
                        //
                        hr = pnetcfgOwner->GetId( &lpwstrId );

                        if (S_OK == hr)
                        {
                            UINT            cmp = _wcsicmp(lpwstrId, c_wszSBridgeSID);

                            hr = pnetcfgOwnerBindings->IsBoundTo( pnetcfgBridge );

                            if ( (S_OK == hr) && (cmp != 0) )
                            {
                                // Activate this binding path
                                hr = pnetcfgOwnerBindings->BindTo(pnetcfgAdapter);
                            }
                            else
                            {
                                // Deactivate this path
                                hr = pnetcfgOwnerBindings->UnbindFrom(pnetcfgAdapter);
                            }

                            CoTaskMemFree(lpwstrId);
                        }

                        pnetcfgOwnerBindings->Release();
                    }

                    pnetcfgOwner->Release();
                }

                pnetcfgPath->Release();
            }

            penumPaths->Release();
        }

        pnetcfgAdapterBindings->Release();
    }

    return hr;
}

HRESULT
CHNBridgedConn::UnbindFromBridge(
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )
{
    HRESULT             hr = S_OK;
    GUID                *pguidAdapter;
    INetCfg             *pnetcfg = NULL;
    INetCfgLock         *pncfglock = NULL;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we can't acquire NetCfg.
        if( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    //
    // Get our own device GUID
    //
    hr = GetGuid (&pguidAdapter);

    if ( SUCCEEDED(hr) )
    {
        IHNetBridge     *pbridge;

        //
        // Get our bridge
        //
        hr = GetBridge (&pbridge);

        if ( SUCCEEDED(hr) )
        {
            IHNetConnection *phnetconBridge;

            //
            // Get the bridge's IHNetConnection interface
            //
            hr = pbridge->QueryInterface(
                    IID_PPV_ARG(IHNetConnection, &phnetconBridge)
                    );

            if ( SUCCEEDED(hr) )
            {
                GUID        *pguidBridge;

                // Get the bridge's device GUID
                hr = phnetconBridge->GetGuid (&pguidBridge);

                if ( SUCCEEDED(hr) )
                {
                    INetCfgComponent    *pnetcfgcompAdapter;

                    hr = FindAdapterByGUID(
                            pnetcfg,
                            pguidAdapter,
                            &pnetcfgcompAdapter
                            );

                    if ( SUCCEEDED(hr) )
                    {
                        INetCfgComponent    *pnetcfgcompBridge;

                        hr = FindAdapterByGUID(
                            pnetcfg,
                            pguidBridge,
                            &pnetcfgcompBridge
                            );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = CopyBridgeBindings(
                                    pnetcfgcompAdapter,
                                    pnetcfgcompBridge
                                    );

                            pnetcfgcompBridge->Release();
                        }

                        pnetcfgcompAdapter->Release();
                    }

                    CoTaskMemFree(pguidBridge);
                }

                phnetconBridge->Release();
            }

            pbridge->Release();
        }

        CoTaskMemFree(pguidAdapter);
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();

            // Refresh the UI for this connection
            RefreshNetConnectionsUI();
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hnbridge.cpp ===
//depot/private/homenet/net/homenet/Config/CfgMgr/HNBridge.cpp#13 - edit change 5915 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N B R I D G E . C P P
//
//  Contents:   CHNBridge implementation
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// IHNetBridge Methods
//

STDMETHODIMP
CHNBridge::EnumMembers(
    IEnumHNetBridgedConnections **ppEnum
    )

{
    HRESULT                                     hr;
    CComObject<CEnumHNetBridgedConnections>     *pEnum;
    INetCfgComponent                            *pBridgeProtocol = NULL;
    INetCfg                                     *pnetcfg;
    IHNetBridgedConnection                      **rgBridgedAdapters = NULL;
    ULONG                                       ulCountAdapters = 0L;

    if( NULL != ppEnum )
    {
        *ppEnum = NULL;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                IID_PPV_ARG(INetCfg, &pnetcfg));

        if( S_OK == hr )
        {
            hr = pnetcfg->Initialize( NULL );

            if( S_OK == hr )
            {
                hr = pnetcfg->FindComponent( c_wszSBridgeSID, &pBridgeProtocol );

                if( S_OK == hr )
                {
                    INetCfgComponentBindings    *pnetcfgProtocolBindings;

                    // Get the ComponentBindings interface for the protocol component
                    hr = pBridgeProtocol->QueryInterface(
                            IID_PPV_ARG(INetCfgComponentBindings, &pnetcfgProtocolBindings)
                            );

                    if( S_OK == hr )
                    {
                        const GUID               guidDevClass = GUID_DEVCLASS_NET;
                        IEnumNetCfgComponent    *penumncfgcomp;
                        INetCfgComponent        *pnetcfgcomp;

                        //
                        // Get the list of NET (adapter) devices
                        //
                        hr = pnetcfg->EnumComponents( &guidDevClass, &penumncfgcomp );

                        if( S_OK == hr )
                        {
                            ULONG               ul;

                            //
                            // Examine each adapter to see if it's bound to the bridge protocol
                            //
                            while( (S_OK == hr) && (S_OK == penumncfgcomp->Next(1, &pnetcfgcomp, &ul)) )
                            {
                                _ASSERT( 1L == ul );
                                hr = pnetcfgProtocolBindings->IsBoundTo(pnetcfgcomp);

                                if( S_OK == hr )
                                {
                                    IHNetBridgedConnection      *pBridgedConnection;

                                    //
                                    // The bridge protocol is bound to this adapter. Turn the NetCfg component
                                    // interface into an IHNetBridgedConnection.
                                    //
                                    hr = GetIHNetConnectionForNetCfgComponent(
                                            m_piwsHomenet,
                                            pnetcfgcomp,
                                            TRUE,
                                            IID_PPV_ARG(IHNetBridgedConnection, &pBridgedConnection)
                                            );

                                    if( S_OK == hr )
                                    {
                                        IHNetBridgedConnection  **ppNewArray;

                                        //
                                        // Add the new IHNetBridgedConnection to our array
                                        //

                                        ppNewArray = reinterpret_cast<IHNetBridgedConnection**>(CoTaskMemRealloc( rgBridgedAdapters, (ulCountAdapters + 1) * sizeof(IHNetBridgedConnection*) ));

                                        if( NULL == ppNewArray )
                                        {
                                            hr = E_OUTOFMEMORY;
                                            // rgBridgedAdapters will be cleaned up below
                                        }
                                        else
                                        {
                                            // Use the newly grown array
                                            rgBridgedAdapters =  ppNewArray;
                                            rgBridgedAdapters[ulCountAdapters] = pBridgedConnection;
                                            ulCountAdapters++;
                                            pBridgedConnection->AddRef();
                                        }

                                        pBridgedConnection->Release();
                                    }
                                }
                                else if( S_FALSE == hr )
                                {
                                    // The bridge protocol is not bound to this adapter. Reset hr to success.
                                    hr = S_OK;
                                }

                                pnetcfgcomp->Release();
                            }

                            penumncfgcomp->Release();
                        }

                        pnetcfgProtocolBindings->Release();
                    }

                    pBridgeProtocol->Release();
                }

                pnetcfg->Uninitialize();
            }

            pnetcfg->Release();
        }

        //
        // Turn the array of bridge members into an enumeration
        //
        if( S_OK == hr )
        {
            hr = CComObject<CEnumHNetBridgedConnections>::CreateInstance(&pEnum);

            if( SUCCEEDED(hr) )
            {
                pEnum->AddRef();

                hr = pEnum->Initialize(rgBridgedAdapters, ulCountAdapters);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnum-> QueryInterface(
                            IID_PPV_ARG(IEnumHNetBridgedConnections, ppEnum)
                            );
                }

                pEnum->Release();
            }
        }

        //
        // The enumeration made a copy of the array and AddRef()ed the members.
        // Ditch it now.
        //
        if( rgBridgedAdapters )
        {
            ULONG           i;

            _ASSERT( ulCountAdapters );

            for( i = 0; i < ulCountAdapters; i++ )
            {
                _ASSERT( rgBridgedAdapters[i] );
                rgBridgedAdapters[i]->Release();
            }

            CoTaskMemFree( rgBridgedAdapters );
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CHNBridge::AddMember(
    IHNetConnection *pConn,
    IHNetBridgedConnection **ppBridgedConn,
    INetCfg *pnetcfgExisting
    )

{
    HRESULT             hr = S_OK;


    if (NULL == ppBridgedConn)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppBridgedConn = NULL;

        if (NULL == pConn)
        {
            hr = E_INVALIDARG;
        }
    }

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    //
    // Make sure that it's permissible to add this connection
    // to a bridge
    //

    if (S_OK == hr)
    {
        HNET_CONN_PROPERTIES *pProps;

        hr = pConn->GetProperties(&pProps);

        if (S_OK == hr)
        {
            if (!pProps->fCanBeBridged)
            {
                hr = E_UNEXPECTED;
            }

            CoTaskMemFree(pProps);
        }
    }

    //
    // Bind the adapter to the bridge
    //

    if (S_OK == hr)
    {
        GUID            *pguidAdapter;

        hr = pConn->GetGuid (&pguidAdapter);

        if (S_OK == hr)
        {
            hr = BindNewAdapter (pguidAdapter, pnetcfgExisting);
            CoTaskMemFree(pguidAdapter);
        }
    }

    if (SUCCEEDED(hr))
    {
        if( NULL != pnetcfgExisting )
        {
            // Need to apply the changes for the next call to succeed
            hr = pnetcfgExisting->Apply();
        }

        if( SUCCEEDED(hr) )
        {
            // We should now be able to turn the provided connection into
            // an IHNetBridgedConnection
            hr = pConn->GetControlInterface( IID_PPV_ARG(IHNetBridgedConnection, ppBridgedConn) );

            // There is no good way to recover if this last operation failed
            _ASSERT( SUCCEEDED(hr) );

            //
            // Inform netman that something changed. Error doesn't matter.
            //
            UpdateNetman();
        }
    }

    return hr;
}

STDMETHODIMP
CHNBridge::Destroy(
    INetCfg *pnetcfgExisting
    )

{
    HRESULT                     hr = S_OK;
    IEnumHNetBridgedConnections *pEnum;
    IHNetBridgedConnection      *pConn;
    GUID                        *pGuid = NULL;

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    // Remember our connection GUID before we destroy it
    hr = GetGuid( &pGuid );

    if (SUCCEEDED(hr))
    {
        //
        // Get the enumeration of our members
        //

        hr = EnumMembers(&pEnum);

        if (S_OK == hr)
        {
            ULONG ulCount;

            //
            // Remove each member from the bridge
            //

            do
            {
                hr = pEnum->Next(
                        1,
                        &pConn,
                        &ulCount
                        );

                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    hr = pConn->RemoveFromBridge( pnetcfgExisting );
                    pConn->Release();
                }
            }
            while (SUCCEEDED(hr) && 1 == ulCount);

            pEnum->Release();
        }
    }
    else
    {
        _ASSERT( NULL == pGuid );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Remove the miniport
        //

        hr = RemoveMiniport( pnetcfgExisting );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Delete the WMI objects
        //

        hr = m_piwsHomenet->DeleteInstance(
                m_bstrProperties,
                0,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            hr = m_piwsHomenet->DeleteInstance(
                m_bstrConnection,
                0,
                NULL,
                NULL
                );
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Inform netman that something changed. Error doesn't matter.
        //

        UpdateNetman();

        // Refresh the UI to remove this connection
        _ASSERT( NULL != pGuid );
        SignalDeletedConnection( pGuid );
    }

    if( NULL != pGuid )
    {
        CoTaskMemFree( pGuid );
    }

    return hr;
}

HRESULT
CHNBridge::RemoveMiniport(
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )
{
    HRESULT             hr = S_OK;
    INetCfg             *pnetcfg = NULL;
    INetCfgLock         *pncfglock = NULL;
    GUID                *pguid;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we failed to get a netcfg context
        if(  FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    hr = GetGuid( &pguid );

    if ( SUCCEEDED(hr) )
    {
        INetCfgComponent        *pnetcfgcomp;

        //
        // Locate ourselves by GUID
        //
        hr = FindAdapterByGUID(pnetcfg, pguid, &pnetcfgcomp);

        if ( SUCCEEDED(hr) )
        {
            const GUID          guidDevClass = GUID_DEVCLASS_NET;
            INetCfgClassSetup   *pncfgsetup = NULL;

            //
            // Recover the NetCfgClassSetup interface
            //
            hr = pnetcfg->QueryNetCfgClass(
                    &guidDevClass,
                    IID_PPV_ARG(INetCfgClassSetup, &pncfgsetup)
                    );

            if ( SUCCEEDED(hr) )
            {
                //
                // Blow away this instance of the bridge
                //
                hr = pncfgsetup->DeInstall(
                        pnetcfgcomp,
                        NULL,
                        NULL
                        );

                pncfgsetup->Release();
            }

            // Done with the bridge component
            pnetcfgcomp->Release();
        }

        CoTaskMemFree(pguid);
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}

HRESULT
CHNBridge::BindNewAdapter(
    IN GUID                 *pguid,
    IN OPTIONAL INetCfg     *pnetcfgExisting
    )
{
    HRESULT             hr = S_OK;
    INetCfg             *pnetcfg = NULL;
    INetCfgLock         *pncfglock = NULL;
    INetCfgComponent    *pnetcfgcomp;

    if( NULL == pnetcfgExisting )
    {
        hr = InitializeNetCfgForWrite( &pnetcfg, &pncfglock );

        // Bail out if we failed to get a netcfg context
        if(  FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        // Use the NetCfg context we were given
        pnetcfg = pnetcfgExisting;
    }

    // We must have a NetCfg context at this point
    _ASSERT( pnetcfg != NULL );

    hr = FindAdapterByGUID(
            pnetcfg,
            pguid,
            &pnetcfgcomp
            );

    if ( SUCCEEDED(hr) )
    {
        hr = BindOnlyToBridge( pnetcfgcomp );
        pnetcfgcomp->Release();
    }

    // If we created our own NetCfg context, shut it down now
    if( NULL == pnetcfgExisting )
    {
        // Apply everything if we succeeded, back out otherwise
        if ( SUCCEEDED(hr) )
        {
            hr = pnetcfg->Apply();

            // Redraw this connection
            SignalModifiedConnection( pguid );
        }
        else
        {
            // Don't want to lose the original error code
            pnetcfg->Cancel();
        }

        UninitializeNetCfgForWrite( pnetcfg, pncfglock );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\bridge\sys\bridge.h ===
/*++

Copyright(c) 1999-2000  Microsoft Corporation

Module Name:

    bridge.h

Abstract:

    Ethernet MAC level bridge.

Author:

    Mark Aiken
    (original bridge by Jameel Hyder)

Environment:

    Kernel mode driver

Revision History:

    Sept 1999 - Original version
    Feb  2000 - Overhaul

--*/

#pragma warning( push, 3 )
// For Ethernet constants and macros
#include <xfilter.h>

// For ULONG_MAX
#include <limits.h>
#pragma warning( pop )

// Disable "conditional expression is constant" warning
#pragma warning( disable: 4127 )

// Disable "Unreferenced formal parameter" warning
#pragma warning( disable: 4100 )

// Disable "Bit field type other than int" warning
#pragma warning( disable: 4214 )

// Debugging defines
#include "brdgdbg.h"

// Singly-linked list implementation
#include "brdgslist.h"

// WAIT_REFCOUNT implementation
#include "brdgwref.h"

// Timer implementation
#include "brdgtimr.h"

// Hash table implementation
#include "brdghash.h"

// Cache implementation
#include "brdgcach.h"

// Our IOCTLs and control structures
#include "bioctl.h"

// Include the STA type declarations
#include "brdgstad.h"

// ===========================================================================
//
// CONSTANTS
//
// ===========================================================================

#define DEVICE_NAME             L"\\Device\\Bridge"
#define SYMBOLIC_NAME           L"\\DosDevices\\Bridge"
#define PROTOCOL_NAME           L"BRIDGE"

//
// The IEEE-specified reserved Spanning Tree Algorithm group destination
// MAC address
//
// This exact address is specified as the "Bridge Group Address" and is used for
// transmitting STA packets. *Any* address with these first 5 bytes is reserved
// by the IEEE for future use (so there are 15 reserved but unused addresses).
//
// Frames addressed to ANY of the reserved addresses are never relayed by the bridge.
//
extern UCHAR                    STA_MAC_ADDR[ETH_LENGTH_OF_ADDRESS];

//
// Each queue draining thread blocks against one kernel event per adapter, plus
// the global kill event and the per-processor event to trigger a re-enumeration
// of adapters.
//
// This limits our maximum number of adapters, since the kernel can't block a
// thread against an unbounded number of objects.
//
#define MAX_ADAPTERS (MAXIMUM_WAIT_OBJECTS - 2)

// Registry key where we keep our global parameters
extern const PWCHAR             gRegConfigPath;

// Size of an Ethernet frame header
#define ETHERNET_HEADER_SIZE    ((2*ETH_LENGTH_OF_ADDRESS) + 2)

// Largest possible Ethernet packet (with header)
#define MAX_PACKET_SIZE         1514

// ===========================================================================
//
// TYPE DECLARATIONS
//
// ===========================================================================

struct _NDIS_REQUEST_BETTER;

// Completion function type for NDIS_REQUEST_BETTER
typedef VOID (*PCOMPLETION_FUNC)(struct _NDIS_REQUEST_BETTER*, PVOID);

//
// Structure for performing NDIS requests. Can block to wait for result or
// specify a custom completion routine.
//
typedef struct _NDIS_REQUEST_BETTER
{
    NDIS_REQUEST            Request;
    NDIS_STATUS             Status;                 // Final status of the request
    NDIS_EVENT              Event;                  // Event signaled when request completes
    PCOMPLETION_FUNC        pFunc;                  // Completion function
    PVOID                   FuncArg;                // Argument to completion function
} NDIS_REQUEST_BETTER, *PNDIS_REQUEST_BETTER;

typedef struct _ADAPTER_QUOTA
{
    //
    // Total number of packets this adapter is holding from each major pool.
    //
    // Note that the sum of all adapters' pool usage can be greater than the pool capacity,
    // because base packets are shared. The quota scheme allows this.
    //
    // [0] == Copy packets
    // [1] == Wrapper packets
    //
    ULONG                   UsedPackets[2];

} ADAPTER_QUOTA, *PADAPTER_QUOTA;

//
// Per adapter data structure
//
typedef struct _ADAPT ADAPT, *PADAPT;

typedef struct _ADAPT
{
    PADAPT                  Next;                   // Next adapter in queue

    LONG                    AdaptSize;              // Size of structure (storage for DeviceName is at tail)
    WAIT_REFCOUNT           Refcount;               // Refcount for the adapter

    // State must be updated inside a write lock on gAdapterCharacteristicsLock,
    // since an adapter's relaying status affects our miniport's virtual status.
    // Only the STA code writes to this field; all other code should treat it as
    // read-only.
    PORT_STATE              State;

    //
    // Various useful info about the adapter. None of these fields are ever changed after
    // adapter initialization.
    //
    NDIS_STRING             DeviceName;
    NDIS_STRING             DeviceDesc;

    UCHAR                   MACAddr[ETH_LENGTH_OF_ADDRESS];
    NDIS_MEDIUM             PhysicalMedium;         // Set to NO_MEDIUM if the NIC doesn't report something more specific

    NDIS_HANDLE             BindingHandle;
    BOOLEAN                 bCompatibilityMode;     // TRUE if the adapter is in compatibility mode

    // These two fields are used while opening / closing an adapter
    NDIS_EVENT              Event;
    NDIS_STATUS             Status;

    // This field is volatile
    BOOLEAN                 bResetting;

    // The queue and bServiceInProgress is protected by this spin lock
    NDIS_SPIN_LOCK          QueueLock;
    BSINGLE_LIST_HEAD       Queue;
    BOOLEAN                 bServiceInProgress;

    // This allows a caller to wait on the queue becoming empty. It is updated when an item is
    // queued or dequeued.
    WAIT_REFCOUNT           QueueRefcount;

    // Auto-clearing event to request servicing of the queue
    KEVENT                  QueueEvent;

    // These fields are locked by gAdapterCharacteristicsLock for all adapters together
    ULONG                   MediaState;             // NdisMediaStateConnected / NdisMediaStateDisconnected
    ULONG                   LinkSpeed;              // Units of 100bps (10MBps == 100,000)

    // This structure is locked by gQuotaLock for all adapters together
    ADAPTER_QUOTA           Quota;                  // Quota information for this adapter

    // Statistics
    LARGE_INTEGER           SentFrames;             // All frames sent (including relay)
    LARGE_INTEGER           SentBytes;              // All bytes sent (including relay)
    LARGE_INTEGER           SentLocalFrames;        // Frames sent from the local machine
    LARGE_INTEGER           SentLocalBytes;         // Bytes sent from the local machine
    LARGE_INTEGER           ReceivedFrames;         // All received frames (including relay)
    LARGE_INTEGER           ReceivedBytes;          // All received bytes (including relay)

    STA_ADAPT_INFO          STAInfo;                // STA data for this adapter

    // Set once from FALSE to TRUE when STA initialization on this adapter has completed.
    // This flag is set inside the gSTALock.
    BOOLEAN                 bSTAInited;

} ADAPT, *PADAPT;

// ===========================================================================
//
// INLINES / MACROS
//
// ===========================================================================

//
// Calculates the difference between a previously recorded time and now
// allowing for timer rollover
//
__forceinline
ULONG
BrdgDeltaSafe(
    IN ULONG                    prevTime,
    IN ULONG                    nowTime,
    IN ULONG                    maxDelta
    )
{
    ULONG                       delta;

    if( nowTime >= prevTime )
    {
        // Timer did not roll over
        delta = nowTime - prevTime;
    }
    else
    {
        // Looks like timer rolled over
        delta = ULONG_MAX - prevTime + nowTime;
    }

    SAFEASSERT( delta < maxDelta );
    return delta;
}

//
// There is no defined InterlockedExchangeULong function in the kernel, just
// InterlockedExchange. Abstract out the cast.
//
__forceinline ULONG
InterlockedExchangeULong(
    IN PULONG           pULong,
    IN ULONG            NewValue
    )
{
    return (ULONG)InterlockedExchange( (PLONG)pULong, NewValue );
}

//
// Acquires an ADAPT structure checking whether the adapter is
// closing or not.
//
__forceinline BOOLEAN
BrdgAcquireAdapter(
    IN PADAPT           pAdapt
    )
{
    return BrdgIncrementWaitRef( &pAdapt->Refcount );
}

//
// Just increments a PADAPT's refcount; assumes that the refcount is already > 0
// Use when it is guaranteed that BrdgAcquireAdapter() has succeeded and
// the refcount is still > 0.
//
__forceinline VOID
BrdgReacquireAdapter(
    IN PADAPT           pAdapt
    )
{
    BrdgReincrementWaitRef( &pAdapt->Refcount );
}

//
// It is safe to acquire an adapter inside the gAdapterListLock or the gAddressLock
//
__forceinline VOID
BrdgAcquireAdapterInLock(
    IN PADAPT           pAdapt
    )
{
    BOOLEAN             bIncremented;

    SAFEASSERT( pAdapt->Refcount.state == WaitRefEnabled );
    bIncremented = BrdgIncrementWaitRef( &pAdapt->Refcount );
    SAFEASSERT( bIncremented );
}

//
// Releases a PADAPT structure (from either a BrdgAcquireAdapter() or BrdgReacquireAdapter()
// call)
//
__forceinline VOID
BrdgReleaseAdapter(
    IN PADAPT           pAdapt
    )
{
    BrdgDecrementWaitRef( &pAdapt->Refcount );
}

// ===========================================================================
//
// PROTOTYPES
//
// ===========================================================================

VOID
BrdgUnload(
    IN  PDRIVER_OBJECT      DriverObject
    );

NDIS_STATUS
BrdgDeferFunction(
    VOID                    (*pFunc)(PVOID),
    PVOID                   arg
    );

NTSTATUS
BrdgReadRegUnicode(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PWCHAR              *String,        // The string from the registry, freshly allocated
    OUT PULONG              StringSize      // Size of allocated memory at String
    );

NTSTATUS
BrdgReadRegDWord(
    IN PUNICODE_STRING      KeyName,
    IN PWCHAR               pValueName,
    OUT PULONG              Value
    );

NTSTATUS
BrdgDispatchRequest(
    IN  PDEVICE_OBJECT      pDeviceObject,
    IN  PIRP                pIrp
    );

NTSTATUS
BrdgOpenDevice (
    IN LPWSTR           pDeviceNameStr,
    OUT PDEVICE_OBJECT  *ppDeviceObject,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject
    );

VOID
BrdgCloseDevice(
    IN HANDLE               FileHandle,
    IN PFILE_OBJECT         pFileObject,
    IN PDEVICE_OBJECT       pDeviceObject
    );

VOID
BrdgShutdown(VOID);

BOOLEAN
BrdgIsRunningOnPersonal(VOID);
                 

// ===========================================================================
//
// GLOBAL VARIABLE DECLARATIONS
//
// ===========================================================================

// NDIS handle for us as a protocol
extern NDIS_HANDLE              gProtHandle;

// The adapter list
extern PADAPT                   gAdapterList;

// RW lock protecting the adapter list
extern NDIS_RW_LOCK             gAdapterListLock;

// != 0 means we are shutting down
extern LONG                     gShuttingDown;

// Our driver object
extern PDRIVER_OBJECT           gDriverObject;

// Our registry key where we can keep config information
extern UNICODE_STRING           gRegistryPath;

// Set if the Bridge believes that tcp/ip has been loaded
extern BOOLEAN                  g_fIsTcpIpLoaded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\homenet\config\cfgmgr\hncfgmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C F G M G R . C P P
//
//  Contents:   CHNetCfgMgr implementation
//
//  Notes:
//
//  Author:     jonburs 23 May 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// Atl methods
//

HRESULT
CHNetCfgMgr::FinalConstruct()

{
    HRESULT hr = S_OK;
    IWbemLocator *pLocator = NULL;
    BSTR bstrNamespace = NULL;

    //
    // Allocate the commonly used BSTRs
    //

    m_bstrWQL = SysAllocString(c_wszWQL);
    if (NULL == m_bstrWQL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        //
        // Allocate the BSTR for our namespace
        //

        bstrNamespace = SysAllocString(c_wszNamespace);
        if (NULL == bstrNamespace)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        //
        // Create the IWbemLocator object. This interface allows us to
        // connect to the desired namespace.
        //

        hr = CoCreateInstance(
                CLSID_WbemLocator,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                IID_PPV_ARG(IWbemLocator, &pLocator)
                );
    }

    if (S_OK == hr)
    {
        //
        // Connect to our namespace
        //

        hr = pLocator->ConnectServer(
                bstrNamespace,
                NULL,   // user
                NULL,   // password
                NULL,   // locale
                0,      // security flags
                NULL,   // authority
                NULL,   // context
                &m_piwsHomenet
                );
    }

    //
    // Cleanup locals.
    //

    if (pLocator) pLocator->Release();
    if (bstrNamespace) SysFreeString(bstrNamespace);

    if (S_OK != hr)
    {
        //
        // Cleanup object members
        //

        SysFreeString(m_bstrWQL);
        m_bstrWQL = NULL;
        if (NULL != m_piwsHomenet)
        {
            m_piwsHomenet->Release();
            m_piwsHomenet = NULL;
        }
    }

    return hr;
}

HRESULT
CHNetCfgMgr::FinalRelease()

{
    if (m_piwsHomenet) m_piwsHomenet->Release();
    if (m_pNetConnUiUtil) m_pNetConnUiUtil->Release();
    if (m_pNetConnHNetUtil) m_pNetConnHNetUtil->Release();
    if (m_bstrWQL) SysFreeString(m_bstrWQL);

    return S_OK;
}


//
// IHNetCfgMgr methods
//

STDMETHODIMP
CHNetCfgMgr::GetIHNetConnectionForINetConnection(
    INetConnection *pNetConnection,
    IHNetConnection **ppHNetConnection
    )

{
    HRESULT hr = S_OK;
    NETCON_PROPERTIES* pProps;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties = NULL;
    BOOLEAN fLanConnection;

    if (NULL == ppHNetConnection)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppHNetConnection = NULL;

        if (NULL == pNetConnection)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Get the properties for the connection
        //

        hr = pNetConnection->GetProperties(&pProps);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Attempt to find the connection and properties
        // instances in the store
        //

        hr = GetConnAndPropInstancesByGuid(
                m_piwsHomenet,
                &pProps->guidId,
                &pwcoConnection,
                &pwcoProperties
                );

        if (FAILED(hr))
        {


            //
            // We have no record of this connection. Determine
            // if it is a lan connection. (Will need to update
            // this for bridge)
            //

            fLanConnection = (NCM_LAN                  == pProps->MediaType ||
                              NCM_BRIDGE               == pProps->MediaType);

            //
            // Create the store instances
            //

            hr = CreateConnectionAndPropertyInstances(
                    &pProps->guidId,
                    fLanConnection,
                    pProps->pszwName,
                    &pwcoConnection,
                    &pwcoProperties
                    );

            //
            // If this is a ras connection, determine the
            // phonebook path
            //

            if (S_OK == hr && FALSE == fLanConnection)
            {
                LPWSTR wsz;
                VARIANT vt;

                hr = GetPhonebookPathFromRasNetcon(pNetConnection, &wsz);
                if (SUCCEEDED(hr))
                {
                    V_VT(&vt) = VT_BSTR;
                    V_BSTR(&vt) = SysAllocString(wsz);
                    CoTaskMemFree(wsz);

                    if (NULL != V_BSTR(&vt))
                    {
                        hr = pwcoConnection->Put(
                                c_wszPhonebookPath,
                                0,
                                &vt,
                                NULL
                                );

                        VariantClear(&vt);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Save modified connection instance
                    //

                    hr = m_piwsHomenet->PutInstance(
                            pwcoConnection,
                            WBEM_FLAG_CREATE_OR_UPDATE,
                            NULL,
                            NULL
                            );
                }
                else
                {
                    //
                    // Delete the newly created instances
                    //

                    DeleteWmiInstance(m_piwsHomenet, pwcoConnection);
                    DeleteWmiInstance(m_piwsHomenet, pwcoProperties);
                    pwcoConnection->Release();
                    pwcoProperties->Release();
                }
            }
        }

        NcFreeNetconProperties(pProps);
    }

    if (S_OK == hr)
    {
        CComObject<CHNetConn> *pHNConn;

        //
        // Create the wrapper object
        //

        hr = CComObject<CHNetConn>::CreateInstance(&pHNConn);

        if (SUCCEEDED(hr))
        {
            pHNConn->AddRef();

            hr = pHNConn->SetINetConnection(pNetConnection);

            if (S_OK == hr)
            {
                hr = pHNConn->InitializeFromInstances(
                        m_piwsHomenet,
                        pwcoConnection,
                        pwcoProperties
                        );
            }

            if (S_OK == hr)
            {
                hr = pHNConn->QueryInterface(
                        IID_PPV_ARG(IHNetConnection, ppHNetConnection)
                        );
            }

            pHNConn->Release();
        }

        pwcoConnection->Release();
        pwcoProperties->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetIHNetConnectionForGuid(
    GUID *pGuid,
    BOOLEAN fLanConnection,
    BOOLEAN fCreateEntries,
    IHNetConnection **ppHNetConnection
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties = NULL;

    if (NULL == ppHNetConnection)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppHNetConnection = NULL;

        if (NULL == pGuid)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Attempt to find the connection and properties
        // instances in the store
        //

        hr = GetConnAndPropInstancesByGuid(
                m_piwsHomenet,
                pGuid,
                &pwcoConnection,
                &pwcoProperties
                );

        if (FAILED(hr) && fCreateEntries)
        {
            INetConnection *pNetConn;

            //
            // We don't have a record of this guid. Get the INetConnection
            // that it corresponds to.
            //

            hr = FindINetConnectionByGuid(pGuid, &pNetConn);

            if (SUCCEEDED(hr))
            {
                hr = GetIHNetConnectionForINetConnection(
                        pNetConn,
                        ppHNetConnection
                        );

                pNetConn->Release();
                return hr;
            }
        }
    }


    if (S_OK == hr)
    {
        CComObject<CHNetConn> *pHNConn;

        //
        // Create the wrapper object
        //

        hr = CComObject<CHNetConn>::CreateInstance(&pHNConn);

        if (SUCCEEDED(hr))
        {
            pHNConn->AddRef();

            hr = pHNConn->InitializeFromInstances(
                    m_piwsHomenet,
                    pwcoConnection,
                    pwcoProperties
                    );

            if (S_OK == hr)
            {
                hr = pHNConn->QueryInterface(
                        IID_PPV_ARG(IHNetConnection, ppHNetConnection)
                        );
            }

            pHNConn->Release();
        }

        pwcoConnection->Release();
        pwcoProperties->Release();
    }

    return hr;
}

//
// IHNetBridgeSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumBridges(
    IEnumHNetBridges **ppEnum
    )

{
    HRESULT                             hr;
    CComObject<CEnumHNetBridges>        *pEnum;
    IHNetBridge                         *phnbridge;

    if( NULL != ppEnum )
    {
        *ppEnum = NULL;

        hr = GetBridgeConnection( m_piwsHomenet, &phnbridge );

        if( S_OK == hr )
        {
            hr = CComObject<CEnumHNetBridges>::CreateInstance(&pEnum);

            if( SUCCEEDED(hr) )
            {
                pEnum->AddRef();

                hr = pEnum->Initialize(&phnbridge, 1L);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnum-> QueryInterface(
                            IID_PPV_ARG(IEnumHNetBridges, ppEnum)
                            );
                }

                pEnum->Release();
            }

            phnbridge->Release();
        }
        else
        {
            // Make an empty enumerator
            hr = CComObject<CEnumHNetBridges>::CreateInstance(&pEnum);

            if( SUCCEEDED(hr) )
            {
                pEnum->AddRef();

                hr = pEnum->Initialize(NULL, 0L);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnum-> QueryInterface(
                            IID_PPV_ARG(IEnumHNetBridges, ppEnum)
                            );
                }

                pEnum->Release();
            }
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::CreateBridge(
    IHNetBridge **ppHNetBridge,
    INetCfg *pnetcfgExisting
    )
{
    HRESULT hr = S_OK;
    GUID guid;
    IWbemClassObject *pwcoConnection = NULL;
    IWbemClassObject *pwcoProperties = NULL;

    if (NULL != ppHNetBridge)
    {
        *ppHNetBridge = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        //
        // Install the bridge driver, and create the bridge miniport.
        //

        hr = InstallBridge( &guid, pnetcfgExisting );
    }

    if (S_OK == hr)
    {
        //
        // See if we already have property instances for this connection.
        // (They may have been created when the bridge connection object
        // was instantiated.)
        //

        hr = GetConnAndPropInstancesByGuid(
                m_piwsHomenet,
                &guid,
                &pwcoConnection,
                &pwcoProperties
                );

        if (S_OK != hr)
        {
            //
            // Create the store instances
            //

            hr = CreateConnectionAndPropertyInstances(
                    &guid,
                    TRUE,
                    c_wszBridge,
                    &pwcoConnection,
                    &pwcoProperties
                    );
        }
    }

    if (S_OK == hr)
    {
        //
        // Inform netman that something changed. Error doesn't matter.
        //

        UpdateNetman();
    }

    if (S_OK == hr)
    {
        CComObject<CHNBridge> *pBridge;

        //
        // Create wrapper object to return
        //

        hr = CComObject<CHNBridge>::CreateInstance(&pBridge);

        if (SUCCEEDED(hr))
        {
            pBridge->AddRef();

            hr = pBridge->InitializeFromInstances(
                    m_piwsHomenet,
                    pwcoConnection,
                    pwcoProperties
                    );

            if (S_OK == hr)
            {
                hr = pBridge->QueryInterface(
                        IID_PPV_ARG(IHNetBridge, ppHNetBridge)
                        );
            }

            pBridge->Release();
        }
    }

    if (NULL != pwcoConnection) pwcoConnection->Release();
    if (NULL != pwcoProperties) pwcoProperties->Release();

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::DestroyAllBridges(
    ULONG *pcBridges,
    INetCfg *pnetcfgExisting
    )

{
    HRESULT hr = S_OK;
    IEnumHNetBridges *pehnbEnum;
    IHNetBridge *phnBridge;

    if (!pcBridges)
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_AllowNetBridge_NLA))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        *pcBridges = 0;

        //
        // Get the enumeration of the bridges.
        //

        hr = EnumBridges(&pehnbEnum);
    }

    if (S_OK == hr)
    {
        //
        // Walk through the enumeration, destroying
        // each bridge
        //

        do
        {
            hr = pehnbEnum->Next(1, &phnBridge, NULL);
            if (S_OK == hr)
            {
                phnBridge->Destroy( pnetcfgExisting );
                phnBridge->Release();
                *pcBridges += 1;
            }
        }
        while (S_OK == hr);

        hr = S_OK;
        pehnbEnum->Release();
    }

    return hr;
}

//
// IHNetFirewallSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumFirewalledConnections(
    IEnumHNetFirewalledConnections **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ConnectionProperties instances
        // where IsFirewall is true.
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetProperties,
                L"IsFirewalled != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetFirewalledConnections> *pEnum;

        hr = CComObject<CEnumHNetFirewalledConnections>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetFirewalledConnections, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS **ppSettings
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoSettings = NULL;

    if (!ppSettings)
    {
        hr = E_POINTER;
    }

    //
    // Allocate the necessary memory for the settings structure.
    //

    if (S_OK == hr)
    {
        *ppSettings = reinterpret_cast<HNET_FW_LOGGING_SETTINGS *>(
                        CoTaskMemAlloc(sizeof(HNET_FW_LOGGING_SETTINGS))
                        );

        if (NULL == *ppSettings)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetFWLoggingSettings,
                FALSE,
                &pwcoSettings
                );
    }

    if (S_OK == hr)
    {
        //
        // Copy the instance info into the settings block
        //

        hr = CopyLoggingInstanceToStruct(pwcoSettings, *ppSettings);

        pwcoSettings->Release();
    }

    if (FAILED(hr))
    {
        //
        // Clean up output structure
        //

        if (ppSettings && *ppSettings)
        {
            CoTaskMemFree(*ppSettings);
            *ppSettings = NULL;
        }
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::SetFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS *pSettings
    )

{
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoSettings;

    if (NULL == pSettings)
    {
        hr = E_INVALIDARG;
    }

    if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        //
        // Attempt to retrieve the HNet_FirewallLoggingSettings instance from
        // the store
        //

        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetFWLoggingSettings,
                TRUE,
                &pwcoSettings
                );
    }

    if (S_OK == hr)
    {
        //
        // Copy settings struct into object instance
        //

        hr = CopyStructToLoggingInstance(pSettings, pwcoSettings);

        if (S_OK == hr)
        {
            //
            // Write settings instance back to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoSettings,
                    WBEM_FLAG_CREATE_OR_UPDATE,
                    NULL,
                    NULL
                    );
        }

        pwcoSettings->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Notify service of configuration change
        //

        UpdateService(IPNATHLP_CONTROL_UPDATE_FWLOGGER);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::DisableAllFirewalling(
    ULONG *pcFirewalledConnections
    )

{
    HRESULT hr = S_OK;
    IEnumHNetFirewalledConnections *pehfcEnum;
    IHNetFirewalledConnection *phfcConnection;

    if (!pcFirewalledConnections)
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_PersonalFirewallConfig))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        *pcFirewalledConnections = 0;

        //
        // Get the enumeration of firewalled connections
        //

        hr = EnumFirewalledConnections(&pehfcEnum);
    }

    if (S_OK == hr)
    {
        //
        // Walk through the enumeration, turning off
        // firewalling for each connection
        //

        do
        {
            hr = pehfcEnum->Next(1, &phfcConnection, NULL);
            if (S_OK == hr)
            {
                phfcConnection->Unfirewall();
                phfcConnection->Release();
                *pcFirewalledConnections += 1;
            }
        }
        while (S_OK == hr);

        hr = S_OK;
        pehfcEnum->Release();
    }

    return hr;
}

//
// IHNetIcsSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumIcsPublicConnections(
    IEnumHNetIcsPublicConnections **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ConnectionProperties instances
        // where IsIcsPublic is true.
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetProperties,
                L"IsIcsPublic != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetIcsPublicConnections> *pEnum;

        hr = CComObject<CEnumHNetIcsPublicConnections>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetIcsPublicConnections, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::EnumIcsPrivateConnections(
    IEnumHNetIcsPrivateConnections **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ConnectionProperties instances
        // where IsIcsPrivate is true.
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetProperties,
                L"IsIcsPrivate != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetIcsPrivateConnections> *pEnum;

        hr = CComObject<CEnumHNetIcsPrivateConnections>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetIcsPrivateConnections, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::DisableIcs(
    ULONG *pcIcsPublicConnections,
    ULONG *pcIcsPrivateConnections
    )

{
    HRESULT hr = S_OK;
    IEnumHNetIcsPrivateConnections *pehiPrivate;
    IEnumHNetIcsPublicConnections *pehiPublic;
    IHNetIcsPrivateConnection *phicPrivate;
    IHNetIcsPublicConnection *phicPublic;

    if (!pcIcsPublicConnections
        || !pcIcsPrivateConnections)
    {
        hr = E_POINTER;
    }

    if (ProhibitedByPolicy(NCPERM_ShowSharedAccessUi))
    {
        hr = HN_E_POLICY;
    }

    if (S_OK == hr)
    {
        *pcIcsPublicConnections = 0;
        *pcIcsPrivateConnections = 0;

        //
        // Get enumeration of private connections
        //

        hr = EnumIcsPrivateConnections(&pehiPrivate);
    }

    if (S_OK == hr)
    {
        //
        // Loop through enumeration, unsharing the connection
        //

        do
        {
            hr = pehiPrivate->Next(1, &phicPrivate, NULL);
            if (S_OK == hr)
            {
                phicPrivate->RemoveFromIcs();
                phicPrivate->Release();
                *pcIcsPrivateConnections += 1;
            }
        } while (S_OK == hr);

        hr = S_OK;
        pehiPrivate->Release();
    }

    if (S_OK == hr)
    {
        //
        // Get enumeration of public connections
        //

        hr = EnumIcsPublicConnections(&pehiPublic);
    }

    if (S_OK == hr)
    {
        //
        // Loop through enumeration, unsharing the connection
        //

        do
        {
            hr = pehiPublic->Next(1, &phicPublic, NULL);
            if (S_OK == hr)
            {
                phicPublic->Unshare();
                phicPublic->Release();
                *pcIcsPublicConnections += 1;
            }
        } while (S_OK == hr);

        hr = S_OK;
        pehiPublic->Release();
    }

    if (S_OK == hr)
    {
        //
        // Currently, maximum of 1 public and private connection
        //

        _ASSERT(*pcIcsPrivateConnections <= 1);
        _ASSERT(*pcIcsPublicConnections <= 1);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetPossiblePrivateConnections(
    IHNetConnection *pConn,
    ULONG *pcPrivateConnections,
    IHNetConnection **pprgPrivateConnections[],
    LONG *pxCurrentPrivate
    )

/*++

Routine Description:

    Given an IHNetConnection, determines the what connections may
    serve as a private connection. Only connections that meet the
    following criteria may serve as a private connection:

    * it's a LAN connection
    * it's not part of a bridge
    * it's not firewalled
    * it's not the connection passed in
    * it's bound to TCP/IP

    Note that these are not the same rules that are used to set the
    fCanBeIcsPrivate member in HNET_CONN_PROPERTIES. In particular,
    these rules don't take into account whether or not a connection
    is currently marked as IcsPublic.

Arguments:

    pConn - the connection that would be the public connection

    pcPrivateConnections - receives the count of connections returned

    pprgPrivateConnections - receives that possible private connections.
        The caller is responsible for:
        1) Releasing all of the interface pointers w/in the array
        2) Calling CoTaskMemFree on the pointer to the array

    pxCurrentPrivate - receives the index into pprgPrivateConnections of
        the connection that is currently marked IcsPrivate. If no connection
        is so marked, receives -1.

Return Value:

    Standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    INetConnectionManager *pNetConnMgr;
    IEnumNetConnection *pEnum;
    INetConnection *rgNetConn[16];
    GUID *pGuid = NULL;
    HNET_CONN_PROPERTIES *pProps;
    IHNetConnection **rgConnections = NULL;
    ULONG cConn = 0;
    ULONG i;
    PIP_INTERFACE_INFO pIpIfTable = NULL;

    if (NULL != pprgPrivateConnections)
    {
        *pprgPrivateConnections = NULL;

        if (NULL == pConn)
        {
            hr = E_INVALIDARG;
        }
        else if (NULL == pcPrivateConnections
                 || NULL == pxCurrentPrivate)
        {
            hr = E_POINTER;
        }
        else
        {
            *pcPrivateConnections = 0;
            *pxCurrentPrivate = -1;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Obtain the IP interface table. We use this table to see if an
    // adapter is bound to TCP/IP.
    //

    if (S_OK == hr)
    {
        DWORD dwError;
        ULONG ulSize = 0;

        dwError = GetInterfaceInfo(NULL, &ulSize);

        if (ERROR_INSUFFICIENT_BUFFER == dwError)
        {
            pIpIfTable =
                reinterpret_cast<PIP_INTERFACE_INFO>(
                    HeapAlloc(GetProcessHeap(), 0, ulSize)
                    );

            if (NULL != pIpIfTable)
            {
                dwError = GetInterfaceInfo(pIpIfTable, &ulSize);
                if (ERROR_SUCCESS != dwError)
                {
                    hr = HRESULT_FROM_WIN32(dwError);
                    HeapFree(GetProcessHeap(), 0, pIpIfTable);
                    pIpIfTable = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    //
    // If the connection we we're given is a LAN connection, get its
    // guid so that we can exclude it from the possible private
    // connections.
    //

    if (S_OK == hr)
    {
        hr = pConn->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (pProps->fLanConnection)
            {
                hr = pConn->GetGuid(&pGuid);
            }

            CoTaskMemFree(pProps);
        }
    }

    //
    // Create the net connections manager, and enumerate through the
    // connections. We don't enumerate through just what our store has,
    // as it might have stale entries (i.e., information for adapters
    // that have been removed from the system).
    //

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                IID_PPV_ARG(INetConnectionManager, &pNetConnMgr)
                );
    }

    if (SUCCEEDED(hr))
    {
        SetProxyBlanket(pNetConnMgr);

        hr = pNetConnMgr->EnumConnections(NCME_DEFAULT, &pEnum);
        pNetConnMgr->Release();
    }

    if (SUCCEEDED(hr))
    {
        ULONG ulCount;

        SetProxyBlanket(pEnum);

        do
        {

            //
            // Grab a bunch of connections out of the enumeration
            //

            hr = pEnum->Next(ARRAYSIZE(rgNetConn), rgNetConn, &ulCount);

            if (SUCCEEDED(hr) && ulCount > 0)
            {
                //
                // Allocate memory for the output array
                //

                LPVOID pTemp = reinterpret_cast<LPVOID>(rgConnections);
                rgConnections = reinterpret_cast<IHNetConnection**>(
                    CoTaskMemRealloc(
                        pTemp,
                        (cConn + ulCount) * sizeof(IHNetConnection*))
                    );

                if (NULL != rgConnections)
                {
                    for (i = 0; i < ulCount; i++)
                    {
                        SetProxyBlanket(rgNetConn[i]);

                        hr = GetIHNetConnectionForINetConnection(
                                rgNetConn[i],
                                &rgConnections[cConn]
                                );

                        if (SUCCEEDED(hr))
                        {
                            hr = rgConnections[cConn]->GetProperties(&pProps);

                            if (SUCCEEDED(hr))
                            {
                                if (!pProps->fLanConnection
                                    || pProps->fPartOfBridge
                                    || pProps->fFirewalled)
                                {
                                    //
                                    // Connection can't be private
                                    //

                                    rgConnections[cConn]->Release();
                                    rgConnections[cConn] = NULL;
                                }
                                else
                                {
                                    GUID *pg;

                                    //
                                    // This connection can be private if:
                                    // 1) it's not the same as the public connection
                                    //    (if the public is LAN), and,
                                    // 2) it's bound to TCP/IP
                                    //

                                    hr = rgConnections[cConn]->GetGuid(&pg);

                                    if (SUCCEEDED(hr))
                                    {
                                        if ((NULL == pGuid
                                                || !IsEqualGUID(*pGuid, *pg))
                                            && ConnectionIsBoundToTcp(pIpIfTable, pg))
                                        {
                                            //
                                            // Connection can be private
                                            //

                                            if (pProps->fIcsPrivate)
                                            {
                                                _ASSERT(-1 == *pxCurrentPrivate);
                                                *pxCurrentPrivate = cConn;
                                            }

                                            cConn += 1;
                                        }
                                        else
                                        {
                                            rgConnections[cConn]->Release();
                                            rgConnections[cConn] = NULL;
                                        }

                                        CoTaskMemFree(pg);
                                    }
                                    else
                                    {
                                        rgConnections[cConn]->Release();
                                        rgConnections[cConn] = NULL;
                                    }
                                }

                                CoTaskMemFree(pProps);
                            }
                        }
                        else
                        {
                            //
                            // The connection couldn't be converted to an
                            // IHNetConnection -- this is expected for
                            // certain connection types (e.g., inbound)
                            //

                            hr = S_OK;
                            rgConnections[cConn] = NULL;
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    if (NULL != pTemp)
                    {
                        rgConnections = reinterpret_cast<IHNetConnection**>(pTemp);
                        for (i = 0; i < cConn; i++)
                        {
                            rgConnections[i]->Release();
                        }
                        CoTaskMemFree(pTemp);
                    }
                }

                //
                // Free the retrieved INetConnections
                //

                for (i = 0; i < ulCount; i++)
                {
                    rgNetConn[i]->Release();
                }
            }

        } while (SUCCEEDED(hr) && ulCount > 0);

        pEnum->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;

        if (cConn > 0)
        {
            *pcPrivateConnections = cConn;
            *pprgPrivateConnections = rgConnections;
        }
        else if (NULL != rgConnections)
        {
            CoTaskMemFree(reinterpret_cast<LPVOID>(rgConnections));
        }
    }
    else
    {
        //
        // Cleanup output array
        //

        if (NULL != rgConnections)
        {
            for (i = 0; i < cConn; i++)
            {
                if (NULL != rgConnections[i])
                {
                    rgConnections[i]->Release();
                }
            }

            CoTaskMemFree(reinterpret_cast<LPVOID>(rgConnections));
        }

        if (NULL != pxCurrentPrivate)
        {
            *pxCurrentPrivate = -1;
        }

        //
        // Even though a failure occurred, return success (with 0 possible
        // private connnections). Doing this allows our UI to continue to
        // show other homenet features, instead of throwing up an error
        // dialog and blocking everything.
        //

        hr = S_OK;
    }

    if (NULL != pGuid)
    {
        CoTaskMemFree(pGuid);
    }

    if (NULL != pIpIfTable)
    {
        HeapFree(GetProcessHeap(), 0, pIpIfTable);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::GetAutodialSettings(
    BOOLEAN *pfAutodialEnabled
    )

{
    HRESULT hr = S_OK;
    BOOL fEnabled;
    DWORD dwError;

    if (!pfAutodialEnabled)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Autodial information is stored in the registry and managed through
        // routines exported from rasapi32.dll. We're not changing any of the
        // autodial code, as to do so would require modifications to numerous
        // files and binaries, and thus would result in a very large test hit.
        //

        dwError = RasQuerySharedAutoDial(&fEnabled);
        if (ERROR_SUCCESS == dwError)
        {
            *pfAutodialEnabled = !!fEnabled;
        }
        else
        {
            //
            // Autodial defaults to true on failure.
            //

            *pfAutodialEnabled = TRUE;
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::SetAutodialSettings(
    BOOLEAN fEnableAutodial
    )

{
    DWORD dwError;

    //
    // Autodial information is stored in the registry and managed through
    // routines exported from rasapi32.dll. We're not changing any of the
    // autodial code, as to do so would require modifications to numerous
    // files and binaries, and thus would result in a very large test hit.
    //

    dwError = RasSetSharedAutoDial(!!fEnableAutodial);

    return HRESULT_FROM_WIN32(dwError);
}

STDMETHODIMP
CHNetCfgMgr::GetDhcpEnabled(
    BOOLEAN *pfDhcpEnabled
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance;

    if (NULL == pfDhcpEnabled)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Default to true on failure
        //

        *pfDhcpEnabled = TRUE;

        //
        // Get the HNet_IcsSettings instance from the store
        //

        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetIcsSettings,
                FALSE,
                &pwcoInstance
                );
    }

    if (S_OK == hr)
    {
        //
        // Retrieve the DHCP enabled property
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszDhcpEnabled,
                pfDhcpEnabled
                );

        pwcoInstance->Release();
    }

    return hr;
    **/
}

STDMETHODIMP
CHNetCfgMgr::SetDhcpEnabled(
    BOOLEAN fEnableDhcp
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance = NULL;

    //
    // Get the HNet_IcsSettings instance from the store
    //

    hr = RetrieveSingleInstance(
            m_piwsHomenet,
            c_wszHnetIcsSettings,
            TRUE,
            &pwcoInstance
            );

    if (S_OK == hr)
    {
        //
        // Write the property
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszDhcpEnabled,
                fEnableDhcp
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoInstance,
                    WBEM_FLAG_CREATE_OR_UPDATE,
                    NULL,
                    NULL
                    );
        }

        pwcoInstance->Release();
    }

    return hr;
    **/
}

STDMETHODIMP
CHNetCfgMgr::GetDhcpScopeSettings(
    DWORD *pdwScopeAddress,
    DWORD *pdwScopeMask
    )

{
    HRESULT hr = S_OK;

    if (NULL == pdwScopeAddress || NULL == pdwScopeMask)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ReadDhcpScopeSettings(pdwScopeAddress, pdwScopeMask);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::SetDhcpScopeSettings(
    DWORD dwScopeAddress,
    DWORD dwScopeMask
    )

{
    //
    // This functionality isn't exposed in any way at the moment.
    //
    // People needing to override the default settings can do so
    // through the registry...
    //

    return E_NOTIMPL;
}


STDMETHODIMP
CHNetCfgMgr::GetDnsEnabled(
    BOOLEAN *pfDnsEnabled
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance = NULL;

    if (NULL == pfDnsEnabled)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Default to true on failure
        //

        *pfDnsEnabled = TRUE;

        //
        // Get the HNet_IcsSettings instance from the store
        //

        hr = RetrieveSingleInstance(
                m_piwsHomenet,
                c_wszHnetIcsSettings,
                FALSE,
                &pwcoInstance
                );
    }

    if (S_OK == hr)
    {
        //
        // Retrieve the DHCP enabled property
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszDnsEnabled,
                pfDnsEnabled
                );

        pwcoInstance->Release();
    }

    return hr;
    **/
}

STDMETHODIMP
CHNetCfgMgr::SetDnsEnabled(
    BOOLEAN fEnableDns
    )

{
    //
    // Not supported in whistler, per 173399.
    //

    return E_NOTIMPL;

    /**
    HRESULT hr = S_OK;
    IWbemClassObject *pwcoInstance = NULL;

    //
    // Get the HNet_IcsSettings instance from the store
    //

    hr = RetrieveSingleInstance(
            m_piwsHomenet,
            c_wszHnetIcsSettings,
            TRUE,
            &pwcoInstance
            );

    if (S_OK == hr)
    {
        //
        // Write the property
        //

        hr = SetBooleanValue(
                pwcoInstance,
                c_wszDnsEnabled,
                fEnableDns
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the modified instance to the store
            //

            hr = m_piwsHomenet->PutInstance(
                    pwcoInstance,
                    WBEM_FLAG_CREATE_OR_UPDATE,
                    NULL,
                    NULL
                    );
        }

        pwcoInstance->Release();
    }

    return hr;
    **/

}
STDMETHODIMP
CHNetCfgMgr::EnumDhcpReservedAddresses(
    IEnumHNetPortMappingBindings **ppEnum
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    IEnumWbemClassObject *pwcoEnum;

    if (NULL != ppEnum)
    {
        *ppEnum = NULL;
    }
    else
    {
        hr = E_POINTER;
    }

    //
    // Query for all enabled bindings where the name is active.
    //

    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                L"Enabled != FALSE AND NameActive != FALSE"
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Build wrapper object
        //

        CComObject<CEnumHNetPortMappingBindings> *pEnum;

        hr = CComObject<CEnumHNetPortMappingBindings>::CreateInstance(&pEnum);

        if (S_OK == hr)
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (S_OK == hr)
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetPortMappingBindings, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::RefreshTargetComputerAddress(
    OLECHAR *pszwName,
    ULONG ulAddress
    )

{
    HRESULT hr = S_OK;
    BSTR bstrQuery;
    LPWSTR wszNameClause;
    LPWSTR wszWhereClause;
    IEnumWbemClassObject *pwcoEnum = NULL;
    IWbemClassObject *pwcoInstance;
    VARIANT vt;
    
    if (NULL == pszwName
        || 0 == ulAddress)
    {
        hr = E_INVALIDARG;
    }

    //
    // Query for all bindings which match the target computer name.
    //
    // SELECT * FROM HNet_ConnectionPortMapping2 where
    //   TargetName = (computer name) AND NameActive != FALSE
    //
    
    if (S_OK == hr)
    {
        hr = BuildQuotedEqualsString(
                &wszNameClause,
                c_wszTargetName,
                pszwName
                );
    }
    
    if (S_OK == hr)
    {
        hr = BuildAndString(
                &wszWhereClause,
                wszNameClause,
                L"NameActive != FALSE"
                );

        delete [] wszNameClause;
    }
    
    if (S_OK == hr)
    {
        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetConnectionPortMapping,
                wszWhereClause
                );

        delete [] wszWhereClause;
    }

    if (S_OK == hr)
    {
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    while (WBEM_S_NO_ERROR == hr)
    {
        ULONG ulCount;
        
        pwcoInstance = NULL;
        hr = pwcoEnum->Next(WBEM_INFINITE, 1, &pwcoInstance, &ulCount);

        if (SUCCEEDED(hr) && ulCount == 1)
        {
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = ulAddress;

            hr = pwcoInstance->Put(
                    c_wszTargetIPAddress,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the modified instance to the store
                //
                hr = m_piwsHomenet->PutInstance(
                        pwcoInstance,
                        WBEM_FLAG_UPDATE_ONLY,
                        NULL,
                        NULL
                        );
            }
        
            pwcoInstance->Release();
        }
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (pwcoEnum)
    {
        pwcoEnum->Release();
    }

    return hr;
}


//
// IHNetProtocolSettings methods
//

STDMETHODIMP
CHNetCfgMgr::EnumApplicationProtocols(
    BOOLEAN fEnabledOnly,
    IEnumHNetApplicationProtocols **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrQuery;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        *ppEnum = NULL;

        //
        // Query the WMI store for HNet_ApplicationProtocol instances;
        // if fEnabledOnly is true, then only retrieve instances for
        // which the Enabled property is true
        //

        hr = BuildSelectQueryBstr(
                &bstrQuery,
                c_wszStar,
                c_wszHnetApplicationProtocol,
                fEnabledOnly ? L"Enabled != FALSE" : NULL
                );
    }

    if (S_OK == hr)
    {
        pwcoEnum = NULL;
        hr = m_piwsHomenet->ExecQuery(
                m_bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrQuery);
    }

    if (WBEM_S_NO_ERROR == hr)
    {

        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetApplicationProtocols> *pEnum;

        hr = CComObject<CEnumHNetApplicationProtocols>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetApplicationProtocols, ppEnum)
                        );
            }

            pEnum->Release();
        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::CreateApplicationProtocol(
    OLECHAR *pszwName,
    UCHAR ucOutgoingIPProtocol,
    USHORT usOutgoingPort,
    USHORT uscResponses,
    HNET_RESPONSE_RANGE rgResponses[],
    IHNetApplicationProtocol **ppProtocol
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;
    VARIANT vt;
    SAFEARRAY *psa;
    IWbemClassObject *pwcoInstance;

    if (NULL == ppProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProtocol = NULL;

        if (NULL == pszwName
                 || 0 == ucOutgoingIPProtocol
                 || 0 == usOutgoingPort
                 || 0 == uscResponses
                 || NULL == rgResponses)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Check to see if there already exists a protocol with the same
        // outgoing protocol and port
        //

        if (ApplicationProtocolExists(
                m_piwsHomenet,
                m_bstrWQL,
                usOutgoingPort,
                ucOutgoingIPProtocol
                ))
        {
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
        }

    }

    if (S_OK == hr)
    {
        //
        // Convert the array of response range structure to a
        // SAFEARRAY of IUnknowns representing instances.
        //

        hr = ConvertResponseRangeArrayToInstanceSafearray(
                m_piwsHomenet,
                uscResponses,
                rgResponses,
                &psa
                );

    }

    if (S_OK == hr)
    {
        //
        // Spawn a new HNet_ApplicationProtocol
        //

        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetApplicationProtocol,
                &pwcoInstance
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the array property
            //


            V_VT(&vt) = VT_ARRAY | VT_UNKNOWN;
            V_ARRAY(&vt) = psa;

            hr = pwcoInstance->Put(
                    c_wszResponseArray,
                    0,
                    &vt,
                    NULL
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                // bug 555896:  should limit the length of untrusted input string
                // to some reasonable size.  Am using INTERNET_MAX_HOST_NAME_LENGTH
                // (somewhat arbitrarily), which is 256.

                WCHAR szwName[INTERNET_MAX_HOST_NAME_LENGTH];
                StringCchCopyW (szwName, INTERNET_MAX_HOST_NAME_LENGTH, pszwName);

                //
                // Write the name
                //

                V_VT(&vt) = VT_BSTR;
                V_BSTR(&vt) = SysAllocString(szwName);

                if (NULL != V_BSTR(&vt))
                {
                    hr = pwcoInstance->Put(
                            c_wszName,
                            0,
                            &vt,
                            NULL
                            );

                    VariantClear(&vt);
                }

            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the response count. WMI uses VT_I4
                // for its uint16 type
                //

                V_VT(&vt) = VT_I4;
                V_I4(&vt) = uscResponses;

                hr = pwcoInstance->Put(
                    c_wszResponseCount,
                    0,
                    &vt,
                    NULL
                    );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the outgoing port
                //

                V_VT(&vt) = VT_I4;
                V_I4(&vt) = usOutgoingPort;

                hr = pwcoInstance->Put(
                    c_wszOutgoingPort,
                    0,
                    &vt,
                    NULL
                    );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Write the outgoing IP protocol
                //

                V_VT(&vt) = VT_UI1;
                V_UI1(&vt) = ucOutgoingIPProtocol;

                hr = pwcoInstance->Put(
                    c_wszOutgoingIPProtocol,
                    0,
                    &vt,
                    NULL
                    );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Set the builtin value to false
                //

                hr = SetBooleanValue(
                        pwcoInstance,
                        c_wszBuiltIn,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // New protocols are disabled by default
                //

                hr = SetBooleanValue(
                        pwcoInstance,
                        c_wszEnabled,
                        FALSE
                        );
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                IWbemCallResult *pResult;

                //
                // Write the instance to the store
                //

                pResult = NULL;
                hr = m_piwsHomenet->PutInstance(
                        pwcoInstance,
                        WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                        NULL,
                        &pResult
                        );

                if (WBEM_S_NO_ERROR == hr)
                {
                    pwcoInstance->Release();
                    pwcoInstance = NULL;

                    hr = pResult->GetResultString(WBEM_INFINITE, &bstr);

                    if (WBEM_S_NO_ERROR == hr)
                    {
                        hr = GetWmiObjectFromPath(
                                m_piwsHomenet,
                                bstr,
                                &pwcoInstance
                                );

                        SysFreeString(bstr);
                    }

                    pResult->Release();
                }
            }

            if (WBEM_S_NO_ERROR == hr)
            {
                //
                // Create the object to return
                //

                CComObject<CHNetAppProtocol> *pProt;

                hr = CComObject<CHNetAppProtocol>::CreateInstance(&pProt);

                if (S_OK == hr)
                {
                    pProt->AddRef();

                    hr = pProt->Initialize(m_piwsHomenet, pwcoInstance);

                    if (S_OK == hr)
                    {
                        hr = pProt->QueryInterface(
                                IID_PPV_ARG(IHNetApplicationProtocol, ppProtocol)
                                );
                    }

                    pProt->Release();
                }
            }

            if (NULL != pwcoInstance)
            {
                pwcoInstance->Release();
            }
        }

        SafeArrayDestroy(psa);
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::EnumPortMappingProtocols(
    IEnumHNetPortMappingProtocols **ppEnum
    )

{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pwcoEnum;
    BSTR bstrClass;

    if (!ppEnum)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
    }

    if (S_OK == hr)
    {
        bstrClass = SysAllocString(c_wszHnetPortMappingProtocol);
        if (NULL == bstrClass)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        //
        // Query the WMI store for HNet_PortMappingProtocol instances.
        //

        pwcoEnum = NULL;
        hr = m_piwsHomenet->CreateInstanceEnum(
                bstrClass,
                WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL,
                &pwcoEnum
                );

        SysFreeString(bstrClass);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Create and initialize the wrapper for the enum
        //

        CComObject<CEnumHNetPortMappingProtocols> *pEnum;

        hr = CComObject<CEnumHNetPortMappingProtocols>::CreateInstance(&pEnum);
        if (SUCCEEDED(hr))
        {
            pEnum->AddRef();

            hr = pEnum->Initialize(m_piwsHomenet, pwcoEnum);

            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(
                        IID_PPV_ARG(IEnumHNetPortMappingProtocols, ppEnum)
                        );
            }

            pEnum->Release();

        }

        pwcoEnum->Release();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::CreatePortMappingProtocol(
    OLECHAR *pszwName,
    UCHAR ucIPProtocol,
    USHORT usPort,
    IHNetPortMappingProtocol **ppProtocol
    )

{
    HRESULT hr = S_OK;
    BSTR bstr;
    VARIANT vt;
    IWbemClassObject *pwcoInstance;

    if (NULL == ppProtocol)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProtocol = NULL;

        if (NULL == pszwName
                 || 0 == ucIPProtocol
                 || 0 == usPort)
        {
            hr = E_INVALIDARG;
        }
    }

    if (S_OK == hr)
    {
        //
        // Check to see if there already exists a protocol with
        // the same port/protocol combination
        //

        if (PortMappingProtocolExists(
                m_piwsHomenet,
                m_bstrWQL,
                usPort,
                ucIPProtocol
                ))
        {
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
        }

    }

    if (S_OK == hr)
    {
        hr = SpawnNewInstance(
                m_piwsHomenet,
                c_wszHnetPortMappingProtocol,
                &pwcoInstance
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        // bug 555896:  should limit the length of untrusted input string
        // to some reasonable size.  Am using INTERNET_MAX_HOST_NAME_LENGTH
        // (somewhat arbitrarily), which is 256.

        WCHAR szwName[INTERNET_MAX_HOST_NAME_LENGTH];
        StringCchCopyW (szwName, INTERNET_MAX_HOST_NAME_LENGTH, pszwName);

        V_VT(&vt) = VT_BSTR;
        V_BSTR(&vt) = SysAllocString(szwName);

        if (NULL != V_BSTR(&vt))
        {
            //
            // Write the name
            //

            hr = pwcoInstance->Put(
                    c_wszName,
                    0,
                    &vt,
                    NULL
                    );

            VariantClear(&vt);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the port
            //

            V_VT(&vt) = VT_I4;
            V_I4(&vt) = usPort;

            hr = pwcoInstance->Put(
                c_wszPort,
                0,
                &vt,
                NULL
                );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Write the IP protocol
            //

            V_VT(&vt) = VT_UI1;
            V_UI1(&vt) = ucIPProtocol;

            hr = pwcoInstance->Put(
                c_wszIPProtocol,
                0,
                &vt,
                NULL
                );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Set BuiltIn to false
            //

            hr = SetBooleanValue(
                    pwcoInstance,
                    c_wszBuiltIn,
                    FALSE
                    );
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            IWbemCallResult *pResult;

            //
            // Write the instance to the store
            //

            pResult = NULL;
            hr = m_piwsHomenet->PutInstance(
                    pwcoInstance,
                    WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                    NULL,
                    &pResult
                    );

            if (WBEM_S_NO_ERROR == hr)
            {
                pwcoInstance->Release();
                pwcoInstance = NULL;

                hr = pResult->GetResultString(WBEM_INFINITE, &bstr);

                if (WBEM_S_NO_ERROR == hr)
                {
                    hr = GetWmiObjectFromPath(
                            m_piwsHomenet,
                            bstr,
                            &pwcoInstance
                            );

                    SysFreeString(bstr);
                }

                pResult->Release();
            }
        }

        if (WBEM_S_NO_ERROR == hr)
        {
            //
            // Create the object to return
            //

            CComObject<CHNetPortMappingProtocol> *pProt;

            hr = CComObject<CHNetPortMappingProtocol>::CreateInstance(&pProt);

            if (S_OK == hr)
            {
                pProt->AddRef();

                hr = pProt->Initialize(m_piwsHomenet, pwcoInstance);

                if (S_OK == hr)
                {
                    hr = pProt->QueryInterface(
                            IID_PPV_ARG(IHNetPortMappingProtocol, ppProtocol)
                            );
                }

                pProt->Release();

            }
        }

        if (NULL != pwcoInstance)
        {
            pwcoInstance->Release();
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
         SendPortMappingListChangeNotification();
    }

    return hr;
}

STDMETHODIMP
CHNetCfgMgr::FindPortMappingProtocol(
    GUID *pGuid,
    IHNetPortMappingProtocol **ppProtocol
    )

{
    BSTR bstr;
    HRESULT hr = S_OK;
    OLECHAR *pwszGuid;
    OLECHAR wszPath[MAX_PATH];
    IWbemClassObject *pwcoInstance;

    if (NULL != ppProtocol)
    {
        *ppProtocol = NULL;
        if (NULL == pGuid)
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    if (S_OK == hr)
    {
        //
        // Convert the GUID to string form
        //

        hr = StringFromCLSID(*pGuid, &pwszGuid);
    }

    if (S_OK == hr)
    {
        //
        // Construct the path to the desired protocol
        //

        int count =
            _snwprintf(
                wszPath,
                MAX_PATH,
                L"%s.%s=\"%s\"",
                c_wszHnetPortMappingProtocol,
                c_wszId,
                pwszGuid
                );

        _ASSERT(count > 0);
        CoTaskMemFree(pwszGuid);

        bstr = SysAllocString(wszPath);
        if (NULL != bstr)
        {
            hr = GetWmiObjectFromPath(m_piwsHomenet, bstr, &pwcoInstance);
            SysFreeString(bstr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        CComObject<CHNetPortMappingProtocol> *pProtocol;
        hr = CComObject<CHNetPortMappingProtocol>::CreateInstance(&pProtocol);

        if (SUCCEEDED(hr))
        {
            pProtocol->AddRef();

            hr = pProtocol->Initialize(m_piwsHomenet, pwcoInstance);
            if (SUCCEEDED(hr))
            {
                hr = pProtocol->QueryInterface(
                        IID_PPV_ARG(IHNetPortMappingProtocol, ppProtocol)
                        );
            }

            pProtocol->Release();
        }

        pwcoInstance->Release();
    }

    return hr;
}

//
// Private methods
//

HRESULT
CHNetCfgMgr::CopyLoggingInstanceToStruct(
    IWbemClassObject *pwcoInstance,
    HNET_FW_LOGGING_SETTINGS *pfwSettings
    )

{
    HRESULT hr;
    VARIANT vt;
    BSTR bstrPath;

    _ASSERT(pwcoInstance);
    _ASSERT(pfwSettings);

    //
    // Zero-out settings structure
    //

    ZeroMemory(pfwSettings, sizeof(*pfwSettings));

    //
    // Get the Path property.
    //

    hr = pwcoInstance->Get(
            c_wszPath,
            0,
            &vt,
            NULL,
            NULL
            );

    if (WBEM_S_NO_ERROR == hr)
    {
        _ASSERT(VT_BSTR == V_VT(&vt));

        //
        // Allocate space to hold the string
        //

        pfwSettings->pszwPath =
            (LPWSTR) CoTaskMemAlloc((SysStringLen(V_BSTR(&vt)) + 1)
                                    * sizeof(OLECHAR));

        if (NULL != pfwSettings->pszwPath)
        {
            //
            // Copy string over
            //

            wcscpy(pfwSettings->pszwPath, V_BSTR(&vt));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        //
        // Free the returned BSTR
        //

        VariantClear(&vt);
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get max file size
        //

        hr = pwcoInstance->Get(
                c_wszMaxFileSize,
                0,
                &vt,
                NULL,
                NULL
                );

        if (WBEM_S_NO_ERROR == hr)
        {
            _ASSERT(VT_I4 == V_VT(&vt));

            pfwSettings->ulMaxFileSize = V_I4(&vt);
            VariantClear(&vt);
        }
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get log dropped packets value
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszLogDroppedPackets,
                &pfwSettings->fLogDroppedPackets
                );
    }

    if (WBEM_S_NO_ERROR == hr)
    {
        //
        // Get log connections value
        //

        hr = GetBooleanValue(
                pwcoInstance,
                c_wszLogConnections,
                &pfwSettings->fLogConnections
                );

    }

    if (FAILED(hr) && NULL != pfwSettings->pszwPath)
    {
        CoTaskMemFree(pfwSettings->pszwPath);
    }

    return hr;
}

HRESULT
CHNetCfgMgr::CopyStructToLoggingInstance(
    HNET_FW_LOGGING_SETTINGS *pfwSettings,
    IWbemClassObject *pwcoInstance
    )

{
    HRESULT hr = S_OK;
    VARIANT vt;

    _ASSERT(pwcoInstance);
    _ASSERT(pfwSettings);


    //
    // Wrap the path in a BSTR in a varaint
    //

    VariantInit(&vt);
    V_VT(&vt) = VT_BSTR;
    V_BSTR(&vt) = SysAllocString(pfwSettings->pszwPath);
    if (NULL == V_BSTR(&vt))
    {
        hr = E_OUTOFMEMORY;
   